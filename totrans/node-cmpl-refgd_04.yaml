- en: HTTP Servers and Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've learned about Node.js modules, it's time to put this knowledge
    to work by building a simple Node.js web application. In this chapter, we'll keep
    to a simple application, enabling us to explore three different application frameworks
    for Node.js. In later chapters, we'll build some more complex applications, but
    before we can walk, we must learn to crawl.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: EventEmitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to HTTP events and the HTTP Server object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP request routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2015 template strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple web application with no frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Express application framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express middleware functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with computationally intensive code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP Client object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple REST service with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving events with EventEmitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EventEmitters are one of the core idioms of Node.js. If Node.js's core idea
    is an event-driven architecture, emitting events from an object is one of the
    primary mechanisms of that architecture. An EventEmitter is an object that gives
    notifications—events—at different points in its life cycle. For example, an HTTP
    Server object emits events concerning each stage of the startup/shutdown of the
    Server object, and as HTTP requests are made from HTTP clients.
  prefs: []
  type: TYPE_NORMAL
- en: Many core Node.js modules are EventEmitters, and EventEmitters are an excellent
    skeleton to implement asynchronous programming. EventEmitters have nothing to
    do with web application development, but they are so much part of the Node.js
    woodwork that you may skip over their existence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll work with the HTTPServer and HTTPClient objects. Both
    are subclasses of the `EventEmitter` class, and rely on it to send events for
    each step of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript classes and class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting started on the `EventEmitter` class, we need to take a look
    at another of the ES2015 features: classes. The JavaScript language has always
    had objects, and a concept of a class hierarchy, but nothing so formal as in other
    languages. The ES2015 class object builds on the existing prototype-based inheritance
    model, but with a syntax looking very much like class definitions in other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this class we''ll be using later in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve defined the class, you can export the class definition to other
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions marked with `get` or `set` keywords are getters and setters,
    used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: New instances of a class are created with `new`. You access a getter or setter
    function as if it is a simple field on the object. Behind the scenes, the getter/setter
    function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation is not the best because the `_title` and `_body` fields are
    publicly visible, and there is no data hiding or encapsulation. We'll go over
    a better implementation later.
  prefs: []
  type: TYPE_NORMAL
- en: 'One tests whether a given object is of a certain class by using the `instanceof`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you declare a subclass using the `extends` operator, similar to what''s
    done in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the `LoveNote` class has all the fields of `Note`, plus this
    new field named `heart`.
  prefs: []
  type: TYPE_NORMAL
- en: The EventEmitter Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EventEmitter` object is defined in the events module of Node.js. Directly
    using the `EventEmitter` class means performing `require('events')`. In most cases, you'll
    be using an existing object that uses `EventEmitter` internally and you won't
    require this module. But there are cases where needs dictate implementing an `EventEmitter` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `pulser.js` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This defines a `Pulser` class, which inherits from `EventEmitter`. In older
    Node.js releases, this would require using `util.inherits`, but the new class
    object makes subclassing much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to examine is how `this.emit` in the callback function refers
    to the Pulser object. Before the ES2015 arrow function, when our callbacks used
    a regular `function`, `this` would not have referred to the `Pulser` object. Instead,
    it would have referred to some other object related to the `setInterval` function. Because
    it is an arrow function, the `this` inside the arrow function is the same `this`
    as in the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you needed to use a `function` rather than an arrow function, this trick
    would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What's different is the assignment of `this` to `self`. The value of `this`
    inside the function is different, but the value of `self` remains the same in
    every enclosed scope. This widely-used trick is less necessary now that we have
    arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a simple EventEmitter, but with your own class name, the body of
    the extended class can be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `Pulser` class is sending a timed event, once a second, to
    any listeners. The `start` method uses `setInterval` to kick off repeated callback
    execution, scheduled for every second, calling `emit` to send the `pulse` events
    to any listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to use the `Pulser` object. Create a new file, called `pulsed.js`,
    containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a `Pulser` object and consume its `pulse` events. Calling `pulser.on('pulse')`
    sets up connections for the `pulse` events to invoke the callback function. It
    then calls the `start` method to get the process going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this into a file and name the file `pulsed.js`. When you run it, you
    should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That gives you a little practical knowledge of the `EventEmitter` class. Let's
    now look at its operational theory.
  prefs: []
  type: TYPE_NORMAL
- en: The EventEmitter theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `EventEmitter` class, your code emits events that other code can receive.
    It's a way of connecting two separated sections of your program, kind of like
    how quantum entanglement means two electrons can communicate with each other from
    any distance. Seems simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: The event name can be anything that makes sense to you, and you can define as
    many event names as you like. Event names are defined simply by calling `.emit`
    with the event name. There's nothing formal to do and no registry of event names.
    Simply making a call to `.emit` is enough to define an event name.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, the event name `error` indicates errors.
  prefs: []
  type: TYPE_NORMAL
- en: An object sends events using the `.emit` function. Events are sent to any listeners
    that have registered to receive events from the object. The program registers
    to receive an event by calling that object's `.on` method, giving the event name
    and an event handler function.
  prefs: []
  type: TYPE_NORMAL
- en: There is no central distribution point for all events. Instead, each instance
    of an `EventEmitter` object manages its own set of listeners and distributes its
    events to those listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, it is required to send data along with an event. To do so, simply add
    the data as arguments to the `.emit` call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program receives that event, the data appears as arguments to the
    callback function. Your program would listen to such an event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is no handshaking between event receivers and the event sender. That is,
    the event sender simply goes on with its business, and it gets no notifications
    about any events received, any action taken, or any error that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used another of the ES2015 features, the `rest` operator,
    shown here as `...theArgs.` The *rest* operator catches any number of remaining
    function parameters into an array. Since `EventEmitter` can pass along any number
    of parameters, and the `rest` operator can automatically receive any number of
    parameters, it's a match made in heaven, or else in the TC-39 committee.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP server object is the foundation of all Node.js web applications. The
    object itself is very close to the HTTP protocol, and its use requires knowledge
    of that protocol. In most cases, you'll be able to use an application framework
    such as Express that hides the HTTP protocol details, allowing the programmer
    to focus on business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw a simple HTTP server application in Chapter 2, *Setting up Node.js*,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `http.createServer` function creates an `http.Server` object. Because it
    is an `EventEmitter`, this can be written in another way to make that fact explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `request` event takes a function, which receives `request` and `response`
    objects. The `request` object has data from the web browser, while the `response`
    object is used to gather the data to be sent in the response. The `listen` function
    causes the server to start listening and arranging to dispatch an event for every
    request arriving from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at something more interesting with different actions based on
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, named `server.js`, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To run it, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This application is meant to be similar to PHP''s `sysinfo` function. Node''s
    `os` module is consulted to provide information about the server. This example
    can easily be extended to gather other pieces of data about the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21c31140-b897-4230-b82b-efc3757960f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A central part of any web application is the method of routing requests to
    request handlers. The `request` object has several pieces of data attached to
    it, two of which are useful for routing requests: the `request.url` and `request.method`
    fields.'
  prefs: []
  type: TYPE_NORMAL
- en: In `server.js`, we consult the `request.url` data to determine which page to
    show, after parsing (using `url.parse`) to ease the digestion process. In this
    case, we can do a simple comparison of the `pathname` to determine which handler
    method to use.
  prefs: []
  type: TYPE_NORMAL
- en: Some web applications care about the HTTP verb (`GET`, `DELETE`, `POST`, and
    so on) used and must consult the `request.method` field of the `request` object.
    For example, `POST` is frequently used for `FORM` submissions.
  prefs: []
  type: TYPE_NORMAL
- en: The `pathname` portion of the request URL is used to dispatch the request to
    the correct handler. While this routing method, based on simple string comparison,
    will work for a small application, it'll quickly become unwieldy. Larger applications
    will use pattern matching to use part of the request URL to select the request
    handler function and other parts to extract request data out of the URL. We'll
    see this in action while looking at Express later in the *Getting started with
    Express* section.
  prefs: []
  type: TYPE_NORMAL
- en: A search for a URL match in the npm repository turns up several promising packages
    that could be used to implement request matching and routing. A framework like
    Express has this capability already baked in and tested.
  prefs: []
  type: TYPE_NORMAL
- en: If the request URL is not recognized, the server sends back an error page using
    a `404` result code. The result code informs the browser about the status of the
    request, where a `200` code means everything is fine, and a `404` code means the
    requested page doesn't exist. There are, of course, many other HTTP response codes,
    each with their own meaning.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 multiline and template strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example showed two of the new features introduced with ES2015,
    multiline and template strings. The feature is meant to simplify our life while
    creating text strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing string representations use single quotes and double quotes. Template
    strings are delimited with the backtick character that''s also known as the **grave
    accent**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Before ES2015, one way to implement a multiline string was this construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, that was the code used in the same example in previous versions of this
    book. This is what we can do with ES2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is more succinct and straightforward. The opening quote is on the first
    line, the closing quote on the last line, and everything in between is part of
    our string.
  prefs: []
  type: TYPE_NORMAL
- en: The real purpose of the template strings feature is supporting strings where
    we can easily substitute values directly into the string. Most other programming
    languages support this ability, and now JavaScript does too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-ES2015, a programmer could have written code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is extracted from the same example in previous versions of this
    book. With template strings, this can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Within a template string, the part within the `${ .. }` brackets is interpreted
    as an expression. It can be a simple mathematical expression, a variable reference,
    or, as in this case, a function call.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to mention is a matter of indentation. In normal coding, one
    indents a long argument list to the same level as the containing function call.
    But, for these multiline string examples, the text content is flush with column
    zero. What's up?
  prefs: []
  type: TYPE_NORMAL
- en: 'This may impede the readability of your code, so it''s worth weighing code
    readability against another issue: excess characters in the HTML output. The blanks
    we would use to indent the code for readability will become part of the string
    and will be output in the HTML. By making the code flush with column zero, we
    don''t add excess blanks to the output at the cost of some code readability.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach also carries a security risk. Have you verified the data is safe?
    That it will not form the basis of a security attack? In this case, we're dealing
    with simple strings and numbers coming from a safe data source.  Therefore this
    code is as safe as the Node.js runtime. What about user-supplied content, and
    the risk that a nefarious user might supply insecure content implanting some kind
    of malware into target computers?
  prefs: []
  type: TYPE_NORMAL
- en: For this and many other reasons, it is often safer to use an external template
    engine. Applications like Express make it easy to do so.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Sniffer – listening to the HTTP conversation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The events emitted by the HTTPServer object can be used for additional purposes
    beyond the immediate task of delivering a web application. The following code
    demonstrates a useful module that listens to all the HTTP Server events. It could
    be a useful debugging tool, which also demonstrates how HTTP server objects operate.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js's HTTP Server object is an `EventEmitter` and the HTTP Sniffer simply
    listens to every server event, printing out information pertinent to each event.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re about to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a module, `httpsniffer`, that prints information about HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add that module to the `server.js` script we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun that server to view a trace of HTTP activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `httpsniffer.js` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That was a lot of code! But the key to it is the `sniffOn` function. When given
    an HTTP Server object, it uses the `.on` function to attach listener functions
    that print data about each emitted event. It gives a fairly detailed trace of
    HTTP traffic on an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use it, simply insert this code just before the `listen` function
    in `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, run the server as we did earlier. You can visit `http://localhost:8124/`
    in your browser and see the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You now have a tool for snooping on HTTPServer events. This simple technique
    prints a detailed log of event data. The pattern can be used for any `EventEmitter`
    object. You can use this technique as a way to inspect the actual behavior of
    `EventEmitter` objects in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Web application frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTPServer object is very close to the HTTP protocol. While this is powerful
    in the same way that driving a stick shift car gives you low-level control over
    the driving experience, typical web application programming is better done at
    a higher level. Does anybody use assembly language to write web applications?
    It's better to abstract away the HTTP details and concentrate on your application.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js developer community has developed quite a few application frameworks
    to help with different aspects of abstracting away HTTP protocol details. Of them,
    Express is the most popular, and Koa ([http://koajs.com/](http://koajs.com/))
    should be considered because it was developed by the same team and has fully integrated
    support for `async` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The ExpressJS Wiki has a list of frameworks built on top of ExpressJS, or tools
    that work with it. This includes template engines, middleware modules, and more.
    The ExpressJS Wiki is located at [https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason to use a web framework is that they often provide the best practices
    used in web application development for over 20 years. The usual best practices
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing a page for bad URLs (the 404 page)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screening URLs and forms for any injected scripting attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting the use of cookies to maintain sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging requests for both usage tracking and debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling static files, such as images, CSS, JavaScript, or HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing cache control headers to caching proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting things such as page size or execution time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web frameworks help you invest your time in the task without getting lost in
    the details of implementing HTTP protocol. Abstracting away details is a time-honored
    way for programmers to be more efficient. This is especially true when using a
    library or framework providing prepackaged functions that take care of the details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is perhaps the most popular Node.js web app framework. It's so popular
    that it's part of the MEAN Stack acronym. MEAN refers to MongoDB, ExpressJS, AngularJS,
    and Node.js. Express is described as being Sinatra-like, referring to a popular
    Ruby application framework, and that it isn't an opinionated framework, meaning
    the framework authors don't impose their opinions about structuring an application.
    This means Express is not at all strict about how your code is structured; you
    just write it the way you think is best.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the home page for Express at [http://expressjs.com/](http://expressjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Shortly, we'll implement a simple application to calculate Fibonacci numbers
    using Express, and in later chapters, we'll do quite a bit more with Express.
    We'll also explore how to mitigate the performance problems from computationally
    intensive code we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: As of writing this book, Express 4.16 is the current version, and Express 5
    is in Alpha testing. According to the ExpressJS website, there are very few differences
    between Express 4 and Express 5.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by installing the express-generator. While we can just start writing
    some code, the express-generator provides a blank starting application. We'll
    take that and modify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is different from the suggested installation method on the Express website,
    which was to use the `-g` tag for a global install. We're also using an explicit
    version number to ensure compatibility. As of writing this book, `express-generator@5.x`
    does not exist. When it does exist, one should be able to use the 5.x version
    with the following instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we discussed how many now recommend against installing modules globally.
    In the Twelve-Factor model, it's strongly recommended to not install global dependencies,
    and that's what we're doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is that an `express` command is installed in the `./node_modules/.bin`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `express` command like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We probably don't want to type `./node_modules/.bin/express` every time we run
    the `express-generator` application or, for that matter, any of the other applications
    that provide command-line utilities. Refer back to the discussion in Chapter 3,* Node.js
    Modules* about adding that directory to the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve installed `express-generator` in the `fibonacci` directory,
    use it to set up the blank framework application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This created a bunch of files for us, which we'll walk through in a minute.
    The `node_modules` directory still has the `express-generator` module, which is
    now not useful. We can just leave it there and ignore it, or we can add it to
    the `devDependencies` of the `package.json` it generated. Alternatively, we can
    uninstall it as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is run the blank application in the way we''re told. The
    command shown, `npm start`, relies on a section of the supplied `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `npm` tool supports scripts that are ways to automate various tasks. We'll
    use this capability throughout the book to do various things. When the Twelve-Factor
    Application model suggests automating all your administrative tasks, the `npm`
    scripts feature is an excellent mechanism to do so. Most `npm` scripts are run
    with the `npm run scriptName` command, but the `start` command is explicitly recognized
    by `npm` and can be run as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the dependencies `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application using `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally modify `package.json` to always run with debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install the dependencies, and run the application, type these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `DEBUG` variable this way turns on some debugging output, which
    includes this message about listening on port 3000\. Otherwise, we aren't told
    this information. This syntax is what's used in the Bash shell to run a command
    with an environment variable.  If you get an error try running just "`npm start`"
    then read the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the supplied `npm start` script to always run the app with debugging
    enabled. Change the `scripts` section to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since the output says it is listening on port `3000`, we direct our browser
    to
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3000/` and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95ceee18-cfe6-44b2-9766-c13520701f24.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting environment variables in Windows cmd.exe command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're on Windows the previous example may have failed with an error that
    DEBUG is not a known command.  The problem is that the Windows shell, the `cmd.exe`
    program, does not support the Bash command-line structure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `VARIABLE=value` at the beginning of a command-line is specific to some
    shells, like Bash, on Linux and macOS.  It sets that environment variable only
    for the command-line being executed, and is a very convenient way to temporarily
    override environment variables for a specific command.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly a solution is required if your `package.json` is to be usable across
    different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best solution appears to be the `cross-env` package in the npm repository,
    see: [https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env) 
    With this package installed, commands in the `scripts` section in `package.json` can
    set environment variables just as in Bash on Linux/macOS.  The usage looks like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the command is executed as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Walking through the default Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a working, blank Express application; let's look at what was generated
    for us. We're doing this to familiarize ourselves with Express before diving in
    to start coding our `Fibonacci` application.
  prefs: []
  type: TYPE_NORMAL
- en: Because we used the `--view=hbs` option, this application is set up to use the
    `Handlebars.js` template engine. Handlebars was built on top of Mustache, and
    was originally designed for use in the browser; for more information see its homepage
    at [http://handlebarsjs.com/](http://handlebarsjs.com/). The version shown here
    has been packaged for use with Express, and is documented at [https://github.com/pillarjs/hbs](https://github.com/pillarjs/hbs).
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, a template engine makes it possible to insert data into
    generated web pages. The ExpressJS Wiki has a list of template engines for Express [https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines).
  prefs: []
  type: TYPE_NORMAL
- en: The `views` directory contains two files, `error.hbs` and `index.hbs`. The `hbs`
    extension is used for Handlebars files. Another file, `layout.hbs`, is the default
    page layout. Handlebars has several ways to configure layout templates and even
    partials (snippets of code which can be included anywhere).
  prefs: []
  type: TYPE_NORMAL
- en: The `routes` directory contains the initial routing setup, that is, the code
    to handle specific URLs. We'll modify these later.
  prefs: []
  type: TYPE_NORMAL
- en: The `public` directory will contain assets that the application doesn't generate,
    but are simply sent to the browser. What's initially installed is a CSS file,
    `public/stylesheets/style.css`.
  prefs: []
  type: TYPE_NORMAL
- en: The `package.json` file contains our dependencies and other metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The `bin` directory contains the `www` script that we saw earlier. That's a
    Node.js script, which initializes the HTTPServer objects, starts it listening
    on a TCP port, and calls the last file we'll discuss, `app.js`. These scripts
    initialize Express, hook up the routing modules, and do other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot going on in the `www` and `app.js` scripts, so let''s start
    with the application initialization. Let''s first take a look at a couple of lines
    in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This means that `app.js` is a module that exports the object returned by the
    `express` module. It doesn't start the HTTP server object, however.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s turn to the `www` script. The first thing to see is that it starts
    with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a Unix/Linux technique to make a command script. It says to run the
    following as a script using the `node` command. In other words, we have Node.js
    code and we''re instructing the operating system to execute that code using the
    Node.js runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can also see that the script was made executable by `express-generator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It calls the `app.js` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We see where port `3000` comes from; it''s a parameter to the `normalizePort`
    function. We also see that setting the `PORT` environment variable will override
    the default port `3000`. And finally, we see that the HTTP Server object is created
    here, and is told to use the application instance created in `app.js`. Try running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The application now tells you that it's listening on port `4242`, where you
    can ponder the meaning of life.
  prefs: []
  type: TYPE_NORMAL
- en: The `app` object is next passed to `http.createServer()`. A look in the Node.js
    documentation tells us this function takes a `requestListener`, which is simply
    a function that takes the `request` and `response` objects we've seen previously.
    Therefore, the `app` object is such a function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `www` script starts the server listening on the port we specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now walk through `app.js` in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This tells Express to look for templates in the `views` directory and to use
    the EJS templating engine.
  prefs: []
  type: TYPE_NORMAL
- en: The `app.set` function is used for setting application properties. It'll be
    useful to browse the API documentation as we go through ([http://expressjs.com/en/4x/api.html](http://expressjs.com/en/4x/api.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is a series of `app.use` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `app.use` function mounts middleware functions. This is an important piece
    of Express jargon we will discuss shortly. At the moment, let''s say that middleware
    functions are executed during the processing of routes. This means all the features
    named here are enabled in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is enabled using the Morgan request logger. Visit [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)
    for its documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `body-parser` module handles parsing HTTP request bodies. Visit [https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)
    for its documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cookie-parser` module is used to parse HTTP cookies. Visit [https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)
    for its documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static file web server is configured to serve the asset files in the `public`
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two router modules, `routes` and `users`, to set up which functions handle which
    URLs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Express middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s round out the walkthrough of `app.js` by discussing what middleware
    functions do for our application. We have an example at the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The comment says *catch 404 and forward to error handler*. As you probably know,
    an HTTP 404 status means the requested resource was not found. We need to tell
    the user their request wasn't satisfied, and maybe show them a picture of a flock
    of birds pulling a whale out of the ocean. This is the first step in doing so.
    Before getting to the last step of reporting this error, you must learn how middleware
    works.
  prefs: []
  type: TYPE_NORMAL
- en: We do have a middleware function right in front of us. Refer to its documentation
    at [http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html).
  prefs: []
  type: TYPE_NORMAL
- en: Middleware functions take three arguments. The first two, `request` and `response`,
    are equivalent to the `request` and `response` of the Node.js HTTP request object.
    However, Express expands the objects with additional data and capabilities. The
    last, `next`, is a callback function controlling when the request-response cycle
    ends, and it can be used to send errors down the middleware pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The incoming request gets handled by the first middleware function, then the
    next, then the next, and so on. Each time the request is to be passed down the
    chain of middleware functions, the `next` function is called. If `next` is called
    with an error object, as shown here, an error is being signaled. Otherwise, the
    control simply passes to the next middleware function in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if `next` is not called? The HTTP request will hang because no
    response has been given. A middleware function gives a response when it calls
    functions on the `response` object, such as `res.send` or `res.render`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the inclusion of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This does not call `next`, but instead calls `res.send`. This is the correct
    method of ending the request-response cycle, by sending a response (`res.send`)
    to the request. If neither `next` nor `res.send` is called, the request never
    gets a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, a middleware function does one of the following four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Executes its own business logic. The request logger middleware shown earlier
    is an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies the request or response objects. Both the `body-parser` and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookie-parser` do so, looking for data to add to the `request` object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calls `next` to proceed to the next middleware function or else signals an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends a response, ending the cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordering of middleware execution depends on the order they're added to the
    `app` object. The first added is executed first, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware and request paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen two kinds of middleware functions so far. In one, the first argument
    is the handler function. In the other, the first argument is a string containing
    a URL snippet, and the second argument is the handler function.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s actually going on is `app.use` has an optional first argument: the
    path the middleware is mounted on. The path is a pattern match against the request
    URL, and the given function is triggered if the URL matches the pattern. There''s
    even a method to supply named parameters in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This path specification has a pattern, `:id`, and the value will land in `req.params.id`.
    In this example, we're suggesting a user profiles service, and that for this URL
    we want to display information about the named user.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to use a middleware function is on a specific HTTP request method.
    With `app.use`, any request will be matched, but in truth, `GET` requests are
    supposed to behave differently to `POST` requests. You call `app.METHOD` where
    `METHOD` matches one of the HTTP request verbs. That is, `app.get` matches the
    `GET` method, `app.post` matches `POST`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the `router` object. This is a kind of middleware used explicitly
    for routing requests based on their URL. Take a look at `routes/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have a module whose `exports` object is a router. This router has only one
    route, but it can have any number of routes you think is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `app.js`, this is added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All the functions we discussed for the `app` object apply to the `router` object.
    If the request matches, the router is given the request for its own chain of processing
    functions. An important detail is that the request URL prefix is stripped when
    the request is passed to the router instance.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the `router.get` in `users.js` matches `'/'` and that this
    router is mounted on `'/users'`. In effect, that `router.get` matches `/users`
    as well, but because the prefix was stripped, it specifies `'/'` instead. This
    means a router can be mounted on different path prefixes without having to change
    the router implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can finally get back to the generated `app.js`, the 404 Error page not
    found, and any other errors the application might want to show to the user.
  prefs: []
  type: TYPE_NORMAL
- en: A middleware function indicates an error by passing a value to the `next` function
    call. Once Express sees an error, it will skip any remaining non-error routing,
    and it will only pass it to error handlers instead. An error handler function
    has a different signature than what we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js`, which we''re examining, this is our error handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Error handler functions take four parameters, with `err` added to the familiar
    `req`, `res`, and `next`. For this handler, we use `res.status` to set the HTTP
    response status code, and we use `res.render` to format an HTML response using
    the `views/error.hbs` template. The `res.render` function takes data, rendering
    it with a template to produce HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This means any error in our application will land here, bypassing any remaining
    middleware functions.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Fibonacci sequence with an Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fibonacci numbers are the integer sequence: *0, 1, 1, 2, 3, 5, 8, 13, 21,
    34, ...*'
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in the list is the sum of the previous two entries in the list. The
    sequence was invented in 1202 by Leonardo of Pisa, who was also known as Fibonacci.
    One method to calculate entries in the Fibonacci sequence is the recursive algorithm
    we showed earlier. We will create an Express application that uses the Fibonacci
    implementation and then explore several methods to mitigate performance problems
    in computationally intensive algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the blank application we created in the previous step. We had
    you name that application *Fibonacci* for a reason. We were thinking ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js`, make the following changes to the top portion of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Most of this is what `express-generator` gave us. The `var` statements have
    been changed to `const`, for that little teensy bit of extra comfort. We explicitly
    imported the `hbs` module so we could do some configuration. And we imported a
    router module for Fibonacci, which we'll see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Fibonacci` application, we don't need to support users, and therefore
    deleted that routing module.  The `fibonacci` module, which we'll show next, serves
    to query a number for which we'll calculate the Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-level directory, create a file, `math.js`, containing this extremely
    simplistic Fibonacci implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `views` directory, look at the file named `layout.hbs` which `express-generator`
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This file contains the structure we'll use for HTML pages. Going by the Handlebars
    syntax, we see that `{{title}}` appears within the HTML `title` tag. It means
    when we call `res.render`, we should supply a `title` attribute. The `{{{body}}}`
    tag is where the view template content lands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `views/index.hbs` to just contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This serves as the front page of our application. It will be inserted in place
    of `{{{body}}}` in `layout.hbs`. The marker, `{{> navbar}}`, refers to a partial
    named `navbar`. Earlier, we configured a directory named `partials` to hold partials.
    Now let''s create a file, `partials/navbar.html`, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will serve as a navigation bar that's included on every page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file, `views/fibonacci.hbs`, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the files in `views` are templates into which data is rendered.
    They serve the View aspect of the **Model-View-Controller** (**MVC**) paradigm,
    hence the directory name.
  prefs: []
  type: TYPE_NORMAL
- en: In the `routes` directory, delete the `user.js` module. It is generated by the
    Express framework, but we will not use it in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/index.js`, change the router function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous object passed to `res.render` contains the data values we provide
    to the layout and view templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, finally, in the `routes` directory, create a file named `fibonacci.js`
    containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `package.json` is already set up so we can use `npm start` to run the script
    and always have debugging messages enabled. And now we''re ready to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As it suggests, you can visit `http://localhost:3000/` and see what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaa7f981-70a5-4eed-8d6f-766670e06c67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This page is rendered from the `views/index.hbs` template. Simply click on
    the Fibonacci''s link to go to the next page, which is of course rendered from
    the `views/fibonacci.hbs` template. On that page, you''ll be able to enter a number,
    click on the Submit button, and get an answer (hint: pick a number below `40`
    if you want your answer in a reasonable amount of time):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c358759e-47e0-4436-8932-df9af39f49dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's walk through the application to discuss how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two routes in `app.js`: the route for `/`, which is handled by `routes/index.js`,
    and the route for `/fibonacci`, which is handled by `routes/fibonacci.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `res.render` function renders the named template using the provided data
    values and emits the result as an HTTP response. For the home page of this application,
    the rendering code (`routes/index.js`) and template (`views/index.hbs`) aren't
    much, and it is on the Fibonacci page where all the action is happening.
  prefs: []
  type: TYPE_NORMAL
- en: The `views/fibonacci.hbs` template contains a form in which the user enters
    a number. Because it is a `GET` form, when the user clicks on the Submit button,
    the browser will issue an HTTP `GET` on the `/fibonacci` URL. What distinguishes
    one `GET` on `/fibonacci` from another is whether the URL contains a query parameter
    named `fibonum`. When the user first enters the page, there is no `fibonum` and
    hence nothing to calculate. After the user has entered a number and clicked on
    Submit, there is a `fibonum` and something to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: Express automatically parses the query parameters, making them available as `req.query`.
    That means `routes/fibonacci.js` can quickly check whether there is a `fibonum`.
    If there is, it calls the `fibonacci` function to calculate the value.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we asked you to enter a number less than `40`. Go ahead and enter a
    larger number, such as `50`, but go take a coffee break because this is going
    to take a while to calculate. Or proceed on to reading the next section where
    we start to discuss use of computationally intensive code.
  prefs: []
  type: TYPE_NORMAL
- en: Computationally intensive code and the Node.js event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Fibonacci example is purposely inefficient to demonstrate an important
    consideration for your applications. What happens to the Node.js event loop when
    running long computations? To see the effect, open two browser windows, each opened
    to the Fibonacci page. In one, enter the number `55` or greater, and in the other,
    enter `10`. Note that the second window freezes, and if you leave it running long
    enough, the answer will eventually pop up in both windows. What's happening is
    the Node.js event loop is blocked from processing events because the Fibonacci
    algorithm is running and does not ever yield to the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Since Node.js has a single execution thread, processing requests depend on request
    handlers quickly returning to the event loop. Normally, the asynchronous coding
    style ensures that the event loop executes regularly.
  prefs: []
  type: TYPE_NORMAL
- en: This is true even for requests that load data from a server halfway around the
    globe, because the asynchronous I/O is non-blocking and control is quickly returned
    to the event loop. The naïve Fibonacci function we chose doesn't fit into this
    model because it's a long-running blocking operation. This type of event handler
    prevents the system from processing requests and stops Node.js from doing what
    it's meant to do, namely to be a blisteringly fast web server.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the long-response-time problem is obvious. Response time quickly
    escalates to the point where you can take a vacation to Tibet and perhaps get
    reincarnated as a llama in Peru during the time it takes to respond with the Fibonacci
    number!
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this more clearly, create a file named `fibotimes.js` containing the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run it. You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This quickly calculates the first 40 or so members of the Fibonacci sequence,
    but after the 40th member, it starts taking a couple of seconds per result and
    quickly degrades from there. It is untenable to execute code of this sort on a
    single-threaded system that relies on a quick return to the event loop. A web
    service containing such code would give poor performance to the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two general ways to solve this problem in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithmic refactoring**: Perhaps, like the Fibonacci function we chose,
    one of your algorithms is suboptimal and can be rewritten to be faster. Or, if
    not faster, it can be split into callbacks dispatched through the event loop.
    We''ll look at one such method in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a backend service**: Can you imagine a backend server dedicated
    to calculating Fibonacci numbers? Okay, maybe not, but it''s quite common to implement
    backend servers to offload work from frontend servers, and we will implement a
    backend Fibonacci server at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithmic refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prove that we have an artificial problem on our hands, here is a much more
    efficient `Fibonacci` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If we substitute a call to `math.fibonacciLoop` in place of `math.fibonacci`,
    the `fibotimes` program runs much faster. Even this isn't the most efficient implementation;
    for example, a simple prewired lookup table is much faster at the cost of some
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `fibotimes.js` as follows and rerun the script. The numbers will fly by
    so fast your head will spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Some algorithms aren't so simple to optimize and still take a long time to calculate
    the result. In this section, we're exploring how to handle inefficient algorithms,
    and therefore will stick with the inefficient Fibonacci implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to divide the calculation into chunks and then dispatch the
    computation of those chunks through the event loop. Add the following code to
    `math.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This converts the `fibonacci` function from asynchronous function to a traditional
    callback-oriented asynchronous function. We're using `setImmediate` at each stage
    of the calculation to ensure the event loop executes regularly and that the server
    can easily handle other requests while churning away on a calculation. It does
    nothing to reduce the computation required; this is still the silly, inefficient
    Fibonacci algorithm. All we've done is spread the computation through the event
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `fibotimes.js`, we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This version of `fibotimes.js` executes the same, we simply type `node fibotimes`. 
    However, using `fibonacciAsync` will require changes in the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it''s an asynchronous function, we will need to change our router code.
    Create a new file, named `routes/fibonacci-async1.js`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as earlier, just rewritten for an asynchronous Fibonacci calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js`, make this change to the application wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the server no longer freezes when calculating a large Fibonacci
    number. The calculation of course still takes a long time, but at least other
    users of the application aren't blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify this by again opening two browser windows in the application.
    Enter 60 in one window, and in the other start requesting smaller Fibonacci numbers.
    Unlike with the original `fibonacci` function, using `fibonacciAsync` allows both
    windows to give answers, though if you really did enter 60 in the first window
    you might as well take that three-month vacation to Tibet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec067649-82e1-43c2-8987-b932f0255f23.png)'
  prefs: []
  type: TYPE_IMG
- en: It's up to you, and your specific algorithms, to choose how to best optimize
    your code and to handle any long-running computations you may have.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP Client requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next way to mitigate computationally intensive code is to push the calculation
    to a backend process. To explore that strategy, we'll request computations from
    a backend Fibonacci server, using the HTTP Client object to do so. However, before we
    look at that, let's first talk in general about using the HTTP Client object.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js includes an HTTP Client object, useful for making HTTP requests. It
    has the capability to issue any kind of HTTP request. In this section, we'll use
    the HTTP Client object to make HTTP requests similar to calling a **Representational
    State Transfer** (**REST**) web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some code inspired by the `wget` or `curl` commands to make
    HTTP requests and show the results. Create a file named `wget.js` containing this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s more in the printout, namely the HTML of the page at `http://example.com/`.
    The purpose of `wget.js` is to make an HTTP request and show you voluminous details
    of the response. An HTTP request is initiated with the `http.request` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `options` object describes the request to make, and the `callback` function
    is called when the response arrives. The `options` object is fairly straightforward,
    with the `host`, `port`, and `path` fields specifying the URL being requested.
    The `method` field must be one of the HTTP verbs (`GET`, `PUT`, `POST`, and so
    on). You can also provide a `headers` array for the headers in the HTTP request.
    For example, you might need to provide a cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `response` object is itself an `EventEmitter`, which emits the `data` and
    `error` events. The `data` event is called as data arrives, and the `error` event
    is, of course, called on errors.
  prefs: []
  type: TYPE_NORMAL
- en: The request object is a `WritableStream`, which is useful for HTTP requests
    containing data, such as `PUT` or `POST`. This means the `request` object has
    a `write` function that writes data to the requester. The data format in an HTTP
    request is specified by the standard **Multipurpose Internet Mail Extensions** (**MIME**)
    originally created to give us better email. Around 1992, the WWW community worked
    with the MIME standard committee which was developing a format for multi-part,
    multi-media-rich electronic mail. Receiving fancy-looking email is so commonplace
    today that one might not be aware that email used to be plain text. MIME-types
    were developed to describe the format of each piece of data, and the WWW community
    adopted this for use on the web. HTML forms will post with a Content-Type of `multipart/form-data`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a REST backend service from an Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how to make HTTP client requests, we can look at how to
    make a REST query inside an Express web application. What that effectively means
    is to make an HTTP `GET` request to a backend server, which responds with the
    Fibonacci number represented by the URL. To do so, we'll refactor the `Fibonacci`
    application to make a Fibonacci server that is called from the application. While
    this is overkill for calculating Fibonacci numbers, it lets us look at the basics
    of implementing a multitier application stack in Express.
  prefs: []
  type: TYPE_NORMAL
- en: Inherently, calling a REST service is an asynchronous operation. That means
    calling the REST service will involve a function call to initiate the request
    and a callback function to receive the response. REST services are accessed over
    HTTP, so we'll use the HTTP client object to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple REST server with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Express has a powerful templating system, making it suitable for delivering
    HTML web pages to browsers, it can also be used to implement a simple REST service.
    The parameterized URLs we showed earlier (`/user/profile/:id`) can act like parameters
    to a REST call. And Express makes it easy to return data encoded in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file named `fiboserver.js` containing this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is a stripped-down Express application that gets right to the point of
    providing a Fibonacci calculation service. The one route it supports handles the
    Fibonacci computation using the same functions we've already worked with.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time we've seen `res.send` used. It's a flexible way to send
    responses which can take an array of header values (for the HTTP response header),
    and an HTTP status code. As used here, it automatically detects the object, formats
    it as JSON text, and sends it with the correct `Content-Type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `package.json`, add this to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This automates launching our Fibonacci service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we''re specifying the TCP/IP port via an environment variable and
    using that variable in the application. This is another aspect of the Twelve-Factor
    application model: to put configuration data in the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in a separate command window, we can use the `curl` program to make some
    requests against this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Over in the window where the service is running, we''ll see a log of `GET`
    requests and how long each took to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a simple client program, `fiboclient.js`, to programmatically
    call the Fibonacci service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `package.json`, add this to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the *client* app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We're building our way toward adding the REST service to the web application.
    At this point, we've proved several things, one of which is the ability to call
    a REST service in our program.
  prefs: []
  type: TYPE_NORMAL
- en: We also inadvertently demonstrated an issue with long-running calculations.
    You'll notice the requests were made from the largest to the smallest, but the
    results appeared in a very different order. Why? It's because of the processing
    time for each request, and the inefficient algorithm we're using. The computation
    time increases enough to ensure that the larger request values require enough
    processing time to reverse the order.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that `fiboclient.js` sends all its requests right away, and
    then each one waits for the response to arrive. Because the server is using `fibonacciAsync`,
    it will work on calculating all responses simultaneously. The values that are
    quickest to calculate are the ones that will be ready first. As the responses
    arrive in the client, the matching response handler fires, and in this case, the
    result prints to the console. The results will arrive when they're ready and not
    a millisecond sooner.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Fibonacci application for REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve implemented a REST-based server, we can return to the `Fibonacci`
    application, applying what we''ve learned to improve it. We will lift some of
    the code from `fiboclient.js` and transplant it into the application to do this.
    Create a new file, `routes/fibonacci-rest.js`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In `app.js`, make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `package.json`, change the `scripts` entry to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How can we have the same value for `SERVERPORT` for all three `scripts` entries? 
    The answer is that the variable is used differently in different places. In `startrest`,
    that variable is used in `routes/fibonacci-rest.js` to know at which port the
    REST service is running. Likewise, in `client`, `fiboclient.js` uses that variable
    for the same purpose. Finally, in `server`, the `fiboserver.js` script uses the
    `SERVERPORT` variable to know which port to listen on.
  prefs: []
  type: TYPE_NORMAL
- en: In `start` and `startrest`, no value is given for `PORT`. In both cases, `bin/www`
    defaults to `PORT=3000` if it is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one command window, start the backend server, and in the other, start the
    application. Open a browser window as before, and make a few requests. You should
    see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output like this for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Because we haven't changed the templates, the screen will look exactly as it
    did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may run into another problem with this solution. The asynchronous implementation
    of our inefficient Fibonacci algorithm may cause the Fibonacci service process
    to run out of memory. In the Node.js FAQ, [https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ),
    it''s suggested to use the `--max_old_space_size` flag. You''d add this in `package.json`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: However, the FAQ also says that if you're running into maximum memory space
    problems, your application should probably be refactored. This gets back to our
    point several pages ago that there are several approaches to addressing performance
    problems, one of which is the algorithmic refactoring of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Why go to the trouble of developing this REST server when we could just directly
    use `fibonacciAsync`?
  prefs: []
  type: TYPE_NORMAL
- en: We can now push the CPU load for this heavyweight calculation to a separate
    server. Doing so would preserve CPU capacity on the frontend server so it can
    attend to web browsers. GPU co-processors are now widely used for numerical computing
    and can be accessed via a simple network API. The heavy computation can be kept
    separate, and you can even deploy a cluster of backend servers sitting behind
    a load balancer, evenly distributing requests.
  prefs: []
  type: TYPE_NORMAL
- en: What we've demonstrated is that it's possible to implement simple multitier
    REST services in a few lines of Node.js and Express.
  prefs: []
  type: TYPE_NORMAL
- en: Some RESTful modules and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few available packages and frameworks to assist your REST-based
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Restify ([>http://restify.com/](http://restify.com/)): This offers both client-side
    and server-side frameworks for both ends of REST transactions. The server-side
    API is similar to Express.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loopback ([http://loopback.io/](http://loopback.io/)): This is an offering
    from StrongLoop, the current sponsor of the Express project. It offers a lot of
    features and is, of course, built on top of Express.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about Node's HTTP support, implementing web
    applications, and REST service implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can move on to implementing a more complete application: one for taking
    notes. We will use the Notes application for several upcoming chapters as a vehicle
    to explore the Express application framework, database access, deployment to cloud
    services or on your own server, and user authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build the basic infrastructure.
  prefs: []
  type: TYPE_NORMAL
