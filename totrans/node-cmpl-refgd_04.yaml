- en: HTTP Servers and Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器和客户端
- en: Now that you've learned about Node.js modules, it's time to put this knowledge
    to work by building a simple Node.js web application. In this chapter, we'll keep
    to a simple application, enabling us to explore three different application frameworks
    for Node.js. In later chapters, we'll build some more complex applications, but
    before we can walk, we must learn to crawl.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Node.js模块，是时候通过构建一个简单的Node.js Web应用来应用这些知识了。在本章中，我们将保持应用简单，这样我们就可以探索Node.js的三个不同应用框架。在后面的章节中，我们将构建一些更复杂的应用，但在我们能够行走之前，我们必须学会爬行。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: EventEmitters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发射器
- en: Listening to HTTP events and the HTTP Server object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听HTTP事件和HTTP服务器对象
- en: HTTP request routing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求路由
- en: ES2015 template strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015模板字符串
- en: Building a simple web application with no frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无框架构建简单的Web应用
- en: The Express application framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express应用框架
- en: Express middleware functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express中间件函数
- en: How to deal with computationally intensive code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理计算密集型代码
- en: The HTTP Client object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端对象
- en: Creating a simple REST service with Express
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建一个简单的REST服务
- en: Sending and receiving events with EventEmitters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件发射器发送和接收事件
- en: EventEmitters are one of the core idioms of Node.js. If Node.js's core idea
    is an event-driven architecture, emitting events from an object is one of the
    primary mechanisms of that architecture. An EventEmitter is an object that gives
    notifications—events—at different points in its life cycle. For example, an HTTP
    Server object emits events concerning each stage of the startup/shutdown of the
    Server object, and as HTTP requests are made from HTTP clients.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器（EventEmitters）是Node.js的核心惯用法之一。如果Node.js的核心思想是事件驱动架构，那么从对象中发射事件是该架构的主要机制之一。事件发射器是一个在其生命周期中的不同点提供通知（事件）的对象。例如，HTTP服务器对象会发射与服务器对象启动/关闭的每个阶段相关的事件，以及HTTP客户端发起HTTP请求时。
- en: Many core Node.js modules are EventEmitters, and EventEmitters are an excellent
    skeleton to implement asynchronous programming. EventEmitters have nothing to
    do with web application development, but they are so much part of the Node.js
    woodwork that you may skip over their existence.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多核心Node.js模块都是事件发射器（EventEmitters），而事件发射器是实现异步编程的一个优秀框架。事件发射器与Web应用开发无关，但它们是Node.js结构中如此重要的一部分，以至于你可能会忽略它们的实际存在。
- en: In this chapter, we'll work with the HTTPServer and HTTPClient objects. Both
    are subclasses of the `EventEmitter` class, and rely on it to send events for
    each step of the HTTP protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将与HTTP服务器和HTTP客户端对象一起工作。这两个对象都是`EventEmitter`类的子类，并且依赖于它来发送HTTP协议每个步骤的事件。
- en: JavaScript classes and class inheritance
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript类和类继承
- en: 'Before getting started on the `EventEmitter` class, we need to take a look
    at another of the ES2015 features: classes. The JavaScript language has always
    had objects, and a concept of a class hierarchy, but nothing so formal as in other
    languages. The ES2015 class object builds on the existing prototype-based inheritance
    model, but with a syntax looking very much like class definitions in other languages.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习`EventEmitter`类之前，我们需要看看ES2015的另一个特性：类。JavaScript语言始终有对象和类层次结构的概念，但与其他语言相比，并没有那么正式。ES2015类对象建立在现有的基于原型的继承模型之上，但语法看起来非常类似于其他语言中的类定义。
- en: 'For example, consider this class we''ll be using later in the book:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在本书后面将要使用到的这个类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you''ve defined the class, you can export the class definition to other
    modules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了类，你就可以将类定义导出到其他模块：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The functions marked with `get` or `set` keywords are getters and setters,
    used like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标记有`get`或`set`关键字的函数是getter和setter，使用方式如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: New instances of a class are created with `new`. You access a getter or setter
    function as if it is a simple field on the object. Behind the scenes, the getter/setter
    function is invoked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`创建类的实例。你可以像访问对象上的简单字段一样访问getter或setter函数。幕后，getter/setter函数被调用。
- en: The preceding implementation is not the best because the `_title` and `_body` fields are
    publicly visible, and there is no data hiding or encapsulation. We'll go over
    a better implementation later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现并不是最佳方案，因为`_title`和`_body`字段是公开可见的，没有数据隐藏或封装。我们将在稍后的章节中介绍一个更好的实现。
- en: 'One tests whether a given object is of a certain class by using the `instanceof`
    operator:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`instanceof`运算符来测试给定对象是否属于某个特定的类：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, you declare a subclass using the `extends` operator, similar to what''s
    done in other languages:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用`extends`运算符声明一个子类，这与在其他语言中做的类似：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In other words, the `LoveNote` class has all the fields of `Note`, plus this
    new field named `heart`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`LoveNote`类有`Note`类的所有字段，加上这个名为`heart`的新字段。
- en: The EventEmitter Class
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventEmitter类
- en: The `EventEmitter` object is defined in the events module of Node.js. Directly
    using the `EventEmitter` class means performing `require('events')`. In most cases, you'll
    be using an existing object that uses `EventEmitter` internally and you won't
    require this module. But there are cases where needs dictate implementing an `EventEmitter` subclass.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`对象定义在Node.js的events模块中。直接使用`EventEmitter`类意味着执行`require(''events'')`。在大多数情况下，你会使用一个内部使用`EventEmitter`的现有对象，而不需要这个模块。但也有一些情况下，需求决定了需要实现一个`EventEmitter`子类。'
- en: 'Create a file named `pulser.js` containing the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`pulser.js`的文件，包含以下代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a `Pulser` class, which inherits from `EventEmitter`. In older
    Node.js releases, this would require using `util.inherits`, but the new class
    object makes subclassing much simpler.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个从`EventEmitter`继承的`Pulser`类。在较老的Node.js版本中，这需要使用`util.inherits`，但新的类对象使得子类化变得更加简单。
- en: Another thing to examine is how `this.emit` in the callback function refers
    to the Pulser object. Before the ES2015 arrow function, when our callbacks used
    a regular `function`, `this` would not have referred to the `Pulser` object. Instead,
    it would have referred to some other object related to the `setInterval` function. Because
    it is an arrow function, the `this` inside the arrow function is the same `this`
    as in the outer function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要检查的是回调函数中的`this.emit`如何引用Pulser对象。在ES2015箭头函数之前，当我们的回调使用常规`function`时，`this`不会指向`Pulser`对象。相反，它会指向与`setInterval`函数相关的其他对象。因为它是箭头函数，所以箭头函数内部的`this`与外部函数中的`this`是相同的。
- en: 'If you needed to use a `function` rather than an arrow function, this trick
    would work:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用函数而不是箭头函数，这个技巧会起作用：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What's different is the assignment of `this` to `self`. The value of `this`
    inside the function is different, but the value of `self` remains the same in
    every enclosed scope. This widely-used trick is less necessary now that we have
    arrow functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他不同之处在于将`this`赋值给`self`。函数内部`this`的值是不同的，但在每个封闭的作用域中`self`的值保持不变。现在我们有了箭头函数，这个广泛使用的技巧变得不那么必要了。
- en: 'If you want a simple EventEmitter, but with your own class name, the body of
    the extended class can be empty:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个简单的EventEmitter，但有自己的类名，扩展类的主体可以是空的：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of the `Pulser` class is sending a timed event, once a second, to
    any listeners. The `start` method uses `setInterval` to kick off repeated callback
    execution, scheduled for every second, calling `emit` to send the `pulse` events
    to any listeners.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pulser`类的目的是发送一个定时事件，每秒一次，到任何监听器。`start`方法使用`setInterval`来启动重复的回调执行，每秒调度一次，调用`emit`将`pulse`事件发送到任何监听器。'
- en: 'Now, let''s see how to use the `Pulser` object. Create a new file, called `pulsed.js`,
    containing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`Pulser`对象。创建一个名为`pulsed.js`的新文件，包含以下内容：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we create a `Pulser` object and consume its `pulse` events. Calling `pulser.on('pulse')`
    sets up connections for the `pulse` events to invoke the callback function. It
    then calls the `start` method to get the process going.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Pulser`对象并消费其`pulse`事件。调用`pulser.on('pulse')`为`pulse`事件设置连接，以便调用回调函数。然后调用`start`方法使进程开始运行。
- en: 'Enter this into a file and name the file `pulsed.js`. When you run it, you
    should see the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容输入到一个文件中，并将文件命名为`pulsed.js`。当你运行它时，你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That gives you a little practical knowledge of the `EventEmitter` class. Let's
    now look at its operational theory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你对`EventEmitter`类有了点实际的知识。现在，让我们看看它的操作理论。
- en: The EventEmitter theory
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventEmitter理论
- en: With the `EventEmitter` class, your code emits events that other code can receive.
    It's a way of connecting two separated sections of your program, kind of like
    how quantum entanglement means two electrons can communicate with each other from
    any distance. Seems simple enough.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`类，你的代码可以发出事件，其他代码可以接收这些事件。这是连接程序中两个分离部分的一种方式，有点像量子纠缠意味着两个电子可以从任何距离相互通信。看起来很简单。
- en: The event name can be anything that makes sense to you, and you can define as
    many event names as you like. Event names are defined simply by calling `.emit`
    with the event name. There's nothing formal to do and no registry of event names.
    Simply making a call to `.emit` is enough to define an event name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称可以是您认为有意义的任何名称，并且您可以定义任意多个事件名称。事件名称通过调用 `.emit` 并提供事件名称来定义。没有正式的操作要做，也没有事件名称的注册。只需调用
    `.emit` 就足以定义一个事件名称。
- en: By convention, the event name `error` indicates errors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，事件名称 `error` 表示错误。
- en: An object sends events using the `.emit` function. Events are sent to any listeners
    that have registered to receive events from the object. The program registers
    to receive an event by calling that object's `.on` method, giving the event name
    and an event handler function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象使用 `.emit` 函数发送事件。事件被发送到已注册接收该对象事件的任何监听器。程序通过调用该对象的 `.on` 方法来注册接收事件，提供事件名称和事件处理函数。
- en: There is no central distribution point for all events. Instead, each instance
    of an `EventEmitter` object manages its own set of listeners and distributes its
    events to those listeners.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 没有所有事件的中央分发点。相反，`EventEmitter` 对象的每个实例管理自己的监听器集，并将事件分发给这些监听器。
- en: 'Often, it is required to send data along with an event. To do so, simply add
    the data as arguments to the `.emit` call, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要在事件中发送数据。为此，只需将数据作为参数添加到 `.emit` 调用中，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the program receives that event, the data appears as arguments to the
    callback function. Your program would listen to such an event as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序接收到该事件时，数据作为回调函数的参数出现。您的程序可以如下监听此类事件：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is no handshaking between event receivers and the event sender. That is,
    the event sender simply goes on with its business, and it gets no notifications
    about any events received, any action taken, or any error that occurred.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 事件接收者和事件发送者之间没有握手。也就是说，事件发送者只是继续其业务，并且不会收到任何关于接收到的任何事件、采取的任何行动或发生的任何错误的任何通知。
- en: In this example, we used another of the ES2015 features, the `rest` operator,
    shown here as `...theArgs.` The *rest* operator catches any number of remaining
    function parameters into an array. Since `EventEmitter` can pass along any number
    of parameters, and the `rest` operator can automatically receive any number of
    parameters, it's a match made in heaven, or else in the TC-39 committee.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 ES2015 的另一个特性，即 `rest` 操作符，在这里显示为 `...theArgs`。`rest` 操作符将任意数量的剩余函数参数捕获到一个数组中。由于
    `EventEmitter` 可以传递任意数量的参数，而 `rest` 操作符可以自动接收任意数量的参数，这是一场天作之合，或者是在 TC-39 委员会上的。
- en: HTTP server applications
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 服务器应用程序
- en: The HTTP server object is the foundation of all Node.js web applications. The
    object itself is very close to the HTTP protocol, and its use requires knowledge
    of that protocol. In most cases, you'll be able to use an application framework
    such as Express that hides the HTTP protocol details, allowing the programmer
    to focus on business logic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器对象是所有 Node.js 网络应用程序的基础。该对象本身非常接近 HTTP 协议，其使用需要对该协议的了解。在大多数情况下，您可以使用像
    Express 这样的应用程序框架来隐藏 HTTP 协议的细节，使程序员能够专注于业务逻辑。
- en: 'We already saw a simple HTTP server application in Chapter 2, *Setting up Node.js*,
    which is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第二章 *设置 Node.js* 中看到了一个简单的 HTTP 服务器应用程序，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `http.createServer` function creates an `http.Server` object. Because it
    is an `EventEmitter`, this can be written in another way to make that fact explicit:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer` 函数创建一个 `http.Server` 对象。因为它是一个 `EventEmitter`，所以可以用另一种方式来明确这一点：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `request` event takes a function, which receives `request` and `response`
    objects. The `request` object has data from the web browser, while the `response`
    object is used to gather the data to be sent in the response. The `listen` function
    causes the server to start listening and arranging to dispatch an event for every
    request arriving from a web browser.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 事件接受一个函数，该函数接收 `request` 和 `response` 对象。`request` 对象包含来自网页浏览器的数据，而
    `response` 对象用于收集要发送在响应中的数据。`listen` 函数使服务器开始监听并安排为每个来自网页浏览器的请求分配一个事件。'
- en: Now, let's look at something more interesting with different actions based on
    the URL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些更有趣的内容，这些内容根据不同的 URL 执行不同的操作。
- en: 'Create a new file, named `server.js`, containing the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `server.js` 的新文件，包含以下代码：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To run it, type the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，请输入以下命令：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This application is meant to be similar to PHP''s `sysinfo` function. Node''s
    `os` module is consulted to provide information about the server. This example
    can easily be extended to gather other pieces of data about the server:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序旨在类似于 PHP 的 `sysinfo` 函数。Node 的 `os` 模块被用来提供有关服务器的信息。这个示例可以很容易地扩展以收集有关服务器的其他数据：
- en: '![](img/21c31140-b897-4230-b82b-efc3757960f4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21c31140-b897-4230-b82b-efc3757960f4.png)'
- en: 'A central part of any web application is the method of routing requests to
    request handlers. The `request` object has several pieces of data attached to
    it, two of which are useful for routing requests: the `request.url` and `request.method`
    fields.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Web 应用程序的核心部分是将请求路由到请求处理程序的方法。`request` 对象附带了多个数据项，其中两个对路由请求很有用：`request.url`
    和 `request.method` 字段。
- en: In `server.js`, we consult the `request.url` data to determine which page to
    show, after parsing (using `url.parse`) to ease the digestion process. In this
    case, we can do a simple comparison of the `pathname` to determine which handler
    method to use.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server.js` 中，我们通过解析（使用 `url.parse`）来确定要显示哪个页面，然后咨询 `request.url` 数据。在这种情况下，我们可以简单地比较
    `pathname` 来确定要使用哪个处理程序方法。
- en: Some web applications care about the HTTP verb (`GET`, `DELETE`, `POST`, and
    so on) used and must consult the `request.method` field of the `request` object.
    For example, `POST` is frequently used for `FORM` submissions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Web 应用程序关注所使用的 HTTP 动词（`GET`、`DELETE`、`POST` 等），并必须咨询 `request` 对象的 `request.method`
    字段。例如，`POST` 经常用于 `FORM` 提交。
- en: The `pathname` portion of the request URL is used to dispatch the request to
    the correct handler. While this routing method, based on simple string comparison,
    will work for a small application, it'll quickly become unwieldy. Larger applications
    will use pattern matching to use part of the request URL to select the request
    handler function and other parts to extract request data out of the URL. We'll
    see this in action while looking at Express later in the *Getting started with
    Express* section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 URL 的 `pathname` 部分用于将请求调度到正确的处理程序。虽然这种基于简单字符串比较的路由方法适用于小型应用程序，但它很快就会变得难以控制。大型应用程序将使用模式匹配来使用请求
    URL 的一部分来选择请求处理程序函数，并从 URL 中提取其他部分作为请求数据。我们将在查看 Express 的“Express 入门”部分时看到这一点。
- en: A search for a URL match in the npm repository turns up several promising packages
    that could be used to implement request matching and routing. A framework like
    Express has this capability already baked in and tested.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm 仓库中搜索 URL 匹配，会找到几个有潜力的包，可以用来实现请求匹配和路由。像 Express 这样的框架已经内置并测试了这种功能。
- en: If the request URL is not recognized, the server sends back an error page using
    a `404` result code. The result code informs the browser about the status of the
    request, where a `200` code means everything is fine, and a `404` code means the
    requested page doesn't exist. There are, of course, many other HTTP response codes,
    each with their own meaning.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求 URL 不可识别，服务器会使用 `404` 状态码发送一个错误页面。结果代码会通知浏览器请求的状态，其中 `200` 状态码表示一切正常，而
    `404` 状态码表示请求的页面不存在。当然，还有许多其他的 HTTP 响应代码，每个都有其特定的含义。
- en: ES2015 multiline and template strings
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015 多行和模板字符串
- en: The previous example showed two of the new features introduced with ES2015,
    multiline and template strings. The feature is meant to simplify our life while
    creating text strings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了 ES2015 中引入的两个新特性，多行和模板字符串。这个特性旨在简化我们创建文本字符串的过程。
- en: 'The existing string representations use single quotes and double quotes. Template
    strings are delimited with the backtick character that''s also known as the **grave
    accent**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的字符串表示使用单引号和双引号。模板字符串由反引号字符分隔，该字符也称为 **重音符号**：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before ES2015, one way to implement a multiline string was this construct:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2015 之前，实现多行字符串的一种方法是使用以下结构：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Yes, that was the code used in the same example in previous versions of this
    book. This is what we can do with ES2015:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这正是之前这本书的版本中相同示例所使用的代码。这是我们可以用 ES2015 做的事情：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is more succinct and straightforward. The opening quote is on the first
    line, the closing quote on the last line, and everything in between is part of
    our string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加简洁直接。开引号位于第一行，闭引号位于最后一行，而两者之间的所有内容都是我们字符串的一部分。
- en: The real purpose of the template strings feature is supporting strings where
    we can easily substitute values directly into the string. Most other programming
    languages support this ability, and now JavaScript does too.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串功能的真正目的是支持可以直接将值直接替换到字符串中的字符串。大多数其他编程语言都支持这种能力，现在 JavaScript 也支持了。
- en: 'Pre-ES2015, a programmer could have written code like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2015 之前，程序员可以编写如下代码：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, this is extracted from the same example in previous versions of this
    book. With template strings, this can be written as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是从本书之前版本中的相同示例中提取的。使用模板字符串，可以写成如下所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Within a template string, the part within the `${ .. }` brackets is interpreted
    as an expression. It can be a simple mathematical expression, a variable reference,
    or, as in this case, a function call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串中，`${ .. }` 括号内的部分被解释为表达式。它可以是简单的数学表达式、变量引用，或者，如本例中所示，函数调用。
- en: The last thing to mention is a matter of indentation. In normal coding, one
    indents a long argument list to the same level as the containing function call.
    But, for these multiline string examples, the text content is flush with column
    zero. What's up?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是缩进的问题。在常规编码中，会将长参数列表缩进到与包含函数调用相同的级别。但是，对于这些多行字符串示例，文本内容与列零对齐。这是怎么回事？
- en: 'This may impede the readability of your code, so it''s worth weighing code
    readability against another issue: excess characters in the HTML output. The blanks
    we would use to indent the code for readability will become part of the string
    and will be output in the HTML. By making the code flush with column zero, we
    don''t add excess blanks to the output at the cost of some code readability.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会妨碍代码的可读性，因此权衡代码可读性和另一个问题：HTML 输出中的多余字符是值得的。我们用来提高代码可读性的空白将变成字符串的一部分，并将在
    HTML 中输出。通过使代码与列零对齐，我们不会因为牺牲一些代码可读性而向输出添加多余的空白。
- en: This approach also carries a security risk. Have you verified the data is safe?
    That it will not form the basis of a security attack? In this case, we're dealing
    with simple strings and numbers coming from a safe data source.  Therefore this
    code is as safe as the Node.js runtime. What about user-supplied content, and
    the risk that a nefarious user might supply insecure content implanting some kind
    of malware into target computers?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也伴随着安全风险。您已经验证了数据的安全性吗？它不会成为安全攻击的基础吗？在这种情况下，我们处理的是来自安全数据源的简单字符串和数字。因此，这段代码与
    Node.js 运行时的安全性相同。那么用户提供的内 容和恶意用户可能提供的不安全内容，将某种恶意软件植入目标计算机的风险怎么办？
- en: For this and many other reasons, it is often safer to use an external template
    engine. Applications like Express make it easy to do so.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因以及许多其他原因，通常更安全地使用外部模板引擎。像 Express 这样的应用程序使得这样做变得容易。
- en: HTTP Sniffer – listening to the HTTP conversation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP Sniffer – 监听 HTTP 对话
- en: The events emitted by the HTTPServer object can be used for additional purposes
    beyond the immediate task of delivering a web application. The following code
    demonstrates a useful module that listens to all the HTTP Server events. It could
    be a useful debugging tool, which also demonstrates how HTTP server objects operate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPServer 对象发出的事件可以用于超出立即交付 Web 应用程序的直接任务的其他目的。以下代码演示了一个有用的模块，它监听所有 HTTP 服务器事件。它可以是一个有用的调试工具，同时也展示了
    HTTP 服务器对象是如何操作的。
- en: Node.js's HTTP Server object is an `EventEmitter` and the HTTP Sniffer simply
    listens to every server event, printing out information pertinent to each event.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的 HTTP 服务器对象是一个 `EventEmitter`，HTTP Sniffer 简单地监听每个服务器事件，打印出与每个事件相关的信息。
- en: 'What we''re about to do is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的就是：
- en: Create a module, `httpsniffer`, that prints information about HTTP requests.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `httpsniffer` 的模块，打印有关 HTTP 请求的信息。
- en: Add that module to the `server.js` script we just created.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该模块添加到我们刚刚创建的 `server.js` 脚本中。
- en: Rerun that server to view a trace of HTTP activity.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行该服务器以查看 HTTP 活动的跟踪。
- en: 'Create a file named `httpsniffer.js` containing the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `httpsniffer.js` 的文件，包含以下代码：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That was a lot of code! But the key to it is the `sniffOn` function. When given
    an HTTP Server object, it uses the `.on` function to attach listener functions
    that print data about each emitted event. It gives a fairly detailed trace of
    HTTP traffic on an application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多！但关键在于 `sniffOn` 函数。当给定一个 HTTP 服务器对象时，它使用 `.on` 函数附加监听函数，打印出关于每个发出的事件的详细信息。它为应用程序上的
    HTTP 流提供了相当详细的跟踪。
- en: 'In order to use it, simply insert this code just before the `listen` function
    in `server.js`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，只需在`server.js`中的`listen`函数之前插入此代码：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this in place, run the server as we did earlier. You can visit `http://localhost:8124/`
    in your browser and see the following console output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，像之前一样运行服务器。你可以在浏览器中访问`http://localhost:8124/`，并看到以下控制台输出：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You now have a tool for snooping on HTTPServer events. This simple technique
    prints a detailed log of event data. The pattern can be used for any `EventEmitter`
    object. You can use this technique as a way to inspect the actual behavior of
    `EventEmitter` objects in your program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个工具可以监视HTTPServer事件。这个简单的技术会打印出详细的事件数据日志。这个模式可以用于任何`EventEmitter`对象。你可以使用这个技术作为检查程序中`EventEmitter`对象实际行为的一种方式。
- en: Web application frameworks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序框架
- en: The HTTPServer object is very close to the HTTP protocol. While this is powerful
    in the same way that driving a stick shift car gives you low-level control over
    the driving experience, typical web application programming is better done at
    a higher level. Does anybody use assembly language to write web applications?
    It's better to abstract away the HTTP details and concentrate on your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPServer对象非常接近HTTP协议。虽然这和驾驶手动挡汽车一样，能让你对驾驶体验有低级别的控制，但在更高的层面上进行典型的网络应用程序编程会更好。有人用汇编语言编写网络应用程序吗？最好是抽象掉HTTP细节，专注于你的应用程序。
- en: The Node.js developer community has developed quite a few application frameworks
    to help with different aspects of abstracting away HTTP protocol details. Of them,
    Express is the most popular, and Koa ([http://koajs.com/](http://koajs.com/))
    should be considered because it was developed by the same team and has fully integrated
    support for `async` functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js开发者社区已经开发了许多应用程序框架，以帮助抽象HTTP协议细节的不同方面。其中，Express是最受欢迎的，而且Koa([http://koajs.com/](http://koajs.com/))也应该被考虑，因为它是由同一个团队开发的，并且完全集成了对`async`函数的支持。
- en: The ExpressJS Wiki has a list of frameworks built on top of ExpressJS, or tools
    that work with it. This includes template engines, middleware modules, and more.
    The ExpressJS Wiki is located at [https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ExpressJS维基页面上列出了建立在ExpressJS之上或与之配合使用的框架列表。这包括模板引擎、中间件模块等。ExpressJS维基页面位于[https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki)。
- en: 'One reason to use a web framework is that they often provide the best practices
    used in web application development for over 20 years. The usual best practices
    include the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络框架的一个原因是，它们通常提供了超过20年来在Web应用程序开发中使用的最佳实践。通常的最佳实践包括以下内容：
- en: Providing a page for bad URLs (the 404 page)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用于错误URL（404页面）的页面
- en: Screening URLs and forms for any injected scripting attacks
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选URL和表单以检测任何注入的脚本攻击
- en: Supporting the use of cookies to maintain sessions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用cookie来维持会话
- en: Logging requests for both usage tracking and debugging
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求以进行使用跟踪和调试
- en: Authentication
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Handling static files, such as images, CSS, JavaScript, or HTML
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理静态文件，例如图像、CSS、JavaScript或HTML
- en: Providing cache control headers to caching proxies
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为缓存代理提供缓存控制头
- en: Limiting things such as page size or execution time
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制诸如页面大小或执行时间等因素
- en: Web frameworks help you invest your time in the task without getting lost in
    the details of implementing HTTP protocol. Abstracting away details is a time-honored
    way for programmers to be more efficient. This is especially true when using a
    library or framework providing prepackaged functions that take care of the details.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 网络框架可以帮助你在任务中投入时间，而不会迷失在实现HTTP协议的细节中。抽象细节是程序员提高效率的传统方法。这在使用提供预包装函数的库或框架时尤其如此，这些函数会处理细节。
- en: Getting started with Express
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Express
- en: Express is perhaps the most popular Node.js web app framework. It's so popular
    that it's part of the MEAN Stack acronym. MEAN refers to MongoDB, ExpressJS, AngularJS,
    and Node.js. Express is described as being Sinatra-like, referring to a popular
    Ruby application framework, and that it isn't an opinionated framework, meaning
    the framework authors don't impose their opinions about structuring an application.
    This means Express is not at all strict about how your code is structured; you
    just write it the way you think is best.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Express可能是最受欢迎的Node.js网络应用程序框架。它如此受欢迎，以至于它是MEAN Stack缩写词的一部分。MEAN代表MongoDB、ExpressJS、AngularJS和Node.js。Express被描述为类似于Sinatra，指的是一个流行的Ruby应用程序框架，并且它不是一个有偏见的框架，这意味着框架作者不会强加他们对应用程序结构的看法。这意味着Express对您的代码结构没有任何严格的要求；您只需按照您认为最好的方式编写即可。
- en: You can visit the home page for Express at [http://expressjs.com/](http://expressjs.com/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问Express的主页，网址为[http://expressjs.com/](http://expressjs.com/)。
- en: Shortly, we'll implement a simple application to calculate Fibonacci numbers
    using Express, and in later chapters, we'll do quite a bit more with Express.
    We'll also explore how to mitigate the performance problems from computationally
    intensive code we discussed earlier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将使用Express实现一个简单的应用程序来计算斐波那契数，在后面的章节中，我们将使用Express做更多的事情。我们还将探讨如何减轻我们之前讨论的计算密集型代码的性能问题。
- en: As of writing this book, Express 4.16 is the current version, and Express 5
    is in Alpha testing. According to the ExpressJS website, there are very few differences
    between Express 4 and Express 5.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本书时，Express 4.16是当前版本，Express 5处于Alpha测试阶段。根据ExpressJS网站，Express 4和Express
    5之间几乎没有区别。
- en: Let's start by installing the express-generator. While we can just start writing
    some code, the express-generator provides a blank starting application. We'll
    take that and modify it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装express-generator。虽然我们可以直接开始编写代码，但express-generator提供了一个空白起始应用程序。我们将使用它并进行修改。
- en: 'Install it using the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令进行安装：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is different from the suggested installation method on the Express website,
    which was to use the `-g` tag for a global install. We're also using an explicit
    version number to ensure compatibility. As of writing this book, `express-generator@5.x`
    does not exist. When it does exist, one should be able to use the 5.x version
    with the following instructions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Express网站上建议的安装方法不同，该方法是使用`-g`标签进行全局安装。我们还在使用显式的版本号以确保兼容性。截至撰写本书时，`express-generator@5.x`不存在。当它存在时，应该能够使用以下说明使用5.x版本。
- en: Earlier, we discussed how many now recommend against installing modules globally.
    In the Twelve-Factor model, it's strongly recommended to not install global dependencies,
    and that's what we're doing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了很多人现在推荐不要全局安装模块。在Twelve-Factor模型中，强烈建议不要安装全局依赖项，这正是我们所做的。
- en: 'The result is that an `express` command is installed in the `./node_modules/.bin`
    directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在`./node_modules/.bin`目录中安装了一个`express`命令：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the `express` command like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行`express`命令：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We probably don't want to type `./node_modules/.bin/express` every time we run
    the `express-generator` application or, for that matter, any of the other applications
    that provide command-line utilities. Refer back to the discussion in Chapter 3,* Node.js
    Modules* about adding that directory to the `PATH` variable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不想每次运行`express-generator`应用程序或任何提供命令行工具的其他应用程序时都输入`./node_modules/.bin/express`，尤其是对于其他应用程序。请参考第3章中关于将此目录添加到`PATH`变量的讨论，标题为*Node.js模块*。
- en: 'Now that you''ve installed `express-generator` in the `fibonacci` directory,
    use it to set up the blank framework application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在`fibonacci`目录中安装了`express-generator`，请使用它来设置空白框架应用程序：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This created a bunch of files for us, which we'll walk through in a minute.
    The `node_modules` directory still has the `express-generator` module, which is
    now not useful. We can just leave it there and ignore it, or we can add it to
    the `devDependencies` of the `package.json` it generated. Alternatively, we can
    uninstall it as shown here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们创建了一大批文件，我们将在稍后进行讲解。`node_modules`目录中仍然有`express-generator`模块，现在它不再有用。我们可以简单地将其留在那里并忽略它，或者我们可以将其添加到它生成的`package.json`文件的`devDependencies`中。或者，我们可以像下面这样卸载它。
- en: 'The next thing to do is run the blank application in the way we''re told. The
    command shown, `npm start`, relies on a section of the supplied `package.json`
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是按照指示运行空白应用程序。显示的命令`npm start`依赖于提供的`package.json`文件的一部分：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `npm` tool supports scripts that are ways to automate various tasks. We'll
    use this capability throughout the book to do various things. When the Twelve-Factor
    Application model suggests automating all your administrative tasks, the `npm`
    scripts feature is an excellent mechanism to do so. Most `npm` scripts are run
    with the `npm run scriptName` command, but the `start` command is explicitly recognized
    by `npm` and can be run as shown previously.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 工具支持脚本，这是一种自动化各种任务的方式。本书中我们将利用这一功能来完成各种任务。当十二要素应用程序模型建议自动化所有管理任务时，`npm`
    脚本功能是一个出色的机制来实现这一点。大多数 `npm` 脚本都是通过 `npm run scriptName` 命令运行的，但 `start` 命令被 `npm`
    明确识别，可以像之前展示的那样运行。'
- en: 'The steps are:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Install the dependencies `npm install`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项 `npm install`。
- en: Start the application using `npm start`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm start` 命令启动应用程序。
- en: Optionally modify `package.json` to always run with debugging.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地修改 `package.json` 以始终以调试模式运行。
- en: 'To install the dependencies, and run the application, type these commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装依赖项并运行应用程序，请输入以下命令：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Setting the `DEBUG` variable this way turns on some debugging output, which
    includes this message about listening on port 3000\. Otherwise, we aren't told
    this information. This syntax is what's used in the Bash shell to run a command
    with an environment variable.  If you get an error try running just "`npm start`"
    then read the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置 `DEBUG` 变量会打开一些调试输出，其中包括关于监听端口 3000 的消息。否则，我们不会被告知这些信息。这种语法是在 Bash shell
    中运行带有环境变量的命令时使用的。如果你遇到错误，尝试只运行 "`npm start`"，然后阅读下一节。
- en: 'We can modify the supplied `npm start` script to always run the app with debugging
    enabled. Change the `scripts` section to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改提供的 `npm start` 脚本，使其始终以调试模式运行应用程序。将 `scripts` 部分更改为以下内容：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since the output says it is listening on port `3000`, we direct our browser
    to
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出表明它正在监听端口 `3000`，我们将浏览器指向
- en: '`http://localhost:3000/` and see the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `http://localhost:3000/` 打开浏览器并查看以下输出：
- en: '![](img/95ceee18-cfe6-44b2-9766-c13520701f24.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95ceee18-cfe6-44b2-9766-c13520701f24.png)'
- en: Setting environment variables in Windows cmd.exe command line
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows cmd.exe 命令行中设置环境变量
- en: If you're on Windows the previous example may have failed with an error that
    DEBUG is not a known command.  The problem is that the Windows shell, the `cmd.exe`
    program, does not support the Bash command-line structure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上，之前的示例可能会因为 DEBUG 命令未知而失败。问题在于 Windows 的 shell，即 `cmd.exe` 程序，不支持
    Bash 命令行结构。
- en: Adding `VARIABLE=value` at the beginning of a command-line is specific to some
    shells, like Bash, on Linux and macOS.  It sets that environment variable only
    for the command-line being executed, and is a very convenient way to temporarily
    override environment variables for a specific command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行开始处添加 `VARIABLE=value` 是一些 shell 的特性，如 Linux 和 macOS 上的 Bash。它只为正在执行的命令设置该环境变量，并且是临时覆盖特定命令环境变量的非常方便的方式。
- en: Clearly a solution is required if your `package.json` is to be usable across
    different operating systems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果要让 `package.json` 在不同的操作系统上可用，就需要一个解决方案。
- en: 'The best solution appears to be the `cross-env` package in the npm repository,
    see: [https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env) 
    With this package installed, commands in the `scripts` section in `package.json` can
    set environment variables just as in Bash on Linux/macOS.  The usage looks like
    so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来最好的解决方案是 npm 仓库中的 `cross-env` 包，请参阅：[https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env)。安装此包后，`package.json`
    中的 `scripts` 部分的命令可以设置环境变量，就像在 Linux/macOS 上的 Bash 一样。使用方法如下：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then the command is executed as so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后命令执行如下：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Walking through the default Express application
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫步默认 Express 应用程序
- en: We have a working, blank Express application; let's look at what was generated
    for us. We're doing this to familiarize ourselves with Express before diving in
    to start coding our `Fibonacci` application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个工作状态为空的 Express 应用程序；让我们看看为我们生成的内容。我们这样做是为了在开始编写我们的 `Fibonacci` 应用程序之前熟悉
    Express。
- en: Because we used the `--view=hbs` option, this application is set up to use the
    `Handlebars.js` template engine. Handlebars was built on top of Mustache, and
    was originally designed for use in the browser; for more information see its homepage
    at [http://handlebarsjs.com/](http://handlebarsjs.com/). The version shown here
    has been packaged for use with Express, and is documented at [https://github.com/pillarjs/hbs](https://github.com/pillarjs/hbs).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `--view=hbs` 选项，这个应用程序被设置为使用 `Handlebars.js` 模板引擎。Handlebars 是在 Mustache
    之上构建的，最初是为在浏览器中使用而设计的；更多信息请参阅其主页 [http://handlebarsjs.com/](http://handlebarsjs.com/)。这里显示的版本是为与
    Express 一起使用而打包的，并在 [https://github.com/pillarjs/hbs](https://github.com/pillarjs/hbs)
    上有文档。
- en: Generally speaking, a template engine makes it possible to insert data into
    generated web pages. The ExpressJS Wiki has a list of template engines for Express [https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，模板引擎使得将数据插入生成的网页成为可能。ExpressJS Wiki 列出了 Express 的模板引擎列表 [https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines)。
- en: The `views` directory contains two files, `error.hbs` and `index.hbs`. The `hbs`
    extension is used for Handlebars files. Another file, `layout.hbs`, is the default
    page layout. Handlebars has several ways to configure layout templates and even
    partials (snippets of code which can be included anywhere).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`views` 目录包含两个文件，`error.hbs` 和 `index.hbs`。`hbs` 扩展名用于 Handlebars 文件。另一个文件
    `layout.hbs` 是默认页面布局。Handlebars 有几种配置布局模板和部分（可以在任何地方包含的代码片段）的方法。'
- en: The `routes` directory contains the initial routing setup, that is, the code
    to handle specific URLs. We'll modify these later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes` 目录包含初始路由设置，即处理特定 URL 的代码。我们稍后会修改这些。'
- en: The `public` directory will contain assets that the application doesn't generate,
    but are simply sent to the browser. What's initially installed is a CSS file,
    `public/stylesheets/style.css`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 目录将包含应用程序不生成但直接发送到浏览器的资源。最初安装的是 CSS 文件，`public/stylesheets/style.css`。'
- en: The `package.json` file contains our dependencies and other metadata.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件包含我们的依赖项和其他元数据。'
- en: The `bin` directory contains the `www` script that we saw earlier. That's a
    Node.js script, which initializes the HTTPServer objects, starts it listening
    on a TCP port, and calls the last file we'll discuss, `app.js`. These scripts
    initialize Express, hook up the routing modules, and do other things.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin` 目录包含我们之前看到的 `www` 脚本。这是一个 Node.js 脚本，它初始化 HTTPServer 对象，开始监听 TCP 端口，并调用我们将要讨论的最后一个文件，`app.js`。这些脚本初始化
    Express，连接路由模块，并执行其他操作。'
- en: 'There''s a lot going on in the `www` and `app.js` scripts, so let''s start
    with the application initialization. Let''s first take a look at a couple of lines
    in `app.js`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `www` 和 `app.js` 脚本中有很多事情在进行，所以让我们从应用程序初始化开始。让我们首先看看 `app.js` 中的几行：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This means that `app.js` is a module that exports the object returned by the
    `express` module. It doesn't start the HTTP server object, however.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `app.js` 是一个导出 `express` 模块返回的对象的模块。然而，它并没有启动 HTTP 服务器对象。
- en: 'Now, let''s turn to the `www` script. The first thing to see is that it starts
    with this line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向 `www` 脚本。首先要注意的是，它从这一行开始：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is a Unix/Linux technique to make a command script. It says to run the
    following as a script using the `node` command. In other words, we have Node.js
    code and we''re instructing the operating system to execute that code using the
    Node.js runtime:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Unix/Linux 技巧，用于创建命令脚本。它指示使用 `node` 命令作为脚本运行以下内容。换句话说，我们有 Node.js 代码，并指示操作系统使用
    Node.js 运行时执行该代码：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can also see that the script was made executable by `express-generator`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到脚本是由 `express-generator` 使其可执行的。
- en: 'It calls the `app.js` module as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它以如下方式调用 `app.js` 模块：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We see where port `3000` comes from; it''s a parameter to the `normalizePort`
    function. We also see that setting the `PORT` environment variable will override
    the default port `3000`. And finally, we see that the HTTP Server object is created
    here, and is told to use the application instance created in `app.js`. Try running
    the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到端口 `3000` 的来源；它是 `normalizePort` 函数的参数。我们还可以看到设置 `PORT` 环境变量将覆盖默认端口 `3000`。最后，我们看到在这里创建了
    HTTP 服务器对象，并指示它使用在 `app.js` 中创建的应用程序实例。尝试运行以下命令：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The application now tells you that it's listening on port `4242`, where you
    can ponder the meaning of life.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在告诉您它正在端口 `4242` 上监听，在那里您可以思考生命的意义。
- en: The `app` object is next passed to `http.createServer()`. A look in the Node.js
    documentation tells us this function takes a `requestListener`, which is simply
    a function that takes the `request` and `response` objects we've seen previously.
    Therefore, the `app` object is such a function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `app` 对象传递给 `http.createServer()`。查看 Node.js 文档告诉我们这个函数接受一个 `requestListener`，它只是一个接受我们之前看到的
    `request` 和 `response` 对象的函数。因此，`app` 对象就是一个这样的函数。
- en: Finally, the `www` script starts the server listening on the port we specified.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`www` 脚本启动服务器，监听我们指定的端口。
- en: 'Let''s now walk through `app.js` in more detail:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地走一遍 `app.js`：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This tells Express to look for templates in the `views` directory and to use
    the EJS templating engine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Express 在 `views` 目录中查找模板，并使用 EJS 模板引擎。
- en: The `app.set` function is used for setting application properties. It'll be
    useful to browse the API documentation as we go through ([http://expressjs.com/en/4x/api.html](http://expressjs.com/en/4x/api.html)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.set` 函数用于设置应用程序属性。在我们浏览过程中，将很有用查看 API 文档 ([http://expressjs.com/en/4x/api.html](http://expressjs.com/en/4x/api.html))。'
- en: 'Next is a series of `app.use` calls:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一系列 `app.use` 调用：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `app.use` function mounts middleware functions. This is an important piece
    of Express jargon we will discuss shortly. At the moment, let''s say that middleware
    functions are executed during the processing of routes. This means all the features
    named here are enabled in `app.js`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use` 函数挂载中间件函数。这是我们很快将要讨论的 Express 行话中的一个重要部分。目前，让我们说中间件函数是在处理路由时执行的。这意味着这里命名的所有功能都在
    `app.js` 中启用：'
- en: Logging is enabled using the Morgan request logger. Visit [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)
    for its documentation.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Morgan 请求记录器启用日志记录。访问 [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)
    查看其文档。
- en: The `body-parser` module handles parsing HTTP request bodies. Visit [https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)
    for its documentation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser` 模块处理解析 HTTP 请求体。访问 [https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)
    查看其文档。'
- en: The `cookie-parser` module is used to parse HTTP cookies. Visit [https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)
    for its documentation.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie-parser` 模块用于解析 HTTP 钩子。访问 [https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)
    查看其文档。'
- en: A static file web server is configured to serve the asset files in the `public`
    directory.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了一个静态文件网络服务器，用于在 `public` 目录中提供资产文件。
- en: Two router modules, `routes` and `users`, to set up which functions handle which
    URLs.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个路由模块 `routes` 和 `users`，用于设置哪些函数处理哪些 URL。
- en: The Express middleware
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express 中间件
- en: 'Let''s round out the walkthrough of `app.js` by discussing what middleware
    functions do for our application. We have an example at the end of the script:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论 `app.js` 中的中间件函数对应用程序做了什么来完善对 `app.js` 的演练。脚本末尾有一个示例：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The comment says *catch 404 and forward to error handler*. As you probably know,
    an HTTP 404 status means the requested resource was not found. We need to tell
    the user their request wasn't satisfied, and maybe show them a picture of a flock
    of birds pulling a whale out of the ocean. This is the first step in doing so.
    Before getting to the last step of reporting this error, you must learn how middleware
    works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注释说明 *捕获 404 并转发到错误处理器*。正如你可能知道的，HTTP 404 状态码表示请求的资源未找到。我们需要告诉用户他们的请求没有得到满足，也许可以展示一群鸟从海洋中拉出鲸鱼的图片。这是这样做的第一步。在到达报告此错误的最后一步之前，你必须了解中间件是如何工作的。
- en: We do have a middleware function right in front of us. Refer to its documentation
    at [http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有一个中间件函数就在眼前。请参阅其文档 [http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html)。
- en: Middleware functions take three arguments. The first two, `request` and `response`,
    are equivalent to the `request` and `response` of the Node.js HTTP request object.
    However, Express expands the objects with additional data and capabilities. The
    last, `next`, is a callback function controlling when the request-response cycle
    ends, and it can be used to send errors down the middleware pipeline.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数接受三个参数。前两个，`request` 和 `response`，等同于我们之前看到的 Node.js HTTP 请求对象的 `request`
    和 `response`。然而，Express 通过添加额外的数据和功能扩展了这些对象。最后一个，`next`，是一个回调函数，用于控制请求-响应周期何时结束，并且可以用来将错误发送到中间件管道。
- en: The incoming request gets handled by the first middleware function, then the
    next, then the next, and so on. Each time the request is to be passed down the
    chain of middleware functions, the `next` function is called. If `next` is called
    with an error object, as shown here, an error is being signaled. Otherwise, the
    control simply passes to the next middleware function in the chain.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 进入请求首先由第一个中间件函数处理，然后是下一个，再下一个，依此类推。每次请求需要传递给中间件函数链时，都会调用`next`函数。如果`next`函数被传递一个错误对象，如这里所示，则表示正在发出错误信号。否则，控制权简单地传递给链中的下一个中间件函数。
- en: What happens if `next` is not called? The HTTP request will hang because no
    response has been given. A middleware function gives a response when it calls
    functions on the `response` object, such as `res.send` or `res.render`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调用`next`会发生什么？HTTP请求将会挂起，因为没有给出响应。中间件函数在调用`response`对象上的函数时给出响应，例如`res.send`或`res.render`。
- en: 'For example, consider the inclusion of `app.js`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`app.js`的包含：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This does not call `next`, but instead calls `res.send`. This is the correct
    method of ending the request-response cycle, by sending a response (`res.send`)
    to the request. If neither `next` nor `res.send` is called, the request never
    gets a response.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会调用`next`，而是调用`res.send`。这是结束请求-响应循环的正确方法，通过向请求发送响应（`res.send`）。如果没有调用`next`或`res.send`，则请求永远不会得到响应。
- en: 'Hence, a middleware function does one of the following four things:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，中间件函数执行以下四件事情之一：
- en: Executes its own business logic. The request logger middleware shown earlier
    is an example.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行自己的业务逻辑。前面展示的请求记录器中间件就是一个例子。
- en: Modifies the request or response objects. Both the `body-parser` and
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改请求或响应对象。`body-parser`和
- en: '`cookie-parser` do so, looking for data to add to the `request` object.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cookie-parser`这样做，寻找要添加到`request`对象中的数据。'
- en: Calls `next` to proceed to the next middleware function or else signals an error.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`next`以继续到下一个中间件函数，或者发出错误信号。
- en: Sends a response, ending the cycle.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送响应，结束循环。
- en: The ordering of middleware execution depends on the order they're added to the
    `app` object. The first added is executed first, and so on.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件执行顺序取决于它们添加到`app`对象的顺序。首先添加的将被首先执行，依此类推。
- en: Middleware and request paths
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件和请求路径
- en: We've seen two kinds of middleware functions so far. In one, the first argument
    is the handler function. In the other, the first argument is a string containing
    a URL snippet, and the second argument is the handler function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种中间件函数。在第一种中，第一个参数是处理函数。在另一种中，第一个参数是包含URL片段的字符串，第二个参数是处理函数。
- en: 'What''s actually going on is `app.use` has an optional first argument: the
    path the middleware is mounted on. The path is a pattern match against the request
    URL, and the given function is triggered if the URL matches the pattern. There''s
    even a method to supply named parameters in the URL:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的事情是`app.use`有一个可选的第一个参数：中间件挂载的路径。路径是与请求URL的模式匹配，如果URL与模式匹配，则触发给定的函数。甚至还有一个方法可以在URL中提供命名参数：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This path specification has a pattern, `:id`, and the value will land in `req.params.id`.
    In this example, we're suggesting a user profiles service, and that for this URL
    we want to display information about the named user.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径规范有一个模式`：id`，值将落在`req.params.id`上。在这个例子中，我们建议一个用户配置文件服务，并且对于这个URL，我们想要显示有关命名用户的详细信息。
- en: Another way to use a middleware function is on a specific HTTP request method.
    With `app.use`, any request will be matched, but in truth, `GET` requests are
    supposed to behave differently to `POST` requests. You call `app.METHOD` where
    `METHOD` matches one of the HTTP request verbs. That is, `app.get` matches the
    `GET` method, `app.post` matches `POST`, and so on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件函数的另一种方式是在特定的HTTP请求方法上。使用`app.use`，任何请求都会被匹配，但事实上，`GET`请求应该与`POST`请求有不同的行为。你调用`app.METHOD`，其中`METHOD`与HTTP请求动词之一匹配。也就是说，`app.get`匹配`GET`方法，`app.post`匹配`POST`，依此类推。
- en: 'Finally, we get to the `router` object. This is a kind of middleware used explicitly
    for routing requests based on their URL. Take a look at `routes/users.js`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达`router`对象。这是一种用于根据其URL显式路由请求的中间件。看看`routes/users.js`：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have a module whose `exports` object is a router. This router has only one
    route, but it can have any number of routes you think is appropriate.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个模块，其`exports`对象是一个路由器。这个路由器只有一个路由，但它可以有任意数量的你认为合适的路由。
- en: 'Back in `app.js`, this is added as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，添加方式如下：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All the functions we discussed for the `app` object apply to the `router` object.
    If the request matches, the router is given the request for its own chain of processing
    functions. An important detail is that the request URL prefix is stripped when
    the request is passed to the router instance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的所有 `app` 对象的函数都适用于 `router` 对象。如果请求匹配，路由器会接收到请求以执行其自己的处理函数链。一个重要的细节是，当请求传递给路由器实例时，请求
    URL 前缀会被移除。
- en: You'll notice that the `router.get` in `users.js` matches `'/'` and that this
    router is mounted on `'/users'`. In effect, that `router.get` matches `/users`
    as well, but because the prefix was stripped, it specifies `'/'` instead. This
    means a router can be mounted on different path prefixes without having to change
    the router implementation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `users.js` 中的 `router.get` 匹配 `'/'`，并且这个路由器被挂载在 `'/users'` 上。实际上，那个 `router.get`
    也匹配 `/users`，但由于前缀被移除，它指定了 `'/'`。这意味着路由器可以挂载在不同的路径前缀上，而无需更改路由器实现。
- en: Error handling
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Now, we can finally get back to the generated `app.js`, the 404 Error page not
    found, and any other errors the application might want to show to the user.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以回到生成的 `app.js` 文件，404 错误页面未找到，以及应用程序可能想要向用户显示的任何其他错误。
- en: A middleware function indicates an error by passing a value to the `next` function
    call. Once Express sees an error, it will skip any remaining non-error routing,
    and it will only pass it to error handlers instead. An error handler function
    has a different signature than what we saw earlier.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中间件函数通过向 `next` 函数调用传递一个值来指示错误。一旦 Express 看到错误，它将跳过任何剩余的非错误路由，并且只将其传递给错误处理器。错误处理器函数的签名与我们之前看到的不同。
- en: 'In `app.js`, which we''re examining, this is our error handler:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在检查的 `app.js` 文件中，这是我们的错误处理器：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Error handler functions take four parameters, with `err` added to the familiar
    `req`, `res`, and `next`. For this handler, we use `res.status` to set the HTTP
    response status code, and we use `res.render` to format an HTML response using
    the `views/error.hbs` template. The `res.render` function takes data, rendering
    it with a template to produce HTML.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理器函数接受四个参数，其中 `err` 是添加到熟悉的 `req`、`res` 和 `next` 参数中的。对于这个处理器，我们使用 `res.status`
    来设置 HTTP 响应状态码，并使用 `res.render` 来使用 `views/error.hbs` 模板格式化一个 HTML 响应。`res.render`
    函数接受数据，并通过模板将其渲染成 HTML。
- en: This means any error in our application will land here, bypassing any remaining
    middleware functions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应用程序中的任何错误都会在这里处理，绕过任何剩余的中间件函数。
- en: Calculating the Fibonacci sequence with an Express application
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 应用程序计算斐波那契序列
- en: 'The Fibonacci numbers are the integer sequence: *0, 1, 1, 2, 3, 5, 8, 13, 21,
    34, ...*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是整数序列：*0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...*
- en: Each entry in the list is the sum of the previous two entries in the list. The
    sequence was invented in 1202 by Leonardo of Pisa, who was also known as Fibonacci.
    One method to calculate entries in the Fibonacci sequence is the recursive algorithm
    we showed earlier. We will create an Express application that uses the Fibonacci
    implementation and then explore several methods to mitigate performance problems
    in computationally intensive algorithms.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每一项都是该列表中前两项之和。这个序列是在 1202 年由比萨的莱昂纳多（也被称为斐波那契）发明的。计算斐波那契序列中项的一个方法是我们之前展示的递归算法。我们将创建一个使用斐波那契实现的
    Express 应用程序，然后探讨几种减轻计算密集型算法性能问题的方法。
- en: Let's start with the blank application we created in the previous step. We had
    you name that application *Fibonacci* for a reason. We were thinking ahead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一步创建的空白应用程序开始。我们让您将这个应用程序命名为 *Fibonacci* 有原因。我们是有远见的。
- en: 'In `app.js`, make the following changes to the top portion of the file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.js` 文件的最顶部部分，进行以下更改：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Most of this is what `express-generator` gave us. The `var` statements have
    been changed to `const`, for that little teensy bit of extra comfort. We explicitly
    imported the `hbs` module so we could do some configuration. And we imported a
    router module for Fibonacci, which we'll see in a minute.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分是 `express-generator` 给我们的。`var` 语句已被更改为 `const`，为了那一点点额外的舒适感。我们显式地导入了 `hbs`
    模块，以便进行一些配置。我们还导入了用于斐波那契的路由器模块，我们将在稍后看到。
- en: For the `Fibonacci` application, we don't need to support users, and therefore
    deleted that routing module.  The `fibonacci` module, which we'll show next, serves
    to query a number for which we'll calculate the Fibonacci number.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Fibonacci` 应用程序，我们不需要支持用户，因此删除了那个路由模块。我们将在下面展示的 `fibonacci` 模块用于查询一个数字，我们将计算其斐波那契数。
- en: 'In the top-level directory, create a file, `math.js`, containing this extremely
    simplistic Fibonacci implementation:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶级目录中，创建一个名为 `math.js` 的文件，包含以下极其简单的斐波那契实现：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `views` directory, look at the file named `layout.hbs` which `express-generator`
    created:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `views` 目录中，查看 `express-generator` 创建的名为 `layout.hbs` 的文件：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This file contains the structure we'll use for HTML pages. Going by the Handlebars
    syntax, we see that `{{title}}` appears within the HTML `title` tag. It means
    when we call `res.render`, we should supply a `title` attribute. The `{{{body}}}`
    tag is where the view template content lands.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含我们将用于 HTML 页面的结构。根据 Handlebars 语法，我们看到 `{{title}}` 出现在 HTML 的 `title` 标签内。这意味着当我们调用
    `res.render` 时，我们应该提供一个 `title` 属性。`{{{body}}}` 标签是视图模板内容所在的位置。
- en: 'Change `views/index.hbs` to just contain the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `views/index.hbs` 修改为只包含以下内容：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This serves as the front page of our application. It will be inserted in place
    of `{{{body}}}` in `layout.hbs`. The marker, `{{> navbar}}`, refers to a partial
    named `navbar`. Earlier, we configured a directory named `partials` to hold partials.
    Now let''s create a file, `partials/navbar.html`, containing:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这充当我们应用程序的前页。它将被插入到 `layout.hbs` 中的 `{{{body}}}` 位置。标记 `{{> navbar}}` 指的是名为
    `navbar` 的部分。之前，我们配置了一个名为 `partials` 的目录来保存部分。现在让我们创建一个文件，`partials/navbar.html`，包含以下内容：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will serve as a navigation bar that's included on every page.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个包含在每一页上的导航栏。
- en: 'Create a file, `views/fibonacci.hbs`, containing the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，`views/fibonacci.hbs`，包含以下代码：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Remember that the files in `views` are templates into which data is rendered.
    They serve the View aspect of the **Model-View-Controller** (**MVC**) paradigm,
    hence the directory name.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `views` 目录中的文件是模板，数据将渲染到这些模板中。它们服务于 **模型-视图-控制器**（**MVC**）模式的视图方面，因此目录名为
    `views`。
- en: In the `routes` directory, delete the `user.js` module. It is generated by the
    Express framework, but we will not use it in this application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes` 目录下，删除 `user.js` 模块。它是 Express 框架生成的，但我们在本应用程序中不会使用它。
- en: 'In `routes/index.js`, change the router function to the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/index.js` 中，将路由函数更改为以下内容：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The anonymous object passed to `res.render` contains the data values we provide
    to the layout and view templates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `res.render` 的匿名对象包含我们提供给布局和视图模板的数据值。
- en: 'Then, finally, in the `routes` directory, create a file named `fibonacci.js`
    containing the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，在 `routes` 目录下，创建一个名为 `fibonacci.js` 的文件，包含以下代码：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `package.json` is already set up so we can use `npm start` to run the script
    and always have debugging messages enabled. And now we''re ready to do so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 已经设置好，我们可以使用 `npm start` 来运行脚本，并始终启用调试消息。现在我们准备这样做：'
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As it suggests, you can visit `http://localhost:3000/` and see what we have:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如其所指，您可以通过 `http://localhost:3000/` 访问并查看我们有什么：
- en: '![](img/eaa7f981-70a5-4eed-8d6f-766670e06c67.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaa7f981-70a5-4eed-8d6f-766670e06c67.png)'
- en: 'This page is rendered from the `views/index.hbs` template. Simply click on
    the Fibonacci''s link to go to the next page, which is of course rendered from
    the `views/fibonacci.hbs` template. On that page, you''ll be able to enter a number,
    click on the Submit button, and get an answer (hint: pick a number below `40`
    if you want your answer in a reasonable amount of time):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面是从 `views/index.hbs` 模板渲染的。只需点击斐波那契的链接即可转到下一页，当然这一页也是从 `views/fibonacci.hbs`
    模板渲染的。在该页面上，您将能够输入一个数字，点击提交按钮，并获得答案（提示：如果您想在一个合理的时间内得到答案，请选择小于 `40` 的数字）：
- en: '![](img/c358759e-47e0-4436-8932-df9af39f49dc.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c358759e-47e0-4436-8932-df9af39f49dc.png)'
- en: Let's walk through the application to discuss how it works.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历应用程序来讨论它是如何工作的。
- en: 'There are two routes in `app.js`: the route for `/`, which is handled by `routes/index.js`,
    and the route for `/fibonacci`, which is handled by `routes/fibonacci.js`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.js` 中有两个路由：一个是 `/` 路由，由 `routes/index.js` 处理，另一个是 `/fibonacci` 路由，由 `routes/fibonacci.js`
    处理。
- en: The `res.render` function renders the named template using the provided data
    values and emits the result as an HTTP response. For the home page of this application,
    the rendering code (`routes/index.js`) and template (`views/index.hbs`) aren't
    much, and it is on the Fibonacci page where all the action is happening.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.render` 函数使用提供的数据值渲染命名模板，并将结果作为 HTTP 响应发出。对于本应用程序的首页，渲染代码（`routes/index.js`）和模板（`views/index.hbs`）并不多，所有的动作都在斐波那契页面上发生。'
- en: The `views/fibonacci.hbs` template contains a form in which the user enters
    a number. Because it is a `GET` form, when the user clicks on the Submit button,
    the browser will issue an HTTP `GET` on the `/fibonacci` URL. What distinguishes
    one `GET` on `/fibonacci` from another is whether the URL contains a query parameter
    named `fibonum`. When the user first enters the page, there is no `fibonum` and
    hence nothing to calculate. After the user has entered a number and clicked on
    Submit, there is a `fibonum` and something to calculate.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`views/fibonacci.hbs` 模板包含一个表单，用户可以在其中输入一个数字。因为它是一个 `GET` 表单，所以当用户点击提交按钮时，浏览器将对
    `/fibonacci` URL 发出 HTTP `GET` 请求。区分 `/fibonacci` 上的一个 `GET` 请求与另一个请求的是 URL 是否包含名为
    `fibonum` 的查询参数。当用户首次进入页面时，没有 `fibonum`，因此没有要计算的内容。在用户输入数字并点击提交后，就有 `fibonum`
    和要计算的内容了。'
- en: Express automatically parses the query parameters, making them available as `req.query`.
    That means `routes/fibonacci.js` can quickly check whether there is a `fibonum`.
    If there is, it calls the `fibonacci` function to calculate the value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Express 自动解析查询参数，使它们作为 `req.query` 可用。这意味着 `routes/fibonacci.js` 可以快速检查是否存在
    `fibonum`。如果存在，它将调用 `fibonacci` 函数来计算值。
- en: Earlier, we asked you to enter a number less than `40`. Go ahead and enter a
    larger number, such as `50`, but go take a coffee break because this is going
    to take a while to calculate. Or proceed on to reading the next section where
    we start to discuss use of computationally intensive code.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们要求您输入一个小于 `40` 的数字。现在请输入一个更大的数字，例如 `50`，但请去喝杯咖啡，因为这需要一段时间来计算。或者继续阅读下一节，我们将开始讨论计算密集型代码的使用。
- en: Computationally intensive code and the Node.js event loop
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算密集型代码和 Node.js 事件循环
- en: This Fibonacci example is purposely inefficient to demonstrate an important
    consideration for your applications. What happens to the Node.js event loop when
    running long computations? To see the effect, open two browser windows, each opened
    to the Fibonacci page. In one, enter the number `55` or greater, and in the other,
    enter `10`. Note that the second window freezes, and if you leave it running long
    enough, the answer will eventually pop up in both windows. What's happening is
    the Node.js event loop is blocked from processing events because the Fibonacci
    algorithm is running and does not ever yield to the event loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个斐波那契示例故意设计得效率低下，以展示对您应用的重要考虑。当运行长时间计算时，Node.js 的事件循环会发生什么？为了看到效果，请打开两个浏览器窗口，每个窗口都打开到斐波那契页面。在一个窗口中，输入数字
    `55` 或更大，在另一个窗口中，输入 `10`。注意第二个窗口会冻结，如果您让它运行足够长的时间，最终两个窗口都会弹出答案。发生的情况是 Node.js
    的事件循环因为斐波那契算法正在运行而被阻塞，无法处理事件。
- en: Since Node.js has a single execution thread, processing requests depend on request
    handlers quickly returning to the event loop. Normally, the asynchronous coding
    style ensures that the event loop executes regularly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 有一个单独的执行线程，处理请求依赖于请求处理程序快速返回到事件循环。通常，异步编码风格确保事件循环定期执行。
- en: This is true even for requests that load data from a server halfway around the
    globe, because the asynchronous I/O is non-blocking and control is quickly returned
    to the event loop. The naïve Fibonacci function we chose doesn't fit into this
    model because it's a long-running blocking operation. This type of event handler
    prevents the system from processing requests and stops Node.js from doing what
    it's meant to do, namely to be a blisteringly fast web server.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至适用于从地球另一端的服务器加载数据的请求，因为异步 I/O 是非阻塞的，并且控制权会迅速返回到事件循环。我们选择的简单斐波那契函数不适合这个模型，因为它是一个长时间运行的阻塞操作。这种类型的事件处理程序阻止系统处理请求，并阻止
    Node.js 做它应该做的事情，即成为一个极快的 Web 服务器。
- en: In this case, the long-response-time problem is obvious. Response time quickly
    escalates to the point where you can take a vacation to Tibet and perhaps get
    reincarnated as a llama in Peru during the time it takes to respond with the Fibonacci
    number!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，长时间响应问题很明显。响应时间迅速攀升到您可以休假去西藏，也许在响应斐波那契数字的时间内，您可能会在秘鲁转世为一只骆马！
- en: 'To see this more clearly, create a file named `fibotimes.js` containing the
    following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地看到这一点，创建一个名为 `fibotimes.js` 的文件，包含以下代码：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now run it. You will get the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它。您将得到以下输出：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This quickly calculates the first 40 or so members of the Fibonacci sequence,
    but after the 40th member, it starts taking a couple of seconds per result and
    quickly degrades from there. It is untenable to execute code of this sort on a
    single-threaded system that relies on a quick return to the event loop. A web
    service containing such code would give poor performance to the users.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以快速计算出斐波那契数列的前40个左右的成员，但到了第40个成员之后，每个结果都需要几秒钟的时间，并且从那里开始迅速下降。在依赖于快速返回事件循环的单线程系统中执行此类代码是不可行的。包含此类代码的Web服务会给用户带来较差的性能。
- en: 'There are two general ways to solve this problem in Node.js:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中解决这个问题的两种通用方法：
- en: '**Algorithmic refactoring**: Perhaps, like the Fibonacci function we chose,
    one of your algorithms is suboptimal and can be rewritten to be faster. Or, if
    not faster, it can be split into callbacks dispatched through the event loop.
    We''ll look at one such method in a moment.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法重构**：也许，就像我们选择的斐波那契函数一样，你的某个算法可能不是最优的，并且可以被重写以使其更快。或者，如果不是更快，它可以通过事件循环分派回调来分割。我们将在稍后查看这样一个方法。'
- en: '**Creating a backend service**: Can you imagine a backend server dedicated
    to calculating Fibonacci numbers? Okay, maybe not, but it''s quite common to implement
    backend servers to offload work from frontend servers, and we will implement a
    backend Fibonacci server at the end of this chapter.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建后端服务**：你能想象一个专门用于计算斐波那契数的后端服务器吗？好吧，可能不会，但实现后端服务器以从前端服务器卸载工作是非常常见的，我们将在本章末尾实现一个后端斐波那契服务器。'
- en: Algorithmic refactoring
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法重构
- en: 'To prove that we have an artificial problem on our hands, here is a much more
    efficient `Fibonacci` function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们手头有一个人为的问题，这里有一个更高效的 `Fibonacci` 函数：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we substitute a call to `math.fibonacciLoop` in place of `math.fibonacci`,
    the `fibotimes` program runs much faster. Even this isn't the most efficient implementation;
    for example, a simple prewired lookup table is much faster at the cost of some
    memory.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `math.fibonacci` 的调用替换为 `math.fibonacciLoop`，则 `fibotimes` 程序将运行得更快。即使这也不是最有效的实现；例如，一个简单的预配查找表在内存消耗上有所牺牲，但速度要快得多。
- en: 'Edit `fibotimes.js` as follows and rerun the script. The numbers will fly by
    so fast your head will spin:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编辑 `fibotimes.js` 并重新运行脚本。数字会飞快地闪过，让你的头都要转晕了：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Some algorithms aren't so simple to optimize and still take a long time to calculate
    the result. In this section, we're exploring how to handle inefficient algorithms,
    and therefore will stick with the inefficient Fibonacci implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有些算法并不容易优化，计算结果仍然需要很长时间。在本节中，我们将探讨如何处理低效的算法，因此我们将坚持使用低效的斐波那契实现。
- en: 'It is possible to divide the calculation into chunks and then dispatch the
    computation of those chunks through the event loop. Add the following code to
    `math.js`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将计算分成几块，然后通过事件循环调度这些块的计算。将以下代码添加到 `math.js` 中：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This converts the `fibonacci` function from asynchronous function to a traditional
    callback-oriented asynchronous function. We're using `setImmediate` at each stage
    of the calculation to ensure the event loop executes regularly and that the server
    can easily handle other requests while churning away on a calculation. It does
    nothing to reduce the computation required; this is still the silly, inefficient
    Fibonacci algorithm. All we've done is spread the computation through the event
    loop.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `fibonacci` 函数从异步函数转换为传统的基于回调的异步函数。我们在计算的每个阶段使用 `setImmediate`，以确保事件循环定期执行，并且服务器可以轻松处理其他请求，同时进行计算。这并没有减少所需的计算量；这仍然是愚蠢且低效的斐波那契算法。我们所做的只是将计算分散到事件循环中。
- en: 'In `fibotimes.js`, we can use this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fibotimes.js` 中，我们可以使用以下代码：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This version of `fibotimes.js` executes the same, we simply type `node fibotimes`. 
    However, using `fibonacciAsync` will require changes in the server.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `fibotimes.js` 执行的是相同的操作，我们只需输入 `node fibotimes`。然而，使用 `fibonacciAsync`
    将需要在服务器上进行更改。
- en: 'Because it''s an asynchronous function, we will need to change our router code.
    Create a new file, named `routes/fibonacci-async1.js`, containing the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个异步函数，我们需要更改我们的路由代码。创建一个新文件，命名为 `routes/fibonacci-async1.js`，包含以下内容：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is the same as earlier, just rewritten for an asynchronous Fibonacci calculation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前相同，只是为了异步斐波那契计算而重写。
- en: 'In `app.js`, make this change to the application wiring:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.js` 中，进行以下更改以调整应用程序的连接：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With this change, the server no longer freezes when calculating a large Fibonacci
    number. The calculation of course still takes a long time, but at least other
    users of the application aren't blocked.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，服务器在计算大斐波那契数时不再冻结。当然，计算仍然需要很长时间，但至少应用程序的其他用户不会被阻塞。
- en: 'You can verify this by again opening two browser windows in the application.
    Enter 60 in one window, and in the other start requesting smaller Fibonacci numbers.
    Unlike with the original `fibonacci` function, using `fibonacciAsync` allows both
    windows to give answers, though if you really did enter 60 in the first window
    you might as well take that three-month vacation to Tibet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过再次在应用程序中打开两个浏览器窗口来验证这一点。在一个窗口中输入 60，在另一个窗口中开始请求较小的斐波那契数。与原始的 `fibonacci`
    函数不同，使用 `fibonacciAsync` 允许两个窗口都给出答案，尽管如果您真的在第一个窗口中输入了 60，您不妨去西藏度假三个月：
- en: '![](img/ec067649-82e1-43c2-8987-b932f0255f23.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec067649-82e1-43c2-8987-b932f0255f23.png)'
- en: It's up to you, and your specific algorithms, to choose how to best optimize
    your code and to handle any long-running computations you may have.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如何最佳优化您的代码以及处理您可能有的任何长时间运行的计算取决于您自己，以及您的特定算法。
- en: Making HTTP Client requests
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 HTTP 客户端请求
- en: The next way to mitigate computationally intensive code is to push the calculation
    to a backend process. To explore that strategy, we'll request computations from
    a backend Fibonacci server, using the HTTP Client object to do so. However, before we
    look at that, let's first talk in general about using the HTTP Client object.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 减少计算密集型代码的另一种方法是将其推送到后端进程。为了探索这种策略，我们将使用 HTTP 客户端对象从后端斐波那契服务器请求计算。然而，在我们查看这一点之前，让我们首先一般性地讨论使用
    HTTP 客户端对象。
- en: Node.js includes an HTTP Client object, useful for making HTTP requests. It
    has the capability to issue any kind of HTTP request. In this section, we'll use
    the HTTP Client object to make HTTP requests similar to calling a **Representational
    State Transfer** (**REST**) web service.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 包含一个 HTTP 客户端对象，这对于发送 HTTP 请求非常有用。它能够发出任何类型的 HTTP 请求。在本节中，我们将使用 HTTP
    客户端对象来发送类似于调用 **表示状态传输**（**REST**）Web 服务的 HTTP 请求。
- en: 'Let''s start with some code inspired by the `wget` or `curl` commands to make
    HTTP requests and show the results. Create a file named `wget.js` containing this
    code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些受 `wget` 或 `curl` 命令启发的代码开始，这些代码用于发送 HTTP 请求并显示结果。创建一个名为 `wget.js` 的文件，包含以下代码：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can run the script as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式运行脚本：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'There''s more in the printout, namely the HTML of the page at `http://example.com/`.
    The purpose of `wget.js` is to make an HTTP request and show you voluminous details
    of the response. An HTTP request is initiated with the `http.request` method,
    as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出中还有更多内容，即 `http://example.com/` 页面的 HTML。`wget.js` 的目的是发送 HTTP 请求并显示响应的详细信息。HTTP
    请求是通过 `http.request` 方法发起的，如下所示：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `options` object describes the request to make, and the `callback` function
    is called when the response arrives. The `options` object is fairly straightforward,
    with the `host`, `port`, and `path` fields specifying the URL being requested.
    The `method` field must be one of the HTTP verbs (`GET`, `PUT`, `POST`, and so
    on). You can also provide a `headers` array for the headers in the HTTP request.
    For example, you might need to provide a cookie:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 对象描述了要发出的请求，当响应到达时，会调用 `callback` 函数。`options` 对象相当直接，其中 `host`、`port`
    和 `path` 字段指定了请求的 URL。`method` 字段必须是 HTTP 动词之一（`GET`、`PUT`、`POST` 等）。您还可以为 HTTP
    请求提供 `headers` 数组。例如，您可能需要提供 cookie：'
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `response` object is itself an `EventEmitter`, which emits the `data` and
    `error` events. The `data` event is called as data arrives, and the `error` event
    is, of course, called on errors.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`response` 对象本身是一个 `EventEmitter`，它发出 `data` 和 `error` 事件。当数据到达时，会调用 `data`
    事件，而 `error` 事件当然是在出现错误时调用。'
- en: The request object is a `WritableStream`, which is useful for HTTP requests
    containing data, such as `PUT` or `POST`. This means the `request` object has
    a `write` function that writes data to the requester. The data format in an HTTP
    request is specified by the standard **Multipurpose Internet Mail Extensions** (**MIME**)
    originally created to give us better email. Around 1992, the WWW community worked
    with the MIME standard committee which was developing a format for multi-part,
    multi-media-rich electronic mail. Receiving fancy-looking email is so commonplace
    today that one might not be aware that email used to be plain text. MIME-types
    were developed to describe the format of each piece of data, and the WWW community
    adopted this for use on the web. HTML forms will post with a Content-Type of `multipart/form-data`,
    for example.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象是一个 `WritableStream`，这对于包含数据的 HTTP 请求非常有用，例如 `PUT` 或 `POST`。这意味着 `request`
    对象有一个 `write` 函数，可以将数据写入请求者。HTTP 请求中的数据格式由标准 **多用途互联网邮件扩展**（**MIME**）指定，该标准最初是为了让我们有更好的电子邮件体验。大约在
    1992 年，万维网社区与 MIME 标准委员会合作，该委员会正在开发一种用于多部分、多媒体丰富的电子邮件的格式。如今，收到看起来很花哨的电子邮件已经变得司空见惯，以至于人们可能没有意识到电子邮件曾经只是纯文本。MIME
    类型被开发出来以描述每份数据的格式，而万维网社区采用了这种格式用于网页。例如，HTML 表单将以 `multipart/form-data` 的内容类型进行提交。
- en: Calling a REST backend service from an Express application
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Express 应用程序中调用 REST 后端服务
- en: Now that we've seen how to make HTTP client requests, we can look at how to
    make a REST query inside an Express web application. What that effectively means
    is to make an HTTP `GET` request to a backend server, which responds with the
    Fibonacci number represented by the URL. To do so, we'll refactor the `Fibonacci`
    application to make a Fibonacci server that is called from the application. While
    this is overkill for calculating Fibonacci numbers, it lets us look at the basics
    of implementing a multitier application stack in Express.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何进行 HTTP 客户端请求，我们可以看看如何在 Express 网络应用程序中执行 REST 查询。这实际上意味着向后端服务器发送一个
    HTTP `GET` 请求，该服务器通过 URL 返回斐波那契数。为此，我们将重构 `Fibonacci` 应用程序，以创建一个从应用程序中调用的斐波那契服务器。虽然这对于计算斐波那契数来说有点过度，但它让我们能够查看在
    Express 中实现多层应用程序堆栈的基本方法。
- en: Inherently, calling a REST service is an asynchronous operation. That means
    calling the REST service will involve a function call to initiate the request
    and a callback function to receive the response. REST services are accessed over
    HTTP, so we'll use the HTTP client object to do so.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，调用 REST 服务是一个异步操作。这意味着调用 REST 服务将涉及一个函数调用来发起请求，以及一个回调函数来接收响应。REST 服务通过 HTTP
    访问，因此我们将使用 HTTP 客户端对象来完成此操作。
- en: Implementing a simple REST server with Express
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 实现简单的 REST 服务器
- en: While Express has a powerful templating system, making it suitable for delivering
    HTML web pages to browsers, it can also be used to implement a simple REST service.
    The parameterized URLs we showed earlier (`/user/profile/:id`) can act like parameters
    to a REST call. And Express makes it easy to return data encoded in JSON.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Express 拥有强大的模板系统，使其适合向浏览器提供 HTML 网页，但它也可以用来实现简单的 REST 服务。我们之前展示的参数化 URL（`/user/profile/:id`）可以像
    REST 调用的参数一样使用。Express 使得返回编码为 JSON 的数据变得容易。
- en: 'Now, create a file named `fiboserver.js` containing this code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `fiboserver.js` 的文件，包含以下代码：
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is a stripped-down Express application that gets right to the point of
    providing a Fibonacci calculation service. The one route it supports handles the
    Fibonacci computation using the same functions we've already worked with.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版的 Express 应用程序，它直接提供斐波那契计算服务。它支持的一个路由使用我们之前已经使用过的相同函数来处理斐波那契计算。
- en: This is the first time we've seen `res.send` used. It's a flexible way to send
    responses which can take an array of header values (for the HTTP response header),
    and an HTTP status code. As used here, it automatically detects the object, formats
    it as JSON text, and sends it with the correct `Content-Type`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到 `res.send` 的使用。它是一种灵活的方式来发送响应，可以接受一个包含头部值的数组（用于 HTTP 响应头部），以及一个 HTTP
    状态码。在这里的使用中，它会自动检测对象，将其格式化为 JSON 文本，并使用正确的 `Content-Type` 发送。
- en: 'In `package.json`, add this to the `scripts` section:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 的 `scripts` 部分添加以下内容：
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This automates launching our Fibonacci service.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这自动启动了我们的斐波那契服务。
- en: 'Note that we''re specifying the TCP/IP port via an environment variable and
    using that variable in the application. This is another aspect of the Twelve-Factor
    application model: to put configuration data in the environment.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过环境变量指定TCP/IP端口，并在应用程序中使用该变量。这是十二因素应用程序模型的一个方面：将配置数据放在环境中。
- en: 'Now, let''s run it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它：
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, in a separate command window, we can use the `curl` program to make some
    requests against this service:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个命令窗口中，我们可以使用`curl`程序向该服务发出一些请求：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Over in the window where the service is running, we''ll see a log of `GET`
    requests and how long each took to process:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务运行的那个窗口中，我们将看到`GET`请求的日志以及每个请求处理所需的时间：
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s create a simple client program, `fiboclient.js`, to programmatically
    call the Fibonacci service:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的客户端程序，`fiboclient.js`，以编程方式调用Fibonacci服务：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, in `package.json`, add this to the `scripts` section:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`package.json`中，在`scripts`部分添加以下内容：
- en: '[PRE73]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then run the *client* app:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行*客户端*应用程序：
- en: '[PRE74]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We're building our way toward adding the REST service to the web application.
    At this point, we've proved several things, one of which is the ability to call
    a REST service in our program.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在逐步将REST服务添加到Web应用程序中。到目前为止，我们已经证明了几件事情，其中之一就是能够在我们的程序中调用REST服务。
- en: We also inadvertently demonstrated an issue with long-running calculations.
    You'll notice the requests were made from the largest to the smallest, but the
    results appeared in a very different order. Why? It's because of the processing
    time for each request, and the inefficient algorithm we're using. The computation
    time increases enough to ensure that the larger request values require enough
    processing time to reverse the order.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无意中展示了一个与长时间运行的计算相关的问题。你会注意到请求是从大到小进行的，但结果却以一个非常不同的顺序出现。为什么？这是因为每个请求的处理时间，以及我们正在使用的低效算法。计算时间增加得足够多，以确保较大的请求值需要足够多的处理时间来反转顺序。
- en: What happens is that `fiboclient.js` sends all its requests right away, and
    then each one waits for the response to arrive. Because the server is using `fibonacciAsync`,
    it will work on calculating all responses simultaneously. The values that are
    quickest to calculate are the ones that will be ready first. As the responses
    arrive in the client, the matching response handler fires, and in this case, the
    result prints to the console. The results will arrive when they're ready and not
    a millisecond sooner.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是`fiboclient.js`立即发送所有请求，然后每个请求都等待响应到达。因为服务器正在使用`fibonacciAsync`，它将同时处理所有响应。计算最快的值将首先准备好。当响应到达客户端时，匹配的响应处理程序被触发，在这种情况下，结果打印到控制台。结果将在准备好时到达，而不是提前一毫秒。
- en: Refactoring the Fibonacci application for REST
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Fibonacci应用程序进行REST重构
- en: 'Now that we''ve implemented a REST-based server, we can return to the `Fibonacci`
    application, applying what we''ve learned to improve it. We will lift some of
    the code from `fiboclient.js` and transplant it into the application to do this.
    Create a new file, `routes/fibonacci-rest.js`, with the following code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个基于REST的服务器，我们可以回到`Fibonacci`应用程序，应用我们所学的内容来改进它。我们将从`fiboclient.js`中提取一些代码并将其移植到应用程序中。创建一个新文件，`routes/fibonacci-rest.js`，并包含以下代码：
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In `app.js`, make this change:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，进行以下更改：
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, in `package.json`, change the `scripts` entry to the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`package.json`中，将`scripts`条目更改为以下内容：
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How can we have the same value for `SERVERPORT` for all three `scripts` entries? 
    The answer is that the variable is used differently in different places. In `startrest`,
    that variable is used in `routes/fibonacci-rest.js` to know at which port the
    REST service is running. Likewise, in `client`, `fiboclient.js` uses that variable
    for the same purpose. Finally, in `server`, the `fiboserver.js` script uses the
    `SERVERPORT` variable to know which port to listen on.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让所有三个`scripts`条目的`SERVERPORT`具有相同的值？答案是，该变量在不同的地方有不同的用途。在`startrest`中，该变量用于`routes/fibonacci-rest.js`以知道REST服务正在哪个端口运行。同样，在`client`中，`fiboclient.js`使用该变量用于相同的目的。最后，在`server`中，`fiboserver.js`脚本使用`SERVERPORT`变量来知道要监听哪个端口。
- en: In `start` and `startrest`, no value is given for `PORT`. In both cases, `bin/www`
    defaults to `PORT=3000` if it is not specified.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`和`startrest`中，没有为`PORT`提供值。在这两种情况下，如果未指定，`bin/www`默认为`PORT=3000`。
- en: 'In one command window, start the backend server, and in the other, start the
    application. Open a browser window as before, and make a few requests. You should
    see output similar to this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个命令窗口中启动后端服务器，在另一个窗口中启动应用程序。像之前一样打开一个浏览器窗口，发送几个请求。你应该会看到类似以下的输出：
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output like this for the application:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的输出如下：
- en: '[PRE79]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Because we haven't changed the templates, the screen will look exactly as it
    did earlier.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有更改模板，屏幕将看起来与之前完全一样。
- en: 'We may run into another problem with this solution. The asynchronous implementation
    of our inefficient Fibonacci algorithm may cause the Fibonacci service process
    to run out of memory. In the Node.js FAQ, [https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ),
    it''s suggested to use the `--max_old_space_size` flag. You''d add this in `package.json`
    as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到这个解决方案的另一个问题。我们低效的斐波那契算法的异步实现可能会导致斐波那契服务进程耗尽内存。在Node.js常见问题解答（[https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ)）中，建议使用`--max_old_space_size`标志。你可以在`package.json`中添加如下：
- en: '[PRE80]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: However, the FAQ also says that if you're running into maximum memory space
    problems, your application should probably be refactored. This gets back to our
    point several pages ago that there are several approaches to addressing performance
    problems, one of which is the algorithmic refactoring of your application.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，常见问题解答（FAQ）也提到，如果你遇到最大内存空间问题，你的应用程序可能需要进行重构。这回到了我们之前提到的几个页面，即解决性能问题的几种方法之一是应用算法重构。
- en: Why go to the trouble of developing this REST server when we could just directly
    use `fibonacciAsync`?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要费心开发这个REST服务器，而不是直接使用`fibonacciAsync`？
- en: We can now push the CPU load for this heavyweight calculation to a separate
    server. Doing so would preserve CPU capacity on the frontend server so it can
    attend to web browsers. GPU co-processors are now widely used for numerical computing
    and can be accessed via a simple network API. The heavy computation can be kept
    separate, and you can even deploy a cluster of backend servers sitting behind
    a load balancer, evenly distributing requests.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个重量级计算的CPU负载推送到一个单独的服务器。这样做将保留前端服务器的CPU容量，以便它可以处理网络浏览器。GPU协处理器现在在数值计算中得到了广泛的应用，并且可以通过简单的网络API访问。重计算可以保持独立，你甚至可以部署一个位于负载均衡器后面的后端服务器集群，均匀地分配请求。
- en: What we've demonstrated is that it's possible to implement simple multitier
    REST services in a few lines of Node.js and Express.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所展示的是，在Node.js和Express中，只需几行代码就可以实现简单的多层REST服务。
- en: Some RESTful modules and frameworks
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些RESTful模块和框架
- en: 'Here are a few available packages and frameworks to assist your REST-based
    projects:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可用的包和框架可以帮助你的基于REST的项目：
- en: 'Restify ([>http://restify.com/](http://restify.com/)): This offers both client-side
    and server-side frameworks for both ends of REST transactions. The server-side
    API is similar to Express.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Restify ([>http://restify.com/](http://restify.com/))：这为REST事务的两端提供了客户端和服务器端框架。服务器端API与Express类似。
- en: 'Loopback ([http://loopback.io/](http://loopback.io/)): This is an offering
    from StrongLoop, the current sponsor of the Express project. It offers a lot of
    features and is, of course, built on top of Express.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loopback ([http://loopback.io/](http://loopback.io/))：这是StrongLoop提供的产品，目前是Express项目的赞助商。它提供了许多功能，当然，它是建立在Express之上的。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about Node's HTTP support, implementing web
    applications, and REST service implementation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多关于Node的HTTP支持、实现Web应用程序和REST服务实现的知识。
- en: 'Now we can move on to implementing a more complete application: one for taking
    notes. We will use the Notes application for several upcoming chapters as a vehicle
    to explore the Express application framework, database access, deployment to cloud
    services or on your own server, and user authentication.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续实现一个更完整的应用程序：一个用于记笔记的应用。我们将使用笔记应用程序在接下来的几个章节中作为探索Express应用程序框架、数据库访问、部署到云服务或自己的服务器以及用户认证的载体。
- en: In the next chapter, we will build the basic infrastructure.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建基本的基础设施。
