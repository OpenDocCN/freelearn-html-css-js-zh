<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Talking to Your App</h1></div></div></div><p>The media capabilities of our mobile devices are frankly amazing, especially when you consider where we were five, ten, fifteen years ago. The first mass-produced MP3 player was the <em>SaeHan/Eiger MPMan</em> (<a class="ulink" href="http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan">http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan</a>) introduced in 1997. The device had 32 MB of storage, enough for roughly 6 to 7 songs (assuming 1 MB/minute, 5m per song). While it may seem paltry by today's standards, it was a revolution and spawned a new way to listen to music.</p><p>Today's devices are now so much more, portable entertainment devices that can play games, video, and all sorts of audio. Being able to play sounds in your app is critical, and there are few apps that could make the case for having no sound whatsoever. Although a bit on the extreme side, perhaps, <em>TweetBot</em> is a classic example of an app that is enhanced by the sound it produces via the user's interactions.</p><p>Today's devices can also record audio for a variety of reasons, whether it be for a reminder later, recording a speech or meeting, and more. There are a lot of apps that wouldn't require this functionality, but for a certain segment, it's important that you know how to record.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>What do we build?</h1></div></div></div><p>We will build a <a id="id506" class="indexterm"/>fairly simple app with one purpose: to store and play back the end user's recordings, whatever they may be. They could be a short memo or a meeting.<a id="id507" class="indexterm"/> We'll be using a lot of our existing framework, and there's not a lot visually, but there is a lot going on underneath to support audio playback and recording.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>What does it do?</h2></div></div></div><p>In this <a id="id508" class="indexterm"/>project, you will be able to play and record audio. We'll be recording to the <code class="literal">WAV</code> format for iOS and the <code class="literal">AMR</code> format for Android. Other platforms support other formats, so if you are targeting a platform other than Android or iOS, be sure to double-check what formats are supported.</p><p>You'll also be able to play audio; we'll support both <code class="literal">MP3 </code>and <code class="literal">WAV </code>on Android and <code class="literal">WAV </code>on iOS (the primary reason we exclude MP3 for iOS here is a bug that causes <code class="literal">MP3</code> <code class="literal">format audios</code> to render with horrible quality and extremely loud volume).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Why is it great?</h2></div></div></div><p>There's another<a id="id509" class="indexterm"/> reason why this project is so great: we're introducing gesture support. That's right: <em>swipe-to-delete</em> and <em>long-press</em> will feature in this app as well.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>How are we going to do it?</h2></div></div></div><p>We'll be<a id="id510" class="indexterm"/> following the same task list as our previous projects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the user interface and the look and feel</li><li class="listitem" style="list-style-type: disc">Designing the data model</li><li class="listitem" style="list-style-type: disc">Implementing the data model</li><li class="listitem" style="list-style-type: disc">Implementing gesture support</li><li class="listitem" style="list-style-type: disc">Implementing the main view</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>What do I need to get started?</h2></div></div></div><p>As always, <a id="id511" class="indexterm"/>go ahead and create your project following the same steps we've used in previous projects. You might also want to refer to the PhoneGap Media API documentation, as we'll be using it extensively. (refer to <a class="ulink" href="http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media">http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media</a>)</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Designing the user interface and the look and feel</h1></div></div></div><p>This app will be<a id="id512" class="indexterm"/> <em>visually</em> simpler than any of our previous apps.<a id="id513" class="indexterm"/> We only need one view, and the look of that view has already largely been defined by our Android interfaces for the last two projects. That's right; the view is essentially a list of items, nothing fancy.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>Getting on with it</h2></div></div></div><p>There are some things we will change in our list of items. Essentially we will clean up the list by hiding the action icons (delete, share, and so on) and showing them only when we receive a gesture. We will also include <em>Play</em> and <em>Pause</em> buttons<a id="id514" class="indexterm"/> in the list item instead of any particular document image. After all, we don't have album art for recordings the user creates themselves.</p><p>Let's look at the mockup<a id="id515" class="indexterm"/>:</p><div><img src="img/9403_05_01.jpg" alt="Getting on with it"/></div><p>As you can see, this mockup is pretty similar to the Android file listings we've had in our previous projects. It is substantially different than the document-based list on iOS, but the preceding view is common enough that users will know how to use it.</p><p>The icons in the list will not be document icons. Instead we'll use play and pause icons to show the state of the document. If it is currently being played, we'll show the pause icon, and if it is not being played, we'll show the play icon.</p><p>The <strong>Delete</strong> button<a id="id516" class="indexterm"/> on the right is shown by using the horizontal swipe gesture; these buttons are otherwise invisible.</p><p>Where are the rest of our<a id="id517" class="indexterm"/> document actions, like rename or copy, you ask? That's a great question. They're still available, but only when a user holds their finger on the item for more than a second. At that point, the long-press swipe is recognized, and a small menu will pop up asking the user what they would like to do.</p><p>The <strong>Record</strong> button<a id="id518" class="indexterm"/> is intended to start a recording session. It will ask for the filename, and once entered, it will display another pop up indicating that it is recording. The user can stop recording by pressing the <em>stop</em> button on the pop up. We'll also display a microphone icon on this pop up to indicate to the user that the app is recording.</p><p>Now that we have the mockup finished, let's work on our graphical design in our graphics editor. The result will be as follows:</p><div><img src="img/9403_05_02.jpg" alt="Getting on with it"/></div><p>The following are also some icons that we created as part of our mockup. You can find their images in the <a id="id519" class="indexterm"/>code files available for this project.</p><p>A microphone is shown as follows:</p><div><img src="img/9403_05_03.jpg" alt="Getting on with it"/></div><p>A play button can be seen as follows:</p><div><img src="img/9403_05_04.jpg" alt="Getting on with it"/></div><p>And a pause button will be as follows:</p><div><img src="img/9403_05_05.jpg" alt="Getting on with it"/></div><p>Notice that the<a id="id520" class="indexterm"/> background canvas and the navigation bar is the same as our previous project. All we really need for this task are the icons for the play state, the pause state, and the microphone. Everything else can be handled with CSS and HTML.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec104"/>What did we do?</h2></div></div></div><p>In this section, we've designed the user interface and defined the feel of the app. We've also designed the icons we'll be needing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Designing the data model</h1></div></div></div><p>The data model <a id="id521" class="indexterm"/>isn't terribly complex, but it is definitely a bit different from our previous projects. The document collection is fundamentally the <a id="id522" class="indexterm"/>same, so we won't cover that model, but the document itself is different. It must load and manage audio resources instead of regular files.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Getting on with it</h2></div></div></div><p>Our model is defined as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>VoiceRecDocument</p>
</th><th style="text-align: left" valign="bottom"> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>- fileEntry</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- filename</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- fileType</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- completion</p>
</td><td style="text-align: left" valign="top">
<p>Function</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- failure</p>
</td><td style="text-align: left" valign="top">
<p>Function</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- state</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- title</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- media</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- position</p>
</td><td style="text-align: left" valign="top">
<p>Number</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- duration</p>
</td><td style="text-align: left" valign="top">
<p>Number</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- playing</p>
</td><td style="text-align: left" valign="top">
<p>Boolean</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- recording</p>
</td><td style="text-align: left" valign="top">
<p>Boolean</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- paused</p>
</td><td style="text-align: left" valign="top">
<p>Boolean</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- positionTimer</p>
</td><td style="text-align: left" valign="top">
<p>Timer ID</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- durationTimer</p>
</td><td style="text-align: left" valign="top">
<p>Timer ID</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- getFileName()</p>
</td><td rowspan="18" style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>- setFileName()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- initializeMediaObject()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- isPlaying()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- isRecording()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- updatePosition()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- updateDuration()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- getPlaybackPosition()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- setPlaybackPosition()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- getDuration()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- startPlayback()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- pausePlayback()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- releaseResources()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- stopPlayback()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- startRecording()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- stopRecording()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- dispatchFailure()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>- dispatchSuccess()</p>
</td></tr></tbody></table></div><p>Let's go over <a id="id523" class="indexterm"/>what each of these properties and methods should do:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">fileEntry</code> property<a id="id524" class="indexterm"/> stores the file entry obtained from the File API.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">fileName</code> property<a id="id525" class="indexterm"/> stores the full path to the audio file.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">fileType</code> property<a id="id526" class="indexterm"/> stores the extension of the audio file (WAV, MP3, and so on).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">completion</code><a id="id527" class="indexterm"/> and <code class="literal">failure</code><a id="id528" class="indexterm"/> methods point to the <code class="literal">completion</code> and <code class="literal">failure</code> functions.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">title</code> property<a id="id529" class="indexterm"/> stores the name of the file (minus the path and extension).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">media</code> property<a id="id530" class="indexterm"/> will store the <code class="literal">Media</code> object from the <code class="literal">Media</code> API.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">position</code> property<a id="id531" class="indexterm"/> will indicate the current playback position in seconds.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">duration</code> property<a id="id532" class="indexterm"/> will indicate the current recording duration or length of the file for playback (in seconds).</li><li class="listitem" style="list-style-type: disc"><code class="literal">playing</code><a id="id533" class="indexterm"/>, <code class="literal">recording</code><a id="id534" class="indexterm"/>, <code class="literal">paused</code><a id="id535" class="indexterm"/> are internal state methods used to track what is happening inside the object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">positionTimer</code><a id="id536" class="indexterm"/> and <code class="literal">durationTimer</code><a id="id537" class="indexterm"/> are timer IDs used to update the position and duration properties.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">get</code>/<code class="literal">setFileName</code> methods<a id="id538" class="indexterm"/> gets/sets<a id="id539" class="indexterm"/> the <code class="literal">fileName</code> property.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">isPlaying</code>/<code class="literal">isRecording</code><a id="id540" class="indexterm"/> methods<a id="id541" class="indexterm"/> return the respective property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">updatePosition</code>/<code class="literal">updateDuration</code> <a id="id542" class="indexterm"/>are <a id="id543" class="indexterm"/>internal methods used to update the <code class="literal">position</code> and <code class="literal">duration</code> property during playback and recording.</li><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>/<code class="literal">setPlaybackPosition</code><a id="id544" class="indexterm"/> will get or set the current playback position.<a id="id545" class="indexterm"/> If setting, this will use the <code class="literal">seekTo()</code> method of the <code class="literal">Media</code> API.</li><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>/<code class="literal">pause</code>/<code class="literal">stopPlayback</code> will start, pause, or stop playback.</li><li class="listitem" style="list-style-type: disc"><code class="literal">releaseResources</code><a id="id546" class="indexterm"/> will allow the memory consumed by the media file to be released back to the device so that we don't run out of memory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">start</code><a id="id547" class="indexterm"/>/<code class="literal">stopRecording</code><a id="id548" class="indexterm"/> will start or stop recording.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dispatchFailure</code><a id="id549" class="indexterm"/>/<code class="literal">Success</code><a id="id550" class="indexterm"/> will call the <code class="literal">failure</code> or <code class="literal">completion</code> method.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec106"/>What did we do?</h2></div></div></div><p>In this task, we defined the model for <code class="literal">VoiceRecDocument</code> as well as the various interactions that go on internally.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Implementing the data model</h1></div></div></div><p>Now that <a id="id551" class="indexterm"/>we've designed <a id="id552" class="indexterm"/>the model, let's go ahead and implement it.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec107"/>Getting ready</h2></div></div></div><p>Like in our previous projects, we'll have two data models: the first one to deal with the collection of playable files, and the second one to deal with handling a specific playable file. The first, <code class="literal">VoiceRecDocumentCollection.js</code> is quite similar to our previous projects, and so we <a id="id553" class="indexterm"/>won't go over it in this task. But the <code class="literal">VoiceRecDocument.js</code> file is very different, so go ahead and open it up (it's in the <code class="literal">www/models</code> directory), so you can follow along.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec108"/>Getting on with it</h2></div></div></div><p>Let's start<a id="id554" class="indexterm"/> using the following code snippet:</p><div><pre class="programlisting">DOC.VoiceRecDocument = function(theFileEntry, completion, failure)
{
  var self = this;
  self.fileEntry = theFileEntry;
  self.fileName = self.fileEntry.fullPath;
  self.fileType = PKUTIL.FILE.getFileExtensionPart(self.fileName);
  self.completion = completion;
  self.failure = failure;
  self.state = "";</pre></div><p>As in our prior projects, the incoming parameters include a file entry obtained from the <code class="literal">File</code> API. We'll use this to determine the name of the audio file to play as well as its type. We're using some new functions, introduced in this version of the framework, to do work with the various portions that make up a file, namely, the path, the filename, and the file extension. Earlier, we use <code class="literal">PKUTIL.FILE.getFileExtensionPart()</code> to obtain the type of the file, whether it is an MP3, WAV, or something else.</p><div><pre class="programlisting">  self.title = PKUTIL.FILE.getFileNamePart(self.fileName);
  self.media = null;
  self.position = 0;
  self.duration = 0;
  self.playing = false;
  self.recording = false;
  self.paused = false;
  self.positionTimer = -1;
  self.durationTimer = -1;</pre></div><p>Here we define several properties that we will use to keep track of the various states and timers we need to use to properly manage our audio:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">title</code>: This <a id="id555" class="indexterm"/>property <a id="id556" class="indexterm"/>gives the title of the file, essentially the filename minus the path and extension.</li><li class="listitem" style="list-style-type: disc"><code class="literal">media</code>: This property <a id="id557" class="indexterm"/>gives the <code class="literal">Media</code> object <a id="id558" class="indexterm"/>provided by PhoneGap. This property will be set whenever the program needs to play a sound or record something.</li><li class="listitem" style="list-style-type: disc"><code class="literal">position</code>: This <a id="id559" class="indexterm"/>property gives the<a id="id560" class="indexterm"/> approximate position in the sound file for playback. It's approximate because it is updated every few milliseconds with the position. We'll discuss why in a bit.</li><li class="listitem" style="list-style-type: disc"><code class="literal">duration</code>: This<a id="id561" class="indexterm"/> property gives the <a id="id562" class="indexterm"/>duration of the sound file (if playing), or the approximate duration of the recording (while, or after, recording).</li><li class="listitem" style="list-style-type: disc"><code class="literal">playing</code>, <code class="literal">recording</code>, <code class="literal">paused</code>: These<a id="id563" class="indexterm"/> are simply<a id="id564" class="indexterm"/> Boolean variables <a id="id565" class="indexterm"/>intended to make it easy to determine what we're doing. Are we playing the file, recording a file, and, if we're playing, are we paused?</li><li class="listitem" style="list-style-type: disc"><code class="literal">durationTimer</code>, <code class="literal">positionTimer</code>: Timer IDs are used to track the intervals that get created whenever we load a<a id="id566" class="indexterm"/> media file<a id="id567" class="indexterm"/> or prepare one for recording. The <code class="literal">durationTimer</code> property updates the <code class="literal">duration</code> property, and the <code class="literal">positionTimer</code> property updates the position.<div><pre class="programlisting">  self.getFileName = function()
  {
    return self.fileName;
  }

  self.setFileName = function(theFileName)
  {
    self.theFileName = theFileName;
    self.fileType = PKUTIL.FILE.getFileExtensionPart(self.fileName);
    self.title = PKUTIL.FILE.getFileNamePart(self.fileName);
  }</pre></div></li></ul></div><p>The preceding <a id="id568" class="indexterm"/>code snippet handles getting and setting the<a id="id569" class="indexterm"/> filename. If we set a filename, we have to update the filename, type, and title.</p><div><pre class="programlisting">  self.initializeMediaObject = function()
  {</pre></div><p>This method is a very important method; we'll be calling it at the top of most of our methods that work with playback or recording. This is to ensure that the <code class="literal">media</code> property is properly initialized. But it is also to ensure a few other details are correctly set up, as follows:</p><div><pre class="programlisting">    if (self.media == null)
    {
      if (PKDEVICE.platform()=="android")
      {
        self.fileName = self.fileName.replace ("file://","");
      }</pre></div><p>First, we do these steps if and only if we don't already have a <code class="literal">media</code> object at hand. If we do, there's no need to initialize it again.</p><p>Secondly, we check if we're running on Android. If we are, the <code class="literal">file://</code> prefix that comes out of the <code class="literal">File</code> API will confuse the <code class="literal">Media</code> APIs, and so we remove it.</p><div><pre class="programlisting">      self.media = new Media(self.fileName, self.dispatchSuccess, self.dispatchFailure);</pre></div><p>Next, <a id="id570" class="indexterm"/>we initialize <a id="id571" class="indexterm"/>the <code class="literal">media</code> property with a new <code class="literal">Media</code> object. This object requires the filename of the audio file, and two functions: one for when various audio functions complete successfully (generally only when playback or recording has stopped), and another for when something goes wrong.</p><div><pre class="programlisting">      self.positionTimer = setInterval(self.updatePosition, 250);
      self.durationTimer = setInterval(self.updateDuration, 250);
    }
  }</pre></div><p>Finally, we also set up our two timers to update every quarter of a second. These times could be made faster or slower depending upon the granularity of updates you like, but <code class="literal">250</code> milliseconds seems to be enough.</p><div><pre class="programlisting">  self.isPlaying = function()
  {
    return self.playing;
  }

  self.isRecording = function()
  {
    return self.recording;
  }</pre></div><p>Of course, like any good model, we need to provide methods to indicate our state. Hence, <code class="literal">isPlaying</code> and <code class="literal">isRecording</code> are used in the preceding code snippet.</p><div><pre class="programlisting">  self.updatePosition = function()
  {
    if (self.playing)
    {
      self.media.getCurrentPosition(function(position)
      {
        self.position = position;
      }, self.dispatchFailure);
    } else
    {
      if (self.recording)
      {
        self.position += 0.25;
      } else
      {
        self.position = 0;
      }
    }
  }</pre></div><p>If you recall, this function is called continuously during playback and recording. If playing, we ask <a id="id572" class="indexterm"/>the <code class="literal">Media</code> API what the current position is, but we have to supply a callback method in order to actually find out what the <a id="id573" class="indexterm"/>position is. This should usually be called nearly instantly, but we can't guarantee it, so this is why we have encapsulated obtaining the position somewhat. We'll define a <code class="literal">getPosition()</code> method later that just looks at the <code class="literal">position</code> property instead of having to do the callback every time we want to know where we are in the audio file.</p><div><pre class="programlisting">  self.updateDuration = function()
  {
    if (self.media.getDuration() &gt; -1)
    {
      self.duration = self.media.getDuration();
      clearInterval(self.durationTimer);
      self.durationTimer = -1;
    } else
    {
      self.duration--;
      if (self.duration &lt; -20)
      {
        self.duration = -1;
        clearInterval(self.durationTimer);
        self.durationTimer = -1;
      }
    }
  }</pre></div><p>Obtaining the duration is even harder than obtaining the current position, mainly because it is quite possible that the <code class="literal">Media</code> API is streaming a file from the Internet rather than playing a local file. Therefore, the duration may take some time to obtain.</p><p>For as long as the duration timer is running, we'll ask the <code class="literal">Media</code> API if it has a duration for the file yet. If it doesn't, it'll return <code class="literal">-1</code>. If it does return a value greater than <code class="literal">-1</code>, we can stop the timer, since once we get a duration, it isn't likely to change.</p><p>There's no need to keep asking for the duration forever, especially if we can't determine the duration, so we use the negative numbers <code class="literal">-1</code> to <code class="literal">-20</code> of our <code class="literal">duration</code> property as a kind of timeout. We subtract one each time we fail to obtain a valid duration, and if we go below <code class="literal">-20</code>, we give up by stopping the timer.</p><div><pre class="programlisting">  self.getPlaybackPosition = function()
  {
    return self.position;
  }

  self.setPlaybackPosition = function(newPosition)
  {
    self.position = newPosition;
    self.initializeMediaObject();
    self.media.seekTo(newPosition * 1000);
  }</pre></div><p>Getting the playback position is now simple, we just return our own <code class="literal">position</code> property. But sometimes<a id="id574" class="indexterm"/> we need to change the current playback position. <a id="id575" class="indexterm"/>To do this, we use the <code class="literal">seekTo()</code> method of the <code class="literal">Media</code> API to adjust the position. For whatever reason, the position used in the <code class="literal">seekTo()</code> method is in milliseconds, while the position we obtain constantly with our timer is in seconds, hence the multiplication by <code class="literal">1000</code>.</p><div><pre class="programlisting">  self.getDuration = function()
  {
    return self.duration;
  }

  self.startPlayback = function()
  {
    self.initializeMediaObject();
    self.media.play();
    self.paused = false;
    self.recording = false;
    self.playing = true;
  }

  self.pausePlayback = function()
  {
    self.initializeMediaObject();
    self.media.pause();
    self.playing = false;
    self.paused = true;
    self.recording = false;
  }</pre></div><p>Starting playback is actually very simple: once we initialize the object, we just call the <code class="literal">play()</code> method on it. Playback will start as soon as possible. We also set our state properties to indicate that we are playing.</p><p>Once playing, we can also pause easily: we just have to call the <code class="literal">pause()</code> method. We update our state to reflect that we are paused as well.</p><div><pre class="programlisting">  self.releaseResources = function()
  {
    if (self.recording)
    {
      self.stopRecording();
    }
    if (self.positionTimer &gt; -1)
    {
      clearInterval(self.positionTimer);
    }
    if (self.durationTimer &gt; -1)
    {
      clearInterval(self.durationTimer);
    }
    self.durationTimer = -1;
    self.positionTimer = -1;
    self.media.release();
    self.media = null;
  }</pre></div><p>Since media files can consume a lot of memory, whenever they aren't in use, they should be released <a id="id576" class="indexterm"/>from memory. When we release the file, we also need to stop the timers, if running).</p><div><pre class="programlisting">  self.stopPlayback = function()
  {
    self.initializeMediaObject();
    self.media.stop();
    self.isPlaying = false;
    self.isPaused = false;
    self.isRecording = false;
  }</pre></div><p>Stopping playback is quite simple: just call the <code class="literal">stop()</code> method instead of the <code class="literal">pause() method</code>. The <a id="id577" class="indexterm"/>difference between the two is that pausing playback allows a subsequent call to the <code class="literal">play() method</code> to resume immediately where we paused. Calling the <code class="literal">stop()</code> method will reset our position to zero, so the next <code class="literal">play()</code> method will start from the beginning.</p><div><pre class="programlisting">  self.startRecording = function()
  {
    self.initializeMediaObject();
    self.media.startRecord();
    self.isPlaying = false;
    self.isPaused = false;
    self.isRecording = true;
  }

  self.stopRecording = function()
  {
    self.initializeMediaObject();
    self.media.stopRecord();
    self.isPlaying = false;
    self.isPaused = false;
    self.isRecording = false;
  }</pre></div><p>Recording is similarly easy: we just call <code class="literal">startRecord()</code> or <code class="literal">stopRecord()</code>. There is no functionality for providing support for pausing in the middle of recording.</p><div><pre class="programlisting">  self.dispatchFailure = function(e)
  {
    console.log("While " + self.State + ", encountered error: " + e.target.error.code);
    if (self.failure)
    {
      self.failure(e);
    }
  }</pre></div><p>Our <code class="literal">failure</code> method<a id="id578" class="indexterm"/> is pretty simple. If an error occurs, <a id="id579" class="indexterm"/>we'll log it, and then call the <code class="literal">failure</code> method given when creating this object.</p><div><pre class="programlisting">  self.dispatchSuccess = function()
  {
    if (self.completion)
    {
      self.completion();
    }
  }
}</pre></div><p>The <code class="literal">success</code> function is even simpler: we just call the <code class="literal">completion()</code> method passed in when creating the object.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec109"/>What did we do?</h2></div></div></div><p>In this task, we created the data model for a specific audio file as well as the methods for initiating, pausing, and stopping playback, and those for initiating and stopping recording.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec110"/>What else do I need to know?</h2></div></div></div><p>The <code class="literal">completion</code> method is generally called at the end of playback, though it can be called for other reasons as well. In general, one would use this to clean up the media object, but if it is called when not expected, the result would be an abrupt stop of playback.</p><p>The other important issue is that each platform supports only certain media files for playback and even different ones for recording. Here's a short list:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Platform</p>
</th><th style="text-align: left" valign="bottom">
<p>Plays</p>
</th><th style="text-align: left" valign="bottom">
<p>Records</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>iOS</p>
</td><td style="text-align: left" valign="top">
<p>WAV</p>
</td><td style="text-align: left" valign="top">
<p>WAV</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Android</p>
</td><td style="text-align: left" valign="top">
<p>MP3,WAV, 3GR</p>
</td><td style="text-align: left" valign="top">
<p>3GR</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Implementing gesture support</h1></div></div></div><p>Gestures<a id="id580" class="indexterm"/> are<a id="id581" class="indexterm"/> a critical component of most mobile <a id="id582" class="indexterm"/>platforms these days, and users expect the apps they use to support them. A gesture can be fairly elaborate (say, drawing a shape, or using multiple fingers) or simple (just pressing an item for a certain time), but it is necessary that you get used to the idea.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec111"/>Getting ready</h2></div></div></div><p>When working on the device using native code, gesture recognition is typically provided to us nearly for free. That is, the framework provided by the OS does the hard work of recognizing a gesture.</p><p>Unfortunately, with PhoneGap, we lose that for free part and have to implement our gestures on our own. That's where <code class="literal">ui-gestures.js</code> in the <code class="literal">www/framework</code> directory comes in. Go ahead and open it up so that we can walk through some of what it does.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec112"/>Getting on with it</h2></div></div></div><p>Let's take a look at the following code, starting at the top:</p><div><pre class="programlisting">var GESTURES = GESTURES || {};

GESTURES.consoleLogging = false;

GESTURES.SimpleGesture = function(element)
{</pre></div><p>The first thing we do is define a new namespace called <code class="literal">GESTURES</code>. Then we create a <code class="literal">SimpleGesture</code> class<a id="id583" class="indexterm"/> within it. <code class="literal">SimpleGesture</code> will be the basis for all single-finger gestures that we support, <a id="id584" class="indexterm"/>which includes a long press gesture, a horizontal swipe gesture, and a vertical swipe gesture.</p><div><pre class="programlisting">  var self = this;

  self.theElement =  {  };

  self._touchStartX = 0;
  self._touchStartY = 0;
  self._touchX = 0;
  self._touchY = 0;
  self._deltaX = 0;
  self._deltaY = 0;
  self._duration = 0;
  self._timerId = -1;
  self._distance = 0;
  self._event =   {  };
  self._cleared = false;</pre></div><p>There's a lot of properties that go into detecting gestures. Essentially, we have to keep track of where a touch first started, and then where that touch ended (<code class="literal">touchStartX</code>, <code class="literal">touchStartY</code>, <code class="literal">touchX</code>, <code class="literal">touchY</code>). We also need to know how far away that final touch was from when it started (<code class="literal">deltaX</code>, <code class="literal">deltaY</code>, <code class="literal">distance</code>). In order to prevent gestures from being recognized when someone holds their finger on the screen for a long time to slowly scroll through a list, we also track the duration of the touch. If it goes for too long, we refuse to detect a gesture and possibly interrupt the user performing some other operation.</p><p>We also keep track of whether or not the gesture has been recognized or cancelled. This is done with the <code class="literal">_cleared</code> property. If <code class="literal">_cleared</code> is <code class="literal">true</code>, the gesture has been recognized or cancelled and must not be recognized again (until the user lifts their finger from the screen).</p><div><pre class="programlisting">  self.attachToElement = function(element)
  {
    self.theElement = element;
    self.theElement.addEventListener("touchstart", self.touchStart, false);
    self.theElement.addEventListener("touchmove", self.touchMove, false);
    self.theElement.addEventListener("touchend", self.touchEnd, false);

    self.theElement.addEventListener("mousedown", self.mouseDown, false);
    self.theElement.addEventListener("mousemove", self.mouseMove, false);
    self.theElement.addEventListener("mouseup", self.mouseUp, false);

  }</pre></div><p>The first step, however, is to attach all our event listeners to a particular element. We attach six, namely, <code class="literal">touchstart</code>, <code class="literal">touchmove</code>, <code class="literal">touchend</code>, <code class="literal">mousedown</code>, <code class="literal">mousemove</code>, and <code class="literal">mouseup</code>. The first <a id="id585" class="indexterm"/>three are for WebKit browsers; the last three are for Windows Phone browsers. (Since gesture support is part of the YASMF framework, it needs to support more than just iOS and Android, hence the support here for WP7.)</p><div><pre class="programlisting">  self.recognizeGesture = function(o)
  {
    if (GESTURES.consoleLogging)
    {
      console.log("default recognizer...");
    }
  }
  self.attachGestureRecognizer = function(fn)
  {
    self.recognizeGesture = fn;
  }</pre></div><p>Part of what makes the <code class="literal">SimpleGesture</code> class so flexible is that it allows the <code class="literal">recognizeGesture()</code> method<a id="id586" class="indexterm"/> in the prior code snippet to be overridden using <code class="literal">attachGestureRecognizer()</code>
<a id="id587" class="indexterm"/>. This also means that as part of the default implementation, we don't recognize any gesture at all yet. It's just a placeholder for the recognition engines later on.</p><div><pre class="programlisting">  self.updateGesture = function()
  {
    self._duration += 100;
    self._distance = Math.sqrt((self._deltaX * self._deltaX) + (self._deltaY * self._deltaY));
    if (GESTURES.consoleLogging)
    {
      console.log("gesture: start: (" + self._touchStartX + "," + self._touchStartY + ") current: (" + self._touchX + "," + self._touchY + ") delta: (" + self._deltaX + "," + self._deltaY + ") delay: " + self._duration + "ms, " + self._distance + "px");
    }     if (!self._cleared)
    {
      self.recognizeGesture(self);
    }
  }</pre></div><p>When a suspected gesture is in progress, we call the <code class="literal">updateGesture()</code> method<a id="id588" class="indexterm"/> every <code class="literal">100</code> milliseconds. It will then helpfully <a id="id589" class="indexterm"/>calculate the distance from the initial touch and call the <code class="literal">recognizeGesture()</code> method<a id="id590" class="indexterm"/>, assuming that a gesture hasn't already been recognized yet.</p><p>Try to work out how we obtain the distance; you should recognize it from your geometry lessons.</p><div><pre class="programlisting">  self.clearEvent = function()
  {
    if (self._cleared)
    {
      if (self._event.cancelBubble)
      {
        self._event.cancelBubble();
      }
      if (self._event.stopPropagation)
      {
        self._event.stopPropagation();
      }
      if (self._event.preventDefault)
      {
        self._event.preventDefault();
      } else
      {
        self._event.returnValue = false;
      }
    }
    if (self._timerId &gt; -1)
    {
      clearInterval(self._timerId);
      self._timerId = -1;
    }
    self._cleared = true;
  }</pre></div><p>When we recognize a gesture or determine that there is no gesture at all, there's really no reason to continue tracking the fingers and such, so the preceding method cancels out all the timers. However, it only prevents the default actions that would otherwise occur (such as clicks) if the gesture itself is physically recognized (not just cancelled). This is because as part of the recognition process, we can call this method once (cancelled) or twice (recognized). The second time through we'll cancel all the default actions. This means that attaching gestures to elements won't prevent the click events from firing as long as gesture isn't recognized.</p><div><pre class="programlisting">  self.eventStart = function()
  {
    if (GESTURES.consoleLogging)
    {
      console.log("eventstart");
    }
    self._duration = 0;
    self._deltaX = 0;
    self._deltaY = 0;
    self._cleared = false;
    self._touchStartX = self._touchX;
    self._touchStartY = self._touchY;
    self._timerId = setInterval(self.updateGesture, 100);
  }</pre></div><p>
<code class="literal">eventStart()</code> is a<a id="id591" class="indexterm"/> fairly generic function. All it does is clear out some of our properties and then set others <a id="id592" class="indexterm"/>to the first touch point. It also starts the timer that calls the <code class="literal">updateGesture</code> method.<a id="id593" class="indexterm"/>
</p><div><pre class="programlisting">  self.touchStart = function(event)
  {
    if (GESTURES.consoleLogging)
    {
      console.log("touchstart");
    }
    if (event)
    {
      self._touchX = event.touches[0].screenX;
      self._touchY = event.touches[0].screenY;
      self._event = event;
    } else
    {
      self._touchX = window.event.screenX;
      self._touchY = window.event.screenY;
      self._event = window.event;
    }
    self.eventStart();
  }

  self.mouseDown = function(event)
  {
    if (GESTURES.consoleLogging)
    {
      console.log("mousedown");
    }
    if (event)
    {
      self._touchX = event.screenX;
      self._touchY = event.screenY;
      self._event = event;
    } else
    {
      self._touchX = window.event.screenX;
      self._touchY = window.event.screenY;
      self._event = window.event;
    }
    self.eventStart();
  }</pre></div><p>You may wonder why we have such similar handlers for <code class="literal">touchstart</code> and <code class="literal">mousedown</code>. This is because this part of the framework can technically live outside of the framework. That means it could<a id="id594" class="indexterm"/> recognize mouse events on a desktop computer as well. The other thing, however, to remember is that WP7 thinks touches are mouse events, not touch events, which is why we have to keep track of the difference. Note that we call the <code class="literal">eventStart()</code> method to do the stuff that is common to each methodology.</p><div><pre class="programlisting">  self.eventMove = function()
  {
    if (GESTURES.consoleLogging)
    {
      console.log("eventmove");
    }
    self._deltaX = self._touchX - self._touchStartX;
    self._deltaY = self._touchY - self._touchStartY;

  }</pre></div><p>When the touch moves, <code class="literal">eventMove</code> will eventually be called by <code class="literal">touchMove()</code> or <code class="literal">mouseMove()</code>. Their code is pretty similar to <code class="literal">touchStart</code>/<code class="literal">mouseStart()</code> so we won't cover their code here. The main point is that as the touch moves around, the deltas are continually updated so that when <code class="literal">updateGesture()</code> is called, it can accurately determine the distance.</p><div><pre class="programlisting">  self.eventEnd = function()
  {
    if (GESTURES.consoleLogging)
    {
      console.log("eventend");
    }
      elf.clearEvent();
  }</pre></div><p>When the finger is lifted from the screen, <code class="literal">eventEnd()</code> will be called from either <code class="literal">touchEnd()</code> or <code class="literal">mouseUp()</code>. We call <code class="literal">clearEvent()</code> to reset all the tracking and timers involved.</p><div><pre class="programlisting">  self.attachToElement(element);
}</pre></div><p>Finally, at the end of the object creation process, we attach the events to the incoming element. At that point, any gesture applied to the element will be tracked, but not yet recognized. That's what is covered in the next snippet:</p><div><pre class="programlisting">GESTURES.LongPressGesture = function(element, whatToDo, delayToRecognition, delayToCancel)
{</pre></div><p>Detecting a long press is probably the easiest kind of gesture. Essentially a long press is a touch that stays within a certain spot for a certain amount of time. Since humans aren't perfect, we have to <a id="id595" class="indexterm"/>allow some tolerance to how much a finger can wiggle during this time. Thus, we can't cancel the gesture the instant we detect some finger movement. That said, we should cancel the gesture if the finger movement goes outside of a specific radius (here we'll use 25 px), because the user may be doing a different gesture altogether (or none at all).</p><div><pre class="programlisting">  var myGesture = new GESTURES.SimpleGesture(element);</pre></div><p>First, we create a new <code class="literal">SimpleGesture</code> object. Then we're going to extend it using a poor man's inheritance. (It isn't really object-oriented inheritance, but it is good enough for what we need.)</p><div><pre class="programlisting">  myGesture._delayToRecognition = delayToRecognition || 1000;
  myGesture._delayToCancel = delayToCancel || 3000;
  myGesture._whatToDo = whatToDo;</pre></div><p>We then attach the <code class="literal">whatToDo</code>, <code class="literal">delayToRecognition</code>, and <code class="literal">delayToCancel</code> parameters to the new object. If the latter two aren't supplied, we give defaults of <code class="literal">3000</code> milliseconds and we'll ignore the gesture, and <code class="literal">1000</code> milliseconds to the recognition of a long press.</p><p>
<code class="literal">whatToDo</code> must be a function; we'll call it if the gesture is recognized.</p><div><pre class="programlisting">  myGesture.attachGestureRecognizer(function(o)
  {
    if (GESTURES.consoleLogging)
    {
      console.log("longpress recognizer...");
    }
    if (o._distance &lt; 25)
    {
      if (o._duration &gt;= o._delayToRecognition &amp;&amp; o._duration &lt;= o._delayToCancel)
      {
        o.clearEvent();
        o._whatToDo(o);
      }
    } </pre></div><p>Here's where we override the <code class="literal">SimpleGesture</code> object's <em>do-nothing</em> recognizer and attach our own. If the distance between the first position and current position of the touch is less than 25 px, we'll consider looking at the gesture. Then the duration of the gesture must be longer than the <code class="literal">delayToRecognition</code> (1000 milliseconds default) parameter, but not longer than the <code class="literal">delayToCancel</code> (3000 milliseconds default) parameter. If we fall in between, we'll clear the event and call <code class="literal">whatToDo()</code>.</p><div><pre class="programlisting">    else
    {
      o.clearEvent();
    }
  });</pre></div><p>On the other hand, if the distance is more than 25 px, the person isn't doing a long press. They're doing something else, so we cancel the gesture entirely.</p><div><pre class="programlisting">  return myGesture;
}


GESTURES.HorizontalSwipeGesture = function(element, whatToDo, radiusToRecognition, delayToCancel)
{</pre></div><p>Horizontal swipes are a little more complicated, but not by too much. First, we need to have a definition <a id="id596" class="indexterm"/>of horizontal. Again, the human finger is likely to wobble and wiggle a bit when making the gesture. We also need a minimum length; a movement horizontally of a couple pixels shouldn't be enough to trigger the gesture. Here we define a horizontal swipe as any swipe longer than 50 px and one that doesn't vary along the vertical axis by more than 25 px in either direction (50 px total).</p><p>We also do away with the <code class="literal">delayToRecognition</code> we used for long presses – that's where the length of the swipe comes into play.</p><div><pre class="programlisting">  var myGesture = new GESTURES.SimpleGesture(element);</pre></div><p>Just like for our long press, we'll create the new gesture from a <code class="literal">SimpleGesture</code> object.</p><div><pre class="programlisting">  myGesture._radiusToRecognition = radiusToRecognition || 50;
  myGesture._delayToCancel = delayToCancel || 3000;
  myGesture._whatToDo = whatToDo;</pre></div><p>Then we attach the various parameters. The <code class="literal">radiusToRecognition</code> parameter<a id="id597" class="indexterm"/> is really the length of the swipe. Anything inside that radius won't be considered at all, but anything outside the radius is long enough to be considered.</p><div><pre class="programlisting">  myGesture.attachGestureRecognizer(function(o)
  {
    if (GESTURES.consoleLogging)
    {
      console.log("horizontal recognizer...");
    }
    if (o._distance &gt; o._radiusToRecognition)
    {
      if (o._duration &lt;= o._delayToCancel)
      {
        if (Math.abs(o._deltaY) &lt; 25)
        {
          o.clearEvent();
          o._whatToDo(o);
        }
      }
    }
  });
  return myGesture;
}</pre></div><p>The recognizer itself is pretty easy; the distance between the first and current point must be greater than the <code class="literal">radiusToRecognition</code> parameter, the duration must not be longer than the <code class="literal">delayToCancel</code> (3000 milliseconds by default) parameter, and the finger must not have gone up or down more than <code class="literal">25</code> px from that first touch. If all these conditions are met, we've had a horizontal swipe, and we clear the event and call <code class="literal">whatToDo()</code>.</p><p>The vertical <a id="id598" class="indexterm"/>swipe is essentially identical except that instead of using <code class="literal">deltaY</code> in the earlier code, it uses <code class="literal">deltaX</code>. A vertical swipe is only valid if the finger doesn't vary on the horizontal axis by more than <code class="literal">25</code> px on either side. Since they are so similar, we won't go over the code.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec113"/>What did we do?</h2></div></div></div><p>In this task, we've looked at how to recognize three simple gestures, namely, the long press gesture, the horizontal swipe gesture, and the vertical swipe gesture. In the next task, we'll implement the gesture recognizers in order to provide the various actions we can perform on a document, such as copying, renaming, or deleting them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Implementing the main view</h1></div></div></div><p>Our main view is <a id="id599" class="indexterm"/>pretty simple visually, but it is definitely <a id="id600" class="indexterm"/>complex underneath. Let's take a look at how the final result will appear. First, this is how it looks when recording:</p><div><img src="img/9403_05_06.jpg" alt="Implementing the main view"/></div><p>Next, this is<a id="id601" class="indexterm"/> how it looks after the recording:</p><div><img src="img/9403_05_07.jpg" alt="Implementing the main view"/></div><p>If we swipe on the newly recorded item, we get the <strong>Delete</strong> button as shown in the next screenshot:</p><div><img src="img/9403_05_08.jpg" alt="Implementing the main view"/></div><p>If we long press on the <a id="id602" class="indexterm"/>recorded item, the following screen will appear:</p><div><img src="img/9403_05_09.jpg" alt="Implementing the main view"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec114"/>Getting ready</h2></div></div></div><p>Go ahead and<a id="id603" class="indexterm"/> open the <code class="literal">documentsView.js</code> file in <code class="literal">www/views</code> so that you can follow along.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec115"/>Getting on with it</h2></div></div></div><p>Let's first go over the HTML for our view. The first portion (with class <code class="literal">viewBackground</code>) is like all the previous projects, so we'll skip that portion and go straight to the template that shows each list item on the screen, seen in the following code block:</p><div><pre class="programlisting">&lt;div id="documentsView_documentTemplate" class="hidden"&gt;
  &lt;div class="documentContainer" 
    id="documentsView_item%INDEX%"&gt;
    &lt;div class="documentTapArea" 
      id="documentsView_item%INDEX%_area"
    onclick="documentsView.documentContainerTapped(%INDEX%);"&gt;
    &lt;/div&gt;
    &lt;div class="documentImage"&gt;
      &lt;img id="documentsView_item%INDEX%_img"
      src="img/playButton.png" border=0
      onclick="documentsView.documentContainerTapped(%INDEX%);
      "/&gt;
    &lt;/div&gt;
    &lt;div class="documentTitle"
    onclick="documentsView.documentContainerTapped(%INDEX%);"&gt;
      &lt;span&gt;%TITLE%&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="documentActions" 
      id="documentsView_actions%INDEX%"&gt;
      &lt;button class="destructive barButton" 
      id="documentsView_deleteButton%INDEX%"
      onclick="documentsView.deleteDocument(%INDEX%); return 
        false;"&gt;
        %DELETE%
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This template is similar to, though not exactly like, the template we used in prior projects. What we've done is to change the <code class="literal">documentImage</code> class of the <code class="literal">div</code> element into the state of the document. If it shows a <em>play</em> icon, this particular item can be tapped to start playback. If it shows <em>pause</em>, it can be tapped to pause playback.</p><p>The <strong>Delete</strong> button is contained within the <code class="literal">documentActions</code> class<a id="id604" class="indexterm"/> of the <code class="literal">div</code> element (which is hidden by default). When tapped, it'll call <code class="literal">deleteDocument()</code>
<a id="id605" class="indexterm"/> with the index of the item tapped.</p><p>All the other elements, such as the <code class="literal">title</code>, call <code class="literal">documentContainerTapped()</code>. This allows tapping on everything except the <strong>Delete</strong> button when visible to <em>start</em> or <em>pause</em> playback. If we didn't <a id="id606" class="indexterm"/>have these <code class="literal">onclick</code> handlers everywhere, some elements would not respond to touch like we would expect.</p><p>Now let's go over how the view works:</p><div><pre class="programlisting">  var documentsView = $ge("documentsView") ||  {  };
  documentsView.firstTime = true;
  documentsView.lastScrollLeft = 0;
  documentsView.lastScrollTop = 0;
  documentsView.myScroll =  {  };
  documentsView.availableDocuments =  {  };</pre></div><p>So far, pretty much the same as previous projects.</p><div><pre class="programlisting">  documentsView.currentDocument = null;
  documentsView.documentCurrentlyPlaying = -1;</pre></div><p>Here, however, we begin to diverge. We need to store both the current item that is playing and an index to that item. If we didn't, and we tapped two or more items, we'd end up with all of those items playing at once. Instead, we need to stop the previous item and start the tapped item so that only one audio file is playing at one time.</p><p>We'll skip over initializing the view, since it's like all the other projects. Instead, we'll look at the <a id="id607" class="indexterm"/>
<code class="literal">documentContainterTapped()</code> method in the following code snippet:</p><div><pre class="programlisting">   documentsView.documentContainerTapped = function(idx)
  {
    var theElement = $ge("documentsView_item" + idx + "_img");

    if (documentsView.documentCurrentlyPlaying == idx)
    {
      if (documentsView.currentDocument.isPlaying())
      {
        documentsView.currentDocument.pausePlayback();
        theElement.setAttribute("src", "./images/playButton.png");
      } else
      {
        documentsView.currentDocument.startPlayback();
        theElement.setAttribute("src", "./images/pauseButton.png");
      }
    } </pre></div><p>First, we check to see if the index (<code class="literal">idx</code>) is the same as the currently playing file. If it is, we need to pause (or resume) it. We don't want to release any resources or stop the file – otherwise when the item is tapped again, playback will start all over. We also set the image of the particular item to either the <em>play</em> or <em>pause</em> icon as appropriate.</p><div><pre class="programlisting">    else
    {
      if (documentsView.documentCurrentlyPlaying &gt; -1)
      {
        var theOldElement = $ge("documentsView_item" + documentsView.documentCurrentlyPlaying + "_img");
        documentsView.currentDocument.releaseResources();
        documentsView.currentDocument = null;
        documentsView.documentCurrentlyPlaying = -1;
        theOldElement.setAttribute("src", "./images/playButton.png");
      }</pre></div><p>If the index (<code class="literal">idx</code>) is different, we first check to see if anything's currently playing (or paused). If it is, we release <a id="id608" class="indexterm"/>those resources so that we aren't keeping on to them when we're going to start playing a different item.</p><div><pre class="programlisting">      documentsView.currentDocument = new DOC.VoiceRecDocument(documentsView.availableDocuments.getDocumentAtIndex(idx), documentsView.mediaSuccess, null);
      documentsView.currentDocument.startPlayback();
      documentsView.documentCurrentlyPlaying = idx;
      theElement.setAttribute("src", "./images/pauseButton.png");
    }
<code class="literal">  }</code>
</pre></div><p>Next we create a new <code class="literal">VoiceRecDocument</code> function<a id="id609" class="indexterm"/> and start the playback.</p><div><pre class="programlisting">  documentsView.mediaSuccess = function()
  {
    var theElement = $ge("documentsView_item" + documentsView.documentCurrentlyPlaying + "_img");
    documentsView.currentDocument.releaseResources();
    documentsView.currentDocument = null;
    documentsView.documentCurrentlyPlaying = -1;
    theElement.setAttribute("src", "./images/playButton.png");
  }</pre></div><p>The <code class="literal">mediaSuccess()</code> method<a id="id610" class="indexterm"/>, which is passed when creating the <code class="literal">VoiceRecDocument</code> function earlier, is generally called whenever the audio file is forcibly stopped (not paused) or stops on its own. Since we don't provide our own <em>stop</em> method visually, we can safely assume that the file has stopped playing on its own. When that is the case, we release the resources so that the file isn't taking up any memory when it isn't being played.</p><p>Next, we're going to skip to the <code class="literal">documentIterator()</code> method<a id="id611" class="indexterm"/>:</p><div><pre class="programlisting">  documentsView.documentIterator = function(o)
  {
    var theHTML = "";
    var theNumberOfDocuments = 0;
    for (var i = 0; i &lt; o.getDocumentCount(); i++)
    {
      var theDocumentEntry = o.getDocumentAtIndex(i);

      theHTML += PKUTIL.instanceOfTemplate($ge("documentsView_documentTemplate"),
      {
        "title" : PKUTIL.FILE.getFileNamePart ( theDocumentEntry.name ),
        "index" : i,
        "delete" : __T("DELETE")
      });
      theNumberOfDocuments++;
    }
    $ge("documentsView_contentArea").innerHTML = theHTML;</pre></div><p>This first portion is fairly self-explanatory. We assign the title of the item to the file name (minus the path and extension), <a id="id612" class="indexterm"/>we assign the indexes, and then also fill in the word <code class="literal">delete</code> whenever we come across it.</p><div><pre class="programlisting">    PKUTIL.delay(100, function()
    {</pre></div><p>Next, we delay for a short time to make sure the DOM has had time to process all the new items before we go on to working with them.</p><div><pre class="programlisting">      for (var i = 0; i &lt; theNumberOfDocuments; i++)
      {
        var theElement = $ge("documentsView_item" + i + "");</pre></div><p>Each element we created needs to have two gestures applied: a long press gesture and a horizontal swipe gesture. So first we look up the element using the preceding code snippet.</p><div><pre class="programlisting">        var theLPGesture = new GESTURES.LongPressGesture(theElement, function(o)
        {
          documentsView.longPressReceived(o.data);
        });
          theLPGesture.data = i;</pre></div><p>Next, we create the long press gesture and attach it to the element. When the gesture is recognized, we'll call <code class="literal">longpressReceived()</code> with <code class="literal">o.data</code>. This data is what we set in the next line; it'll be the index of the item that has been long pressed.</p><div><pre class="programlisting">        var theHSGesture = new GESTURES.HorizontalSwipeGesture(theElement, function(o)
        {
          documentsView.horizontalSwipeReceived(o.data);
        });
        theHSGesture.data = i;
      }
    });
  }</pre></div><p>Assigning a horizontal swipe gesture is much the same, except we call <code class="literal">horizontalSwipeReceived</code>.</p><div><pre class="programlisting">  documentsView.longPressReceived = function(idx)
  {
    var anAlert = new PKUI.MESSAGE.Confirm(__T("Select Action"), __T("Select an action to perform:"), "Copy|Rename|Cancel&lt;", function(i)
    {
      PKUTIL.delay(100, function()
      {
        if (i == 0)
        {
          documentsView.copyDocument(idx);
        }
          if (i == 1)
        {
          documentsView.renameDocument(idx);
        }
      });
    });
    anAlert.show();
  }</pre></div><p>When a long press is received, we'll call the preceding method. We'll create a confirmation pop up <a id="id613" class="indexterm"/>with three possible actions: <code class="literal">Copy</code>, <code class="literal">Rename</code>, and <code class="literal">Cancel</code>. We've modified the framework a little to support more than two buttons on a pop up, so don't worry that they'll be crowding anything out.</p><p>If the user taps <strong>Copy</strong>, we'll call the <code class="literal">copyDocument()</code> method<a id="id614" class="indexterm"/>, and if they tap <strong>Rename</strong>, we'll call <a id="id615" class="indexterm"/>
<code class="literal">renameDocument()</code>.</p><div><pre class="programlisting">  documentsView.horizontalSwipeReceived = function(idx)
  {
    var theActionContainer = $ge("documentsView_actions" + idx);
    if (theActionContainer.style.display == "block")
    {
      theActionContainer.style.opacity = "0";
      PKUTIL.delay(400, function()
      {
        theActionContainer.style.display = "none";
      });
    } else
    {
      theActionContainer.style.display = "block";
      PKUTIL.delay(50, function()
      {
        theActionContainer.style.opacity = "1";
      });
    }

  }</pre></div><p>When a horizontal swipe is received, however, we do something different: we want to either display or <a id="id616" class="indexterm"/>hide the <strong>Delete</strong> button for that item. We can see if it is visible by checking the <code class="literal">style.display</code> property. We've taken the route of setting the <code class="literal">opacity</code> and <code class="literal">display</code> to show or hide it. This may not exactly match the native methodology (iOS slides this button in, for example), but it works well enough.</p><div><pre class="programlisting">  documentsView.startRecording = function (theFileEntry)
  {</pre></div><p>Recording is probably the most complicated and difficult thing to get right. After all, each platform has different recording types that they support, but they also have their own quirks (such as whether or not the file must already exist or not).</p><div><pre class="programlisting">    documentsView.currentDocument = new DOC.VoiceRecDocument(theFileEntry, null, null);</pre></div><p>First, we create the new document with the desired filename; we ask the user this in the<a id="id617" class="indexterm"/> <code class="literal">createDocument()</code> method.</p><div><pre class="programlisting">    var anAlert = new PKUI.MESSAGE.Confirm(
         __T("Recording..."),
         "&lt;img src='./images/microphone.png' width=54 height=123&gt;",
         __T("STOP_"), function(i)
    {
      documentsView.currentDocument.stopRecording();
      documentsView.currentDocument.releaseResources();
      documentsView.currentDocument = null;
      documentsView.documentCurrentlyPlaying = -1;
      documentsView.reloadAvailableDocuments();
    });
    anAlert.show();</pre></div><p>Next, we display a simple alert that has the microphone image in it and a <strong>Stop</strong> button. (That <code class="literal">_</code> at the end tells the alert to let the button fill the entire alert's width so that it is easier to tap.) When the user taps the <strong>Stop</strong> button, we'll stop recording and release all the resources. We also have to reload the documents so that the user can tap on it to play it back if they want.</p><div><pre class="programlisting">    documentsView.currentDocument.startRecording();
  }</pre></div><p>Here we take advantage of one important fact of our pop-up system—they don't block our script execution. That means, we can be showing the alert and then continue to do other work, in this case, recording.</p><div><pre class="programlisting">  documentsView.createNewDocument = function()
  {</pre></div><p>That was the easy part; getting ready to record is the hard part. We do this in <code class="literal">createNewDocument()</code>,<a id="id618" class="indexterm"/> which is called when the <strong>REC</strong> button is tapped.</p><div><pre class="programlisting">    var anAlert = new PKUI.MESSAGE.Prompt(__T("Create Document"), __T("This will create a new document with the name below:"), "text", "Memo " + __D(new Date(), "yyyy-MM-dd HH-mm-ss"), __T("Don't Create&lt;|Create&gt;"), function(i)
    {</pre></div><p>Like always, we ask <a id="id619" class="indexterm"/>the user to give us a new name for the document. Here we use <code class="literal">Memo</code> and the date.</p><div><pre class="programlisting">      if (i === 1)
      {
        var fileType = ".wav";
        if (device.platform()=="android")
        {
          fileType = ".3gr";
        }
        documentsView.availableDocuments.createDocument("" + anAlert.inputElement.value + fileType, function()</pre></div><p>First, we figure out what type of file we can record to based on the platform, and then pass that to <code class="literal">createDocument()</code>. Then, we define what should happen when <code class="literal">createDocument()</code> succeeds:</p><div><pre class="programlisting">        {
          if (documentsView.documentCurrentlyPlaying &gt; -1)
          {
            documentsView.mediaSuccess();
          }</pre></div><p>If we have an existing audio file playing, we stop it. We wouldn't want it to interfere with recording, after all.</p><div><pre class="programlisting">          var theFileEntry = documentsView.availableDocuments.getFileEntry();
          if (PKDEVICE.platform()=="ios")
          {
            console.log(4);
            theFileEntry.createWriter(function(writer)
            {
              console.log(5);
              writer.onwriteend = function(e)
              {
                documentsView.startRecording (theFileEntry);
              };

              writer.write("It doesn't matter what goes here.");
              console.log(12);
            }, function(err)
            {
              console.log(6);
              var anAlert = new PKUI.MESSAGE.Alert(__T("Oops!"), __T("Couldn't create the file."));
              anAlert.show();
            });
        }</pre></div><p>Then, for iOS, we create a new file with some junk text. For some reason, the <code class="literal">Media</code> API requires the file to exist <a id="id620" class="indexterm"/>prior to the recording, or it will fail to record. The other platforms don't have this restriction.</p><div><pre class="programlisting">        else
        {
          if (PKDEVICE.platform()=="android")
          {
            theFileEntry.remove( function () { documentsView.startRecording(theFileEntry); } , null );
          }</pre></div><p>That said, the file gets created anyway, and can confuse Android. So we delete the file entirely before recording.</p><div><pre class="programlisting">          else
          {
            documentsView.startRecording(theFileEntry);
          }
        }
        }, function(e)
        {
          var anAlert = new PKUI.MESSAGE.Alert(__T("Oops!"), __T("Couldn't create the file."));
          anAlert.show();
        });
      }
    });
    anAlert.show();
  }

  documentsView.renameDocument = function(idx)
  {
    var theFile = documentsView.availableDocuments.getDocumentAtIndex(idx).name;
    var theFileName = PKUTIL.FILE.getFileNamePart(theFile);
    var theFileExt = PKUTIL.FILE.getFileExtensionPart(theFile);</pre></div><p>Previously, we only had to worry about one type of file in the list. But when renaming a file, or copying a file, <a id="id621" class="indexterm"/>we need to be sensitive to the type of file we are working with, because we need to duplicate the file extension on the new name. We do this by first getting the file extension in the preceding code snippet.</p><div><pre class="programlisting">    var anAlert = new PKUI.MESSAGE.Prompt(__T("Rename Document"), __T("Rename your document to the following:"), "text", theFileName, __T("Cancel&lt;|Rename&gt;"), function(i)
    {
      if (i == 1)
      {
        if (documentsView.documentCurrentlyPlaying &gt; -1)
        {
          documentsView.currentDocument.releaseResources();
        }</pre></div><p>Then, if we're renaming (or deleting) a file (we don't do this for a copy), we stop any playback of the file we're renaming (or deleting) prior to actually doing the operation.</p><div><pre class="programlisting">
<code class="literal">        var theNewFileName = "" + anAlert.inputElement.value + PKUTIL.FILE.extensionSeparator + theFileExt;</code>
</pre></div><p>Next we construct the new filename with the same extension as the old file. From here on out, the code is identical to the prior projects, so we won't go over the rest of it. The important thing here is that you must preserve the file extension of any file when renaming or copying it.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec116"/>What did we do?</h2></div></div></div><p>We created a view that can list the available audio files, manage their playback, and also record new files. We also created a long press gesture and a horizontal swipe gesture for each item to implement the various file management operations necessary.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Game Over..... Wrapping it up</h1></div></div></div><p>We've created a<a id="id622" class="indexterm"/> simple media recorder and playback app. It can manage all the files it creates (and even play a few it didn't). It also supports, for the first time, simple gestures, which are key to simplifying the complexity of the user interface.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>There are, of course, <a id="id623" class="indexterm"/>many ways you could enhance this project, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pop up a simple media player view over the document view while the item is playing. Give the user a way to go backward and forward in the audio file.</li><li class="listitem" style="list-style-type: disc">Create a separate view while recording that displays the duration of the recording in a prominent fashion.</li><li class="listitem" style="list-style-type: disc">If you want to get really creative, add this project to the <code class="literal">Filer</code> project. Allow a recording to be created as a document is written on the device, and then when that document is later viewed, play the recording so that the user can follow along.</li></ul></div></div></body></html>