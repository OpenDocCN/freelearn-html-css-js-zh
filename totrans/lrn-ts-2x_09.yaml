- en: Automating Your Development Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about the main elements of the TypeScript
    syntax and the main features of its type system. Over the next few chapters, we
    will focus on the TypeScript tools and other elements of its ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to use some tools to automate our
    development workflow. These tools will help us to reduce the amount of time that
    we usually spend in some trivial and repetitive tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Source control tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation and test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffolding tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern development workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a web application with high-quality standards has become a time-consuming
    activity. If we want to achieve a great user experience, we will need to ensure
    that our applications can run as smoothly as possible on many different web browsers,
    devices, internet connection speeds, and screen resolutions. Furthermore, we will
    need to spend a lot of our time working on quality assurance and performance optimization
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As software engineers, we should try to minimize the time we spend on trivial
    and repetitive tasks. This might sound familiar as we have been doing this for
    years. We started by writing build scripts (such as makefiles) or automated tests
    and today, in a modern web development workflow, we use many tools to literally
    try to automate as many tasks as we can. These tools can be categorized into the
    following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Source control tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package managers tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration (CI) tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffolding tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are about to learn how to automate many tasks in our development workflow;
    however, before that, we need to install a few tools in our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a platform built on V8 (Google's open source JavaScript engine).
    Node.js allows us to run JavaScript outside a web browser. We can write backend
    and desktop applications using TypeScript and Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we are planning to write backend applications, we are going to need
    Node.js because many of the tools used in this chapter are Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't install Node.js in the previous chapters, you could visit [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to download the installer for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code is an open source editor developed by Microsoft. The open
    source community around this editor is really active and has developed many plugins
    and themes. We can download Visual Studio Code from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: We can additionally visit the Visual Studio extensions panel (the fifth icon
    on the left-hand side of the screen) to browse and install an extension or theme.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is open source, and it is available for Linux, OS X, and
    Windows, so it will suit most readers. If you want to work with Visual Studio,
    you will be able to find the extension to enable TypeScript support in Visual
    Studio at [https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304](https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304).
  prefs: []
  type: TYPE_NORMAL
- en: Git and GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toward the end of this chapter, we will learn how to configure a CI service.
    The CI service will observe changes in our application's code and ensure that
    the changes don't break the application.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to observe the changes in the code, we will need to use a source
    control system. There are a few source control systems available. Some of the
    most widely used ones are Subversion, Mercurial, and Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source control systems have many benefits, among which we can highlight the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Source control tools enable multiple developers to work on a source file without
    any work being potentially lost by one developer overriding previous changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control tools allow us to track and audit the changes in our source code.
    These features can be really useful, for example, when trying to find out when
    a new bug was introduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While working through the examples in this chapter, we will perform some changes
    to the source code. We will use Git and GitHub to manage these changes.
  prefs: []
  type: TYPE_NORMAL
- en: We need to visit [http://git-scm.com/downloads](http://git-scm.com/downloads)
    to download the Git installer. We can then visit [https://github.com/](https://github.com/)
    to create a GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub account will offer a few different subscription plans. The free plan
    offers everything we need to follow the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Companion source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The companion source code for this book can be found online at [https://github.com/remojansen/LearningTypeScript](https://github.com/remojansen/LearningTypeScript).
    The source code for this chapter includes a small example with the following directory
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97401c5f-091d-40c0-aef8-1e02b83331a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two main files, named `main_server.ts` and `main_browser.ts`. Both
    files are located under the `src` directory. These files create an instance of
    a class named `Calculator` and use it to perform some operations. The result of
    the operations is logged in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `main_browser.ts` file displays the results inside an HTML element instead
    of displaying them in the console. The `main_browser.ts` file also imports a `.scss`
    file to demonstrate how we can work with `.css` and `.scss` files,  with Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Calculator` class can perform different kinds of mathematical operations
    and is defined in the `calculator.ts` file, which is located under the `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Calculator` class can only perform two operations. Each operation is defined
    on its own file under the `operations` directory. The `add` operation is defined
    in the `add.ts` file and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pow` operation is defined in the `pow.ts` file and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `isNumber` validation function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use these files during the rest of this chapter, which means
    that we might need to come back to them later to fully understand the rest of
    the contents of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Source control tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have installed Git and created a GitHub account, we will use GitHub
    to create a new code repository. A repository is a central file storage location.
    It is used by the source control systems to store multiple versions of files.
    While a repository can be configured on a local machine for a single user, it
    is often stored on a server, which can be accessed by multiple users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new repository on GitHub, log in to your GitHub account and click
    on the link to create a new repository, which you can find in the top-right corner
    of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64ea8ec7-7154-4125-9e0d-4f5c45ec2b78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A form similar to the one in the following screenshot will then be displayed
    on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a239ba06-7171-4c13-9c3b-3126909fb8d4.png)'
  prefs: []
  type: TYPE_IMG
- en: This form contains some fields that allow us to set the repository's name, description,
    and some privacy settings.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you will need a paid GitHub account if you want to use a private
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add a `README.md` file, which uses markdown syntax and is used to
    add whatever text we want to the repository home page on GitHub. Furthermore,
    we can add a default `.gitignore` file, which is used to specify files that we
    would like to be ignored by Git and therefore not be saved into the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended option for the default `.gitignore` file is `Node`. We will
    use GitHub throughout this book. However, if you want to use a local repository,
    you can use the Git `init` command to create an empty repository. Refer to the
    Git documentation at [http://git-scm.com/docs/git-init](http://git-scm.com/docs/git-init)
    to learn more about the `git init` command and working with a local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not less important, we can also select a software license to cover
    our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the repository, we will visit our profile page on GitHub,
    find the repository that we have just created, and visit it. In the repository''s
    home page, we will be able to find the clone URL in the top-right corner of the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32bb99ac-aa20-4a23-b183-eb6f53c0a427.png)'
  prefs: []
  type: TYPE_IMG
- en: clone URL
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to copy the repository''s clone URL, open a console, and use the URL
    as an argument of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes the Windows **command-line interface** (**CLI**) is not able to find
    the Git and Node commands. The easiest way to get around this issue is to use
    the Git console (installed with Git) rather than using the Windows command line. If
    you want to use the Windows console, you will need to manually add the Git and
    Node installation paths to the Windows `PATH` environment variable. If you are
    working with OS X or Linux, the default CLI should work fine. Also, note that
    we will use the Unix path syntax in all the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command''s output should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then move into the repository''s directory using the change directory
    command (`cd`) and use the `git status` command to check the local repository
    status. The command''s output should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git status` command is telling us that there are no changes in our working
    directory. Let''s open the repository folder in Visual Studio Code and create
    a new file called `gulpfile.js`. Now, run the `git status` command again, and
    we should see some new untracked files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The project explorer in Visual Studio Code displays the files using a color
    code to help us to identify whether a file is new (green), has been removed (red),
    or has changed (yellow) since our last commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we make some changes, such as adding a new file or changing an existing
    file, we need to execute the `git add` command to indicate that we want to add
    that change to a snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have staged the content we want to snapshot, we have to run the
    `git commit` command to actually record the snapshot. Recording a snapshot requires
    a commentary field, which can be provided using the `git commit` command together
    with the `-m` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the preceding command you need to configure your GitHub email/username
    on the Terminal. You can use any one of the following commands to configure your
    GitHub account on the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git config --global user.email "you@example.com"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`git config --global user.name "Your Name"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, the command output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To share the commit with the other developers, we need to push our changes
    to the remote repository. We can do this by executing the `git push` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `git push` command will ask for our GitHub username and password and then
    send the changes to the remote repository. If we visit the repository's page on
    GitHub, we will be able to find the recently created file. We will return to GitHub
    later in this chapter to configure our CI server.
  prefs: []
  type: TYPE_NORMAL
- en: If we are working with a large team, we might encounter some file conflicts
    when attempting to push some changes to the remote repository. Resolving a file
    conflict is out of the scope of this book; however, if you need further information
    about Git, you will find an extensive user manual at [https://www.kernel.org/pub/software/scm/git/docs/user-manual.html](https://www.kernel.org/pub/software/scm/git/docs/user-manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: Package management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package management tools are used for dependency management, so that we no longer
    have to manually download and manage our application's dependencies. We are not
    going to cover package management tools in this chapter because we have already
    covered them in [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to use `npm`, we can install TypeScript using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler will then become available in our CLI as a command
    named `tsc`. We can check the version of TypeScript installed in our machine using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler accepts many more options. For example, we can use
    the `--target` or `-t` option to select which version of JavaScript we would like
    to target as the compilation output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create a `tsconfig.json` file to set the desired compilation
    settings. We can also use the TypeScript compiler to autogenerate a `tsconfig.json`
    file with default settings using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating a `tsconfig.json` file, you can pass it to the TypeScript compiler
    using the `--project` or `-p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the official TypeScript documentation at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    if you wish to learn more about the available compilation options.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing refers to the practice of testing certain functions and areas (units)
    of our code. This gives us the ability to verify that our functions work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that the reader will have some understanding of the unit test
    process, but the contents exposed here will be covered at a much higher level
    of detail in [Chapter 14](e365ca9e-d510-4127-a701-959ad8e2626f.xhtml), *Application
    Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we included the most important parts of the
    application included in the companion source code for this chapter. The source
    code defined a calculator with support for two operations: `pow` and `add`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pow` operation expects two numbers as its arguments and has two possible
    execution paths:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pow` function will throw an exception if one of the two arguments provided
    is not a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pow` function will return a number if both arguments are valid numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, we will write a unit test of each of the execution paths of our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a couple of unit tests for the `pow` operation
    using two testing libraries, `mocha` and `chai`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet groups all the tests related to the `pow` operation
    in what is known as a **test fixture**. A test fixture can be defined using the
    `describe` function and is just a group of test cases. A test case can be defined
    using the `it` functions and can contain one or more test assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Our test assertions are defined using the `assert` function, which is part of
    the Chai library.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `describe` and the `it` functions are global functions declared by
    Mocha. We don’t need to import `Mocha` because it is imported as a global by our
    test runner configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tests and generate a test coverage report using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command uses `nyc`, which is a tool used to generate test coverage
    reports. This tool uses `ts-node` and `mocha` to run the tests. This explains
    why we can run the test without compiling them and why we can use Mocha without
    importing it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is not very convenient, but we can declare an `npm` command to
    solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we need to install all these dependencies and their type definitions
    (when appropriate) using npm. We can then use the following npm command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The companion source code includes many more tests. The existing tests cover
    most of the possible execution paths of all the existing functions in the application
    but don''t fully cover the `main_server.ts` file. This can be observed in the
    test coverage report generated by `nyc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7835ccc-7b03-401d-ba39-c7fe34f9fef0.png)'
  prefs: []
  type: TYPE_IMG
- en: Linting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following tool is a code linting tool. A linting tool helps us to enforce
    certain code styling rules in our code base. For example, in a large development
    team, it is very common to have long discussions about the code styling.
  prefs: []
  type: TYPE_NORMAL
- en: The term *code styling* refers to certain cosmetic elements of our code, such
    as using spaces or tabs. However, sometimes the code styling involves certain
    rules that are not purely cosmetic and are intended to make our code more maintainable.
    A good example of this would be a code styling rule that enforces using trailing
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: Code styling guidelines and rules are great but enforcing them can take a significant
    amount of human effort. We would have to review every single code change to make
    sure that the code contributions respect our code styling rules.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of a linting tool is to automate the enforcement of the code styling
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript world, the leading linting tool is **tslint**. We can install
    `tslint` using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create a `tslint.json` file. This file contains the configuration
    that allows us to enable and disable certain styling rules. The following code
    snippet is an example of a `tslint.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `tslint.json` file, we can check our source code using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is not really convenient. We can use `npm` `scripts`
    to create a more convenient command, named `lint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run `tslint` using the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Working with npm scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `package.json` file contains a field named `scripts`. This field can contain
    multiple entries, and each entry is used to create a command. A command can execute
    any kind of custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create the `package.json` file using the `npm init` command, the default
    command is not implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In a real-world scenario, we would have multiple commands as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Some commands, such as the `test`, `install`, or `start` commands, are considered
    standard commands. You can execute a standard command by using the `npm` command
    followed by the name of the standard command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the commands that are not considered standard, we need to use the `npm`
    command followed by the `run` command and the name of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the npm documentation at [https://docs.npmjs.com](https://docs.npmjs.com)
    to learn more about all the npm features.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most popular JavaScript task runners are Grunt and Gulp. The main
    difference between Gulp and Grunt is that while in Grunt we work using files as
    the input and output of our tasks, in Gulp we work with streams and pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt is configured using some configuration fields and values. However, Gulp
    prefers code over configuration. This approach makes the Gulp configuration somehow
    more minimalist and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will work with Gulp; however, if you want to learn more about
    Grunt, you can do so at [http://gruntjs.com/](http://gruntjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: To gain a good understanding of Gulp, we are going to configure some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing `gulp` using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s create a JavaScript file named `gulpfile.js` inside the root folder
    of our project, which should contain the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, run `gulp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we installed Gulp using the `-g` flag because we are going
    to invoke the `gulp` command directly from the command-line interface. However,
    if we are planning to use `npm scripts`, we should install Gulp and any other
    dependencies as project dependencies using the `--save-dev` flag instead. Note
    that using global (`-g`) dependencies is not recommended. Also, note that we must
    execute this command from the location in which the `gulpfile.js` file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created our first Gulp task, which is named `hello`. When we run the
    `gulp` command, it will automatically try to search for the `gulpfile.js` in the
    current directory, and once found, it will try to find the `hello` task. If everything
    worked as expected, we should see an output similar to the following in our CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We will now add a second task, which will use the `gulp-tslint` plugin to check
    whether our TypeScript code follows a series of recommended practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install the plugin with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then load the plugin in our `gulpfile.js` file and add a new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have named the new task `lint`. Let''s take a look at the operations performed
    by the `lint` task, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The `gulp src` function will read the files with the file extension `.ts` located
    in the `src` directory and its subdirectories. We are also fetching all the files
    with the file extension `.test.ts` in the directory located in `test` and its
    subdirectories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many plugins allow us to indicate files to be ignored by adding the exclamation
    symbol (`!`) before a path. For example, the path `!path/*.d.ts` will ignore all
    files with the extension `.d.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pipe` function is used to pass the output stream of the `src` as the input
    of the `gulpTslint` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the output of the `tslint` function as the input of the `report`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have added the `lint` task, we will modify the `gulpfile.js` file
    to add one more task, named `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The default task can be used to invoke both the `hello` and `lint` tasks. When
    we define a `gulp` task, we invoke the `task` function with two arguments. The
    first argument is the task name. The second argument can take a function that
    defines a task or an array containing a list of subtasks.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the gulp task execution order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now learn how to control the order in which the tasks are executed.
    If we try to execute the default, the `hello` and `lint` tasks will be executed
    in parallel because the subtasks are executed in parallel by default.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we will need to run our tasks in a certain order. Controlling the
    execution order of our tasks can be challenging since in Gulp all the tasks are
    asynchronous by default.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are three ways to make a task synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Passing in a callback to the task definition function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to pass a callback function to the task definition function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Returning a promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to use a promise as the return of the task definition
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Returning a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to use a stream as the return of the task definition function.
    This is simple because the pipe operator returns a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some synchronous tasks, we can use them as a subtask of a
    new task named `async`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, it is also possible to define
    a task that has some subtasks. However, if the complexity of our build process
    increases, we can end up with a very difficult to follow task dependency graph.
    Fortunately, we can install the `run-sequence` Gulp plugin via `npm`, which will
    allow us to have better control over the task execution order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will run in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lint`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tsc` and `tsc-tests` in parallel'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bundle-js` and `bundle-test` in parallel'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`karma`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`browser-sync`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gulp development team announced plans to improve the management of the task
    execution order without the need of external plugins. Refer to the Gulp documentation
    at [https://github.com/gulpjs/gulp/](https://github.com/gulpjs/gulp/) to learn
    more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, when we compile our TypeScript code, the compiler will generate
    a JavaScript file for each existing TypeScript file. If we run the application
    in a web browser, these files won't be really useful on their own because the
    only way to use them would be to create an individual HTML `script` tag for each
    one of them.
  prefs: []
  type: TYPE_NORMAL
- en: However, this would be highly inconvenient and inefficient because each `script`
    tag will translate into a round trip between the web browser and the server serving
    the JavaScript files. Using `script` tags is also slower than using Ajax calls
    because `script` tags can prevent the browser from rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in a modern web browser, we can make some of the `script` tags
    asynchronous but it is not always an option. Please refer to [https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript) to
    learn more about asynchronous scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there are a few potential solutions for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load the files using AJAX calls**: We can use a tool to load each of the
    JavaScript files on demand using AJAX calls. This approach is known as asynchronous
    module loading. To follow this approach, we will need to use Require.js and change
    the configuration of the TypeScript compiler to use the asynchronous module definition
    (AMD) notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle all the files into one unique file and load it using a script tag**:
    We can use a tool to trace the application modules and dependencies and generate
    a highly optimized single file, which will contain all the application modules.
    To follow this approach, we will need to use a tool, such as Webpack or Browserify
    and change the configuration of the TypeScript compiler to use the correct module
    syntax (usually CommonJS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid approach**: We can follow a hybrid approach by creating a highly optimized
    bundle that contains the minimum number of files required by the application to
    be able to work. Additional files are then loaded on demand using AJAX calls when
    they are required by the application users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more about modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on the second approach. We will create
    a highly optimized module bundler using Webpack. Creating a highly optimized application
    bundle usually involves multiple steps; Webpack can perform each of these tasks
    but it is not really designed to be used as a task runner. We can install Webpack
    using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to install a few extra modules required by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Most of these modules are Webpack plugins and their dependencies. We need them
    because we are going to use them in our Webpack configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: We can configure Webpack by creating a file named `webpack.config.js` in the
    root directory of our project. The following code section displays the entire
    content of the Webpack configuration file used by the companion source code of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `webpack.config.js` file is importing some dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we declare three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: The `corePlugins` variable is an array that contains the configuration of Webpack
    plugins that are used in development builds and production builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `devPlugins` variable is an array that contains the configuration of Webpack
    plugins used in development builds only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prodPlugins` variable is an array that contains the configuration of Webpack
    plugins used in production builds only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the plugins requires some specific configuration. For example, the
    `ExtractTextPlugin` is used to extract our CSS code from the main application
    bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file uses the environment variable `NODE_ENV` determine whether
    we are running a development build or a production build. The production build
    uses the `uglify` plugin, but it is not used by the development build.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `uglify` plugin to minimize the output size. The reduced file
    size will reduce the application loading time but will make it harder to debug.
    Fortunately, we can generate source maps to facilitate the debugging process.
    The source maps are generated by the `source-map-loader` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Uglify removes all line breaks and whitespaces and reduces the length of some
    variable names. Source map files allow us to map the source code of the reduced
    file to its original code while debugging. A source map provides a way of mapping
    code within a compressed file back to its original position in a source file.
    This means we can easily debug an application even after its assets have been
    optimized. The Chrome and Firefox developer tools both ship with built-in support
    for source maps.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we define the application's entry point. We use an object as
    a map to define an entry point, which means that we can define multiple entry
    points. Each entry point is transformed into a `bundle.js` file that will be stored
    under a directory named `public`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the rest of the `webpack.config.js` file, we have appended
    a forward slash to the name of the application's entry point. We have also used
    a special syntax to use the name of the entry point as part of the name of the
    output files (for example, `[name]bundle.js`). This is a trick that we can use
    to generate a unique folder for each of the output bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the file declares the configuration for some of the plugins, such
    as the TypeScript plugin or the `sass` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the Webpack bundling process using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we must execute this command from the location in which the
    `gulpfile.js` file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, we should be able to see a new folder named `public`.
    The `public` folder should contain the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04a03f6d-0182-4c43-b7f7-7bd37b14bf4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The companion source code also includes a file named `index.html`. This file
    is the entry point of the frontend application that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This example should give us a good first impression about how to work with Webpack.
    The following section describes how we can use the Webpack development as a web
    server to access this application from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)
    if you need additional information about webpack. It is also recommended to refer
    to the documentation of each of the plugins to learn more about the available
    configuration options. Some npm modules might require some additional tools. It
    is not very common, but some modules might require tools such as the gcc/g++ compilers
    and the Python interpreter to be installed in your development environment. Please
    refer to the documentation of your operating system online to learn how to install
    the gcc/g++ compilers and the Python interpreter if you encounter this kind of
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Webpack development server is a command-line utility that monitors our filesystem
    for changes and triggers the Webpack bundling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the Webpack development server using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then execute the webpack development server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The Webpack development server will then start watching our filesystem for changes.
    If a change is detected, it will automatically run the Webpack build process using
    the existing the `webpack.config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Webpack development server also starts a web server. The server is running
    on port 8080 by default.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server)
    to learn more about the Webpack development server.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio is a lightweight but powerful code editor with an extensive number
    of features. Learning all these features is out of the scope of this book because
    we could dedicate an entire book to cover them. However, we are going to dedicate
    a little bit of time to learning about two of the best features available in this
    code editor: quick fixes and the code debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to read the Visual Studio Code user guide at [https://code.visualstudio.com/docs/editor/codebasics](https://code.visualstudio.com/docs/editor/codebasics)
    to learn how to make the most of this IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Quick fixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code can detect some errors and automatically fix them using a
    set of features known as *quick fixes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code will display a bulb icon on the left-hand side of our code
    near some error. If we click on the bulb icon, Visual Studio Code will display
    all the available quick fixes. If we select one of the available quick fixes,
    Visual Studio Code will perform the necessary changes to solve the problem automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d016bb6-1551-4826-975d-f28ff5d27c01.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can debug our application using Node.js, we need to configure a debugging
    task in Visual Studio Code. We need to select the debug panel and add a new configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6983883b-b282-4153-986a-7563557bccd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A panel with a few options will then be displayed. We need to select Node.js.
    If you want to run and debug the application using Docker, you will be able to
    do so as well but it is out of the scope of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44cf7ca9-791f-40b8-b905-01b19d51a4cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting Node.js will create a folder named `.vscode` and a file named `launch.json`.
    This file allows us to define as many debugging tasks as we may need. A debug
    task declares the instructions required to debug our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of the debugging task is different for each testing tool.
    In the example application, we have used `mocha`, which means that our debugging
    task will need to use the `mocha` binary and some arguments to start a debugging
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configuration can be used to debug the tests in the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `.vscode` folder must be in the root of your project. The
    companion source code includes this folder under the chapter's folder instead
    of the root directory. If you want to try it, you will need to open the chapter's
    folder as the root directory with Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating and configuring the `launch.json` file, we can select the task
    that we just defined under the DEBUG panel and click on the *Play* button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a3af054-7611-441f-ae71-a449e70cb5d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The test execution will be paused when a breakpoint is reached. We can set
    a breakpoint by clicking on the left-hand side of a line in our source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e43488fa-9719-4e3e-9b08-f43a849cc3ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Visual Studio Code debugging panel allows us to examine the current execution
    context using the debugging panel available on the left-hand side of the screen.
    This panel contains a few subpanels:'
  prefs: []
  type: TYPE_NORMAL
- en: The variables panel allows us to see all the variables declared in the current
    execution context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The watch panel allows us to create a *watcher*. A watcher is just a filter
    that allows us to display the value of a variable of our choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call stack panel allows us to see the function call stack. We can click
    on the function in the call stack to navigate to the selected function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The breakpoints panel allows us to enable and disable the breakpoints that
    we have created, as well as to enable some generic ones (for example, uncaught
    exceptions):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3272fd3d-b6e2-4e1a-9f65-dc8e87360c79.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution panel located on the top of the screen allows us to control the
    execution of the test at our own pace.
  prefs: []
  type: TYPE_NORMAL
- en: Source control utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code also allows us to interact with Git through a graphical user
    interface. To access the Git features, we need to click on the Git panel on the
    left-hand side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Git panel allows us to see the current changes. We can select changes to
    be committed (stag) or roll back the changes. We can then commit the changes by
    introducing a message and clicking on the approval icon located on the top right-hand
    side of the Git panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f64be25d-0bc9-4030-97a6-8cbbc1ee25d9.png)'
  prefs: []
  type: TYPE_IMG
- en: ts-node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript community has developed an alternative version of Node.js that
    is able to work with TypeScript files as if it was natively supported. This alternative
    version of Node.js is known as `ts-node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ts-node` command allows us to execute TypeScript files without having
    to compile them first. We can execute a TypeScript file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The example application uses npm `scripts` to create a more convenient version
    of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `npm` command can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `ts-node` command tries to find the compilation setting in the
    `tsconfig.json` file and expects it to be located in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `ts-node` command is a very convenient tool when we want to try something
    without having to spend too much time configuring a tool such as Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: It may feel like `ts-node` can execute TypeScript natively, but this is not
    the case. Our TypeScript code is first compiled and then executed using the Node.js
    binary. This means that using `ts-node` in a production Node.js application is
    not recommended because we will pay a performance penalty (the compilation time).
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration (CI) tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is a development practice that helps to prevent potential integration issues.
    Software integration issues refer to the difficulties that may arise during the
    practice of combining individually tested software components into an integrated
    whole. Software is integrated when components are combined into subsystems or
    when subsystems are combined into products.
  prefs: []
  type: TYPE_NORMAL
- en: Components may be integrated after all are implemented and tested, as in a waterfall
    model or a big bang approach. On the other hand, CI requires developers to daily
    commit their code into a remote code repository. Each commit is then verified
    by an automated process, allowing teams to detect integration issues earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create a code repository on GitHub and
    how to validate our application using unit tests and linting tools, but we haven't
    configured a CI server to observe our commits and run these validations accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use Travis CI as our CI server because it is highly integrated
    with GitHub and is free for open source projects and learning purposes. There
    are many other options when it comes to choosing a CI server, but exploring these
    options is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Travis CI, we need to visit [https://travis-ci.org](https://travis-ci.org)
    and log in using our GitHub credentials. Once we have logged in, we will be able
    to see a list of our public GitHub repositories and will also be able to enable
    the CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6564c10-d433-4db0-8fa1-7e364329eaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To finish the configuration, we need to add a file named `travis.yml` to our
    application''s root directory, which contains the Travis CI configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are many other available Travis CI configuration options. Refer to [http://docs.travis-ci.com/](http://docs.travis-ci.com/)
    to learn more about the available options.
  prefs: []
  type: TYPE_NORMAL
- en: After completing these two small configuration steps, Travis CI will be ready
    to observe the commits to our remote code repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the configuration to indicate to Travis CI that our application
    is a Node.js application. The CI build for each potential kind of application
    can be highly customized, regardless of its technology stack.
  prefs: []
  type: TYPE_NORMAL
- en: However, in most cases, we will simply use the defaults set for a given kind
    of application. In the case of Node.js, Travis CI uses `npm install` and `npm
    test` as the default commands.
  prefs: []
  type: TYPE_NORMAL
- en: If the build works in the local development environment, but fails in the CI
    server, we will have to check the build error log and try to figure out what went
    wrong. Chances are that the software versions in our environment will be ahead
    of the ones in the CI server and we will need to indicate to Travis CI that a
    dependency needs to be installed or updated. We can find the Travis CI documentation
    at [http://docs.travis-ci.com/user/build-configuration/](http://docs.travis-ci.com/user/build-configuration/)
    to learn how to resolve this kind of issue.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A scaffolding tool is used to autogenerate the project structure, building
    scripts, and much more. Some examples of popular scaffolding tools include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React CLI (create-react-app-typescript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yeoman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools are designed to support many kinds of projects. The scaffolding
    tools will save us time by autogenerating some things for us, such as the webpack
    configuration or the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to spend some time reading the documentation of these
    tools to learn more about their existing customization options.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can learn more about the Angular CLI, the React CLI, and
    Yeoman at [https://cli.angular.io](https://cli.angular.io), [https://github.com/wmonk/create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript),
    and [http://yeoman.io](http://yeoman.io) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that it is never a good idea to let a tool generate some code for
    us if we don't understand what that code does. While, in the future, you should
    consider using a tool to generate a new project, it is recommended to gain a good
    understanding of task and test runners before using a scaffolding tool.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the command line win?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that during this chapter, we have used the CLI a lot instead
    of visual tools. We have used the command-line terminal to perform many kinds
    of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CLI has always been popular but I remember that, a few years ago, I used
    to do some of these things using Visual tools. For example, I remember running
    unit tests in .NET applications using a visual test runner for NUnit (a unit testing
    library for .NET applications). You might be wondering why we stopped using the
    visual tool and went back to the command line like in the early days?
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe that the CLI wins for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Our software development teams have become much more diverse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our software development methodologies have evolved toward automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our software teams are much more diverse today and, as a result, it is common
    to encounter teams composed of DevOps engineers who work with a Linux distribution,
    mobile software engineers who work on OS X, and web engineers who work on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The team members may use different operating systems, but they all follow the
    same process, and they share one unique development process. For example, if one
    of the members of the team wants to execute the unit tests, it would be possible
    to do so by executing a command in the OS console. We can go one step further
    and also use the same command as part of our CI build.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI wins because it enables our development teams to share one unique set
    of development processes and practices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with a long list of different development
    tools. It is impossible to cover so many tools in depth in one chapter, but now
    that we know the basics, it should be much easier to gradually dive deeper into
    more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the development of backend applications
    with Node.js and TypeScript.
  prefs: []
  type: TYPE_NORMAL
