- en: Automating Your Development Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化开发工作流程
- en: In the previous chapters, we learned about the main elements of the TypeScript
    syntax and the main features of its type system. Over the next few chapters, we
    will focus on the TypeScript tools and other elements of its ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了 TypeScript 语法的主要元素及其类型系统的主要功能。在接下来的几章中，我们将关注 TypeScript 工具及其生态系统中的其他元素。
- en: In this chapter, we are going to learn how to use some tools to automate our
    development workflow. These tools will help us to reduce the amount of time that
    we usually spend in some trivial and repetitive tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用一些工具来自动化我们的开发工作流程。这些工具将帮助我们减少我们在一些琐碎和重复性任务上通常花费的时间。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Source control tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制工具
- en: Package management tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包管理工具
- en: Task runners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务运行器
- en: Module bundlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块打包器
- en: Test automation and test coverage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化和测试覆盖率
- en: Integration tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成工具
- en: Scaffolding tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚手架工具
- en: A modern development workflow
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代化开发工作流程
- en: Developing a web application with high-quality standards has become a time-consuming
    activity. If we want to achieve a great user experience, we will need to ensure
    that our applications can run as smoothly as possible on many different web browsers,
    devices, internet connection speeds, and screen resolutions. Furthermore, we will
    need to spend a lot of our time working on quality assurance and performance optimization
    tasks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以高标准开发网络应用程序已经成为一项耗时的工作。如果我们想要实现出色的用户体验，我们需要确保我们的应用程序能够在许多不同的网页浏览器、设备、互联网连接速度和屏幕分辨率上尽可能顺畅地运行。此外，我们还需要花费大量时间在质量保证和性能优化任务上。
- en: 'As software engineers, we should try to minimize the time we spend on trivial
    and repetitive tasks. This might sound familiar as we have been doing this for
    years. We started by writing build scripts (such as makefiles) or automated tests
    and today, in a modern web development workflow, we use many tools to literally
    try to automate as many tasks as we can. These tools can be categorized into the
    following groups:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们应该尽量减少我们在琐碎和重复性任务上花费的时间。这听起来可能很熟悉，因为我们已经这样做了很多年。我们最初是通过编写构建脚本（如 makefiles）或自动化测试开始的，而如今，在现代网页开发工作流程中，我们使用许多工具来尽可能地自动化尽可能多的任务。这些工具可以分为以下几类：
- en: Source control tools
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制工具
- en: Package managers tools
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包管理器工具
- en: Task runners
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务运行器
- en: Module bundlers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块打包器
- en: Test runners
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行器
- en: Continuous integration (CI) tools
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成（CI）工具
- en: Scaffolding tools
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚手架工具
- en: Prerequisites
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件
- en: We are about to learn how to automate many tasks in our development workflow;
    however, before that, we need to install a few tools in our development environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将学习如何在开发工作流程中自动化许多任务；然而，在此之前，我们需要在我们的开发环境中安装一些工具。
- en: Node.js
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: Node.js is a platform built on V8 (Google's open source JavaScript engine).
    Node.js allows us to run JavaScript outside a web browser. We can write backend
    and desktop applications using TypeScript and Node.js.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个基于 V8（谷歌的开源 JavaScript 引擎）构建的平台。Node.js 允许我们在网页浏览器之外运行 JavaScript。我们可以使用
    TypeScript 和 Node.js 编写后端和桌面应用程序。
- en: Even if we are planning to write backend applications, we are going to need
    Node.js because many of the tools used in this chapter are Node.js applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的计划是编写后端应用程序，我们也需要 Node.js，因为本章中使用的许多工具都是 Node.js 应用程序。
- en: If you didn't install Node.js in the previous chapters, you could visit [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to download the installer for your operating system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在前面的章节中没有安装 Node.js，您可以从 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    下载适用于您操作系统的安装程序。
- en: Visual Studio Code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Visual Studio Code is an open source editor developed by Microsoft. The open
    source community around this editor is really active and has developed many plugins
    and themes. We can download Visual Studio Code from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是由微软开发的开源编辑器。围绕这个编辑器的开源社区非常活跃，已经开发了众多插件和主题。我们可以从 [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    下载 Visual Studio Code。
- en: We can additionally visit the Visual Studio extensions panel (the fifth icon
    on the left-hand side of the screen) to browse and install an extension or theme.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问 Visual Studio 扩展面板（屏幕左侧的第五个图标）来浏览和安装扩展或主题。
- en: Visual Studio Code is open source, and it is available for Linux, OS X, and
    Windows, so it will suit most readers. If you want to work with Visual Studio,
    you will be able to find the extension to enable TypeScript support in Visual
    Studio at [https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304](https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是开源的，并且适用于 Linux、OS X 和 Windows，因此它将适合大多数读者。如果你想在 Visual
    Studio 中工作，你将能够在 [https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304](https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304)
    找到启用 TypeScript 支持的 Visual Studio 扩展。
- en: Git and GitHub
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 和 GitHub
- en: Toward the end of this chapter, we will learn how to configure a CI service.
    The CI service will observe changes in our application's code and ensure that
    the changes don't break the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将学习如何配置 CI 服务。CI 服务将观察我们应用程序代码中的更改，并确保这些更改不会破坏应用程序。
- en: To be able to observe the changes in the code, we will need to use a source
    control system. There are a few source control systems available. Some of the
    most widely used ones are Subversion, Mercurial, and Git.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够观察代码中的更改，我们需要使用源代码控制系统。目前有几种源代码控制系统可供选择。其中一些最广泛使用的包括 Subversion、Mercurial
    和 Git。
- en: 'Source control systems have many benefits, among which we can highlight the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码控制系统有许多好处，其中我们可以强调以下几点：
- en: Source control tools enable multiple developers to work on a source file without
    any work being potentially lost by one developer overriding previous changes.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制工具使多个开发者能够在不丢失任何工作的情况下，通过一个开发者覆盖之前的更改来共同工作在一个源文件上。
- en: Source control tools allow us to track and audit the changes in our source code.
    These features can be really useful, for example, when trying to find out when
    a new bug was introduced.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制工具允许我们跟踪和审计源代码中的更改。这些功能非常有用，例如，在试图找出何时引入了新的错误时。
- en: While working through the examples in this chapter, we will perform some changes
    to the source code. We will use Git and GitHub to manage these changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理本章的示例时，我们将对源代码进行一些更改。我们将使用 Git 和 GitHub 来管理这些更改。
- en: We need to visit [http://git-scm.com/downloads](http://git-scm.com/downloads)
    to download the Git installer. We can then visit [https://github.com/](https://github.com/)
    to create a GitHub account.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要访问 [http://git-scm.com/downloads](http://git-scm.com/downloads) 下载 Git 安装程序。然后我们可以访问
    [https://github.com/](https://github.com/) 创建一个 GitHub 账户。
- en: A GitHub account will offer a few different subscription plans. The free plan
    offers everything we need to follow the examples in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 账户将提供几种不同的订阅计划。免费计划提供了我们跟随本书示例所需的一切。
- en: Companion source code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴随源代码
- en: 'The companion source code for this book can be found online at [https://github.com/remojansen/LearningTypeScript](https://github.com/remojansen/LearningTypeScript).
    The source code for this chapter includes a small example with the following directory
    architecture:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的相关源代码可以在网上找到，地址为 [https://github.com/remojansen/LearningTypeScript](https://github.com/remojansen/LearningTypeScript)。本章的源代码包括一个具有以下目录结构的小示例：
- en: '![](img/97401c5f-091d-40c0-aef8-1e02b83331a1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97401c5f-091d-40c0-aef8-1e02b83331a1.png)'
- en: 'There are two main files, named `main_server.ts` and `main_browser.ts`. Both
    files are located under the `src` directory. These files create an instance of
    a class named `Calculator` and use it to perform some operations. The result of
    the operations is logged in the console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要文件，分别命名为 `main_server.ts` 和 `main_browser.ts`。这两个文件都位于 `src` 目录下。这些文件创建了一个名为
    `Calculator` 的类的实例，并使用它执行一些操作。操作的结果被记录在控制台：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `main_browser.ts` file displays the results inside an HTML element instead
    of displaying them in the console. The `main_browser.ts` file also imports a `.scss`
    file to demonstrate how we can work with `.css` and `.scss` files,  with Webpack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`main_browser.ts` 文件在 HTML 元素内显示结果，而不是在控制台显示。`main_browser.ts` 文件还导入一个 `.scss`
    文件，以展示我们如何使用 Webpack 与 `.css` 和 `.scss` 文件一起工作。'
- en: 'The `Calculator` class can perform different kinds of mathematical operations
    and is defined in the `calculator.ts` file, which is located under the `src` directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator` 类可以执行不同种类的数学运算，并在 `src` 目录下的 `calculator.ts` 文件中定义：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Calculator` class can only perform two operations. Each operation is defined
    on its own file under the `operations` directory. The `add` operation is defined
    in the `add.ts` file and looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator` 类只能执行两种操作。每个操作都在 `operations` 目录下的单独文件中定义。加法操作在 `add.ts` 文件中定义，如下所示：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `pow` operation is defined in the `pow.ts` file and looks as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow` 操作定义在 `pow.ts` 文件中，其形式如下：'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the `isNumber` validation function looks as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`isNumber` 验证函数的形式如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are going to use these files during the rest of this chapter, which means
    that we might need to come back to them later to fully understand the rest of
    the contents of this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分使用这些文件，这意味着我们可能需要稍后返回来完全理解本章的其余内容。
- en: Source control tools
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制工具
- en: Now that we have installed Git and created a GitHub account, we will use GitHub
    to create a new code repository. A repository is a central file storage location.
    It is used by the source control systems to store multiple versions of files.
    While a repository can be configured on a local machine for a single user, it
    is often stored on a server, which can be accessed by multiple users.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Git 并创建了 GitHub 账户，我们将使用 GitHub 来创建一个新的代码仓库。仓库是一个中央文件存储位置。源代码控制系统使用它来存储文件的多个版本。虽然仓库可以在本地机器上为单个用户配置，但它通常存储在服务器上，可以被多个用户访问。
- en: 'To create a new repository on GitHub, log in to your GitHub account and click
    on the link to create a new repository, which you can find in the top-right corner
    of the screen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 GitHub 上创建一个新的仓库，请登录到你的 GitHub 账户，然后在屏幕右上角点击创建新仓库的链接：
- en: '![](img/64ea8ec7-7154-4125-9e0d-4f5c45ec2b78.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64ea8ec7-7154-4125-9e0d-4f5c45ec2b78.png)'
- en: 'A form similar to the one in the following screenshot will then be displayed
    on screen:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上会显示与以下截图相似的表单：
- en: '![](img/a239ba06-7171-4c13-9c3b-3126909fb8d4.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a239ba06-7171-4c13-9c3b-3126909fb8d4.png)'
- en: This form contains some fields that allow us to set the repository's name, description,
    and some privacy settings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单包含一些字段，允许我们设置仓库的名称、描述和一些隐私设置。
- en: Please note that you will need a paid GitHub account if you want to use a private
    repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你想要使用私有仓库，你需要一个付费的 GitHub 账户。
- en: We can also add a `README.md` file, which uses markdown syntax and is used to
    add whatever text we want to the repository home page on GitHub. Furthermore,
    we can add a default `.gitignore` file, which is used to specify files that we
    would like to be ignored by Git and therefore not be saved into the repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个 `README.md` 文件，它使用 Markdown 语法，并用于将我们想要添加到 GitHub 仓库主页上的任何文本。此外，我们还可以添加一个默认的
    `.gitignore` 文件，该文件用于指定我们希望 Git 忽略的文件，因此这些文件不会被保存到仓库中。
- en: The recommended option for the default `.gitignore` file is `Node`. We will
    use GitHub throughout this book. However, if you want to use a local repository,
    you can use the Git `init` command to create an empty repository. Refer to the
    Git documentation at [http://git-scm.com/docs/git-init](http://git-scm.com/docs/git-init)
    to learn more about the `git init` command and working with a local repository.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `.gitignore` 文件推荐选项是 `Node`。本书中我们将使用 GitHub。然而，如果你想要使用本地仓库，你可以使用 Git 的 `init`
    命令来创建一个空仓库。有关 `git init` 命令和本地仓库操作的更多信息，请参考 Git 文档[http://git-scm.com/docs/git-init](http://git-scm.com/docs/git-init)。
- en: Last, but not less important, we can also select a software license to cover
    our source code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们还可以选择一个软件许可来覆盖我们的源代码。
- en: 'Once we have created the repository, we will visit our profile page on GitHub,
    find the repository that we have just created, and visit it. In the repository''s
    home page, we will be able to find the clone URL in the top-right corner of the
    page:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了仓库，我们将访问 GitHub 上的个人资料页面，找到我们刚刚创建的仓库，并访问它。在仓库的主页上，我们可以在页面的右上角找到克隆 URL：
- en: '![](img/32bb99ac-aa20-4a23-b183-eb6f53c0a427.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32bb99ac-aa20-4a23-b183-eb6f53c0a427.png)'
- en: clone URL
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆 URL
- en: 'We need to copy the repository''s clone URL, open a console, and use the URL
    as an argument of the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复制仓库的克隆 URL，打开控制台，并将 URL 作为以下命令的参数：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sometimes the Windows **command-line interface** (**CLI**) is not able to find
    the Git and Node commands. The easiest way to get around this issue is to use
    the Git console (installed with Git) rather than using the Windows command line. If
    you want to use the Windows console, you will need to manually add the Git and
    Node installation paths to the Windows `PATH` environment variable. If you are
    working with OS X or Linux, the default CLI should work fine. Also, note that
    we will use the Unix path syntax in all the examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Windows的**命令行界面**（**CLI**）无法找到Git和Node命令。绕过这个问题的最简单方法是用Git控制台（与Git一起安装）而不是使用Windows命令行。如果您想使用Windows控制台，您需要手动将Git和Node的安装路径添加到Windows的`PATH`环境变量中。如果您使用的是OS
    X或Linux，默认的CLI应该可以正常工作。此外，请注意，在所有示例中，我们将使用Unix路径语法。
- en: 'The command''s output should look similar to the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出应该类似于以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then move into the repository''s directory using the change directory
    command (`cd`) and use the `git status` command to check the local repository
    status. The command''s output should look similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用更改目录命令（`cd`）进入仓库目录，并使用`git status`命令来检查本地仓库状态。命令的输出应该类似于以下内容：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `git status` command is telling us that there are no changes in our working
    directory. Let''s open the repository folder in Visual Studio Code and create
    a new file called `gulpfile.js`. Now, run the `git status` command again, and
    we should see some new untracked files:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`git status`命令告诉我们工作目录中没有更改。现在，让我们在Visual Studio Code中打开仓库文件夹，创建一个名为`gulpfile.js`的新文件。现在，再次运行`git
    status`命令，我们应该看到一些新的未跟踪文件：'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The project explorer in Visual Studio Code displays the files using a color
    code to help us to identify whether a file is new (green), has been removed (red),
    or has changed (yellow) since our last commit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code中的项目资源管理器使用颜色代码显示文件，以帮助我们识别自上次提交以来文件是否是新添加的（绿色）、已被删除（红色）或已更改（黄色）。
- en: 'When we make some changes, such as adding a new file or changing an existing
    file, we need to execute the `git add` command to indicate that we want to add
    that change to a snapshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行一些更改，例如添加新文件或更改现有文件时，我们需要执行`git add`命令来指示我们想要将此更改添加到快照中：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have staged the content we want to snapshot, we have to run the
    `git commit` command to actually record the snapshot. Recording a snapshot requires
    a commentary field, which can be provided using the `git commit` command together
    with the `-m` argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将想要快照的内容放入暂存区，我们必须运行`git commit`命令来实际记录快照。记录快照需要注释字段，可以使用`git commit`命令与`-m`参数一起提供：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To run the preceding command you need to configure your GitHub email/username
    on the Terminal. You can use any one of the following commands to configure your
    GitHub account on the Terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行上述命令，您需要在终端上配置您的GitHub电子邮件/用户名。您可以使用以下任一命令在终端上配置GitHub账户：
- en: '`git config --global user.email "you@example.com"`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`git config --global user.email "you@example.com"`'
- en: '`git config --global user.name "Your Name"`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`git config --global user.name "Your Name"`'
- en: 'If everything goes well, the command output should be similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，命令输出应该类似于以下内容：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To share the commit with the other developers, we need to push our changes
    to the remote repository. We can do this by executing the `git push` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要与其他开发者共享提交，我们需要将我们的更改推送到远程仓库。我们可以通过执行`git push`命令来完成：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `git push` command will ask for our GitHub username and password and then
    send the changes to the remote repository. If we visit the repository's page on
    GitHub, we will be able to find the recently created file. We will return to GitHub
    later in this chapter to configure our CI server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push`命令将要求我们输入GitHub用户名和密码，然后将更改发送到远程仓库。如果我们访问GitHub上的仓库页面，我们将能够找到最近创建的文件。我们将在本章的后面部分回到GitHub以配置我们的CI服务器。'
- en: If we are working with a large team, we might encounter some file conflicts
    when attempting to push some changes to the remote repository. Resolving a file
    conflict is out of the scope of this book; however, if you need further information
    about Git, you will find an extensive user manual at [https://www.kernel.org/pub/software/scm/git/docs/user-manual.html](https://www.kernel.org/pub/software/scm/git/docs/user-manual.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与一个大型团队一起工作，在尝试将一些更改推送到远程仓库时可能会遇到一些文件冲突。解决文件冲突超出了本书的范围；然而，如果您需要有关Git的更多信息，您将在[https://www.kernel.org/pub/software/scm/git/docs/user-manual.html](https://www.kernel.org/pub/software/scm/git/docs/user-manual.html)找到一个详尽的用户手册。
- en: Package management tools
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理工具
- en: Package management tools are used for dependency management, so that we no longer
    have to manually download and manage our application's dependencies. We are not
    going to cover package management tools in this chapter because we have already
    covered them in [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理工具用于依赖管理，这样我们就不必手动下载和管理应用程序的依赖项。在本章中，我们不会涵盖包管理工具，因为我们已经在第5章[与依赖项一起工作](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)中介绍过它们。
- en: The TypeScript compiler
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript编译器
- en: 'Now that we have learned how to use `npm`, we can install TypeScript using
    the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用`npm`，我们可以使用以下命令安装TypeScript：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The TypeScript compiler will then become available in our CLI as a command
    named `tsc`. We can check the version of TypeScript installed in our machine using
    the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将在我们的CLI中以名为`tsc`的命令的形式可用。我们可以使用以下命令检查机器上安装的TypeScript版本：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The TypeScript compiler accepts many more options. For example, we can use
    the `--target` or `-t` option to select which version of JavaScript we would like
    to target as the compilation output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器接受许多其他选项。例如，我们可以使用`--target`或`-t`选项来选择我们希望作为编译输出的JavaScript版本：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we can create a `tsconfig.json` file to set the desired compilation
    settings. We can also use the TypeScript compiler to autogenerate a `tsconfig.json`
    file with default settings using the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个`tsconfig.json`文件来设置所需的编译设置。我们还可以使用TypeScript编译器使用以下命令自动生成具有默认设置的`tsconfig.json`文件：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After creating a `tsconfig.json` file, you can pass it to the TypeScript compiler
    using the `--project` or `-p` option:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`tsconfig.json`文件后，您可以使用`--project`或`-p`选项将其传递给TypeScript编译器：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please refer to the official TypeScript documentation at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    if you wish to learn more about the available compilation options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于可用编译选项的信息，请参阅官方TypeScript文档[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。
- en: Unit testing and test coverage
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和测试覆盖率
- en: Unit testing refers to the practice of testing certain functions and areas (units)
    of our code. This gives us the ability to verify that our functions work as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是指测试我们代码中某些函数和区域（单元）的实践。这使我们能够验证我们的函数是否按预期工作。
- en: It is expected that the reader will have some understanding of the unit test
    process, but the contents exposed here will be covered at a much higher level
    of detail in [Chapter 14](e365ca9e-d510-4127-a701-959ad8e2626f.xhtml), *Application
    Testing*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 预期读者对单元测试过程有一定了解，但这里所涉及的内容将在第14章[应用测试](e365ca9e-d510-4127-a701-959ad8e2626f.xhtml)中更详细地介绍。
- en: 'At the beginning of this chapter, we included the most important parts of the
    application included in the companion source code for this chapter. The source
    code defined a calculator with support for two operations: `pow` and `add`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们包括了本章配套源代码中包含的应用程序最重要的部分。源代码定义了一个支持两个操作`pow`和`add`的计算器。
- en: 'The `pow` operation expects two numbers as its arguments and has two possible
    execution paths:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow`操作期望两个数字作为其参数，并有两个可能的执行路径：'
- en: The `pow` function will throw an exception if one of the two arguments provided
    is not a number
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供的两个参数中有一个不是数字，`pow`函数将抛出异常
- en: The `pow` function will return a number if both arguments are valid numbers
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个参数都是有效的数字，`pow`函数将返回一个数字
- en: Ideally, we will write a unit test of each of the execution paths of our function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们将为函数的每个执行路径编写一个单元测试。
- en: 'The following code snippet declares a couple of unit tests for the `pow` operation
    using two testing libraries, `mocha` and `chai`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用两个测试库`mocha`和`chai`为`pow`操作声明了几个单元测试：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code snippet groups all the tests related to the `pow` operation
    in what is known as a **test fixture**. A test fixture can be defined using the
    `describe` function and is just a group of test cases. A test case can be defined
    using the `it` functions and can contain one or more test assertions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将所有与`pow`操作相关的测试组合在所谓的**测试夹具**中。测试夹具可以使用`describe`函数定义，它只是一组测试用例。测试用例可以使用`it`函数定义，可以包含一个或多个测试断言。
- en: Our test assertions are defined using the `assert` function, which is part of
    the Chai library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试断言是通过 `assert` 函数定义的，它是 Chai 库的一部分。
- en: Both the `describe` and the `it` functions are global functions declared by
    Mocha. We don’t need to import `Mocha` because it is imported as a global by our
    test runner configuration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 和 `it` 函数都是 Mocha 声明的全局函数。我们不需要导入 `Mocha`，因为它是通过我们的测试运行器配置作为全局导入的。'
- en: 'We can run the tests and generate a test coverage report using the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行测试并生成测试覆盖率报告：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command uses `nyc`, which is a tool used to generate test coverage
    reports. This tool uses `ts-node` and `mocha` to run the tests. This explains
    why we can run the test without compiling them and why we can use Mocha without
    importing it explicitly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用了 `nyc`，这是一个用于生成测试覆盖率报告的工具。该工具使用 `ts-node` 和 `mocha` 来运行测试。这也解释了为什么我们可以不编译测试代码就运行测试，以及为什么我们可以使用
    Mocha 而不必显式导入。
- en: 'This command is not very convenient, but we can declare an `npm` command to
    solve this problem:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令不是很方便，但我们可以声明一个 `npm` 命令来解决这个问题：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please note that we need to install all these dependencies and their type definitions
    (when appropriate) using npm. We can then use the following npm command instead:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要使用 npm 安装所有这些依赖项及其类型定义（当适用时）。然后我们可以使用以下 npm 命令：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The companion source code includes many more tests. The existing tests cover
    most of the possible execution paths of all the existing functions in the application
    but don''t fully cover the `main_server.ts` file. This can be observed in the
    test coverage report generated by `nyc`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的源代码包含更多的测试。现有的测试覆盖了应用程序中所有现有函数的大多数可能的执行路径，但并没有完全覆盖 `main_server.ts` 文件。这可以在
    `nyc` 生成的测试覆盖率报告中观察到：
- en: '![](img/a7835ccc-7b03-401d-ba39-c7fe34f9fef0.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7835ccc-7b03-401d-ba39-c7fe34f9fef0.png)'
- en: Linting tools
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码风格检查工具
- en: The following tool is a code linting tool. A linting tool helps us to enforce
    certain code styling rules in our code base. For example, in a large development
    team, it is very common to have long discussions about the code styling.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具是一个代码风格检查工具。代码风格检查工具帮助我们强制执行代码库中的某些代码风格规则。例如，在一个大型开发团队中，关于代码风格的长时间讨论是非常常见的。
- en: The term *code styling* refers to certain cosmetic elements of our code, such
    as using spaces or tabs. However, sometimes the code styling involves certain
    rules that are not purely cosmetic and are intended to make our code more maintainable.
    A good example of this would be a code styling rule that enforces using trailing
    commas.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *代码风格* 指的是我们代码的某些外观元素，例如使用空格或制表符。然而，有时代码风格涉及某些规则，这些规则不仅仅是外观上的，而是旨在使我们的代码更易于维护。一个很好的例子是强制使用尾随逗号的代码风格规则。
- en: Code styling guidelines and rules are great but enforcing them can take a significant
    amount of human effort. We would have to review every single code change to make
    sure that the code contributions respect our code styling rules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码风格指南和规则很好，但执行它们可能需要大量的人工努力。我们必须审查每一个代码更改，以确保代码贡献符合我们的代码风格规则。
- en: The main goal of a linting tool is to automate the enforcement of the code styling
    rules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码风格检查工具的主要目标是自动化执行代码风格规则的实施。
- en: 'In the TypeScript world, the leading linting tool is **tslint**. We can install
    `tslint` using `npm`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 世界中，主要的代码风格检查工具是 **tslint**。我们可以使用 `npm` 安装 `tslint`：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then need to create a `tslint.json` file. This file contains the configuration
    that allows us to enable and disable certain styling rules. The following code
    snippet is an example of a `tslint.json` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个 `tslint.json` 文件。该文件包含允许我们启用和禁用某些风格规则的配置。以下是一个 `tslint.json` 文件的代码片段示例：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After creating the `tslint.json` file, we can check our source code using the
    following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `tslint.json` 文件后，我们可以使用以下命令检查我们的源代码：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command is not really convenient. We can use `npm` `scripts`
    to create a more convenient command, named `lint`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令并不太方便。我们可以使用 `npm` 脚本来创建一个更方便的命令，命名为 `lint`：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then run `tslint` using the following `npm` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下 `npm` 命令运行 `tslint`：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Working with npm scripts
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 脚本
- en: The `package.json` file contains a field named `scripts`. This field can contain
    multiple entries, and each entry is used to create a command. A command can execute
    any kind of custom logic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件包含一个名为 `scripts` 的字段。该字段可以包含多个条目，每个条目用于创建一个命令。一个命令可以执行任何类型的自定义逻辑。'
- en: 'When we create the `package.json` file using the `npm init` command, the default
    command is not implemented:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`npm init`命令创建`package.json`文件时，默认命令尚未实现：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a real-world scenario, we would have multiple commands as in the following
    example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，我们会有多个命令，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some commands, such as the `test`, `install`, or `start` commands, are considered
    standard commands. You can execute a standard command by using the `npm` command
    followed by the name of the standard command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令，例如`test`、`install`或`start`命令，被视为标准命令。您可以通过使用`npm`命令后跟标准命令的名称来执行标准命令：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the commands that are not considered standard, we need to use the `npm`
    command followed by the `run` command and the name of the command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不被视为标准的命令，我们需要使用`npm`命令后跟`run`命令和命令的名称：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Please refer to the npm documentation at [https://docs.npmjs.com](https://docs.npmjs.com)
    to learn more about all the npm features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://docs.npmjs.com](https://docs.npmjs.com)上的npm文档，了解更多关于所有npm功能的信息。
- en: Gulp
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gulp
- en: Two of the most popular JavaScript task runners are Grunt and Gulp. The main
    difference between Gulp and Grunt is that while in Grunt we work using files as
    the input and output of our tasks, in Gulp we work with streams and pipes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最受欢迎的JavaScript任务运行器是Grunt和Gulp。Gulp与Grunt的主要区别在于，在Grunt中，我们使用文件作为任务输入和输出，而在Gulp中，我们使用流和管道。
- en: Grunt is configured using some configuration fields and values. However, Gulp
    prefers code over configuration. This approach makes the Gulp configuration somehow
    more minimalist and easy to read.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt使用一些配置字段和值进行配置。然而，Gulp更倾向于代码而非配置。这种方法使Gulp配置在某些方面更加简约且易于阅读。
- en: In this book, we will work with Gulp; however, if you want to learn more about
    Grunt, you can do so at [http://gruntjs.com/](http://gruntjs.com/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Gulp；然而，如果您想了解更多关于Grunt的信息，可以在[http://gruntjs.com/](http://gruntjs.com/)学习。
- en: To gain a good understanding of Gulp, we are going to configure some tasks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Gulp，我们将配置一些任务。
- en: 'Let''s start by installing `gulp` using `npm`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用`npm`安装`gulp`：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then let''s create a JavaScript file named `gulpfile.js` inside the root folder
    of our project, which should contain the following piece of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在我们的项目根目录内创建一个名为`gulpfile.js`的JavaScript文件，它应该包含以下代码片段：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, finally, run `gulp`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`gulp`：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please note that we installed Gulp using the `-g` flag because we are going
    to invoke the `gulp` command directly from the command-line interface. However,
    if we are planning to use `npm scripts`, we should install Gulp and any other
    dependencies as project dependencies using the `--save-dev` flag instead. Note
    that using global (`-g`) dependencies is not recommended. Also, note that we must
    execute this command from the location in which the `gulpfile.js` file is located.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`-g`标志安装了Gulp，因为我们打算直接从命令行界面调用`gulp`命令。然而，如果我们打算使用`npm scripts`，我们应该使用`--save-dev`标志将Gulp和任何其他依赖项作为项目依赖项安装。请注意，使用全局（`-g`）依赖项是不推荐的。另外，请注意，我们必须从`gulpfile.js`文件所在的目录执行此命令。
- en: 'We have created our first Gulp task, which is named `hello`. When we run the
    `gulp` command, it will automatically try to search for the `gulpfile.js` in the
    current directory, and once found, it will try to find the `hello` task. If everything
    worked as expected, we should see an output similar to the following in our CLI:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们第一个Gulp任务，该任务命名为`hello`。当我们运行`gulp`命令时，它将自动尝试在当前目录中搜索`gulpfile.js`，一旦找到，它将尝试找到`hello`任务。如果一切按预期进行，我们应该在我们的CLI中看到以下类似的输出：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will now add a second task, which will use the `gulp-tslint` plugin to check
    whether our TypeScript code follows a series of recommended practices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加第二个任务，该任务将使用`gulp-tslint`插件来检查我们的TypeScript代码是否遵循一系列推荐的最佳实践。
- en: 'We need to install the plugin with `npm`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`npm`安装该插件：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can then load the plugin in our `gulpfile.js` file and add a new task:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`gulpfile.js`文件中加载该插件并添加一个新任务：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have named the new task `lint`. Let''s take a look at the operations performed
    by the `lint` task, step by step:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新任务命名为`lint`。让我们一步一步地查看`lint`任务执行的操作：
- en: The `gulp src` function will read the files with the file extension `.ts` located
    in the `src` directory and its subdirectories. We are also fetching all the files
    with the file extension `.test.ts` in the directory located in `test` and its
    subdirectories.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gulp src`函数将读取位于`src`目录及其子目录中具有`.ts`文件扩展名的文件。我们还在`test`目录及其子目录中检索所有具有`.test.ts`文件扩展名的文件。'
- en: Many plugins allow us to indicate files to be ignored by adding the exclamation
    symbol (`!`) before a path. For example, the path `!path/*.d.ts` will ignore all
    files with the extension `.d.ts`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pipe` function is used to pass the output stream of the `src` as the input
    of the `gulpTslint` function.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the output of the `tslint` function as the input of the `report`
    function.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have added the `lint` task, we will modify the `gulpfile.js` file
    to add one more task, named `default`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The default task can be used to invoke both the `hello` and `lint` tasks. When
    we define a `gulp` task, we invoke the `task` function with two arguments. The
    first argument is the task name. The second argument can take a function that
    defines a task or an array containing a list of subtasks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the gulp task execution order
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now learn how to control the order in which the tasks are executed.
    If we try to execute the default, the `hello` and `lint` tasks will be executed
    in parallel because the subtasks are executed in parallel by default.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we will need to run our tasks in a certain order. Controlling the
    execution order of our tasks can be challenging since in Gulp all the tasks are
    asynchronous by default.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: However, there are three ways to make a task synchronous.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Passing in a callback to the task definition function
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to pass a callback function to the task definition function
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Returning a promise
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to use a promise as the return of the task definition
    function as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Returning a stream
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do is to use a stream as the return of the task definition function.
    This is simple because the pipe operator returns a stream:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have some synchronous tasks, we can use them as a subtask of a
    new task named `async`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we can see in the preceding code snippet, it is also possible to define
    a task that has some subtasks. However, if the complexity of our build process
    increases, we can end up with a very difficult to follow task dependency graph.
    Fortunately, we can install the `run-sequence` Gulp plugin via `npm`, which will
    allow us to have better control over the task execution order:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code snippet will run in the following order:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`lint`'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tsc` and `tsc-tests` in parallel'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bundle-js` and `bundle-test` in parallel'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`karma`'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`browser-sync`'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gulp development team announced plans to improve the management of the task
    execution order without the need of external plugins. Refer to the Gulp documentation
    at [https://github.com/gulpjs/gulp/](https://github.com/gulpjs/gulp/) to learn
    more about it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, when we compile our TypeScript code, the compiler will generate
    a JavaScript file for each existing TypeScript file. If we run the application
    in a web browser, these files won't be really useful on their own because the
    only way to use them would be to create an individual HTML `script` tag for each
    one of them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: However, this would be highly inconvenient and inefficient because each `script`
    tag will translate into a round trip between the web browser and the server serving
    the JavaScript files. Using `script` tags is also slower than using Ajax calls
    because `script` tags can prevent the browser from rendering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将非常不方便且效率低下，因为每个 `script` 标签都会在浏览器和提供 JavaScript 文件的服务器之间产生往返。使用 `script`
    标签也比使用 Ajax 调用慢，因为 `script` 标签可以阻止浏览器渲染。
- en: Please note that in a modern web browser, we can make some of the `script` tags
    asynchronous but it is not always an option. Please refer to [https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript) to
    learn more about asynchronous scripts.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在现代浏览器中，我们可以使一些 `script` 标签异步，但这并不总是可行的选项。请参阅[https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript)
    了解有关异步脚本的更多信息。
- en: 'Fortunately, there are a few potential solutions for this problem:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几个潜在的解决方案可以解决这个问题：
- en: '**Load the files using AJAX calls**: We can use a tool to load each of the
    JavaScript files on demand using AJAX calls. This approach is known as asynchronous
    module loading. To follow this approach, we will need to use Require.js and change
    the configuration of the TypeScript compiler to use the asynchronous module definition
    (AMD) notation.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 AJAX 调用加载文件**：我们可以使用一个工具按需使用 AJAX 调用加载每个 JavaScript 文件。这种方法被称为异步模块加载。为了遵循这种方法，我们需要使用
    Require.js 并更改 TypeScript 编译器的配置以使用异步模块定义（AMD）语法。'
- en: '**Bundle all the files into one unique file and load it using a script tag**:
    We can use a tool to trace the application modules and dependencies and generate
    a highly optimized single file, which will contain all the application modules.
    To follow this approach, we will need to use a tool, such as Webpack or Browserify
    and change the configuration of the TypeScript compiler to use the correct module
    syntax (usually CommonJS).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有文件打包成一个唯一的文件并使用脚本标签加载**：我们可以使用一个工具跟踪应用程序模块和依赖项，并生成一个高度优化的单个文件，该文件将包含所有应用程序模块。为了遵循这种方法，我们需要使用工具，如
    Webpack 或 Browserify，并更改 TypeScript 编译器的配置以使用正确的模块语法（通常是 CommonJS）。'
- en: '**Hybrid approach**: We can follow a hybrid approach by creating a highly optimized
    bundle that contains the minimum number of files required by the application to
    be able to work. Additional files are then loaded on demand using AJAX calls when
    they are required by the application users.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合方法**：我们可以通过创建一个高度优化的包，其中包含应用程序运行所需的最少文件数，来遵循混合方法。当应用程序用户需要时，额外的文件将按需使用
    AJAX 调用加载。'
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more about modules.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 5 章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，以了解更多关于模块的信息。
- en: 'In this chapter, we are going to focus on the second approach. We will create
    a highly optimized module bundler using Webpack. Creating a highly optimized application
    bundle usually involves multiple steps; Webpack can perform each of these tasks
    but it is not really designed to be used as a task runner. We can install Webpack
    using `npm`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注第二种方法。我们将使用 Webpack 创建一个高度优化的模块打包器。创建一个高度优化的应用程序包通常涉及多个步骤；Webpack
    可以执行这些任务中的每一个，但它并不是真正设计用来作为任务运行器的。我们可以使用 `npm` 安装 Webpack：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are also going to install a few extra modules required by this example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装一些由本例所需的额外模块：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Most of these modules are Webpack plugins and their dependencies. We need them
    because we are going to use them in our Webpack configuration file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些模块都是 Webpack 插件及其依赖项。我们需要它们，因为我们将要在我们的 Webpack 配置文件中使用它们。
- en: We can configure Webpack by creating a file named `webpack.config.js` in the
    root directory of our project. The following code section displays the entire
    content of the Webpack configuration file used by the companion source code of
    this chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在项目的根目录中创建一个名为 `webpack.config.js` 的文件来配置 Webpack。以下代码部分显示了本章配套源代码中使用的整个
    Webpack 配置文件的内容。
- en: 'The `webpack.config.js` file is importing some dependencies:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.config.js` 文件正在导入一些依赖项：'
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we declare three variables:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明三个变量：
- en: The `corePlugins` variable is an array that contains the configuration of Webpack
    plugins that are used in development builds and production builds
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corePlugins`变量是一个数组，它包含用于开发构建和生产构建的Webpack插件的配置'
- en: The `devPlugins` variable is an array that contains the configuration of Webpack
    plugins used in development builds only
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devPlugins`变量是一个数组，它只包含开发构建中使用的Webpack插件的配置'
- en: The `prodPlugins` variable is an array that contains the configuration of Webpack
    plugins used in production builds only
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prodPlugins`变量是一个数组，它只包含生产构建中使用的Webpack插件的配置'
- en: 'Each of the plugins requires some specific configuration. For example, the
    `ExtractTextPlugin` is used to extract our CSS code from the main application
    bundle:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件都需要一些特定的配置。例如，`ExtractTextPlugin`用于从主应用包中提取我们的CSS代码：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The configuration file uses the environment variable `NODE_ENV` determine whether
    we are running a development build or a production build. The production build
    uses the `uglify` plugin, but it is not used by the development build.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件使用环境变量`NODE_ENV`来确定我们是在运行开发构建还是生产构建。生产构建使用`uglify`插件，但在开发构建中并不使用。
- en: We then use the `uglify` plugin to minimize the output size. The reduced file
    size will reduce the application loading time but will make it harder to debug.
    Fortunately, we can generate source maps to facilitate the debugging process.
    The source maps are generated by the `source-map-loader` plugin.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`uglify`插件来最小化输出文件的大小。文件大小的减小将减少应用加载时间，但会使调试变得更加困难。幸运的是，我们可以生成源映射来简化调试过程。源映射是由`source-map-loader`插件生成的。
- en: Uglify removes all line breaks and whitespaces and reduces the length of some
    variable names. Source map files allow us to map the source code of the reduced
    file to its original code while debugging. A source map provides a way of mapping
    code within a compressed file back to its original position in a source file.
    This means we can easily debug an application even after its assets have been
    optimized. The Chrome and Firefox developer tools both ship with built-in support
    for source maps.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Uglify移除所有换行符和空白字符，并缩短一些变量名的长度。源映射文件允许我们在调试时将压缩文件的源代码映射到其原始代码。源映射提供了一种将压缩文件中的代码映射回源文件中原始位置的方法。这意味着我们可以在优化资产之后轻松地调试应用。Chrome和Firefox开发者工具都内置了对源映射的支持。
- en: At this point, we define the application's entry point. We use an object as
    a map to define an entry point, which means that we can define multiple entry
    points. Each entry point is transformed into a `bundle.js` file that will be stored
    under a directory named `public`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们定义了应用的入口点。我们使用一个对象作为映射来定义一个入口点，这意味着我们可以定义多个入口点。每个入口点都会转换成一个名为`bundle.js`的文件，该文件将被存储在名为`public`的目录下。
- en: As we can see in the rest of the `webpack.config.js` file, we have appended
    a forward slash to the name of the application's entry point. We have also used
    a special syntax to use the name of the entry point as part of the name of the
    output files (for example, `[name]bundle.js`). This is a trick that we can use
    to generate a unique folder for each of the output bundles.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`webpack.config.js`文件的其余部分所看到的，我们在应用的入口点名称后附加了一个正斜杠。我们还使用了一种特殊语法，将入口点的名称作为输出文件名称的一部分（例如，`[name]bundle.js`）。这是一个我们可以用来为每个输出包生成唯一文件夹的技巧。
- en: 'Finally, the file declares the configuration for some of the plugins, such
    as the TypeScript plugin or the `sass` plugin:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该文件声明了一些插件的配置，例如TypeScript插件或`sass`插件：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can execute the Webpack bundling process using the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令执行Webpack打包过程：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Please note that we must execute this command from the location in which the
    `gulpfile.js` file is located.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须从`gulpfile.js`文件所在的目录执行此命令。
- en: 'If everything went well, we should be able to see a new folder named `public`.
    The `public` folder should contain the following files:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能看到一个名为`public`的新文件夹。`public`文件夹应包含以下文件：
- en: '![](img/04a03f6d-0182-4c43-b7f7-7bd37b14bf4f.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04a03f6d-0182-4c43-b7f7-7bd37b14bf4f.png)'
- en: 'The companion source code also includes a file named `index.html`. This file
    is the entry point of the frontend application that we just created:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码还包括一个名为`index.html`的文件。此文件是我们刚刚创建的前端应用的入口点：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This example should give us a good first impression about how to work with Webpack.
    The following section describes how we can use the Webpack development as a web
    server to access this application from a web browser.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应该能给我们一个关于如何使用 Webpack 的良好第一印象。下一节将描述我们如何使用 Webpack 开发服务器作为 Web 服务器来从 Web
    浏览器访问此应用程序。
- en: Please refer to the documentation at [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)
    if you need additional information about webpack. It is also recommended to refer
    to the documentation of each of the plugins to learn more about the available
    configuration options. Some npm modules might require some additional tools. It
    is not very common, but some modules might require tools such as the gcc/g++ compilers
    and the Python interpreter to be installed in your development environment. Please
    refer to the documentation of your operating system online to learn how to install
    the gcc/g++ compilers and the Python interpreter if you encounter this kind of
    issue.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要关于 webpack 的更多信息，请参阅 [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)
    的文档。还建议参考每个插件的文档，以了解更多关于可用配置选项的信息。某些 npm 模块可能需要一些额外的工具。这种情况并不常见，但某些模块可能需要安装 gcc/g++
    编译器和 Python 解释器等工具到您的开发环境中。如果您遇到此类问题，请查阅您操作系统的在线文档，了解如何安装 gcc/g++ 编译器和 Python
    解释器。
- en: Webpack development server
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack 开发服务器
- en: The Webpack development server is a command-line utility that monitors our filesystem
    for changes and triggers the Webpack bundling process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 开发服务器是一个命令行工具，它监视我们的文件系统以查找变化，并触发 Webpack 打包过程。
- en: 'We can install the Webpack development server using npm:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 npm 安装 Webpack 开发服务器：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can then execute the webpack development server using the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令执行 webpack 开发服务器：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Webpack development server will then start watching our filesystem for changes.
    If a change is detected, it will automatically run the Webpack build process using
    the existing the `webpack.config.js` file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 开发服务器将开始监视我们的文件系统以查找变化。如果检测到变化，它将自动使用现有的 `webpack.config.js` 文件运行 Webpack
    构建过程。
- en: The Webpack development server also starts a web server. The server is running
    on port 8080 by default.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 开发服务器还会启动一个 Web 服务器。默认情况下，服务器运行在端口 8080 上。
- en: Please refer to the documentation at [https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server)
    to learn more about the Webpack development server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server)
    上的文档，以了解更多关于 Webpack 开发服务器的信息。
- en: Visual Studio Code
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'Visual Studio is a lightweight but powerful code editor with an extensive number
    of features. Learning all these features is out of the scope of this book because
    we could dedicate an entire book to cover them. However, we are going to dedicate
    a little bit of time to learning about two of the best features available in this
    code editor: quick fixes and the code debugger.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 是一个轻量级但功能强大的代码编辑器，具有众多功能。学习所有这些功能超出了本书的范围，因为我们完全可以写一本书来涵盖它们。然而，我们将花一点时间来了解这个代码编辑器中两个最好的功能：快速修复和代码调试器。
- en: It is recommended to read the Visual Studio Code user guide at [https://code.visualstudio.com/docs/editor/codebasics](https://code.visualstudio.com/docs/editor/codebasics)
    to learn how to make the most of this IDE.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 建议阅读 Visual Studio Code 用户指南 [https://code.visualstudio.com/docs/editor/codebasics](https://code.visualstudio.com/docs/editor/codebasics)，以了解如何充分利用此
    IDE。
- en: Quick fixes
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速修复
- en: Visual Studio Code can detect some errors and automatically fix them using a
    set of features known as *quick fixes*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 可以检测一些错误，并使用一组称为 *快速修复* 的功能自动修复它们。
- en: 'Visual Studio Code will display a bulb icon on the left-hand side of our code
    near some error. If we click on the bulb icon, Visual Studio Code will display
    all the available quick fixes. If we select one of the available quick fixes,
    Visual Studio Code will perform the necessary changes to solve the problem automatically:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 将在我们的代码中某些错误附近左侧显示一个灯泡图标。如果我们点击灯泡图标，Visual Studio Code 将显示所有可用的快速修复。如果我们选择其中一个可用的快速修复，Visual
    Studio Code 将自动执行必要的更改以解决问题：
- en: '![](img/0d016bb6-1551-4826-975d-f28ff5d27c01.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d016bb6-1551-4826-975d-f28ff5d27c01.png)'
- en: Debugging utilities
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试工具
- en: 'Before we can debug our application using Node.js, we need to configure a debugging
    task in Visual Studio Code. We need to select the debug panel and add a new configuration:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用Node.js调试我们的应用程序之前，我们需要在Visual Studio Code中配置一个调试任务。我们需要选择调试面板并添加一个新的配置：
- en: '![](img/6983883b-b282-4153-986a-7563557bccd9.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6983883b-b282-4153-986a-7563557bccd9.png)'
- en: 'A panel with a few options will then be displayed. We need to select Node.js.
    If you want to run and debug the application using Docker, you will be able to
    do so as well but it is out of the scope of this book:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将显示一个带有几个选项的面板。我们需要选择Node.js。如果您想使用Docker运行和调试应用程序，您也可以这样做，但这本书的范围之外：
- en: '![](img/44cf7ca9-791f-40b8-b905-01b19d51a4cf.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44cf7ca9-791f-40b8-b905-01b19d51a4cf.png)'
- en: Selecting Node.js will create a folder named `.vscode` and a file named `launch.json`.
    This file allows us to define as many debugging tasks as we may need. A debug
    task declares the instructions required to debug our unit tests.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Node.js将会创建一个名为`.vscode`的文件夹和一个名为`launch.json`的文件。这个文件允许我们定义我们可能需要的任意数量的调试任务。一个调试任务声明了调试我们的单元测试所需的指令。
- en: The configuration of the debugging task is different for each testing tool.
    In the example application, we have used `mocha`, which means that our debugging
    task will need to use the `mocha` binary and some arguments to start a debugging
    session.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 调试任务的配置对于每个测试工具都是不同的。在示例应用中，我们使用了`mocha`，这意味着我们的调试任务将需要使用`mocha`二进制文件和一些参数来启动调试会话。
- en: 'The following configuration can be used to debug the tests in the example application:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置可以用于调试示例应用程序中的测试：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Please note that the `.vscode` folder must be in the root of your project. The
    companion source code includes this folder under the chapter's folder instead
    of the root directory. If you want to try it, you will need to open the chapter's
    folder as the root directory with Visual Studio Code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`.vscode`文件夹必须位于项目的根目录下。配套源代码在章节文件夹下包含此文件夹，而不是在根目录下。如果您想尝试，您需要使用Visual Studio
    Code将章节文件夹作为根目录打开。
- en: 'After creating and configuring the `launch.json` file, we can select the task
    that we just defined under the DEBUG panel and click on the *Play* button:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并配置`launch.json`文件后，我们可以在DEBUG面板下选择我们刚刚定义的任务，然后点击*播放*按钮：
- en: '![](img/1a3af054-7611-441f-ae71-a449e70cb5d9.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a3af054-7611-441f-ae71-a449e70cb5d9.png)'
- en: 'The test execution will be paused when a breakpoint is reached. We can set
    a breakpoint by clicking on the left-hand side of a line in our source code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到断点时，测试执行将暂停。我们可以在源代码的左侧单击一行来设置断点：
- en: '![](img/e43488fa-9719-4e3e-9b08-f43a849cc3ec.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e43488fa-9719-4e3e-9b08-f43a849cc3ec.png)'
- en: 'The Visual Studio Code debugging panel allows us to examine the current execution
    context using the debugging panel available on the left-hand side of the screen.
    This panel contains a few subpanels:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的调试面板允许我们使用屏幕左侧可用的调试面板检查当前执行上下文。此面板包含几个子面板：
- en: The variables panel allows us to see all the variables declared in the current
    execution context.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量面板允许我们查看当前执行上下文中声明的所有变量。
- en: The watch panel allows us to create a *watcher*. A watcher is just a filter
    that allows us to display the value of a variable of our choice.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察面板允许我们创建一个*观察者*。观察者只是一个过滤器，允许我们显示我们选择的变量的值。
- en: The call stack panel allows us to see the function call stack. We can click
    on the function in the call stack to navigate to the selected function.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用堆栈面板允许我们查看函数调用堆栈。我们可以在调用堆栈中单击函数以导航到所选函数。
- en: 'The breakpoints panel allows us to enable and disable the breakpoints that
    we have created, as well as to enable some generic ones (for example, uncaught
    exceptions):'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点面板允许我们启用和禁用我们创建的断点，以及启用一些通用的断点（例如，未捕获的异常）：
- en: '![](img/3272fd3d-b6e2-4e1a-9f65-dc8e87360c79.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3272fd3d-b6e2-4e1a-9f65-dc8e87360c79.png)'
- en: The execution panel located on the top of the screen allows us to control the
    execution of the test at our own pace.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕顶部的执行面板允许我们以自己的节奏控制测试的执行。
- en: Source control utilities
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理工具
- en: Visual Studio Code also allows us to interact with Git through a graphical user
    interface. To access the Git features, we need to click on the Git panel on the
    left-hand side of the screen.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code还允许我们通过图形用户界面与Git进行交互。要访问Git功能，我们需要点击屏幕左侧的Git面板。
- en: 'The Git panel allows us to see the current changes. We can select changes to
    be committed (stag) or roll back the changes. We can then commit the changes by
    introducing a message and clicking on the approval icon located on the top right-hand
    side of the Git panel:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Git面板允许我们查看当前的变化。我们可以选择要提交（暂存）或回滚的变化。然后，我们可以通过输入一条消息并点击Git面板右上角的批准图标来提交这些变化：
- en: '![](img/f64be25d-0bc9-4030-97a6-8cbbc1ee25d9.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f64be25d-0bc9-4030-97a6-8cbbc1ee25d9.png)'
- en: ts-node
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ts-node`'
- en: The TypeScript community has developed an alternative version of Node.js that
    is able to work with TypeScript files as if it was natively supported. This alternative
    version of Node.js is known as `ts-node`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript社区已经开发了一个Node.js的替代版本，它能够像原生支持一样处理TypeScript文件。这个Node.js的替代版本被称为`ts-node`。
- en: 'The `ts-node` command allows us to execute TypeScript files without having
    to compile them first. We can execute a TypeScript file using the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts-node`命令允许我们在不先编译的情况下执行TypeScript文件。我们可以使用以下命令执行TypeScript文件：'
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The example application uses npm `scripts` to create a more convenient version
    of this command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序使用npm `scripts`创建了这个命令的更方便版本：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `npm` command can be executed as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`命令可以按照以下方式执行：'
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By default, the `ts-node` command tries to find the compilation setting in the
    `tsconfig.json` file and expects it to be located in the current directory.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ts-node`命令会尝试在`tsconfig.json`文件中查找编译设置，并期望它位于当前目录。
- en: The `ts-node` command is a very convenient tool when we want to try something
    without having to spend too much time configuring a tool such as Webpack.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要尝试某事而不必花费太多时间配置像Webpack这样的工具时，`ts-node`命令是一个非常方便的工具。
- en: It may feel like `ts-node` can execute TypeScript natively, but this is not
    the case. Our TypeScript code is first compiled and then executed using the Node.js
    binary. This means that using `ts-node` in a production Node.js application is
    not recommended because we will pay a performance penalty (the compilation time).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会感觉`ts-node`可以原生执行TypeScript，但这并不是事实。我们的TypeScript代码首先被编译，然后使用Node.js二进制文件执行。这意味着在Node.js生产应用程序中使用`ts-node`是不推荐的，因为我们将会付出性能代价（编译时间）。
- en: Continuous integration (CI) tools
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成（CI）工具
- en: CI is a development practice that helps to prevent potential integration issues.
    Software integration issues refer to the difficulties that may arise during the
    practice of combining individually tested software components into an integrated
    whole. Software is integrated when components are combined into subsystems or
    when subsystems are combined into products.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CI是一种开发实践，有助于防止潜在的集成问题。软件集成问题是指在将单独测试的软件组件组合成一个整体的过程中可能出现的困难。当组件组合成子系统或子系统组合成产品时，软件就实现了集成。
- en: Components may be integrated after all are implemented and tested, as in a waterfall
    model or a big bang approach. On the other hand, CI requires developers to daily
    commit their code into a remote code repository. Each commit is then verified
    by an automated process, allowing teams to detect integration issues earlier.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以在所有实现和测试完成后进行集成，就像瀑布模型或大爆炸方法一样。另一方面，CI要求开发者每天将代码提交到远程代码仓库。然后，每个提交都会通过自动化流程进行验证，使团队能够更早地发现集成问题。
- en: In this chapter, we have learned how to create a code repository on GitHub and
    how to validate our application using unit tests and linting tools, but we haven't
    configured a CI server to observe our commits and run these validations accordingly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在GitHub上创建代码仓库，以及如何使用单元测试和代码检查工具来验证我们的应用程序，但我们还没有配置CI服务器来观察我们的提交并相应地运行这些验证。
- en: We are going to use Travis CI as our CI server because it is highly integrated
    with GitHub and is free for open source projects and learning purposes. There
    are many other options when it comes to choosing a CI server, but exploring these
    options is out of the scope of this book.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Travis CI作为我们的CI服务器，因为它与GitHub高度集成，并且对开源项目和学习教育项目免费。在选择CI服务器时还有许多其他选项，但这些选项超出了本书的范围。
- en: 'To configure Travis CI, we need to visit [https://travis-ci.org](https://travis-ci.org)
    and log in using our GitHub credentials. Once we have logged in, we will be able
    to see a list of our public GitHub repositories and will also be able to enable
    the CI:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Travis CI，我们需要访问[https://travis-ci.org](https://travis-ci.org)并使用我们的GitHub凭据登录。登录后，我们将能够看到我们公开的GitHub仓库列表，并且还可以启用CI：
- en: '![](img/c6564c10-d433-4db0-8fa1-7e364329eaf7.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6564c10-d433-4db0-8fa1-7e364329eaf7.png)'
- en: 'To finish the configuration, we need to add a file named `travis.yml` to our
    application''s root directory, which contains the Travis CI configuration:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成配置，我们需要在我们的应用程序根目录中添加一个名为`travis.yml`的文件，其中包含Travis CI配置：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are many other available Travis CI configuration options. Refer to [http://docs.travis-ci.com/](http://docs.travis-ci.com/)
    to learn more about the available options.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他可用的Travis CI配置选项。请参阅[http://docs.travis-ci.com/](http://docs.travis-ci.com/)了解有关可用选项的更多信息。
- en: After completing these two small configuration steps, Travis CI will be ready
    to observe the commits to our remote code repository.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这两个小配置步骤后，Travis CI将准备好观察我们远程代码仓库的提交。
- en: We have used the configuration to indicate to Travis CI that our application
    is a Node.js application. The CI build for each potential kind of application
    can be highly customized, regardless of its technology stack.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用配置来向Travis CI指示我们的应用程序是一个Node.js应用程序。无论其技术栈如何，每种潜在类型的应用程序的CI构建都可以高度定制。
- en: However, in most cases, we will simply use the defaults set for a given kind
    of application. In the case of Node.js, Travis CI uses `npm install` and `npm
    test` as the default commands.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，我们只需使用为给定类型的应用程序设置的默认值。在Node.js的情况下，Travis CI使用`npm install`和`npm
    test`作为默认命令。
- en: If the build works in the local development environment, but fails in the CI
    server, we will have to check the build error log and try to figure out what went
    wrong. Chances are that the software versions in our environment will be ahead
    of the ones in the CI server and we will need to indicate to Travis CI that a
    dependency needs to be installed or updated. We can find the Travis CI documentation
    at [http://docs.travis-ci.com/user/build-configuration/](http://docs.travis-ci.com/user/build-configuration/)
    to learn how to resolve this kind of issue.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建在本地开发环境中工作，但在CI服务器上失败，我们将不得不检查构建错误日志并尝试找出出了什么问题。可能性是，我们环境中的软件版本将领先于CI服务器中的版本，我们需要向Travis
    CI指示需要安装或更新依赖项。我们可以在[http://docs.travis-ci.com/user/build-configuration/](http://docs.travis-ci.com/user/build-configuration/)找到Travis
    CI文档，了解如何解决这类问题。
- en: Scaffolding tools
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架工具
- en: 'A scaffolding tool is used to autogenerate the project structure, building
    scripts, and much more. Some examples of popular scaffolding tools include the
    following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 框架工具用于自动生成项目结构、构建脚本等。以下是一些流行的框架工具的示例：
- en: The Angular CLI
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CLI
- en: The React CLI (create-react-app-typescript)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React CLI (create-react-app-typescript)
- en: Yeoman
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yeoman
- en: These tools are designed to support many kinds of projects. The scaffolding
    tools will save us time by autogenerating some things for us, such as the webpack
    configuration or the `package.json` file.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具旨在支持许多类型的项目。框架工具将通过为我们自动生成一些内容来节省我们的时间，例如webpack配置或`package.json`文件。
- en: It is highly recommended to spend some time reading the documentation of these
    tools to learn more about their existing customization options.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议花些时间阅读这些工具的文档，以了解更多有关它们现有自定义选项的信息。
- en: Please note that you can learn more about the Angular CLI, the React CLI, and
    Yeoman at [https://cli.angular.io](https://cli.angular.io), [https://github.com/wmonk/create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript),
    and [http://yeoman.io](http://yeoman.io) respectively.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以在[https://cli.angular.io](https://cli.angular.io)、[https://github.com/wmonk/create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript)和[http://yeoman.io](http://yeoman.io)分别了解有关Angular
    CLI、React CLI和Yeoman的更多信息。
- en: Please note that it is never a good idea to let a tool generate some code for
    us if we don't understand what that code does. While, in the future, you should
    consider using a tool to generate a new project, it is recommended to gain a good
    understanding of task and test runners before using a scaffolding tool.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们不了解代码的功能，让工具为我们生成代码从来不是一个好主意。虽然在未来，你应该考虑使用工具来生成新项目，但在使用框架工具之前，建议先深入了解任务和测试运行器。
- en: Why does the command line win?
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么命令行会获胜？
- en: 'You may have noticed that during this chapter, we have used the CLI a lot instead
    of visual tools. We have used the command-line terminal to perform many kinds
    of tasks:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在本章中，我们大量使用了CLI而不是可视化工具。我们使用命令行终端执行了许多任务：
- en: Work with source control
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与源代码管理协同工作
- en: Install dependencies
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖
- en: Run tasks
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行任务
- en: Test our code
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的代码
- en: Debug our code
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试我们的代码
- en: Create projects
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目
- en: The CLI has always been popular but I remember that, a few years ago, I used
    to do some of these things using Visual tools. For example, I remember running
    unit tests in .NET applications using a visual test runner for NUnit (a unit testing
    library for .NET applications). You might be wondering why we stopped using the
    visual tool and went back to the command line like in the early days?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）一直很受欢迎，但我记得，几年前，我使用一些可视化工具来做这些事情。例如，我记得使用 NUnit 的可视化测试运行器在 .NET 应用程序中运行单元测试（NUnit
    是 .NET 应用程序的单元测试库）。你可能想知道为什么我们停止使用可视化工具，又回到了像早期那样的命令行？
- en: 'I believe that the CLI wins for two main reasons:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 CLI 胜出的主要原因有两个：
- en: Our software development teams have become much more diverse
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的软件开发团队变得更加多元化
- en: Our software development methodologies have evolved toward automation
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们软件开发的方法论已经向自动化方向发展
- en: Our software teams are much more diverse today and, as a result, it is common
    to encounter teams composed of DevOps engineers who work with a Linux distribution,
    mobile software engineers who work on OS X, and web engineers who work on Windows.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件团队现在更加多元化，因此，遇到由 DevOps 工程师、使用 Linux 发行版的移动软件工程师和 Windows 上工作的网络工程师组成的团队是很常见的。
- en: The team members may use different operating systems, but they all follow the
    same process, and they share one unique development process. For example, if one
    of the members of the team wants to execute the unit tests, it would be possible
    to do so by executing a command in the OS console. We can go one step further
    and also use the same command as part of our CI build.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员可能会使用不同的操作系统，但他们都遵循相同的流程，并且共享一个独特的发展流程。例如，如果团队成员之一想要执行单元测试，可以通过在操作系统控制台中执行命令来实现。我们可以更进一步，也可以将相同的命令作为我们持续集成构建的一部分。
- en: The CLI wins because it enables our development teams to share one unique set
    of development processes and practices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）胜出，因为它使我们的开发团队能够共享一套独特的发展流程和实践。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work with a long list of different development
    tools. It is impossible to cover so many tools in depth in one chapter, but now
    that we know the basics, it should be much easier to gradually dive deeper into
    more advanced use cases.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用一系列不同的开发工具。在一章中深入探讨这么多工具是不可能的，但现在我们已经了解了基础知识，逐步深入到更高级的使用案例应该会容易得多。
- en: In the next chapter, we will learn about the development of backend applications
    with Node.js and TypeScript.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用 Node.js 和 TypeScript 开发后端应用程序。
