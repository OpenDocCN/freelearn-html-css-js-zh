<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Asynchronous Testing &#x2013; AJAX"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Asynchronous Testing – AJAX</h1></div></div></div><p>Inevitably, there comes a time in every JavaScript application when asynchronous code needs to be tested.</p><p>Asynchronous<a id="id157" class="indexterm"/> means that you cannot deal with it in a linear fashion—a function might return immediately after its execution, but the result will come later, usually through a callback.</p><p>This is a very common pattern while dealing with AJAX requests, for example, through jQuery:</p><div class="informalexample"><pre class="programlisting">$.ajax('http://localhost/data.json', {
  success: function (data) {
    // handle the result
  }
});</pre></div><p>In this chapter, we are going to learn the different ways Jasmine allows us to write tests for asynchronous code.</p><div class="section" title="Acceptance criterion"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Acceptance criterion</h1></div></div></div><p>To demonstrate Jasmine support of<a id="id158" class="indexterm"/> asynchronous testing, we are going to implement the following acceptance criterion:</p><p>Stock when fetched, should update its share price</p><p>Using the techniques we have showed you until now, you could write this acceptance criterion in <code class="literal">StockSpec.js</code>, inside the <code class="literal">spec</code> folder file, as follows:</p><div class="informalexample"><pre class="programlisting">describe("Stock", function() {
  var stock;
  var originalSharePrice = 0;

  beforeEach(function() {
    stock = new Stock({
      symbol: 'AOUE',
      sharePrice: originalSharePrice
    });
  });

  it("should have a share price", function() {
    expect(stock.sharePrice).toEqual(originalSharePrice);
  });

  <span class="strong"><strong>describe("when fetched", function() {</strong></span>
<span class="strong"><strong>    var fetched = false;</strong></span>
<span class="strong"><strong>    beforeEach(function() {</strong></span>
<span class="strong"><strong>      stock.fetch();</strong></span>
<span class="strong"><strong>    });</strong></span>

<span class="strong"><strong>    it("should update its share price", function() {</strong></span>
<span class="strong"><strong>      expect(stock.sharePrice).toEqual(20.18);</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>That would lead to the <a id="id159" class="indexterm"/>implementation of the <code class="literal">fetch</code> function from the <code class="literal">Stock.js</code> file inside the <code class="literal">src</code> folder, as follows:</p><div class="informalexample"><pre class="programlisting">Stock.prototype.<span class="strong"><strong>fetch</strong></span> = function() {
  var that = this;
  var url = 'http://localhost:8000/stocks/'+that.symbol;

  <span class="strong"><strong>$.getJSON</strong></span>(url, function (data) {
    that.sharePrice = data.sharePrice;
  });
};</pre></div><p>The important part in the preceding code is the <code class="literal">$.getJSON</code> call, an AJAX request expecting a JSON response containing an updated share price, such as:</p><div class="informalexample"><pre class="programlisting">{
  "sharePrice": 20.18
}</pre></div><p>By now, you can see that we are stuck; in order to run this spec, we will need a server running.</p></div></div>
<div class="section" title="Setting up the scenario"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Setting up the scenario</h1></div></div></div><p>Since this book is all about <a id="id160" class="indexterm"/>JavaScript, we are going to create a very simple <span class="strong"><strong>Node.js</strong></span> server to be used by the specs. Node.js is a platform that allows the development of network applications, such as web servers, using JavaScript.</p><p>In <a class="link" href="ch06.html" title="Chapter 6. Light Speed Unit Testing">Chapter 6</a>, <span class="emphasis"><em>Light Speed Unit Testing</em></span>, we are going to see alternative solutions to test AJAX requests without the<a id="id161" class="indexterm"/> need for a server. And in <a class="link" href="ch08.html" title="Chapter 8. Build Automation">Chapter 8</a>, <span class="emphasis"><em>Build Automation</em></span>, we are going to see how to use Node.js as a foundation for an advanced build system.</p><div class="section" title="Installing Node.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Installing Node.js</h2></div></div></div><p>If you already have <a id="id162" class="indexterm"/>Node.js installed, you can skip to the next section.</p><p>There are installers available for Windows and Mac OS X. Perform the following steps to install Node.js:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the Node.js website <a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a>.</li><li class="listitem">Click on the <span class="strong"><strong>Install</strong></span> button.</li><li class="listitem">Once the download is completed, execute the installer and follow the steps.</li></ol></div><p>To check other installation methods and instructions on how to install Node.js on Linux distributions, check the official documentation at <a class="ulink" href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager</a>.</p><p>Once you are done, you should have the <code class="literal">node</code> and <code class="literal">npm</code> commands available on your command line.</p></div><div class="section" title="Coding the server"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Coding the server</h2></div></div></div><p>For the purpose of learning how to <a id="id163" class="indexterm"/>write asynchronous specs, we are going to create a server that returns some fake data. Create a new file in the project's root folder called <code class="literal">server.js</code> and add the following code to it:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var app = express();

app.get('/stocks/:symbol', function (req, res) {
  res.setHeader('Content-Type', 'application/json');
  res.send({ sharePrice: 20.18 });
});

app.use(express.static(__dirname));

app.listen(8000);</pre></div><p>To handle the HTTP requests, we use<a id="id164" class="indexterm"/> <span class="strong"><strong>Express</strong></span>, a Node.js web application framework. By reading the code, you can see that it defines a route to <code class="literal">/stocks/:symbol</code>, so it accepts requests such as <code class="literal">http://localhost:8000/stocks/AOUE</code> and responds with JSON data.</p><p>We also use the <code class="literal">express.static</code> module to serve the spec runner at <code class="literal">http://localhost:8000/SpecRunner.html</code>.</p><p>There is a requirement to circumvent the SOP. This is a policy that dictates, for security reasons, that AJAX <a id="id165" class="indexterm"/>requests aren't allowed to be performed on domains different than the application.</p><p>This issue was first demonstrated while using HTML fixtures in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>.</p><p>Using the Chrome browser inspector, you can see errors in the console while opening the <code class="literal">SpecRunner.html</code> file with a <code class="literal">file://</code> protocol (basically, the way you've been doing until now):</p><div class="mediaobject"><img src="graphics/B04138_04_01.jpg" alt="Coding the server"/><div class="caption"><p>This shows the same origin policy error</p></div></div><p>By serving the runner, and all of the application and test code under the same base URL, we prevent this problem from happening and are able to run the specs on any browser.</p></div><div class="section" title="Running the server"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Running the server</h2></div></div></div><p>To run the server, first<a id="id166" class="indexterm"/> you need to install its dependencies (Express) using Node's package manager. Inside the application root folder, run the <code class="literal">npm</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install express</strong></span>
</pre></div><p>This command will download Express and place it inside a new folder called <code class="literal">node_modules</code> inside the project folder.</p><p>Now you should be able to run the server by invoking the following <code class="literal">node</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node server.js</strong></span>
</pre></div><p>To check whether it is working, hit <code class="literal">http://localhost:8000/stocks/AOUE</code> on your browser, and you should receive the JSON response:</p><div class="informalexample"><pre class="programlisting">{"sharePrice": "20.18"}</pre></div><p>Now that we have our server dependency working, we can get back to writing the spec.</p></div></div>
<div class="section" title="Writing the spec"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Writing the spec</h1></div></div></div><p>With the server running, open <a id="id167" class="indexterm"/>your browser at <code class="literal">http://localhost:8000/SpecRunner.html</code> to see the results of our specs.</p><p>You can see that even though the server is running, and the spec appears to be correct, it is failing. This is due to the fact that <code class="literal">stock.fetch()</code> is asynchronous. A call to <code class="literal">stock.fetch()</code> returns immediately, allowing Jasmine to run the expectations before the AJAX request is completed:</p><div class="informalexample"><pre class="programlisting">it("should update its share price", function() {
  expect(stock.sharePrice).toEqual(20.18);
});</pre></div><p>To fix this, we need to embrace the asynchronicity of the <code class="literal">stock.fetch()</code> function and instruct Jasmine to wait for its execution before running the expectations.</p><div class="section" title="Asynchronous setups and teardowns"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Asynchronous setups and teardowns</h2></div></div></div><p>In the example shown, we<a id="id168" class="indexterm"/> invoke the <code class="literal">fetch</code> function during the spec's <a id="id169" class="indexterm"/>setup (the <code class="literal">beforeEach</code> function).</p><p>The only thing we need to do to identify that this setup step is asynchronous is add a <code class="literal">done</code> argument to its function definition:</p><div class="informalexample"><pre class="programlisting">describe("when fetched", function() {
  beforeEach(function(<span class="strong"><strong>done</strong></span>) {
    
  });

  it("should update its share price", function() {
    expect(stock.sharePrice).toEqual(20.18);
  });
});</pre></div><p>Once Jasmine identifies this <code class="literal">done</code> argument, it passes as its value a function that must be called once the asynchronous operation is completed.</p><p>So we could then pass this <code class="literal">done</code> function as a <code class="literal">success</code> callback of the <code class="literal">fetch</code> function:</p><div class="informalexample"><pre class="programlisting">beforeEach(function(done) {
  stock.fetch(<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    success: done</strong></span>
<span class="strong"><strong>  }</strong></span>);
});</pre></div><p>At the implementation, invoke it once the AJAX operation is completed:</p><div class="informalexample"><pre class="programlisting">Stock.prototype.fetch = function(params) {
  params = params || {};
  var that = this;
  <span class="strong"><strong>var success = params.success || function () {};</strong></span>
<span class="strong"><strong>  var url = 'http://localhost:8000/stocks/'+that.symbol;</strong></span>

  $.getJSON(url, function (data) {
    that.sharePrice = data.sharePrice;
<span class="strong"><strong>    success(that);</strong></span>
  });
};</pre></div><p>That is all there is to it; Jasmine will wait for the AJAX operation to be completed and the test will pass.</p><p>When required, it is also <a id="id170" class="indexterm"/>possible to have asynchronous <code class="literal">afterEach</code> <a id="id171" class="indexterm"/>definitions using the same <code class="literal">done</code> argument.</p></div><div class="section" title="Asynchronous specs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Asynchronous specs</h2></div></div></div><p>Another approach would be to have an<a id="id172" class="indexterm"/> asynchronous spec instead of an asynchronous setup. To demonstrate how this would work, we are going to need to rewrite our previous acceptance criteria:</p><div class="informalexample"><pre class="programlisting">describe("Stock", function() {
  var stock;
  var originalSharePrice = 0;

  beforeEach(function() {
    stock = new Stock({
      symbol: 'AOUE',
      sharePrice: originalSharePrice
    });
  });

  it("should be able to update its share price", function(done) {
    stock.fetch();
    expect(stock.sharePrice).toEqual(20.18);
  });
});</pre></div><p>Again, all we have to do is add a <code class="literal">done</code> argument to its function definition and invoke the <code class="literal">done</code> function once the test is done:</p><div class="informalexample"><pre class="programlisting">it("should be able to update its share price", function(<span class="strong"><strong>done</strong></span>) {
  stock.fetch({
    success: function () {
      expect(stock.sharePrice).toEqual(20.18);
      <span class="strong"><strong>done();</strong></span>
    }
  });
});</pre></div><p>The difference here is that we had to<a id="id173" class="indexterm"/> move the expectation for it to be inside the <code class="literal">success</code> callback right before invoking the <code class="literal">done</code> function.</p></div><div class="section" title="Timeout"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Timeout</h2></div></div></div><p>When writing<a id="id174" class="indexterm"/> asynchronous specs, Jasmine will wait for 5 seconds, by default, for the <code class="literal">done</code> callback to be called, failing the spec if it is not called before this timeout.</p><p>In this contrived example, where the server was a simple stub returning static data, that timeout was not a problem, but there are situations where that default time is not enough to complete an asynchronous task.</p><p>Although it is not recommended to have long-running specs, it is nice to know there is a way around this default behavior by changing a simple configuration variable in Jasmine called <code class="literal">jasmine.DEFAULT_TIMEOUT_INTERVAL</code>.</p><p>To make it take effect in the entire suite, one could set it at the <code class="literal">SpecHelper.js</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  <span class="strong"><strong>jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;</strong></span>

  jasmine.addMatchers({
    // matchers code
  });
});

jasmine.getFixtures().fixturesPath = 'spec/fixtures';</pre></div><p>To make it take effect over a single spec, change its value in <code class="literal">beforeEach</code> and restore it during <code class="literal">afterEach</code>:</p><div class="informalexample"><pre class="programlisting">describe("Stock", function() {
<span class="strong"><strong>  var defaultTimeout;</strong></span>

  beforeEach(function() {
<span class="strong"><strong>    defaultTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;</strong></span>
<span class="strong"><strong>    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;</strong></span>
  });

  afterEach(function() {
<span class="strong"><strong>    jasmine.DEFAULT_TIMEOUT_INTERVAL = defaultTimeout;</strong></span>
  });

  it("should be able to update its share price", function(done) {

  });
});</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, you have seen how to test asynchronous code, a scenario common when testing server interactions (AJAX).</p><p>I have also presented you with the Node.js platform and used it to code a simple server to be used as a test fixture.</p><p>In <a class="link" href="ch06.html" title="Chapter 6. Light Speed Unit Testing">Chapter 6</a>, <span class="emphasis"><em>Light Speed Unit Testing</em></span>, we are going to see different solutions to AJAX testing—solutions that don't require a server running.</p><p>In the next chapter, we are going to learn about spies and how we can use them to perform behavior checking.</p></div></body></html>