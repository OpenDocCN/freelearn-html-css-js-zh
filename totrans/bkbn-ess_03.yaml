- en: Chapter 3. Accessing Server Data with Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `Model`, Backbone's main class to work with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new `Model` subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get and set `Model` attributes and trigger other code when these attributes
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store these attributes to a remote server and retrieve them from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the several convenience methods that `Model` has borrowed from Underscore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Models** in Backbone are the core of all data interactions, both within the
    client code itself and when communicating with a remote server. While one can
    simply use a plain JavaScript object instead of a `Model`, Models offer three
    major advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Models use Backbone's class system, making it easy to define methods, create
    subclasses, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models allow other code to listen for and respond to changes in the `Model`
    attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models simplify and encapsulate the logic used to communicate with the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As discussed in the previous chapter, we can create our own subclass of Model
    using `extend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve created that class, we can instantiate new `Model` instances using
    JavaScript''s `new` keyword, and (optionally) we can pass in an initial set of
    attributes and options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Attributes, options, and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about attributes in Backbone, they often sound similar to regular
    JavaScript properties. After all, both attributes and properties are key-value
    pairs stored on a `Model` object. The difference between the two is that attributes
    aren''t (in a technical sense) actually properties of a Model at all; instead,
    they are the properties of a property of a `Model`. Each `Model` class has a property
    called `attributes`, and the attributes themselves are stored as properties of
    that `attributes` property. Take an example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Attributes versus Properties**'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding code snippet, Backbone's `Models` class can also have
    regular, nonattribute properties. If you need to store a piece of data in a Model,
    you can choose between using a property or an attribute. In general, you should
    use an attribute only when the data is going to be synced to the server or when
    you want other parts of your code to be able to listen for data changes. If your
    data doesn't meet these requirements, it's best to store it as a regular JavaScript
    property instead of as an attribute, because storing such data as an attribute
    will create more work for you when you save the `Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: On a purely conceptual level, any of the core persistent information that a
    `Model` class is designed to hold belongs in its attributes, while any information
    that is secondary or derived, or which is only designed to last until the user
    refreshes the page, should be stored as properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to pass in attributes when you create a new `Model` class, you
    can simply provide them as the first argument and Backbone will automatically
    add them. You can also define default attributes, which all new `Models` of that
    class will have, using the defaults property when you extend your `Model` class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to remember, however, that in JavaScript, objects are passed
    by reference, which means that any object you provide in `defaults` will be shared
    with, not copied between, instances of your `Model` class. In other words, check
    out the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since you probably don't want changes to one Model affecting your other Models,
    you should avoid setting objects in defaults. If you really need to set an object
    as a default, you can do so in the Model's `initialize` method or by using a more
    advanced function-based form of defaults, which we'll cover later on in [Chapter
    7](part0069.xhtml#aid-21PMQ1 "Chapter 7. Fitting Square Pegs in Round Holes –
    Advanced Backbone Techniques"), *Fitting Square Pegs in Round Holes – Advanced
    Backbone Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While setting default attributes for Models is easy, the same cannot be said
    about adding default direct properties to a Model when it is first created. The
    best way to set these properties is to use the Model''s `initialize` method. For
    instance, if you want to set a `renderBlackAndWhite` property when you create
    a `Book` Model, you can do what is described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets the `renderBlackAndWhite` property of each newly created
    book to the `renderBlackAndWhite` option passed in when the book is created.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `attributes` property is (behind the scenes) just a JavaScript object,
    that doesn''t mean that we should treat it as such. For instance, you should never
    set an attribute directly by changing the *attributes* property of a `Model` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the attributes of Backbone''s `Models` should be set using the Model''s
    `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set` method has two forms or *signatures*. The first (shown previously)
    takes two arguments: one for the data''s key and one for its value. This form
    is great if you only want to set one value at a time, but if you need to set multiple
    values, you can use the second form instead, which takes only a single argument
    containing all the values of `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, Models also have an `unset` method, which takes only a single
    *key* argument and works in a similar way as JavaScript''s `delete` statement,
    except that it also lets any code listening to the Model known about the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have guessed, retrieving attributes through Backbone is done using
    the `get` method, which takes only a single *key* argument and returns the value
    for that key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` method is very simple; I''d actually like to show its entire source
    code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, you may be thinking, if that's all there is to get, why not just use the
    `attributes` object directly? After all, there's no difference, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, there are two benefits of using the `get` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first benefit is that using `get` makes your code slightly short and more
    readable as well as more consistent since your `get` calls will match your `set`
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second benefit, and only a programmatic advantage, is that using `get` offers
    the option of future extensibility. Like many Backbone methods, `get` is not just
    designed for out of the box use but also for extension by you, the Backbone developer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's imagine for a moment that you are building a Backbone application, and
    one day, you realize that you need to know when some piece of code accesses a
    certain attribute. Maybe, you find the need to do so as you're adding auditing
    or logging capabilities, or maybe you're just trying to debug a tricky problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you've written your application to access attributes directly, you'll need
    to find every place in your code that gets an attribute and then update that code.
    However, if you have already been using the `get` method, you can simply override
    the `get` method on the relevant `Model` (or `Models`) to tap in to all of your
    existing `get` logic from a single place in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the primary advantages of using the `set` and `unset` methods, as we
    just described, is that they allow other parts of your code to listen for changes
    to a Model''s attributes. This works similar to listening for a DOM event in jQuery
    and is done using the `on` and `off` methods of the `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, the `on` method, just like jQuery''s,
    takes two arguments: an `event` function and a `callback` function. When the event
    is triggered, Backbone invokes the `callback` function. The event listener can
    be removed using the `off` method. If you want your code to listen for multiple
    events, you can combine them with spaces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Backbone offers one significant improvement over jQuery however, in the form
    of an optional third `context` argument. If this argument is provided, the callback
    will be bound (as if you had used the `_.bind` method mentioned in the previous
    chapter) as it''s registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we define an `Author` class with a `listenForDeathOfRival`
    method, which takes a rival (another `Author` class) as an argument and sets up
    a listener for when the rival is destroyed. We pass the original author as the
    `context` argument, so when the callback resolves, its `this` method will be set
    to that author. We then call `listenForDeathOfRival` on `byron` and pass in `keats`
    so that `byron` listens for a destroy event on `keats`.
  prefs: []
  type: TYPE_NORMAL
- en: When we then trigger Keats' destruction in the final line, we trigger the event
    listener setup by `listenForDeathOfRival`, which gives the alert message. The
    message is able to include both the authors' names because when the callback resolves,
    Keats' name is available from the `rival` variable, while Byron's name is available
    as an attribute of the `Model` (because we passed his Model as the `context` argument
    when we set up the event listener).
  prefs: []
  type: TYPE_NORMAL
- en: Available events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Models` have several different events available for you to listen to, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Trigger |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | When any attribute of a Model changes |'
  prefs: []
  type: TYPE_TB
- en: '| `change:attribute` | When the specified attribute changes |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy` | When the Model is destroyed |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | When an AJAX method of the Model starts |'
  prefs: []
  type: TYPE_TB
- en: '| `sync` | When an AJAX method of the Model has completed |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | When an AJAX method of the Model returns an error |'
  prefs: []
  type: TYPE_TB
- en: '| `invalid` | When validation triggered by a Model''s `save`/`isValid` call
    fails |'
  prefs: []
  type: TYPE_TB
- en: 'There are also several other events that are related to **Collection**, which
    will be explained further in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Trigger |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | When the Model is added to a Collection |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | When the Model is removed from a Collection |'
  prefs: []
  type: TYPE_TB
- en: '| `reset` | When a Collection that the Model belongs to is reset |'
  prefs: []
  type: TYPE_TB
- en: Models also have one other, special, event called `all`. This event is triggered
    in response when any of the other `Model` events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although you are unlikely to use them very often, you may find it useful to
    create your own custom events on certain occasions. This can be done by using
    the Model''s `trigger` method, which lets you simulate an event coming from the
    `Model`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can listen for these events in the way same as any other non-custom event,
    by using the `on` method. Any additional arguments passed to `trigger` (such as
    the `5` in the preceding example) will be passed as arguments to event handlers
    that listen for that event.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve filled a `Model` class with data, we might not want to lose that
    data, and that''s where the AJAX features of Model come into play. Every Model
    has three methods to interact with the server, which can be used to generate four
    types of HTTP requests, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | RESTful URL | HTTP method | Server action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch` | `/books/id` | `GET` | `retrieves data` |'
  prefs: []
  type: TYPE_TB
- en: '| `save` (for a new `Model`) | `/books` | `PUT` | `sends data` |'
  prefs: []
  type: TYPE_TB
- en: '| `save` (for an existing `Model`) | `/books/id` | `POST` | `sends data` |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy` | `/books/id` | `DELETE` | `deletes data` |'
  prefs: []
  type: TYPE_TB
- en: The sample URLs in the preceding table are what Backbone will generate by default
    when it tries to perform any of the three AJAX methods. Backbone works best with
    a set of server-side APIs that are organized using this RESTful architecture.
    The basic idea of a RESTful server-side API is that it is made up of URL endpoints
    that expose various resources for the client to consume.
  prefs: []
  type: TYPE_NORMAL
- en: The different HTTP methods are used in such an architecture to control which
    action the server should take with that resource. Thus, to delete a book with
    an ID of 7, a RESTful API will expect a `DELETE` request to `/books/7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, Backbone won''t know that the server-side endpoint for a Book `Model`
    will be `/books` unless you tell it, which you can do by specifying a `urlRoot`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If, for some reason, your server-side API is on a different domain, you can
    also use `urlRoot` method to specify an entirely different domain. For instance,
    to indicate that our `Book` class should use the papers endpoint of [http://www.example.com/](http://www.example.com/),
    we can set `urlRoot` of [http://www.example.com/papers](http://www.example.com/papers).
    This approach will not work on most sites, however, because of cross-site scripting
    limitations imposed by browsers; so, unless you employ special techniques (for
    instance, a server-side proxy), you will most likely want your server-side API
    to be on the same domain that serves your JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: If your server-side API isn't RESTful, you can still use Backbone's AJAX capabilities
    by overwriting its built-in `url` method. While the default version of this method
    simply combines the Model's `urlRoot` method with its ID (if any), you can redefine
    it to specify any URL that you'd prefer Backbone to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say our book Models have a `fiction` attribute and we
    want to use two different endpoints to save our books: `/fiction` for fiction
    books and `/nonfiction` for nonfiction books. We can override our `url` method
    to tell Backbone as much, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Storing URLs on the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we just covered, Backbone allows you to specify any URLs you want for your
    Models. If your site is fairly complex, however, it''s a good idea to store the
    actual URL strings, or even URL-generating functions, in a separate `urls` object.
    Take an example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is not strictly necessary (and is may be overkill on smaller sites),
    this approach has several benefits on a larger site:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily share URLs between any of your Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You easily share URLs between your Models and non-Backbone AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding existing URLs is quick and easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any URL changes, you only have to edit one file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we''ve avoided the question of how exactly Backbone determines
    what a Model''s ID is. As it turns out, Backbone has a very simple mechanism:
    it uses whatever attribute you specify as the `idAttribute` property of the `Model`
    class. The default `idAttribute` property is simply `id`; so, if the JSON returned
    by your server includes an `id` attribute, you don''t even need to specify an
    `idAttribute` property. However, since many APIs don''t use `id` (for example,
    some use `_id` instead), Backbone watches for changes to its attributes, and when
    it sees an attribute that matches the `idAttribute` property, it will set the
    Model''s special `id` property to that attribute''s value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to telling Backbone what URL to use when saving the Model, the
    `ID` attribute also has another function: its absence tells Backbone that the
    Model is new, which you can see if you use the `isNew` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can also be overridden if you need to use some other mechanism
    to determine whether a `Model` class is new or not. There''s one other issue with
    `isNew` though: if new Models don''t have IDs, how will you identify them? For
    instance, if you were storing a set of `Models` by `ID`, what will you do with
    the new ones?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To get around this problem, Backbone provides a special client-side only `ID`,
    or `cid` property, on every Model. This `cid` property is guaranteed to be unique,
    but has no connection whatsoever with the Model's actual `ID` (if it even has
    one). It is also not guaranteed to be consistent; if you refresh the page, your
    Models' might have entirely different `cid` properties generated for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of a `cid` property allows you to use a Model''s ID for all server-related
    tasks and its `cid` for all client-side tasks, without the need to get a new ID
    from the server every time you create a new Model. By using the `cid` property,
    we can solve our previous problem and successfully index new books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Fetching data from the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first of Backbone's three AJAX methods, `fetch`, is used to retrieve the
    data of a Model from the server. The `fetch` method doesn't require any arguments,
    but it takes a single optional `options` argument. This argument can take Backbone-specific
    options, such as silent (which will prevent the Model from triggering an event
    as a result of fetch), or any options that you will normally pass to `$.ajax`,
    such as *async*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify what to do when the `fetch` request is finished in one of the
    two ways. First, you can specify a `success` or `error` callback in the options
    passed to `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetch` method also returns a jQuery promise, which is an object that lets
    you say *when the fetch is done, do ___* or *if the fetch fails, do ___*. We can
    use promises instead of a success callback to trigger logic after the AJAX operation
    finishes, and this approach even lets us chain multiple callbacks together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While both approaches work, the promise style is slightly more powerful because
    it allows you to easily trigger multiple callbacks from a single `fetch` or trigger
    a callback only after multiple `fetch` calls complete. For instance, let''s say
    we wanted to fetch two different Models and display an alert only after they''ve
    both been returned from the server. Using the success/error approach, this can
    be awkward, but with the promise style (combined with jQuery''s `when` function),
    the problem is simple to solve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once a `fetch` method is complete, Backbone will take the server's response,
    assume that it's a JSON object representing the Model's attributes, and call `set`
    on that object. In other words, `fetch` is really just a `GET` request followed
    by a set of whatever comes back in the response. The `fetch` method is designed
    to work with a RESTful-style API that returns just the Model's JSON, so if your
    server returns something else, such as that same JSON wrapped inside an `envelope`
    object, you'll need to override a special `Model` method called `parse`.
  prefs: []
  type: TYPE_NORMAL
- en: When a `fetch` method finishes, Backbone passes the server's response through
    `parse` before it calls `set`, and the default implementation of the `parse` method
    simply returns the object given to it without modification. By overriding the
    `parse` method with your own logic, however, you can tell Backbone how to convert
    this response from whatever format the server sent it in into a Backbone attributes
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say that instead of returning the data for a book directly,
    your server returned an object with the book''s attributes contained inside a
    book key, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By overriding the `parse` method of our `Book` class, we can tell Backbone
    to throw out the `otherInfo` and just use the `Book` property as our book''s attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Saving data to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've started creating Models, you'll no doubt find yourself wanting to
    save their data to your remote server, and that's where Backbone's `save` method
    comes in. As its name suggests, `save` allows you to send your Model's attributes
    to your server. It does so in the JSON format, at the URL specified by the `url`
    method of your Model, via an AJAX `POST` or `PUT` request. Like `fetch`, `save`
    allows you to provide `success` and `error` callback options and (also like `fetch`)
    it returns a promise, which can be used to trigger code once the `save` method
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of `save` used with a promise-based callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code reveals another problem: it will only work if our server
    is set up to receive all of the Model''s attributes in the JSON format. If we
    want to save only some of those attributes or if we want to send other JSON, such
    as a wrapping `envelope` object, Backbone''s `save` method won''t work out of
    the box. Fortunately, Backbone provides a solution in the form of its `toJSON`
    method. When you save, Backbone passes your `Models` attributes through `toJSON`,
    which (like `parse`) normally does nothing, because by default `toJSON` simply
    returns whatever is passed in to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, by overriding `toJSON`, you can gain complete control over what Backbone
    sends to your server. For instance, if we wanted to wrap our book JSON inside
    another object as a `book` property and then add some further information, we
    can override `toJSON` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you send anything to the server, it''s a good idea to make sure that
    the data you''re sending is actually valid. To solve this problem, Backbone provides
    another method for you to optionally overwrite: `validate`. The `validate` method
    is called every time you save, but its default implementation simply returns `true`.
    If you overwrite it, however, you can add whatever validation logic you want,
    and if that logic returns `false`, then the whole `save` operation will fail and
    also return `false`. For instance, let''s say we wanted to ensure that every new
    book has a minimum of 10 pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if the validation fails, Backbone will not even return a promise;
    it will just return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, if you add validation logic to your `Model` class, you will need
    to test for a failed validation case separately every time you `save`; you can''t
    simply rely on the `fail` method of the returned promise since no such promise
    will be returned. In other words, the following won''t work (and will cause an
    error since `false` has no `fail` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you should use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can also check the validity of your Models at any time by using
    the **isValid** method, which will only return the validation result (and not
    `save`).
  prefs: []
  type: TYPE_NORMAL
- en: Return of Underscore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That covers all the core functionality of `Model`, but before we move on to
    explore `Collections`, some of the convenience methods of `Model` are worth mentioning.
    In addition to requiring Underscore, Backbone alo incorporates many `Underscore`
    methods into its classes as shortcut methods, and `Model` is a perfect example.
    The main advantage of using these built-in shortcut methods, besides being a bit
    more readable, is that they operate on the Model's attributes rather than the
    `Model` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, Underscore has a method called `keys`, which you can use to get
    all the keys on an object. You can use this method directly to get all the keys
    of a Model''s attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you use Model''s version of that same method instead, you can simplify
    your code slightly and make it slightly more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a total of six of these methods on `Model`, and while we don''t have
    time to explain all of them in this book, here''s a brief summary of what each
    one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | What it does |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `keys` | This returns every attribute key |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | This returns every attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| `pairs` | This returns an array of attribute key/value pairs |'
  prefs: []
  type: TYPE_TB
- en: '| `invert` | This returns the attributes with keys and values switched; for
    instance, an attribute of `{''pages'': 20}` will become `{''20'': ''pages''}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pick` | This returns both the keys and values of only the specified attributes;
    for instance, `book.pick(''pages'')` will return `{pages: 20}` without any title
    or other attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `omit` | This returns both the keys and values for every attribute except
    those specified; for instance, `book.omit(''pages'')` will return `{title: ''Short
    Title''}` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Backbone's `Model` class. You learned how to use
    `get` and `set` to change attributes, how to use `on` and `off` to listen for
    events, and how to use `fetch`, `save`, and `destroy` to exchange data with a
    remote server. You also learned how you can customize Backbone to handle your
    server's API by modifying the `url`, `urlRoot`, and `idAttribute` properties and
    how to handle differently structured data with `parse` and `toJSON`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at Backbone's other data class, `Collection`.
    Collections allow you to store groups of Models together, and (just like Models)
    they allow you to listen for changes and send or retrieve data to/from the server.
  prefs: []
  type: TYPE_NORMAL
