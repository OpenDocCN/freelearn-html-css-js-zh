["```js\n      var sphereGeometry = new THREE.SphereGeometry(1.5,20,20);\n      var matProps = {\n        specular: '#a9fcff',\n        color: '#00abb1',\n        emissive: '#006063',\n        shininess: 10\n      }\n      var sphereMaterial = new\n      THREE.MeshPhongMaterial(matProps);\n      var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);\n      sphereMesh.name = 'sphere';\n      scene.add(sphereMesh);\n    ```", "```js\n      // create a camera, which defines where we're looking at.\n      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n      // position and point the camera to the center of the scene\n      camera.position.x = 15;\n      camera.position.y = 6;\n      camera.position.z = 15;\n    ```", "```js\n      function render() {\n        var sphere = scene.getObjectByName('sphere');\n        renderer.render(scene, camera);\n     camera.lookAt(sphere.position);\n        step += 0.02;\n        sphere.position.x = 0 + (10 * (Math.cos(step)));\n        sphere.position.y = 0.75 * Math.PI / 2 + (6 * Math.abs(Math.sin(step)));\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n      // position and point the camera to the center of the scene\n      camera.position.x = 15;\n      camera.position.y = 15;\n      camera.position.z = 15;\n      camera.lookAt(scene.position);\n    ```", "```js\n      // create an helper\n      var helper = new THREE.BoundingBoxHelper(cube);\n      helper.update();\n      // get the bounding sphere\n      var boundingSphere = helper.box.getBoundingSphere();\n      // calculate the distance from the center of the sphere\n      // and subtract the radius to get the real distance.\n      var center = boundingSphere.center;\n      var radius = boundingSphere.radius;\n      var distance = center.distanceTo(camera.position) - radius;\n      var realHeight = Math.abs(helper.box.max.y - helper.box.min.y);\n    ```", "```js\n      var fov = 2 * Math.atan(realHeight * control.correctForDepth / (2 * distance)) * (180 / Math.PI);\n    ```", "```js\n      camera.fov = fov;\n      camera.updateProjectionMatrix();\n    ```", "```js\n      camera = new THREE.PerspectiveCamera();\n    ```", "```js\n      camera.aspect = window.innerWidth / window.innerHeight;\n    ```", "```js\n      camera.near = 0.1;\n      camera.far = 1000;\n    ```", "```js\n      camera.fov = 45;\n    ```", "```js\n      camera.updateProjectionMatrix();\n    ```", "```js\n      camera.position.x = 15;\n      camera.position.y = 16;\n      camera.position.z = 13;\n      scene.add(camera);\n    ```", "```js\n  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n```", "```js\n      camera = new THREE.OrthographicCamera();\n    ```", "```js\n      camera.left = window.innerWidth / -2;\n      camera.right =  window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / - 2;\n    ```", "```js\n      camera.near = 0.1;\n      camera.far = 1500;\n    ```", "```js\n      camera.updateProjectionMatrix();\n    ```", "```js\n      camera.position.x = -500;\n      camera.position.y = 200;\n      camera.position.z = 300;\n      camera.lookAt(scene.position);\n    ```", "```js\n      renderer.render(scene, camera);\n    ```", "```js\n  camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0.1, 1500);\n```", "```js\n      container = document.createElement( 'div' );\n      container.setAttribute(\n        \"style\",\"width:800px; height:600px\");\n      document.body.appendChild( container );\n    ```", "```js\n      orthoCamera = new THREE.OrthographicCamera( \n        WIDTH / - 2, WIDTH / 2,     HEIGHT / 2, HEIGHT / - 2, - 500, 1000 );\n      orthoCamera.position.x = 0;\n      orthoCamera.position.y = 0;\n      orthoCamera.position.z = 0;\n    ```", "```js\n      orthoScene = new THREE.Scene();\n    ```", "```js\n      var spriteMaterial = new THREE.SpriteMaterial({map: THREE.ImageUtils.loadTexture(\"../assets/overlay/overlay.png\")});\n      var sprite = new THREE.Sprite(spriteMaterial);\n      sprite.position.set(0,0,10);\n      sprite.scale.set(HEIGHT,WIDTH,1);\n      orthoScene.add(sprite);\n    ```", "```js\n      persCamera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 2100 );\n      persScene = new THREE.Scene();\n    ```", "```js\n      renderer = new THREE.WebGLRenderer();\n      renderer.setClearColor( 0xf0f0f0 );\n      renderer.setSize( 800, 600 );\n     renderer.autoClear = false;\n      container.appendChild( renderer.domElement );\n    ```", "```js\n      function render() {\n        renderer.clear();\n        renderer.render( persScene, persCamera );\n        renderer.clearDepth();\n        renderer.render( orthoScene, orthoCamera );\n      }\n    ```", "```js\n      // create a camera, which defines where we're looking at.\n      camera = new THREE.PerspectiveCamera(45,window.innerWidth / window.innerHeight, 0.1, 1000);\n      // position and point the camera to the center of the scene\n      camera.position.x = 15;\n      camera.position.y = 16;\n      camera.position.z = 13;\n      camera.lookAt(scene.position);\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        var x = camera.position.x;\n        var z = camera.position.z;\n        camera.position.x = x * Math.cos(control.rotSpeed) + z * Math.sin(control.rotSpeed);\n        camera.position.z = z * Math.cos(control.rotSpeed) – x * Math.sin(control.rotSpeed);\n        camera.lookAt(scene.position);\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  function render() {\n    renderer.render(scene, camera);\n    var z = camera.position.z;\n    var y = camera.position.y;\n camera.position.y = y * Math.cos(control.rotSpeed) + z * Math.sin(control.rotSpeed);\n camera.position.z = z * Math.cos(control.rotSpeed) – y * Math.sin(control.rotSpeed);\n    camera.lookAt(scene.position);\n    requestAnimationFrame(render);\n  }\n```", "```js\n      function onResize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n      }\n    ```", "```js\n      window.addEventListener('resize', onResize, false);\n    ```", "```js\n      var projector = new THREE.Projector();\n    ```", "```js\n    var vector = new THREE.Vector3();\n      projector.projectVector(\n        vector.setFromMatrixPosition( object.matrixWorld ),\n        camera );\n    ```", "```js\n      var width = window.innerWidth;\n      var height = window.innerHeight;\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      vector.x = ( vector.x * widthHalf ) + widthHalf;\n      vector.y = - ( vector.y * heightHalf ) + heightHalf;\n    ```", "```js\n      document.addEventListener('mousedown', onDocumentMouseDown, false);\n    ```", "```js\n    function onDocumentMouseDown(event) { ... }\n    ```", "```js\n    var projector = new THREE.Projector();\n      var vector = new THREE.Vector3(\n        (event.clientX / window.innerWidth) * 2 - 1,\n        -(event.clientY / window.innerHeight) * 2 + 1,\n        0.5);\n      projector.unprojectVector(vector, camera);\n\n    ```", "```js\n      var raycaster = new THREE.Raycaster(camera.position,vector.sub(camera.position).normalize());\n      var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);\n    ```", "```js\n      if (intersects.length > 0) {\n        intersects[0].object.material.transparent = true;\n        if (intersects[0].object.material.opacity === 0.5) {\n          intersects[0].object.material.opacity = 1;\n        } else {\n          intersects[0].object.material.opacity = 0.5;\n        }\n      }\n    ```", "```js\n  var points = [];\n  points.push(new THREE.Vector3(camera.position.x, camera.position.y - 0.2, camera.position.z));\n  points.push(intersects[0].point);\n  var mat = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    transparent: true,\n    opacity: 0.6\n  });\n  var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 60, 0.001);\n  var tube = new THREE.Mesh(tubeGeometry, mat);\n  scene.add(tube);\n```"]