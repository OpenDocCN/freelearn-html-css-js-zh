<html><head></head><body><div><h1 class="header-title">Working with Decorators</h1>
                
            
            
                
<p class="chapter-content">In this chapter, we are going to learn about annotations and decorators—the two new features based on the future ECMAScript 7 specification, but we can use them today with TypeScript 1.5 or higher. You will learn about the following topics:</p>
<ul>
<li>Annotations and decorators</li>
<li>The reflection metadata API</li>
<li>The decorator factory</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Prerequisites</h1>
                
            
            
                
<p class="chapter-content">The TypeScript features in this chapter require TypeScript 1.5 or higher and the following options to be enabled in the <kbd>tsconfig.json</kbd> file:</p>
<pre>"experimentalDecorators": true, 
"emitDecoratorMetadata": true </pre>
<p>As indicated by the experimental decorators compilation flag, the decorator's API is considered experimental. This doesn't mean that it is not ready for production usage. It means that the decorator API is subject to potential breaking changes in the future.</p>
<p class="chapter-content">We are also going to need a polyfill for the <kbd>reflect–metadata</kbd> API. We need a polyfill because most JavaScript engines don't support this API yet. We can expect that, in the long term, this polyfill will not be required but, currently, we can use the <kbd>reflect–metadata</kbd> npm module:</p>
<pre class="chapter-content"><strong>npm install reflect-metadata</strong></pre>
<p>The <kbd>reflect-metadata</kbd> version was 0.1.12 at the time of writing. Please note that the examples are included in the companion source code. The examples can be executed with ts node. For example, the first example included in the companion source code can be executed as follows: <br/><kbd>ts-node chapters/chapter_08/01_class_decorator.ts</kbd></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Annotations versus decorators</h1>
                
            
            
                
<p class="chapter-content">Annotations are a way to add metadata to class declarations. The metadata can then be used by libraries and other development tools, such as inversion of control containers. The annotations API was originally proposed by the Google AtScript team, but annotations are not a standard. However, decorators are a proposed standard for the ECMAScript specification, to annotate and modify classes and properties at design time. Annotations and decorators are pretty much the same:</p>
<p>"Annotations and decorators are nearly the same thing. From a consumer perspective, we have exactly the same syntax. The only thing that differs is that we don't have control over how annotations are added as metadata to our code. A decorator is rather an interface to build something that ends up as annotation. Over a long term, however, we can just focus on decorators, since those are a real proposed standard. AtScript is TypeScript and TypeScript implements decorators".<br/>
                  – <q>Pascal Precht</q>, The Difference between Annotations and Decorators</p>
<p class="chapter-content">We are going to use the following class to showcase how to work with decorators:</p>
<pre> class Person {
 
    public name: string; 
    public surname: string; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    public saySomething(something: string): string { 
        return `${this.name} ${this.surname} says: ${something}`; 
    } 
 
} </pre>
<p class="chapter-content">There are four types of decorators that can be used to annotate: classes, properties, methods, and parameters.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The class decorators</h1>
                
            
            
                
<p class="chapter-content">The official TypeScript decorator proposal defines a class decorator as follows:</p>
<p>A class decorator function is a function that accepts a constructor function as its argument, and returns either undefined, the provided constructor function, or a new constructor function. Returning undefined is equivalent to returning the provided constructor function.                                                                                                                                                     – Ron Buckton, Decorators Proposal - TypeScript </p>
<p class="chapter-content">A class decorator is used to modify the constructor of a class in some way. If the class decorator returns <kbd>undefined</kbd>, the original constructor remains the same. If the decorator returns, the return value will be used to override the original class constructor. The following type declares the signature of a class decorator:</p>
<pre>declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void; </pre>
<p>Please note that this signature is subject to change in future releases of TypeScript. Please refer to the <kbd>lib.d.ts</kbd> file in the TypeScript source code at <a href="https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts">https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts</a> to find the current signature.</p>
<p class="chapter-content">We are going to create a class decorator named <kbd>logClass</kbd>. We can start by defining the decorator as follows:</p>
<pre>function logClass(target: any) { 
  // ... 
} </pre>
<p class="chapter-content">The preceding class decorator does not have any logic yet, but we can already apply it to a class. To apply a decorator, we need to use the at (<kbd>@</kbd>) symbol:</p>
<pre>@logClass 
class Person { 
  public name: string; 
  public surname: string; 
  //... </pre>
<p class="chapter-content">If we compile the preceding code snippet into JavaScript, a function named <kbd>__decorate</kbd> will be generated by the TypeScript compiler. We are not going to examine the internal implementation of the <kbd>__decorate</kbd> function, but we need to understand that it is used to apply a decorator at runtime because the decorator syntax is not supported natively by JavaScript. We can see it in action by examining the JavaScript code that is generated when we compile the decorated <kbd>Person</kbd> class mentioned previously:</p>
<pre>var Person = /** @class */ (function () { 
    function Person(name, surname) { 
        this.name = name; 
        this.surname = surname; 
    } 
    Person.prototype.saySomething = function (something) { 
        return this.name + " " + this.surname + " says: " + something; 
    }; 
    Person = __decorate([ 
        logClass 
    ], Person); 
    return Person; 
}()); </pre>
<p class="chapter-content">As we can see in the preceding code snippet, the <kbd>Person</kbd> class is declared, but it is then passed to the <kbd>__decorate</kbd> function. The value returned by the <kbd>__decorate</kbd> function is re-assigned to the <kbd>Person</kbd> class. Now that we know how the class decorator will be invoked, let's implement it:</p>
<pre>function logClass&lt;TFunction extends Function&gt;(target: TFunction) { 
 
    // save a reference to the original constructor 
    const originalConstructor = target; 
 
    function logClassName(func: TFunction) { 
        console.log("New: " + func.name); 
    } 
 
    // a utility function to generate instances of a class 
    function instanciate(constructor: any, ...args: any[]) { 
        return new constructor(...args); 
    } 
 
    // the new constructor behaviour 
    const newConstructor = function(...args: any[]) { 
        logClassName(originalConstructor); 
        return instanciate(originalConstructor, ...args); 
    }; 
 
    // copy prototype so instanceof operator still works 
    newConstructor.prototype = originalConstructor.prototype; 
 
    // return new constructor (will override original) 
    return newConstructor as any; 
} </pre>
<p class="chapter-content">The class decorator takes the constructor of the class being decorated as its only argument. This means that the argument (named <kbd>target</kbd>) is the constructor of the <kbd>Person</kbd> class. The decorator starts by creating a copy of the class constructor, then it defines a utility function (named <kbd>instanciate</kbd>) that can be used to generate instances of a class. Decorators are used to add some extra logic or metadata to the decorated element. When we try to extend the functionality of a function (methods or constructors), we need to wrap the original function with a new function, which contains the additional logic and invokes the original function. In the preceding decorator, we added extra logic to log in the console, the name of the class when a new instance is created. To achieve this, a new class constructor (named <kbd>newConstructor</kbd>) was declared. The new constructor invokes a function named <kbd>logClassName</kbd>, which implements the additional logic and uses the <kbd>instanciate</kbd> function to invoke the original class constructor. At the end of the decorator, the prototype of the original constructor function is copied to the new constructor function to ensure that the <kbd>instanceof</kbd> operator continues to work when it is applied to an instance of the decorated class. Finally, the new constructor is returned, and it is used to override the original class constructor. After decorating the class constructor, a new instance is created:</p>
<pre>const me = new Person("Remo", "Jansen"); </pre>
<p class="chapter-content">On doing so, the following text appears in the console:</p>
<pre><strong>"New: Person"</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The method decorators</h1>
                
            
            
                
<p class="chapter-content">The official TypeScript decorator proposal defines a method decorator as follows:</p>
<p>"A method decorator function is a function that accepts three arguments: The object that owns the property, the key for the property (a string or a symbol), and optionally the property descriptor of the property. The function must return either undefined, the provided property descriptor, or a new property descriptor. Returning undefined is equivalent to returning the provided property descriptor".                           <br/>
                                                      — Ron Buckton, Decorators Proposal - TypeScript</p>
<p class="chapter-content">The method decorator is like the class decorator, but it is used to override a method, as opposed to using it to override the constructor of a class. The following type declares the signature of a method decorator:</p>
<pre>declare type MethodDecorator = &lt;T&gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void; </pre>
<p>Please note that this signature is subject to change in future releases of TypeScript. Please refer to the <kbd>lib.d.ts</kbd> file in the TypeScript source code at <a href="https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts">https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts</a> to find the current signature.</p>
<p class="chapter-content">The method decorator takes as arguments the class being decorated (target), the name of the method being decorated, and a <kbd>TypePropertyDescriptor</kbd> of the property being decorated. A property descriptor is an object used to describe the properties of a class. A property descriptor contains the following properties:</p>
<pre>interface TypedPropertyDescriptor&lt;T&gt; { 
    enumerable?: boolean; 
    configurable?: boolean; 
    writable?: boolean; 
    value?: T; 
    get?: () =&gt; T; 
    set?: (value: T) =&gt; void; 
} </pre>
<p>Note that a property descriptor is an object that can be obtained by invoking the <kbd>Object.getOwnPropertyDescriptor()</kbd> method. You can learn more at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor</a>.</p>
<p class="chapter-content">If the method decorator returns a property descriptor, the returned value will be used to override the property descriptor of the method. Let's declare a method decorator named <kbd>logMethod</kbd> without any behavior for now:</p>
<pre>function logMethod(<a>target: any, key: string, descriptor: any</a>) { 
  // ... 
} </pre>
<p class="chapter-content">We can apply the decorator to one of the methods in the <kbd>Person</kbd> class:</p>
<pre>class Person { 
 
    public name: string; 
    public surname: string; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    @logMethod 
    public saySomething(something: string): string { 
        return `${this.name} ${this.surname} says: ${something}`; 
    } 
 
} </pre>
<p class="chapter-content">If we compile the preceding code snippet into JavaScript, we will be able to observe that the method decorator is invoked using the following arguments:</p>
<ul>
<li>The prototype (<kbd>Person.prototype</kbd>) of the class that contains the method being decorated</li>
<li>The name of the method (<kbd>saySomething</kbd>) being decorated</li>
<li>The property descriptor of the method being decorated is <kbd>Object.getOwnPropertyDescriptor(Person.prototype, saySomething)</kbd></li>
</ul>
<p class="chapter-content">Now that we know the value of the decorator parameters, we can proceed to implement it:</p>
<pre class="mce-root">function logMethod(
    target: any, 
    key: string, 
    descriptor: TypedPropertyDescriptor&lt;any&gt; 
) { 
 
    // save a reference to the original method 
    const originalMethod = descriptor.value; 
 
    function logFunctionCall(method: string, args: string, result: string) { 
        console.log(`Call: ${method}(${args}) =&gt; ${result}`); 
    } 
 
    // editing the descriptor/value parameter 
    descriptor.value = function(this: any, ...args: any[]) { 
 
        // convert method arguments to string 
        const argsStr = args.map((a: any) =&gt; { 
            return JSON.stringify(a); 
        }).join(); 
 
        // invoke method and get its return value 
        const result = originalMethod.apply(this, args); 
 
        // convert result to string 
        const resultStr = JSON.stringify(result); 
 
        // display in console the function call details 
        console.log(); 
        console.log(`Call: ${key}(${argsStr}) =&gt; ${resultStr}`); 
 
        // return the result of invoking the method 
        return result; 
    }; 
 
    // return edited descriptor 
    return descriptor; <br/>}</pre>
<p class="chapter-content">Just like we did when we implemented the class decorator, we start by creating a copy of the element being decorated. Instead of accessing the method via the class prototype (<kbd>target[key]</kbd>), we will access it via the property descriptor (<kbd>descriptor.value</kbd>). We then create a new function that will replace the method being decorated. The new function invokes the original method but also contains some additional logic used to log in the console, the method name, and the value of its arguments every time it is invoked. After applying the decorator to the method, the method name and arguments will be logged in the console when it is invoked:</p>
<pre>const person = new Person("Michael", "Jackson"); 
person.saySomething("Annie, are you ok?"); </pre>
<p>On doing so, the following text appears in the console:</p>
<pre><strong>Call: saySomething("Annie, are you ok?") =&gt; "Michael Jackson says: Annie, are you ok?"</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The property decorators</h1>
                
            
            
                
<p class="chapter-content">The official TypeScript decorators proposal defines a method property as follows:</p>
<p>A property decorator function is a function that accepts two arguments: The object that owns the property and the key for the property (a string or a symbol). A property decorator does not return.         <br/>
                                                               —Ron Buckton, Decorators Proposal - TypeScript</p>
<p class="chapter-content">The following type declares the signature of a property decorator:</p>
<pre>declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void; </pre>
<p>Please note that this signature is subject to change in future releases of TypeScript. Please refer to the <kbd>lib.d.ts file</kbd> in the TypeScript source code at <a href="https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts">https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts</a> to find the current signature.</p>
<p class="chapter-content">A property decorator is really like a method decorator. The main differences are that a property decorator doesn't return a value and that the third parameter (the property descriptor is missing) is not passed to the property decorator. Let's create a property decorator named <kbd>logProperty</kbd> to see how it works:</p>
<pre>function logProperty(target: any, key: string) {
  // ... 
} </pre>
<p class="chapter-content">We can use it in one of the <kbd>Person</kbd> class's properties as follows:</p>
<pre>class Person { 
 
    @logProperty 
    public name: string; 
 
    @logProperty 
    public surname: string; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    public saySomething(something: string): string { 
        return `${this.name} ${this.surname} says: ${something}`; 
    } 
 
} </pre>
<p class="chapter-content">As we have been doing so far, we are going to implement a decorator that will override the decorated property with a new property that will behave exactly as the original one, but will perform an additional task—logging the property value in the console whenever it changes:</p>
<pre class="mce-root">function logProperty(target: any, key: string) { 
 
    // property value 
    let _val = target[key]; 
 
    function logPropertyAccess(acces: "Set" | "Get", k: string, v: any) { 
        console.log(`${acces}: ${k} =&gt; ${v}`); 
    } 
 
    // property getter 
    const getter = function() { 
        logPropertyAccess("Get", key, _val); 
        return _val; 
    }; 
 
    // property setter 
    const setter = function(newVal: any) { 
        logPropertyAccess("Set", key, newVal); 
        _val = newVal; 
    }; 
 
    // Delete property. The delete operator throws 
    // in strict mode if the property is an own 
    // non-configurable property and returns 
    // false in non-strict mode. 
    if (delete target[key]) { 
        Object.defineProperty(target, key, { 
            get: getter, 
            set: setter, 
            enumerable: true, 
            configurable: true 
        }); <br/>}<br/>}</pre>
<p class="chapter-content">In the preceding decorator, we created a copy of the original property value and declared two functions: <kbd>getter</kbd> (invoked when we change the value of the property) and <kbd>setter</kbd> (invoked when we read the value of the property) respectively. The method decorator returned a value used to override the element being decorated. Because the property decorator doesn't return a value, we can't override the property being decorated, but we can replace it. We have manually deleted the original property (using the <kbd>delete</kbd> keyword) and created a new property using the <kbd>Object.defineProperty</kbd> function and the previously declared getter and setter functions. After applying the decorator to the <kbd>name</kbd> property, we will be able to observe any changes to its value in the console:</p>
<pre>const person = new Person("Michael", "Jackson"); 
// Set: name =&gt; Michael 
// Set: surname =&gt; Jackson 
 
person.saySomething("Annie, are you ok?"); 
// Get: name =&gt; Michael 
// Get: surname =&gt; Jackson </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The parameter decorators</h1>
                
            
            
                
<p class="chapter-content">The official decorators proposal defines a parameter decorator as follows:</p>
<p>"A parameter decorator function is a function that accepts three arguments: The object that owns the method that contains the decorated parameter, the property key of the property (or undefined for a parameter of the constructor), and the ordinal index of the parameter. The return value of this decorator is ignored".</p>
<p>- Ron Buckton, Decorators Proposal - TypeScript</p>
<p class="chapter-content">The following type declares the signature of a parameter decorator:</p>
<pre>declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void; </pre>
<p>Please note that this signature is subject to change in future releases of TypeScript. Please refer to the <kbd>lib.d.ts file</kbd> in the TypeScript source code at <a href="https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts">https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts</a> to find the current signature.</p>
<p class="chapter-content">The main difference between the preceding decorators and the parameter decorators is that we cannot use a parameter decorator to extend the functionality of a given class. Let's create a parameter decorator named <kbd>addMetadata</kbd> to see how it works:</p>
<pre>function addMetadata(target: any, key: string, index: number) {
  // ... 
} </pre>
<p class="chapter-content">We can apply the parameter decorator to a parameter as follows:</p>
<pre>@logMethod 
public saySomething(@addMetadata something: string): string { 
    return `${this.name} ${this.surname} says: ${something}`; 
} </pre>
<p class="chapter-content">The parameter decorator doesn't return, which means that we will not be able to override the original method that takes the parameter being decorated as an argument. We can use parameter decorators to link some metadata to the class being decorated. In the following implementation, we will add an array named <kbd>log_${key}_parameters</kbd> as a class property, where <kbd>key</kbd> is the name of the method that contains the parameter being decorated:</p>
<pre>function addMetadata(target: any, key: string, index: number) {
    const metadataKey = `_log_${key}_parameters`; 
    if (Array.isArray(target[metadataKey])) { 
        target[metadataKey].push(index); 
    } else { 
        target[metadataKey] = [index]; 
    } 
} </pre>
<p class="chapter-content">To allow more than one parameter to be decorated, we check whether the new field is an array. If the new field is not an array, we create and initialize the new field to be a new array containing the index of the parameter being decorated. If the new field is an array, the index of the parameter being decorated is added to the array. A parameter decorator is not useful on its own; it needs to be used with a method decorator, so the parameter decorator adds the metadata, and the method decorator reads it:</p>
<pre>@readMetadata 
public saySomething(@addMetadata something: string): string { 
    return `${this.name} ${this.surname} says: ${something}`; 
} </pre>
<p class="chapter-content">The following method decorator works like the method decorator that we implemented previously in this chapter, but it will read the metadata added by the parameter decorator, and instead of displaying all the arguments passed to the method in the console when it is invoked, it will only log the ones that have been decorated:</p>
<pre class="mce-root">function readMetadata(target: any, key: string, descriptor: any) {
 
    const originalMethod = descriptor.value; 
 
    descriptor.value = function(...args: any[]) { 
 
        const metadataKey = `_log_${key}_parameters`; 
        const indices = target[metadataKey]; 
 
        if (Array.isArray(indices)) { 
 
            for (let i = 0; i &lt; args.length; i++) { 
 
                if (indices.indexOf(i) !== -1) { 
                    const arg = args[i]; 
                    const argStr = JSON.stringify(arg); 
                    console.log(`${key} arg[${i}]: ${argStr}`); 
                } 
            } 
 
            return originalMethod.apply(this, args); 
 
        } 
 
    }; 
 
    return descriptor; <br/>}</pre>
<p class="mce-root">If we apply the <kbd>saySomething</kbd> method:</p>
<pre>const person = new Person("Remo", "Jansen"); 
person.saySomething("hello!"); </pre>
<p class="chapter-content">The <kbd>readMetadata</kbd> decorator will display the value of the parameters and which indices were added to the metadata (class property named <kbd>_log_saySomething_parameters</kbd>) in the console by the <kbd>addMetadata</kbd> decorator:</p>
<pre>saySomething arg[0]: "hello!" </pre>
<p>Note that in the previous example, we used a class property to store some metadata. However, this is not recommended practice. Later in this chapter, you will learn how to use the <kbd>reflection-metadata</kbd> API; this API has been designed specifically to generate and read metadata, and it is, therefore, recommended to use it when we need to work with decorators and metadata.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decorators with arguments</h1>
                
            
            
                
<p class="chapter-content">We can use a special kind of decorator factory to allow developers to configure the behavior of a decorator. For example, we could pass a string to a class decorator as follows:</p>
<pre>@logClass("option") 
class Person { 
// ... </pre>
<p class="chapter-content">To be able to pass some parameters to a decorator, we need to wrap the decorator with a function. The wrapper function takes the options of our choice and returns a decorator:</p>
<pre>function logClass(option: string) { 
    return function(target: any) { 
        // class decorator logic goes here 
        // we have access to the decorator parameters 
        console.log(target, option); 
    }; 
} </pre>
<p class="chapter-content">This can be applied to all the kinds of decorators that you learned in this chapter.</p>
<p>It is very important to <strong>avoid using an arrow function as the inner function</strong> to prevent potential problems with the <kbd>this</kbd> operator at runtime.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The reflect metadata API</h1>
                
            
            
                
<p class="chapter-content">We have learned that decorators can be used to modify and extend the behavior of a class's methods or properties. While this is a very good way to get to understand decorator in depth, <strong>it is not recommended to use a decorator to modify and extend the behavior of a class</strong>. Instead, we should try to use decorators to add metadata to the class being decorated. The metadata can then be consumed by other tools.</p>
<p>The recommendation to avoid using a decorator to modify and extend the behavior of a class could be reverted in the future if the TypeScript team implements a future known as <q>decorator mutation</q>. You can learn more about the status of the decorator mutation proposal at <a href="https://github.com/Microsoft/TypeScript/issues/4881">https://github.com/Microsoft/TypeScript/issues/4881</a>.</p>
<p class="chapter-content">The possibility of adding metadata to a class might not seem useful or exciting, but in my opinion, it is one of the greatest things that has happened to JavaScript in the past few years. As we already know, TypeScript only uses types at design time. However, some features, such as dependency injection, runtime type assertions, reflection, and automated mocking during testing are not possible when the type information is not available at runtime. The lack of type information at runtime is not a problem anymore because we can use decorators to generate metadata and that metadata can contain the required type information. The metadata can then be processed at runtime. When the TypeScript team started to think about the best possible way to allow developers to generate type information metadata, they reserved a few special decorator names for this purpose. The idea was that when an element was decorated using these reserved decorators, the compiler would automatically add the type's information to the element being decorated. The reserved decorators were the following:</p>
<p>"TypeScript compiler will honor special decorator names and will flow additional information into the decorator factory parameters annotated by these decorators.<br/>
<br/>
@type - The serialized form of the type of the decorator target<br/>@returnType - The serialized form of the return type of the decorator target if it is a function type, undefined otherwise<br/>@parameterTypes - A list of serialized types of the decorator target's arguments if it is a function type, undefined otherwise<br/>@name - The name of the decorator target  "                       <br/>
                                                                 – Decorators brainstorming by Jonathan Turner<br/></p>
<p class="chapter-content">Shortly after, the team TypeScript decided to use the reflection metadata API (one of the proposed ES7 features) instead of the reserved decorators. The idea is almost identical, but instead of using the reserved decorator names, we will use some reserved metadata keys to retrieve the metadata using the reflection metadata API. The TypeScript documentation defines three reserved metadata keys:</p>
<ul>
<li class="chapter-content"><em><em>Type metadata uses the metadata key design:type.</em></em></li>
<li class="chapter-content"><em>Parameter type metadata uses the metadata key design: paramtypes.</em></li>
<li class="chapter-content"><em>Return type metadata uses the metadata key design: returntype.</em></li>
</ul>
<p>- Issue #2577 - TypeScript Official Repository at GitHub.com<br/></p>
<p class="chapter-content">We will now learn how we to use the reflection metadata API. We need to start by installing the <kbd>reflect-metadata</kbd> npm module:</p>
<pre><strong>npm install reflect-metadata</strong> </pre>
<p>We don't need to install type definitions for the <kbd>reflect-metadata</kbd> npm module because it includes the type definitions.</p>
<p class="chapter-content">We can then import the <kbd>reflect-metadata</kbd> npm module as follows:</p>
<pre>import "reflect-metadata"; </pre>
<p>The <kbd>reflect-metadata</kbd> module <strong>should be imported only once in your entire application</strong> because the <kbd>Reflect</kbd> object is meant to be a global singleton.</p>
<p class="chapter-content">If you try to use some of the <kbd>reflect-metadata</kbd> API from a TypeScript in which the <kbd>reflect-metadata</kbd> module is not imported, you will need to add the following option to your <kbd>tsconfig.json</kbd> file:</p>
<pre>"types": [ 
  "reflect-metadata" 
] </pre>
<p class="chapter-content">We can then create a class for testing purposes. We are going to get the type of one of the class properties at runtime. We are going to decorate the class using a <kbd>property</kbd> decorator named <kbd>logType</kbd>:</p>
<pre>class Demo1 { 
    @logType 
    public attr1: string; 
    public constructor(attr1: string) { 
        this.attr1 = attr1; 
    } 
} </pre>
<p class="chapter-content">We need to invoke the <kbd>Reflect.getMetadata()</kbd> method using the <kbd>design:type</kbd> as the metadata key. The metadata value will be returned as a function. For example, for the type string, the <kbd>function String(){}</kbd> function is returned. We can use the <kbd>function.name</kbd> property to get the type as a string:</p>
<pre><a>function logType(target: any, key: string) {</a> 
    const type = Reflect.getMetadata("design:type", target, key); 
    console.log(`${key} type: ${type.name}`); 
} </pre>
<p class="chapter-content">If we compile the preceding code and run the resulting JavaScript code in a web browser, we will be able to see the type of the <kbd>attr1</kbd> property in the console:</p>
<pre>    <strong>'attr1 type: String'</strong>  </pre>
<p>Remember that to run this example, the <kbd>reflect-metadata</kbd> library must be imported as follows:<br/>
<kbd>import "reflect-metadata";</kbd></p>
<p class="chapter-content">We can apply the other reserved metadata keys similarly. Let's create a method with many parameters to use the <kbd>design:paramtypes</kbd> reserved metadata key to retrieve the types of the parameters:</p>
<pre class="mce-root">class Foo {} 
interface FooInterface {} 
 
class Demo2 { 
    @logParamTypes 
    public doSomething( 
        param1: string, 
        param2: number, 
        param3: Foo, 
        param4: { test: string }, 
        param5: FooInterface, 
        param6: Function, 
        param7: (a: number) =&gt; void 
    ): number { 
        return 1; <br/>    } <br/>}</pre>
<p class="mce-root">This time, we will use the <kbd>design:paramtypes</kbd> reserved metadata key. We are querying the types of multiple parameters, so the types will be returned as an array by the <kbd>Reflect.getMetadata()</kbd> function:</p>
<pre>function logParamTypes(target: any, key: string) {
    const types = Reflect.getMetadata( 
        "design:paramtypes", 
        target, 
        key 
    ); 
    const s = types.map((a: any) =&gt; a.name).join(); 
    console.log(`${key} param types: ${s}`); 
} </pre>
<p class="chapter-content">If we compile and run the preceding code in a web browser, we will be able to see the types of the parameters in the console:</p>
<pre>    <strong>'doSomething param types: String, Number, Foo, Object, Object, <br/> Function, Function'</strong>
  </pre>
<p class="chapter-content">The types are serialized and follow some rules. We can see that functions are serialized as function, and object literals (<kbd>{test : string}</kbd>) and interfaces are serialized as object. The following table showcases how different types are serialized:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Type</strong></td>
<td><strong>Serialized</strong></td>
</tr>
<tr>
<td>void</td>
<td>Undefined</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>number</td>
<td>Number</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>symbol</td>
<td>Symbol</td>
</tr>
<tr>
<td>any</td>
<td>Object</td>
</tr>
<tr>
<td>enum</td>
<td>Number</td>
</tr>
<tr>
<td>Class C{}</td>
<td>C</td>
</tr>
<tr>
<td>Object literal {}</td>
<td>Object</td>
</tr>
<tr>
<td>interface</td>
<td>Object</td>
</tr>
</tbody>
</table>
<p>Note that some developers have required the possibility of accessing the type of interfaces and the inheritance tree of a class via metadata. This feature is known as <strong>complex type serialization</strong> and is not available at the time of writing.</p>
<p class="chapter-content">To conclude, we are going to create a method with a return type and use the <kbd>design:returntype</kbd> reserved metadata key to retrieve the types of the return type:</p>
<pre>class Demo3 { 
    @logReturntype 
    public doSomething2(): string { 
        return "test"; 
    } 
} </pre>
<p class="chapter-content">Just like in the two previous decorators, we need to invoke the <kbd>Reflect.getMetadata()</kbd> function passing the <kbd>design:returntype</kbd> reserved metadata key:</p>
<pre>function logReturntype(target: any, key: string) { 
    const returnType = Reflect.getMetadata( 
        "design:returntype", 
        target, 
        key 
    ); 
    console.log(`${key} return type: ${returnType.name}`); 
} </pre>
<p class="chapter-content">If we compile and run the preceding code in a web browser, we will be able to see the types of the return type in the console:</p>
<pre>    <strong>'doSomething2 return type: String'</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The decorator factory</h1>
                
            
            
                
<p class="chapter-content">The official decorators proposal defines a decorator factory as follows:</p>
<p>A decorator factory is a function that can accept any number of arguments, and must return one of the types of decorator function.</p>
<p>- Ron Buckton, Decorators Proposal - TypeScript</p>
<p class="chapter-content">We have learned to implement class, property, method, and parameter decorators. However, in most cases, we will consume decorators, not implement them. For example, in <kbd>InversifyJS</kbd>, we use the <kbd>@injectable</kbd> decorator to declare that a class will be injected into other classes, but we don't need to implement the <kbd>@injectable</kbd> decorator. We can use the decorator factory to make decorators easier to consume. Let's consider the following code snippet:</p>
<pre>@logClass 
class Person { 
 
    @logProperty 
    public name: string; 
 
    @logProperty 
    public surname: string; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    @readMetadata 
    public saySomething(@addMetadata something: string): string { 
        return `${this.name} ${this.surname} says: ${something}`; 
    } 
} </pre>
<p class="chapter-content">The problem with the preceding code is that we, as developers, need to know that the <kbd>logMethod</kbd> decorator can only be applied to a method. This might seem trivial because the decorator name used (<kbd>logMethod</kbd>) makes it easier for us. A better solution is to enable developers to use a decorator named <kbd>@log</kbd> without having to worry about using the right kind of decorator:</p>
<pre>@log 
class Person { 
 
    @log 
    public name: string; 
 
    @log 
    public surname: string; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    @log 
    public saySomething(@log something: string): string { 
        return `${this.name} ${this.surname} says: ${something}`; 
    } 
} </pre>
<p class="chapter-content">We can achieve this by creating a decorator factory. A decorator factory is a function that can identify what kind of decorator is required and return it:</p>
<pre>function decoratorFactory( 
    classDecorator: Function, 
    propertyDecorator: Function, 
    methodDecorator: Function, 
    parameterDecorator: Function 
) { 
    return function (this: any, ...args: any[]) { 
        const nonNullableArgs = args.filter(a =&gt; a !== undefined); 
        switch (nonNullableArgs.length) { 
            case 1: 
                return classDecorator.apply(this, args); 
            case 2: 
                // break instead of return as property 
                // decorators don't have a return 
                propertyDecorator.apply(this, args); 
                break; 
            case 3: 
                if (typeof args[2] === "number") { 
                    parameterDecorator.apply(this, args); 
                } else { 
                    return methodDecorator.apply(this, args); 
                } 
                break; 
            default: 
                throw new Error("Decorators are not valid here!"); 
        } 
    }; 
} </pre>
<p class="chapter-content">As we can observe in the preceding code snippet, the decorator factory is a factory of decorators. The generated decorator uses the number and type of arguments passed to the decorator to identify the required kind of decorator that is appropriate for each case. The decorator factory can be used to create a universal decorator as follows:</p>
<pre>const log = decoratorFactory( 
    logClass, 
    logProperty, 
    readMetadata, 
    addMetadata 
); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we learned how to consume and implement the four available types of decorators (class, method, property, and parameter). We used decorators to mutate the original classes to understand how they work but we also learned that we <strong>should avoid using decorators to mutate the prototype of a class</strong>. We also learned how to create a decorator factory to abstract developers from the decorator types when they are consumed, how to pass configuration to a decorator, and how to use the reflection metadata API to access type information at runtime. As we have already mentioned, decorators in TypeScript are still an experimental feature, which doesn't mean that they are not ready for their usage in production systems but that their public API might be subject to breaking changes in the future. Please note that the future TypeScript releases will document how to get around these potential breaking changes if they end up happening. In the following chapter, we will learn how to configure an advanced TypeScript development workflow.</p>


            

            
        
    </div>



  </body></html>