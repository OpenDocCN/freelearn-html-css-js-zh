<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Routing, Touch Support, and Debugging</h1></div></div></div><p>In this chapter, we will perform the last steps before we customize the theme and create the production build of our application. We will cover some different topics, such as enabling routing in our application, a quick overview about responsive design and Ext JS, touch support, debugging Ext JS apps, and a quick overview about testing.</p><p>So, in this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ext JS routing</li><li class="listitem" style="list-style-type: disc">Responsive design and touch support</li><li class="listitem" style="list-style-type: disc">Transforming Ext JS projects into mobile apps</li><li class="listitem" style="list-style-type: disc">Debugging Ext JS applications</li><li class="listitem" style="list-style-type: disc">Tools for testing Ext JS applications</li><li class="listitem" style="list-style-type: disc">Helpful tools</li><li class="listitem" style="list-style-type: disc">Where to find extra and open source plugins</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec49"/>Ext JS routing</h1></div></div></div><p>Routing<a id="id870" class="indexterm"/> is <a id="id871" class="indexterm"/>a capability introduced in Ext JS 5 that makes the process of handling history using the <code class="literal">Ext.util.History</code> class in the application easier.</p><p>On a normal website, a user navigates to and from different pages as they click links or fill out forms. However, in a single-page application, a user's interaction doesn't load a new page. Instead, it is handled within a single page and components react to that interaction. So how do we still allow users to use the browser's forward and back buttons? Using routes allows the user to use this capability by mapping hash tokens to controller methods.</p><p>For example, we have a screen to manage the Films information. Using routing, we can allow the user to access this screen (if the user has proper entitlements) and automatically selects a particular row of the<a id="id872" class="indexterm"/> Films grid by accessing <code class="literal">https://localhost/masteringextjs/#films/3</code>. When the user accesses this link, we can instruct the application to open the <strong>Films</strong> tab and select the row of the film that has the ID <strong>3</strong>.</p><p>To enable routes<a id="id873" class="indexterm"/> in our application, we are going to use the <code class="literal">Root</code> Controller that was created by Sencha Cmd automatically when we created the application.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec102"/>Default token</h2></div></div></div><p>We are going to start<a id="id874" class="indexterm"/> by enabling a default token. When our<a id="id875" class="indexterm"/> application starts, it is going to redirect to the <code class="literal">#home</code> hash token. To do so, we are going to add the following code to the <code class="literal">Application.js</code> file:</p><div><pre class="programlisting">defaultToken : 'home',</pre></div><p>Then, inside the <code class="literal">Root</code> Controller, we will listen to this hash and redirect to the <code class="literal">onHome</code> method, as follows:</p><div><pre class="programlisting">routes : {
    'home' : 'onHome'
},</pre></div><p>Inside the <code class="literal">onHome</code> method, we want to activate the first tab (<strong>Home</strong>) of the <code class="literal">Main Panel</code>. Use the following code to do this:</p><div><pre class="programlisting">onHome : function() {
    var mainPanel = this.getMainPanel(); //#1
    if (mainPanel){
        mainPanel.setActiveTab(0);
    }
},</pre></div><p>We are using a <code class="literal">getMain</code> method (<code class="literal">#1</code>), which refers to a <code class="literal">ref</code> of the Controller. We need to declare it as well. We are going to declare <code class="literal">ref</code> configuration inside the <code class="literal">init</code> method:</p><div><pre class="programlisting">init: function() {
    this.addRef([{
        ref: 'mainPanel',
        selector: 'mainpanel'
    }]);
    this.callParent();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>Loading a Controller programmatically</h2></div></div></div><p>At the beginning <a id="id876" class="indexterm"/>of this book, you learned that the Controllers are loaded when the application is loaded (MVC). As our application has a <strong>Login</strong> screen, we do not want to enable the routes when the application is loaded. We only want to enable the routes after the user is logged in. The <code class="literal">Root</code> Controller is going to be loaded when the application loads, and we do not want that to happen.</p><p>Inside <code class="literal">Application.js</code> we are going to comment the <code class="literal">Root</code> Controller:</p><div><pre class="programlisting">controllers: [
    //<strong>'Root'</strong>,
    'Menu',
    'StaticData'
],</pre></div><p>When the <code class="literal">Main</code> View is loaded, we want to initialize the <code class="literal">Root</code> Controller. So we are going to <code class="literal">init</code> the <code class="literal">Root</code> Controller inside the <code class="literal">init</code> method of <code class="literal">main.MainController</code>:</p><div><pre class="programlisting">init: function() {
    Packt.app.createController('Root');
},</pre></div><p>And this is how we create a Controller programmatically in Ext JS. The Router will be enabled only after the <code class="literal">Main</code> View is loaded. We could place all the routes inside <code class="literal">MainController</code>, but it would coexist with the existing code that we have in <code class="literal">MainController</code> already, and maintaining this code in the future could be a little difficult. This is also a design decision that we need to make: do we keep all the routes inside a single Controller or do we separate the code? Feel free to organize the code as you see fit. In big applications, it can be difficult to maintain many hash tokens organized in a single Controller.</p><p>With the code we have so far, when we render <code class="literal">https://localhost/masteringextjs</code> application, it will be redirected automatically to <code class="literal">https://localhost/masteringextjs/#home</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>Handling routes</h2></div></div></div><p>Inside<a id="id877" class="indexterm"/> the <code class="literal">routes</code> configuration of the <code class="literal">Root</code> Controller<strong>,</strong> we will <a id="id878" class="indexterm"/>handle the possible routes for our application. We will use the <code class="literal">xtypes</code> we created for our application. It is a good thing we kept track of them in the <code class="literal">menu</code> table in our database (<code class="literal">className</code> column)!</p><p>The following are the possible hash tokens we have in our application: <code class="literal">user</code>, <code class="literal">actorsgrid</code>, <code class="literal">categoriesgrid</code>, <code class="literal">languagesgrid</code>, <code class="literal">citiesgrid</code>, <code class="literal">countriesgrid</code>, <code class="literal">films</code>, and <code class="literal">salesfilmcategory</code>. We can define a method for each one of them as we developed for the <code class="literal">home</code> token. But what should be done when the user accesses any of these tokens open in the respective tab. So what we want to do is handle multiple tokens in a single method. This is the code we will add inside the <code class="literal">routes</code> configuration in the <code class="literal">Root</code> Controller:</p><div><pre class="programlisting">'user|actorsgrid|categoriesgrid|languagesgrid|citiesgrid|countriesgrid|films|salesfilmcategory': {
    before: 'onBeforeRoute',
    action: 'onRoute'
}</pre></div><p>When we <a id="id879" class="indexterm"/>want <a id="id880" class="indexterm"/>to handle several tokens in the same method, we can use <code class="literal">|</code> to separate them. Note that in the preceding code, we are declaring two methods: <code class="literal">onBeforeRoute</code> and <code class="literal">onRoute</code>. We might want to check whether the user has entitlements to access the screen (after all, what is stopping a smart user trying to access a screen that the user does not have permission via routing?). So we can handle it in the following code (however, this is not necessarily the best way to secure an application):</p><div><pre class="programlisting">onBeforeRoute: function(action){
    var hash = Ext.util.History.getToken(); //#1

    Ext.Ajax.request({
        url     : 'php/security/verifyEntitlement.php',
        params  : {
            module : hash
        },
        success : function(conn, response, options, eOpts) {

            var result = Packt.util.Util.decodeJSON(conn.responseText);

            if (result.success) {
                action.resume();   //#2
            } else {
                Packt.util.Util.showErrorMsg(result.msg);
                action.stop();     //#3
            }
        },
        failure : function(conn, response, options, eOpts) {
            Packt.util.Util.showErrorMsg(conn.responseText);
            action.stop();         //#4
        }
    });
},</pre></div><p>As we are using generic code here and we want to send to the <code class="literal">className</code> parameter the user is trying to access to the server, we <a id="id881" class="indexterm"/>can retrieve it using the code in line <code class="literal">#1</code>. The <code class="literal">before</code> action method only <a id="id882" class="indexterm"/>receives one parameter, which is the <code class="literal">action</code> parameter. Depending on the result, we can resume it (<code class="literal">#2</code>), which means the user has access to the screen—and the <code class="literal">onRoute</code> method will be executed next. Or, we can stop the action (<code class="literal">#3</code> and <code class="literal">#4</code>), which means the <code class="literal">onRoute</code> method will not be executed next.</p><p>Let's take a look at the method <code class="literal">onRoute</code> method:</p><div><pre class="programlisting">onRoute: function(){
    var me = this,
        hash = Ext.util.History.getToken(),
        main = me.getMain(); //#5

    me.locateMenuItem(main, hash); //#6
},</pre></div><p>This method will call the <code class="literal">locateMenuItem</code> (<code class="literal">#6</code>) method passing the <code class="literal">mainmenu</code> reference (<code class="literal">#5</code>):</p><div><pre class="programlisting">{
    ref: 'main',
    selector: '[xtype=mainmenu]'
}</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec59"/>Refactoring the Menu code</h3></div></div></div><p>Let's take<a id="id883" class="indexterm"/> a look at the <code class="literal">locateMenuItem</code> code:</p><div><pre class="programlisting">locateMenuItem: function(mainMenu, hash){
    var me = this,
        root, node;
    Ext.each(mainMenu.items.items, function(tree){
        if (tree.getXType() === 'menutree'){
            root = tree.getRootNode();
            node = root.findChild('className', hash);
            if (node){
                me.openTab(node); //#1
                return;
            }
        }
    });
},</pre></div><p>The previously mentioned method is searching for a node in each <code class="literal">menutree</code> we created for the menu of the application that matches the hash of the route. If we find the node, we call the <code class="literal">openTab</code> method (<code class="literal">#1</code>):</p><div><pre class="programlisting">openTab: function(record){
    var mainPanel = this.getMainPanel();

    var newTab = mainPanel.items.findBy(
        function (tab){
            return tab.title === record.get('text');
        });

    if (!newTab){
        newTab = mainPanel.add({
            xtype: record.get('className'),
            glyph: record.get('glyph') + '@FontAwesome',
            title: record.get('text'),
            closable: true
        });
    }

    mainPanel.setActiveTab(newTab);
},</pre></div><p>If we take a <a id="id884" class="indexterm"/>look at the code of the <code class="literal">onTreePanelItemClick</code> method from the <code class="literal">Menu</code> Controller, we will note that it is exactly the same as the <code class="literal">openTab</code> method. Although we are handling routes at the end of this book, it is best if we start handling them when we start developing the application. So, if you are planning on using routes, make sure routes is part of the design, because it might require some code changes if you decide to implement it after the application is developed.</p><p>The <code class="literal">onTreePanelItemClick</code> method will have the following code now:</p><div><pre class="programlisting">onTreePanelItemClick: function(view, record, item, index, event, options){
    this.redirectTo(record.get('className'));
},</pre></div><p>When the user clicks on the <code class="literal">Node</code> of the <code class="literal">Tree</code> of the menu we implemented, it is going to redirect to the hash of the <code class="literal">className</code> parameter of the <code class="literal">Node</code>, and the <code class="literal">Root</code> Controller will handle opening the tab.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Handling unmatched routes</h2></div></div></div><p>If<a id="id885" class="indexterm"/> the<a id="id886" class="indexterm"/> user tries to access a route that is not defined in the application, we can execute some code as well. In the <code class="literal">Root</code> Controller, we can add the following code:</p><div><pre class="programlisting">listen : {
    controller : {
        '*': {
            unmatchedroute: 'onUnmatchedRoute'
        }
    }
},</pre></div><p>And we <a id="id887" class="indexterm"/>can <a id="id888" class="indexterm"/>display an error message to the user, as follows:</p><div><pre class="programlisting">onUnmatchedRoute : function(hash) {
    Packt.util.Util.showErrorMsg('Hash does not exist!');
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Handling parameters</h2></div></div></div><p>Now let's<a id="id889" class="indexterm"/> develop more complex route handling. For the <a id="id890" class="indexterm"/>
<strong>Films</strong> screen, let's say we want the user to be able to select a row from the Films grid using a hash token, as demonstrated in the following screenshot:</p><div><img src="img/0457OT_10_01.jpg" alt="Handling parameters"/></div><p>We can define the following route:</p><div><pre class="programlisting">'films/:id' : {
    action: 'onFilmSelect',
    before: 'onBeforeFilmSelect',
    conditions : {
        ':id' : '([0-9]+)'
    }
}</pre></div><p>This <a id="id891" class="indexterm"/>means the <a id="id892" class="indexterm"/>user can try to access a URL with the format <code class="literal">https://localhost/masteringextjs/#films/2</code>. If the user tries to access <code class="literal">https://localhost/masteringextjs/#films/ace</code>, it is not valid because of the condition of the <code class="literal">id</code> parameter—it needs to be a numeric value. This means we can also define regular expressions to validate the parameters of hash tokens.</p><p>Before we execute <code class="literal">onFilmSelect</code>, we want to do a few things:</p><div><pre class="programlisting">onBeforeFilmSelect: function(id, action){

    var me = this,
        main = me.getMain();

    this.locateMenuItem(this.getMain(),'films'); //#1

    var record = this.getFilmsGrid().getStore().findRecord('film_id', id);
    if(record) {
        action.resume();
    }
    else {
        action.stop();
    }
},</pre></div><p>We need to open the <strong>Films</strong> screen (<code class="literal">#1</code>) and check whether the record the user wants to select exists in the Store. If the result is positive, continue the execution and if not, stop it.</p><p>The reference for <code class="literal">filmsGrid</code> is given here:</p><div><pre class="programlisting">{
    ref: 'filmsGrid',
    selector: '[xtype=films-grid]'
}</pre></div><p>And finally, the reference for the <code class="literal">onFilmSelect</code> method is given here:</p><div><pre class="programlisting">onFilmSelect: function(id){
    this.getFilmsGrid().fireEvent('selectfilm', id);
}</pre></div><p>We are going to fire the <code class="literal">selectfilm</code> event of <code class="literal">films-grid</code>, as shown in the following code; this requires some new code inside the <code class="literal">FilmsGrid</code> class:</p><div><pre class="programlisting">listeners: {
    itemclick: 'onItemClick',
    selectfilm: 'onFilmSelect'
}</pre></div><p>We are going <a id="id893" class="indexterm"/>to handle the listeners in the <code class="literal">FilmsController</code> class, as shown in the following code:</p><div><pre class="programlisting">onFilmSelect: function(id){
    var me = this,
        grid = me.lookupReference('filmsGrid'),
        store = me.getStore('films'),
        record = store.findRecord( 'film_id', id );

    if (record){
        grid.getSelectionModel().select(record);
    }
},</pre></div><p>What we are doing <a id="id894" class="indexterm"/>in the preceding code is finding the record by <code class="literal">film_id</code> given and selecting it in <code class="literal">FilmsGrid</code>.</p><p>When the user clicks on a row of the grid, the <code class="literal">onItemClick</code> method will be fired:</p><div><pre class="programlisting">onItemClick: function( view, record, item, index, e, eOpts ) {
    this.redirectTo('films/' + record.get('film_id'));
}</pre></div><p>We are simply going to redirect the request to the <code class="literal">Route</code> Controller so that it can handle the selection with the code we developed in this topic.</p><div><div><h3 class="title"><a id="note88"/>Note</h3><p>As mentioned before, routing can become very complex in some applications, so the best thing is to start handling them from the very beginning of development. For more details, please check out Sencha guides and documentation about routing.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec50"/>Using the responsive design plugin</h1></div></div></div><p>Another new <a id="id895" class="indexterm"/>capability introduced in Ext JS 5 is the option to develop responsive applications. Mobile devices are part of our lives. We basically have <a id="id896" class="indexterm"/>a computer in our pockets. It is very common nowadays to have tablet or mobile compatible as an item listed in a user requirements document. Fortunately, Ext JS 5 provides good support and allows us to achieve this requirement without too much effort.</p><p>Ext JS 5 introduces the responsive plugin and mixin. The plugin can be used in any component, and the mixin can be used in any other class. This plugin responds dynamically to changes in screen size and orientation by controlling <code class="literal">responsiveConfig</code>.</p><p>For example, let's do a quick example in our project. If the width of the screen is less than 768 pixels and<a id="id897" class="indexterm"/> the screen is in <code class="literal">tall</code> mode, we are going to hide the application menu and display a new button that is going to render the menu as displayed in the following screenshot:</p><div><img src="img/0457OT_10_02.jpg" alt="Using the responsive design plugin"/></div><p>In the <code class="literal">Packt.view.main.Main</code> class, we are going to add the responsive plugin to the <code class="literal">west</code> region. The code is presented as follows:</p><div><pre class="programlisting">{
    xtype: 'mainmenu',
    region: 'west',
    plugins: 'responsive',
    responsiveConfig: {
        'width &lt; 768 &amp;&amp; tall': {
            visible: false
        },
        'width &gt;= 768': {
            visible: true
        }
    }
}</pre></div><p>Inside <code class="literal">responsiveConfig</code>, we <a id="id898" class="indexterm"/>can add some conditions and set the component's configuration accordingly. We can change the layout, render a different component, and do whatever is needed in the application. With only the preceding code, if we execute the application and decrease the browser's width, we will see the menu will be hidden automatically when the criteria are met. It is really nice!</p><p>In <code class="literal">Packt.view.main.Header</code>, we are going to add a new component as well, as follows:</p><div><pre class="programlisting">{
    xtype: 'tbfill'
},{
<strong>    xtype: 'responsive-mainmenu'</strong>
},{
    xtype: 'translation'
},</pre></div><p>The code for this component is presented as follows:</p><div><pre class="programlisting">Ext.define('Packt.view.main.ResponsiveMenuButton', {
    extend: 'Ext.button.Split',
    xtype: 'responsive-mainmenu',

    requires: [
        'Packt.view.main.MainModel'
    ],

    text: 'Menu',

    plugins: 'responsive',
    responsiveConfig: {
        'width &lt; 768 &amp;&amp; tall': {
            visible: true
        },
        'width &gt;= 768': {
            visible: false
        }
    },

    menu: {
        xtype: 'menu',
        items: [{
            xtype: 'mainmenu'
        }]
    }
});</pre></div><p>We are reusing the<a id="id899" class="indexterm"/> menu we developed at the beginning of this book. Of course, we could develop a UX that is more user friendly, but we are just focusing on the functionality here for a quick test.</p><p>Google Chrome has a really nice feature if we need to work with responsive design. It is the capability of emulating the project in different devices to see how they are going to look. In Google Developer Tools, click on the mobile device icon as shown in the following screenshot and start the adventure:</p><div><img src="img/0457OT_10_03.jpg" alt="Using the responsive design plugin"/></div><div><div><h3 class="title"><a id="note89"/>Note</h3><p>For more information about Ext JS 5 and responsive design, please read <a class="ulink" href="http://www.sencha.com/blog/designing-responsive-applications-with-ext-js">http://www.sencha.com/blog/designing-responsive-applications-with-ext-js</a> and check the source code of this example <a class="ulink" href="http://goo.gl/odce6j">http://goo.gl/odce6j</a>. Firefox also has a mobile view in its developer toolbar. Go to <strong>Tools</strong> | <strong>Web Developer</strong> | <strong>Responsive Design View</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Enabling touch support</h1></div></div></div><p>In this<a id="id900" class="indexterm"/> section, we will quickly discuss responsive design. Since it is <a id="id901" class="indexterm"/>not the primary topic of this book, we will implement a very simple example that will give us an idea of what we need to do if we need to develop a responsive application with Ext JS. And speaking of responsive design, we know Ext JS is great to develop desktop applications (that will be executed from a desktop computer or a laptop), but mobiles have now become a very integral part of our lives. We will figure out the means to run the same application running on a desktop and also on a mobile device. We will also discuss how to enable touch support in our application as well.</p><p>The major difference between running an application on a desktop and a mobile device is the events, among other details. On a desktop, when the user clicks on a button, we listen to the <code class="literal">click</code> event. On a touch mobile device, there is no <code class="literal">click</code> event; there is the <code class="literal">tap</code> event, because we are touching the screen and not working with a mouse.</p><p>Another detail is the size of the components. The Ext JS classic theme is really nice, but small for touch screens. Throughout this book, we have been using the <code class="literal">Neptune</code> theme, which is the default theme set to the application when we created it with Sencha Cmd. The <code class="literal">Neptune</code> theme has larger components than the <code class="literal">classic</code> theme but still is not good enough to be used on touch devices. Let's experiment! If you have a touch device, try executing the application we developed throughout this book on it. If you do not have a touch device, you need not worry; you can do this experiment using the Google Chrome emulator mentioned in the preceding topic.</p><p>The following screenshot exemplifies the application being executed on an iPad mini:</p><div><img src="img/0457OT_10_04.jpg" alt="Enabling touch support"/></div><p>If we try to use<a id="id902" class="indexterm"/> the application as is, we will be able to use most of its capabilities. Because we are using a desktop theme, with small icons, it will not work 100% in a mobile device. For example, the <code class="literal">RowExpander</code> + button doesn't work very well because the + icon is very small for a mobile device.</p><p>Ext JS 5 introduces <a id="id903" class="indexterm"/>new themes that were designed specially for touch devices. There is a special version of the <code class="literal">Neptune</code> theme and also a special version of the <code class="literal">Crisp</code> theme (also introduced in Ext JS 5). We can add the touch support to our application by changing the theme in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">"theme": "ext-theme-neptune-touch", //or "ext-theme-crisp-touch"</pre></div><p>With <code class="literal">sencha app watch</code> being executed in a terminal, try changing the theme to one of the previously mentioned options. Don't forget to clean the browser's cache to make sure you will get the new version of the CSS file next time you refresh the application. Now let's try the application again, as follows:</p><div><img src="img/0457OT_10_05.jpg" alt="Enabling touch support"/></div><p>Note how there<a id="id904" class="indexterm"/> is more space between the components now. This is to make sure we can tap (touch) the components.</p><p>We don't <a id="id905" class="indexterm"/>have a touch-optimized application. To make it 100 percent, we can review any size that we set (for example, column width) and use some responsive design techniques to have the application looking great in mobile devices!</p><div><div><h3 class="title"><a id="note90"/>Note</h3><p>For more information, please visit <a class="ulink" href="http://goo.gl/VnT7bT">http://goo.gl/VnT7bT</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>From Ext JS to mobile</h2></div></div></div><p>What if the <a id="id906" class="indexterm"/>product you are developing requires a special app implement, especially for touch devices? We are not talking about the techniques we implemented in the previous topic; we are talking about a mobile app for the same product. For example, Facebook has a version for desktop, but it also has an app for mobile devices. It might be what you need as well.</p><p>We would like to introduce Sencha Touch, the cousin of Ext JS! Sencha Touch was the first HTML5 mobile framework on the market. And there's more good news: you do not need to rewrite all of your code to have the same application also available to mobile devices.</p><p>Sencha Touch and<a id="id907" class="indexterm"/> Ext JS share the same API. The data package, such as models, stores and the core of the framework, is the same. Sencha Touch also uses MVC. The Controller and View (components) work in a way that is very similar to that of Ext JS Controller and View. Of course, the biggest difference is in the views since a web component is different from a mobile component. However, Sencha Touch also offers forms and lists, and we can find even grid components customized for mobile devices. The charts are also shared between the frameworks.</p><p>The following diagram shows the analysis of how much code we can reuse after using Sencha Touch:</p><p> </p><div><img src="img/0457OT_10_06.jpg" alt="From Ext JS to mobile"/></div><p>The amount of <a id="id908" class="indexterm"/>code we can reuse is huge! And we also have two ways of implementing it: the first one is to have a mobile app, where the user will access a URL pointing to a Sencha Touch deploy (Sencha Touch and server-side code at the same domain). And the second option is to have the Sencha Touch code running on the user's device (Sencha Touch offers native packaging to iOS and Android, but we can also have native Blackberry 10 and Windows Phone 8 native apps with Sencha Touch) and the server-side code running on a server on the Web. In this case, we can use<a id="id909" class="indexterm"/> CORS (<a class="ulink" href="http://enable-cors.org/">http://enable-cors.org/</a>) to make the Ajax communication between the app and the server-side code.</p><div><div><h3 class="title"><a id="note91"/>Note</h3><p>To learn more about <a id="id910" class="indexterm"/>Sencha Touch, please go to <a class="ulink" href="http://www.sencha.com/products/touch/">http://www.sencha.com/products/touch/</a>.</p></div></div><p>On mobile, it is also possible to access the hardware features such as contacts, camera, geolocation, and more. We can use an open source framework called <a id="id911" class="indexterm"/>
<strong>Apache Cordova</strong> (or <a id="id912" class="indexterm"/>
<strong>Phonegap</strong>, which is a Apache Cordova implementation). Sencha Cmd also has commands that support the integration with Cordova. The following links provide more information about this topic:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html">http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://cordova.apache.org/">http://cordova.apache.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://phonegap.com/">http://phonegap.com/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://vimeo.com/76568053">http://vimeo.com/76568053</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Debugging Ext JS applications</h1></div></div></div><p>The <a id="id913" class="indexterm"/>art of debugging is as important as the art of programming. We usually write code that we think is going to work as soon as we execute it, but<a id="id914" class="indexterm"/> this is not true sometimes. We write the code, then we get an exception or JavaScript error, and then we need to dive into the code again to see where we went wrong. It's part of being a developer and it is also part of life!</p><p>Throughout this book, you learned that debugging is important, especially when we were learning an easier way to figure out the correct <a id="id915" class="indexterm"/>
<strong>Component Query</strong> selector. When developing applications with Ext JS, it is mandatory to use a debug tool. This is so because it is not only for debugging, but you will also be able to learn more about the framework, and it is a great learning exercise.</p><p>A few things we always need to remind ourselves of while creating Ext JS applications: case-sensitive matters—the <code class="literal">LoginScreen</code> class is different from <code class="literal">Loginscreen</code>. Be careful with reserved words (<a class="ulink" href="http://mattsnider.com/reserved-words-in-javascript/">http://mattsnider.com/reserved-words-in-javascript/</a>)—you cannot use them as namespaces, names of classes and packages, or as variable names. Check the spelling; this is very important—sometimes when we are typing, we can type an extra character (<em>fat finger</em> syndrome).</p><p>If you have <a id="id916" class="indexterm"/>programmed in JavaScript for almost 10 years now, you will <a id="id917" class="indexterm"/>know that before, our only friend was the dear <code class="literal">alert</code> prompt. We used to put several alerts on the code, execute it, and then see which alert was not executed so that we could find where the error was. Now we have our dear friend <code class="literal">console</code>. Abuse the use of console for <code class="literal">log</code>, <code class="literal">warn</code>, and <code class="literal">error</code>!</p><p>We also have great tools to debug! The two most important are Google Developer Tools and Firebug for Firefox! Learn to use at least one of them (they are very similar).</p><p>For example, let's use Google Developer Tools. It comes with a few tabs; on the <strong>Network</strong> tab, we can see the files that were loaded as follows:</p><div><img src="img/0457OT_10_07.jpg" alt="Debugging Ext JS applications"/></div><p>And speaking of files that are being loaded or not, this is a very huge deal! Simple mistakes, such as the name of the class (using MVC), path of CSS, and JS on the <code class="literal">index.html</code> file, can be verified using the <strong>Console</strong> or the <strong>Network</strong> tab. This tab is also very important as in some chapters we verified the parameters that were being sent to the server. Even though it might be the first time we are working with an Ext JS component, and we do not know how to handle the data that will be sent to the server, we can take a look at the parameters of the request in the <strong>Network</strong> tab, and then it is easier to read the correct parameters in the server. The same applies when we receive any information from the server, for example, check whether the JSON is coming as per Ext JS expectations.</p><p>On the <strong>Elements</strong> tab, we can see details; the HTML code that was generated by the Ext JS code and also the CSS <a id="id918" class="indexterm"/>that is being applied to the components. This is very useful when we want to apply some custom CSS and debug why the style was not applied.</p><div><img src="img/0457OT_10_08.jpg" alt="Debugging Ext JS applications"/></div><p>When we<a id="id919" class="indexterm"/> move the mouse over, the portion related to that HTML is highlighted on the screen. We also have the <strong>CSS</strong> and <strong>Script</strong> tabs. We can change the CSS and script in real time and see the changes applied in real time! This is simply amazing! So, it is very important to learn how to use a debug tool.</p><p>In the <strong>Sources</strong> tab, we can take the source code that was loaded in the form of the project's structure. This tab is very important for us because it allows us to use the debugging capabilities of the browser to debug our code. The debugging technique is very similar to what is used with server-side languages; we add a breakpoint, execute the code, and then watch and inspect variable values and see what happens in every line of the source code, as follows:</p><div><img src="img/0457OT_10_09.jpg" alt="Debugging Ext JS applications"/></div><div><div><h3 class="title"><a id="note92"/>Note</h3><p>To learn more about<a id="id920" class="indexterm"/> Firebug, please visit <a class="ulink" href="http://getfirebug.com/">http://getfirebug.com/</a>. And to learn more about <a id="id921" class="indexterm"/>Google Developer Tools, please visit: <a class="ulink" href="https://developers.google.com/chrome-developer-tools/">https://developers.google.com/chrome-developer-tools/</a> and <a class="ulink" href="https://developer.chrome.com/extensions/tut_debugging">https://developer.chrome.com/extensions/tut_debugging</a>.</p></div></div><p>And, of course, there <a id="id922" class="indexterm"/>are the special add-ons we talked about in <a class="link" href="ch07.html" title="Chapter 7. Static Data Management">Chapter 7</a>, <em>Static Data Management</em>: Sencha add-on for Chrome and Illumination for developers for Firebug.</p><p>Mastering one <a id="id923" class="indexterm"/>debugging tool is important as mastering the art of programming in Ext JS. After all, we don't know if we will have the opportunity to work on a project from scratch or we will need to maintain other developers' code. In this case, knowing how to debug is a must-have skill! Choose your favorite weapon and have fun coding and debugging!</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Testing Ext JS applications</h1></div></div></div><p>Testing is<a id="id924" class="indexterm"/> a very important part when developing applications <a id="id925" class="indexterm"/>or providing maintenance. When we do not write tests, we need to verify each use case manually, and if we change anything on the code, we will need to perform all the testing manually again. The same happens when we need to maintain the code; developers usually test only what has been changed, but the correct thing to do would be regression tests to see whether the change did not break anything else. So spending some time writing tests can be a win at the end. You will spend a little bit more time writing code, but then you will be able to run all the tests with a single click and then verify what is broken and what is still working.</p><p>We are also very used to performing unit tests on the server-side code. Java, PHP, Ruby, C# communities offer a lot of options to perform unit tests on the server-side code, and sometimes, we can forget to test the frontend code (in this case Ext JS). But do not worry; there are a few tools we can use to include Ext JS on the tests as well.</p><p>One tool that is very popular for JavaScript testing in general is <a id="id926" class="indexterm"/>
<strong>Jasmine</strong> (<a class="ulink" href="http://jasmine.github.io/">http://jasmine.github.io/</a>). Jasmine is a testing tool that is used for <a id="id927" class="indexterm"/>
<strong>Behavior-Driven Development</strong> (<strong>BDD</strong>)—(<a class="ulink" href="http://en.wikipedia.org/wiki/Behavior-driven_development">http://en.wikipedia.org/wiki/Behavior-driven_development</a>). In Ext JS documentation, you can find two guides explaining how to test Ext JS applications with Jasmine: <a class="ulink" href="http://docs.sencha.com/extjs/4.2.0/#!/guide/testing">http://docs.sencha.com/extjs/4.2.0/#!/guide/testing</a> and <a class="ulink" href="http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers">http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers</a>. Although the guides were written for Ext JS 4.x, they can also be applied to Ext JS 5.</p><p>There is also<a id="id928" class="indexterm"/> a <a id="id929" class="indexterm"/>testing framework designed specially for a Sencha application called <a id="id930" class="indexterm"/>
<strong>Siesta</strong> (<a class="ulink" href="http://www.bryntum.com/products/siesta/">http://www.bryntum.com/products/siesta/</a>). Siesta can also be used to test JavaScript code in general, but the cool side of Siesta is that it provides a special API so that we can test Ext JS applications, including tests on user interface components. Siesta comes with some great examples that can be used to start writing our own test cases.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Helpful tools</h1></div></div></div><p>In this<a id="id931" class="indexterm"/> topic, we will present some tools that can help developers a lot while implementing Ext JS applications. You can find all the links of the tools mentioned here at the end of this topic.</p><p>The first tool is <strong>JSLint</strong>. JSLint <a id="id932" class="indexterm"/>is a tool that can help you to find JavaScript errors and can also help you to clean your code.</p><p>The second tool is <strong>YSlow</strong>. YSlow<a id="id933" class="indexterm"/> analyzes web pages and tells you why they're slow based on the rules for high performance websites. YSlow is a Firefox add-on integrated with the popular Firebug web development tool.</p><p>Ext JS is a JavaScript framework, and JavaScript performance is a topic that is a concern for a lot of companies. The minimum the user needs to load on the browser, the better. That is why it is very important to make a production build using Sencha Cmd and not simply deploy all the application files on production.</p><p>Sencha Cmd<a id="id934" class="indexterm"/> is also going to minify the Ext JS CSS file to a smaller CSS, and we can also include only the CSS for the components that we are going to really use (just in case we create a custom theme). It is also important to create any application custom CSS inside the <code class="literal">sass/etc</code> or <code class="literal">sass/var</code> folders so that the CSS can also be added to the main CSS file generated by Sencha Cmd.</p><p><strong>CSS Sprites</strong><a id="id935" class="indexterm"/> is another very important topic. Font icons such as Font Awesome are really nice, but sometimes that is a need to use image icons. In this case, we can create a CSS Sprite, which involves creating a single image with all the icons. And on the CSS, we simply have a single image and pass a <code class="literal">background-position</code> property of the icon we want to display, like this:</p><div><pre class="programlisting">.icon-message {
  background-image: url('mySprite.png');
  background-position: -10px -10px;
}

.icon-envolope {
  background-image: url('mySprite.png');
  background-position: -15px -15px;
}</pre></div><p>There are a few tools that can also help us to create CSS Sprites, such as<a id="id936" class="indexterm"/> <strong>SpritePad</strong>, <strong>SpriteMe</strong>, and <a id="id937" class="indexterm"/>
<strong>Compass Sprite Generator</strong>.</p><p>Here are all the links<a id="id938" class="indexterm"/> for <a id="id939" class="indexterm"/>the<a id="id940" class="indexterm"/> tools mentioned in this section:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>JSLint</strong>: <a class="ulink" href="http://www.jslint.com/">http://www.jslint.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>YSlow</strong>: <a class="ulink" href="http://developer.yahoo.com/yslow/">http://developer.yahoo.com/yslow/</a></li><li class="listitem" style="list-style-type: disc"><strong>SpritePad</strong>: <a class="ulink" href="http://wearekiss.com/spritepad">http://wearekiss.com/spritepad</a></li><li class="listitem" style="list-style-type: disc"><strong>SpriteMe</strong>: <a class="ulink" href="http://www.spriteme.org/">http://www.spriteme.org/</a></li><li class="listitem" style="list-style-type: disc"><strong>Compass Sprite Generator</strong>: <a class="ulink" href="http://compass-style.org/help/tutorials/spriting/">http://compass-style.org/help/tutorials/spriting/</a></li></ul></div><p>Always remember that Ext JS is JavaScript, so we need to care about performance as well. With all these little tips posted on this topic, an Ext JS application can improve its performance as well.</p><p>And last but not least, there are two tools from Sencha: <strong>Sencha</strong> <strong>Architect</strong> <a id="id941" class="indexterm"/>and <strong>Sencha</strong> <strong>Eclipse</strong> <strong>Plugin</strong>. Sencha Architect is a visual designer tool that is very similar to Visual Studio: you drag and drop, and you can see how the application looks, and the entire configuration that you need to do is done using the <strong>Config</strong> panel. Only methods, functions, and templates are free to enter whatever code you like. The good thing about Sencha Architect is that it helps to follow all the best practices and the code is very well organized. You can also develop all the Ext JS code using Sencha Architect, and on the server side, you can continue using the IDE you like the most (Eclipse, Aptana, Visual Studio, and others).</p><p>And <a id="id942" class="indexterm"/>Sencha Eclipse Plugin is a plugin for the Eclipse IDE that has the autocomplete feature enabled. Both Sencha Architect and Sencha Eclipse Plugin are paid tools. But you can download a trial version for testing at <a class="ulink" href="http://www.sencha.com/products/complete/">http://www.sencha.com/products/complete/</a> or <a class="ulink" href="http://www.sencha.com/products/architect/">http://www.sencha.com/products/architect/</a>.</p><p>Another great IDE to develop Sencha applications is <a id="id943" class="indexterm"/>
<strong>WebStorm</strong> (or <strong>IntelliJ IDEA</strong>). WebStorm <a id="id944" class="indexterm"/>also has the autocomplete feature (if we set it up), support for Sass and Compass (used by Ext JS for theming), and JSLint to validate the JavaScript code, among other features. It is also a paid tool, but you can download a trial version for testing at <a class="ulink" href="https://www.jetbrains.com/webstorm/">https://www.jetbrains.com/webstorm/</a>. The <a id="id945" class="indexterm"/>source of this book was written with IntelliJ IDEA.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Third-party components and plugins</h1></div></div></div><p>Although<a id="id946" class="indexterm"/> Ext JS provides great components, we usually will also want to develop our own components or maybe use other developers' components. The Ext JS community is great regarding this subject. A lot of developers share <a id="id947" class="indexterm"/>their own components, extensions, and plugins with the community. There<a id="id948" class="indexterm"/> are two main<a id="id949" class="indexterm"/> places you can find them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Sencha Market</strong>: <a class="ulink" href="https://market.sencha.com/">https://market.sencha.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>Sencha Forum</strong>: <a class="ulink" href="http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins">http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, you learned how to enable routing, and you also quickly overviewed responsible design and touch support for Ext JS applications. You learned about the importance of knowing how to debug an Ext JS application and about some tools that can help us with this task. You also learned that performance is really important and that we can do a lot more to improve the performance of our Ext JS application with the help of some free tools. We also listed where to find great plugins, extensions, and new components that we can use in our projects.</p><p>In the next chapter, we will customize the theme for our application, and we will perform the production build.</p></div></body></html>