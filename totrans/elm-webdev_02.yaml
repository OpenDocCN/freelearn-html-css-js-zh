- en: Building Your First Elm App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the second chapter. The goal of this chapter is to understand the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elm Architecture basics—working with Model, View, and Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Messages* in Elm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unidirectional data flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `beginnerProgram` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinforcing the use of HTML functions in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`If-else` expressions in Elm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Case` expressions in Elm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of Elm data structures (lists, tuples, records, sets, arrays, and dictionaries)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union types in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modulus to perform calculations in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with the Elm architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `if-else` expressions and `case` expressions in your apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a very simple *Fruit* Cou*nter* app in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a very simple *FizzBuzz* app in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's build an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss immutable data structures and the basics of
    the Elm architecture. To make things more practical, we will build a very simple
    app, which will serve our goal of reinforcing these important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elm is a functional programming language. One of the tenets of functional programming
    languages is that data structures are immutable. Once created, they cannot be
    changed. In practice, this means that functions in Elm will take in a data structure
    as its argument, and then return an entirely new data structure.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, it makes perfect sense. If all the data structures are
    immutable, how do we deal with change? More specifically, how do we deal with
    changes that Elm functions introduce on the existing data? The only obvious answer
    is to create entirely new data.
  prefs: []
  type: TYPE_NORMAL
- en: How does Elm apply this in practice?
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to build an app in the health niche. The app is a simple
    countdown app that displays only a button and a number. The app starts with the
    number 5\. The idea of the app is for a user to press a button whenever they have
    eaten a healthy snack, say, a piece of fruit. That way, a user will improve their
    healthy habits by making sure that they have eaten five pieces of fruit a day.
  prefs: []
  type: TYPE_NORMAL
- en: The Elm architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very minimum that we need to understand about the Elm architecture is that
    it is made up of four things: Model, View, Message, and Update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the architecture is usually described as being
    made up of only three things: Model, View, and Update. However, for the sake of
    clarity and easier learning, at this point of our journey into Elm, we can think
    of the Message as an equal building block of the Elm architecture. In later chapters,
    as we dive deeper into both theory and practice, we will clarify these distinctions.
    However, for the sake of having a clear mental model of all the things that are
    in play here, we will think of the Elm architecture as having four constituent
    pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Model holds our app state. The Model in our *Fruit Counter* app is very
    simple: it holds, as its one and only data structure, an integer. When we first
    run our app, the Model holds the value of 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Since it is represented in terms of data structures, and since data structures
    in Elm are immutable, our model will have to be updated as a copy of the previous
    data plus changes made to it. The model is updated whenever a function operates
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: When will a function operate on the model?
  prefs: []
  type: TYPE_NORMAL
- en: Since we are building a very simple app, the only time a function will operate
    on the model is when the user clicks the one button in our app. Clicking this
    one button will decrement the current value in the model by 1\. Since data in
    Elm is immutable, a function will have to return a new copy of the model, with
    updates taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The View can be thought of as *the way to see the Model on our screen*. The
    View is a function, and we pass the Model to it. Thus, the View takes in the Model
    as its parameter, and returns HTML, which will be rendered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think of the View is that it is *a way to allow the user to interact
    with the Model*. To use the API reference we made in the previous chapter, the
    View is sort of like a visual API for the Model. It is a way for the user to manipulate
    the Model in a structured way.
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with the View, they manipulate the Model by changing its
    state. Since our app is very simple, the only way to change the state is to press
    that one button in our app, which will decrement the current value that our model
    holds.
  prefs: []
  type: TYPE_NORMAL
- en: This one button press will make the View send a Message to the Update.
  prefs: []
  type: TYPE_NORMAL
- en: The Message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the user has interacted with the View (pressed the button), the notification
    of this action will be sent to the Update function in the form of a Message. Since
    there is only one possible action that can happen, that Message is simply: *decrement.*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in any realistic app, the Message will have to have a lot more logic,
    but for the sake of simplicity, let's leave it at *decrement.*
  prefs: []
  type: TYPE_NORMAL
- en: The Update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Update function receives the Message. Next, the Update function determines
    how to update the state of our app, that is, the Model, based on the Message received.
    Once the update is made, a new Model is created and it renders the View. The user
    then interacts with the View which results in the Message being sent again. The
    Update receives the Message and updates the Model, and the cycle continues.
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectional data flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting way of looking at our app is as flows of data. The reason to
    have this concept and use it in our discussions is because it is a helpful way
    of looking at the changing of state in our Elm app.
  prefs: []
  type: TYPE_NORMAL
- en: Since Elm is built on a lot of restrictions, it only makes sense to have this
    idea of restrictions applied to its architecture as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at what is happening in our simple app, you will notice that the
    data always moves in only one direction: From Model to View to Message to Update
    to Model. That''s what unidirectional data flow basically is.'
  prefs: []
  type: TYPE_NORMAL
- en: This concept allows us to be able to track state changes with ease, and it also
    makes it a lot less difficult to reason about these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Our app requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point of the book, we are more than ready to build our first app:'
  prefs: []
  type: TYPE_NORMAL
- en: We have an idea of how functional programming works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We understand the most basic concepts of how the Elm architecture operates (Model,
    View, Message, Update)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know what we want our app to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with this knowledge, we can now build our app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Fruit Counter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with our app skeleton. Let''s point our browser to [Ellie-app.com](http://Ellie-app.com),
    and we''ll be greeted with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will be the starting point for our app. We'll build on top
    of it by slowly adding features to it, and explaining the underlying concepts
    at the appropriate times, just when we need to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing everything we need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by updating `module Main` to expose everything, by adding two dots
    inside parentheses. We will do the same for the imported `HTML` module, since
    we want do be able to use all the available HTML functions. Specifically, we need
    access to the `h1`, `p`, and `button` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the line that reads `main : HTML msg` is an optional type annotation,
    so to demonstrate that we can work without it, we''ll comment it out by placing
    two hyphens and a space at the beginning of this line.'
  prefs: []
  type: TYPE_NORMAL
- en: Including type annotations is considered a best practice, and we have commented
    it out only to show that our app will still run without a type annotation (as
    well as to demonstrate how to add one-line comments in Elm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To preview the app at this stage, simply compile it in the Ellie-app.
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our Model is just a simple integer type.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll simply ignore what this `type alias` signifies, as it will only
    distract us from understanding fundamental concepts at the moment. We will return
    to types later on in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `View` function will receive the current model and will return the following
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml), *Why Is This a Great
    Time to Learn Elm?*, we looked at rendering some basic HTML to the screen using
    Elm's HTML functions. To reinforce that concept in light of the preceding code,
    let's quickly discuss the HTML that our `view` function will render.
  prefs: []
  type: TYPE_NORMAL
- en: The code that we are assigning to the `view` function is located to the right
    of the equals sign (Elm's assignment operator). In this code, we are running the
    `div` function.  Like all other HTML functions in Elm, the `div` function has
    two pairs of square brackets. The first pair of square brackets optionally lists
    the HTML attributes for the `div` function, and the second one lists the content
    of the actual `div`.
  prefs: []
  type: TYPE_NORMAL
- en: We have left the first pair of square brackets empty, which means we have not
    given any attributes to our `div` function. Then, inside the second pair of square
    brackets of the `div` function, we have passed in the `h1` function .
  prefs: []
  type: TYPE_NORMAL
- en: Like all other HTML functions, the `h1` function also has two pairs of square
    brackets. In the preceding example, our `h1` function has no attributes specified
    (as the first pair of brackets is empty - just like we did with the `div`, its
    parent function/element). Inside the second pair of brackets of the `h1` function,
    we call the `text` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `text` function will render a text node. The text to be output inside the
    text node is surrounded by parentheses. Inside the parentheses, we are using a
    string literal and we are concatenating to it the value of the `model`, converted
    to a string (using the `toString` function).
  prefs: []
  type: TYPE_NORMAL
- en: We've just learned about one of Elm's operators, the `++` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In Elm, `++` is the string concatenation operator, used to join together two
    separate strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will initialize our model with the value of 5, the preceding code
    for the `view` function will initially return the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `view` function is now ready at the most rudimentary level. Next, we'll
    deal with the Message section.
  prefs: []
  type: TYPE_NORMAL
- en: The Message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now look at the Message section, where we''ll declare a new type, and
    we''ll call it `Msg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier in the chapter, we will not deal with explaining types
    at this time.
  prefs: []
  type: TYPE_NORMAL
- en: The Update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to add our update. In the previous step, we have declared our special
    type of `Msg`. We''ll pass it to the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, it should be easy for you to guess what the `update` function will
    do: it will accept a `msg` and a `model`, and it will return a copy of the `model`,
    decremented by 1.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point of our *Fruit Counter* app development, all we have to do is make
    the Model, View, and Update work together, and for that, we'll use the `beginnerProgram`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the beginnerProgram function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to add the `beginnerProgram` function, which we will assign to the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main` function currently looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add our updated `main` function, which will now have the `beginnerProgram`
    function assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just call the `beginnerProgram` function. Then, we pass it
    the `model`, `view`, and `update` functions, and assign each of them a value.
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the model with the value of `5`. For the `update`, we assign it to
    the value of the `update` function. The `view` is similarly set to the value of
    the `view` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we made these changes to our `main` function, the full code of our app
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran our app at this point, everything would work, and we would get the
    following output on our screen: Fruit to eat: 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though our app is really basic, it's great that everything works and that
    we are not getting any compiler errors at this time.  However, there is one thing
    we did not do, and that is that we have not added the button, the one entry point
    to initiate the changing of our app's current state.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do add this button, feel free to look at the preceding code and think
    a bit about a perfectly stateless app. Currently, our app's model will never change,
    as the update section of our code will never be run.
  prefs: []
  type: TYPE_NORMAL
- en: Let's rectify that by adding a button.
  prefs: []
  type: TYPE_NORMAL
- en: Views, buttons, and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by simply adding a static button to our app. We''ll do that by
    updating the view function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you saved and ran the app right now, the compiler would throw the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why did we get this error? Because we haven't imported the `onClick` function.
    Let's do that now, by adding the import at Line 3 of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the beginning of our code, this is what the first three lines of
    code should look like after the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running our app now would give us a simple, rudimentary, but working app built
    with Elm!
  prefs: []
  type: TYPE_NORMAL
- en: When you click the Eat fruit button, the `view` function hits the first pair
    of square brackets on the `button` function, and it watches for the click event.
    We have provided the `onClick` function with the `Msg` to be sent once the button
    is clicked. Since there is only one possible message in our app, once the click
    event is triggered, the `view` function will send the `Decrement` message to the
    `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `update` function has received the message, it will return a new `model`,
    and the new `model` gets rendered by the `view` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an issue. If we keep clicking the button, our app will ultimately
    move into counting negative numbers, and that's just impossible. A user should
    not have negative 2 fruits left to eat.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining the Decrement message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to constrain the Decrement message, let''s begin by looking at the
    current update function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s introduce an `if-else` statement to cater for different possible
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the preceding code does not produce the desired results. Instead,
    we get this compiler message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We briefly touched upon Elm constraints in [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml),
    *Why Is This a Great Time to Learn Elm?* The preceding issue is a great example
    of Elm constraints in practice. Because of the way Elm is set up, each branch
    must return the same data type. In our case, we can either return Booleans for
    either branch of the `if-else` expression, or return numbers, but we can not have
    them mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we rectify this? To keep things simple and still use an `if-else`
    expression we started with, let''s think of a terse way to avoid type mismatch.
    Our counter value should never go under zero, so we can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding code, our `if-else` logic will always return a number. 
    The update function's message value will be incremented by 1 as long as it's greater
    than zero. Otherwise (in case it is zero), it will be increased by 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap this section up, let''s look at another way we could have written the
    main function in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we finish this section of our chapter, let''s look at the completed
    *Fruit Counter* app, as we will refer to it later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have looked at a practical implementation of a simple app, let's
    discuss some of the theoretical concepts behind it, namely values and types in
    Elm, functions in Elm, and `if` expressions. We will wrap it up with a more in-depth
    look at Elm messages.
  prefs: []
  type: TYPE_NORMAL
- en: Values, expressions, data structures, and types in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no statements in Elm. In the `if-else` example we saw earlier in this
    chapter, the structure that we used was an expression, not a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This difference is important, because it tells us something about the behavior
    of the Elm language: an expression will always return a value. In fact, everything
    in Elm is an expression, and thus everything will return a value, even without having
    to use the `return` keyword explicitly (like we have to do in JavaScript, for
    example).'
  prefs: []
  type: TYPE_NORMAL
- en: What, then, can this value be? A value is just a result of a calculation. It
    is the result of running an expression. In other words, when an expression is
    evaluated, it will result in a value. To test this out, we can have a look at
    the **Elm REPL**. To keep things simple, we will use the online elm-repl, available
    at [elmrepl.cuberoot.in](http://elmrepl.cuberoot.in).
  prefs: []
  type: TYPE_NORMAL
- en: The Elm REPL is an interpreter for the Elm language. It's important to distinguish
    between the interpreter and the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we using Elm REPL in the following examples? We are using it because
    it is a straightforward way to get information on the type of value that each
    of the expressions we give the REPL will evaluate to. In other words, we will
    give the Elm REPL a number of expressions, mostly in the form of simple values,
    and the REPL will give us back their type. We will start with expressions whose
    values will evaluate to primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primitive types in Elm include `Char`, `String`, `Bool`, and `number` (`Int`
    and `Float`).
  prefs: []
  type: TYPE_NORMAL
- en: Char and String types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s type the following inside the online elm-repl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The Elm-repl will give us back the result of running the preceding expression,
    and follow it up with the type of that value. The type of value ''a'' is a `Char`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do another one, this time with double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What we get back is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read the preceding as: Value `''''a''''` has a type of `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, when we use single quotes, we get `Chars`.
  prefs: []
  type: TYPE_NORMAL
- en: To get the type of `String` from a value, we need to surround that value in
    double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline strings are written by enclosing any number of lines in three consecutive
    double quote characters. When using REPL, each line must also end with a backslash.
    Elm REPL inserts the pipe characters automatically. The entered multiline string
    value will still evaluate to the type of `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at other primitive types in Elm.
  prefs: []
  type: TYPE_NORMAL
- en: The number type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we just type a number, we''ll get back that same number, followed with a
    colon and the `number` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we test a decimal number, we''ll get back the type of `Float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Why are some types capitalized, and some are not?
  prefs: []
  type: TYPE_NORMAL
- en: If a type is capitalized, it means it is an explicit type.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the `number` type is used for both `Ints` and `Floats`. Which one
    it will end up being (which *explicit* type it will end up being), depends on
    how that number is used.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, `number` is an implicit type, since it can end up as an explicit
    `Int` or an explicit `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get back a value of type `Int`, let''s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Capitalization is important! For example, typing `true` will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have covered the primitive types in Elm. Next, we are going to
    look at data structures. Since Elm language is statically typed, and since everything
    in Elm is an expression, it follows that whatever we put into REPL will in fact
    be an expression, with a value that will evaluate to a type. Data structures are
    part of this behavior too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data structures: lists, tuples, records, sets, arrays, and dictionaries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic data structures in Elm are lists, tuples, records, sets, arrays, and dictionaries.
    In this section, we will look at the behavior of each of these data structures,
    using Elm REPL and the Ellie-app.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list in Elm is like an array in JavaScript. For our first example, let''s
    type this value in Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get back from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, a List of numbers!
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast that with Floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL responds with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try Chars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, mixing values in Lists in Elm is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, we cannot mix types in Elm Lists. In other words, each List in Elm
    is a group of expressions that must always evaluate to the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try Strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What about an empty list?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*List a* means that this list is empty, that is, that it can hold *anything*.
    This wraps up our short overview of Lists in Elm. Next, we will look at tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Elm, a tuple is a data structure that can hold values of various types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a Tuple in Elm REPL, let''s simply put a `String` and a Boolean inside
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will respond with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A tuple can hold a maximum of nine values. Interestingly, tuples of different
    lengths are considered to be of different types. For example, let''s make a List
    that holds two tuples, using Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression will evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What REPL tells us is that the value we put in is a `List` of two tuples, holding
    values of `Char` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to vary the number of Chars in the second tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code in the REPL will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Elm looks at the expression we gave it, and comes back with the Type Mismatch
    error. Indeed, for two tuples to be considered to be of the same type, they have
    to hold the same number of values, and those values *also* need to be of the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding working example, we added two tuples of two Chars to a `List`,
    and Elm REPL returned ` List ( Char, Char )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum number of values a tuple can hold in Elm is 9\. If you try to add
    10 or more values to a tuple, Elm will throw an error. Let''s try this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'What we get back is the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the chapters that follow, we will get to know tuples in much greater depth.
    For now, let''s just mention a common use case: since tuples as a data structure
    can hold various values, they are useful as a way to store results of calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records in Elm use curly braces, and a label for each value must be provided.
    Records can also hold multiple values. For example, we can type the following
    record into Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We will use records a lot in our Elm programs, as records allow us to model
    the data in a wide variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used a record in our code in this chapter, in the *Adding the
    beginnerProgram function* section. Let''s recall the code we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To test out the code in REPL, we will only have to use the record, without
    all the fluff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'REPL will respond with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will follow up the preceding error with a similar error saying that
    the `''update''` variable cannot be found either. To rectify this, as an exercise,
    we can give values to the variables used in our record, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have assigned values of type `String` to the `view` and `update` variables
    in the Elm REPL. Then we entered the record, and the REPL returned types for each
    of the variables used in the record. Thus, in the preceding example, the `model`
    is of type `number`, the `update` is of type `String`, and the `view` is also
    of type `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll look at sets, arrays, and dictionaries, which have to be imported,
    although they too are built into Elm.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sets are collections of unique values. Their uniqueness is guaranteed by the
    Elm programming language. We can instantiate sets as empty sets or use the `fromList`
    function. Creating an empty set is easy: `set = Set.empty`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the other way of creating sets in Elm, by pointing our browser
    to: [ellie-app.com/new](http://ellie-app.com/new).
  prefs: []
  type: TYPE_NORMAL
- en: 'The page that opens already has some Elm code in it. Let''s adjust that code
    so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did in the preceding code was, after importing `Set` (to the variable
    we named `set`), we assigned the returned value from the evaluated expression:
    `Set.fromList [1,1,1,2]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we gave the `set ` variable to our `main` function, to render it out as
    a text node. Of course, before it could be rendered out, we had to convert it
    to a `String`.  After pressing the Compile button in the Ellie-app, we should
    see the following result: `Set.fromList [1,2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are useful when we are trying to find differences between data structures.
    Next, we'll look at arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays in Elm are zero-based, just like they are in JavaScript. With arrays,
    we can work with elements based on their index. Like sets, arrays can be created
    using the `fromList` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can create an empty array like this: `array = Array.empty`.
    Still in the Ellie-app, let''s make a slight change to our code to test out arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a slight twist—we grouped the concatenation of
    two arrays and a space, all converted to `Strings`, and then ran the `text` function
    on them, finally passing the value returned from the evaluation of the expression
    to the main function.
  prefs: []
  type: TYPE_NORMAL
- en: The compiled code will display the following result: `Array.fromList [1,1,1,2]
    Just 1`. For now, let's just ignore what this result means, as we'll get back
    to it later in the book. Next, we'll look at dictionaries in Elm.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionaries are also created using the `fromList` function. Let''s revisit
    the Ellie-app, with our code changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After compilation, the Ellie-app will return this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`Dict` is the data structure used to store pairs of keys and values. Keys must
    be unique. To learn more about this data structure, visit the following URL: [http://package.elm-lang.org/packages/elm-lang/core/latest/Dict](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how types work for functions and `if` expressions in the
    Elm language.
  prefs: []
  type: TYPE_NORMAL
- en: Functions, if expressions, and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new function in Elm REPL. We''ll call our function `multiplyBy5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line says that our `multiplyBy5` function has the type of `number
    -> number`. Let''s see what type will get returned from a function that works
    with Strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, the `++` operator is the concat operator in Elm; it will
    join two `Strings` together. Thus, expectedly, Elm REPL will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding function is of type `String -> String`.
  prefs: []
  type: TYPE_NORMAL
- en: But, what is this `String -> String`? And, along the same lines, what is the
    `Int -> Int` from the previous example? `String -> String` simply means that the
    function expects a `String` as its argument, and will also return a `String`.
    For the `Int -> Int` example, the function expects a value of type `Int` and will
    also return a value of type `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to take a look at the basics of types in `if` expressions in Elm.
    Consider the following snippet of code and the response REPL gave it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are running an `if` expression using the variable
    `time` (which we assign the value of `24`).  Then, we are running our comparison.
    Note that if expressions should actually be referred to as `if-else` expressions,
    as `if` expressions must have an else, otherwise they won't work in Elm.  Both
    the `if` and the `else` branch must be of the same type. That's why in the preceding
    example we are making sure that either result we get is of type `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Elm messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started off this chapter by looking at the Elm arhitecture: Model, View,
    and Update. We also mentioned another important ingredient: Messages, **a way
    for Views to communicate with Updates**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We used a very simple example app, *Fruit Counter*. The app was simple indeed:
    the only message our view could ever send to the update function was `Decrement`.
    The simplicity of the app we made was a great way for us to understand the architecture
    without having to introduce too many concepts that would get in the way of learning.'
  prefs: []
  type: TYPE_NORMAL
- en: However, now that we have a rudimentary understanding of all the moving parts
    and how they fit together, we can talk about another level of complexity related
    to messages in the Elm arhitecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we can look at a finished example straight from the official documentation.
    This will serve two purposes: first, it will get us in the habit of referring
    to the excellent official docs as often as possible, and second, it will give
    us a benchmark that we will initially look up to, and during the course of the
    book, leave behind as we learn more advanced concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, open the documentation for the buttons example at: [https://guide.elm-lang.org/architecture/user_input/buttons.HTML](https://guide.elm-lang.org/architecture/user_input/buttons.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, visit the Ellie online editor at [https://ellie-app.com/new](https://ellie-app.com/new),
    and paste in the code from the buttons example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After pasting in the code, click the Compile button in the right-hand pane and
    the app will compile and run there. The app itself is very similar to our *Fruit
    Counter*, only slightly more advanced. Let's compare these differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Fruit Counter*, we had the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Buttons app, the message is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is the comment preceding the code. Initially, we used
    `MESSAGE` as the comment text. However, in the Buttons example, they are using
    `UPDATE` in their inline comment. The reason: conventionally, the Elm architecture
    is considered to consist only of Model, View, and Update. We used Message as a
    separate part of the architecture only to help understand it easier. The most
    important point of that understanding is: **the View sends Messages to the Update
    function**. Conceptually, this is the same in both examples. The only difference
    is that now the *Message* is defined in the *Update* section of our app, as it
    should be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing to note is that our message only had the value of `Decrement`.
    It *could only be* a `Decrement` message. In the Buttons app, we have two options:
    the Message can be *either* a `Decrement` *or* an `Increment`.'
  prefs: []
  type: TYPE_NORMAL
- en: What's with the `type` keyword, and the pipe character, then? It has to do with
    something known as **union types** (also known as **algebraic data types** or
    **tagged unions**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Elm, a union type is simply a custom type that we can come up with on the
    fly. In our *Fruit Counter* app, our `Msg` union type has only one value: `Decrement`.
    In the Buttons app, the `Msg` union type can have either of the two values: `Increment`
    or `Decrement`. To differentiate clearly between possible values in a union type,
    we use the pipe character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make another custom union type in the Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: To create a union type, we begin with the `type` keyword. Next, we provide the
    actual type, `Vehicle`. We created a custom type on the fly, and named it `Vehicle`!
    To the right of the assignment operator  (the `=` sign), we provide the values
    that the `Vehicle` union type can have. **These values are called type constructors**,
    as you can use them to **construct** new instances of `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new instance of `Vehicle` in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We have just constructed a new instance of the `Vehicle` type. As we can see,
    the REPL responds with this information—the value is `Helicopter`, and its type
    is `Vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is helpful to explain the same concept in a couple of different
    ways. Another way of looking at union types is that they are a way for us to describe
    constructor functions, that is, to define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` function, we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means that to make a `Msg`, either the `Increment` function
    or the `Decrement` function needs to be called.
  prefs: []
  type: TYPE_NORMAL
- en: The theoretical underpinnings of union types are rooted in mathematical logic,
    namely the set theory, which is basically the study of collections of things.
    Thus, we can look at a union type as a combination of any number of collections
    of things. Both union types and the set theory can get quite abstract, but at
    this point in our learning, suffice it to say that union types are a way to organize
    messages in Elm apps.
  prefs: []
  type: TYPE_NORMAL
- en: Functions, pattern matching, and case expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to build a simple app and learn important theory
    behind it. We expanded on this goal by comparing our own app with the one from
    the official docs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the update function of the Buttons App and
    take it apart in order to have complete understanding of what it does and how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: This is important, because once we understand how the `update` function works
    in the Buttons app, we will be able confidently to implement a similar solution
    and improve our *Fruit Counter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by inspecting the `update` function in the Buttons app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We see a new keyword here: `case`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the way that the `case` syntax works is as follows—a variable has
    a certain value. Based on its value, a certain block of code will execute. When
    the value is different, the block of code to execute will be different as well.
    Finally, at the end of a `case` expression, there is a block of code that will
    execute for all the values that were not already specified in the `case` expression.
    In other words, for any unspecified scenario, there is a case block at the bottom
    to take care of it. This `case` block is called the *wildcard* and it's marked
    with the underscore character, `_`. As we can see in the preceding example, there
    are situations where the *wildcard* case does not need to be added, because we
    have *already covered* all the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Elm `case` expressions are evaluated via pattern matching, that is, by verifying
    whether a `case` conforms to a pattern. *If expressions* and *case expressions*
    are quite similar.  One major difference is that `case` expressions *match patterns*,
    and `if` expressions *check for true conditions* as ways to determine which code
    blocks to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the syntax of `case` expressions, we can see that they start with
    the `case` keyword, followed by the name of the case expression (in our example,
    `msg`). The name is completely arbitrary; instead of `msg`, we could have used
    anything else. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, the *first parameter* of the `update`
    function and the *name of the case expression* must be the same. To avoid confusion,
    it's best to stick with `msg ` as the first parameter here, as that is the norm,
    and you'll see it used that way in most Elm programs.
  prefs: []
  type: TYPE_NORMAL
- en: So, after the `case` keyword, and the name of the case expression, we have another
    keyword, `of`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we list our cases. The structure of the code is always the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the first case, we can see that it''s written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the pattern to match is `Increment`, and the
    expression to evaluate is `model + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Fruit Counter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on everything we have learned so far, let''s improve the *Fruit Counter*
    app. Here is the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s highlight the improvements we made to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: We added another button to our `view` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added a new message, `Reset`, to be sent when the new button is clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added the `Reset` constructor function to our `Msg` union type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `update` function, we gave our case expression the name of `msg`, and
    we also gave it two patterns to match: `Decrement` and `Reset`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `Decrement` pattern gets matched, an `if` expression will be evaluated
    (to determine whether the model should be decreased by one or whether its value
    should be `5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `Reset` pattern gets matched, an expression of `5` will be evaluated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding explanation, an effort was made to describe all the updates
    in accordance with the concepts we learned in this chapter. It is important to
    understand the preceding explanation as it is the foundation on which we will
    build more complex apps in chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple FizzBuzz app in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FizzBuzz is a word game for kids. The purpose is to teach math, namely division.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game is simple: each player calls out a number, starting from 1\. If a
    number can be divided by three, a player needs to call out *Fizz* instead of a
    number. Furthermore, if a number can be divided by five, a player needs to call
    out *Buzz* instead of a number.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if a number can be divided by both 3 and 5, a player needs to call
    out *FizzBuzz*.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a well-known game, and a relatively simple problem, it is a great
    way to test the level of knowledge of a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In order to go about solving this problem, we will introduce a new operator,
    the modulus operator, `%`. This operator returns the division remainder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way it works can be best described by an example. Open up the online Elm
    REPL, and run the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is: if we divide `12` by `10`, we will get `1`, and what will
    remain is `2`. Since `2` is less then `10`, it will not be divided, as the modulus
    in our example will only divide in increments of `10`, and return the remainder.'
  prefs: []
  type: TYPE_NORMAL
- en: That's why we said that the modulus operator returns the remainder of a division
    (that is, whatever is on the right side of the modulus operator determines the
    size of increments).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get this back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we will get the exact same result if we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression will evaluate to `1 : Int` because the size of the
    increments that will be calculated is `9` in the preceding example. Since *9 *
    2 = 18*, the remainder of the division is 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What will happen if we divide the number by itself? Let''s try number `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We get back the value `0`, of type `Int`. We can do the same for `5` and `15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Again, we get back zero, of type `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean in practice? It means that we can use an `if-else` expression
    to check for all the numbers that do not have a remainder when divided by 3\.
    For all the numbers that satisfy that condition, we will return *Fizz*. We will
    apply a similar approach for numbers 5 and 15, as dictated by the rules of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough information for us to create our simple *FizzBuzz* app. Navigate
    your browser to ;[https://ellie-app.com/new](https://ellie-app.com/new) and type
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have enough knowledge fully to understand the preceding code
    with ease. Looking at the preceding code, one of the important concepts to be
    reminded of is the principle that we need to obey when working with `if` expressions:
    they should always return the same type of value. That is why we are passing the
    value to the `toString` function at the very bottom of our `if` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reminder of piping syntax (discussed in [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml),
    *Why Is This a Great Time to Learn Elm?*), here is another way we could have written
    the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `|>` is called the **forward function application operator**.
  prefs: []
  type: TYPE_NORMAL
- en: We have achieved our goal of making a working *FizzBuzz* app in Elm. In the
    chapters that follow, we will look at ways of making improvements to our simple
    *FizzBuzz* app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered a number of important topics, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Elm syntax: values, types, data structures, `if-else` expressions, `case` expressions,
    and some operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TEA: The Elm architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of unidirectional data flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Elm REPL and the Ellie-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also built two working apps, which, although simple, have shown the practical
    application of the theoretical concepts we covered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will make our own personal portfolio in Elm.
  prefs: []
  type: TYPE_NORMAL
