- en: Building Your First Elm App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the second chapter. The goal of this chapter is to understand the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elm Architecture basics—working with Model, View, and Update
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Messages* in Elm'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unidirectional data flows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `beginnerProgram` function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinforcing the use of HTML functions in Elm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`If-else` expressions in Elm'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Case` expressions in Elm'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of Elm data structures (lists, tuples, records, sets, arrays, and dictionaries)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union types in Elm
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modulus to perform calculations in Elm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following things:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Work with the Elm architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `if-else` expressions and `case` expressions in your apps
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a very simple *Fruit* Cou*nter* app in Elm
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a very simple *FizzBuzz* app in Elm
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's build an app
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss immutable data structures and the basics of
    the Elm architecture. To make things more practical, we will build a very simple
    app, which will serve our goal of reinforcing these important concepts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elm is a functional programming language. One of the tenets of functional programming
    languages is that data structures are immutable. Once created, they cannot be
    changed. In practice, this means that functions in Elm will take in a data structure
    as its argument, and then return an entirely new data structure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, it makes perfect sense. If all the data structures are
    immutable, how do we deal with change? More specifically, how do we deal with
    changes that Elm functions introduce on the existing data? The only obvious answer
    is to create entirely new data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How does Elm apply this in practice?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to build an app in the health niche. The app is a simple
    countdown app that displays only a button and a number. The app starts with the
    number 5\. The idea of the app is for a user to press a button whenever they have
    eaten a healthy snack, say, a piece of fruit. That way, a user will improve their
    healthy habits by making sure that they have eaten five pieces of fruit a day.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The Elm architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very minimum that we need to understand about the Elm architecture is that
    it is made up of four things: Model, View, Message, and Update.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the architecture is usually described as being
    made up of only three things: Model, View, and Update. However, for the sake of
    clarity and easier learning, at this point of our journey into Elm, we can think
    of the Message as an equal building block of the Elm architecture. In later chapters,
    as we dive deeper into both theory and practice, we will clarify these distinctions.
    However, for the sake of having a clear mental model of all the things that are
    in play here, we will think of the Elm architecture as having four constituent
    pieces.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Model holds our app state. The Model in our *Fruit Counter* app is very
    simple: it holds, as its one and only data structure, an integer. When we first
    run our app, the Model holds the value of 5.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模型持有我们的应用程序状态。在我们的*水果计数器*应用程序中，模型非常简单：它只持有作为其唯一数据结构的一个整数。当我们首次运行我们的应用程序时，模型持有值为5。
- en: Since it is represented in terms of data structures, and since data structures
    in Elm are immutable, our model will have to be updated as a copy of the previous
    data plus changes made to it. The model is updated whenever a function operates
    on it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是以数据结构的形式表示的，并且由于Elm中的数据结构是不可变的，因此我们的模型必须作为前一个数据的副本加上对其所做的更改来更新。模型在函数对其操作时更新。
- en: When will a function operate on the model?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数何时会操作模型？
- en: Since we are building a very simple app, the only time a function will operate
    on the model is when the user clicks the one button in our app. Clicking this
    one button will decrement the current value in the model by 1\. Since data in
    Elm is immutable, a function will have to return a new copy of the model, with
    updates taken into account.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个非常简单的应用程序，函数将仅在用户点击我们应用程序中的一个按钮时操作模型。点击此按钮将使模型中的当前值递减1。由于Elm中的数据是不可变的，函数必须返回一个包含更新的新模型副本。
- en: The View
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: The View can be thought of as *the way to see the Model on our screen*. The
    View is a function, and we pass the Model to it. Thus, the View takes in the Model
    as its parameter, and returns HTML, which will be rendered in the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以被视为*在屏幕上查看模型的方式*。视图是一个函数，我们将其传递给模型。因此，视图将模型作为其参数，并返回HTML，这些HTML将在浏览器中渲染。
- en: Another way to think of the View is that it is *a way to allow the user to interact
    with the Model*. To use the API reference we made in the previous chapter, the
    View is sort of like a visual API for the Model. It is a way for the user to manipulate
    the Model in a structured way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考视图的方式是，它*是一种允许用户与模型交互的方式*。根据我们在上一章中制作的API参考，视图可以看作是模型的一个视觉API。它是用户以结构化方式操作模型的一种方式。
- en: When a user interacts with the View, they manipulate the Model by changing its
    state. Since our app is very simple, the only way to change the state is to press
    that one button in our app, which will decrement the current value that our model
    holds.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与视图交互时，他们会通过改变其状态来操作模型。由于我们的应用程序非常简单，改变状态的唯一方式是按下我们应用程序中的一个按钮，这将递减模型当前持有的值。
- en: This one button press will make the View send a Message to the Update.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次按钮点击将使视图向更新发送一个消息。
- en: The Message
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'After the user has interacted with the View (pressed the button), the notification
    of this action will be sent to the Update function in the form of a Message. Since
    there is only one possible action that can happen, that Message is simply: *decrement.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户与视图交互（按下按钮）之后，此操作的通告将以消息的形式发送到更新函数。由于只有一个可能发生的行为，该消息很简单：*递减*。
- en: Of course, in any realistic app, the Message will have to have a lot more logic,
    but for the sake of simplicity, let's leave it at *decrement.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在任何现实的应用中，消息将需要更多的逻辑，但为了简单起见，让我们将其保留为*递减*。
- en: The Update
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: The Update function receives the Message. Next, the Update function determines
    how to update the state of our app, that is, the Model, based on the Message received.
    Once the update is made, a new Model is created and it renders the View. The user
    then interacts with the View which results in the Message being sent again. The
    Update receives the Message and updates the Model, and the cycle continues.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数接收消息。接下来，更新函数根据接收到的消息确定如何更新我们应用程序的状态，即模型。一旦更新完成，就会创建一个新的模型并渲染视图。然后用户与视图交互，这会导致再次发送消息。更新接收消息并更新模型，然后循环继续。
- en: Unidirectional data flows
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向数据流
- en: An interesting way of looking at our app is as flows of data. The reason to
    have this concept and use it in our discussions is because it is a helpful way
    of looking at the changing of state in our Elm app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以数据流的方式看待我们的应用程序是一种有趣的方法。我们之所以有这个概念并在我们的讨论中使用它，是因为它是一种帮助我们观察Elm应用程序状态变化的有用方式。
- en: Since Elm is built on a lot of restrictions, it only makes sense to have this
    idea of restrictions applied to its architecture as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Elm建立在许多限制之上，因此将其架构也应用于这种限制性的理念是有意义的。
- en: 'If you look at what is happening in our simple app, you will notice that the
    data always moves in only one direction: From Model to View to Message to Update
    to Model. That''s what unidirectional data flow basically is.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看我们的简单应用中正在发生的事情，你会注意到数据总是单向移动：从模型到视图到消息到更新到模型。这就是单向数据流的基本原理。
- en: This concept allows us to be able to track state changes with ease, and it also
    makes it a lot less difficult to reason about these changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念使我们能够轻松跟踪状态变化，同时也使得对这些变化的推理变得容易得多。
- en: Our app requirements
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用需求
- en: 'At this point of the book, we are more than ready to build our first app:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们已准备好构建我们的第一个应用：
- en: We have an idea of how functional programming works
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对函数式编程的工作方式有一个概念
- en: We understand the most basic concepts of how the Elm architecture operates (Model,
    View, Message, Update)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们理解了Elm架构运作的最基本概念（模型、视图、消息、更新）
- en: We know what we want our app to do
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道我们想要我们的应用做什么
- en: Armed with this knowledge, we can now build our app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们现在可以构建我们的应用。
- en: Building the Fruit Counter app
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建水果计数器应用
- en: 'Let''s begin with our app skeleton. Let''s point our browser to [Ellie-app.com](http://Ellie-app.com),
    and we''ll be greeted with this code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的应用骨架开始。让我们将浏览器指向 [Ellie-app.com](http://Ellie-app.com)，我们将看到以下代码：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will be the starting point for our app. We'll build on top
    of it by slowly adding features to it, and explaining the underlying concepts
    at the appropriate times, just when we need to understand them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将是我们的应用起点。我们将通过逐渐添加功能来构建它，并在适当的时候解释底层概念，即当我们需要理解它们的时候。
- en: Exposing everything we need
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示我们所需要的一切
- en: Let's begin by updating `module Main` to expose everything, by adding two dots
    inside parentheses. We will do the same for the imported `HTML` module, since
    we want do be able to use all the available HTML functions. Specifically, we need
    access to the `h1`, `p`, and `button` functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新`module Main`开始，通过在括号内添加两个点来暴露一切，我们将对导入的`HTML`模块做同样的事情，因为我们想要能够使用所有可用的HTML函数。具体来说，我们需要访问`h1`、`p`和`button`函数。
- en: 'Next, the line that reads `main : HTML msg` is an optional type annotation,
    so to demonstrate that we can work without it, we''ll comment it out by placing
    two hyphens and a space at the beginning of this line.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，读取为`main : HTML msg`的行是一个可选的类型注解，为了演示我们可以没有它工作，我们将通过在行首放置两个连字符和一个空格来注释掉它。'
- en: Including type annotations is considered a best practice, and we have commented
    it out only to show that our app will still run without a type annotation (as
    well as to demonstrate how to add one-line comments in Elm).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包含类型注解被认为是最佳实践，我们只是将其注释掉以显示我们的应用即使没有类型注解也可以运行（以及演示如何在Elm中添加单行注释）。
- en: 'Our app now looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在看起来是这样的：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To preview the app at this stage, simply compile it in the Ellie-app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要预览这个阶段的app，只需在Ellie-app中编译它。
- en: The Model
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Let''s add our model:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的模型：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our Model is just a simple integer type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型只是一个简单的整数类型。
- en: For now, we'll simply ignore what this `type alias` signifies, as it will only
    distract us from understanding fundamental concepts at the moment. We will return
    to types later on in the book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简单地忽略这个`type alias`的含义，因为它只会让我们在理解基本概念时分心。我们将在本书的后面部分回到类型。
- en: The View
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'Our `View` function will receive the current model and will return the following
    HTML:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`View`函数将接收当前模型并将返回以下HTML：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml), *Why Is This a Great
    Time to Learn Elm?*, we looked at rendering some basic HTML to the screen using
    Elm's HTML functions. To reinforce that concept in light of the preceding code,
    let's quickly discuss the HTML that our `view` function will render.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml)，*为什么现在是学习Elm的绝佳时机？*，我们探讨了使用Elm的HTML函数将一些基本的HTML渲染到屏幕上的情况。鉴于前面的代码，让我们快速讨论`view`函数将要渲染的HTML。
- en: The code that we are assigning to the `view` function is located to the right
    of the equals sign (Elm's assignment operator). In this code, we are running the
    `div` function.  Like all other HTML functions in Elm, the `div` function has
    two pairs of square brackets. The first pair of square brackets optionally lists
    the HTML attributes for the `div` function, and the second one lists the content
    of the actual `div`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给 `view` 函数的代码位于等号右侧（Elm 的赋值操作符）。在这段代码中，我们正在运行 `div` 函数。像 Elm 中的所有其他 HTML
    函数一样，`div` 函数有两个方括号对。第一对方括号可选地列出 `div` 函数的 HTML 属性，第二对方括号列出实际的 `div` 内容。
- en: We have left the first pair of square brackets empty, which means we have not
    given any attributes to our `div` function. Then, inside the second pair of square
    brackets of the `div` function, we have passed in the `h1` function .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留出了第一对方括号为空，这意味着我们没有给 `div` 函数指定任何属性。然后，在 `div` 函数的第二对方括号内，我们传递了 `h1` 函数。
- en: Like all other HTML functions, the `h1` function also has two pairs of square
    brackets. In the preceding example, our `h1` function has no attributes specified
    (as the first pair of brackets is empty - just like we did with the `div`, its
    parent function/element). Inside the second pair of brackets of the `h1` function,
    we call the `text` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有其他 HTML 函数一样，`h1` 函数也有两个方括号对。在上面的例子中，我们的 `h1` 函数没有指定任何属性（因为第一对方括号是空的——就像我们在
    `div` 中做的那样，它的父函数/元素）。在 `h1` 函数的第二对方括号内，我们调用 `text` 函数。
- en: The `text` function will render a text node. The text to be output inside the
    text node is surrounded by parentheses. Inside the parentheses, we are using a
    string literal and we are concatenating to it the value of the `model`, converted
    to a string (using the `toString` function).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 函数将渲染一个文本节点。要输出到文本节点中的文本被括号包围。在括号内，我们使用一个字符串字面量，并将其与 `model` 的值（使用 `toString`
    函数转换为字符串）连接起来。'
- en: We've just learned about one of Elm's operators, the `++` operator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了 Elm 的一个操作符，即 `++` 操作符。
- en: In Elm, `++` is the string concatenation operator, used to join together two
    separate strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Elm 中，`++` 是字符串连接操作符，用于将两个独立的字符串连接在一起。
- en: 'Since we will initialize our model with the value of 5, the preceding code
    for the `view` function will initially return the following HTML code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将模型初始化为 5 的值，因此 `view` 函数的前置代码最初将返回以下 HTML 代码：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `view` function is now ready at the most rudimentary level. Next, we'll
    deal with the Message section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点函数现在在最低级别上已经准备好了。接下来，我们将处理消息部分。
- en: The Message
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'Let''s now look at the Message section, where we''ll declare a new type, and
    we''ll call it `Msg`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看消息部分，我们将声明一个新的类型，我们将其称为 `Msg`：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As mentioned earlier in the chapter, we will not deal with explaining types
    at this time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我们不会在此处解释类型。
- en: The Update
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'It''s time to add our update. In the previous step, we have declared our special
    type of `Msg`. We''ll pass it to the `update` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加我们的更新了。在上一个步骤中，我们已声明我们的特殊类型 `Msg`。我们将将其传递给 `update` 函数：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By now, it should be easy for you to guess what the `update` function will
    do: it will accept a `msg` and a `model`, and it will return a copy of the `model`,
    decremented by 1.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该很容易猜到 `update` 函数将做什么：它将接受一个 `msg` 和一个 `model`，并将返回一个 `model` 的副本，其值减
    1。
- en: At this point of our *Fruit Counter* app development, all we have to do is make
    the Model, View, and Update work together, and for that, we'll use the `beginnerProgram`
    function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 *Fruit Counter* 应用程序开发的这个阶段，我们只需要让模型（Model）、视图（View）和更新（Update）协同工作，为此，我们将使用
    `beginnerProgram` 函数。
- en: Adding the beginnerProgram function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 beginnerProgram 函数
- en: It's time to add the `beginnerProgram` function, which we will assign to the `main` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加 `beginnerProgram` 函数了，我们将将其分配给 `main` 函数。
- en: 'Our `main` function currently looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 `main` 函数看起来是这样的：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s add our updated `main` function, which will now have the `beginnerProgram`
    function assigned to it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的更新后的 `main` 函数，现在它将分配给 `beginnerProgram` 函数：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we just call the `beginnerProgram` function. Then, we pass it
    the `model`, `view`, and `update` functions, and assign each of them a value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是调用了 `beginnerProgram` 函数。然后，我们传递 `model`、`view` 和 `update` 函数，并为每个函数分配一个值。
- en: We initialize the model with the value of `5`. For the `update`, we assign it to
    the value of the `update` function. The `view` is similarly set to the value of
    the `view` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化模型为`5`的值。对于`update`，我们将其赋值给`update`函数的值。`view`同样设置为`view`函数的值。
- en: 'After we made these changes to our `main` function, the full code of our app
    now looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`main`函数做出这些更改之后，我们应用的完整代码现在看起来是这样的：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we ran our app at this point, everything would work, and we would get the
    following output on our screen: Fruit to eat: 5.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用，一切都会正常工作，屏幕上会出现以下输出：要吃的水果：5。
- en: Even though our app is really basic, it's great that everything works and that
    we are not getting any compiler errors at this time.  However, there is one thing
    we did not do, and that is that we have not added the button, the one entry point
    to initiate the changing of our app's current state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用非常基础，但一切正常，我们没有遇到任何编译器错误，这真是太好了。然而，我们还没有做的一件事是，我们没有添加按钮，这是启动我们应用当前状态改变的一个入口点。
- en: Before we do add this button, feel free to look at the preceding code and think
    a bit about a perfectly stateless app. Currently, our app's model will never change,
    as the update section of our code will never be run.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加这个按钮之前，请随意查看前面的代码，并稍微思考一下一个完全无状态的应用。目前，我们的应用模型永远不会改变，因为我们的代码中的更新部分永远不会被执行。
- en: Let's rectify that by adding a button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个按钮来纠正这个问题。
- en: Views, buttons, and events
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图、按钮和事件
- en: 'Let''s begin by simply adding a static button to our app. We''ll do that by
    updating the view function with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单地给我们的应用添加一个静态按钮开始。我们将通过更新视图函数来实现这一点，以下是相应的代码：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you saved and ran the app right now, the compiler would throw the following
    error:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在保存并运行应用，编译器会抛出以下错误：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why did we get this error? Because we haven't imported the `onClick` function.
    Let's do that now, by adding the import at Line 3 of our app.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会得到这个错误？因为我们还没有导入`onClick`函数。现在让我们通过在应用的第3行添加导入语句来解决这个问题。
- en: 'Looking at the beginning of our code, this is what the first three lines of
    code should look like after the update:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们代码的开头，更新后的前三条代码应该如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running our app now would give us a simple, rudimentary, but working app built
    with Elm!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的应用会给我们一个简单、基础但功能齐全的应用，它是用Elm构建的！
- en: When you click the Eat fruit button, the `view` function hits the first pair
    of square brackets on the `button` function, and it watches for the click event.
    We have provided the `onClick` function with the `Msg` to be sent once the button
    is clicked. Since there is only one possible message in our app, once the click
    event is triggered, the `view` function will send the `Decrement` message to the
    `update` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“吃水果”按钮时，`view`函数会调用`button`函数的第一对方括号，并监听点击事件。我们为`onClick`函数提供了在按钮点击时发送的`Msg`。由于我们的应用中只有一个可能的消息，一旦点击事件被触发，`view`函数将向`update`函数发送`Decrement`消息。
- en: Once the `update` function has received the message, it will return a new `model`,
    and the new `model` gets rendered by the `view` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`update`函数收到消息，它将返回一个新的`model`，新的`model`将被`view`函数渲染。
- en: However, there is an issue. If we keep clicking the button, our app will ultimately
    move into counting negative numbers, and that's just impossible. A user should
    not have negative 2 fruits left to eat.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题。如果我们继续点击按钮，我们的应用最终会进入计数负数的状态，这是不可能的。用户不应该剩下负2个要吃的水果。
- en: In the following section, we'll fix this issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将修复这个问题。
- en: Constraining the Decrement message
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制减少消息
- en: 'In order to constrain the Decrement message, let''s begin by looking at the
    current update function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制减少消息，让我们首先看看当前的更新函数：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s introduce an `if-else` statement to cater for different possible
    scenarios:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引入一个`if-else`语句来应对不同的可能情况：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unfortunately, the preceding code does not produce the desired results. Instead,
    we get this compiler message:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的代码并没有产生预期的结果。相反，我们得到了以下编译器消息：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We briefly touched upon Elm constraints in [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml),
    *Why Is This a Great Time to Learn Elm?* The preceding issue is a great example
    of Elm constraints in practice. Because of the way Elm is set up, each branch
    must return the same data type. In our case, we can either return Booleans for
    either branch of the `if-else` expression, or return numbers, but we can not have
    them mixed up.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml) *为什么现在是学习 Elm 的好时机？*
    中简要提到了 Elm 的约束。前面的问题是一个 Elm 约束在实践中的绝佳例子。由于 Elm 的设置方式，每个分支都必须返回相同的数据类型。在我们的情况下，我们可以为
    `if-else` 表达式的任一分支返回布尔值，或者返回数字，但不能混合使用。
- en: 'So, how do we rectify this? To keep things simple and still use an `if-else`
    expression we started with, let''s think of a terse way to avoid type mismatch.
    Our counter value should never go under zero, so we can simply do this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何纠正这个问题？为了使事情简单并仍然使用我们最初开始的 `if-else` 表达式，让我们考虑一种简洁的方式来避免类型不匹配。计数器的值永远不会低于零，所以我们只需这样做：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the preceding code, our `if-else` logic will always return a number. 
    The update function's message value will be incremented by 1 as long as it's greater
    than zero. Otherwise (in case it is zero), it will be increased by 5.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们的 `if-else` 逻辑将始终返回一个数字。更新函数的消息值只要大于零就会增加 1。否则（如果它是零），它将增加 5。
- en: 'To wrap this section up, let''s look at another way we could have written the
    main function in our code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这一部分，让我们看看我们还可以如何编写我们的代码中的主函数：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we finish this section of our chapter, let''s look at the completed
    *Fruit Counter* app, as we will refer to it later in the chapter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章的这一部分之前，让我们看看完成的 *Fruit Counter* 应用程序，因为我们将在本章后面提到它：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have looked at a practical implementation of a simple app, let's
    discuss some of the theoretical concepts behind it, namely values and types in
    Elm, functions in Elm, and `if` expressions. We will wrap it up with a more in-depth
    look at Elm messages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个简单应用程序的实际实现，让我们讨论一些背后的理论概念，即 Elm 中的值和类型、函数以及 `if` 表达式。我们将通过更深入地研究
    Elm 消息来结束讨论。
- en: Values, expressions, data structures, and types in Elm
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 中的值、表达式、数据结构和类型
- en: There are no statements in Elm. In the `if-else` example we saw earlier in this
    chapter, the structure that we used was an expression, not a statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中没有语句。在我们本章前面看到的 `if-else` 示例中，我们使用的是表达式，而不是语句。
- en: 'This difference is important, because it tells us something about the behavior
    of the Elm language: an expression will always return a value. In fact, everything
    in Elm is an expression, and thus everything will return a value, even without having
    to use the `return` keyword explicitly (like we have to do in JavaScript, for
    example).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异很重要，因为它告诉我们关于 Elm 语言行为的一些信息：表达式总是会返回一个值。实际上，Elm 中的每件事都是一个表达式，因此每件事都会返回一个值，甚至不需要显式地使用
    `return` 关键字（例如，在 JavaScript 中我们必须这样做）。
- en: What, then, can this value be? A value is just a result of a calculation. It
    is the result of running an expression. In other words, when an expression is
    evaluated, it will result in a value. To test this out, we can have a look at
    the **Elm REPL**. To keep things simple, we will use the online elm-repl, available
    at [elmrepl.cuberoot.in](http://elmrepl.cuberoot.in).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个值可以是什么？值只是计算的结果。它是运行表达式的结果。换句话说，当表达式被评估时，它将产生一个值。为了测试这一点，我们可以看看 **Elm REPL**。为了使事情简单，我们将使用可在线访问的
    elm-repl，网址为 [elmrepl.cuberoot.in](http://elmrepl.cuberoot.in)。
- en: The Elm REPL is an interpreter for the Elm language. It's important to distinguish
    between the interpreter and the compiler.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Elm REPL 是 Elm 语言的解释器。区分解释器和编译器很重要。
- en: Why are we using Elm REPL in the following examples? We are using it because
    it is a straightforward way to get information on the type of value that each
    of the expressions we give the REPL will evaluate to. In other words, we will
    give the Elm REPL a number of expressions, mostly in the form of simple values,
    and the REPL will give us back their type. We will start with expressions whose
    values will evaluate to primitive types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在以下示例中使用 Elm REPL？我们使用它是因为这是一种直接获取我们给 REPL 的每个表达式评估到的值类型信息的方法。换句话说，我们将给
    Elm REPL 提供一系列表达式，主要是简单值的形式，REPL 将返回它们的类型。我们将从评估为原始类型的表达式开始。
- en: Primitive types in Elm
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 中的原始类型
- en: The primitive types in Elm include `Char`, `String`, `Bool`, and `number` (`Int`
    and `Float`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的原始类型包括 `Char`、`String`、`Bool` 和 `number`（`Int` 和 `Float`）。
- en: Char and String types
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符和字符串类型
- en: 'Let''s type the following inside the online elm-repl:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在在线 elm-repl 中输入以下内容：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The Elm-repl will give us back the result of running the preceding expression,
    and follow it up with the type of that value. The type of value ''a'' is a `Char`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Elm-repl 会给我们返回运行前面表达式的结果，并跟随着该值的类型。值 'a' 的类型是 `Char`：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s do another one, this time with double quotes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个，这次用双引号：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What we get back is this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是这个：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can read the preceding as: Value `''''a''''` has a type of `String`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以读作：值 `''a''` 的类型是 `String`。
- en: Obviously, when we use single quotes, we get `Chars`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当我们使用单引号时，我们得到 `Chars`。
- en: To get the type of `String` from a value, we need to surround that value in
    double quotes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要从值中获取 `String` 类型，我们需要在该值周围加上双引号。
- en: 'Multiline strings are written by enclosing any number of lines in three consecutive
    double quote characters. When using REPL, each line must also end with a backslash.
    Elm REPL inserts the pipe characters automatically. The entered multiline string
    value will still evaluate to the type of `String`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串通过将任意数量的行用三个连续的双引号括起来来编写。当使用 REPL 时，每一行也必须以反斜杠结尾。Elm REPL 会自动插入管道字符。输入的多行字符串值仍然会评估为
    `String` 类型：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's look at other primitive types in Elm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Elm 中的其他原始类型。
- en: The number type
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型
- en: 'If we just type a number, we''ll get back that same number, followed with a
    colon and the `number` type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只输入一个数字，我们将得到相同的数字，后面跟着一个冒号和 `number` 类型：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we test a decimal number, we''ll get back the type of `Float`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试一个十进制数，我们将得到 `Float` 类型的类型：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Why are some types capitalized, and some are not?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有些类型是大写的，而有些不是？
- en: If a type is capitalized, it means it is an explicit type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型是大写的，这意味着它是一个显式类型。
- en: Basically, the `number` type is used for both `Ints` and `Floats`. Which one
    it will end up being (which *explicit* type it will end up being), depends on
    how that number is used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`number` 类型用于 `Int` 和 `Float`。它最终会变成哪种类型（即最终会变成哪种显式类型），取决于这个数字是如何使用的。
- en: Put differently, `number` is an implicit type, since it can end up as an explicit
    `Int` or an explicit `Float`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`number` 是一个隐式类型，因为它最终可以是显式的 `Int` 或显式的 `Float`。
- en: 'To get back a value of type `Int`, let''s run the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取类型为 `Int` 的值，请运行以下命令：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Booleans
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Let''s look at Boolean values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看布尔值：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Capitalization is important! For example, typing `true` will throw an error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大写很重要！例如，输入 `true` 会引发错误：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this, we have covered the primitive types in Elm. Next, we are going to
    look at data structures. Since Elm language is statically typed, and since everything
    in Elm is an expression, it follows that whatever we put into REPL will in fact
    be an expression, with a value that will evaluate to a type. Data structures are
    part of this behavior too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们已经涵盖了 Elm 中的原始类型。接下来，我们将查看数据结构。由于 Elm 语言是静态类型的，并且 Elm 中的每件事都是表达式，因此我们可以推断出，无论我们放入
    REPL 中的内容实际上都是一个表达式，其值将评估为某种类型。数据结构也是这种行为的组成部分。
- en: 'Data structures: lists, tuples, records, sets, arrays, and dictionaries'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构：列表、元组、记录、集合、数组和字典
- en: Basic data structures in Elm are lists, tuples, records, sets, arrays, and dictionaries.
    In this section, we will look at the behavior of each of these data structures,
    using Elm REPL and the Ellie-app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的基本数据结构是列表、元组、记录、集合、数组和字典。在本节中，我们将使用 Elm REPL 和 Ellie-app 来查看这些数据结构的每个行为。
- en: Lists
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'A list in Elm is like an array in JavaScript. For our first example, let''s
    type this value in Elm REPL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的列表类似于 JavaScript 中的数组。在我们的第一个例子中，让我们在 Elm REPL 中输入这个值：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is what we get back from the REPL:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从 REPL 获取到的：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Awesome, a List of numbers!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，一个数字列表！
- en: 'Contrast that with Floats:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与浮点数进行对比：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The REPL responds with:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 的响应是：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s try Chars:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试字符：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The REPL returns this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回这个：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, mixing values in Lists in Elm is not allowed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Elm 的列表中混合值是不允许的：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Evidently, we cannot mix types in Elm Lists. In other words, each List in Elm
    is a group of expressions that must always evaluate to the same type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 明显地，我们无法在 Elm 列表中混合类型。换句话说，Elm 中的每个列表都是一个表达式组，这些表达式必须始终评估为相同的类型。
- en: 'Let''s try Strings:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试字符串：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What about an empty list?:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个空列表呢？：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*List a* means that this list is empty, that is, that it can hold *anything*.
    This wraps up our short overview of Lists in Elm. Next, we will look at tuples.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`List a` 意味着这个列表是空的，也就是说，它可以包含任何东西。这总结了我们对 Elm 中列表的简要概述。接下来，我们将查看元组。'
- en: Tuples
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: In Elm, a tuple is a data structure that can hold values of various types.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Elm 中，元组是一种可以持有各种类型值的 数据结构。
- en: 'To make a Tuple in Elm REPL, let''s simply put a `String` and a Boolean inside
    parentheses:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Elm REPL 中创建一个元组，我们只需在括号内放入一个 `String` 和一个布尔值：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The REPL will respond with:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将会响应：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A tuple can hold a maximum of nine values. Interestingly, tuples of different
    lengths are considered to be of different types. For example, let''s make a List
    that holds two tuples, using Elm REPL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以持有最多九个值。有趣的是，不同长度的元组被认为是不同类型的。例如，让我们使用 Elm REPL 创建一个包含两个元组的 List：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This expression will evaluate to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将会计算为：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What REPL tells us is that the value we put in is a `List` of two tuples, holding
    values of `Char` type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 告诉我们的是，我们放入的值是一个包含两个元组的 `List`，这些元组持有 `Char` 类型的值。
- en: 'Let''s try to vary the number of Chars in the second tuple:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改变第二个元组中 Chars 的数量：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the preceding code in the REPL will throw the following error:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中运行前面的代码将会抛出以下错误：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Elm looks at the expression we gave it, and comes back with the Type Mismatch
    error. Indeed, for two tuples to be considered to be of the same type, they have
    to hold the same number of values, and those values *also* need to be of the same
    type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 会查看我们给出的表达式，并返回类型不匹配错误。确实，为了使两个元组被认为是同一类型，它们必须持有相同数量的值，并且这些值 *也* 必须是同一类型的。
- en: In the preceding working example, we added two tuples of two Chars to a `List`,
    and Elm REPL returned ` List ( Char, Char )`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的工作示例中，我们将两个包含两个 Chars 的元组添加到了一个 `List` 中，Elm REPL 返回了 `List ( Char, Char
    )`。
- en: 'The maximum number of values a tuple can hold in Elm is 9\. If you try to add
    10 or more values to a tuple, Elm will throw an error. Let''s try this out:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中元组能持有的最大值数是 9。如果你尝试向元组中添加 10 个或更多的值，Elm 将会抛出一个错误。让我们来试一试：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What we get back is the following error:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是以下错误：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the chapters that follow, we will get to know tuples in much greater depth.
    For now, let''s just mention a common use case: since tuples as a data structure
    can hold various values, they are useful as a way to store results of calculations.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地了解元组。现在，让我们只提一下一个常见的用例：由于元组作为数据结构可以持有各种值，因此它们作为存储计算结果的手段非常有用。
- en: Records
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: 'Records in Elm use curly braces, and a label for each value must be provided.
    Records can also hold multiple values. For example, we can type the following
    record into Elm REPL:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的记录使用花括号，并且每个值都必须有一个标签。记录也可以持有多个值。例如，我们可以在 Elm REPL 中输入以下记录：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The REPL will return this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将返回以下内容：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will use records a lot in our Elm programs, as records allow us to model
    the data in a wide variety of scenarios.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Elm 程序中大量使用记录，因为记录允许我们在各种场景下建模数据。
- en: 'We have already used a record in our code in this chapter, in the *Adding the
    beginnerProgram function* section. Let''s recall the code we used:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码中，我们已经使用了记录，在 *添加 beginnerProgram 函数* 部分中。让我们回顾一下我们使用的代码：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To test out the code in REPL, we will only have to use the record, without
    all the fluff:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 REPL 中测试代码，我们只需要使用记录，而不需要所有冗余的部分：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'REPL will respond with the following error:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将会返回以下错误：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The REPL will follow up the preceding error with a similar error saying that
    the `''update''` variable cannot be found either. To rectify this, as an exercise,
    we can give values to the variables used in our record, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将会跟随前面的错误，并给出一个类似的错误，指出 `'update'` 变量也无法找到。为了纠正这个问题，作为一个练习，我们可以给记录中使用的变量赋值，如下所示：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have assigned values of type `String` to the `view` and `update` variables
    in the Elm REPL. Then we entered the record, and the REPL returned types for each
    of the variables used in the record. Thus, in the preceding example, the `model`
    is of type `number`, the `update` is of type `String`, and the `view` is also
    of type `String`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `String` 类型的值赋给了 Elm REPL 中的 `view` 和 `update` 变量。然后我们输入了记录，REPL 返回了记录中使用的每个变量的类型。因此，在前面的例子中，`model`
    是 `number` 类型，`update` 是 `String` 类型，而 `view` 也是 `String` 类型。
- en: Next up, we'll look at sets, arrays, and dictionaries, which have to be imported,
    although they too are built into Elm.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨集合、数组和字典，虽然它们也需要导入，但它们同样内置在 Elm 中。
- en: Sets
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are collections of unique values. Their uniqueness is guaranteed by the
    Elm programming language. We can instantiate sets as empty sets or use the `fromList`
    function. Creating an empty set is easy: `set = Set.empty`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是唯一值的集合。它们的唯一性由 Elm 编程语言保证。我们可以通过 `fromList` 函数实例化集合。创建一个空集合很简单：`set = Set.empty`。
- en: Let's look at the other way of creating sets in Elm, by pointing our browser
    to: [ellie-app.com/new](http://ellie-app.com/new).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Elm 中创建集合的另一种方法，通过将浏览器指向：[ellie-app.com/new](http://ellie-app.com/new)。
- en: 'The page that opens already has some Elm code in it. Let''s adjust that code
    so that it looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的页面已经包含了一些 Elm 代码。让我们调整代码，使其看起来如下：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'What we did in the preceding code was, after importing `Set` (to the variable
    we named `set`), we assigned the returned value from the evaluated expression:
    `Set.fromList [1,1,1,2]`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在导入 `Set`（到我们命名为 `set` 的变量）之后，将评估表达式的返回值赋给了它：`Set.fromList [1,1,1,2]`。
- en: Next, we gave the `set ` variable to our `main` function, to render it out as
    a text node. Of course, before it could be rendered out, we had to convert it
    to a `String`.  After pressing the Compile button in the Ellie-app, we should
    see the following result: `Set.fromList [1,2]`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `set` 变量传递给 `main` 函数，以将其渲染为文本节点。当然，在它被渲染出来之前，我们必须将其转换为 `String`。在 Ellie-app
    中按下编译按钮后，我们应该看到以下结果：`Set.fromList [1,2]`。
- en: Sets are useful when we are trying to find differences between data structures.
    Next, we'll look at arrays.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图找出数据结构之间的差异时，集合非常有用。接下来，我们将探讨数组。
- en: Arrays
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays in Elm are zero-based, just like they are in JavaScript. With arrays,
    we can work with elements based on their index. Like sets, arrays can be created
    using the `fromList` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的数组是零基的，就像在 JavaScript 中一样。使用数组，我们可以根据它们的索引来处理元素。和集合一样，数组可以使用 `fromList`
    函数创建。
- en: 'Alternatively, we can create an empty array like this: `array = Array.empty`.
    Still in the Ellie-app, let''s make a slight change to our code to test out arrays:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个空数组，如下所示：`array = Array.empty`。仍然在 Ellie-app 中，让我们对我们的代码进行轻微的修改以测试数组：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, we have a slight twist—we grouped the concatenation of
    two arrays and a space, all converted to `Strings`, and then ran the `text` function
    on them, finally passing the value returned from the evaluation of the expression
    to the main function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个小小的转折——我们将两个数组的连接和一个空格（都转换为 `Strings`）分组，然后对它们运行 `text` 函数，最后将表达式评估的返回值传递给主函数。
- en: The compiled code will display the following result: `Array.fromList [1,1,1,2]
    Just 1`. For now, let's just ignore what this result means, as we'll get back
    to it later in the book. Next, we'll look at dictionaries in Elm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的代码将显示以下结果：`Array.fromList [1,1,1,2] Just 1`。现在，让我们暂时忽略这个结果的意义，因为我们将在本书的后面部分再次回到它。接下来，我们将探讨
    Elm 中的字典。
- en: Dictionaries
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are also created using the `fromList` function. Let''s revisit
    the Ellie-app, with our code changed as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也是使用 `fromList` 函数创建的。让我们回到 Ellie-app，我们的代码已按如下方式更改：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After compilation, the Ellie-app will return this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Ellie-app 将返回以下内容：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`Dict` is the data structure used to store pairs of keys and values. Keys must
    be unique. To learn more about this data structure, visit the following URL: [http://package.elm-lang.org/packages/elm-lang/core/latest/Dict](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dict` 是用于存储键值对的数据结构。键必须是唯一的。要了解更多关于这个数据结构的信息，请访问以下网址：[http://package.elm-lang.org/packages/elm-lang/core/latest/Dict](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict)。'
- en: Next, we'll look at how types work for functions and `if` expressions in the
    Elm language.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 Elm 语言中类型如何作用于函数和 `if` 表达式。
- en: Functions, if expressions, and types
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数、if 表达式和类型
- en: 'Let''s create a new function in Elm REPL. We''ll call our function `multiplyBy5`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Elm REPL 中创建一个新的函数。我们将我们的函数命名为 `multiplyBy5`：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The REPL will return this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将返回以下内容：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding line says that our `multiplyBy5` function has the type of `number
    -> number`. Let''s see what type will get returned from a function that works
    with Strings:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行表示我们的 `multiplyBy5` 函数的类型为 `number -> number`。让我们看看处理字符串的函数将返回什么类型：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As we already know, the `++` operator is the concat operator in Elm; it will
    join two `Strings` together. Thus, expectedly, Elm REPL will return:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`++` 运算符是 Elm 中的连接运算符；它将两个 `Strings` 连接在一起。因此，预期 Elm REPL 将返回以下内容：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we can see, the preceding function is of type `String -> String`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的函数类型为 `String -> String`。
- en: But, what is this `String -> String`? And, along the same lines, what is the
    `Int -> Int` from the previous example? `String -> String` simply means that the
    function expects a `String` as its argument, and will also return a `String`.
    For the `Int -> Int` example, the function expects a value of type `Int` and will
    also return a value of type `Int`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个 `String -> String` 是什么意思？同样地，前一个例子中的 `Int -> Int` 又是什么意思？`String -> String`
    简单来说就是该函数期望一个 `String` 类型的参数，并将返回一个 `String`。对于 `Int -> Int` 的例子，该函数期望一个 `Int`
    类型的值，并将返回一个 `Int` 类型的值。
- en: 'It''s time to take a look at the basics of types in `if` expressions in Elm.
    Consider the following snippet of code and the response REPL gave it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看 Elm 中 `if` 表达式的类型基础了。考虑以下代码片段和 REPL 给出的响应：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we are running an `if` expression using the variable
    `time` (which we assign the value of `24`).  Then, we are running our comparison.
    Note that if expressions should actually be referred to as `if-else` expressions,
    as `if` expressions must have an else, otherwise they won't work in Elm.  Both
    the `if` and the `else` branch must be of the same type. That's why in the preceding
    example we are making sure that either result we get is of type `String`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用变量 `time`（我们将其赋值为 `24`）运行一个 `if` 表达式。然后，我们运行比较。请注意，`if` 表达式实际上应该被称为
    `if-else` 表达式，因为 `if` 表达式必须有 `else` 部分，否则在 Elm 中将无法工作。`if` 和 `else` 分支必须是同一类型。这就是为什么在前面的例子中，我们确保我们得到的任何结果都是
    `String` 类型。
- en: Revisiting Elm messages
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视 Elm 消息
- en: 'We started off this chapter by looking at the Elm arhitecture: Model, View,
    and Update. We also mentioned another important ingredient: Messages, **a way
    for Views to communicate with Updates**.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章从 Elm 架构：模型、视图和更新开始。我们还提到了另一个重要组成部分：消息，**这是视图与更新进行通信的方式**。
- en: 'We used a very simple example app, *Fruit Counter*. The app was simple indeed:
    the only message our view could ever send to the update function was `Decrement`.
    The simplicity of the app we made was a great way for us to understand the architecture
    without having to introduce too many concepts that would get in the way of learning.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个非常简单的示例应用，*水果计数器*。该应用确实很简单：我们的视图可以向更新函数发送的唯一消息是`Decrement`。我们创建的应用的简单性是我们理解架构的好方法，无需引入太多会妨碍学习的概念。
- en: However, now that we have a rudimentary understanding of all the moving parts
    and how they fit together, we can talk about another level of complexity related
    to messages in the Elm arhitecture.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们已经对所有的组成部分及其如何组合有了基本的理解，我们可以讨论 Elm 架构中与消息相关的另一个复杂层次。
- en: 'To do that, we can look at a finished example straight from the official documentation.
    This will serve two purposes: first, it will get us in the habit of referring
    to the excellent official docs as often as possible, and second, it will give
    us a benchmark that we will initially look up to, and during the course of the
    book, leave behind as we learn more advanced concepts.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以查看官方文档中的一个完成示例。这将有两个目的：首先，它将使我们养成尽可能经常参考优秀官方文档的习惯，其次，它将为我们提供一个基准，我们最初会参考，在本书的学习过程中，随着我们学习更高级的概念，我们将逐渐超越。
- en: To get started, open the documentation for the buttons example at: [https://guide.elm-lang.org/architecture/user_input/buttons.HTML](https://guide.elm-lang.org/architecture/user_input/buttons.html).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开按钮示例的文档，网址为：[https://guide.elm-lang.org/architecture/user_input/buttons.HTML](https://guide.elm-lang.org/architecture/user_input/buttons.html)。
- en: 'Next, visit the Ellie online editor at [https://ellie-app.com/new](https://ellie-app.com/new),
    and paste in the code from the buttons example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，访问 Ellie 在线编辑器，网址为[https://ellie-app.com/new](https://ellie-app.com/new)，并将按钮示例中的代码粘贴进去：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After pasting in the code, click the Compile button in the right-hand pane and
    the app will compile and run there. The app itself is very similar to our *Fruit
    Counter*, only slightly more advanced. Let's compare these differences.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴代码后，点击右侧面板中的编译按钮，应用将在那里编译并运行。该应用本身与我们的 *水果计数器* 非常相似，只是稍微复杂一些。让我们比较这些差异。
- en: 'In *Fruit Counter*, we had the following message:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *水果计数器* 中，我们有以下消息：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the Buttons app, the message is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮应用中，消息如下：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first thing to note is the comment preceding the code. Initially, we used
    `MESSAGE` as the comment text. However, in the Buttons example, they are using
    `UPDATE` in their inline comment. The reason: conventionally, the Elm architecture
    is considered to consist only of Model, View, and Update. We used Message as a
    separate part of the architecture only to help understand it easier. The most
    important point of that understanding is: **the View sends Messages to the Update
    function**. Conceptually, this is the same in both examples. The only difference
    is that now the *Message* is defined in the *Update* section of our app, as it
    should be.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是代码前面的注释。最初，我们使用`MESSAGE`作为注释文本。然而，在按钮示例中，他们使用`UPDATE`作为内联注释。原因是：传统上，Elm架构被认为只由模型(Model)、视图(View)和更新(Update)组成。我们使用Message作为架构的独立部分只是为了更容易理解它。理解的最重要的一点是：**视图向更新函数发送消息**。从概念上讲，这两个例子是相同的。唯一的区别是现在*消息*被定义在我们应用的*更新*部分，正如它应该的那样。
- en: 'The second thing to note is that our message only had the value of `Decrement`.
    It *could only be* a `Decrement` message. In the Buttons app, we have two options:
    the Message can be *either* a `Decrement` *or* an `Increment`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点要注意的是，我们的消息只有`Decrement`的值。它*只能是*一个`Decrement`消息。在按钮应用中，我们有两种选择：消息可以是*要么*`Decrement`，*要么*`Increment`。
- en: What's with the `type` keyword, and the pipe character, then? It has to do with
    something known as **union types** (also known as **algebraic data types** or
    **tagged unions**).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`type`关键字和管道字符是什么意思呢？这与一个称为**联合类型**（也称为**代数数据类型**或**标记联合**）的东西有关。
- en: 'In Elm, a union type is simply a custom type that we can come up with on the
    fly. In our *Fruit Counter* app, our `Msg` union type has only one value: `Decrement`.
    In the Buttons app, the `Msg` union type can have either of the two values: `Increment`
    or `Decrement`. To differentiate clearly between possible values in a union type,
    we use the pipe character.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Elm中，联合类型只是我们可以即时想出的自定义类型。在我们的*Fruit Counter*应用中，我们的`Msg`联合类型只有一个值：`Decrement`。在按钮应用中，`Msg`联合类型可以是两个值中的任何一个：`Increment`或`Decrement`。为了在联合类型中清楚地区分可能的值，我们使用管道字符。
- en: 'Let''s make another custom union type in the Elm REPL:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Elm REPL中创建另一个自定义联合类型：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: To create a union type, we begin with the `type` keyword. Next, we provide the
    actual type, `Vehicle`. We created a custom type on the fly, and named it `Vehicle`!
    To the right of the assignment operator  (the `=` sign), we provide the values
    that the `Vehicle` union type can have. **These values are called type constructors**,
    as you can use them to **construct** new instances of `Vehicle`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个联合类型，我们首先使用`type`关键字。接下来，我们提供实际类型，`Vehicle`。我们即时创建了一个自定义类型，并将其命名为`Vehicle`！在赋值运算符（等号`=`）的右侧，我们提供`Vehicle`联合类型可以具有的值。**这些值被称为类型构造函数**，因为你可以使用它们来**构造**新的`Vehicle`实例。
- en: 'Let''s create a new instance of `Vehicle` in the REPL:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中创建一个新的`Vehicle`实例：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have just constructed a new instance of the `Vehicle` type. As we can see,
    the REPL responds with this information—the value is `Helicopter`, and its type
    is `Vehicle`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个新的`Vehicle`类型的实例。正如我们所见，REPL以这条信息响应——值是`Helicopter`，其类型是`Vehicle`。
- en: Sometimes, it is helpful to explain the same concept in a couple of different
    ways. Another way of looking at union types is that they are a way for us to describe
    constructor functions, that is, to define them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用几种不同的方式解释相同的概念是有帮助的。看待联合类型的另一种方式是，它们是我们描述构造函数的方式，也就是说，定义它们。
- en: 'In the `update` function, we had:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，我们有：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code means that to make a `Msg`, either the `Increment` function
    or the `Decrement` function needs to be called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码意味着要创建一个`Msg`，必须调用`Increment`函数或`Decrement`函数。
- en: The theoretical underpinnings of union types are rooted in mathematical logic,
    namely the set theory, which is basically the study of collections of things.
    Thus, we can look at a union type as a combination of any number of collections
    of things. Both union types and the set theory can get quite abstract, but at
    this point in our learning, suffice it to say that union types are a way to organize
    messages in Elm apps.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的理论基础根植于数学逻辑，即集合论，这基本上是研究事物集合的研究。因此，我们可以将联合类型看作是任何数量的事物集合的组合。联合类型和集合论都可以相当抽象，但在这个学习阶段，我们只需说联合类型是组织Elm应用中消息的一种方式。
- en: Functions, pattern matching, and case expressions
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数、模式匹配和情况表达式
- en: The goal of this chapter was to build a simple app and learn important theory
    behind it. We expanded on this goal by comparing our own app with the one from
    the official docs.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是构建一个简单的应用，并学习其背后的重要理论。我们通过将我们的应用与官方文档中的应用进行比较来扩展了这个目标。
- en: In this section, we will look at the update function of the Buttons App and
    take it apart in order to have complete understanding of what it does and how
    it works.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看Buttons应用的更新函数，并对其进行拆解，以便完全理解其功能和运作方式。
- en: This is important, because once we understand how the `update` function works
    in the Buttons app, we will be able confidently to implement a similar solution
    and improve our *Fruit Counter*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们一旦理解了Buttons应用中的`update`函数是如何工作的，我们就可以自信地实现一个类似的解决方案，并改进我们的*水果计数器*。
- en: 'Let''s begin by inspecting the `update` function in the Buttons app:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查Buttons应用的`update`函数开始：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We see a new keyword here: `case`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一个新的关键字：`case`。
- en: Generally, the way that the `case` syntax works is as follows—a variable has
    a certain value. Based on its value, a certain block of code will execute. When
    the value is different, the block of code to execute will be different as well.
    Finally, at the end of a `case` expression, there is a block of code that will
    execute for all the values that were not already specified in the `case` expression.
    In other words, for any unspecified scenario, there is a case block at the bottom
    to take care of it. This `case` block is called the *wildcard* and it's marked
    with the underscore character, `_`. As we can see in the preceding example, there
    are situations where the *wildcard* case does not need to be added, because we
    have *already covered* all the possibilities.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`case`语法的运作方式如下——一个变量具有某个值。根据其值，将执行特定的代码块。当值不同时，要执行的代码块也会不同。最后，在`case`表达式的末尾，有一个代码块将执行所有在`case`表达式中未指定的值。换句话说，对于任何未指定的场景，都有一个在底部的case块来处理它。这个`case`块被称为*通配符*，并用下划线字符`_`标记。正如我们可以在前面的例子中看到的那样，在某些情况下，不需要添加*通配符*case，因为我们已经*覆盖*了所有可能性。
- en: Elm `case` expressions are evaluated via pattern matching, that is, by verifying
    whether a `case` conforms to a pattern. *If expressions* and *case expressions*
    are quite similar.  One major difference is that `case` expressions *match patterns*,
    and `if` expressions *check for true conditions* as ways to determine which code
    blocks to run.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Elm的`case`表达式通过模式匹配来评估，也就是说，通过验证`case`是否符合模式。*if表达式*和*case表达式*非常相似。一个主要区别是`case`表达式*匹配模式*，而`if`表达式*检查真条件*，作为确定要运行哪个代码块的方式。
- en: 'Looking at the syntax of `case` expressions, we can see that they start with
    the `case` keyword, followed by the name of the case expression (in our example,
    `msg`). The name is completely arbitrary; instead of `msg`, we could have used
    anything else. For example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 查看case表达式的语法，我们可以看到它们以`case`关键字开头，后面跟着case表达式的名称（在我们的例子中，是`msg`）。名称是完全任意的；我们本可以使用任何其他名称，而不仅仅是`msg`。例如：
- en: '[PRE68]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see in the preceding code snippet, the *first parameter* of the `update`
    function and the *name of the case expression* must be the same. To avoid confusion,
    it's best to stick with `msg ` as the first parameter here, as that is the norm,
    and you'll see it used that way in most Elm programs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的代码片段中看到的那样，`update`函数的第一个参数和`case表达式`的名称必须相同。为了避免混淆，最好在这里坚持使用`msg`作为第一个参数，因为这是规范，你将在大多数Elm程序中看到这种方式的使用。
- en: So, after the `case` keyword, and the name of the case expression, we have another
    keyword, `of`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`case`关键字和case表达式的名称之后，我们还有一个关键字`of`。
- en: 'Next, we list our cases. The structure of the code is always the same:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们列出我们的case。代码的结构始终相同：
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we look at the first case, we can see that it''s written as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看第一个case，我们可以看到它被写成如下：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code snippet, the pattern to match is `Increment`, and the
    expression to evaluate is `model + 1`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，要匹配的模式是`Increment`，要评估的表达式是`model + 1`。
- en: Improving the Fruit Counter app
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进水果计数器应用
- en: 'Based on everything we have learned so far, let''s improve the *Fruit Counter*
    app. Here is the full code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们迄今为止所学的一切，让我们改进*水果计数器*应用。以下是完整的代码：
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s highlight the improvements we made to our app:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们突出显示我们对应用所做的改进：
- en: We added another button to our `view` function.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`view`函数中添加了另一个按钮。
- en: We added a new message, `Reset`, to be sent when the new button is clicked.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当新按钮被点击时，我们添加了一个新的消息`Reset`。
- en: We added the `Reset` constructor function to our `Msg` union type.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向我们的 `Msg` 联合类型中添加了 `Reset` 构造函数。
- en: 'In our `update` function, we gave our case expression the name of `msg`, and
    we also gave it two patterns to match: `Decrement` and `Reset`.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `update` 函数中，我们给我们的模式表达式命名为 `msg`，并且我们还给它提供了两个匹配模式：`Decrement` 和 `Reset`。
- en: If the `Decrement` pattern gets matched, an `if` expression will be evaluated
    (to determine whether the model should be decreased by one or whether its value
    should be `5`).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果匹配到 `Decrement` 模式，将评估一个 `if` 表达式（以确定模型是否应该减一或其值应该是 `5`）。
- en: If the `Reset` pattern gets matched, an expression of `5` will be evaluated.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果匹配到 `Reset` 模式，将评估一个 `5` 的表达式。
- en: In the preceding explanation, an effort was made to describe all the updates
    in accordance with the concepts we learned in this chapter. It is important to
    understand the preceding explanation as it is the foundation on which we will
    build more complex apps in chapters that follow.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的解释中，我们尽力按照本章学到的概念描述了所有的更新。理解前面的解释非常重要，因为它是我们在后续章节构建更复杂应用程序的基础。
- en: Building a simple FizzBuzz app in Elm
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Elm 中构建简单的 FizzBuzz 应用程序
- en: FizzBuzz is a word game for kids. The purpose is to teach math, namely division.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: FizzBuzz 是一种儿童文字游戏。其目的是教授数学，即除法。
- en: 'The game is simple: each player calls out a number, starting from 1\. If a
    number can be divided by three, a player needs to call out *Fizz* instead of a
    number. Furthermore, if a number can be divided by five, a player needs to call
    out *Buzz* instead of a number.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏很简单：每个玩家从1开始报数。如果一个数可以被3整除，玩家需要报出 *Fizz* 而不是数字。此外，如果一个数可以被5整除，玩家需要报出 *Buzz*
    而不是数字。
- en: Finally, if a number can be divided by both 3 and 5, a player needs to call
    out *FizzBuzz*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一个数可以被3和5整除，玩家需要报出 *FizzBuzz*。
- en: Since this is a well-known game, and a relatively simple problem, it is a great
    way to test the level of knowledge of a programmer.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个众所周知且相对简单的问题，因此它是测试程序员知识水平的好方法。
- en: In order to go about solving this problem, we will introduce a new operator,
    the modulus operator, `%`. This operator returns the division remainder.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题的方法，我们将引入一个新的运算符，即取模运算符 `%`。这个运算符返回除法的余数。
- en: 'The way it works can be best described by an example. Open up the online Elm
    REPL, and run the following expression:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式可以通过一个例子来最好地描述。打开在线 Elm REPL，并运行以下表达式：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The REPL will return:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将返回：
- en: '[PRE73]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'What this means is: if we divide `12` by `10`, we will get `1`, and what will
    remain is `2`. Since `2` is less then `10`, it will not be divided, as the modulus
    in our example will only divide in increments of `10`, and return the remainder.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：如果我们用 `12` 除以 `10`，我们会得到 `1`，而剩下的就是 `2`。由于 `2` 小于 `10`，它不会被整除，因为在我们例子中的取模运算只会以
    `10` 为增量进行除法，并返回余数。
- en: That's why we said that the modulus operator returns the remainder of a division
    (that is, whatever is on the right side of the modulus operator determines the
    size of increments).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么我们说取模运算符返回除法的余数（也就是说，取模运算符右侧的内容决定了增量的大小）。
- en: 'So, for example, if we run this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们运行这个：
- en: '[PRE74]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We will get this back:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下返回：
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'However, we will get the exact same result if we run this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行这个：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding expression will evaluate to `1 : Int` because the size of the
    increments that will be calculated is `9` in the preceding example. Since *9 *
    2 = 18*, the remainder of the division is 1.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的表达式将评估为 `1 : Int`，因为在前面的例子中，将要计算的增量大小是 `9`。由于 `9 * 2 = 18`，除法的余数是 `1`。'
- en: 'What will happen if we divide the number by itself? Let''s try number `3`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数字除以它自己会发生什么？让我们尝试数字 `3`：
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The REPL returns the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We get back the value `0`, of type `Int`. We can do the same for `5` and `15`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到返回值 `0`，类型为 `Int`。我们可以对 `5` 和 `15` 做同样的操作：
- en: '[PRE79]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Again, we get back zero, of type `Int`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到零，类型为 `Int`。
- en: What does this mean in practice? It means that we can use an `if-else` expression
    to check for all the numbers that do not have a remainder when divided by 3\.
    For all the numbers that satisfy that condition, we will return *Fizz*. We will
    apply a similar approach for numbers 5 and 15, as dictated by the rules of the
    game.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中意味着我们可以使用 `if-else` 表达式来检查所有除以3没有余数的数字。对于所有满足该条件的数字，我们将返回 *Fizz*。我们将根据游戏规则对数字5和15采用类似的方法。
- en: 'This is enough information for us to create our simple *FizzBuzz* app. Navigate
    your browser to ;[https://ellie-app.com/new](https://ellie-app.com/new) and type
    the following code:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建简单的 *FizzBuzz* 应用所需的信息。将您的浏览器导航到 ;[https://ellie-app.com/new](https://ellie-app.com/new)
    并输入以下代码：
- en: '[PRE80]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'At this point, we have enough knowledge fully to understand the preceding code
    with ease. Looking at the preceding code, one of the important concepts to be
    reminded of is the principle that we need to obey when working with `if` expressions:
    they should always return the same type of value. That is why we are passing the
    value to the `toString` function at the very bottom of our `if` expression.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有足够的知识轻松理解前面的代码。查看前面的代码，需要提醒的一个重要概念是我们与 `if` 表达式一起工作时需要遵守的原则：它们应该始终返回相同类型的值。这就是为什么我们在
    `if` 表达式的底部传递值到 `toString` 函数的原因。
- en: 'As a quick reminder of piping syntax (discussed in [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml),
    *Why Is This a Great Time to Learn Elm?*), here is another way we could have written
    the main function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对管道语法的快速提醒（在第 1 章 *Why Is This a Great Time to Learn Elm?* 中讨论），以下是另一种我们可以编写主函数的方式：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `|>` is called the **forward function application operator**.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`|>` 被称为 **前向函数应用操作符**。'
- en: We have achieved our goal of making a working *FizzBuzz* app in Elm. In the
    chapters that follow, we will look at ways of making improvements to our simple
    *FizzBuzz* app.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了在 Elm 中创建一个工作 *FizzBuzz* 应用的目标。在接下来的章节中，我们将探讨改进我们简单 *FizzBuzz* 应用的方法。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we have covered a number of important topics, namely:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多个重要主题，具体如下：
- en: 'Elm syntax: values, types, data structures, `if-else` expressions, `case` expressions,
    and some operators'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 语法：值、类型、数据结构、`if-else` 表达式、`case` 表达式以及一些操作符
- en: 'TEA: The Elm architecture'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TEA：Elm 架构
- en: The concept of unidirectional data flows
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向数据流的概念
- en: Working with Elm REPL and the Ellie-app
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Elm REPL 和 Ellie-app 进行工作
- en: We also built two working apps, which, although simple, have shown the practical
    application of the theoretical concepts we covered.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建了两个工作应用，虽然简单，但已经展示了我们所涵盖的理论概念的实际应用。
- en: In the next chapter, we will make our own personal portfolio in Elm.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Elm 创建我们自己的个人投资组合。
