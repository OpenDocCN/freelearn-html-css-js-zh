- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Improving Reliability with Testing Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试工具提高可靠性
- en: Now that we can actually write and build our code for the browser efficiently,
    it makes sense to also consider verifying the code’s output. Does it really fulfill
    the given requirements? Has anything changed in terms of the expected outcome?
    Does the code crash when unexpected values are passed in?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够高效地编写和构建浏览器代码，因此考虑验证代码的输出也是有意义的。它真的满足了给定的要求吗？在预期结果方面有什么变化吗？当传入意外值时，代码会崩溃吗？
- en: What we need to answer these questions is testing. Testing can mean a lot of
    things – and depending on who you ask, you’ll get a different answer to the question
    “What should we test?” In this chapter, we’ll walk through the different options
    that interest us as developers. We’ll see what tools exist to automate these tests
    and how we can set them up and use them practically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要进行测试。测试可以意味着很多不同的事情——而且根据您询问的人不同，您将得到不同的“我们应该测试什么？”问题的答案。在本章中，我们将探讨作为开发者感兴趣的不同选项。我们将了解存在哪些工具可以自动化这些测试，以及我们如何实际设置和使用它们。
- en: We will start our journey into the testing space with a discussion on the beloved
    testing pyramid. We will then continue by learning about the types of test tools
    – most notably, pure runners and whole frameworks. Finally, we’ll cover some of
    the most popular tools in this space.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的测试之旅，首先讨论备受喜爱的测试金字塔。然后，我们将继续学习关于测试工具的类型——最值得注意的是，纯运行器和完整框架。最后，我们将介绍这个领域的一些最受欢迎的工具。
- en: By the end of this chapter, you will know which testing framework or test runner
    to choose for your programming needs, along with the pros and cons of each option.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解针对您的编程需求应选择哪种测试框架或测试运行器，以及每个选项的优缺点。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Considering the testing pyramid
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到测试金字塔
- en: Comparing test runners versus frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较测试运行器和框架
- en: Using the Jest framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 框架
- en: Using the Mocha framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mocha 框架
- en: Using the AVA test runner
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AVA 测试运行器
- en: Using Playwright for visual tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Playwright 进行视觉测试
- en: Using Cypress for end-to-end testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在[https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07)找到。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3DW9yoV](https://bit.ly/3DW9yoV).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在[https://bit.ly/3DW9yoV](https://bit.ly/3DW9yoV)访问。
- en: Considering the testing pyramid
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑到测试金字塔
- en: Over the years, more and more types of software testing have been identified
    and added to the standard repertoire of software projects and testing professionals
    such as quality assurance engineers. A powerful tool to categorize and order the
    most common types of software testing is the testing pyramid.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，越来越多的软件测试类型被识别并添加到软件项目和测试专业人员（如质量保证工程师）的标准工具库中。一个强大的工具，可以分类和排序最常见的软件测试类型，就是测试金字塔。
- en: The testing pyramid arranges the different types of testing by their visibility
    and effort. Higher layers of the pyramid require more effort but have greater
    visibility. Tests that are placed in the lower layers of the pyramid should be
    written a lot more – after all, these are the foundations of the pyramid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔根据测试的可见性和努力程度来安排不同的测试类型。金字塔的较高层需要更多的努力，但具有更高的可见性。应该更多地编写位于金字塔较低层的测试——毕竟，这些是金字塔的基础。
- en: 'An illustration of the testing pyramid is shown in *Figure 7**.1*. The basis
    of the testing pyramid is formed by unit tests, which provide enough reliability
    to run components and integration tests on top of them later. Finally, UI tests
    (quite often referred to as end-to-end tests) can be run to verify that the solution
    works for end users:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1*展示了测试金字塔的示意图。测试金字塔的基础是由单元测试构成的，它们提供了足够的可靠性，可以在其上运行组件和集成测试。最后，可以运行UI测试（通常被称为端到端测试），以验证解决方案是否适用于最终用户：'
- en: '![Figure 7.1 – The testing pyramid with three layers of automatic testing ](img/Figure_7.1_B18989.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 具有三个自动测试层的测试金字塔](img/Figure_7.1_B18989.jpg)'
- en: Figure 7.1 – The testing pyramid with three layers of automatic testing
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 具有三个自动测试层的测试金字塔
- en: Usually, end-to-end tests refer to tests that use the interface as presented
    to the end user. In the case of a web application, this would be the actual website.
    By their nature, end-to-end tests are usually black-box tests. The whole system
    is treated as is, so with everything running as close to the production environment
    as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，端到端测试指的是使用面向最终用户的接口进行的测试。在Web应用程序的情况下，这将是指实际的网站。由于它们的本质，端到端测试通常是黑盒测试。整个系统被视为一个整体，因此尽可能接近生产环境运行。
- en: Black-box tests
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: The notion of a black box comes from the so-called black box approach. This
    is a common technique to analyze an open system by varying the input and measuring
    the output. This approach makes sense when the internal workings are either not
    known or not accessible. Likewise, black-box testing is also performed without
    changing the application’s internal workings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒的概念来源于所谓的黑盒方法。这是一种通过改变输入并测量输出来分析开放系统的常见技术。当内部工作原理既不为人所知也不易访问时，这种方法是有意义的。同样，黑盒测试也是在不更改应用程序内部工作原理的情况下进行的。
- en: Variations of end-to-end tests focus on performance (*load tests*) or security
    (*penetration tests*). While the former can be quite tricky and expensive to run,
    the latter should be performed regularly to shield against potential attacks.
    One of the greatest risks for companies is to be hacked. Not only will this include
    the theft of precious data but it will also have a strong negative impact on the
    company’s brand. To help defend against scenarios like this, sometimes gray-box
    testing is used, which, unlike black-box tests, understands certain documented
    operations of the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的变体主要关注性能（*负载测试*）或安全性（*渗透测试*）。虽然前者可能相当棘手且成本高昂，但后者应定期执行以抵御潜在的攻击。对于公司来说，最大的风险之一就是被黑客攻击。这不仅包括珍贵数据的盗窃，还会对公司的品牌产生强烈的负面影响。为了帮助防御此类场景，有时会使用灰盒测试，这与黑盒测试不同，它理解系统的一些已记录的操作。
- en: One challenge with testing is that many of the terms used, such as integration
    or component tests, are not universally defined. For instance, some people consider
    an integration test to be something very narrow – testing the integration with
    one external part at a time. Other people may say that an integration test should
    cover the integration with all the external parts. Consequently, it is quite important
    to carefully review and define these terms before using them in a project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一个挑战是，许多使用的术语，如集成测试或组件测试，并没有统一的定义。例如，有些人认为集成测试非常狭窄——一次测试与一个外部部分的集成。其他人可能说集成测试应该涵盖与所有外部部分的集成。因此，在使用项目之前仔细审查和定义这些术语非常重要。
- en: When we refer to unit tests, we mean tests for a single unit (such as a function)
    of the project – only one specific part of it. Usually, this unit carries some
    logic that can be tested specifically. Everything that is not related to this
    one unit has to be controlled. While some unit tests can be written like black-box
    tests, most unit tests will require a detailed understanding of the internal workings.
    This way, the behavior of the tested unit can be controlled as required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到单元测试时，我们指的是针对项目单个单元（如函数）的测试——仅针对其特定部分。通常，这个单元携带一些可以具体测试的逻辑。与这个单一单元无关的所有内容都必须得到控制。虽然一些单元测试可以编写成黑盒测试，但大多数单元测试将需要深入了解内部工作原理。这样，就可以按需控制被测试单元的行为。
- en: 'Consider the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: pure.js
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: pure.js
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, the function is very well suited for a unit test:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，该函数非常适合进行单元测试：
- en: It is exported, so we can access it from another module containing the tests.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被导出，因此我们可以从包含测试的另一个模块中访问它。
- en: It does not use anything outside of the function – it’s a so-called pure function.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不使用函数之外的内容——它是一个所谓的纯函数。
- en: The logic is sufficiently complex to test against a set of predefined test cases.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑足够复杂，可以针对一组预定义的测试用例进行测试。
- en: 'Unit tests for the `pickSmallestNumber` function could look as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickSmallestNumber` 函数的单元测试可能如下所示：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned, the code could look like this. The functions used are defined
    nowhere and the preceding code would not run as presented.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码可能看起来像这样。使用的函数定义在别处，前面的代码按所示无法运行。
- en: For these tests, we introduced a new function, `test`, which takes a description
    of the test and the code in the form of a function for running the test. We also
    introduced an assertion function, `assert`, which could be taken from the Node.js
    built into the `assert` module. The proposed `assert` function accepts a Boolean
    input – throwing an exception if the input is `false`. The testing tools and frameworks
    we’ll look at will replace these constructs with more expressive and elegant alternatives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些测试，我们引入了一个新的函数`test`，它接受测试的描述和以函数形式运行的测试代码。我们还引入了一个断言函数`assert`，可以从内置的`assert`模块中获取。建议的`assert`函数接受布尔输入——如果输入为`false`则抛出异常。我们将查看的测试工具和框架将用更具有表现力和优雅的替代方案替换这些结构。
- en: Besides the actual testing and test area differences, the tooling choices also
    offer a few variations. One of the most crucial ones is the difference between
    a full testing framework and a test runner.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际的测试和测试区域差异之外，工具选择也提供了一些变化。其中最关键的一个是完整测试框架和测试运行器之间的差异。
- en: Comparing test runners versus frameworks
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较测试运行器和框架
- en: Historically, tests for JavaScript targeting web browsers could not be just
    written and run automatically. The main reason was that this involved dealing
    with a real browser. There was no way to just *pretend to run in the browser*.
    For this reason alone, the first tools in that space have either been scripts
    or whole websites evaluating JavaScript or browser automation tools. The latter
    actually forms its own category – being at the heart of modern end-to-end tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，针对Web浏览器的JavaScript测试不能简单地编写和自动运行。主要原因在于这涉及到处理真实的浏览器。没有方法可以仅仅“假装在浏览器中运行”。正因为如此，该领域最初的一些工具要么是脚本，要么是整个网站评估JavaScript或浏览器自动化工具。后者实际上形成了一个自己的类别——它是现代端到端测试的核心。
- en: The main driver for running the tests – historically, for starting everything
    that needs to be running to actually perform tests – is called a test runner.
    One of the first very successful test runners in the JavaScript space was **Karma**.
    The job of Karma was to spin up a server that runs a website hosting the tests,
    which are targeting JavaScript code that should run in a browser. Karma then opened
    available browsers to access the hosted website running the tests. The results
    were reported back to the server and shown in the console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的主要驱动力——从历史上看，为了启动所有需要运行以实际执行测试的东西——被称为测试运行器。JavaScript空间中第一个非常成功的测试运行器之一是**Karma**。Karma的工作是启动一个服务器，该服务器运行托管测试的网站，这些测试针对的是应该在浏览器中运行的JavaScript代码。然后Karma打开可用的浏览器以访问运行测试的托管网站。结果被报告回服务器并在控制台中显示。
- en: If all this sounds complicated to you – you would be right, it was. The job
    of these runners was to make this process as reliable as possible. They also tried
    to be user-friendly and hide the underlying complexity as much as possible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来很复杂——你是对的，它确实很复杂。这些运行器的任务是使这个过程尽可能可靠。它们还试图尽可能用户友好，并尽可能隐藏底层复杂性。
- en: Today, test runners like Karma are not really necessary. Instead, most test
    runners such as **AVA** stay in the console by leveraging Node.js. When JavaScript
    code requires the browser API, which is most like the DOM API, the runner just
    emulates these missing APIs. As a result of the emulation, the JavaScript code
    that is tested can run as it would in the browser, but everything remains in Node.js.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，像Karma这样的测试运行器实际上并不是必需的。相反，大多数测试运行器，如**AVA**，通过利用Node.js留在控制台。当JavaScript代码需要浏览器API，这最像DOM
    API时，运行器只是模拟这些缺失的API。由于模拟的结果，被测试的JavaScript代码可以像在浏览器中一样运行，但一切都在Node.js中保持。
- en: While the part about emulating the DOM API sounds great, it is actually not
    within the scope of a test runner. Test runners are really only focused on running
    the tests. Instead, developers establish the emulation part somewhat or pick a
    full test framework. A full test framework should already have figured out things
    such as the DOM API emulation so that they can be easily added, or they are already
    part of the standard installation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于模拟DOM API的部分听起来很棒，但实际上它并不在测试运行器的范围内。测试运行器实际上只专注于运行测试。相反，开发者会建立模拟部分或者选择一个完整的测试框架。一个完整的测试框架应该已经解决了诸如DOM
    API模拟等问题，以便它们可以轻松添加，或者它们已经是标准安装的一部分。
- en: A full test framework not only includes a test runner but also things such as
    an assertion library. So far, we’ve only used some kind of `assert` function with
    a proposed behavior. A full assertion library would give us a set of functions
    that makes the debugging process in the case of a failed assertion quite easy.
    Already from the test output, we would see which assertion was broken – and why.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的测试框架不仅包括测试运行器，还包括断言库等。到目前为止，我们只使用了一些具有建议行为的 `assert` 函数。一个完整的断言库将为我们提供一组函数，使得在断言失败的情况下调试过程变得非常容易。从测试输出中，我们就可以看到哪个断言失败了——以及为什么。
- en: An example of a good assertion library is `should`, `expect`, and `assert`.
    The export that you see most often used in test code is `expect`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的断言库的例子是 `should`、`expect` 和 `assert`。在测试代码中最常使用的导出是 `expect`。
- en: 'Using `expect` from the `chai` package, the first two test cases from our preceding
    unit tests could be rewritten as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 `chai` 包的 `expect`，可以将我们前面的单元测试的前两个测试用例重写如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The beauty of the rewritten code is that it almost reads like text. Even somebody
    with less experience in the testing framework, JavaScript, or Node.js could identify
    what the test does – and even more importantly – what it tries to verify. The
    chaining of the expectation using the member (`.`) operator is one of the things
    that makes Chai such a popular assertion library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写的代码之美在于它几乎就像文本一样易读。即使是那些在测试框架、JavaScript 或 Node.js 方面经验较少的人也能识别出测试做了什么——更重要的是——它试图验证什么。使用成员运算符（`.`）链式调用期望是使
    Chai 成为如此受欢迎的断言库的原因之一。
- en: Every testing framework comes with an assertion library. Some frameworks may
    even let the user decide which assertion library to use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试框架都附带一个断言库。有些框架甚至允许用户决定使用哪个断言库。
- en: 'Now that we know all the basics of testing JavaScript-based applications, we
    should explore some of the tools to actually implement such tests. We will start
    with one of the most commonly used testing utilities: the Jest test framework.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基于 JavaScript 的应用程序测试的所有基础知识，我们应该探索一些实际实施此类测试的工具。我们将从最常用的测试实用工具之一：Jest
    测试框架开始。
- en: Using the Jest framework
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 框架
- en: '**Jest** is a modern test framework that was authored by Facebook to fully
    leverage Node.js for running tests. It should have the power to run all the tests
    required at Facebook without requiring a diploma in engineering to understand,
    control, or modify it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是一个由 Facebook 编写的现代测试框架，旨在充分利用 Node.js 来运行测试。它应该有运行 Facebook 所需的所有测试的能力，而无需拥有工程学学位来理解、控制或修改它。'
- en: 'To use Jest, you need to install the `jest` package from npm:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Jest，你需要从 npm 安装 `jest` 包：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This allows you to use the `jest` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你使用 `jest` 命令行工具。理想情况下，使用 `npx` 运行它，就像我们使用其他工具一样：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Jest can be configured by providing a `jest.config.js` file. The easiest way
    to create this kind of file is by using the `jest` tool with the --`init` flag.
    This will guide us through some questions to create a suitable configuration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 可以通过提供一个 `jest.config.js` 文件来配置。创建此类文件的最简单方法是通过使用带有 --`init` 标志的 `jest`
    工具。这将引导我们回答一些问题以创建合适的配置：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we’ve instructed Jest to change the `test` script in `package.json`.
    Now, when we run `npm run test` or just `npm test` in our terminal for the current
    project, Jest will start. The options for the test environment and coverage are
    interesting to us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指示 Jest 修改 `package.json` 中的 `test` 脚本。现在，当我们在终端中运行 `npm run test`
    或 `npm test` 以运行当前项目的测试时，Jest 将启动。测试环境和覆盖率选项对我们来说很有趣。
- en: 'Let’s have a look at the essential parts of the generated configuration file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的配置文件的基本部分：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The generated configuration file also contains a lot of comments and commented-out
    options. This way, you can configure Jest without having to consult the official
    documentation website.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的配置文件还包含许多注释和注释选项。这样，你可以在不查阅官方文档网站的情况下配置 Jest。
- en: 'The given configuration has just one problem… The selected `jsdom` environment
    only works when a special package called `jest-environment-jsdom` is installed.
    This has been changed in version *28* of Jest and is, unfortunately, not done
    automatically:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的配置有一个问题……选定的 `jsdom` 环境仅在安装了名为 `jest-environment-jsdom` 的特殊包时才工作。这已经在 Jest
    的第 *28* 版本中更改，但遗憾的是，这不是自动完成的：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Luckily, the error messages in Jest are usually quite good and very helpful.
    Even without knowing these things, we’ll get proper messages that tell us exactly
    what to do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Jest 中的错误消息通常相当好，非常有帮助。即使不知道这些事情，我们也会得到正确的消息，告诉我们确切应该做什么。
- en: One last thing we should consider is using Babel for code transformations. These
    transformations are unnecessary if we write pure Node.js-compatible code (such
    as by using CommonJS). Otherwise, code transformations are necessary. In general,
    Jest uses code transformations to make any kind of used code – not only plain
    JavaScript but also flavors such as TypeScript and Flow – usable without requiring
    special treatment upfront.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该考虑的是使用 Babel 进行代码转换。如果我们编写纯 Node.js 兼容的代码（例如，通过使用 CommonJS），则这些转换是不必要的。否则，代码转换是必要的。一般来说，Jest
    使用代码转换来使任何类型的使用的代码——不仅限于纯 JavaScript，还包括 TypeScript 和 Flow 等变体——在无需特殊处理的情况下即可使用。
- en: 'First, let’s install the `babel-jest` plugin and the required `@``babel/core`
    package:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 `babel-jest` 插件和所需的 `@babel/core` 包：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s extend `jest.config.js` with the `transform` configuration section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过 `transform` 配置部分扩展 `jest.config.js`：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The new section tells Jest to use the `babel-jest` transformer for all files
    ending with `.js`. Also add a `.babelrc` file as discussed in [*Chapter 4*](B18989_04.xhtml#_idTextAnchor042),
    *Using Different Flavors* *of JavaScript*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 新的配置部分告诉 Jest 使用 `babel-jest` 转换器来转换所有以 `.js` 结尾的文件。另外，添加一个 `.babelrc` 文件，如
    [*第 4 章*](B18989_04.xhtml#_idTextAnchor042)，*使用 JavaScript 的不同* *变体* 中所述：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this configuration, Babel will properly transform the given files. The
    test code can now be written as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，Babel 将正确转换指定的文件。现在可以按如下方式编写测试代码：
- en: pure.test.js
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: pure.test.js
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While Jest also supports a `test` function as in our pseudo implementation introduced
    in the *Considering the testing pyramid section*, the `it` function is much more
    commonly seen. Note that Jest comes with its own integrated assertion library,
    which uses the `expect` function. The `expect` function is also called a **matcher**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Jest 也支持与我们在 *考虑测试金字塔部分* 中引入的伪实现中的 `test` 函数一样使用 `test` 函数，但 `it` 函数更为常见。请注意，Jest
    内置了自己的断言库，它使用 `expect` 函数。`expect` 函数也被称作 **匹配器**。
- en: Matchers
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器
- en: For our simple example, the matcher will only have to deal with strings and
    numbers. In general, however, any kind of JavaScript input, such as arrays or
    objects, can be matched and asserted. The `expect` function has some helpers to
    deal with, for instance, object equality (`toBe`), as in, having the same reference,
    and equivalence (`toEqual`), as in, having the same content.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单示例，匹配器只需要处理字符串和数字。然而，通常情况下，任何类型的 JavaScript 输入，如数组或对象，都可以进行匹配和断言。`expect`
    函数有一些辅助函数来处理，例如，对象相等（`toBe`），即具有相同的引用，以及等价（`toEqual`），即具有相同的内容。
- en: 'Let’s run this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great – our code works. By default, Jest will look for all files ending with
    `.test.js`. By convention, `.spec.js` files would also work. The convention used
    can be changed though.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们的代码可以正常工作。默认情况下，Jest 会查找所有以 `.test.js` 结尾的文件。按照惯例，`.spec.js` 文件也可以使用。不过，使用的惯例是可以改变的。
- en: Today, Jest is arguably the most used testing framework. However, especially
    older projects potentially use something else. A very solid and common occurrence
    here is Mocha. Like Jest, it is also a testing framework, but with a few key differences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jest 可能是使用最广泛的测试框架。然而，特别是较老的项目可能会使用其他框架。这里一个非常稳固且常见的例子是 Mocha。与 Jest 一样，它也是一个测试框架，但有一些关键的区别。
- en: Using the Mocha framework
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 框架
- en: '`jsdom`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsdom`。'
- en: 'To use Mocha, you need to install the `mocha` package from npm:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Mocha，你需要从 npm 安装 `mocha` 包：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This allows you to use the `mocha` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你使用 `mocha` 命令行工具。理想情况下，使用 `npx` 运行它，就像我们使用其他工具一样：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, not much is working. By default, Mocha follows a different convention
    from Jest. Here, we need to specify a different pattern or place our tests in
    a folder named `test`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有什么起作用。默认情况下，Mocha 使用与 Jest 不同的约定。在这里，我们需要指定不同的模式或将测试放在名为 `test` 的文件夹中。
- en: 'What we definitely need to do is to include Babel for code transformations.
    This works a bit differently than with Jest. Instead of a dedicated plugin, we
    only integrate the `@babel/register` package, which will automatically transform
    any code when a module is loaded:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对需要做的是为代码转换包含 Babel。这与 Jest 的使用略有不同。我们不是使用专门的插件，而是仅集成 `@babel/register` 包，该包将在模块加载时自动转换任何代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can copy the `.babelrc` file that we used previously with Jest. For
    Mocha, the configuration can be placed in a file called `.mocharc.js`. Setting
    up the configuration file to always require the `@babel/register` package first
    looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以复制之前与 Jest 一起使用的 `.babelrc` 文件。对于 Mocha，配置可以放在一个名为 `.mocharc.js` 的文件中。将配置文件设置为始终首先要求
    `@babel/register` 包的设置如下所示：
- en: .mocharc.js
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: .mocharc.js
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Mocha is a kind of special testing framework, as it does not come with an assertion
    library. Instead, it relies on other assertion libraries. As long as it throws
    an exception in case of a mismatch, the assertion works.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一种特殊的测试框架，因为它不附带断言库。相反，它依赖于其他断言库。只要在出现不匹配时抛出异常，断言就会生效。
- en: 'To write tests with Mocha without using a special assertion library besides
    the one that already comes with Node.js, we would write our tests as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Mocha 编写测试而不使用除 Node.js 已经附带的特殊断言库之外的其他断言库，我们可以这样编写测试：
- en: pure.test.js
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pure.test.js
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the `it` functions follow the same behavior as in Jest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`it` 函数的行为与 Jest 中的一致。
- en: 'Now, let us run `mocha` via `npm test`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们通过 `npm test` 运行 `mocha`:'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compared to Jest, we get a little bit less output. Still, all the relevant information
    is presented and if there were an error, we would have gotten all the necessary
    information to identify and fix the issue. The crucial difference between Jest
    and Mocha is that Jest really breaks down the tests according to their associated
    test module, while Mocha just presents the results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Jest 相比，我们得到的输出少一些。尽管如此，所有相关信息都得到了展示，如果有错误，我们就会得到所有必要的信息来识别和修复问题。Jest 和 Mocha
    之间的关键区别在于，Jest 会根据相关的测试模块真正地分解测试，而 Mocha 只是展示结果。
- en: Mocha is actually quite feature-packed and everything but lightweight. A more
    streamlined option is to avoid using a full testing framework and instead go for
    a test runner only. One option is to use AVA.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 实际上功能非常丰富，但并非轻量级。一个更简洁的选项是避免使用完整的测试框架，而是仅使用测试运行器。一个选项是使用 AVA。
- en: Using the AVA test runner
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AVA 测试运行器
- en: AVA is a modern test runner for Node.js. It stands out because of its ability
    to embrace new JavaScript language features and cutting-edge properties of Node.js,
    such as process isolation. In this way, AVA executes tests very quickly and reliably.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: AVA 是一个针对 Node.js 的现代测试运行器。它之所以突出，是因为它能够拥抱新的 JavaScript 语言特性以及 Node.js 的前沿特性，如进程隔离。因此，AVA
    以非常快速和可靠的方式执行测试。
- en: 'To use AVA, you need to install the `ava` package from npm:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 AVA，您需要从 npm 安装 `ava` 包：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This allows you to use the `ava` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您使用 `ava` 命令行工具。理想情况下，使用 `npx` 运行它，就像我们使用其他工具一样：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While Mocha and Jest could also be installed globally, AVA only works in projects
    as a local dependency. As this is the better setup anyway, there should be no
    practical downside from this constraint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Mocha 和 Jest 也可以全局安装，但 AVA 只在项目作为本地依赖项时工作。鉴于这已经是更好的设置，因此从这个限制中不应有实际缺点。
- en: 'As mentioned, AVA is built quite closely on Node.js – following its conventions
    and rules wherever possible. In this regard, AVA also allows us quite quickly
    to adapt ESM instead of CommonJS. By modifying `package.json` for the project,
    we get immediate support for using ESM in our tests, too:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AVA 与 Node.js 构建得非常紧密——尽可能遵循其约定和规则。在这方面，AVA 也允许我们快速适应 ESM 而不是 CommonJS。通过修改项目的
    `package.json`，我们立即支持在测试中使用 ESM：
- en: package.json
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, AVA looks for files that follow the same pattern as Jest. Therefore,
    files that end with `.test.js` and `.spec.js` will be found among others. There
    is no need to configure AVA or place the tests in a separate directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，AVA 会寻找与 Jest 相同模式的文件。因此，以 `.test.js` 和 `.spec.js` 结尾的文件将与其他文件一起被找到。无需配置
    AVA 或将测试放在单独的目录中。
- en: The other thing that AVA does is to provide a function as a default export from
    the `ava` package. This function is needed to declare tests. Each test then receives
    a so-called test context as a callback parameter for its implementation. This
    way, AVA feels a lot more explicit and less magical than the other solutions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: AVA 还提供了一种作为 `ava` 包默认导出的函数。这个函数用于声明测试。每个测试都接收一个所谓的测试上下文作为其实现的回调参数。这样，AVA 感觉比其他解决方案更加明确和不太神秘。
- en: 'Let’s see how we can write the tests with AVA:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 AVA 编写测试：
- en: pure.test.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: pure.test.js
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Overall, the structure is similar to the previous two full frameworks. Still,
    AVA is just a runner and misses things such as special assertion libraries, options
    for mocking, and snapshots, among other things.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tests, we can adjust the `test` script in `package.json`. Triggering
    the `ava` utility, a run with the AVA test runner looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we covered three tools to run some code-centric tests, let’s explore
    some options for running UI tests, too. We will start with **Playwright**, which
    is a modern library to automate the behavior of web browsers such as Google Chrome
    or Firefox.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Using Playwright for visual tests
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is not only a great basis for running logical tests but also for verifying
    visuals, such as those of a website running in a browser. A modern approach for
    browser automation is Playwright.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Playwright, you need to install the `playwright` package from npm:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `playwright` package enables you to use Playwright in an existing application,
    which could also be inside existing tests such as unit tests executed with Jest
    using the `jest-playwright-preset` package.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'An even better setup can be achieved by using the `@playwright/test` test runner
    package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This allows you to use the `playwright` command-line utility. Ideally, run
    it with `npx` as we did with the other tools:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running this will look for all files matching the same conventions as previously
    noted in the Jest and AVA sections. Every file ending with `.test.js` or `.spec.js`
    will be included. Additionally, the Playwright test runner is also capable of
    evaluating TypeScript files. The runner therefore also includes `.test.ts` and
    `.spec.ts` files in its default lookup.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple test run again. We’ll run tests against a public website
    available at [https://microfrontends.art](https://microfrontends.art). The test
    would work against a local website running on localhost, too:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: mf.test.ts
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The structure feels a bit similar to AVA. As with AVA, we are using explicit
    imports to create the test infrastructure. We also need to use the parameter of
    the test’s callback to actually do something useful with the website using the
    `page` object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the `test` script in `package.json` and run the test provided:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Yet another option to write end-to-end tests is Cypress. This promises to be
    even more convenient and also equipped to test individual components, too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Using Cypress for end-to-end testing
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress is a focused, end-to-end testing framework that also comes with the
    ability to test individual UI components. It tries to be different by mostly avoiding
    browser automation. Instead, its test runner is located directly inside the browser.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Cypress, you need to install the `cypress` package from npm:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This allows you to use the `cypress` command-line utility. Ideally, run it
    with `npx` as we did with the other tools:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Cypress is at its heart a graphical tool. As such, we are first introduced
    to a small configurator that allows us to set up our project. The configurator
    is shown in *Figure 7**.2*. Picking **E2E Testing** will give you the ability
    to influence what files are written:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cypress 核心是一个图形工具。因此，我们首先接触到的是一个小的配置器，它允许我们设置我们的项目。配置器在 *图 7.2* 中显示。选择 **端到端测试**
    将使您能够影响要编写的文件： '
- en: '![Figure 7.2 – The Cypress configurator on opening it for the first time ](img/Figure_7.2_B18989.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 第一次打开 Cypress 配置器](img/Figure_7.2_B18989.jpg)'
- en: Figure 7.2 – The Cypress configurator on opening it for the first time
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 第一次打开 Cypress 配置器
- en: The configurator also lets you pick a browser where the tests should actually
    be run. Right now, **Chrome**, **Edge**, **Electron**, and **Firefox** are supported.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 配置器还允许您选择测试实际运行的浏览器。目前，**Chrome**、**Edge**、**Electron** 和 **Firefox** 受支持。
- en: 'At this time, we can add our first test – in the context of Cypress, referred
    to as a spec or specification. We’ll use the same kind of test that we’ve added
    as an example for Playwright:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们可以添加我们的第一个测试——在 Cypress 的上下文中，被称为 spec 或 specification。我们将使用与 Playwright
    例子中添加的相同类型的测试：
- en: mf.cy.js
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: mf.cy.js
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As seen in the preceding small test, the whole test structure is implicit.
    The main downside of this is that there is no good IDE support to help with proper
    typing – that is, type information that can be used by TypeScript. A good way
    out of it is to install the `typescript` package in the project and create a `tsconfig.json`
    that teaches TypeScript about Cypress:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的小测试所示，整个测试结构是隐式的。这种做法的主要缺点是没有良好的 IDE 支持，无法帮助进行适当的类型检查——即 TypeScript 可以使用的类型信息。一种解决办法是在项目中安装
    `typescript` 包并创建一个 `tsconfig.json` 文件，让 TypeScript 了解 Cypress：
- en: tsconfig.json
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: tsconfig.json
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, you can rename the test file to end with `.ts` (in our example, `mf.cy.ts`)
    and enjoy improved autocompletion in most editors and IDEs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将测试文件重命名为以 `.ts` 结尾（在我们的示例中，`mf.cy.ts`），并在大多数编辑器和 IDE 中享受改进的自动完成功能。
- en: 'Running this test will yield a graphical result. In *Figure 7**.3*, you can
    see the output from running the test in the selected browser. This is the key
    point of Cypress. An end-to-end test never leaves the visual area and allows us
    to directly interact with the test within its visual boundaries. This makes tests
    written with Cypress not only very beginner-friendly but also quite easy to debug:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试将生成图形结果。在 *图 7.3* 中，您可以看到在所选浏览器中运行测试的输出。这是 Cypress 的关键点。端到端测试永远不会离开视觉区域，并允许我们在其视觉边界内直接与测试交互。这使得使用
    Cypress 编写的测试不仅非常适合初学者，而且调试起来也相当容易：
- en: '![Figure 7.3 – Running the test directly in the browser ](img/Figure_7.3_B18989.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 在浏览器中直接运行测试](img/Figure_7.3_B18989.jpg)'
- en: Figure 7.3 – Running the test directly in the browser
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 在浏览器中直接运行测试
- en: 'If you want to run the locally available tests directly and without visual
    interaction, then you can also use the `run` command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接运行本地可用的测试而不进行视觉交互，您也可以使用 `run` 命令：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is especially handy in non-local environments, such as a CI/CD pipeline
    for validating software builds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在非本地环境中，例如用于验证软件构建的 CI/CD 管道中，这尤其方便。
- en: With this in mind, let’s recap what we learned in this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们回顾一下在本章中学到的内容。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about which different types of testing we can automate
    and how important these types are for software projects to succeed. You’ve seen
    the popular tools that exist to help us cover our projects. By following the testing
    pyramid, you should be able to decide what tests you need to focus on to make
    your project as reliable as possible.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了我们可以自动化的不同类型的测试以及这些类型对于软件项目成功的重要性。您看到了现有的流行工具，这些工具可以帮助我们覆盖我们的项目。通过遵循测试金字塔，您应该能够决定需要关注哪些测试，以使您的项目尽可能可靠。
- en: By using the power test frameworks such as Jest or Mocha or a flexible runner
    such as AVA, you can automate a lot of different things – from unit tests to full
    end-to-end tests. Dedicated end-to-end test frameworks such as Playwright or Cypress
    also come with their own runners – which makes sense for complex visual tests
    in particular. In the unit and integration testing space, Jest comes in handy.
    It also allows us to quickly integrate other flavors of JavaScript or customize
    a lot of different features.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Jest或Mocha等强大的测试框架，或者使用AVA等灵活的运行器，你可以自动化很多不同的事情——从单元测试到端到端测试。像Playwright或Cypress这样的专用端到端测试框架也自带自己的运行器——这对于复杂的视觉测试尤其有意义。在单元和集成测试领域，Jest非常方便。它还允许我们快速集成其他JavaScript版本或自定义许多不同的功能。
- en: In the next chapter, we will finally also publish our own packages – to the
    public registry and other custom registries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们最终也将发布我们自己的包——到公共注册表和其他自定义注册表。
- en: 'Part 3: Advanced Topics'
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：高级主题
- en: In this part, you’ll dive into advanced topics such as publishing your own npm
    packages and structuring your projects into a shared code base such as a monorepo.
    You’ll see what options exist and how tools such as Nx, Lerna, or Turbo can help
    you set up projects that can scale.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将深入研究高级主题，例如发布自己的npm包以及将你的项目结构化为共享代码库，如monorepo。你将了解有哪些选项，以及工具如Nx、Lerna或Turbo如何帮助你设置可扩展的项目。
- en: To round off your knowledge about Node.js and its ecosystem, this part will
    also teach you how to make use of any kind of code compiled as WebAssembly within
    Node.js, as well as which other runtimes can be used as the basis for web development
    tooling.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你对Node.js及其生态系统有更全面的了解，这一部分还将教你如何在Node.js中使用任何编译为WebAssembly的代码，以及哪些其他运行时可以用作Web开发工具的基础。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分包括以下章节：
- en: '[*Chapter 8*](B18989_08.xhtml#_idTextAnchor079), *Publishing npm Packages*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18989_08.xhtml#_idTextAnchor079), *发布npm包*'
- en: '[*Chapter 9*](B18989_09.xhtml#_idTextAnchor088), *Structuring Code in Monorepos*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18989_09.xhtml#_idTextAnchor088), *在Monorepos中组织代码*'
- en: '[*Chapter 10*](B18989_10.xhtml#_idTextAnchor098), *Integrating Native Code
    with WebAssembly*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18989_10.xhtml#_idTextAnchor098), *将原生代码与WebAssembly集成*'
- en: '[*Chapter 11*](B18989_11.xhtml#_idTextAnchor105)*,* *Using Alternative Runtimes*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18989_11.xhtml#_idTextAnchor105)*,* *使用替代运行时*'
