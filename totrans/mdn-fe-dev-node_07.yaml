- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Reliability with Testing Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can actually write and build our code for the browser efficiently,
    it makes sense to also consider verifying the code’s output. Does it really fulfill
    the given requirements? Has anything changed in terms of the expected outcome?
    Does the code crash when unexpected values are passed in?
  prefs: []
  type: TYPE_NORMAL
- en: What we need to answer these questions is testing. Testing can mean a lot of
    things – and depending on who you ask, you’ll get a different answer to the question
    “What should we test?” In this chapter, we’ll walk through the different options
    that interest us as developers. We’ll see what tools exist to automate these tests
    and how we can set them up and use them practically.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our journey into the testing space with a discussion on the beloved
    testing pyramid. We will then continue by learning about the types of test tools
    – most notably, pure runners and whole frameworks. Finally, we’ll cover some of
    the most popular tools in this space.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know which testing framework or test runner
    to choose for your programming needs, along with the pros and cons of each option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Considering the testing pyramid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing test runners versus frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Jest framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Mocha framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AVA test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Playwright for visual tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress for end-to-end testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3DW9yoV](https://bit.ly/3DW9yoV).
  prefs: []
  type: TYPE_NORMAL
- en: Considering the testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, more and more types of software testing have been identified
    and added to the standard repertoire of software projects and testing professionals
    such as quality assurance engineers. A powerful tool to categorize and order the
    most common types of software testing is the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid arranges the different types of testing by their visibility
    and effort. Higher layers of the pyramid require more effort but have greater
    visibility. Tests that are placed in the lower layers of the pyramid should be
    written a lot more – after all, these are the foundations of the pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: 'An illustration of the testing pyramid is shown in *Figure 7**.1*. The basis
    of the testing pyramid is formed by unit tests, which provide enough reliability
    to run components and integration tests on top of them later. Finally, UI tests
    (quite often referred to as end-to-end tests) can be run to verify that the solution
    works for end users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The testing pyramid with three layers of automatic testing ](img/Figure_7.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The testing pyramid with three layers of automatic testing
  prefs: []
  type: TYPE_NORMAL
- en: Usually, end-to-end tests refer to tests that use the interface as presented
    to the end user. In the case of a web application, this would be the actual website.
    By their nature, end-to-end tests are usually black-box tests. The whole system
    is treated as is, so with everything running as close to the production environment
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Black-box tests
  prefs: []
  type: TYPE_NORMAL
- en: The notion of a black box comes from the so-called black box approach. This
    is a common technique to analyze an open system by varying the input and measuring
    the output. This approach makes sense when the internal workings are either not
    known or not accessible. Likewise, black-box testing is also performed without
    changing the application’s internal workings.
  prefs: []
  type: TYPE_NORMAL
- en: Variations of end-to-end tests focus on performance (*load tests*) or security
    (*penetration tests*). While the former can be quite tricky and expensive to run,
    the latter should be performed regularly to shield against potential attacks.
    One of the greatest risks for companies is to be hacked. Not only will this include
    the theft of precious data but it will also have a strong negative impact on the
    company’s brand. To help defend against scenarios like this, sometimes gray-box
    testing is used, which, unlike black-box tests, understands certain documented
    operations of the system.
  prefs: []
  type: TYPE_NORMAL
- en: One challenge with testing is that many of the terms used, such as integration
    or component tests, are not universally defined. For instance, some people consider
    an integration test to be something very narrow – testing the integration with
    one external part at a time. Other people may say that an integration test should
    cover the integration with all the external parts. Consequently, it is quite important
    to carefully review and define these terms before using them in a project.
  prefs: []
  type: TYPE_NORMAL
- en: When we refer to unit tests, we mean tests for a single unit (such as a function)
    of the project – only one specific part of it. Usually, this unit carries some
    logic that can be tested specifically. Everything that is not related to this
    one unit has to be controlled. While some unit tests can be written like black-box
    tests, most unit tests will require a detailed understanding of the internal workings.
    This way, the behavior of the tested unit can be controlled as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: pure.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the function is very well suited for a unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: It is exported, so we can access it from another module containing the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not use anything outside of the function – it’s a so-called pure function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logic is sufficiently complex to test against a set of predefined test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unit tests for the `pickSmallestNumber` function could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the code could look like this. The functions used are defined
    nowhere and the preceding code would not run as presented.
  prefs: []
  type: TYPE_NORMAL
- en: For these tests, we introduced a new function, `test`, which takes a description
    of the test and the code in the form of a function for running the test. We also
    introduced an assertion function, `assert`, which could be taken from the Node.js
    built into the `assert` module. The proposed `assert` function accepts a Boolean
    input – throwing an exception if the input is `false`. The testing tools and frameworks
    we’ll look at will replace these constructs with more expressive and elegant alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the actual testing and test area differences, the tooling choices also
    offer a few variations. One of the most crucial ones is the difference between
    a full testing framework and a test runner.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing test runners versus frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, tests for JavaScript targeting web browsers could not be just
    written and run automatically. The main reason was that this involved dealing
    with a real browser. There was no way to just *pretend to run in the browser*.
    For this reason alone, the first tools in that space have either been scripts
    or whole websites evaluating JavaScript or browser automation tools. The latter
    actually forms its own category – being at the heart of modern end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: The main driver for running the tests – historically, for starting everything
    that needs to be running to actually perform tests – is called a test runner.
    One of the first very successful test runners in the JavaScript space was **Karma**.
    The job of Karma was to spin up a server that runs a website hosting the tests,
    which are targeting JavaScript code that should run in a browser. Karma then opened
    available browsers to access the hosted website running the tests. The results
    were reported back to the server and shown in the console.
  prefs: []
  type: TYPE_NORMAL
- en: If all this sounds complicated to you – you would be right, it was. The job
    of these runners was to make this process as reliable as possible. They also tried
    to be user-friendly and hide the underlying complexity as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Today, test runners like Karma are not really necessary. Instead, most test
    runners such as **AVA** stay in the console by leveraging Node.js. When JavaScript
    code requires the browser API, which is most like the DOM API, the runner just
    emulates these missing APIs. As a result of the emulation, the JavaScript code
    that is tested can run as it would in the browser, but everything remains in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: While the part about emulating the DOM API sounds great, it is actually not
    within the scope of a test runner. Test runners are really only focused on running
    the tests. Instead, developers establish the emulation part somewhat or pick a
    full test framework. A full test framework should already have figured out things
    such as the DOM API emulation so that they can be easily added, or they are already
    part of the standard installation.
  prefs: []
  type: TYPE_NORMAL
- en: A full test framework not only includes a test runner but also things such as
    an assertion library. So far, we’ve only used some kind of `assert` function with
    a proposed behavior. A full assertion library would give us a set of functions
    that makes the debugging process in the case of a failed assertion quite easy.
    Already from the test output, we would see which assertion was broken – and why.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a good assertion library is `should`, `expect`, and `assert`.
    The export that you see most often used in test code is `expect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `expect` from the `chai` package, the first two test cases from our preceding
    unit tests could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of the rewritten code is that it almost reads like text. Even somebody
    with less experience in the testing framework, JavaScript, or Node.js could identify
    what the test does – and even more importantly – what it tries to verify. The
    chaining of the expectation using the member (`.`) operator is one of the things
    that makes Chai such a popular assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: Every testing framework comes with an assertion library. Some frameworks may
    even let the user decide which assertion library to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know all the basics of testing JavaScript-based applications, we
    should explore some of the tools to actually implement such tests. We will start
    with one of the most commonly used testing utilities: the Jest test framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Jest framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jest** is a modern test framework that was authored by Facebook to fully
    leverage Node.js for running tests. It should have the power to run all the tests
    required at Facebook without requiring a diploma in engineering to understand,
    control, or modify it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Jest, you need to install the `jest` package from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to use the `jest` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Jest can be configured by providing a `jest.config.js` file. The easiest way
    to create this kind of file is by using the `jest` tool with the --`init` flag.
    This will guide us through some questions to create a suitable configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ve instructed Jest to change the `test` script in `package.json`.
    Now, when we run `npm run test` or just `npm test` in our terminal for the current
    project, Jest will start. The options for the test environment and coverage are
    interesting to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the essential parts of the generated configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The generated configuration file also contains a lot of comments and commented-out
    options. This way, you can configure Jest without having to consult the official
    documentation website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given configuration has just one problem… The selected `jsdom` environment
    only works when a special package called `jest-environment-jsdom` is installed.
    This has been changed in version *28* of Jest and is, unfortunately, not done
    automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, the error messages in Jest are usually quite good and very helpful.
    Even without knowing these things, we’ll get proper messages that tell us exactly
    what to do.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing we should consider is using Babel for code transformations. These
    transformations are unnecessary if we write pure Node.js-compatible code (such
    as by using CommonJS). Otherwise, code transformations are necessary. In general,
    Jest uses code transformations to make any kind of used code – not only plain
    JavaScript but also flavors such as TypeScript and Flow – usable without requiring
    special treatment upfront.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install the `babel-jest` plugin and the required `@``babel/core`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s extend `jest.config.js` with the `transform` configuration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The new section tells Jest to use the `babel-jest` transformer for all files
    ending with `.js`. Also add a `.babelrc` file as discussed in [*Chapter 4*](B18989_04.xhtml#_idTextAnchor042),
    *Using Different Flavors* *of JavaScript*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this configuration, Babel will properly transform the given files. The
    test code can now be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: pure.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While Jest also supports a `test` function as in our pseudo implementation introduced
    in the *Considering the testing pyramid section*, the `it` function is much more
    commonly seen. Note that Jest comes with its own integrated assertion library,
    which uses the `expect` function. The `expect` function is also called a **matcher**.
  prefs: []
  type: TYPE_NORMAL
- en: Matchers
  prefs: []
  type: TYPE_NORMAL
- en: For our simple example, the matcher will only have to deal with strings and
    numbers. In general, however, any kind of JavaScript input, such as arrays or
    objects, can be matched and asserted. The `expect` function has some helpers to
    deal with, for instance, object equality (`toBe`), as in, having the same reference,
    and equivalence (`toEqual`), as in, having the same content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Great – our code works. By default, Jest will look for all files ending with
    `.test.js`. By convention, `.spec.js` files would also work. The convention used
    can be changed though.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Jest is arguably the most used testing framework. However, especially
    older projects potentially use something else. A very solid and common occurrence
    here is Mocha. Like Jest, it is also a testing framework, but with a few key differences.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Mocha framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jsdom`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Mocha, you need to install the `mocha` package from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to use the `mocha` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, not much is working. By default, Mocha follows a different convention
    from Jest. Here, we need to specify a different pattern or place our tests in
    a folder named `test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we definitely need to do is to include Babel for code transformations.
    This works a bit differently than with Jest. Instead of a dedicated plugin, we
    only integrate the `@babel/register` package, which will automatically transform
    any code when a module is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can copy the `.babelrc` file that we used previously with Jest. For
    Mocha, the configuration can be placed in a file called `.mocharc.js`. Setting
    up the configuration file to always require the `@babel/register` package first
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .mocharc.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Mocha is a kind of special testing framework, as it does not come with an assertion
    library. Instead, it relies on other assertion libraries. As long as it throws
    an exception in case of a mismatch, the assertion works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write tests with Mocha without using a special assertion library besides
    the one that already comes with Node.js, we would write our tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: pure.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `it` functions follow the same behavior as in Jest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us run `mocha` via `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compared to Jest, we get a little bit less output. Still, all the relevant information
    is presented and if there were an error, we would have gotten all the necessary
    information to identify and fix the issue. The crucial difference between Jest
    and Mocha is that Jest really breaks down the tests according to their associated
    test module, while Mocha just presents the results.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha is actually quite feature-packed and everything but lightweight. A more
    streamlined option is to avoid using a full testing framework and instead go for
    a test runner only. One option is to use AVA.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AVA test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AVA is a modern test runner for Node.js. It stands out because of its ability
    to embrace new JavaScript language features and cutting-edge properties of Node.js,
    such as process isolation. In this way, AVA executes tests very quickly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use AVA, you need to install the `ava` package from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to use the `ava` command-line utility. Ideally, run it with
    `npx` as we did with the other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While Mocha and Jest could also be installed globally, AVA only works in projects
    as a local dependency. As this is the better setup anyway, there should be no
    practical downside from this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, AVA is built quite closely on Node.js – following its conventions
    and rules wherever possible. In this regard, AVA also allows us quite quickly
    to adapt ESM instead of CommonJS. By modifying `package.json` for the project,
    we get immediate support for using ESM in our tests, too:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, AVA looks for files that follow the same pattern as Jest. Therefore,
    files that end with `.test.js` and `.spec.js` will be found among others. There
    is no need to configure AVA or place the tests in a separate directory.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing that AVA does is to provide a function as a default export from
    the `ava` package. This function is needed to declare tests. Each test then receives
    a so-called test context as a callback parameter for its implementation. This
    way, AVA feels a lot more explicit and less magical than the other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can write the tests with AVA:'
  prefs: []
  type: TYPE_NORMAL
- en: pure.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the structure is similar to the previous two full frameworks. Still,
    AVA is just a runner and misses things such as special assertion libraries, options
    for mocking, and snapshots, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tests, we can adjust the `test` script in `package.json`. Triggering
    the `ava` utility, a run with the AVA test runner looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we covered three tools to run some code-centric tests, let’s explore
    some options for running UI tests, too. We will start with **Playwright**, which
    is a modern library to automate the behavior of web browsers such as Google Chrome
    or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Using Playwright for visual tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is not only a great basis for running logical tests but also for verifying
    visuals, such as those of a website running in a browser. A modern approach for
    browser automation is Playwright.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Playwright, you need to install the `playwright` package from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `playwright` package enables you to use Playwright in an existing application,
    which could also be inside existing tests such as unit tests executed with Jest
    using the `jest-playwright-preset` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even better setup can be achieved by using the `@playwright/test` test runner
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to use the `playwright` command-line utility. Ideally, run
    it with `npx` as we did with the other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running this will look for all files matching the same conventions as previously
    noted in the Jest and AVA sections. Every file ending with `.test.js` or `.spec.js`
    will be included. Additionally, the Playwright test runner is also capable of
    evaluating TypeScript files. The runner therefore also includes `.test.ts` and
    `.spec.ts` files in its default lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple test run again. We’ll run tests against a public website
    available at [https://microfrontends.art](https://microfrontends.art). The test
    would work against a local website running on localhost, too:'
  prefs: []
  type: TYPE_NORMAL
- en: mf.test.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The structure feels a bit similar to AVA. As with AVA, we are using explicit
    imports to create the test infrastructure. We also need to use the parameter of
    the test’s callback to actually do something useful with the website using the
    `page` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the `test` script in `package.json` and run the test provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Yet another option to write end-to-end tests is Cypress. This promises to be
    even more convenient and also equipped to test individual components, too.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cypress for end-to-end testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress is a focused, end-to-end testing framework that also comes with the
    ability to test individual UI components. It tries to be different by mostly avoiding
    browser automation. Instead, its test runner is located directly inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Cypress, you need to install the `cypress` package from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to use the `cypress` command-line utility. Ideally, run it
    with `npx` as we did with the other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Cypress is at its heart a graphical tool. As such, we are first introduced
    to a small configurator that allows us to set up our project. The configurator
    is shown in *Figure 7**.2*. Picking **E2E Testing** will give you the ability
    to influence what files are written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The Cypress configurator on opening it for the first time ](img/Figure_7.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The Cypress configurator on opening it for the first time
  prefs: []
  type: TYPE_NORMAL
- en: The configurator also lets you pick a browser where the tests should actually
    be run. Right now, **Chrome**, **Edge**, **Electron**, and **Firefox** are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this time, we can add our first test – in the context of Cypress, referred
    to as a spec or specification. We’ll use the same kind of test that we’ve added
    as an example for Playwright:'
  prefs: []
  type: TYPE_NORMAL
- en: mf.cy.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding small test, the whole test structure is implicit.
    The main downside of this is that there is no good IDE support to help with proper
    typing – that is, type information that can be used by TypeScript. A good way
    out of it is to install the `typescript` package in the project and create a `tsconfig.json`
    that teaches TypeScript about Cypress:'
  prefs: []
  type: TYPE_NORMAL
- en: tsconfig.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can rename the test file to end with `.ts` (in our example, `mf.cy.ts`)
    and enjoy improved autocompletion in most editors and IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this test will yield a graphical result. In *Figure 7**.3*, you can
    see the output from running the test in the selected browser. This is the key
    point of Cypress. An end-to-end test never leaves the visual area and allows us
    to directly interact with the test within its visual boundaries. This makes tests
    written with Cypress not only very beginner-friendly but also quite easy to debug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Running the test directly in the browser ](img/Figure_7.3_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Running the test directly in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the locally available tests directly and without visual
    interaction, then you can also use the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is especially handy in non-local environments, such as a CI/CD pipeline
    for validating software builds.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s recap what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about which different types of testing we can automate
    and how important these types are for software projects to succeed. You’ve seen
    the popular tools that exist to help us cover our projects. By following the testing
    pyramid, you should be able to decide what tests you need to focus on to make
    your project as reliable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: By using the power test frameworks such as Jest or Mocha or a flexible runner
    such as AVA, you can automate a lot of different things – from unit tests to full
    end-to-end tests. Dedicated end-to-end test frameworks such as Playwright or Cypress
    also come with their own runners – which makes sense for complex visual tests
    in particular. In the unit and integration testing space, Jest comes in handy.
    It also allows us to quickly integrate other flavors of JavaScript or customize
    a lot of different features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally also publish our own packages – to the
    public registry and other custom registries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you’ll dive into advanced topics such as publishing your own npm
    packages and structuring your projects into a shared code base such as a monorepo.
    You’ll see what options exist and how tools such as Nx, Lerna, or Turbo can help
    you set up projects that can scale.
  prefs: []
  type: TYPE_NORMAL
- en: To round off your knowledge about Node.js and its ecosystem, this part will
    also teach you how to make use of any kind of code compiled as WebAssembly within
    Node.js, as well as which other runtimes can be used as the basis for web development
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18989_08.xhtml#_idTextAnchor079), *Publishing npm Packages*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18989_09.xhtml#_idTextAnchor088), *Structuring Code in Monorepos*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18989_10.xhtml#_idTextAnchor098), *Integrating Native Code
    with WebAssembly*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18989_11.xhtml#_idTextAnchor105)*,* *Using Alternative Runtimes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
