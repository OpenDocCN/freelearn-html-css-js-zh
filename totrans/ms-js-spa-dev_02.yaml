- en: Chapter 2. Model-View-Whatever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are a frontend developer, you may not be familiar with the traditional
    software architectural pattern referred to as **Model-View-Controller** (**MVC**).
    Variations of this pattern have found their way into frontend software architectural
    patterns in recent years through such frameworks as *Backbone.js*, *Ember.js*,
    and AngularJS. Regardless of your experience in these areas, this chapter will
    discuss the evolution of the so-called **Model-View-Whatever** (**MVW**) pattern
    and its relevance to SPA development through the following topic areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The original MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model-View-Presentation** (**MVP**)/**Model-View-ViewModel** (**MVVM**) explained'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View-Interactor-Presenter-Entity-Router** (**VIPER**) and other variations
    of MVW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS and MVW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MVW pattern in a SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC software architectural pattern has existed in one form or another since
    the 1970s, but it became more popular and generally accepted with its use in web
    application frameworks such as Ruby on Rails, CakePHP, and Django. MVC frameworks
    like these brought a higher level of organization and sophistication to web application
    development than had been previously conceived, and in doing so, paved the way
    for modern SPA development.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the relevance of MVC to modern SPA development, let's first break
    down the components and ideology of MVC.
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Model* component of MVC deals with an application's data. This includes
    data that is displayed to the user, received from the user, and stored in the
    database. Additionally, the Model handles all **Create, Read, Update, Delete**
    (**CRUD**) operations with the database. Many frameworks also use the Model to
    handle an application's *business logic*, or how the data should be manipulated
    before being saved or viewed, but this is not necessarily a standard.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest terms, the Model in an MVC web application is a representation
    of the application's data. That data may include anything relevant to the application,
    such as the current user's information. Traditional web application frameworks
    use relational databases, such as MySQL, to store data. Modern SPA architectures,
    however, are now gravitating more and more toward document-oriented databases,
    or what is commonly referred to as *NoSQL*. MongoDB and many other NoSQL databases
    use JSON documents to store records. This is great for frontend architectures
    because JavaScript can directly parse JSON, and in the case of the MEAN stack,
    JSON data is native to every tier of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a current web application's user information as an example. We will
    refer to this as the *User Model* **:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A simple JSON document like this will be returned from the database to your
    app for direct parsing by JavaScript. There is no need for any **Structured Query
    Language** (**SQL**) with a document-oriented database, hence the term *NoSQL*.
  prefs: []
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core component of MVC is the *View*, and it is likely the one you are most
    familiar with if you are a frontend developer. The View embodies everything that
    the user interacts with, and in the case of a web application, what the browser
    consumes. Traditional MVC frameworks serve Views from the server, but in the case
    of a JavaScript SPA and using an architecture like the MEAN stack, the View is
    contained entirely in the frontend. From a development and asset management standpoint,
    this makes things a lot easier to maintain because the dual aspect of dealing
    with Views both on the server side and the frontend does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The templates for Views in a JavaScript SPA are written using HTML mixed with
    some type of web template system such as Underscore, Handlebars, or Jade, as only
    a few examples. A web template system allows your HTML markup to be parsed by
    JavaScript and evaluated for expressions that place dynamic data and content within
    your Views. For example, let''s look at a simple Handlebars template using the
    User Model from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Imagine an AJAX request is made for the currently logged-in user's data, and
    the SPA returns the User Model JSON document from a `GET` request. The properties
    from that JSON document can be directly inserted into the View for that request.
    In the case of Handlebars, a set of two opening and closing curly braces (`{{
    ... }}`), or double curly brace notation, is used to identify expressions to be
    parsed within the template. In this case, those expressions are simply the user's
    first name, last name, and title. For more information on Handlebars templates,
    see [handlebarsjs.com](http://handlebarsjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: The Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Controller* component in the MVC pattern is the most variable between
    different frameworks, and thus the most difficult to define with true clarity
    as a general concept. In a traditional web application MVC framework such as Ruby
    on Rails or CakePHP, the Controller takes input from the user in the form of web
    requests, or *actions*, and makes changes to the Model before rendering a new
    response in the View. The following diagram shows the flow of the Controller within
    the MVC paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Controller](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from Wikipedia - [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components))
  prefs: []
  type: TYPE_NORMAL
- en: With this representation of the Controller, it is easy to see how it could encapsulate
    a great deal of application code, and in fact when working with some MVC web frameworks,
    it is often difficult to know where to draw the line between Controller logic,
    business rules for the Model, validation rules for the View, and many other common
    components of a web application. This nebulous nature of the Controller has led
    to the decision of the authors of many modern web frameworks to move away from
    the term *Controller* entirely and adapt a new concept in its place.
  prefs: []
  type: TYPE_NORMAL
- en: The Model and the View components of MVC are easy to understand and to differentiate 
    their purposes within a web application, but the Controller is not so clear-cut.
    Let's now explore some of the concepts that have replaced the Controller in more
    recent web application architectural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: MVP and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *Model-View-Whatever* came about amid the rise of many architectural
    patterns that included a Model and a View, but replaced the Controller with a
    different concept for a core component, or even with a number of them.
  prefs: []
  type: TYPE_NORMAL
- en: MVP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVP is a variation on the MVC architectural pattern in which the *Presenter*
    component replaces the Controller. The Presenter also acts as the Controller in
    this pattern, but it takes on additional responsibility in that it serves to handle
    presentation logic for the View. The reasoning behind this paradigm is to enhance
    the testability of an application by having the View itself contain little to
    no presentation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key difference between MVP and MVC is that a Presenter in MVP has a
    one-to-one relationship with a View, meaning there is a unique Presenter defined
    for every View, whereas MVC allows the Controller to have a one-to-many relationship
    with the View. In other words, MVC allows there to be any number of Views defined
    for a Controller and each View is mapped to an *action* of that Controller. MVP
    maps only one View to a Presenter. Additionally, MVP prohibits a direct relationship
    between the View and the Model, which is again for enhancing testability by keeping
    business logic out of the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVP](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from Wikipedia - [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter))
  prefs: []
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM is yet another variation on the MVC architectural pattern. The *ViewModel*
    in this paradigm is a representation of the Model data for the current user's
    session. Changes to the ViewModel are always made before any changes are made
    to the Model.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM is like MVP in that the View has no knowledge of the Model, but in contrast,
    the View has a many-to-one relationship with the ViewModel. This means that multiple
    Views can be mapped to one ViewModel. The ViewModel component also contrasts with
    the Presenter in MVP in that it has no knowledge of the View. Instead, the View
    has a reference to the ViewModel, which allows it to be updated based on changes
    to the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary distinction of MVVM from the other architectural patterns in regard
    to SPA development, however, is the support of *two-way data binding*. This means
    that changes to the ViewModel are automatically reflected in the View, and changes
    to data in the View by the user are automatically updated in the ViewModel. This
    makes MVVM a more viable pattern for modern SPA development because the View can
    be updated and stays in sync with the ViewModel without the need for a new page
    request, which is what would be required in a traditional MVC or MVP architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from [http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx](http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx))
  prefs: []
  type: TYPE_NORMAL
- en: Data binding will be discussed further in *[Chapter 6](ch06.html "Chapter 6. Data
    Binding, and Why You Should Embrace It"), Data Binding, and Why You Should Embrace
    It*.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the differences between MVC, MVP, and MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you should have a basic understanding of the MVC architectural pattern
    and the MVP and MVVM variations of it. A full understanding of these concepts
    is not necessary to move forward with learning JavaScript SPA development, but
    it is important to have some knowledge of the types of components that can comprise
    a multitier stack. Shown here is a diagram highlighting the key differences between
    the three architectural patterns discussed in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summarizing the differences between MVC, MVP, and MVVM](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from [http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx](http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx))
  prefs: []
  type: TYPE_NORMAL
- en: VIPER and other variations of MVW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary reason that modern architectural patterns have moved away from MVC
    is that the Controller in MVC generally embodies too much application code and
    becomes unwieldy, thereby being difficult to test. This has led to patterns that
    not only replace the Controller with something else, but that add multiple layers
    in its place to further establish a separation of concerns within an application.
  prefs: []
  type: TYPE_NORMAL
- en: VIPER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of *iOS*, Apple's mobile operating system, MVC was long encouraged
    as the pattern to follow. More recently, however, many iOS developers have moved
    away from pure MVC and have adopted patterns that establish more than just three
    layers within an application's architecture. One of these patterns is *VIPER,*
    which stands for **View, Interactor, Presenter, Entity, and Routing** (or Router).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly cover what each of these components is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: Just as with MVC, the View represents the user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactor**: Contains the business logic for a particular behavior and corresponding
    View within the app. An Interactor is similar to a Controller in MVC, but it may
    interact with multiple Models and is not constrained to only one Model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presenter**: Contains logic for the View, just as with MVP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity**: Another word for *Model*, simply used to achieve the *E* in the
    **VIPER** acronym.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: Each request in an app is made using a unique call, and in the
    case of a web application, a URL or *route* from the browser is used to make an
    application request. This layer may also be called the Router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is evident from the description of the components in VIPER that they do
    not actually flow in the order of the acronym itself, but rather are ordered as
    such for aesthetic purposes. The diagram below shows the true flow of the VIPER
    pattern, along with representations of the browser and the database to supplement
    the understanding of this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VIPER](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from [http://khanlou.com/2014/03/model-view-whatever/](http://khanlou.com/2014/03/model-view-whatever/))
  prefs: []
  type: TYPE_NORMAL
- en: Other variations of MVW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have covered the traditional MVC architectural pattern, MVP, MVVM,
    and the more recently contrived VIPER pattern. What should be clear is the patterns
    that have followed MVC do not represent a full paradigm shift, but rather a restructuring
    of the traditional Controller component to embody more clarity, and in the case
    of VIPER, to be divided into a further separation of concerns. The general paradigm
    is not lost in these other patterns because the concept of the Model and the View
    remain intact. This trend is what has led to the generalized paradigmatic term
    *Model-View-Whatever* or MVW.
  prefs: []
  type: TYPE_NORMAL
- en: What we are left with is a multitude of architectural patterns that have been
    conceived as abstractions of MVC. So, what pattern should you choose for a JavaScript
    SPA? This is a highly subjective topic, so the best answer is that you should
    choose a pattern based on the type of app you are building, and also based on
    what makes the most sense to you and what you are most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: The software libraries and frameworks you choose to work with should also factor
    into what pattern you use. In that regard, let's take a look at how AngularJS
    has adapted MVC for its own version of MVW.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS and MVW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS is a frontend JavaScript framework for building web applications,
    and it is a core component of the MEAN stack. It provides developers with the
    ability to use custom HTML attributes and elements to drive behavior within an
    app. It also provides some handy features such as two-way data binding and dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS began as a side project of two Google developers, but eventually became
    an official Google open source project. Since its inception, it has undergone
    many changes in its methodology, including a transition away from touting MVC
    as its pattern of choice. Instead, the AngularJS team now labels it as *a JavaScript
    MVW framework* (at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the declaration of AngularJS to be MVW was in response to extensive
    debate and confusion from the developer community over what pattern AngularJS
    follows. The label itself may not be important to some developers, but it is important
    in highlighting the fact that the architectural pattern AngularJS uses is more
    complex than traditional MVC. AngularJS does, however, include a Controller component,
    among others. Let's take a closer look at what those components are.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS is designed for creating web applications, and as such, it includes
    conceptual components that do not exist in traditional MVC. Also keep in mind
    that AngularJS is a frontend framework only, so it is agnostic of what server-side
    framework and database solution is used.
  prefs: []
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Template** in AngularJS is an HTML document that contains special markup
    allowing it to be parsed to handle dynamic data, as with any web template system.
    AngularJS uses its own proprietary web template system as opposed to a third-party
    one, such as **Handlebars**. Just like Handlebars, however, AngularJS uses double
    curly brace notation to identify expressions within the HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of a simple AngularJS template. You can see that it is constructed
    like a normal HTML document, but it also includes AngularJS expressions. You will
    also notice that there are special HTML attributes prefixed by `ng-`, which convey
    different types of application information to the AngularJS framework.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Directives are special HTML markup that AngularJS uses to drive behaviors within
    the DOM. A directive can be driven by a custom HTML attribute prefixed with `ng`,
    a custom HTML element name such as `<my-element></my-element>`, a comment, or
    a CSS class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own directives for your application, but AngularJS also
    includes some predefined directives for common use cases. For example, the `ng-repeat`
    attribute shown in the previous example uses the built-in `ngRepeat` directive,
    which is used to render template markup once per item while iterating over a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the `users` object is iterated over and properties of each `user`
    are rendered from the template.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Model* is a representation of the variable data available for use within
    expressions in the current View. The Model available to a View is confined to
    a particular **Scope**, or context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an array of `users` is registered on the `$scope` object. This
    exposes the `users` variable to a template that has access to this particular
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Scope is a JavaScript object that defines the Model context for variables
    within the View. As shown in the previous example, `$scope.users` would be accessed
    in the View for that Scope as `{{users}}`.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **Expression** in AngularJS is just like an expression in any web template
    system, as explained earlier. Double curly brace notation is used to identify
    expressions in AngularJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `{{user.first_name}}` and `{{user.last_name}}` are AngularJS
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Compiler** parses Template markup and evaluates it for Directives and
    Expressions to drive the behavior and data within the View. The AngularJS compiler
    is internal to the framework and not something that you will often access or interact
    with directly.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Filter** is used to format an Expression in the View to be presented in
    a particular way. For example, the View may be passed a currency amount from the
    Model in the form of a number. A Filter can be added to the Expression in order
    to format what the user sees as a monetary value with a currency symbol. The pipe
    `|` symbol is used within the double curly brace notation to append a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `total` represents the Expression and `currency` represents
    the Filter.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with traditional MVC, the View in AngularJS is the user interface. Views
    are composed of Templates, and the terms are largely interchangeable in the context
    of an AngularJS application.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data binding in AngularJS is *bidirectional*, or two-way, so data changed in
    the View is updated in the Model, and data changed in the Model is updated in
    the View. This is done automatically, without the need for any additional business
    logic to handle the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Controller is really a *View Controller* in AngularJS, since it is a purely
    frontend framework. Like traditional MVC, the Controller contains business logic,
    but that business logic only pertains to the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `UsersController` could be created, for example, that contains the `users`
    Model shown previously and exposes it in the View through its `$scope` object.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *dependency injection* is commonly used with respect to JavaScript
    as the ability to asynchronously add resources to the current web page. In AngularJS,
    the concept is similar, but only with regard to other AngularJS components. For
    example, Directives, Filters, and Controllers are all injectable.
  prefs: []
  type: TYPE_NORMAL
- en: Injector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Injector** is the container for dependencies and is responsible for finding
    them and adding them when needed. It is decoupled from the application code using
    declarative syntax within the View and is typically not accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Module** is a container for all the main components of an app. It gives
    the app a main namespace reference to all associated Directives, Services, Controllers,
    Filters, and any additional configuration information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If your Module depends on any other Modules, you can add them to the empty array
    parameter shown in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a Module to an SPA using AngularJS, you can simply declare the name
    of the module within your main page''s HTML using the custom `ng-app` attribute
    on your app container element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Service** is a component that differentiates AngularJS from traditional
    MVC in that it is used to contain reusable business logic that you may want to
    share across different Controllers within your app. This helps to keep Controllers
    from becoming too large and complicated, and also allows different parts of the
    app to share some commonly used business logic. Currency conversion, for example,
    is something that could be written as a Service because you may want to use it
    in multiple Controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how the components of AngularJS interact
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Diagram from [https://dzone.com/refcardz/angularjs-essentials](https://dzone.com/refcardz/angularjs-essentials))
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS 2.x (in beta at the time of writing) differs in its architectural
    pattern from v1.x, which is the version represented here.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of the components that comprise the
    AngularJS MVW architectural pattern and how those components pertain to a frontend
    SPA architecture, let's apply some of these MVW principles to a simple JavaScript
    SPA example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the MVW pattern in an SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should now be clear to you that MVW is not a precise architectural pattern,
    but rather a paradigm in which you have a Model, a View, and a nebulous third
    component, or more components, depending on how fine-grained you decide to break
    down your separation of concerns. Everything falling within that gray area is
    based on what type of application you are building, what architectural components
    you are comfortable with as a developer, and what frameworks and libraries you
    are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple JavaScript SPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complexity of your SPA should always be a factor in what technologies you
    use to build it. More to the point, you should not go into every project assuming
    you will always use a certain technology stack or framework. This rule goes for
    the MEAN stack as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the User Model example from earlier, and the accompanying Handlebars
    template View, and actually build it out as an SPA, complete with the AJAX request
    to retrieve the User Model data. For something simple like this, using AngularJS
    and the MEAN stack would definitely be overkill. Let's begin by using the NPM,
    Bower, and Grunt environment you set up in [*Chapter 1*](ch01.html "Chapter 1. Getting
    Organized with NPM, Bower, and Grunt")*Getting Organized NPM, Bower, and Grunt*.
    So how do we proceed?
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Model is the simple JSON object of user data we defined earlier. Rather
    than setting up a database for this, let''s simply place it in a text file and
    name it `user.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the file to the same directory as your `package.json`, `bower.json`, and
    `Gruntfile.js`. Feel free to replace the user information with your own for this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The View for this example will be the web template document we defined earlier
    with a definition list containing user information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Save this file to the root directory of your project as well and name it `user.handlebars`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up frontend assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not creating a complex SPA in this case, so we will not use any frontend
    frameworks, but we do want to install a few libraries to make development easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you followed the examples in [*Chapter 1*](ch01.html "Chapter 1. Getting
    Organized with NPM, Bower, and Grunt"),* Getting Organized with NPM, Bower*, and
    Grunt you should already have jQuery installed via Bower. If you have not yet
    installed it, go ahead and do so now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will use jQuery for handling AJAX requests and DOM manipulation within the
    SPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s install the Handlebars library for parsing our web template View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compiling web templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A web template has to be compiled to JavaScript before it can be parsed for
    expressions. This can be done in the browser using the Handlebars frontend library,
    but it means longer execution times when loading templates, and it also means
    loading a larger library asset file on the initial page load. The initial page
    load is critical for a SPA because you do not want the user waiting a long time
    for your app to download assets and prepare the page for the initial View. Additionally,
    if you want to separate your Views into separate files, as we did with `user.handlebars`,
    then those View files have to be loaded asynchronously at some point to hand over
    to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Precompiling web templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To circumvent large asset payloads and extraneous round trips to the server
    to fetch Views, Handlebars allows you to *precompile* web templates to JavaScript
    so that they can be used immediately within your app. This gives you the ability
    to separate your Views into different files and keep things organized and still
    maintain a lower initial page load.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let''s install the Handlebars Node.js package globally so
    that it can be used from the command line in any directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now allow you to compile your templates on the command line to create
    a precompiled JavaScript template file you can use in your SPA. From the root
    of your project directory, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command is telling the Handlebars compiler to take all files with the extension
    .`handlebars` (in this case only `user.handlebars`) and compile them to a single
    file named `templates.js`. This could allow to you have 100 separate web template
    View files and precompile them to one JavaScript file, for example. This is a
    good practice because it allows you to map each View file to a REST API endpoint
    on your server side. In the case of our SPA example, our endpoint will be requesting
    the `user.json` file through AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: Handling server HTTP requests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we will install the *PayloadJS* library for handling REST requests within
    the SPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: PayloadJS will allow us to easily make AJAX requests triggered from our SPA
    markup by using custom `data-` HTML attributes to define behaviors and parameters
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SPA layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important pieces of a SPA is the *single page* itself, or the
    *layout* for your app. This is the one and only server-side HTML page that you
    will load in order to initialize and display your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file in the root of your directory named `index.html`, and enter the
    following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will be the main layout page for your SPA. You will notice that `script`
    tag references have been added that point to jQuery, Handlebars, PayloadJS, and
    the `templates.js` file we created. These are all of the assets you will need
    loaded in order to run this SPA. Additionally, the `Payload.deliver()` command
    is run at the bottom of the page and passed an object to overwrite any of its
    default initialization options. This method simply initializes PayloadJS to drive
    the behavior within the DOM indicated in the `data-` attributes on the link with
    the text **Load user data**. In this case, we are setting the `templates` property
    that is passed in to `Handlebars.templates`, since that is the namespace containing
    our Handlebars template.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on using PayloadJS, please see payloadjs.com.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the SPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you have all of the necessary files in place to run this simple SPA. The
    only thing left is a local server to run and load the `index.html` file for testing.
    Let''s install a simple HTTP server with NPM for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Install this package globally so that it can be run from the command line.
    This simple Node.js HTTP server can be run specifying any local directory as your
    server. In this case, we want to run the server for the current project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, you should see something similar to the following
    output in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the HTTP server is running and available locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you should be able to go to a browser and load the URL `localhost:8080`
    and you will see the contents of the `index.html` page you created. The only visible
    content of the page is the link with the text **Load user data**. If everything
    is set up properly and you click on that link, you should notice a **Loading...**
    indicator below it for a brief moment, followed by the contents of the `user.handlebars`
    template file populated with the data from the `user.json` file loaded into the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serving the SPA](img/image_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The full page with the response after clicking on the link should look similar
    to the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of a simple JavaScript SPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So we have created a simple JavaScript SPA using a general MVW pattern with
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Model: `user.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'View: `user.handlebars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precompiled templates file: `templates.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SPA layout page: `index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP server: Node.js *http-server* package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is about as simple as it gets, but you have created an SPA nonetheless.
    This example should give you an idea of how powerful JavaScript can be for creating
    a single page application. Feel free to extend this simple SPA with more Model
    data files, additional web template Views, some CSS, and a bit of your own creativity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have an understanding of the traditional MVC pattern, MVP, MVVM,
    VIPER, and the reasons for the transition away from traditional MVC and conventions
    leading to the more generalized MVW pattern. The should also understand that the
    term *Model-View-Whatever*, or *MVW*, was largely popularized by the AngularJS
    team, and that this was done in regard to the modern SPA requiring a new and more
    complex set of components that were non-existent when the original MVC pattern
    was conceived of.
  prefs: []
  type: TYPE_NORMAL
- en: You also should now have the ability to build a simple JavaScript SPA with just
    a few Node.js and Bower packages. Now it's on to bigger and better things. In
    the next chapter, we will discuss how to create the ideal application development
    environment for a SPA by expanding on the Node.js environment we have been working
    with so far.
  prefs: []
  type: TYPE_NORMAL
