- en: Chapter 2. Model-View-Whatever
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 模型-视图-任何东西
- en: 'If you are a frontend developer, you may not be familiar with the traditional
    software architectural pattern referred to as **Model-View-Controller** (**MVC**).
    Variations of this pattern have found their way into frontend software architectural
    patterns in recent years through such frameworks as *Backbone.js*, *Ember.js*,
    and AngularJS. Regardless of your experience in these areas, this chapter will
    discuss the evolution of the so-called **Model-View-Whatever** (**MVW**) pattern
    and its relevance to SPA development through the following topic areas:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名前端开发者，你可能不熟悉被称为 **模型-视图-控制器**（**MVC**）的传统软件架构模式。近年来，这种模式的变体通过 *Backbone.js*、*Ember.js*
    和 AngularJS 等框架进入了前端软件架构模式。无论你在这些领域的经验如何，本章将通过以下主题区域讨论所谓的 **模型-视图-任何东西**（**MVW**）模式的演变及其与
    SPA 开发的相关性：
- en: The original MVC pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的 MVC 模式
- en: '**Model-View-Presentation** (**MVP**)/**Model-View-ViewModel** (**MVVM**) explained'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-展示**（**MVP**）/**模型-视图-视图模型**（**MVVM**）解释'
- en: '**View-Interactor-Presenter-Entity-Router** (**VIPER**) and other variations
    of MVW'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图-交互器-展示器-实体-路由器**（**VIPER**）和其他 MVW 变体'
- en: AngularJS and MVW
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS 和 MVW
- en: Using the MVW pattern in a SPA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SPA 中使用 MVW 模式
- en: The original MVC pattern
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始的 MVC 模式
- en: The MVC software architectural pattern has existed in one form or another since
    the 1970s, but it became more popular and generally accepted with its use in web
    application frameworks such as Ruby on Rails, CakePHP, and Django. MVC frameworks
    like these brought a higher level of organization and sophistication to web application
    development than had been previously conceived, and in doing so, paved the way
    for modern SPA development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 软件架构模式自 20 世纪 70 年代以来以某种形式存在，但随着其在 Ruby on Rails、CakePHP 和 Django 等网络应用框架中的应用，它变得更加流行并被广泛接受。这类
    MVC 框架为网络应用开发带来了比以往更高的组织和复杂性水平，并在这样做的同时，为现代单页应用（SPA）的发展铺平了道路。
- en: To understand the relevance of MVC to modern SPA development, let's first break
    down the components and ideology of MVC.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 MVC 对现代 SPA 开发的相关性，让我们首先分解 MVC 的组件和理念。
- en: The Model
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The *Model* component of MVC deals with an application's data. This includes
    data that is displayed to the user, received from the user, and stored in the
    database. Additionally, the Model handles all **Create, Read, Update, Delete**
    (**CRUD**) operations with the database. Many frameworks also use the Model to
    handle an application's *business logic*, or how the data should be manipulated
    before being saved or viewed, but this is not necessarily a standard.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 的 *模型* 组件处理应用的数据。这包括显示给用户的数据、从用户接收的数据以及存储在数据库中的数据。此外，模型处理与数据库的所有 **创建、读取、更新、删除**（**CRUD**）操作。许多框架还使用模型来处理应用的业务逻辑，即数据在保存或查看之前应该如何被操作，但这并不一定是标准。
- en: In the simplest terms, the Model in an MVC web application is a representation
    of the application's data. That data may include anything relevant to the application,
    such as the current user's information. Traditional web application frameworks
    use relational databases, such as MySQL, to store data. Modern SPA architectures,
    however, are now gravitating more and more toward document-oriented databases,
    or what is commonly referred to as *NoSQL*. MongoDB and many other NoSQL databases
    use JSON documents to store records. This is great for frontend architectures
    because JavaScript can directly parse JSON, and in the case of the MEAN stack,
    JSON data is native to every tier of the architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，MVC 网络应用中的模型是应用数据的表示。这些数据可能包括与应用相关的任何内容，例如当前用户的信息。传统的网络应用框架使用关系数据库，如 MySQL
    来存储数据。然而，现代 SPA 架构现在越来越多地倾向于文档导向数据库，通常被称为 *NoSQL*。MongoDB 和许多其他 NoSQL 数据库使用 JSON
    文档来存储记录。这对于前端架构来说非常好，因为 JavaScript 可以直接解析 JSON，在 MEAN 栈的情况下，JSON 数据是架构每一层的原生数据。
- en: Let's take a current web application's user information as an example. We will
    refer to this as the *User Model* **:**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以当前网络应用的用户信息为例。我们将称之为 *用户模型* **：**
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A simple JSON document like this will be returned from the database to your
    app for direct parsing by JavaScript. There is no need for any **Structured Query
    Language** (**SQL**) with a document-oriented database, hence the term *NoSQL*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的简单 JSON 文档将从数据库返回到您的应用，由 JavaScript 直接解析。在文档导向数据库中不需要任何 **结构化查询语言**（**SQL**），因此有
    *NoSQL* 这个术语。
- en: The View
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The core component of MVC is the *View*, and it is likely the one you are most
    familiar with if you are a frontend developer. The View embodies everything that
    the user interacts with, and in the case of a web application, what the browser
    consumes. Traditional MVC frameworks serve Views from the server, but in the case
    of a JavaScript SPA and using an architecture like the MEAN stack, the View is
    contained entirely in the frontend. From a development and asset management standpoint,
    this makes things a lot easier to maintain because the dual aspect of dealing
    with Views both on the server side and the frontend does not exist.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 的核心组件是 *视图*，如果你是前端开发者，你很可能最熟悉它。视图体现了用户与之交互的一切，在 Web 应用程序的情况下，是浏览器所消耗的内容。传统的
    MVC 框架从服务器端提供视图，但在 JavaScript SPA 和使用类似 MEAN 栈的架构的情况下，视图完全包含在前端。从开发和资产管理角度来看，这使得维护变得更加容易，因为处理服务器端和前端视图的双重性质不存在。
- en: 'The templates for Views in a JavaScript SPA are written using HTML mixed with
    some type of web template system such as Underscore, Handlebars, or Jade, as only
    a few examples. A web template system allows your HTML markup to be parsed by
    JavaScript and evaluated for expressions that place dynamic data and content within
    your Views. For example, let''s look at a simple Handlebars template using the
    User Model from earlier:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript SPA 中，视图的模板使用 HTML 与某种类型的 Web 模板系统（如 Underscore、Handlebars 或 Jade）混合编写，仅举几个例子。Web
    模板系统允许您的 HTML 标记被 JavaScript 解析并评估表达式，这些表达式将动态数据和内容放置在您的视图中。例如，让我们看看一个简单的 Handlebars
    模板，它使用了之前提到的用户模型：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Imagine an AJAX request is made for the currently logged-in user's data, and
    the SPA returns the User Model JSON document from a `GET` request. The properties
    from that JSON document can be directly inserted into the View for that request.
    In the case of Handlebars, a set of two opening and closing curly braces (`{{
    ... }}`), or double curly brace notation, is used to identify expressions to be
    parsed within the template. In this case, those expressions are simply the user's
    first name, last name, and title. For more information on Handlebars templates,
    see [handlebarsjs.com](http://handlebarsjs.com).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 AJAX 请求用于获取当前登录用户的资料，SPA 通过 `GET` 请求返回用户模型的 JSON 文档。该 JSON 文档中的属性可以直接插入到该请求的视图。在
    Handlebars 的例子中，使用一对开闭花括号（`{{ ... }}`）或双花括号表示法来标识模板内要解析的表达式。在这种情况下，这些表达式仅仅是用户的姓氏、名字和头衔。有关
    Handlebars 模板的更多信息，请参阅 [handlebarsjs.com](http://handlebarsjs.com)。
- en: The Controller
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'The *Controller* component in the MVC pattern is the most variable between
    different frameworks, and thus the most difficult to define with true clarity
    as a general concept. In a traditional web application MVC framework such as Ruby
    on Rails or CakePHP, the Controller takes input from the user in the form of web
    requests, or *actions*, and makes changes to the Model before rendering a new
    response in the View. The following diagram shows the flow of the Controller within
    the MVC paradigm:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式中的 *控制器* 组件在不同框架之间变化最大，因此作为一般概念，用真正的清晰度来定义它是最困难的。在像 Ruby on Rails 或 CakePHP
    这样的传统 Web 应用 MVC 框架中，控制器从用户那里接收以 Web 请求或 *动作* 的形式输入，在渲染新响应到视图之前对模型进行更改。以下图表显示了
    MVC 范式中控制器的流程：
- en: '![The Controller](img/image_02_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![控制器](img/image_02_001.jpg)'
- en: (Diagram from Wikipedia - [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: （来自维基百科的图表 - [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components)）
- en: With this representation of the Controller, it is easy to see how it could encapsulate
    a great deal of application code, and in fact when working with some MVC web frameworks,
    it is often difficult to know where to draw the line between Controller logic,
    business rules for the Model, validation rules for the View, and many other common
    components of a web application. This nebulous nature of the Controller has led
    to the decision of the authors of many modern web frameworks to move away from
    the term *Controller* entirely and adapt a new concept in its place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种控制器表示法，很容易看出它如何封装大量的应用程序代码，实际上，在与某些 MVC Web 框架一起工作时，很难知道在控制器逻辑、模型业务规则、视图验证规则以及许多其他
    Web 应用程序常见组件之间如何划清界限。控制器的这种模糊性质导致许多现代 Web 框架的作者决定完全放弃使用 *控制器* 这个术语，并采用一个新的概念来替代。
- en: The Model and the View components of MVC are easy to understand and to differentiate 
    their purposes within a web application, but the Controller is not so clear-cut.
    Let's now explore some of the concepts that have replaced the Controller in more
    recent web application architectural patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 中的模型和视图组件易于理解，并且可以在 Web 应用程序中区分它们的目的，但 Controller 并不是那么清晰。现在让我们探讨一些最近 Web
    应用程序架构模式中取代 Controller 的概念。
- en: MVP and MVVM
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP 和 MVVM
- en: The term *Model-View-Whatever* came about amid the rise of many architectural
    patterns that included a Model and a View, but replaced the Controller with a
    different concept for a core component, or even with a number of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *模型-视图-任何东西* 出现在许多包含模型和视图的架构模式兴起之际，但用不同的概念替换了核心组件的 Controller，甚至替换了多个组件。
- en: MVP
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP
- en: MVP is a variation on the MVC architectural pattern in which the *Presenter*
    component replaces the Controller. The Presenter also acts as the Controller in
    this pattern, but it takes on additional responsibility in that it serves to handle
    presentation logic for the View. The reasoning behind this paradigm is to enhance
    the testability of an application by having the View itself contain little to
    no presentation logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 是 MVC 架构模式的一种变体，其中 *Presenter* 组件取代了 Controller。在这个模式中，Presenter 也充当 Controller
    的角色，但它承担了额外的责任，即处理视图的展示逻辑。这种范式背后的推理是通过让视图本身包含很少或没有展示逻辑来增强应用程序的可测试性。
- en: 'Another key difference between MVP and MVC is that a Presenter in MVP has a
    one-to-one relationship with a View, meaning there is a unique Presenter defined
    for every View, whereas MVC allows the Controller to have a one-to-many relationship
    with the View. In other words, MVC allows there to be any number of Views defined
    for a Controller and each View is mapped to an *action* of that Controller. MVP
    maps only one View to a Presenter. Additionally, MVP prohibits a direct relationship
    between the View and the Model, which is again for enhancing testability by keeping
    business logic out of the View:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 和 MVC 之间的另一个关键区别是，MVP 中的 Presenter 与视图有一个一对一的关系，这意味着为每个视图定义了一个独特的 Presenter，而
    MVC 允许 Controller 与视图有一对多的关系。换句话说，MVC 允许为 Controller 定义任意数量的视图，并且每个视图都映射到该 Controller
    的 *操作*。MVP 只映射一个视图到 Presenter。此外，MVP 禁止视图和模型之间的直接关系，这又是为了通过将业务逻辑排除在视图之外来增强可测试性：
- en: '![MVP](img/image_02_002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![MVP](img/image_02_002.jpg)'
- en: (Diagram from Wikipedia - [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: (来自维基百科的图表 - [https://zh.wikipedia.org/wiki/模型-视图-控制器](https://zh.wikipedia.org/wiki/模型-视图-控制器))
- en: MVVM
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM
- en: MVVM is yet another variation on the MVC architectural pattern. The *ViewModel*
    in this paradigm is a representation of the Model data for the current user's
    session. Changes to the ViewModel are always made before any changes are made
    to the Model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 是 MVC 架构模式的一种变体。在这个范式中的 *ViewModel* 是当前用户会话中模型数据的表示。对 ViewModel 的更改总是在对模型进行任何更改之前进行的。
- en: MVVM is like MVP in that the View has no knowledge of the Model, but in contrast,
    the View has a many-to-one relationship with the ViewModel. This means that multiple
    Views can be mapped to one ViewModel. The ViewModel component also contrasts with
    the Presenter in MVP in that it has no knowledge of the View. Instead, the View
    has a reference to the ViewModel, which allows it to be updated based on changes
    to the ViewModel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 与 MVP 类似，因为视图对模型没有了解，但相比之下，视图与 ViewModel 之间有一个多对一的关系。这意味着多个视图可以映射到一个 ViewModel。ViewModel
    组件也与 MVP 中的 Presenter 相对立，因为它对视图没有了解。相反，视图有一个对 ViewModel 的引用，这使得它可以根据 ViewModel
    的更改进行更新。
- en: 'The primary distinction of MVVM from the other architectural patterns in regard
    to SPA development, however, is the support of *two-way data binding*. This means
    that changes to the ViewModel are automatically reflected in the View, and changes
    to data in the View by the user are automatically updated in the ViewModel. This
    makes MVVM a more viable pattern for modern SPA development because the View can
    be updated and stays in sync with the ViewModel without the need for a new page
    request, which is what would be required in a traditional MVC or MVP architecture:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与SPA开发中的其他架构模式相比，MVVM的主要区别在于支持**双向数据绑定**。这意味着ViewModel的变化会自动反映在视图中，而用户在视图中对数据的变化也会自动更新ViewModel。这使得MVVM成为现代SPA开发中更可行的模式，因为视图可以更新并保持与ViewModel的同步，而无需新的页面请求，这在传统的MVC或MVP架构中是必需的：
- en: '![MVVM](img/image_02_003.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM](img/image_02_003.jpg)'
- en: (Diagram from [http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx](http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: （图来自[http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx](http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx)）
- en: Data binding will be discussed further in *[Chapter 6](ch06.html "Chapter 6. Data
    Binding, and Why You Should Embrace It"), Data Binding, and Why You Should Embrace
    It*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定将在*[第6章](ch06.html "第6章。数据绑定，以及为什么你应该接受它")、数据绑定，以及为什么你应该接受它*中进一步讨论。
- en: Summarizing the differences between MVC, MVP, and MVVM
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结MVC、MVP和MVVM之间的区别
- en: 'Now you should have a basic understanding of the MVC architectural pattern
    and the MVP and MVVM variations of it. A full understanding of these concepts
    is not necessary to move forward with learning JavaScript SPA development, but
    it is important to have some knowledge of the types of components that can comprise
    a multitier stack. Shown here is a diagram highlighting the key differences between
    the three architectural patterns discussed in this section:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对MVC架构模式及其MVP和MVVM变体有一个基本的了解。对这些概念有全面的理解并不是学习JavaScript SPA开发所必需的，但了解可以组成多层堆栈的组件类型是很重要的。下面是一个图解，突出了本节中讨论的三个架构模式之间的关键区别：
- en: '![Summarizing the differences between MVC, MVP, and MVVM](img/image_02_004.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![总结MVC、MVP和MVVM之间的区别](img/image_02_004.jpg)'
- en: (Diagram from [http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx](http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: （图来自[http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx](http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx)）
- en: VIPER and other variations of MVW
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VIPER和其他MVW变体
- en: The primary reason that modern architectural patterns have moved away from MVC
    is that the Controller in MVC generally embodies too much application code and
    becomes unwieldy, thereby being difficult to test. This has led to patterns that
    not only replace the Controller with something else, but that add multiple layers
    in its place to further establish a separation of concerns within an application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现代架构模式远离MVC的主要原因是MVC中的控制器通常包含太多的应用程序代码，变得难以管理，因此难以测试。这导致了不仅用其他东西替换控制器，而且在它的位置添加多个层，以进一步在应用程序中建立关注点的分离。
- en: VIPER
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VIPER
- en: In the world of *iOS*, Apple's mobile operating system, MVC was long encouraged
    as the pattern to follow. More recently, however, many iOS developers have moved
    away from pure MVC and have adopted patterns that establish more than just three
    layers within an application's architecture. One of these patterns is *VIPER,*
    which stands for **View, Interactor, Presenter, Entity, and Routing** (or Router).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在*iOS*的世界里，苹果的移动操作系统，MVC长期以来一直被鼓励作为遵循的模式。然而，最近，许多iOS开发者已经远离了纯MVC，并采用了在应用程序架构中建立超过三个层的模式。其中一种模式是*VIPER*，代表**视图（View）、交互器（Interactor）、展示者（Presenter）、实体（Entity）和路由（Routing**）（或路由器）。
- en: 'Let''s briefly cover what each of these components is:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地介绍一下这些组件各自是什么：
- en: '**View**: Just as with MVC, the View represents the user interface.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：与MVC一样，视图代表用户界面。'
- en: '**Interactor**: Contains the business logic for a particular behavior and corresponding
    View within the app. An Interactor is similar to a Controller in MVC, but it may
    interact with multiple Models and is not constrained to only one Model.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互器**：包含应用程序中特定行为和对应视图的业务逻辑。交互器类似于MVC中的控制器，但它可能与多个模型交互，并且不受限于仅与一个模型交互。'
- en: '**Presenter**: Contains logic for the View, just as with MVP.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示者**：包含视图的逻辑，就像MVP一样。'
- en: '**Entity**: Another word for *Model*, simply used to achieve the *E* in the
    **VIPER** acronym.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：是“模型”的另一种说法，简单来说就是用来实现**VIPER**缩写中的“E”。'
- en: '**Routing**: Each request in an app is made using a unique call, and in the
    case of a web application, a URL or *route* from the browser is used to make an
    application request. This layer may also be called the Router.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：在应用程序中，每个请求都是通过一个唯一的调用进行的，在Web应用程序的情况下，使用浏览器中的URL或*路由*来发起应用程序请求。这一层也可以称为路由器。'
- en: 'It is evident from the description of the components in VIPER that they do
    not actually flow in the order of the acronym itself, but rather are ordered as
    such for aesthetic purposes. The diagram below shows the true flow of the VIPER
    pattern, along with representations of the browser and the database to supplement
    the understanding of this flow:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从VIPER组件的描述中可以看出，它们实际上并不是按照缩写本身的顺序流动，而是为了美观目的而这样排序。下面的图表显示了VIPER模式的真正流程，以及浏览器和数据库的表示，以补充对这种流程的理解：
- en: '![VIPER](img/image_02_005.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![VIPER](img/image_02_005.jpg)'
- en: (Diagram from [http://khanlou.com/2014/03/model-view-whatever/](http://khanlou.com/2014/03/model-view-whatever/))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （来自[http://khanlou.com/2014/03/model-view-whatever/](http://khanlou.com/2014/03/model-view-whatever/)的图表）
- en: Other variations of MVW
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVW的其他变体
- en: So far, we have covered the traditional MVC architectural pattern, MVP, MVVM,
    and the more recently contrived VIPER pattern. What should be clear is the patterns
    that have followed MVC do not represent a full paradigm shift, but rather a restructuring
    of the traditional Controller component to embody more clarity, and in the case
    of VIPER, to be divided into a further separation of concerns. The general paradigm
    is not lost in these other patterns because the concept of the Model and the View
    remain intact. This trend is what has led to the generalized paradigmatic term
    *Model-View-Whatever* or MVW.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了传统的MVC架构模式、MVP、MVVM以及最近提出的VIPER模式。应该清楚的是，这些在MVC之后出现的模式并不代表一个完整的范式转变，而是对传统控制器组件的重构，以体现更多的清晰性，在VIPER的情况下，则是进一步的关注点分离。在这些其他模式中，一般范式并没有丢失，因为模型和视图的概念仍然保持不变。这种趋势导致了通用范式术语*模型-视图-任何东西*或MVW。
- en: What we are left with is a multitude of architectural patterns that have been
    conceived as abstractions of MVC. So, what pattern should you choose for a JavaScript
    SPA? This is a highly subjective topic, so the best answer is that you should
    choose a pattern based on the type of app you are building, and also based on
    what makes the most sense to you and what you are most comfortable with.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的是许多作为MVC抽象的架构模式。那么，对于JavaScript SPA，你应该选择哪种模式呢？这是一个非常主观的话题，所以最好的答案是，你应该根据你正在构建的应用程序类型来选择模式，同时也基于对你来说最有意义和最舒适的东西。
- en: The software libraries and frameworks you choose to work with should also factor
    into what pattern you use. In that regard, let's take a look at how AngularJS
    has adapted MVC for its own version of MVW.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的软件库和框架也应该考虑你使用哪种模式。在这方面，让我们看看AngularJS是如何为它的MVW版本调整MVC的。
- en: AngularJS and MVW
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS和MVW
- en: AngularJS is a frontend JavaScript framework for building web applications,
    and it is a core component of the MEAN stack. It provides developers with the
    ability to use custom HTML attributes and elements to drive behavior within an
    app. It also provides some handy features such as two-way data binding and dependency
    injection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是一个用于构建Web应用程序的前端JavaScript框架，它是MEAN堆栈的核心组件。它为开发者提供了使用自定义HTML属性和元素来驱动应用程序内行为的能力。它还提供了一些实用的功能，如双向数据绑定和依赖注入。
- en: A brief history of AngularJS
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS的简要历史
- en: AngularJS began as a side project of two Google developers, but eventually became
    an official Google open source project. Since its inception, it has undergone
    many changes in its methodology, including a transition away from touting MVC
    as its pattern of choice. Instead, the AngularJS team now labels it as *a JavaScript
    MVW framework* (at the time of writing).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS最初是两位Google开发者的一个侧项目，但最终成为了一个官方的Google开源项目。自其诞生以来，它在方法论上经历了许多变化，包括从宣传MVC作为首选模式转变为不再宣传。相反，AngularJS团队现在将其标记为*一个JavaScript
    MVW框架*（截至写作时）。
- en: The reason for the declaration of AngularJS to be MVW was in response to extensive
    debate and confusion from the developer community over what pattern AngularJS
    follows. The label itself may not be important to some developers, but it is important
    in highlighting the fact that the architectural pattern AngularJS uses is more
    complex than traditional MVC. AngularJS does, however, include a Controller component,
    among others. Let's take a closer look at what those components are.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 AngularJS 为 MVW 的原因是对开发者社区中关于 AngularJS 遵循何种模式的广泛辩论和混淆的反应。标签本身可能对某些开发者来说并不重要，但它有助于强调
    AngularJS 使用的架构模式比传统的 MVC 更复杂。然而，AngularJS 的确包括控制器组件等。让我们更详细地看看这些组件是什么。
- en: AngularJS components
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS 组件
- en: AngularJS is designed for creating web applications, and as such, it includes
    conceptual components that do not exist in traditional MVC. Also keep in mind
    that AngularJS is a frontend framework only, so it is agnostic of what server-side
    framework and database solution is used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 是为了创建网页应用而设计的，因此它包括了一些在传统 MVC 中不存在的概念组件。同时，请记住 AngularJS 只是一个前端框架，所以它与后端框架和数据库解决方案无关。
- en: Template
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Template
- en: 'A **Template** in AngularJS is an HTML document that contains special markup
    allowing it to be parsed to handle dynamic data, as with any web template system.
    AngularJS uses its own proprietary web template system as opposed to a third-party
    one, such as **Handlebars**. Just like Handlebars, however, AngularJS uses double
    curly brace notation to identify expressions within the HTML markup:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中的 **模板** 是一个包含特殊标记的 HTML 文档，允许它被解析以处理动态数据，就像任何网页模板系统一样。AngularJS
    使用自己的专有网页模板系统，而不是第三方系统，如 **Handlebars**。然而，与 Handlebars 一样，AngularJS 也使用双大括号符号来标识
    HTML 标记中的表达式：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is an example of a simple AngularJS template. You can see that it is constructed
    like a normal HTML document, but it also includes AngularJS expressions. You will
    also notice that there are special HTML attributes prefixed by `ng-`, which convey
    different types of application information to the AngularJS framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 AngularJS 模板的例子。你可以看到它就像一个正常的 HTML 文档一样构建，但它还包括 AngularJS 表达式。你还会注意到有一些特殊
    HTML 属性以 `ng-` 为前缀，这些属性将不同类型的应用信息传达给 AngularJS 框架。
- en: Directives
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Directives
- en: Directives are special HTML markup that AngularJS uses to drive behaviors within
    the DOM. A directive can be driven by a custom HTML attribute prefixed with `ng`,
    a custom HTML element name such as `<my-element></my-element>`, a comment, or
    a CSS class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是 AngularJS 用来在 DOM 中驱动行为的特殊 HTML 标记。一个指令可以通过以 `ng` 为前缀的自定义 HTML 属性、自定义 HTML
    元素名称（如 `<my-element></my-element>`）、注释或 CSS 类来驱动。
- en: 'You can define your own directives for your application, but AngularJS also
    includes some predefined directives for common use cases. For example, the `ng-repeat`
    attribute shown in the previous example uses the built-in `ngRepeat` directive,
    which is used to render template markup once per item while iterating over a collection:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的应用定义自己的指令，但 AngularJS 也包括一些预定义的指令用于常见用例。例如，前一个示例中显示的 `ng-repeat` 属性使用了内置的
    `ngRepeat` 指令，该指令用于在迭代集合时渲染模板标记：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the example, the `users` object is iterated over and properties of each `user`
    are rendered from the template.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`users` 对象被迭代，每个 `user` 的属性从模板中渲染出来。
- en: Model
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Model
- en: 'The *Model* is a representation of the variable data available for use within
    expressions in the current View. The Model available to a View is confined to
    a particular **Scope**, or context:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*Model* 是当前 View 中可用于表达式的变量数据的表示。一个 View 可用的 Model 被限制在特定的 **Scope** 或上下文中：'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, an array of `users` is registered on the `$scope` object. This
    exposes the `users` variable to a template that has access to this particular
    scope.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个 `users` 数组被注册在 `$scope` 对象上。这使 `users` 变量暴露给可以访问此特定 Scope 的模板。
- en: Scope
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scope
- en: The Scope is a JavaScript object that defines the Model context for variables
    within the View. As shown in the previous example, `$scope.users` would be accessed
    in the View for that Scope as `{{users}}`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Scope 是一个 JavaScript 对象，它定义了 View 中变量的 Model 上下文。正如前一个示例所示，`$scope.users` 将在该
    Scope 的 View 中以 `{{users}}` 的形式访问。
- en: Expressions
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Expressions
- en: 'An **Expression** in AngularJS is just like an expression in any web template
    system, as explained earlier. Double curly brace notation is used to identify
    expressions in AngularJS:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中的 **表达式** 就像任何网页模板系统中的表达式一样，如前所述。AngularJS 中使用双大括号符号来标识表达式：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `{{user.first_name}}` and `{{user.last_name}}` are AngularJS
    expressions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`{{user.first_name}}`和`{{user.last_name}}`是AngularJS表达式。
- en: Compiler
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器
- en: The **Compiler** parses Template markup and evaluates it for Directives and
    Expressions to drive the behavior and data within the View. The AngularJS compiler
    is internal to the framework and not something that you will often access or interact
    with directly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器**解析模板标记，并对其中的指令和表达式进行评估，以驱动视图中的行为和数据。AngularJS编译器是框架内部的，通常不会直接访问或与之交互。'
- en: Filter
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'A **Filter** is used to format an Expression in the View to be presented in
    a particular way. For example, the View may be passed a currency amount from the
    Model in the form of a number. A Filter can be added to the Expression in order
    to format what the user sees as a monetary value with a currency symbol. The pipe
    `|` symbol is used within the double curly brace notation to append a filter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤器**用于在视图中格式化表达式，以便以特定方式呈现。例如，视图可能从模型中接收到一个以数字形式表示的货币金额。可以通过添加过滤器到表达式中来格式化用户看到的货币值，并带有货币符号。管道`|`符号在双大括号符号内用于附加过滤器：'
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, `total` represents the Expression and `currency` represents
    the Filter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`total`代表表达式，而`currency`代表过滤器。
- en: View
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: Just as with traditional MVC, the View in AngularJS is the user interface. Views
    are composed of Templates, and the terms are largely interchangeable in the context
    of an AngularJS application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像传统的MVC（模型-视图-控制器）一样，AngularJS中的视图是用户界面。视图由模板组成，在AngularJS应用程序的上下文中，这两个术语在很大程度上是可以互换的。
- en: Data binding
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Data binding in AngularJS is *bidirectional*, or two-way, so data changed in
    the View is updated in the Model, and data changed in the Model is updated in
    the View. This is done automatically, without the need for any additional business
    logic to handle the changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS中的数据绑定是**双向的**，或者说双向的，因此视图中的数据变化会更新到模型中，而模型中的数据变化会更新到视图中。这是自动完成的，无需任何额外的业务逻辑来处理这些变化。
- en: Controller
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器
- en: 'A Controller is really a *View Controller* in AngularJS, since it is a purely
    frontend framework. Like traditional MVC, the Controller contains business logic,
    but that business logic only pertains to the View:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在AngularJS中实际上是一个**视图控制器**，因为它是一个纯前端框架。像传统的MVC一样，控制器包含业务逻辑，但这种业务逻辑仅与视图相关：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `UsersController` could be created, for example, that contains the `users`
    Model shown previously and exposes it in the View through its `$scope` object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以创建一个`UsersController`，其中包含之前显示的`users`模型，并通过其`$scope`对象将其暴露在视图中。
- en: Dependency injection
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The term *dependency injection* is commonly used with respect to JavaScript
    as the ability to asynchronously add resources to the current web page. In AngularJS,
    the concept is similar, but only with regard to other AngularJS components. For
    example, Directives, Filters, and Controllers are all injectable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*依赖注入*在JavaScript中通常与异步向当前网页添加资源的能力相关联。在AngularJS中，这个概念类似，但仅限于其他AngularJS组件。例如，指令（Directives）、过滤器（Filters）和控制器（Controllers）都是可注入的。
- en: Injector
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入器
- en: The **Injector** is the container for dependencies and is responsible for finding
    them and adding them when needed. It is decoupled from the application code using
    declarative syntax within the View and is typically not accessed directly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注入器**是依赖项的容器，负责在需要时查找并添加它们。它通过视图中的声明性语法与应用程序代码解耦，通常不会直接访问。'
- en: Module
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: 'The **Module** is a container for all the main components of an app. It gives
    the app a main namespace reference to all associated Directives, Services, Controllers,
    Filters, and any additional configuration information:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是应用程序所有主要组件的容器。它为应用程序提供了一个主命名空间引用，包括所有相关的指令（Directives）、服务（Services）、控制器（Controllers）、过滤器（Filters）以及任何额外的配置信息：'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If your Module depends on any other Modules, you can add them to the empty array
    parameter shown in the previous example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块依赖于任何其他模块，你可以将它们添加到前一个例子中显示的空数组参数中。
- en: 'To apply a Module to an SPA using AngularJS, you can simply declare the name
    of the module within your main page''s HTML using the custom `ng-app` attribute
    on your app container element:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模块应用于使用AngularJS的SPA（单页应用），你可以在主页的HTML中简单地使用自定义的`ng-app`属性在你的应用容器元素中声明模块的名称：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Service
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: The **Service** is a component that differentiates AngularJS from traditional
    MVC in that it is used to contain reusable business logic that you may want to
    share across different Controllers within your app. This helps to keep Controllers
    from becoming too large and complicated, and also allows different parts of the
    app to share some commonly used business logic. Currency conversion, for example,
    is something that could be written as a Service because you may want to use it
    in multiple Controllers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**是区分 AngularJS 和传统 MVC 的组件，因为它用于包含可重用的业务逻辑，你可能在应用程序的不同控制器之间共享这些逻辑。这有助于防止控制器变得过大和复杂，并允许应用程序的不同部分共享一些常用的业务逻辑。例如，货币转换可以编写为一个服务，因为你可能想在多个控制器中使用它。'
- en: 'The following diagram illustrates how the components of AngularJS interact
    with each other:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了 AngularJS 的组件如何相互交互：
- en: '![Service](img/image_02_006.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![服务](img/image_02_006.jpg)'
- en: (Diagram from [https://dzone.com/refcardz/angularjs-essentials](https://dzone.com/refcardz/angularjs-essentials))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （来自 [https://dzone.com/refcardz/angularjs-essentials](https://dzone.com/refcardz/angularjs-essentials)
    的图表）
- en: AngularJS 2.x (in beta at the time of writing) differs in its architectural
    pattern from v1.x, which is the version represented here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 2.x（在撰写本文时处于测试版）在架构模式上与 v1.x 不同，这里展示的是 v1.x 版本。
- en: Now that you have a better understanding of the components that comprise the
    AngularJS MVW architectural pattern and how those components pertain to a frontend
    SPA architecture, let's apply some of these MVW principles to a simple JavaScript
    SPA example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了构成 AngularJS MVW 架构模式的组件以及这些组件如何与前端 SPA 架构相关，让我们将这些 MVW 原则应用到简单的
    JavaScript SPA 示例中。
- en: Using the MVW pattern in an SPA
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SPA 中使用 MVW 模式
- en: It should now be clear to you that MVW is not a precise architectural pattern,
    but rather a paradigm in which you have a Model, a View, and a nebulous third
    component, or more components, depending on how fine-grained you decide to break
    down your separation of concerns. Everything falling within that gray area is
    based on what type of application you are building, what architectural components
    you are comfortable with as a developer, and what frameworks and libraries you
    are working with.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚，MVW 不是一个精确的架构模式，而是一种范式，其中你有一个模型、一个视图，以及一个模糊的第三组件，或者更多组件，这取决于你决定如何细化你的关注点分离。所有落在那个灰色区域的东西都是基于你正在构建的应用程序类型、作为开发者的你感到舒适的架构组件，以及你正在使用的框架和库。
- en: Building a simple JavaScript SPA
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 JavaScript SPA
- en: The complexity of your SPA should always be a factor in what technologies you
    use to build it. More to the point, you should not go into every project assuming
    you will always use a certain technology stack or framework. This rule goes for
    the MEAN stack as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 SPA 的复杂性应该是你选择构建它的技术的一个因素。更具体地说，你不应该假设每个项目你都会使用某个特定的技术栈或框架。这个规则也适用于 MEAN
    栈。
- en: Let's take the User Model example from earlier, and the accompanying Handlebars
    template View, and actually build it out as an SPA, complete with the AJAX request
    to retrieve the User Model data. For something simple like this, using AngularJS
    and the MEAN stack would definitely be overkill. Let's begin by using the NPM,
    Bower, and Grunt environment you set up in [*Chapter 1*](ch01.html "Chapter 1. Getting
    Organized with NPM, Bower, and Grunt")*Getting Organized NPM, Bower, and Grunt*.
    So how do we proceed?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面的用户模型示例和相应的 Handlebars 模板视图为例，实际上构建一个 SPA，包括用于检索用户模型数据的 AJAX 请求。对于这样简单的东西，使用
    AngularJS 和 MEAN 栈无疑是过度设计。让我们从使用你在 [*第 1 章*](ch01.html "第 1 章。使用 NPM、Bower 和 Grunt
    进行组织")*使用 NPM、Bower 和 Grunt 进行组织*中设置的 NPM、Bower 和 Grunt 环境 开始。那么我们该如何进行呢？
- en: Creating the Model
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'The Model is the simple JSON object of user data we defined earlier. Rather
    than setting up a database for this, let''s simply place it in a text file and
    name it `user.json`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是我们之前定义的简单 JSON 用户数据对象。而不是为这个设置数据库，让我们简单地将它放在一个文本文件中，命名为 `user.json`：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file to the same directory as your `package.json`, `bower.json`, and
    `Gruntfile.js`. Feel free to replace the user information with your own for this
    example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到与你的 `package.json`、`bower.json` 和 `Gruntfile.js` 相同的目录下。在这个示例中，你可以随意替换用户信息。
- en: Creating the View
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'The View for this example will be the web template document we defined earlier
    with a definition list containing user information:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的视图将是之前定义的包含用户信息的网页模板文档：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save this file to the root directory of your project as well and name it `user.handlebars`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存到您的项目根目录，并命名为 `user.handlebars`。
- en: Setting up frontend assets
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置前端资产
- en: We are not creating a complex SPA in this case, so we will not use any frontend
    frameworks, but we do want to install a few libraries to make development easier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会创建一个复杂的 SPA，因此我们不会使用任何前端框架，但我们确实想安装一些库以简化开发。
- en: 'If you followed the examples in [*Chapter 1*](ch01.html "Chapter 1. Getting
    Organized with NPM, Bower, and Grunt"),* Getting Organized with NPM, Bower*, and
    Grunt you should already have jQuery installed via Bower. If you have not yet
    installed it, go ahead and do so now:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了 [*第 1 章*](ch01.html "第 1 章。使用 NPM、Bower 和 Grunt 进行组织")、*使用 NPM、Bower
    进行组织* 和 Grunt 的示例，您应该已经通过 Bower 安装了 jQuery。如果您尚未安装它，请现在安装：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will use jQuery for handling AJAX requests and DOM manipulation within the
    SPA.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 jQuery 在 SPA 中处理 AJAX 请求和 DOM 操作。
- en: 'Now let''s install the Handlebars library for parsing our web template View:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装 Handlebars 库以解析我们的网页模板视图：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compiling web templates
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译网页模板
- en: A web template has to be compiled to JavaScript before it can be parsed for
    expressions. This can be done in the browser using the Handlebars frontend library,
    but it means longer execution times when loading templates, and it also means
    loading a larger library asset file on the initial page load. The initial page
    load is critical for a SPA because you do not want the user waiting a long time
    for your app to download assets and prepare the page for the initial View. Additionally,
    if you want to separate your Views into separate files, as we did with `user.handlebars`,
    then those View files have to be loaded asynchronously at some point to hand over
    to the compiler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析表达式之前，网页模板必须编译为 JavaScript。这可以在浏览器中使用 Handlebars 前端库完成，但这意味着加载模板时的执行时间会更长，同时也意味着在初始页面加载时加载更大的库资产文件。对于
    SPA 来说，初始页面加载是至关重要的，因为您不希望用户长时间等待您的应用程序下载资产并准备初始视图。此外，如果您想将视图分离到单独的文件中，就像我们用 `user.handlebars`
    做的那样，那么这些视图文件必须在某个时刻异步加载，以便传递给编译器。
- en: Precompiling web templates
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预编译网页模板
- en: To circumvent large asset payloads and extraneous round trips to the server
    to fetch Views, Handlebars allows you to *precompile* web templates to JavaScript
    so that they can be used immediately within your app. This gives you the ability
    to separate your Views into different files and keep things organized and still
    maintain a lower initial page load.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过大量资产负载以及服务器往返以获取视图的额外往返，Handlebars 允许您将网页模板 *预编译* 为 JavaScript，以便它们可以在您的应用程序中立即使用。这使您能够将视图分离到不同的文件中，保持事物组织有序，同时仍然保持较低的初始页面加载。
- en: 'For this example, let''s install the Handlebars Node.js package globally so
    that it can be used from the command line in any directory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们全局安装 Handlebars Node.js 包，以便可以在任何目录中使用命令行：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will now allow you to compile your templates on the command line to create
    a precompiled JavaScript template file you can use in your SPA. From the root
    of your project directory, enter the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您在命令行中编译模板，创建一个预编译的 JavaScript 模板文件，您可以在您的 SPA 中使用。从您的项目目录的根目录开始，输入以下命令：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command is telling the Handlebars compiler to take all files with the extension
    .`handlebars` (in this case only `user.handlebars`) and compile them to a single
    file named `templates.js`. This could allow to you have 100 separate web template
    View files and precompile them to one JavaScript file, for example. This is a
    good practice because it allows you to map each View file to a REST API endpoint
    on your server side. In the case of our SPA example, our endpoint will be requesting
    the `user.json` file through AJAX.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 Handlebars 编译器将所有扩展名为 .`handlebars` 的文件（在这种情况下仅为 `user.handlebars`）编译到一个名为
    `templates.js` 的单个文件中。这可以使您拥有 100 个独立的网页模板视图文件，并将它们预编译到一个 JavaScript 文件中，例如。这是一个好习惯，因为它允许您将每个视图文件映射到服务器端的
    REST API 端点。在我们的 SPA 示例中，我们的端点将通过 AJAX 请求 `user.json` 文件。
- en: Handling server HTTP requests
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理服务器 HTTP 请求
- en: 'Now we will install the *PayloadJS* library for handling REST requests within
    the SPA:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装 *PayloadJS* 库以在 SPA 中处理 REST 请求：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: PayloadJS will allow us to easily make AJAX requests triggered from our SPA
    markup by using custom `data-` HTML attributes to define behaviors and parameters
    in the DOM.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PayloadJS 将允许我们通过使用自定义的 `data-` HTML 属性在 DOM 中定义行为和参数，轻松地从我们的 SPA 标记中触发 AJAX
    请求。
- en: Creating the SPA layout
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 SPA 布局
- en: One of the most important pieces of a SPA is the *single page* itself, or the
    *layout* for your app. This is the one and only server-side HTML page that you
    will load in order to initialize and display your app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPA）最重要的部分之一是*单页*本身，或者说是你应用的*布局*。这是你将加载的唯一一个服务器端HTML页面，用于初始化和显示你的应用。
- en: 'Create a file in the root of your directory named `index.html`, and enter the
    following code into it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的目录根目录下创建一个名为`index.html`的文件，并将以下代码输入到其中：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will be the main layout page for your SPA. You will notice that `script`
    tag references have been added that point to jQuery, Handlebars, PayloadJS, and
    the `templates.js` file we created. These are all of the assets you will need
    loaded in order to run this SPA. Additionally, the `Payload.deliver()` command
    is run at the bottom of the page and passed an object to overwrite any of its
    default initialization options. This method simply initializes PayloadJS to drive
    the behavior within the DOM indicated in the `data-` attributes on the link with
    the text **Load user data**. In this case, we are setting the `templates` property
    that is passed in to `Handlebars.templates`, since that is the namespace containing
    our Handlebars template.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是你的SPA的主要布局页面。你会注意到已经添加了`script`标签引用，指向jQuery、Handlebars、PayloadJS和我们创建的`templates.js`文件。这些都是你需要加载以运行此SPA的资产。此外，`Payload.deliver()`命令在页面底部运行，并传递一个对象以覆盖其任何默认初始化选项。此方法简单初始化PayloadJS以驱动DOM中`data-`属性指示的行为。在这种情况下，我们正在设置传递给`Handlebars.templates`的`templates`属性，因为它是包含我们的Handlebars模板的命名空间。
- en: For more information on using PayloadJS, please see payloadjs.com.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用PayloadJS的更多信息，请参阅payloadjs.com。
- en: Serving the SPA
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端渲染SPA
- en: 'Now you have all of the necessary files in place to run this simple SPA. The
    only thing left is a local server to run and load the `index.html` file for testing.
    Let''s install a simple HTTP server with NPM for this purpose:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经放置了所有必要的文件来运行这个简单的SPA。唯一剩下的事情是运行一个本地服务器来加载和测试`index.html`文件。让我们使用NPM安装一个简单的HTTP服务器来完成这个目的：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Install this package globally so that it can be run from the command line.
    This simple Node.js HTTP server can be run specifying any local directory as your
    server. In this case, we want to run the server for the current project directory:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将此包全局安装，以便可以从命令行运行。这个简单的Node.js HTTP服务器可以指定任何本地目录作为你的服务器。在这种情况下，我们想要运行当前项目目录的服务器：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After running this command, you should see something similar to the following
    output in your console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该能在你的控制台看到以下类似的输出：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This indicates that the HTTP server is running and available locally.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明HTTP服务器正在本地运行并可用。
- en: 'Now you should be able to go to a browser and load the URL `localhost:8080`
    and you will see the contents of the `index.html` page you created. The only visible
    content of the page is the link with the text **Load user data**. If everything
    is set up properly and you click on that link, you should notice a **Loading...**
    indicator below it for a brief moment, followed by the contents of the `user.handlebars`
    template file populated with the data from the `user.json` file loaded into the
    page:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够打开浏览器并加载URL `localhost:8080`，你将看到你创建的`index.html`页面的内容。页面上唯一可见的内容是带有文本**加载用户数据**的链接。如果一切设置正确，并且你点击该链接，你应该会注意到短暂的**加载中...**指示器，随后是`user.handlebars`模板文件的内容，这些内容是从加载到页面中的`user.json`文件中获取的：
- en: '![Serving the SPA](img/image_02_007.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Serving the SPA](img/image_02_007.jpg)'
- en: The full page with the response after clicking on the link should look similar
    to the preceding screenshot.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接后的完整页面应类似于前面的截图。
- en: Overview of a simple JavaScript SPA
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单JavaScript SPA概述
- en: 'So we have created a simple JavaScript SPA using a general MVW pattern with
    the following components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用以下组件创建了一个简单的JavaScript SPA，采用通用的MVW模式：
- en: 'Model: `user.json`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型：`user.json`
- en: 'View: `user.handlebars`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图：`user.handlebars`
- en: 'Precompiled templates file: `templates.js`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译的模板文件：`templates.js`
- en: 'SPA layout page: `index.html`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA布局页面：`index.html`
- en: 'HTTP server: Node.js *http-server* package'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器：Node.js *http-server* 包
- en: This is about as simple as it gets, but you have created an SPA nonetheless.
    This example should give you an idea of how powerful JavaScript can be for creating
    a single page application. Feel free to extend this simple SPA with more Model
    data files, additional web template Views, some CSS, and a bit of your own creativity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是最简单的情况了，但你仍然创建了一个 SPA。这个例子应该能给你一个关于 JavaScript 在创建单页应用方面多么强大的概念。你可以自由地通过添加更多的模型数据文件、额外的网页模板视图、一些
    CSS 和一点自己的创意来扩展这个简单的 SPA。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have an understanding of the traditional MVC pattern, MVP, MVVM,
    VIPER, and the reasons for the transition away from traditional MVC and conventions
    leading to the more generalized MVW pattern. The should also understand that the
    term *Model-View-Whatever*, or *MVW*, was largely popularized by the AngularJS
    team, and that this was done in regard to the modern SPA requiring a new and more
    complex set of components that were non-existent when the original MVC pattern
    was conceived of.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经理解了传统的 MVC 模式、MVP、MVVM、VIPER，以及从传统 MVC 和约定过渡到更通用的 MVW 模式的理由。你也应该明白，“模型-视图-任何东西”（Model-View-Whatever），或简称
    MVW，这个术语在很大程度上是由 AngularJS 团队推广的，这是为了满足现代单页应用（SPA）需要的新和更复杂的组件集，而这些组件在原始 MVC 模式构思时并不存在。
- en: You also should now have the ability to build a simple JavaScript SPA with just
    a few Node.js and Bower packages. Now it's on to bigger and better things. In
    the next chapter, we will discuss how to create the ideal application development
    environment for a SPA by expanding on the Node.js environment we have been working
    with so far.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在也应该有能力仅使用几个 Node.js 和 Bower 包来构建一个简单的 JavaScript SPA。现在，让我们继续前进，做一些更大、更好的事情。在下一章中，我们将讨论如何通过扩展我们迄今为止一直在使用的
    Node.js 环境，来创建一个理想的 SPA 应用程序开发环境。
