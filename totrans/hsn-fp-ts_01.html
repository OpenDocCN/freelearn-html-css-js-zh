<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Programming Fundamentals</h1>
                </header>
            
            <article>
                
<p>JavaScript has been a multi-paradigm programming language since its inception back in 1995. It allows us to take advantage of an <strong>object-oriented programming</strong> (<strong>OOP</strong>) style along with a functional programming style. <span>The same can be said of TypeScript. However, </span><span>for functional programming,</span><span> </span><span>TypeScript is even better suited than JavaScript because, as we will learn in this chapter, static type systems and type inference are both very important features in functional programming languages such as the ML family of programming languages</span><span>, for example</span><span>.</span></p>
<p>The JavaScript and TypeScript ecosystems have experienced a significant increase in interest in functional programming over the last few years. I believe that this increase in interest can be attributed to the success of React. React is a library <span>developed by Facebook </span>for building user interfaces, and it is highly influenced by some core functional programming concepts.</p>
<p>In this chapter, we will focus on learning some of the most basic functional programming concepts and principles.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>The main characteristics of functional programming</li>
<li>The main benefits of functional programming</li>
<li>Pure functions</li>
<li>side-effects</li>
<li>Immutability</li>
<li>Function arity</li>
<li>Higher-order functions</li>
<li>Laziness</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Is TypeScript a functional programming language?</h1>
                </header>
            
            <article>
                
<p>The answer to this question is yes, but only in part. TypeScript is a multi-paradigm programming language and, as a result, it includes many influences from both OOP languages and functional programming paradigms.</p>
<p>However, if we focus on TypeScript as a functional programming language, we can observe that it is not a purely functional programming language because, for example, the TypeScript compiler doesn't force our code to be free of side-effects.</p>
<p>Not being a purely functional programming language should not be interpreted as something negative. TypeScript provides us with an extensive set of features that allow us to take advantage of some of the best features of the world of OOP languages and the world of functional programming languages. This has allowed TypeScript-type systems to attain a very good compromise between productivity and formality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The benefits of functional programming</h1>
                </header>
            
            <article>
                
<p>Writing TypeScript code using a functional programming style has many benefits, among which we can highlight the following:</p>
<ul>
<li><strong>Our code is testable:</strong> If we try to write our functions as pure functions, we will be able to write unit tests extremely easily. We will learn more about pure functions later in this chapter.</li>
<li><strong>Our code is easy to reason about:</strong> Functional programming can seem hard to understand for developers with a lack of experience in functional programming. However, when an application is implemented correctly using the functional programming paradigm, the results are very small functions (often one-line functions) and very declarative APIs that can be reasoned about with ease. Also, pure functions only work with their arguments, which means that when we want to understand what a function does, we only need to examine the function itself and we don't need to be concerned about any other external variables.</li>
<li><strong>Concurrency: </strong>Most of our functions are stateless, and our code is mostly stateless. We push state out of the core of our application, which makes our applications much more likely to be able to support many concurrent operations and it will be more scalable. We will learn more about stateless code later in this chapter.</li>
<li><strong>Simpler caching:</strong> Caching strategies to cache results become much simpler when we can predict the output of a function given its arguments.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing functional programming</h1>
                </header>
            
            <article>
                
<p><strong>Functional programming</strong> (<strong>FP</strong>) is a programming paradigm that receives its name from the way we build applications when we use it. In a programming paradigm such as OOP, the main building blocks that we use to create an application are objects (objects are declared using classes). However, in FP, we use functions as the main building block in our applications<strong>.</strong></p>
<p>Each new programming paradigm introduces a series of concepts and ideas associated with it. Some of these concepts are universal and are also of interest while learning a different programming paradigm. In OOP, we have concepts such as inheritance, encapsulation, and polymorphism. In functional programming, concepts include higher-order functions, function <span>partial </span>application, immutability, and referential transparency. We are going to examine some of these concepts in this chapter.</p>
<p><strong>Michael Feathers</strong>, the author of the SOLID acronym and many other well-known software engineering principles, once wrote the following:</p>
<div class="mce-root packt_quote">"Object-oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts."</div>
<p>                                                                                                                                                      – <em>Michael Feathers</em></p>
<p>The preceding quote mentions moving parts. We should understand these moving parts as <strong>state changes</strong> (also known as <strong>state mutations</strong>). In OOP, we use encapsulation to prevent objects from being aware of the state mutations of other objects. In functional programming, we try to avoid dealing with state mutations instead of encapsulating them.</p>
<p>FP reduces the number of places in which state changes take place within an application and tries to move these places into the boundaries of the application to try to keep the application's core stateless.</p>
<p>A mutable state is bad because it makes the behavior of our code harder to predict. Take the following function, <span>for example</span>:</p>
<pre>function isIndexPage() {<br/>  return window.location.pathname === "/";<br/>}</pre>
<p>The preceding code snippet declared a function named <kbd>isIndexPage</kbd>. This function can be used to check whether the current page is the root page in a web application based on the current path.</p>
<p>The path is some data that changes all the time, so we can consider it a piece of state. If we try to predict the result of invoking the <kbd>isIndexPage</kbd>, we will need to know the current state. The problem is that we could wrongly assume that the state has not changed since the last known state. We can solve this problem by transforming the preceding function into what is known <span>in FP </span>as a <strong>pure function</strong>, as we will learn in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure functions</h1>
                </header>
            
            <article>
                
<p>FP introduces a number of concepts and principles that will help us to improve the predictability of our code. In this section, we are going to learn about one of these core concepts—pure functions.</p>
<p>A function can be considered pure when it returns a value that is computed using only the arguments passed to it. Also, a pure function avoids mutating its arguments or any other external variables. As a result, a pure function always returns the same value given the same arguments, independently of when it is invoked.</p>
<p>The <kbd>isIndexPage</kbd> function declared in the preceding section is not a pure function because it accesses the <kbd>pathname</kbd> variable, which has not been passed as an argument to the function. We can transform the preceding function into a pure function by rewriting it as follows:</p>
<pre>function isIndexPage(pathname: string) {<br/>  return pathname === "/";<br/>}</pre>
<p>Even though this is a basic example, we can easily perceive that the newer version is much easier to predict. Pure functions help us to make our code easier to understand, maintain, and test.</p>
<p>Imagine that we wanted to write a unit test for the impure version of the <kbd>isIndexPage</kbd> function. We would encounter some problems when trying to write a test because the function uses the <kbd>window.location</kbd> object. We could overcome this issue by using a mocking framework, but it would add a lot of complexity to our unit tests just because we didn't use a pure function.</p>
<p>On the other hand, testing the pure version of the <kbd>isIndexPage</kbd> function would be straightforward, as follows:</p>
<pre>function shouldReturnTrueWhenPathIsIndex(){<br/>    let expected = true;<br/>    let result = isIndexPage("/");<br/>    if (expected !== result) {<br/>        throw new Error('Expected ${expected} to equals ${result}');<br/>    }<br/>}<br/><br/>function shouldReturnFalseWhenPathIsNotIndex() {<br/>    let expected = false;<br/>    let result = isIndexPage("/someotherpage");<br/>    if (expected !== result) {<br/>        throw new Error('Expected ${expected} to equals ${result}');<br/>    }<br/>}</pre>
<p>Now that we understand how functional programming helps us to write better code by avoiding state mutations, we can learn about side-effects and referential transparency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">side-effects</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we learned that a pure function returns a value that can be computed using only the arguments passed to it. A pure function also avoids mutating its arguments or any other external variable that is not passed to the function as an argument. In FP terminology, it is common to say that a pure function is a function that has no side-effects, which means that, when we invoke a pure function, we can expect that the function is not going to interfere (through a state mutation) with any other component in our application.</p>
<p>Certain programming languages, such as Haskell, can ensure that an application is free of side-effects using their type system. TypeScript has fantastic interoperability with JavaScript, but the downside of this, compared to a more isolated language such as Haskell, is that the type system is not able to guarantee that our application is free from side-effects. However, we can use some FP techniques to improve the type safety of our TypeScript applications. Let's take a look at an example:</p>
<pre><span>interface User {</span><br/><span>    ageInMonths: number;</span><br/><span>    name: string;</span><br/><span>}</span><br/><br/><span>function findUserAgeByName(users: User[], name: string): number {</span><br/><span>    if (users.length == 0) {</span><br/><span>        throw new Error("There are no users!");</span><br/><span>    }</span><br/><span>    const user = users.find(u =&gt; u.name === name);</span><br/><span>    if (!user) {</span><br/><span>        throw new Error("User not found!");</span><br/><span>    } else {</span><br/><span>        return user.ageInMonths;</span><br/><span>    }</span><br/><span>}</span></pre>
<p class="mce-root">The preceding function returns a <kbd>number</kbd>. The code compiles without issues. The problem is that the function does not always return a <kbd>number</kbd>. As a result, we can consume the function as follows and our code will compile and throw an exception at runtime: </p>
<pre><span>const users = [</span><br/><span>    { ageInMonths: 1, name: "Remo" },</span><br/><span>    { ageInMonths: 2, name: "Leo" }</span><br/><span>];</span><br/><br/><span>// The variable userAge1 is as number</span><br/><span>const userAge1 = findUserAgeByName(users, "Remo"); </span><br/><span>console.log('Remo is ${userAge1 / 12} years old!');</span><br/><br/><span>// The variable userAge2 is a number but the function throws!</span><br/><span>const userAge2 = findUserAgeByName([], "Leo"); // Error</span><br/><span>console.log('Leo is ${userAge2 / 12} years old!');</span></pre>
<p class="mce-root">The following example showcases a new implementation of the preceding function. This time, instead of returning a number, we will explicitly return a promise. The promise forces us to then use the handler. This handler is only executed if the promise is fulfilled, which means that if the function returns an error, we will never try to convert the age to years:</p>
<pre class="mce-root">function safeFindUserAgeByName(users: User[], name: string): Promise&lt;number&gt; {<br/>    if (users.length == 0) {<br/>        return Promise.reject(new Error("There are no users!"));<br/>    }<br/>    const user = users.find(u =&gt; u.name === name);<br/>    if (!user) {<br/>        return Promise.reject(new Error("User not found!"));<br/>    } else {<br/>        return Promise.resolve(user.ageInMonths);<br/>    }<br/>}<br/><br/>safeFindUserAgeByName(users, "Remo")<br/>    .then(userAge1 =&gt; console.log('Remo is ${userAge1 / 12} years old!'));<br/><br/>safeFindUserAgeByName([], "Leo") // Error<br/>    .then(userAge1 =&gt; console.log('Leo is ${userAge1 / 12} years old!'));</pre>
<p><span>The <kbd>Promise</kbd> type helps us to prevent errors because it expresses potential errors in an explicit way. In programming languages such as Haskell, this is the default </span>behavior<span> of the type system, but, in programming languages such as TypeScript, it is up to us to use types in a safer way.</span></p>
<div class="packt_infobox">We will learn more about Promises in <a href="3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml" target="_blank">Chapter 3</a>, <em>Mastering Asynchronous Programming</em>. We will also learn more about how we can use a number of libraries to reduce the chances of side-effects in our TypeScript applications in <a href="ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml" target="_blank">Chapter 8</a>, <em>Category Theory</em>.</div>
<div class="packt_tip">If you find the idea of your JavaScript applications being free of side-effects <span>attractive</span>, you can try open-source projects such as <a href="https://github.com/bodil/eslint-config-cleanjs">https://github.com/bodil/eslint-config-cleanjs</a>. This project is an ESLint configuration that aims to restrict you to a subset of JavaScript, which would be as close to an idealized pure functional language as possible. Unfortunately, at the time of publication, no similar tools are available that are specifically designed for TypeScript.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referential transparency</h1>
                </header>
            
            <article>
                
<p>Referential transparency is another concept closely related to pure functions and side-effects. A function is pure when it is free from side-effects. An expression is said to be referentially transparent when it can be replaced with its corresponding value without changing the application's behavior. For example, if we are using the following <span>in our code</span>:</p>
<pre>let result = isIndexPage("/");</pre>
<p>We know that the <kbd>isIndexPage</kbd> function is referentially transparent because it would be safe to substitute it for its return type. In this case, we know that when we invoke the <kbd>isIndexPage</kbd> function with <kbd>/</kbd> as an argument, the function will always return <kbd>true</kbd>, which means that it would be safe to do the following:</p>
<pre>let result = true;</pre>
<p>A pure function is a referentially transparent expression. An expression that is not referentially transparent is known as referentially opaque.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless versus stateful</h1>
                </header>
            
            <article>
                
<p>Pure functions and referentially transparent expressions are stateless. A piece of code is stateless when its outcomes are not influenced by previous events. For example, the results of the <kbd>isIndexPage</kbd> function will not be influenced by the number of times that we invoke it, or by the moment in time when we invoke it.</p>
<p>The opposite of stateless code is stateful code. Stateless code is very difficult to test and becomes a problem when we are trying to implement scalable and resilient systems. Resilient systems are systems that can handle server failures; there is usually more than one instance of a service, and if one of them crashes, others can continue handling traffic. Also, new instances are created automatically after one of the instances has crashed. This becomes very difficult if our servers are stateful because we need to save the current state before a crash and restore the state before we spin up a new instance. The whole process becomes much simpler when we design our servers to be stateless.</p>
<p>With the arrival of the cloud computing revolution, these kinds of system have become more common, and this has led to an interest in functional programming languages and design principles because functional programming encourages us to write stateless code. The opposite can be said of OOP because classes are the main construct in OOP applications. Classes encapsulate state properties that are then modified by methods, which encourages methods to be stateful and not pure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declarative versus imperative programming</h1>
                </header>
            
            <article>
                
<p>The advocates of the FP paradigm often use declarative programming as one of its main benefits. Declarative programming is not necessarily exclusive to functional programming, but FP certainly encourages or facilitates this programming style. Before we take a look at some examples, we are going to define declarative programming and imperative programming:</p>
<ul>
<li class="mce-root"><strong>Imperative programming</strong> is a programming paradigm that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates.</li>
<li class="mce-root"><strong>Declarative programming</strong> is a programming paradigm that expresses the logic of a computation without describing its control flow. Many languages that apply this style attempt to minimize or eliminate side-effects by describing what the program must accomplish in terms of the problem domain, rather than describing how to accomplish it as a sequence of steps.</li>
</ul>
<p>The following example calculates the average result of an exam given a collection of objects that contains an ID and a result for a list of students. This example uses an imperative programming style because, as we can see, it uses control flow statements (<kbd>for</kbd>). The example is also clearly imperative because it mutates a state. The <kbd>total</kbd> <span>variable </span>is declared using the <kbd>let</kbd> keyword because it is mutated as many times as results are contained in the <kbd>results</kbd> array:</p>
<pre>interface Result {<br/> id: number;<br/> result:number;<br/>}<br/><br/>const results: Result[] = [<br/> { id: 1, result: 64 },<br/> { id: 2, result: 87 },<br/> { id: 3, result: 89 }<br/>];<br/><br/>function avg(arr: Result[]) {<br/> let total = 0;<br/> for (var i = 0; i &lt; arr.length; i++) {<br/> total += arr[i].result;<br/> }<br/> return total / arr.length;<br/>}<br/><br/>const resultsAvg = avg(results);<br/>console.log(resultsAvg);</pre>
<p>On the other hand, the following example is declarative because there are no control flow statements and there are no state mutations:</p>
<pre>interface Result {<br/>    id: number;<br/>    result:number;<br/>}<br/><br/>const results: Result[] = [<br/>    { id: 1, result: 64 },<br/>    { id: 2, result: 87 },<br/>    { id: 3, result: 89 }<br/>];<br/><br/>const add = (a: number, b: number) =&gt; a + b;<br/>const division = (a: number, b: number) =&gt; a / b;<br/><br/>const avg = (arr: Result[]) =&gt;<br/>    division(arr.map(a =&gt; a.result).reduce(add, 0), arr.length)<br/><br/>const resultsAvg = avg(results);<br/>console.log(resultsAvg);</pre>
<p>While the previous example is declarative, it is not as declarative as it could be. The following example takes the declarative style one step further so we can get an idea of how a piece of declarative code may appear. Don't worry if you don't understand everything in this example right now. We will be able to understand it once we learn more about functional programming techniques later in this book. Note how the program is now defined as a set of very small functions that don't mutate the state and that also don't use control flow statements. These functions are reusable because they are independent of the problem that we are trying to solve. For example, the <kbd>avg</kbd> function can calculate an average, but it doesn't need to be an average of results:</p>
<pre>const add = (a: number, b: number) =&gt; a + b;<br/>const addMany = (...args: number[]) =&gt; args.reduce(add, 0);<br/>const div = (a: number, b: number) =&gt; a / b;<br/>const mapProp = &lt;T&gt;(k: keyof T, arr: T[]) =&gt; arr.map(a =&gt; a[k]);<br/>const avg = (arr: number[]) =&gt; div(addMany(...arr), arr.length);<br/><br/>interface Result {<br/>    id: number;<br/>    result:number;<br/>}<br/><br/>const results: Result[] = [<br/>    { id: 1, result: 64 },<br/>    { id: 2, result: 87 },<br/>    { id: 3, result: 89 }<br/>];<br/><br/>const resultsAvg = avg(mapProp("result", results));<br/>console.log(resultsAvg);</pre>
<p>The actual code that is specific to the problem that we are trying to solve is very small:</p>
<pre>const resultsAvg = avg(mapProp("result", results));</pre>
<p>This code is not reusable, but the <kbd>add</kbd>, <kbd>addMany</kbd>, <kbd>div</kbd>, <kbd>mapProp</kbd>, and <kbd>avg</kbd> <span>functions </span>are reusable. This demonstrates how declarative programming can lead to more reusable code than imperative programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability</h1>
                </header>
            
            <article>
                
<p>Immutability refers to the inability to change the value of a variable after a value has been assigned to it. Purely functional programming languages include immutable implementations of common data structures. For example, when we add an element to an array, we are mutating the original array. However, if we use an immutable array and we try to add a new element to it, the original array will not be mutated, and we will add the new item to a copy of it.</p>
<p>The following code snippet declares a class named <kbd>ImmutableList</kbd> that demonstrates how it is possible to implement an immutable array:</p>
<pre>class ImmutableList&lt;T&gt; {<br/>    private readonly _list: ReadonlyArray&lt;T&gt;;<br/>    private _deepCloneItem(item: T) {<br/>        return JSON.parse(JSON.stringify(item)) as T;<br/>    }<br/>    public constructor(initialValue?: Array&lt;T&gt;) {<br/>        this._list = initialValue || [];<br/>    }<br/>    public add(newItem: T) {<br/>        const clone = this._list.map(i =&gt; this._deepCloneItem(i));<br/>        const newList = [...clone, newItem];<br/>        const newInstance = new ImmutableList&lt;T&gt;(newList);<br/>        return newInstance;<br/>    }<br/>    public remove(<br/>        item: T,<br/>        areEqual: (a: T, b: T) =&gt; boolean = (a, b) =&gt; a === b<br/>    ) {<br/>        const newList = this._list.filter(i =&gt; !areEqual(item, i))<br/>                            .map(i =&gt; this._deepCloneItem(i));<br/>        const newInstance = new ImmutableList&lt;T&gt;(newList);<br/>        return newInstance;<br/>    }<br/>    public get(index: number): T | undefined {<br/>        const item = this._list[index];<br/>        return item ? this._deepCloneItem(item) : undefined;<br/>    }<br/>    public find(filter: (item: T) =&gt; boolean) {<br/>        const item = this._list.find(filter);<br/>        return item ? this._deepCloneItem(item) : undefined;<br/>    }<br/>}</pre>
<p>Every time we add an item to, or remove it from, the immutable array, we create a new instance of the immutable array. This implementation is very inefficient, but it demonstrates the basic idea. We are going to create a quick test to demonstrate how the preceding class works. We are going to use some data regarding superheroes:</p>
<pre>interface Hero { <br/>    name: string;<br/>    powers: string[];<br/>}<br/><br/>const heroes = [<br/>    {<br/>        name: "Spiderman",<br/>        powers: [<br/>            "wall-crawling",<br/>            "enhanced strength",<br/>            "enhanced speed",<br/>            "spider-Sense"<br/>        ]<br/>    },<br/>    {<br/>        name: "Superman",<br/>        powers: [<br/>            "flight",<br/>            "superhuman strength",<br/>            "x-ray vision",<br/>            "super-speed"<br/>        ]<br/>    }<br/>];<br/><br/>const hulk = {<br/>    name: "Hulk",<br/>    powers: [<br/>        "superhuman strength",<br/>        "superhuman speed",<br/>        "superhuman Stamina",<br/>        "superhuman durability"<br/>    ]<br/>};</pre>
<p>We can now use the preceding data to create a new immutable list instance. When we add a new superhero to the list, a new immutable list is created. If we try to search for the superhero <kbd>Hulk</kbd> in the two immutable lists, we will observe that only the second list contains it. We can also compare both lists to observe that they are two different objects, demonstrated as follows:</p>
<pre>const myList = new ImmutableList&lt;Hero&gt;(heroes);<br/>const myList2 = myList.add(hulk);<br/>const result1 = myList.find((h =&gt; h.name === "Hulk")); <br/>const result2 = myList2.find((h =&gt; h.name === "Hulk"));<br/>const areEqual = myList2 === myList;<br/><br/>console.log(result1); // undefined<br/>console.log(result2); // { name: "Hulk", powers: Array(4) }<br/>console.log(areEqual); // false</pre>
<p>Creating our own immutable data structures is, in most cases, not necessary. In a real-world application, we can use libraries such as <kbd>Immutable.js</kbd> to enjoy immutable data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions as first-class citizens</h1>
                </header>
            
            <article>
                
<p>It is common to find mentions of functions as <strong>first-class citizens</strong> in the FP literature. We say that a function is a first-class citizen when it can do everything that a variable can do, which means that functions can be passed to other functions as an argument. For example, the following function takes a function as its second argument:</p>
<pre>function find&lt;T&gt;(arr: T[], filter: (i: T) =&gt; boolean) {<br/>    return arr.filter(filter);<br/>}<br/><br/>find(heroes, (h) =&gt; h.name === "Spiderman");</pre>
<p>Or, it is returned by another function. For example, the following function takes a function as its only argument and returns a function:</p>
<pre>function find&lt;T&gt;(filter: (i: T) =&gt; boolean) {<br/>    return (arr: T[]) =&gt; {<br/>        return arr.filter(filter);<br/>    }<br/>}<br/>  <br/>const findSpiderman = find((h: Hero) =&gt; h.name === "Spiderman");<br/>const spiderman = findSpiderman(heroes);</pre>
<p>Functions can also be assigned to variables. For example, in the preceding code snippet, we assigned the function returned by the find function to a variable named <kbd>findSpiderman</kbd>:</p>
<pre>const findSpiderman = find((h: Hero) =&gt; h.name === "SPiderman");</pre>
<p>Both JavaScript and TypeScript treat functions as first-class citizens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>Lambda expressions are just expressions that can be used to declare anonymous functions (functions without a name). Before the ES6 specification, the only way to assign a function as a value to a variable was to use a function expression:</p>
<pre>const log = function(arg: any) { console.log(arg); };</pre>
<p>The ES6 specification introduced the arrow function syntax:</p>
<pre>const log = (arg: any) =&gt; console.log(arg);</pre>
<div class="packt_infobox">
<p>Please refer to <a href="5c1a8b07-e106-4ea8-a5e5-909e641eb271.xhtml" target="_blank">Chapter 2</a>, <em>Mastering Functions</em>, <a href="0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml" target="_blank">Chapter 4</a>, <em>The Runtime – The Event Loop and the this Operator</em>, and <a href="68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml" target="_blank">Chapter 5</a>, <em>The Runtime – Closures <span>and Prototypes</span></em><span>,</span> to learn more about arrow functions and function expressions.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function arity</h1>
                </header>
            
            <article>
                
<p>The <strong>arity</strong> of a function is the number of arguments that the function takes. A unary function is a function that only takes a single argument:</p>
<pre>function isNull&lt;T&gt;(a: T|null) {<br/>    return (a === null);<br/>}</pre>
<p>Unary functions are very important in functional programming because they facilitate utilization of the function composition pattern.</p>
<div class="packt_infobox">
<p>We will learn more about function composition patterns later in <a href="b9229d02-8eca-4ff7-a88f-e4ccb019270f.xhtml" target="_blank">Chapter 6</a>, <em>Functional Programming Techniques</em>.</p>
</div>
<p>A binary function is a function that takes two arguments:</p>
<pre>function add(a: number, b: number) {<br/>    return a + b;<br/>}</pre>
<p>Functions with two or more arguments are also important because some of the most common FP patterns and techniques (for example, partial application and currying) have been designed to transform functions that allow multiple arguments into unary functions.</p>
<p><span>There are also functions with three (</span><strong>ternary functions</strong><span>) or more arguments. However, functions that accept a variable number of arguments, known as</span> <strong>variadic functions</strong><span>, are particularly interesting in functional programming, as demonstrated in the following code snippet:</span></p>
<pre>function addMany(...numbers: number[]) {<br/>    numbers.reduce((p, c) =&gt; p + c, 0);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Higher-order functions</h1>
                </header>
            
            <article>
                
<p>A higher-order function is a function that does at least one of the following:</p>
<ul>
<li>Takes one or more functions as arguments</li>
<li>Returns a function as its result</li>
</ul>
<p>Higher-order functions are some of the most powerful tools that we can use to write JavaScript in a functional programming style. Let's look at some examples.</p>
<p>The following code snippet declares a function named <kbd>addDelay</kbd>. The function creates a new function that waits for a given number of milliseconds before printing a message in the console. The function is considered a higher-order function because it returns a function:</p>
<pre>function addDelay(msg: string, ms: number) {<br/>    return () =&gt; {<br/>        setTimeout(() =&gt; {<br/>            console.log(msg);<br/>        }, ms);<br/>    };<br/>}<br/><br/>const delayedSayHello = addDelay("Hello world!", 500);<br/>delayedSayHello(); // Prints "Hello world!" (after 500 ms)</pre>
<p>The following code snippet declares a function named <kbd>addDelay</kbd>. The function creates a new function that adds a delay in milliseconds to the execution of another function that is passed as an argument. The function is considered a higher-order function because it takes a function as an argument and returns a function:</p>
<pre>function addDelay(func: () =&gt; void, ms: number) {<br/>    return () =&gt; {<br/>        setTimeout(() =&gt; {<br/>            func();<br/>        }, ms);<br/>    };<br/>}<br/><br/>function sayHello() {<br/>    console.log("Hello world!");<br/>}<br/><br/>const delayedSayHello = addDelay(sayHello, 500);<br/>delayedSayHello(); // Prints "Hello world!" (after 500 ms)</pre>
<p>Higher-order functions are an effective technique for abstracting a solution for a common problem. The preceding example demonstrates how we can use a higher-order function (<kbd>addDelay</kbd>) to add a delay to another function (<kbd>sayHello</kbd>). This technique allows us to abstract the delay functionality and keeps the <kbd>sayHello</kbd> function, or other functions, agnostic of the implementation details of the delay functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laziness</h1>
                </header>
            
            <article>
                
<p>Many functional programming languages feature lazy-evaluated APIs. The idea behind lazy evaluation is that operations are not computed until doing so can no longer be postponed. The following example declares a function that allows us to find an element in an array. When the function is invoked, we don't filter the array. Instead, we declare a <kbd>proxy</kbd> and a <kbd>handler</kbd>:</p>
<pre>function lazyFind&lt;T&gt;(arr: T[], filter: (i: T) =&gt; boolean): T {<br/><br/>    let hero: T | null = null;<br/>    <br/>    const proxy = new Proxy(<br/>        {},<br/>        {<br/>            get: (obj, prop) =&gt; {<br/>                console.log("Filtering...");<br/>                if (!hero) {<br/>                    hero = arr.find(filter)<span class="x x-first"> </span><span class="pl-k x">||</span><span class="x"> </span><span class="pl-c1 x x-last">null</span>;<br/>                }<br/>                return hero ? (hero as any)[prop] : null;<br/>            }<br/>        }<br/>    );<br/><br/>    return proxy as any;<br/>}</pre>
<p>It is only later, when one of the properties in the result is accessed, that the <kbd>proxy handler</kbd> is invoked and filtering takes place:</p>
<pre>const heroes = [<br/>    {<br/>        name: "Spiderman",<br/>        powers: [<br/>            "wall-crawling",<br/>            "enhanced strength",<br/>            "enhanced speed",<br/>            "spider-Sense"<br/>        ]<br/>    },<br/>    {<br/>        name: "Superman",<br/>        powers: [<br/>            "flight",<br/>            "superhuman strength",<br/>            "x-ray vision",<br/>            "super-speed"<br/>        ]<br/>    }<br/>];<br/><br/>console.log("A");<br/>const spiderman = lazyFind(heroes, (h) =&gt; h.name === "Spiderman");<br/>console.log("B");<br/>console.log(spiderman.name);<br/>console.log("C");<br/><br/>/*<br/>    A<br/>    B<br/>    Filtering...<br/>    Spiderman<br/>    C<br/>*/</pre>
<p><span>If we examine the console output, we will be able to see that the <span class="packt_screen">Filtering...</span> message is not logged into the console until we access the property <kbd>name</kbd> of the <kbd>result</kbd> object. The preceding implementation is a very rudimentary implementation, but it can help us to understand how lazy evaluation works. Laziness can sometimes improve the overall performance of our applications.</span></p>
<div class="packt_infobox">
<p>We will learn more about function composition patterns later in <a href="6a03c916-f7a5-439a-bea6-6facecef0347.xhtml" target="_blank">Chapter 9</a><span>,</span> <em>Functional-Reactive Programming</em><span>.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored some of the most fundamental principles and concepts of the functional programming paradigm.</p>
<p class="mce-root">Over the next four chapters, we are going to deviate a little bit from functional programming because we are going to take an extensive look at functions, asynchronous programming, and certain aspects of the TypeScript/JavaScript runtime, such as closures and prototypes. We need to explore these topics before we can learn more about the implementation of functional programming techniques. However, if you are already very confident with using functions, closures, the <kbd>this</kbd> operator, and prototypes, then you should be able to skip the next four chapters.</p>


            </article>

            
        </section>
    </body></html>