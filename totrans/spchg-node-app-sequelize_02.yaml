- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Defining and Using Sequelize Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用 Sequelize 模型
- en: For our *Avalon Airlines* project that we introduced in the previous chapter,
    we will need to instruct our application on how we want to define our database’s
    schematics. A database can have various roles and applications but only a single
    purpose, and that purpose is to organize our data (storage is the filesystem’s
    job). Before we can begin defining our models within the Node.js application,
    we need to think about the entities of our business logic and models from a project’s
    perspective (and each project will have different requirements). Most projects
    will structure their schema in a way that categorizes *organizations* (for example,
    customers, employees, vendors, and companies) and *things* such as products, planes,
    and receipts from transactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在上一章中介绍的 *Avalon Airlines* 项目，我们需要指导我们的应用程序如何定义我们数据库的图。数据库可以有多种角色和应用，但只有一个目的，那就是组织我们的数据（存储是文件系统的职责）。在我们开始在
    Node.js 应用程序中定义模型之前，我们需要从项目角度考虑我们的业务逻辑和模型（每个项目都会有不同的要求）。大多数项目都会以一种方式结构化其图，将 *组织*（例如，客户、员工、供应商和公司）以及
    *事物*（如产品、飞机和交易收据）进行分类。
- en: '`snake_case` or with a `PascalCase` pattern). Relations—or associations—between
    models will be automatically created and managed by Sequelize. Business logic
    workflows can also be established so that you do not have to remember workflows
    such as *removing the customer’s boarding pass if they canceled their trip*. That
    part would be handled in one organized place versus invoking `RemoveBoardingPass(...)`
    in every code section that cancels a trip (regardless of whether the method was
    called from the customer, an employee, and so on). This chapter will teach you
    how to define and synchronize your models with a database and how to apply the
    data to a Node.js runtime application using Sequelize. This will be the initial
    foundation on how to operate Sequelize.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`snake_case` 或 `PascalCase` 模式）。模型之间的关系或关联将由 Sequelize 自动创建和管理。还可以建立业务逻辑工作流程，这样您就不必记住像
    *如果客户取消了行程，则删除客户的登机牌* 这样的工作流程。这部分将由一个组织良好的地方处理，而不是在每个取消行程的代码部分调用 `RemoveBoardingPass(...)`（无论该方法是从客户、员工等调用）。本章将教会您如何定义和同步您的模型与数据库，以及如何使用
    Sequelize 将数据应用到 Node.js 运行时应用程序。这将是我们操作 Sequelize 的初始基础。'
- en: 'This chapter will introduce you to the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍以下概念：
- en: Defining models for a database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库模型
- en: Exploring the various Sequelize data types and when to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索各种 Sequelize 数据类型及其使用时机
- en: Migrating schematic changes and data from Sequelize to the database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sequelize 中的图和数据进行迁移到数据库
- en: Manipulating and querying data using Sequelize
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sequelize 操作和查询数据
- en: Advanced Sequelize options for defining models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模型的 Sequelize 高级选项
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章中包含的代码文件，地址为 [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2)
- en: Defining models for a database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为数据库定义模型
- en: In this section, we will go over a brief overview of our project’s requirements
    and establish which kinds of models we need to define. After that, we will run
    a script generator command from the Sequelize **command-line interface** (**CLI**)
    tool and inspect the basic structure of a model’s definition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要概述我们项目的要求，并确定我们需要定义哪些类型的模型。之后，我们将从 Sequelize **命令行界面**（**CLI**）工具运行一个脚本生成命令，并检查模型定义的基本结构。
- en: 'For *Avalon Airlines*, we will begin modeling with the following *organizations*
    and *things*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Avalon Airlines*，我们将从以下 *组织* 和 *事物* 开始建模：
- en: Airplanes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞机
- en: Customers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Flight schedules
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞行计划
- en: Boarding tickets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登机牌
- en: Each model will have its own table within the database. We will eventually associate
    these models or tables with columns, indices, validation, and relations to other
    models. For now, we will define, select (or query), insert, update, and delete
    data from these tables using Sequelize within our Node.js application. If you
    are working on a pre-existing project that already has a database, the *Manipulating
    and querying data using Sequelize* section will pertain to you more than to someone
    starting on a project from a clean slate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型将在数据库中拥有自己的表。我们最终将把这些模型或表与列、索引、验证和其他模型的关系关联起来。目前，我们将在 Node.js 应用程序中使用 Sequelize
    定义、选择（或查询）、插入、更新和删除这些表中的数据。如果您正在处理一个已经存在数据库的现有项目，那么“使用 Sequelize 操作和查询数据”这一部分将比从零开始的项目更有相关性。
- en: 'We will first generate our models with the minimum requirements for columns
    using the Sequelize CLI tool. Then, we will go over the code that was generated
    by the CLI so that you are more familiar with how to define Sequelize models without
    depending on the CLI. Generate the previously mentioned models with the following
    commands within the project’s root directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用 Sequelize CLI 工具生成满足列的最小要求的模型。然后，我们将回顾 CLI 生成的代码，以便您更熟悉如何在不依赖 CLI 的情况下定义
    Sequelize 模型。在项目的根目录下使用以下命令生成之前提到的模型：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may have noticed we used a singular noun for our models’ names. Sequelize
    will automatically pluralize the associated table and models for us. You can disable
    this behavior via Sequelize configuration settings, which will be discussed in
    detail further in this chapter. For our `BoardingTickets` model, we will generate
    associations of a customer and flight schedules in the next chapter, but for now,
    we can build the bare minimum for the table.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们为模型名称使用了单数名词。Sequelize 会自动为我们将关联的表和模型复数化。您可以通过 Sequelize 配置设置来禁用此行为，这将在本章后面详细讨论。对于我们的
    `BoardingTickets` 模型，我们将在下一章生成客户和航班计划的关联，但就目前而言，我们可以为表构建最基本的结构。
- en: Tip
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Sequelize comes with some useful utility functions available to the developer.
    The framework uses a library called `Sequelize`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 为开发者提供了一些有用的实用函数。该框架使用一个名为 `Sequelize` 的库。
- en: 'Opening the `models/flightschedule.js` file, we should see the following generated
    code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `models/flightschedule.js` 文件，我们应该看到以下生成的代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `''use strict'';` line in the preceding code snippet will tell our Node.js
    runtime to execute the JavaScript file (`models/flightschedule.js`) with a set
    of rules to help alleviate **sloppy mode**. **Strict mode** will prohibit the
    developer from assigning values to undeclared variables, using reserved keywords
    as defined by **ECMAScript 2015** (**ES6**), and so on. This mode is completely
    optional for the contents of this book; however, if you wish to learn more, Mozilla
    offers a helpful guide on the differences between strict and sloppy mode here:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段中的 `'use strict';` 行将告诉我们的 Node.js 运行时使用一组规则来执行 JavaScript 文件（`models/flightschedule.js`），以帮助减轻**宽松模式**。**严格模式**将禁止开发者向未声明的变量赋值，使用由
    **ECMAScript 2015**（**ES6**）定义的保留关键字等。这种模式对于本书的内容完全是可选的；然而，如果您想了解更多，Mozilla 提供了一份关于严格模式和宽松模式之间差异的有用指南：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode)。
- en: The next set of instructions is to import the `Model` class from Sequelize,
    which we will use to initialize the model in the next few commands. The `module.exports`
    line that follows is a pattern that the Sequelize model loader (the `models/index.js`
    file) can interpret and how to invoke the file. The first argument provides an
    instance of Sequelize to us with all of the parameters and configuration settings
    that we established from the `models/index.js` file. The second parameter, `DataTypes`,
    provides a more ergonomic way of declaring the various data types for our columns
    (for example, instead of having to type out `sequelize.DataTypes.STRING`, we can
    omit the `sequelize.` instance prefix and just use `DataTypes.STRING`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是从 Sequelize 导入 `Model` 类，我们将在接下来的几个命令中使用它来初始化模型。随后的 `module.exports` 行是一个模式，Sequelize
    模型加载器（`models/index.js` 文件）可以解释并调用该文件。第一个参数为我们提供了一个 Sequelize 实例，其中包含我们从 `models/index.js`
    文件中设置的参数和配置设置。第二个参数 `DataTypes` 提供了一种更方便的方式来声明我们列的各种数据类型（例如，我们不需要输入 `sequelize.DataTypes.STRING`，我们可以省略
    `sequelize.` 实例前缀，直接使用 `DataTypes.STRING`）。
- en: Next, we define our `FlightSchedule` class and extend Sequelize’s `Model` class.
    Here, we can define our associations, hooks/events, table information, and so
    on. The CLI will generate a static function for us called **associations**. For
    now, we can leave this function as is; we will modify it later throughout the
    book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `FlightSchedule` 类并扩展 Sequelize 的 `Model` 类。在这里，我们可以定义我们的关联、钩子/事件、表信息等。CLI
    将为我们生成一个名为 **associations** 的静态函数。目前，我们可以保持这个函数不变；我们将在本书的后续部分对其进行修改。
- en: 'The last instruction within this file takes our `FlightSchedule` class and
    invokes the `init()` function, which will set up internal rules and instructions
    to help Sequelize navigate the model’s definition. This is also where Sequelize
    learns how to synchronize the model with the database, as shown in the following
    screenshot. If you were to set Sequelize’s option to `sync: true`, there would
    be additional `DROP TABLE IF EXISTS` for when we want to test our application
    on a clean slate every runtime. Having the sync option set to `true` is useful
    for unit tests and early prototype development. It is *not* recommended to set
    this option to `true` within a production environment:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '文件中的最后一条指令是调用 `FlightSchedule` 类的 `init()` 函数，这将设置内部规则和指令以帮助 Sequelize 导航模型定义。这也是
    Sequelize 学习如何与数据库同步的地方，如下面的截图所示。如果你将 Sequelize 的选项设置为 `sync: true`，则会在每次运行时添加额外的
    `DROP TABLE IF EXISTS` 指令，以便我们在每次运行时都能在一个干净的状态下测试我们的应用程序。将同步选项设置为 `true` 对于单元测试和早期原型开发很有用。**不推荐**在生产环境中将此选项设置为
    `true`：'
- en: '![Figure 2.1 – Sequelize’s automatic synchronization ](img/Figure_2.1_B17841.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Sequelize 的自动同步](img/Figure_2.1_B17841.jpg)'
- en: Figure 2.1 – Sequelize’s automatic synchronization
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Sequelize 的自动同步
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Running our Node.js application and letting Sequelize synchronize our database
    is fine for the initial implementation phase, but we will go over the methodology
    of using Sequelize’s CLI and migrations to perform the necessary SQL commands
    to synchronize the database. Migrations offer incremental changes/updates as opposed
    to the Sequelize synchronize option, which is more of a generic solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的 Node.js 应用程序并让 Sequelize 同步数据库对于初始实现阶段来说是可行的，但我们将介绍使用 Sequelize 的 CLI
    和迁移来执行必要的 SQL 命令以同步数据库的方法。迁移提供了增量更改/更新，而 Sequelize 同步选项则更像是通用的解决方案。
- en: The first parameter of the `init()` function is where we define our model’s
    attributes (or columns). The pattern for this is typically an object with the
    keys as column names and the value for each key is either a DataType, a literal
    string value, or an object containing advanced options for each column. From this
    example, we are shown three columns (`originAirport`, `destinationAirport`, and
    `departureTime`) with `string`, `string`, and `date` data types respectively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 函数的第一个参数是我们定义模型属性（或列）的地方。这种模式的典型形式是一个对象，其键为列名，每个键的值可以是数据类型、一个字面字符串值，或者包含每个列高级选项的对象。从这个例子中，我们可以看到三个列（`originAirport`、`destinationAirport`
    和 `departureTime`），它们分别对应 `string`、`string` 和 `date` 数据类型。'
- en: The second parameter lets us define instance type settings for the model explicitly.
    This is where we can define a different table name, choose whether to pluralize
    our tables, disable meta columns (such as `createdAt` and `updatedAt`), and so
    on. We will go into details about these options later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数允许我们明确地定义模型的实例类型设置。在这里，我们可以定义不同的表名，选择是否使我们的表名复数化，禁用元列（如 `createdAt` 和 `updatedAt`），等等。我们将在本章后面详细介绍这些选项。
- en: 'If you prefer to not use classes in your project, there is another way to define
    our models. The following code snippet provides an example of using Sequelize’s
    `define()` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢不在你的项目中使用类，还有一种定义我们模型的方法。以下代码片段提供了一个使用 Sequelize 的 `define()` 函数的示例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parameters remain relatively the same as `init()` except that the first
    parameter is now the model’s name. Either way is acceptable and one does not provide
    advantages over the other from Sequelize’s point of view. This book will use the
    former example throughout its code base (the `Model` class), but for advanced
    configuration settings and adding associations, this book will illustrate both
    styles as there are some fundamental differences, ergonomically speaking. For
    programmers who favor using TypeScript over JavaScript, the `Model` class method
    may provide a more native experience to you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与 `init()` 几乎相同，只是第一个参数现在是模型名称。两种方式都是可接受的，并且从 Sequelize 的角度来看，一种方式并不比另一种方式有优势。本书将在其代码库（`Model`
    类）中使用前者示例，但对于高级配置设置和添加关联，本书将展示两种风格，因为从人体工程学的角度来看，有一些基本差异。对于更喜欢使用 TypeScript 而不是
    JavaScript 的程序员，`Model` 类方法可能为你提供更原生体验。
- en: Now that we have an understanding of how models are defined in Sequelize, we
    can go over which built-in attribute data types Sequelize has to offer, along
    with a brief explanation to help guide your future model designs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 Sequelize 中定义模型，我们可以回顾 Sequelize 提供的内置属性数据类型，以及简要说明以帮助指导你未来的模型设计。
- en: Exploring the various Sequelize data types and when to use them
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索各种 Sequelize 数据类型及其使用时机
- en: As explained earlier, Sequelize offers us various data types to help map our
    model’s attributes to their respective **database management system** (**DBMS**)
    column types. Next is a list of what Sequelize has to offer, along with a brief
    explanation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Sequelize 提供了各种数据类型，以帮助将模型的属性映射到相应的 **数据库管理系统**（**DBMS**）列类型。以下是 Sequelize
    提供的内容列表，以及简要说明。
- en: STRING
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STRING
- en: The `STRING` data type refers to a `VARCHAR` fields usually contain meta information
    to help optimize the DBMS’ query planner. MySQL explicitly adds another byte to
    the column’s prefix header if the size of the string is greater than 255 bytes.
    A query planner could use this information to help alleviate pressure from memory,
    or the `VARCHAR` with a fixed paging length, you would define the column as `DataTypes.STRING(100)`
    instead of `DataTypes.STRING`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRING` 数据类型指的是通常包含元信息的 `VARCHAR` 字段，以帮助优化数据库管理系统的查询计划。如果字符串的大小超过 255 字节，MySQL
    会明确地在列的前缀标题中添加另一个字节。查询计划器可以使用这些信息来帮助减轻内存压力，或者对于具有固定分页长度的 `VARCHAR`，你将定义列为 `DataTypes.STRING(100)`
    而不是 `DataTypes.STRING`。'
- en: Within a `VARCHAR` column type, the DBMS will not store the value as a fixed
    length (no padding is required). If you need data to be retrieved in the exact
    same way it was stored, you could use the `VARCHAR BINARY` column type. This can
    be achieved by declaring the column’s data type as `DataTypes.STRING.BINARY`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `VARCHAR` 列类型中，数据库管理系统不会以固定长度存储值（不需要填充）。如果你需要以与存储时完全相同的方式检索数据，可以使用 `VARCHAR
    BINARY` 列类型。这可以通过将列的数据类型声明为 `DataTypes.STRING.BINARY` 来实现。
- en: Despite having the word “binary” in the data type’s name, for storing movies,
    pictures, and so on, it is often recommended to use the `BLOB` type over `VARCHAR
    BINARY`. The binary part of `VARCHAR BINARY` performs comparisons over the binary
    representation of that column versus a **character set** (**charset**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据类型名称中包含“二进制”一词，但在存储电影、图片等时，通常建议使用 `BLOB` 类型而不是 `VARCHAR BINARY`。`VARCHAR
    BINARY` 的二进制部分是在该列的二进制表示与 **字符集**（**charset**）之间进行比较。
- en: 'For instance, suppose we had the following rows in a database: `A`, `a`, `B`,
    and `b`. The `VARCHAR` column type would have an internal map to tell the database
    that “A” and “a” will be listed prior to “B” and “b”. In a `VARCHAR BINARY` column,
    the sum binary representation of `A`, `a`, `B`, and `b` would be `0`, `2`, `1`,
    `3`, which would sort into the following: `A`, `B`, `a`, `b`. There is no internal
    map/charset for `VARCHAR BINARY` columns, so the database would not be able to
    tell that “A” and “a” are actually the same letter.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在数据库中有以下行：`A`、`a`、`B` 和 `b`。`VARCHAR` 列类型将有一个内部映射来告诉数据库，“A”和“a”将排在“B”和“b”之前。在
    `VARCHAR BINARY` 列中，`A`、`a`、`B` 和 `b` 的二进制表示之和将是 `0`、`2`、`1`、`3`，这将排序为以下顺序：`A`、`B`、`a`、`b`。`VARCHAR
    BINARY` 列没有内部映射/字符集，因此数据库无法知道“a”和“A”实际上是同一个字母。
- en: 'For the most part, we could use `VARCHAR BINARY` and `BLOB` interchangeably
    in MySQL versions above 5.0.2\. There are some small subtle differences, as indicated
    here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，我们可以在 MySQL 版本 5.0.2 以上将 `VARCHAR BINARY` 和 `BLOB` 互换使用。这里有一些细微的差别，如下所示：
- en: An index prefix length must be specified for `BLOB` indexes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `BLOB` 索引必须指定索引前缀长度
- en: '`BLOB` column types cannot have default values'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOB` 列类型不能有默认值'
- en: CHAR
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CHAR
- en: The `CHAR` data type is similar to the `STRING` data type, except that it references
    the `CHAR` column type. Traditionally, a DBMS will cap the length of a `CHAR`
    column to 255 characters. A `VARCHAR` type will allow you to go over the specified
    paging size without an error or an exception. A `CHAR` column could be used as
    a last-resort effort for validating your data and ensuring it does not exceed
    the specified length (for example, `CHAR(20)` would cap the data to 20 characters
    defined by the table’s collation). `CHAR` column types are padded to their fixed
    length, which could help optimize the DBMS—or even your application—presuming
    that the pre-determined length is appropriate for the scenario’s paging size.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR` 数据类型与 `STRING` 数据类型相似，不同之处在于它引用的是 `CHAR` 列类型。传统上，数据库管理系统会将 `CHAR` 列的长度限制为
    255 个字符。`VARCHAR` 类型允许您超过指定的分页大小而不会出现错误或异常。`CHAR` 列可以用作最后的手段来验证您的数据，并确保它不超过指定的长度（例如，`CHAR(20)`
    将数据限制为表中排序规则定义的 20 个字符）。`CHAR` 列类型会被填充到其固定长度，这有助于优化数据库管理系统——甚至您的应用程序——前提是预定的长度适合该场景的分页大小。'
- en: TEXT/TINYTEXT/MEDIUMTEXT/LONGTEXT
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TEXT/TINYTEXT/MEDIUMTEXT/LONGTEXT
- en: 'Database designers understand that sometimes, our text data requires a considerable
    amount of space or needs to be associated with rows larger than 65,535 bytes (a
    MySQL `VARCHAR` limitation). In this case, we would use a `TEXT` column type.
    Every DBMS has its nuances and limitations; since this book uses MySQL, we will
    briefly go over MySQL’s `TEXT` limitations, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计者知道，有时我们的文本数据需要相当大的空间，或者需要与大于 65,535 字节（MySQL `VARCHAR` 限制）的行相关联。在这种情况下，我们会使用
    `TEXT` 列类型。每个数据库管理系统都有其细微差别和限制；由于本书使用 MySQL，我们将简要介绍 MySQL 的 `TEXT` 限制，如下所示：
- en: '`TINYTEXT`: 255 bytes'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TINYTEXT`: 255 字节'
- en: '`TEXT`: 64 **kilobytes** (**KB**)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT`: 64 **千字节** (**KB**)'
- en: '`MEDIUMTEXT`: 16 **megabytes** (**MB**)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIUMTEXT`: 16 **兆字节** (**MB**)'
- en: '`LONGTEXT`: 4 **gigabytes** (**GB**)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONGTEXT`: 4 **千兆字节** (**GB**)'
- en: '`DataTypes.TEXT` will default to the `TEXT` column type, and if you wanted
    to declare your column type as `TINYTEXT`, `MEDIUMTEXT`, or `LONGTEXT`, you would
    use `DataTypes.TEXT(''TINY'')`, `DataTypes.TEXT(''MEDIUM'')`, or `DataTypes.TEXT(''LONG'')`,
    respectively. Unlike the `VARCHAR` type, there is no `BINARY` option for `TEXT`
    column types. For storing serialized binary types, you would use `VARCHAR BINARY`
    or `BLOB` instead.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTypes.TEXT` 将默认为 `TEXT` 列类型，如果您想将列类型声明为 `TINYTEXT`、`MEDIUMTEXT` 或 `LONGTEXT`，则分别使用
    `DataTypes.TEXT(''TINY'')`、`DataTypes.TEXT(''MEDIUM'')` 或 `DataTypes.TEXT(''LONG'')`。与
    `VARCHAR` 类型不同，`TEXT` 列类型没有 `BINARY` 选项。对于存储序列化的二进制类型，您将使用 `VARCHAR BINARY` 或
    `BLOB`。'
- en: CITEXT
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CITEXT
- en: '**CITEXT** stands for **Case-Insensitive Text**, which is a column that preserves
    the data’s casing except for comparison operations. This option is available for
    Postgres and SQLite databases only.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**CITEXT** 代表 **不区分大小写的文本**，这是一个在比较操作之外保留数据大小写的列。此选项仅适用于 Postgres 和 SQLite
    数据库。'
- en: NUMBER
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NUMBER
- en: Not to be confused with Postgres’ `NUMERIC` type, the `NUMBER` data type is
    an abstraction for more than an explicit type, depending on its configuration
    settings. This data type should *not* be used directly unless you are extending/adding
    your own numeric data type. This abstract data type could help organize your code
    if you use the same precision and scale values throughout your database, or if
    your online store sells a product in different denominations and currencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与Postgres的`NUMERIC`类型混淆，`NUMBER`数据类型是根据其配置设置的一个抽象类型，而不仅仅是显式类型。除非您正在扩展/添加自己的数值数据类型，否则不应直接使用此抽象数据类型。如果您的数据库中使用了相同的精度和比例值，或者您的在线商店以不同的货币销售产品，则此抽象数据类型可以帮助组织您的代码。
- en: 'The following code snippet provides an example of how you would extend your
    own numeric data type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了一个如何扩展您自己的数值数据类型的示例：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: INTEGER/TINYINT/SMALLINT/MEDIUMINT/BIGINT
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INTEGER/TINYINT/SMALLINT/MEDIUMINT/BIGINT
- en: 'With `DataTypes.INTEGER`, `DataTypes.SMALLINT`, and so on, we can associate
    our attributes with the respective column types. You can find references for minimum
    and maximum values for each integer type with MySQL here: [https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml](https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml).
    To declare your model’s attribute as an unsigned value, we can attach the `UNSIGNED`
    option to our data type, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DataTypes.INTEGER`、`DataTypes.SMALLINT`等，我们可以将我们的属性与相应的列类型关联起来。您可以在MySQL中找到每个整数类型的最大和最小值参考：[https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml](https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml)。要声明您的模型属性为无符号值，我们可以在数据类型上附加`UNSIGNED`选项，如下所示：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we wanted to have our attribute unsigned and zero-filled, we can chain the
    data-type options, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要我们的属性无符号且零填充，我们可以链式调用数据类型选项，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on which DBMS you use, the `ZEROFILL` option may not be available
    to you. If you are using a Postgres database, then the order of assigning those
    attributes is important (`UNSIGNED` must be declared before `ZEROFILL`). In MySQL,
    the `ZEROFILL` option will also imply `UNSIGNED` automatically. The `ZEROFILL`
    attribute will only affect the data from an aesthetics perspective (when you select
    data) and will not modify your data in storage.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的数据库管理系统（DBMS），`ZEROFILL`选项可能不可用。如果您使用的是Postgres数据库，那么分配这些属性的顺序很重要（`UNSIGNED`必须在`ZEROFILL`之前声明）。在MySQL中，`ZEROFILL`选项也会自动隐含`UNSIGNED`。`ZEROFILL`属性将只从美学角度（当您选择数据时）影响数据，而不会修改您的存储数据。
- en: FLOAT/REAL
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FLOAT/REAL
- en: Traditionally, a DBMS will differentiate between `FLOAT` and `REAL` column types
    by their bit precisions. `FLOAT` columns are usually stored with 32-bit precision,
    and `REAL` column types are stored with 64-bit precision. `REAL` column types
    are 64-bit and `FLOAT` columns are 32-bit. To make things even more confusing,
    MySQL will treat `REAL` as the same as a `DOUBLE` (also known as `DOUBLE PRECISION`
    and `DECIMAL`) column.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，数据库管理系统（DBMS）会根据位精度来区分`FLOAT`和`REAL`列类型。`FLOAT`列通常以32位精度存储，而`REAL`列类型则以64位精度存储。`REAL`列类型是64位的，而`FLOAT`列是32位的。更令人困惑的是，MySQL会将`REAL`视为与`DOUBLE`（也称为`DOUBLE
    PRECISION`和`DECIMAL`）列相同。
- en: 'Internally, Sequelize handles `FLOAT`, `REAL`, and `DOUBLE` in the same way.
    There is a small float validation performed for the `FLOAT` type explicitly, but
    otherwise, Sequelize will translate the column type directly to the DBMS. Just
    as with the integer data types, `UNSIGNED` and `ZEROFILL` can be defined on these
    attributes as well, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Sequelize以相同的方式处理`FLOAT`、`REAL`和`DOUBLE`。对于`FLOAT`类型，会显式执行一个小浮点验证，但除此之外，Sequelize将直接将列类型转换为数据库管理系统。就像整数数据类型一样，`UNSIGNED`和`ZEROFILL`也可以定义在这些属性上，如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: DECIMAL/DOUBLE
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DECIMAL/DOUBLE
- en: The `DECIMAL` or `DOUBLE` data type allows us to define a precise length and
    scale for our columns using the traditional format of `DECIMAL(P, S`) where `P`
    > `S`. The `P` variable is the number’s precision and the `S` variable is the
    number’s scale. The precision determines the maximal length of the whole number
    part, and the scale defines the maximal length of the decimal part. For example,
    `DataTypes.DECIMAL(6, 4`) will give us a decimal column with a precision of 6
    and a scale of 4\. An example value for this column could be `38.3411`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECIMAL`或`DOUBLE`数据类型允许我们使用传统的`DECIMAL(P, S)`格式定义列的精确长度和比例，其中`P` > `S`。`P`变量是数字的精度，而`S`变量是数字的比例。精度决定了整个数字部分的长度，而比例定义了小数部分的长度。例如，`DataTypes.DECIMAL(6,
    4)`将给我们一个精度为6和比例为4的十进制列。此列的一个示例值可以是`38.3411`。'
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may use `DataTypes.NUMERIC` as an alias for `DataTypes.DECIMAL`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `DataTypes.NUMERIC` 作为 `DataTypes.DECIMAL` 的别名使用。
- en: BOOLEAN
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BOOLEAN
- en: There are many ways to express a `false` and 1 for `true`. Sometimes, the Boolean
    value will be stored as a string such as `true`, `false`, `t`, or `f`. Sequelize
    will automatically handle numerical—or bit—values, as well as the “`true`” or
    “`false`” string expressions as appropriate Boolean values for Node.js. If the
    value is marked as “`t`” or “`f`”, then Sequelize will pass the raw value along
    to the programmer to handle (as a way to avoid being over presumptuous—this behavior
    may change in the future). A Boolean column can be defined with just `DataTypes.BOOLEAN`.
    There are no arguments or inputs to process for this data type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表达 `false` 和 `true` 的 1 有许多方式。有时，布尔值可能以字符串形式存储，例如 `true`、`false`、`t` 或 `f`。Sequelize
    会自动处理数值或位值，以及“`true`”或“`false`”字符串表达式作为 Node.js 的适当布尔值。如果值标记为“`t`”或“`f`”，则 Sequelize
    将将原始值传递给程序员处理（作为一种避免过于自信的方式——此行为可能在将来发生变化）。布尔列可以用 `DataTypes.BOOLEAN` 定义。此数据类型没有参数或输入要处理。
- en: DATE/DATEONLY/TIME
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DATE/DATEONLY/TIME
- en: The `DATE` data type references the `DATETIME` column types for MySQL, MariaDB,
    and SQLite. For Postgres, the `DATE` data type will be translated as `TIMESTAMP
    WITH TIME ZONE`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATE` 数据类型引用 MySQL、MariaDB 和 SQLite 的 `DATETIME` 列类型。对于 Postgres，`DATE` 数据类型将被转换为
    `TIMESTAMP WITH TIME ZONE`。'
- en: 'In MySQL, you can define fractional seconds for `DATETIME` columns by up to
    six digits, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，你可以为 `DATETIME` 列定义最多六位小数的分数秒，如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you wish to keep just the date or time, you may use `DataTypes.DATEONLY`
    or `DataTypes.TIME`, respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想保留日期或时间，你可以分别使用 `DataTypes.DATEONLY` 或 `DataTypes.TIME`。
- en: Quick note on Postgres without time zones
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不带时区的 Postgres 的快速说明
- en: 'If you are using Postgres with a column type of `TIMESTAMP WITHOUT TIME ZONE`,
    and you know the data’s time differentiates that from the server that is running
    the application, it is recommended to set the time zone’s offset. This can be
    achieved via the `pg` Node.js library, as illustrated here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是带有 `TIMESTAMP WITHOUT TIME ZONE` 列类型的 Postgres，并且你知道数据的时间与运行应用程序的服务器不同，建议设置时区偏移量。这可以通过
    `pg` Node.js 库实现，如下所示：
- en: '`var types = require(''pg'').types`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`var types = require(''pg'').types`'
- en: '`function setTimestampWithoutTimezoneOffset(val) {`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`function setTimestampWithoutTimezoneOffset(val) {`'
- en: '`    // ''+0000'' being the UTC offset, change this to the desired time zone`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`    // ''+0000'' 是 UTC 偏移量，将其更改为所需时区`'
- en: '`    return val === null ? null : new Date(stringValue + ''+0000'');`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`    return val === null ? null : new Date(stringValue + ''+0000'');`'
- en: '`}`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`types.setTypeParser(types.builtins.TIMESTAMP, setTimestampWithoutTimezoneOffset);`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`types.setTypeParser(types.builtins.TIMESTAMP, setTimestampWithoutTimezoneOffset);`'
- en: 'For more information on setting types for Postgres within Node.js, refer to
    the following link: [https://github.com/brianc/node-pg-types](https://github.com/brianc/node-pg-types)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 Node.js 中为 Postgres 设置类型的更多信息，请参阅以下链接：[https://github.com/brianc/node-pg-types](https://github.com/brianc/node-pg-types)
- en: NOW
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOW
- en: '`DataTypes.NOW` is a special type within Sequelize. It is not to be used as
    the column’s type but as the attribute’s value and is traditionally set as the
    attribute’s `defaultValue` option. If we wanted a `Receipt` model that kept track
    of when a transaction was made, it would look similar to this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTypes.NOW` 是 Sequelize 中的一个特殊类型。它不应用作列的类型，而应作为属性值，并且传统上设置为属性的 `defaultValue`
    选项。如果我们想要一个 `Receipt` 模型来跟踪交易时间，它看起来会像这样：'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Whenever we insert a `Receipt` record, Sequelize will automatically convert
    the `dateOfPurchase` attribute’s value to the DBMS’ `NOW()` function from the
    attribute’s `defaultValue` option using Sequelize’s `DataTypes.NOW` data type.
    If we have defined a value for the attribute initially, then Sequelize will use
    that value instead.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们插入一个 `Receipt` 记录时，Sequelize 会自动将 `dateOfPurchase` 属性的值转换为 DBMS 的 `NOW()`
    函数，使用 Sequelize 的 `DataTypes.NOW` 数据类型，并从属性的 `defaultValue` 选项中获取。如果我们最初为属性定义了一个值，那么
    Sequelize 将使用该值。
- en: HSTORE
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HSTORE
- en: '`HSTORE` is for Postgres only. This data type is used for mapped key-value
    types but is often replaced by `JSON` or `HSTORE`, there is a caveat to keep in
    mind, which is to install the `pg-hstore` Node.js library. The full installation
    command would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`HSTORE` 仅适用于 Postgres。此数据类型用于映射键值类型，但通常被 `JSON` 或 `HSTORE` 替换，但需要注意一个注意事项，即需要安装
    `pg-hstore` Node.js 库。完整的安装命令如下所示：'
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For selecting data, in Sequelize, your `where` clause would be an object instead
    of an integer, string, and so on. An example would look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sequelize 中选择数据时，您的 `where` 子句将是一个对象，而不是整数、字符串等。一个例子如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: JSON
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: 'The `JSON` data type is available for SQLite, MariaDB, MySQL, and Postgres.
    When defining an attribute with the `JSON` type, you can query information similar
    to how the `HSTORE` type is queried, with the exception of having the ability
    to deeply nest your search clause. Let us say we had the following `JSON` data
    type stored in a column:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON` 数据类型适用于 SQLite、MariaDB、MySQL 和 Postgres。当使用 `JSON` 类型定义属性时，您可以查询类似于
    `HSTORE` 类型查询的信息，除了您无法深度嵌套您的搜索子句。假设我们有一个以下 `JSON` 数据类型存储在列中：'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We would search for the nested value like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按如下方式搜索嵌套值：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Please note that MySQL and MariaDB introduced support for `DataTypes.JSON`
    attribute type will not be compatible with your database. To resolve this issue,
    you can define models with getters/setters that will store and retrieve the JSON
    document, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MySQL 和 MariaDB 引入了对 `DataTypes.JSON` 属性类型支持，将不会与您的数据库兼容。要解决这个问题，您可以定义具有获取器/设置器的模型，这些获取器/设置器将存储和检索
    JSON 文档，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For users of MSSQL 2016 and above, please refer to [https://sequelize.org/master/manual/other-data-types.xhtml#mssql](https://sequelize.org/master/manual/other-data-types.xhtml#mssql)
    as a workaround for handling JSON column types with this DBMS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 MSSQL 2016 及以上版本的用户，请参阅 [https://sequelize.org/master/manual/other-data-types.xhtml#mssql](https://sequelize.org/master/manual/other-data-types.xhtml#mssql)
    作为处理此 DBMS 中 JSON 列类型的解决方案。
- en: JSONB
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSONB
- en: The `JSONB` data type is reserved for Postgres only. If you are using a JSON
    column for storage, it is recommended to use the `JSON` column type, and if you
    are using comparison operators on the column, it is recommended to use the `JSONB`
    column type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONB` 数据类型仅适用于 Postgres。如果您使用 JSON 列进行存储，建议使用 `JSON` 列类型；如果您在该列上使用比较运算符，建议使用
    `JSONB` 列类型。'
- en: 'Other than the previously mentioned way of querying JSON data, you can also
    query JSONB data types with the following formats:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的查询 JSON 数据的方法之外，您还可以使用以下格式查询 JSONB 数据类型：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: BLOB
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLOB
- en: 'Several databases, including MySQL, offer a range of `BLOB` attribute type,
    Postgres will always be converted into a `bytea` (byte array) column type. This
    data type is useful for storing anything binary-related, such as images, documents,
    or serialized data. You can see an example of it in use here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 MySQL 在内的几个数据库提供了一系列 `BLOB` 属性类型，Postgres 总是将它们转换为 `bytea`（字节数组）列类型。这种数据类型适用于存储任何与二进制相关的数据，例如图像、文档或序列化数据。您可以在以下示例中看到它的使用：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is a table of different `BLOB` types with their byte prefix length and
    their maximum storage length for MySQL:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个不同 `BLOB` 类型及其字节前缀长度和最大存储长度的表格，适用于 MySQL：
- en: '| BLOB Type | Byte Prefix Length | Maximum Storage (in bytes) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| BLOB 类型 | 字节前缀长度 | 最大存储（以字节为单位） |'
- en: '| TINYBLOB | 1 byte | 2^8 - 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| TINYBLOB | 1 字节 | 2^8 - 1 |'
- en: '| BLOB | 2 bytes | 2^16 - 1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| BLOB | 2 字节 | 2^16 - 1 |'
- en: '| MEDIUMBLOB | 3 bytes | 2^24-1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| MEDIUMBLOB | 3 字节 | 2^24-1 |'
- en: '| LONGBLOB | 4 bytes | 2^32 - 1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| LONGBLOB | 4 字节 | 2^32 - 1 |'
- en: RANGE
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RANGE
- en: '`RANGE` data types are reserved for Postgres only. Supported range types are
    `INTEGER`, `BIGINT`, `DATE`, `DATEONLY`, and `DECIMAL`. You may define an attribute
    with the range type like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANGE` 数据类型仅适用于 Postgres。支持的范围类型是 `INTEGER`、`BIGINT`、`DATE`、`DATEONLY` 和 `DECIMAL`。您可以定义具有范围类型的属性，如下所示：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are a couple of ways to create ranges for our models, as illustrated
    here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，我们可以为我们的模型创建范围，有几种方法可以做到这一点：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When querying a range column, the data for that attribute will always return
    in object notation with the `value` and `inclusive` keys.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询范围列时，该属性的值将始终以对象表示法返回，带有 `value` 和 `inclusive` 键。
- en: UUID/UUIDV1/UUIDV4
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UUID/UUIDV1/UUIDV4
- en: 'A `UUIDV1`/`UUIDV4` data types work in conjunction with the `UUID` attribute
    type. We can declare a model that has a default `UUIDV4` value as its **primary
    key** (**PK**) like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`UUIDV1`/`UUIDV4` 数据类型与 `UUID` 属性类型协同工作。我们可以声明一个具有默认 `UUIDV4` 值作为其 **主键**（**PK**）的模型，如下所示：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: VIRTUAL
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟
- en: The `VIRTUAL` attribute type is a special type that will hydrate the data within
    Sequelize but will not populate the data into the database. The `VIRTUAL` field
    could be used for organizing code, validations, and extending Sequelize to any
    protocol or framework that requires nested typing (for example, GraphQL, **Protocol
    Buffers** (**Protobuf**), and so on), which is covered in [*Chapter 9*](B17841_09.xhtml#_idTextAnchor177),
    *Using and Creating Adapters*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`VIRTUAL`属性类型是一种特殊类型，它将在Sequelize中填充数据，但不会将数据填充到数据库中。`VIRTUAL`字段可用于组织代码、验证以及扩展Sequelize到任何需要嵌套类型（例如，GraphQL、**Protocol
    Buffers**（**Protobuf**）等）的协议或框架，这将在[*第9章*](B17841_09.xhtml#_idTextAnchor177)，*使用和创建适配器*中介绍。'
- en: 'We can define a `VIRTUAL` attribute like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义一个`VIRTUAL`属性：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For retrieving `VIRTUAL` attributes, we would need to define a data type as
    a parameter for the `DataTypes.VIRTUAL` invocation. If we want to pass through
    other attributes within our `VIRTUAL` attribute, we would define a list as the
    second parameter. An example is shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检索`VIRTUAL`属性，我们需要为`DataTypes.VIRTUAL`调用定义一个数据类型作为参数。如果我们想在我们的`VIRTUAL`属性中传递其他属性，我们将定义一个列表作为第二个参数。以下是一个示例：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ENUM
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENUM
- en: 'Sequelize has a `DataTypes.ENUM` attribute type for enumerated columns. At
    the moment, only Postgres has this feature enabled. A solution for other database
    engines would be to define a custom validation rule for your model that performs
    some sort of inclusion operator. Custom validations for our models will be discussed
    in the next chapter. There are three different ways of defining enumerated attributes,
    as illustrated here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize有一个`DataTypes.ENUM`属性类型用于枚举列。目前，只有Postgres启用了此功能。对于其他数据库引擎的解决方案是定义一个自定义验证规则，该规则执行某种包含操作符。下一章将讨论我们模型的自定义验证。定义枚举属性有三种不同的方式，如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ARRAY
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARRAY
- en: '`ARRAY` attribute types are supported for Postgres only at the moment. This
    type requires a parameter of an applicable data type. You can see an example here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有Postgres支持`ARRAY`属性类型。此类型需要一个适用数据类型的参数。您可以在以下示例中查看：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: GEOMETRY
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GEOMETRY
- en: 'Sequelize can handle geometric data for MariaDB, MySQL, and Postgres (as long
    as the PostGIS extension is enabled). The **GeoJSON** specification ([https://tools.ietf.org/html/rfc7946](https://tools.ietf.org/html/rfc7946))
    can be useful for querying geometric data for an airline business. For example,
    we can mark the coordinates of an airport and the current location of an airplane
    to determine the estimated time of arrival without manually memorizing the Haversine
    algorithm (a formula to determine the distance between two points on a sphere).
    Reference examples can be found in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize可以处理MariaDB、MySQL和Postgres的几何数据（只要启用了PostGIS扩展）。**GeoJSON**规范([https://tools.ietf.org/html/rfc7946](https://tools.ietf.org/html/rfc7946))对于查询航空业务中的几何数据可能很有用。例如，我们可以标记机场的坐标和飞机的当前位置，以确定预计到达时间，而无需手动记住Haversine算法（一个确定球面上两点之间距离的公式）。以下代码片段中可以找到参考示例：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, we first define our model with two attributes (`point`
    and `polygon`) with the respective geometry data types (for a complete list, you
    may reference the **Request for Comments** (**RFC**) manual previously mentioned).
    Then, we create our geometric objects with a set of defined values (a point will
    accept two coordinates, and a polygon can accept N coordinates). The last line
    will create an entry with the defined values for the corresponding attribute.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先使用两个属性（`point`和`polygon`）及其相应的几何数据类型（对于完整列表，您可以参考之前提到的**请求评论**（**RFC**）手册）定义我们的模型。然后，我们使用一组定义的值创建我们的几何对象（一个点将接受两个坐标，一个多边形可以接受N个坐标）。最后一行将为相应的属性创建一个具有定义值的条目。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'GeoJSON is handled differently depending on whether we are using the Postgres
    or MariaDB/MySQL dialect. The Postgres dialect will call the `ST_GeomFromGeoJSON`
    function for interpretation of GeoJSON, and MariaDB/MySQL will use the `GeomFromText`
    function. The following reference goes into detail on spatial columns with MySQL:
    [https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml](https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON的处理方式取决于我们是否使用Postgres或MariaDB/MySQL方言。Postgres方言将调用`ST_GeomFromGeoJSON`函数来解释GeoJSON，而MariaDB/MySQL将使用`GeomFromText`函数。以下参考详细介绍了MySQL中的空间列：[https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml](https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml)。
- en: GEOGRAPHY
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GEOGRAPHY
- en: For MariaDB/MySQL, the `GEOGRAPHY` attribute type will work the same as the
    `GEOMETRY` type, but for Postgres, Sequelize will utilize PostGIS’ geography data
    type. The `GEOGRAPHY` attribute type follows the same GeoJSON syntax as the `GEOMETRY`
    type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MariaDB/MySQL，`GEOGRAPHY`属性类型将像`GEOMETRY`类型一样工作，但对于Postgres，Sequelize将使用PostGIS的地形数据类型。`GEOGRAPHY`属性类型遵循与`GEOMETRY`类型相同的GeoJSON语法。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are looking for a complete set of utility functions and querying complex
    relationships between several coordinates, then the `GEOMETRY` type is recommended
    over the `GEOGRAPHY` type. If you need to use geodetic measurements instead of
    Cartesian measurements, or if you have simpler relationships over large areas,
    then the `GEOGRAPHY` type would be more applicable to you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一组完整的实用函数，并查询多个坐标之间的复杂关系，那么建议使用`GEOMETRY`类型而不是`GEOGRAPHY`类型。如果你需要使用大地测量而不是笛卡尔测量，或者如果你在大面积上具有更简单的关系，那么`GEOGRAPHY`类型将更适合你。
- en: CIDR/INET/MACADDR
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIDR/INET/MACADDR
- en: 'These three attribute types are for Postgres only. All of these types perform
    some type of internal validation respective to the type. These types do not have
    an input parameter. The following are brief explanations, with references, for
    each of these data types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种属性类型仅适用于Postgres。这些类型各自执行一些内部验证。这些类型没有输入参数。以下是对这些数据类型的简要说明，并附有参考：
- en: '`CIDR`—This stands for **Classless Inter-Domain Routing** and is used for allocating
    **Internet Protocol** (**IP**) addresses and route tables ([https://datatracker.ietf.org/doc/html/rfc4632](https://datatracker.ietf.org/doc/html/rfc4632))'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CIDR`—这代表**无类别域间路由**，用于分配**互联网协议**（**IP**）地址和路由表 ([https://datatracker.ietf.org/doc/html/rfc4632](https://datatracker.ietf.org/doc/html/rfc4632))'
- en: '`INET`—Common ways of identifying over the net ([https://datatracker.ietf.org/doc/html/rfc6991](https://datatracker.ietf.org/doc/html/rfc6991))'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INET`—在网络上识别的常见方式 ([https://datatracker.ietf.org/doc/html/rfc6991](https://datatracker.ietf.org/doc/html/rfc6991))'
- en: '`MACADDR`—**Unique identifiers** (**UIDs**) for network interfaces ([https://www.rfc-editor.org/rfc/rfc7042.xhtml](https://www.rfc-editor.org/rfc/rfc7042.xhtml))'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACADDR`—网络接口的**唯一标识符**（**UIDs**）([https://www.rfc-editor.org/rfc/rfc7042.xhtml](https://www.rfc-editor.org/rfc/rfc7042.xhtml))'
- en: TSVECTOR
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TSVECTOR
- en: 'The `TSVECTOR` data type is used for searching through text columns with advanced
    operators available in Postgres’ `to_tsquery()` function. These operators include
    wildcard matching, negate matching, and Boolean search. This attribute type is
    for Postgres only and will only accept string variables for values. When querying
    a `TSVECTOR` attribute, Sequelize will not interpret the attribute type with its
    associated functions implicitly (for example, `to_tsvector`). Let’s suppose we
    have the following model definition:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSVECTOR`数据类型用于通过Postgres的`to_tsquery()`函数中可用的高级运算符搜索文本列。这些运算符包括通配符匹配、否定匹配和布尔搜索。此属性类型仅适用于Postgres，并且仅接受字符串变量作为值。在查询`TSVECTOR`属性时，Sequelize不会隐式解释与关联函数（例如，`to_tsvector`）相关的属性类型。假设我们有以下模型定义：'
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we want to query a value on the `col` field, like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要查询`col`字段上的值，如下所示：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The generated SQL would look similar to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SQL将类似于以下内容：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Sequelize will interpret this query with an equals operator for the `where`
    clause. In order to take advantage of the `TSVECTOR` column type, we would have
    to be explicit with our intentions, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize将使用等于运算符解释此查询的`where`子句。为了利用`TSVECTOR`列类型，我们必须明确我们的意图，如下所示：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will convert the `where` clause’s operator from equal to matching (`@@`).
    The `sequelize.fn` method allows you to explicitly invoke a function from your
    DBMS. The query generated by this procedure would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`where`子句的运算符从等于转换为匹配（`@@`）。`sequelize.fn`方法允许你显式调用你的DBMS中的函数。此过程生成的查询将如下所示：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After learning how to define our model and which data types are available to
    us in Sequelize, we can now begin migrating our definitions to an actual database.
    Sequelize offers a migration subcommand within its command-line tool, to make
    this easy for us.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何定义我们的模型以及Sequelize中可用的数据类型之后，我们现在可以将我们的定义迁移到实际的数据库中。Sequelize在其命令行工具中提供了一个迁移子命令，以便我们更容易地完成此操作。
- en: Migrating schematic changes and data from Sequelize to the database
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Sequelize中的图示更改和数据迁移到数据库
- en: We have defined our database’s schema with the generated files from the command-line
    tool, and we are now ready to migrate those definitions to our DBMS. Using Sequelize’s
    migrations can help teams of developers maintain the same schema structure across
    multiple machines. Migrations can provide a historical reference as to how your
    database has changed over time, which can also help us undo certain changes and
    revert our database’s schema to a specific time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用命令行工具生成的文件定义了我们的数据库模式，我们现在准备将这些定义迁移到我们的 DBMS。使用 Sequelize 的迁移可以帮助开发团队在多台机器上维护相同的模式结构。迁移可以提供历史参考，说明数据库是如何随时间变化的，这也可以帮助我们撤销某些更改，并将数据库的模式回滚到特定的时间。
- en: Migrating schematic changes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移电路图更改
- en: The Sequelize CLI provides a convenient way of propagating updates toward a
    database. All of our schematic changes will be located within the `migrations`
    directory, and all of our data seeds will be located within the `seeders` directory.
    This chapter will cover only the initialization of the database’s structure. In
    subsequent chapters, there will be examples of adding and removing columns (or
    indices) using the migration tool.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize CLI 提供了一种方便的方式来将更新传播到数据库。我们所有的电路图更改都将位于`migrations`目录中，我们所有的数据种子都将位于`seeders`目录中。本章将仅涵盖数据库结构的初始化。在随后的章节中，将有使用迁移工具添加和删除列（或索引）的示例。
- en: 'In the *Defining models for a database* section, we used the Sequelize CLI
    to generate our models, which should have created several files in the `migrations`
    directory. Each file is prefixed with a timestamp, a `create`), and the model’s
    name. An example for one of the files (`20210914153156-create-airplane.js`) would
    look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定义数据库模型*部分，我们使用了 Sequelize CLI 来生成我们的模型，这应该在`migrations`目录中创建了几个文件。每个文件都以时间戳、一个`create`和模型的名称为前缀。其中一个文件（例如`20210914153156-create-airplane.js`）的示例如下：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sequelize will use the scope of the `up(…)` method when we invoke the `migrations`
    subcommand. The `down(…)` method is reserved for when we decide to undo, or revert,
    a migration. The **query interface** is a database-agnostic adapter that executes
    generic SQL commands that are available to all supported database engines. We
    will go into detail about the query interface in a later chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`migrations`子命令时，Sequelize 将使用`up(…)`方法的范围。`down(…)`方法保留用于当我们决定撤销或回滚迁移时。**查询接口**是一个数据库无关的适配器，它执行所有支持数据库引擎都可用的一般
    SQL 命令。我们将在后面的章节中详细介绍查询接口。
- en: 'You may have noticed that Sequelize has added several columns to our model’s
    definition. With the default settings, Sequelize will generate three additional
    columns, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 Sequelize 已经在我们的模型定义中添加了几个列。使用默认设置，Sequelize 将生成三个额外的列，如下所示：
- en: '`id`—A PK as an integer value with `autoIncrement` set to `true`. The `autoIncrement`
    flag will create a sequence value (some databases, such as MySQL, will call sequences
    *auto-increment* columns).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—一个设置为`autoIncrement`为`true`的整数 PK。`autoIncrement`标志将创建一个序列值（例如，MySQL 等数据库将序列称为*auto-increment*列）。'
- en: '`createdAt`—This field will generate a timestamp upon the row’s creation. Since
    this is a Sequelize-recognized column, the default value for this column does
    not require us to explicitly state `DataTypes.NOW` or any equivalent value. Sequelize
    will hydrate the row’s value automatically when using applicable methods such
    as `create()`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createdAt`—此字段将在行创建时生成一个时间戳。由于这是一个 Sequelize 识别的列，因此此列的默认值不需要我们明确声明`DataTypes.NOW`或任何等效值。当使用`create()`等适用方法时，Sequelize
    将自动填充行的值。'
- en: '`updatedAt`—Similar to the `createdAt` field, except this value will update
    automatically from Sequelize every time the row is updated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatedAt`—与`createdAt`字段类似，但此值将自动从 Sequelize 更新，每次行更新时都会更新。'
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can prevent Sequelize from creating these attributes automatically through
    configuration settings. These settings will be explained in detail later in this
    chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过配置设置来防止 Sequelize 自动创建这些属性。这些设置将在本章后面详细解释。
- en: 'In the root directory of our project, run the following command to initialize
    migrations:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的根目录中，运行以下命令以初始化迁移：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command will perform several more instructions than iterating through the
    `migrations` directory. Sequelize will first look for a table called `SequelizeMeta`
    that holds meta information on which files have already been processed through
    the `migrations` subcommand. After the table has been found or created, Sequelize
    will iterate through the `migrations` table in sequential order of the file’s
    name (timestamps are a convenient way of maintaining this order) and skip any
    files found within the `SequelizeMeta` table.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将执行比遍历 `migrations` 目录更多的指令。Sequelize 首先会寻找一个名为 `SequelizeMeta` 的表，该表包含通过
    `migrations` 子命令已处理的文件的相关元信息。找到或创建该表后，Sequelize 将按文件名的顺序遍历 `migrations` 表（时间戳是保持这种顺序的便捷方式），并跳过
    `SequelizeMeta` 表中找到的任何文件。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `sequelize-cli` `db:migrate` and `db:seed` commands will use the `NODE_ENV`
    environmental variable to determine where to migrate/initialize data to. As an
    alternative, you can state which database to connect to with the `--url` option,
    like so: `sequelize db:migrate --url ''mysql://user:password@host.com/database''`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequelize-cli` 的 `db:migrate` 和 `db:seed` 命令将使用 `NODE_ENV` 环境变量来确定迁移/初始化数据的位置。作为替代，你可以使用
    `--url` 选项指定要连接到的数据库，如下所示：`sequelize db:migrate --url ''mysql://user:password@host.com/database''`。'
- en: 'If we made a mistake on a model’s definition, after migration, we always have
    the option to revert our changes, like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在模型定义上犯了错误，迁移后，我们始终可以选择撤销更改，如下所示：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will revert the last migration performed by Sequelize. If we want to undo
    all of our changes, there is another subcommand, shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将撤销 Sequelize 执行的最后一个迁移。如果我们想撤销所有更改，还有一个子命令，如下所示：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we want to revert all of our migrations up until a certain point (this is
    why prefixing your filenames with a timestamp is important for congruity), we
    can run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想撤销所有迁移直到某个点（这就是为什么在文件名前加时间戳很重要），我们可以运行以下命令：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After the migration is completed, we should run the following commands:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移完成后，我们应该运行以下命令：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The tables shown in the following screenshot should be displayed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图应显示以下表：
- en: '![Figure 2.2 – Display of the project’s tables ](img/Figure_2.2_B17841.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 显示项目表](img/Figure_2.2_B17841.jpg)'
- en: Figure 2.2 – Display of the project’s tables
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 显示项目表
- en: Initializing seed data
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化种子数据
- en: 'Now that we have our schema in place, we can start populating our database
    with actual data by generating seeder files within the `seeders` directory. Seed
    data is conventionally used for initial configuration data, static information,
    and so on. Good thing too—our business partner just notified us that they have
    purchased five airplanes to help get us started. We can create seed data for these
    airplanes, like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了模式，我们可以通过在 `seeders` 目录内生成种子文件来开始用实际数据填充我们的数据库。种子数据传统上用于初始配置数据、静态信息等。好事成双——我们的商业伙伴刚刚通知我们，他们购买了五架飞机以帮助我们开始。我们可以为这些飞机创建种子数据，如下所示：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will generate a file in our project’s `seeders` directory that contains
    the bare minimum for migrating seed data into the database. Similar to our migration
    files, there are only two methods exposed to the CLI: `up(…)` and `down(…)`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的项目 `seeders` 目录中生成一个文件，该文件包含将种子数据迁移到数据库所需的最基本信息。类似于我们的迁移文件，CLI 只公开了两种方法：`up(…)`
    和 `down(…)`。
- en: 'We will replace the file’s contents with the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下代码替换文件内容：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike Sequelize’s `create()` function, the query interface’s `bulkInsert()`
    method will not hydrate the `createdAt` or `updatedAt` columns automatically.
    If you omit these columns from the seed file, the database will return an error
    since the columns do not have a default value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Sequelize 的 `create()` 函数不同，查询接口的 `bulkInsert()` 方法不会自动填充 `createdAt` 或 `updatedAt`
    列。如果你从种子文件中省略这些列，数据库将返回错误，因为这些列没有默认值。
- en: 'Now, we can process our seed data via the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下命令处理我们的种子数据：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can confirm the changes by entering the following SQL command into our database:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在数据库中输入以下 SQL 命令来确认更改：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We then get the following results:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后得到以下结果：
- en: '![Figure 2.3 – Querying a list of airplanes ](img/Figure_2.3_B17841.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 查询飞机列表](img/Figure_2.3_B17841.jpg)'
- en: Figure 2.3 – Querying a list of airplanes
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 查询飞机列表
- en: 'Reverting seed data is similar to the `migrations` subcommand, as we can see
    here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚种子数据与 `migrations` 子命令类似，如下所示：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Sequelize uses another project internally for migrations called Umzug. A full
    reference, and more examples on how to tune your migration cycle, can be found
    at the project’s GitHub repository: [https://github.com/sequelize/umzug](https://github.com/sequelize/umzug).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 在内部使用另一个名为 Umzug 的项目进行迁移。完整的参考和更多关于如何调整迁移周期的示例可以在项目的 GitHub 仓库中找到：[https://github.com/sequelize/umzug](https://github.com/sequelize/umzug)。
- en: Once we are done inserting seed data into a database, we can now query or manipulate
    that data using Sequelize. The following section will provide a very brief introduction
    for incorporating Sequelize for an Express application following more of a reference
    style for Sequelize. This will help give you an idea of how we will apply Sequelize
    in subsequent chapters for our airline project, and enough technical knowledge
    to help you become comfortable with making your own adjustments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在将种子数据插入数据库后，我们现在可以使用 Sequelize 查询或操作这些数据。以下部分将提供一个关于如何将 Sequelize 集成到 Express
    应用程序的简要介绍，并遵循 Sequelize 的参考风格。这将帮助您了解我们将在后续章节中如何应用 Sequelize 到我们的航空公司项目中，并为您提供足够的知识，以便您能够舒适地调整自己的设置。
- en: Manipulating and querying data using Sequelize
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sequelize 操作和查询数据
- en: After initializing our database’s structure and data, we should be able to view,
    modify, and remove the airplanes from our dashboard. For now, we will create very
    naive and simple implementations for our administrative tasks, but since we are
    the only technical employee at *Avalon Airlines*, this will not be a problem.
    As we continue creating the project, we will modify our application to become
    more robust and function with safety measures in mind.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化我们的数据库结构和数据后，我们应该能够从我们的仪表板中查看、修改和删除飞机。目前，我们将为我们的管理任务创建非常简单和基础的实现，但由于我们是
    *Avalon Airlines* 唯一的技术员工，这不会成为问题。随着我们继续创建项目，我们将修改我们的应用程序，使其更加健壮，并考虑安全措施。
- en: Reading data
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取数据
- en: 'Replace the `app.get(''/'', …)` block with the following code (in `index.js`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `app.get('/', …)` 块替换为以下代码（在 `index.js` 中）：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, save the file and run our application with the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，保存文件，并使用以下命令运行我们的应用程序：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can visit our website at `http://localhost:3000` and should see results
    similar to those shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问我们的网站 `http://localhost:3000`，应该会看到与这里显示的类似的结果：
- en: '![Figure 2.4 – Listing our airplanes  ](img/Figure_2.4_B17841.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 列出我们的飞机](img/Figure_2.4_B17841.jpg)'
- en: Figure 2.4 – Listing our airplanes
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 列出我们的飞机
- en: 'Now, we will create another route that will return the results to us for a
    specific airplane. If the airplane cannot be found, then we should send a *Not
    Found* `404`). Add the following route below the root `app.get(''/'', …)` block):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个路由，该路由将返回特定飞机的结果。如果找不到飞机，则应发送 *未找到* `404`）。在根 `app.get('/', …)` 块下方添加以下路由）：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `findByPk` method will try to find a record from the model’s PK attribute
    (by default, this will be Sequelize’s generated `id` column). When a record is
    found (for example, [http://localhost:3000/airplanes/1](http://localhost:3000/airplanes/1)),
    the application will return the record to us, but if we changed the `id` parameter
    from `1` to `10` (`http://localhost:3000/airplanes/10`), we should receive a *Not
    Found* response.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`findByPk` 方法将尝试从模型的 PK 属性（默认情况下，这将是由 Sequelize 生成的 `id` 列）中查找记录。当找到记录时（例如，[http://localhost:3000/airplanes/1](http://localhost:3000/airplanes/1)），应用程序将返回记录给我们，但如果我们将
    `id` 参数从 `1` 更改为 `10` (`http://localhost:3000/airplanes/10`)，我们应该收到一个 *未找到* 的响应。'
- en: 'Here is a list with a brief explanation of Sequelize functions relating to
    retrieving data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含 Sequelize 数据检索相关函数简要说明的列表：
- en: '`findAll`—Use this when you want to use the `where` clause in your query and
    retrieve more than one row.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAll`—当您想在查询中使用 `where` 子句并检索多行时使用此函数。'
- en: '`findOne`—Similar to the `findAll` function, except that this function will
    return a single row.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findOne`—与 `findAll` 函数类似，但此函数将返回单行记录。'
- en: '`findByPk`—A function that returns a single row using the model’s defined PK.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findByPk`—一个返回使用模型定义的 PK 的单行记录的函数。'
- en: '`findOrCreate`—This function will return a single instance of the row that
    was either found or instantiated from the database. Sequelize will compose the
    attributes defined within the `where` and `defaults` key.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findOrCreate`—此函数将返回数据库中找到或实例化的单个行实例。Sequelize 将组合 `where` 和 `defaults` 键中定义的属性。'
- en: Complex querying
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂查询
- en: 'Sometimes, you will need more than just a simple `where` clause with an `AND`
    operator. Sequelize has several operators built in to help write queries with
    a more complex `where` clause. A full list of these operators is shown here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要比简单的 `where` 子句和 `AND` 运算符更多的东西。Sequelize内置了几个运算符来帮助编写具有更复杂 `where`
    子句的查询。这些运算符的完整列表如下所示：
- en: '`and`/`or`—Logical `AND` and logical `OR`. These values contain an array of
    `where` clause objects.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`/`or`—逻辑 `AND` 和逻辑 `OR`。这些值包含一个 `where` 子句对象的数组。'
- en: '`eq`/`ne`—Equal (`=`) or Not Equal (`!=`).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq`/`ne`—等于 (`=`) 或不等于 (`!=`)。'
- en: '`gte`/`gt`—Greater-Than-or-Equal (`>=`) and Greater-Than (`>`).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gte`/`gt`—大于等于 (`>=`) 和大于 (`>`)。'
- en: '`lte`/`lt`—Lesser-Than-or-Equal (`<=`) and Lesser-Than (`<`).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lte`/`lt`—小于等于 (`<=`) 和小于 (`<`)。'
- en: '`is`/`not`—`IS NULL` and `IS NOT TRUE`, respectively.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`/`not`—`IS NULL` 和 `IS NOT TRUE`，分别。'
- en: '`in`/`notIn`—`IN` and `NOT IN` operators of any array with values.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`/`notIn`—任何具有值的数组的 `IN` 和 `NOT IN` 运算符。'
- en: '`any`/`all`/`values`—`ANY` (Postgres only), `ALL`, and `VALUES` operators respectively.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`/`all`/`values`—`ANY`（仅适用于Postgres）、`ALL` 和 `VALUES` 运算符，分别。'
- en: '`col`—Converts column string values into **identifiers** (**IDs**) specified
    by the database/dialect.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col`—将列字符串值转换为数据库/方言指定的 **标识符**（**IDs**）。'
- en: '`placeholder`—Internal operator used by Sequelize.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeholder`—Sequelize使用的内部运算符。'
- en: '`join`—Used internally by Sequelize.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join`—由Sequelize内部使用。'
- en: '`match`—Match operator used for text searching (Postgres only).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`—用于文本搜索的匹配运算符（仅适用于Postgres）。'
- en: '`like`/`notLike`—`LIKE` and `NOT LIKE`, respectively.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`like`/`notLike`—`LIKE` 和 `NOT LIKE`，分别。'
- en: '`iLike`/`notILike`—Case-insensitive version of `LIKE` and `NOT LIKE` (Postgres
    only).'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iLike`/`notILike`—`LIKE` 和 `NOT LIKE` 的不区分大小写的版本（仅适用于Postgres）。'
- en: '`startsWith`/`endsWith`—Shorthand for the `LIKE ''%...''` and `LIKE ''...%''`
    expressions.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startsWith`/`endsWith`—`LIKE ''%...''` 和 `LIKE ''...%''` 表达式的简写。'
- en: '`substring`—Shorthand expression for `LIKE ''%...%''`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substring`—`LIKE ''%...%''` 的简写表达式。'
- en: '`regexp`/`notRegexp`—`REGEXP` and `NOT REGEXP` for MySQL and Postgres only.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`/`notRegexp`—仅适用于MySQL和Postgres的 `REGEXP` 和 `NOT REGEXP`。'
- en: '`between`/`notBetween`—`BETWEEN x AND y` and `NOT BETWEEN x AND y`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`between`/`notBetween`—`BETWEEN x AND y` 和 `NOT BETWEEN x AND y`。'
- en: '`overlap`—Postgres-only range operator for overlap (`&&`).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overlap`—仅适用于Postgres的范围重叠运算符 (`&&`)。'
- en: '`contains`/`contained`—Postgres-only range operator for `@>` and `<@`, respectively.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`/`contained`—分别对应 `@>` 和 `<@` 的Postgres专用范围运算符。'
- en: '`Adjacent`—Postgres-only range operator for adjacent querying (`-|-`).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Adjacent`—仅适用于Postgres的相邻查询范围运算符 (`-|-`)。'
- en: '`strictLeft`/`strictRight`—Strict operators for Postgres ranges (`<<` and `>>`).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictLeft`/`strictRight`—Postgres范围（`<<` 和 `>>`）的严格运算符。'
- en: '`noExtendRight`/`noExtendLeft`—No extension range operators for Postgres (`&<`
    and `&>`).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noExtendRight`/`noExtendLeft`—Postgres的无扩展范围运算符 (`&<` 和 `&>`)。'
- en: 'Querying a complex `where` clause may look something like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 查询复杂的 `where` 子句可能看起来像这样：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will then produce the following query:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下查询：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Deleting data
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'For deleting an instance (a single record), we can call a `destroy()` function,
    like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除一个实例（单个记录），我们可以调用一个 `destroy()` 函数，如下所示：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If there is no attribute marked as a PK within your model’s definition, then
    Sequelize may not delete the correct record. The instance’s `destroy()` method
    would be called with a `where` clause that tried to match all of the instance’s
    attributes. This could lead to unintentional deletions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的模型定义中没有标记为PK的属性，那么Sequelize可能无法删除正确的记录。实例的 `destroy()` 方法会使用一个尝试匹配实例所有属性的
    `where` 子句被调用。这可能导致意外的删除。
- en: 'To delete multiple rows at once, execute the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性删除多行，执行以下代码：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can remove all of a table’s data by passing a configuration option to the
    `destroy()` method, like so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递配置选项到 `destroy()` 方法来删除表中所有数据，如下所示：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Updating and saving data
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和保存数据
- en: 'Sequelize offers a few ways of updating attributes/data, depending on where
    you are updating from. If you wish to update multiple rows, we could use the model’s
    `update()` function, like so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize提供了几种更新属性/数据的方法，具体取决于你从哪里更新。如果你希望更新多行，我们可以使用模型的 `update()` 函数，如下所示：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This query will update all of the records’ names to `John`, where the current
    value is `NULL`. For updating a specific instance, we would change the attribute’s
    value and then call the `save()` function, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将更新所有记录的名称为 `John`，其中当前值为 `NULL`。对于更新特定实例，我们会更改属性值，然后调用 `save()` 函数，如下所示：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you are in the middle of changing a record’s attributes and your workflow
    requires you to reset the record’s data back to the original values (without touching
    the database), you may do so with the `reload()` method, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在更改记录的属性，并且你的工作流程需要你将记录的数据重置回原始值（而不接触数据库），你可以使用`reload()`方法，如下所示：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating data
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据
- en: 'To create a single row, the code for Sequelize would look similar to this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建单行，Sequelize的代码将类似于以下内容：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second parameter accepts the following options for `create()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()`的第二个参数接受以下选项：'
- en: '`raw`—If this Boolean value is set to `true`, then Sequelize will ignore the
    **virtual setter attributes** within the model’s definition. This is useful when
    you want to skip transforming the data through setter functions and wish to use
    the raw values that are provided from the query directly instead.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw`—如果此布尔值设置为`true`，则Sequelize将忽略模型定义中的**虚拟设置器属性**。当你想跳过通过设置器函数转换数据并直接使用查询提供的原始值时，这很有用。'
- en: '`isNewRecord`—A Boolean value that can enable (if set to `true`) Sequelize’s
    behavior for applying default values, updating a timestamp column, and so on.
    The default value for this method is `true`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNewRecord`—一个布尔值，可以启用（如果设置为`true`）Sequelize应用默认值、更新时间戳列等行为。此方法的默认值为`true`。'
- en: '`include`—An array containing include options for Sequelize. This book will
    provide examples and further details in a later chapter.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`—包含Sequelize的包含选项的数组。本书将在后面的章节中提供示例和更多细节。'
- en: '`fields`—An array of strings containing column names that will filter which
    attributes will be updated, validated, and saved.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`—包含将过滤要更新、验证和保存的属性名称的字符串数组。'
- en: '`silent`—If this value is set to `true`, then Sequelize will not update the
    `updatedAt` timestamp column.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`silent`—如果此值设置为`true`，则Sequelize不会更新`updatedAt`时间戳列。'
- en: '`validate`—A Boolean value to toggle whether or not to execute validations.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate`—一个布尔值，用于切换是否执行验证。'
- en: '`hooks`—A Boolean value that enables/disables running before/after `create`,
    `update`, and `validate` life cycle events.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hooks`—一个布尔值，用于启用/禁用`create`、`update`和`validate`生命周期事件之前/之后运行。'
- en: '`logging`—A function that will pass down the query’s statement.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging`—一个函数，将传递查询的语句。'
- en: '`benchmark`—Logs execution query time (in milliseconds) and will be passed
    as the second parameter for the `logging` function.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`benchmark`—记录执行查询时间（以毫秒为单位），并将作为`logging`函数的第二个参数传递。'
- en: '`transaction`—You may pass a transaction Sequelize instance for this option.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction`—你可以传递一个事务Sequelize实例作为此选项。'
- en: '`searchPath`—Postgres-only option for defining which `search_path` to use when
    querying.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchPath`—仅Postgres选项，用于定义查询时使用哪个`search_path`。'
- en: '`returning`—Postgres-only option for selecting which fields to return when
    creating a new record. A Boolean `true` value will return all of the fields, but
    an array of strings will filter which columns to return.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returning`—仅Postgres选项，用于创建新记录时选择返回哪些字段。布尔值`true`将返回所有字段，但字符串数组将过滤要返回的列。'
- en: 'Bulk-inserting data is very similar to creating a single row with Sequelize.
    The following code snippet illustrates an example of this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 批量插入数据与使用Sequelize创建单行非常相似。以下代码片段展示了这一示例：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first parameter is an array of values, and the second parameter is for
    configuration options. These options are identical to the `create()` method: `fields`,
    `validate`, `hooks`, `transaction`, `logging`, `benchmark`, `returning`, and `searchPath`.
    In addition, the `bulkCreate()` method also offers us the following options:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是值数组，第二个参数是配置选项。这些选项与`create()`方法相同：`fields`、`validate`、`hooks`、`transaction`、`logging`、`benchmark`、`returning`和`searchPath`。此外，`bulkCreate()`方法还提供了以下选项：
- en: '`individualHooks`—Executed before/after create life cycle events for each record
    individually. This does not affect bulk before/after life cycle events.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`individualHooks`—在为每个记录执行创建生命周期事件之前/之后运行。这不会影响批量之前/之后生命周期事件。'
- en: '`ignoreDuplicates`—Ignores duplicated rows by any constrained key defined on
    the table. This feature is not supported on MSSQL or Postgres versions below 9.5.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreDuplicates`—通过在表上定义的任何约束键忽略重复的行。此功能不支持MSSQL或低于9.5版本的Postgres。'
- en: '`k`—An array of fields to update if there is a duplicated key entry (for MySQL/MariaDB,
    SQLite 3.24.0+, and Postgres 9.5+ only).'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k`—如果存在重复键条目，则更新字段的数组（仅适用于MySQL/MariaDB、SQLite 3.24.0+和Postgres 9.5+）。'
- en: Ordering and grouping
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和分组
- en: 'When sifting through your data, you can order (or group) your columns like
    so:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当筛选你的数据时，你可以按如下方式对列进行排序（或分组）：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For grouping, depending on which database you are using, you may have different
    results from other database engines (such as requiring you to select only aggregated
    functions and grouped columns). Consult your database’s documentation for the
    specific nuances and rules that are required for grouping. Here is an example
    of a simple `GROUP BY` statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分组，根据你使用的数据库，你可能与其他数据库引擎（例如，要求你只选择聚合函数和分组列）得到不同的结果。请咨询你数据库的文档，以了解分组所需的特定细微差别和规则。以下是一个简单的
    `GROUP BY` 语句示例：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Caution
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Sequelize will treat the group’s input as a literal value. If you are grouping
    by user-generated content, it is highly recommended to escape your value to avoid
    SQL injections ([https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)).
    You may escape values using the `sequelize.escape('...');` method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将将组的输入视为字面值。如果你是按用户生成的内容分组，强烈建议你转义你的值以避免 SQL 注入（[https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)）。你可以使用
    `sequelize.escape('...');` 方法来转义值。
- en: Limits and pagination
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制和分页
- en: 'We can simply use the `offset` and `limit` key values for our finder methods,
    like so:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用 `offset` 和 `limit` 键值来为我们的查找方法，如下所示：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will select from the `MyModel` table with a limit of 10 and an offset of
    5.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择 `MyModel` 表，限制为 10 行，偏移量为 5。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `limit` property will tell the database to only retrieve that number of
    rows (in MSSQL, this would be `SELECT TOP N` or `FETCH NEXT N ROWS`). The `offset`
    property will skip N rows before retrieving the results. For MSSQL 2008 (and earlier)
    users, Sequelize will offer offset support by nesting queries to simulate offset
    behavior for compatibility and completeness.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 属性会告诉数据库只检索指定数量的行（在 MSSQL 中，这将是 `SELECT TOP N` 或 `FETCH NEXT N ROWS`）。`offset`
    属性会在检索结果之前跳过 N 行。对于 MSSQL 2008（及更早版本）的用户，Sequelize 将通过嵌套查询来模拟偏移行为，以实现兼容性和完整性。'
- en: Now that we have finished referencing Sequelize’s methodologies for querying
    and manipulating data, we can now go over the more advanced options when defining
    a model. These options can change the way Sequelize will transform data internally,
    filter queried data, and adjust naming conventions, allowing you to better adapt
    Sequelize’s behavior to your company/project’s requirements.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对 Sequelize 查询和操作数据方法的引用，我们现在可以讨论在定义模型时更高级的选项。这些选项可以改变 Sequelize 内部转换数据的方式，过滤查询数据，并调整命名约定，使你能够更好地适应
    Sequelize 的行为以满足你公司/项目的需求。
- en: Advanced Sequelize options for defining models
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型的高级 Sequelize 选项
- en: When defining a model, within Sequelize, the last input parameter for the `init()`
    and `define()` methods offers us a way to fine-tune our project’s requirements
    and Sequelize’s behavior. These parameter options are useful for situations such
    as when we need to construct Sequelize in a pre-existing environment that does
    not adhere to Sequelize’s naming conventions (for example, a column named `PersonIsMIA`
    as opposed to Sequelize’s `"PersonIsMia"` convention).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sequelize 中定义模型时，`init()` 和 `define()` 方法的最后一个输入参数为我们提供了一种微调项目需求和 Sequelize
    行为的方式。这些参数选项对于需要在我们不遵循 Sequelize 命名约定（例如，列名为 `PersonIsMIA` 而不是 Sequelize 的 `"PersonIsMia"`
    约定）的现有环境中构建 Sequelize 的情况非常有用。
- en: sequelize
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sequelize
- en: A copy (or new) instance of Sequelize to associate with the model. Sequelize
    will return an error if this field is not provided (except when using the `sequelize.define`
    method). Useful for querying across data centers or even databases.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一个（或新的）Sequelize 实例，用于与模型关联。如果未提供此字段，Sequelize 将返回错误（除了使用 `sequelize.define`
    方法时）。这对于跨数据中心或数据库查询非常有用。
- en: modelName
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: modelName
- en: Explicitly defines the model’s name with a string. This would be the first parameter
    in Sequelize’s `define()` method. If you are using ES6 class definitions, the
    default for this value would be the class name.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 明确使用字符串定义模型的名称。这将是 Sequelize 的 `define()` 方法的第一个参数。如果你正在使用 ES6 类定义，此值的默认值将是类名。
- en: defaultScope/scopes
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defaultScope/scopes
- en: An object for values that will set the model’s default scope and set applicable
    scopes for the model, respectively. Scopes can be useful for code organization
    or enforcing a basic access control list as a default behavior. We will go into
    detail about scoping in a later chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象，用于设置模型的默认作用域和为模型设置适用的作用域。作用域对于代码组织或强制执行基本访问控制列表作为默认行为非常有用。我们将在后面的章节中详细介绍作用域。
- en: omitNull
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: omitNull
- en: Setting this Boolean value to `true` will tell Sequelize to omit any columns
    that have a `null` value when saving a record.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将此布尔值设置为 `true` 将告诉 Sequelize 在保存记录时省略任何具有 `null` 值的列。
- en: timestamps
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: timestamps
- en: This option allows us to control Sequelize’s behavior for adding `createdAt`
    and `updatedAt` timestamp columns for the model. The default value for this setting
    is `true` (Sequelize will create timestamp columns).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许我们控制 Sequelize 为模型添加 `createdAt` 和 `updatedAt` 时间戳列的行为。此设置的默认值为 `true`（Sequelize
    将创建时间戳列）。
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can always override the default settings for the `createdAt` and `updatedAt`
    attributes by defining them explicitly within your model. Sequelize will know
    to use those attributes for timestamp-related columns.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在你的模型中显式定义它们来始终覆盖 `createdAt` 和 `updatedAt` 属性的默认设置。Sequelize 将知道使用这些属性来处理时间戳相关的列。
- en: paranoid
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: paranoid
- en: This Boolean option, when set to `true`, will prevent Sequelize from deleting
    the data (by default) and adds a `deletedAt` timestamp column. The `timestamps`
    option must be set to `true` in order to make `paranoid` applicable. The default
    value for `paranoid` is `false`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当此布尔选项设置为 `true` 时，将防止 Sequelize 删除数据（默认行为）并添加 `deletedAt` 时间戳列。为了使 `paranoid`
    选项生效，必须将 `timestamps` 选项设置为 `true`。`paranoid` 的默认值为 `false`。
- en: 'The following query will perform a “soft deletion”:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询将执行“软删除”：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This query will update the `Post` record of ID 1 and update the `deletedAt`
    column. If we wanted to remove the record from the database (instead of updating
    it), we would use the `force` parameter, as illustrated in the following code
    snippet:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将更新 ID 为 1 的 `Post` 记录并更新 `deletedAt` 列。如果我们想从数据库中删除记录（而不是更新它），我们将使用 `force`
    参数，如下面的代码片段所示：
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This would perform a `delete` query versus an `update` query on the database.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行数据库上的 `delete` 查询而不是 `update` 查询。
- en: createdAt/updatedAt/deletedAt
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createdAt/updatedAt/deletedAt
- en: This option will rename the `createdAt`, `updatedAt`, and `deletedAt` attributes,
    respectively. If you provide camel-cased values and the underscored option is
    set to `true`, Sequelize will automatically convert the column’s casing. Setting
    the value as `false` instead of a string will tell Sequelize to disable its default
    behavior for that respective column.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将分别重命名 `createdAt`、`updatedAt` 和 `deletedAt` 属性。如果你提供驼峰式命名的值，并且设置了下划线选项为
    `true`，Sequelize 将自动转换列的命名格式。将值设置为 `false` 而不是字符串将告诉 Sequelize 禁用该列的默认行为。
- en: underscored
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: underscored
- en: By default, Sequelize will create columns using camel case (for example, `updatedAt`,
    `firstName`, and so on). If you prefer underscores or snake case (for example,
    `updated_at`, `first_name`, and so on), then you would set this value to `true`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Sequelize 将使用驼峰式命名创建列（例如，`updatedAt`、`firstName` 等）。如果你更喜欢下划线或蛇形命名（例如，`updated_at`、`first_name`
    等），则应将此值设置为 `true`。
- en: freezeTableName
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: freezeTableName
- en: As previously mentioned, Sequelize will pluralize table names derived from the
    model’s name by default. Setting this value to `true` would prevent Sequelize
    from transforming the table’s name.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Sequelize 默认会将从模型名称派生的表名进行复数化。将此值设置为 `true` 将防止 Sequelize 转换表名。
- en: tableName
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tableName
- en: Explicitly defines the table name for Sequelize to use when creating SQL queries.
    A typical use case for this option is when you are integrating Sequelize into
    a pre-existing database/schema or when the pluralization is incorrectly set.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义 Sequelize 在创建 SQL 查询时使用的表名。此选项的典型用例是将 Sequelize 集成到现有的数据库/模式中，或者当复数设置不正确时。
- en: name
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: name
- en: 'An object with two available options to define singular and plural names to
    use when associating this model with others. A clearer explanation, and an example,
    will be provided when we go over model associations and relations in a later chapter,
    but you can see an overview of the two options here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象，包含两个可用的选项来定义在将此模型与其他模型关联时使用的单数和复数名称。在后面的章节中介绍模型关联和关系时，我们将提供更清晰的解释和示例，但你可以在此处查看这两个选项的概述：
- en: '`singular`—The name to use when referencing a single instance from a model
    (defaults to `Sequelize.Utils.singularize(modelName)`)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singular`—在引用模型的单个实例时使用的名称（默认为 `Sequelize.Utils.singularize(modelName)`）'
- en: '`pluralize`—The name to use when referencing multiple instances of a model
    (defaults to `Sequelize.Utils.pluralize(modelName)`)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pluralize`—在引用模型的多实例时使用的名称（默认为 `Sequelize.Utils.pluralize(modelName)`）'
- en: schema
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: schema
- en: Defines the model’s schema (this would be referenced as `search_path` in Postgres).
    Not all databases support schemas, and some will refer to schemas as databases
    entirely.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模型的模式（在 Postgres 中这将被称为 `search_path`）。并非所有数据库都支持模式，有些会将模式完全视为数据库。
- en: engine
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: engine
- en: Applicable to MySQL only, this is where you can define your table’s engine type
    (typically `InnoDB` or `MyISAM`). The default is `InnoDB`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于 MySQL，这是您定义表引擎类型的地方（通常是 `InnoDB` 或 `MyISAM`）。默认为 `InnoDB`。
- en: charset
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: charset
- en: Specifies the table’s charset. Useful for when your table’s contents can be
    deterministically defined to a set of characters that could help reduce database
    size (if you do not need universal encodings and only Latin characters, then you
    would use a Latin-derived charset).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 指定表的字符集。当您的表内容可以确定性地定义为一组字符，这有助于减少数据库大小时很有用（如果您不需要通用编码，并且只需要拉丁字符，则应使用拉丁派生的字符集）。
- en: collation
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: collation
- en: Specifies the table’s collation (sorting and ordering rules for the characters).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 指定表的校对（字符的排序和排序规则）。
- en: comment
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: comment
- en: Adds a comment to the table (if applicable to the DBMS).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为表添加注释（如果适用）。
- en: initialAutoIncrement
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: initialAutoIncrement
- en: Sets the initial `AUTO_INCREMENT` value for applicable dialects (MySQL and MariaDB).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为适用方言设置初始 `AUTO_INCREMENT` 值（MySQL 和 MariaDB）。
- en: hooks
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子
- en: An object with keys mapped to hooks (or life cycle events). The values may be
    a function or an array of functions. We will go into details about hooks in a
    later chapter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象，其键映射到钩子（或生命周期事件）。值可以是函数或函数数组。我们将在下一章详细介绍钩子。
- en: validate
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: validate
- en: An object to define model validations. We will go into detail about validations
    in the next chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象，用于定义模型验证。我们将在下一章详细介绍验证。
- en: indexes
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: indexes
- en: 'An array of objects that define table indices’ definitions. These indices are
    created when calling `sync()` or using the migration tool. Each object has the
    following options:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 定义表索引定义的对象数组。这些索引在调用 `sync()` 或使用迁移工具时创建。每个对象都有以下选项：
- en: '`name`—The name of the index (Sequelize will default to the model’s name and
    applicable fields joined by an underscore).'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—索引的名称（Sequelize 将默认使用模型的名称和通过下划线连接的相关字段）。'
- en: '`type`—A string value for defining the index’s type (only for MySQL/MariaDB).
    Typically, this is where you would define `FULLTEXT` or `SPATIAL` indices (`UNIQUE`
    as well, but there is a dialect-agnostic option for creating unique indices).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`—用于定义索引类型的字符串值（仅限 MySQL/MariaDB）。通常，您会在这里定义 `FULLTEXT` 或 `SPATIAL` 索引（`UNIQUE`
    也可以，但有一个与方言无关的选项用于创建唯一索引）。'
- en: '`unique`—Setting this value to true would create a unique index.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique`—将此值设置为 true 将创建一个唯一索引。'
- en: '`using`—The `USING` clause value for the index’s SQL statement. A few examples
    would be `BTREE` (typically, a DBMS will use this index type as the default),
    `HASH` (MySQL/MariaDB/Postgres only), and `GIST`/`GIN` (Postgres only).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using`—索引 SQL 语句的 `USING` 子句值。一些示例包括 `BTREE`（通常，数据库管理系统将使用此索引类型作为默认值），`HASH`（仅限
    MySQL/MariaDB/Postgres），以及 `GIST`/`GIN`（仅限 Postgres）。'
- en: '`operator`—Defines an operator to use for this index (primarily used for Postgres
    but can be used in other dialects).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator`—定义用于此索引的运算符（主要用于 Postgres，但也可以用于其他方言）。'
- en: '`concurrently`—Setting this to `true` offers a way of creating indices without
    writing locks (Postgres only).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrently`—将此设置为 `true` 提供了一种创建索引而不写入锁的方法（仅限 Postgres）。'
- en: '`fields`—An array of index fields to define for the model. Refer to the *Index
    fields* section, next.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`—为模型定义的索引字段数组。请参阅下一节的 *索引字段*。'
- en: Index fields
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引字段
- en: 'Each index definition’s fields value can be one of the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引定义的字段值可以是以下之一：
- en: A string indicating the name of the index
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示索引名称的字符串
- en: Sequelize literal object functions (for example, `sequelize.fn()`)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sequelize 文字对象函数（例如，`sequelize.fn()`）
- en: 'An object with the following keys:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有以下键的对象：
- en: '`attribute`—A string value for the column to index'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute`—用于索引的列的字符串值'
- en: '`length`—Defines the length for a prefix index (if applicable to your DBMS)'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`—定义前缀索引的长度（如果适用）'
- en: '`order`—Determines whether the sorting should be ascending or descending'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order`—确定排序是升序还是降序'
- en: '`collate`—Defines the collation for the column'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collate`—定义列的校对规则'
- en: 'A quick example is provided here to illustrate how to use some of these advanced
    options when defining a Sequelize model:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个快速示例，说明如何在定义Sequelize模型时使用一些这些高级选项：
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a detailed overview of the various parameters
    and configuration settings for defining models with Sequelize. We also learned
    how to use the Sequelize CLI to automatically generate models’ definition (and
    data) files and how to migrate those definitions to a database. This chapter has
    also covered the various attribute types provided by Sequelize, as well as the
    methodologies for querying or updating data from Sequelize to the database.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细概述了使用Sequelize定义模型的各种参数和配置设置。我们还学习了如何使用Sequelize CLI自动生成模型定义（和数据）文件，以及如何将这些定义迁移到数据库。本章还涵盖了Sequelize提供的各种属性类型，以及从Sequelize查询或更新数据到数据库的方法。
- en: In the next chapter, we will go over model validations, establishing foreign
    relationships, and how to constrain your data to meet your project’s requirements.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论模型验证、建立外键关系以及如何约束数据以满足项目需求。
- en: Part 2 – Validating, Customizing, and Associating Your Data
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 验证、自定义和关联您的数据
- en: In this part, you will take a deeper look into Sequelize’s model attributes
    and add validations, custom column types, and related associated models. You will
    explore hooks, JSON, and Blob types, along with transactions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，您将更深入地了解Sequelize的模型属性，并添加验证、自定义列类型和相关关联模型。您将探索钩子、JSON和Blob类型，以及事务。
- en: 'This part comprises the following chapters:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 3*](B17841_03.xhtml#_idTextAnchor098), *Validating Models*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B17841_03.xhtml#_idTextAnchor098), *验证模型*'
- en: '[*Chapter 4*](B17841_04.xhtml#_idTextAnchor111), *Associating Models*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B17841_04.xhtml#_idTextAnchor111), *关联模型*'
- en: '[*Chapter 5*](B17841_05.xhtml#_idTextAnchor134), *Adding Hooks and Lifecycle
    Events to Your Models*'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17841_05.xhtml#_idTextAnchor134), *将钩子和生命周期事件添加到您的模型中*'
- en: '[*Chapter 6*](B17841_06.xhtml#_idTextAnchor147), *Implementing Transactions
    with Sequelize*'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17841_06.xhtml#_idTextAnchor147), *使用Sequelize实现事务*'
- en: '[*Chapter 7*](B17841_07.xhtml#_idTextAnchor159), *Handling Customized, JSON,
    and Blob Data Types*'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17841_07.xhtml#_idTextAnchor159), *处理自定义、JSON和Blob数据类型*'
