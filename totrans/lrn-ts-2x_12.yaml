- en: Frontend Development with Angular and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to develop a frontend web application
    with Angular and TypeScript. Just like in the previous chapter, we are going to
    try to use the backend Node.js application that we previously implemented. The
    application that we are going to develop is a clone of the frontend application
    that we developed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The features and styling of the application will be identical. However, the
    implementation will present some significant differences because we are going
    to use Angular instead of React as our frontend application development framework.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go through the requirements of the application that we are
    going to implement in this chapter because we have covered them already in the
    preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a library that allows us to implement web user interfaces. In this
    chapter, we are going to create a small frontend application using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in the preceding chapter, the JavaScript environment in Node.js
    and a web browser are quite different. The browser environment doesn't support
    modules natively and loading time is one of the major factors that influence the
    performance of a frontend application, which explains the need for a module bundler
    like webpack when we are working on a frontend web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use Webpack just as we have been doing throughout
    this book. We are going to use the following Webpack configuration. It is almost
    identical to the configuration used in the preceding chapter, but we have introduced
    a few modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have introduced the `CommonChunkPlugin`. This plugin is used to identify
    pieces of code that repeat or that match a given rule. When a piece of code matches
    a condition, it is extracted from the main application bundle and is added to
    a second bundle named `vendor`. In this case, we are going to move all the pieces
    of code located under the `node_modules` folder to the vendor bundle, which means
    that we are going to end up with two bundles, one for the application and one
    for the third-party libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also introduced an additional application entry point. We import the
    `zone.js` module. This module is a polyfill for the Zones API, which is a mechanism
    for intercepting and keeping track of asynchronous work. Zones are defined as
    follows in the Zone.js documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Zone is a global object which is configured with rules about how to intercept
    and keep track of the asynchronous callbacks. Zone has these responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Intercept asynchronous task scheduling
  prefs: []
  type: TYPE_NORMAL
- en: Wrap callbacks for error-handling and zone tracking across async operations
  prefs: []
  type: TYPE_NORMAL
- en: Provide a way to attach data to zones
  prefs: []
  type: TYPE_NORMAL
- en: Provide a context-specific last frame error handling
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept blocking methods)
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, a Zone allows one to intercept the scheduling and calling
    of asynchronous operations, and execute additional code before as well as after
    the asynchronous task."
  prefs: []
  type: TYPE_NORMAL
- en: 'We need Zone.js because it is one of the dependencies of Angular. The rest
    of the Webpack configuration doesn''t present any other major differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about webpack.
  prefs: []
  type: TYPE_NORMAL
- en: About the sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement the same application that we implemented
    in the preceding chapter one more time. However, we will use Angular instead of
    React and MobX as our application development framework. We will try to implement
    a copy of the application as close as possible, to enable us to compare both frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The application is included in the companion source code and it is a very small
    web application that allows us to manage a database of movies and actors. We will
    not explain the features of the application in detail here because we already
    explained them in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about the application features
    and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the companion source code to have access to the entire source
    code of the application as well as its configuration, including things like the
    entire `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Serving an Angular application with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we did in the preceding chapter, we need to configure Node.js to server
    the files of our frontend web application. We use the Express static middleware
    to implement this feature just like we did in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about the Express static
    middleware. In particular, please refer to the *Serving React applications with
    Node.js* section.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entry point of the frontend application is in the `web/frontend/main.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use the `platformBrowserDynamic` module to bootstrap our application. We
    do this by invoking the `bootstrapModule` method and passing the main module in
    our application as an argument. We will learn more about modules in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to focus on the `platformBrowserDynamic` module.
    The `platform-browser-dynamic`Â module can be installed using `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use `platformBrowserDynamic` because we expect our application to be executed
    in a browser environment. An Angular application can also be executed in a server-side
    environment like Node.js, but it requires a slightly different bootstrapping configuration.
    Executing an Angular application in Node.js can be used to improve the initial
    loading time of the application. We will not cover this topic in this chapter
    because it is an advanced feature and the purpose of this chapter is just to introduce
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/universal](https://angular.io/guide/universal)
    if you wish to learn more about server-side rendering with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Working with NgModules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we used a module named `AppModule` to bootstrap our
    Angular application. The `AppModule` is in the `web/frontend/app.module.ts` file
    and its content looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppModule` is the entry point of our application, and it provides access
    to every other element in the application. The Angular documentation defines a
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An NgModule is a class marked by the @NgModule decorator. @NgModule takes
    a metadata object that describes how to compile a component''s template and how
    to create an injector at runtime. It identifies the module''s own components,
    directives, and pipes, making some of them public, through the exports property,
    so that external components can use them. @NgModule can also add service providers
    to the application dependency injectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules are a great way to organize an application and extend it with capabilities
    from external libraries. Angular libraries are NgModules, such as FormsModule,
    HttpClientModule, and RouterModule. Many third-party libraries are available as
    NgModules. NgModules consolidate components, directives, and pipes into cohesive
    blocks of functionality, each focused on a feature area, application business
    domain, workflow, or common collection of utilities."
  prefs: []
  type: TYPE_NORMAL
- en: A module allows us to group features; we can group all the elements (components,
    services, and so on) required for certain feature into a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@NgModule` decorator allows us to set up certain settings. The following
    list defines the purpose of some of the fields used by the application included
    in the companion source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `bootstrap` field is used to declare which component must be the root component
    during the bootstrapping process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `declarations` field is used to declare which components are going to be
    used within the Angular templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imports` field is used to make other components available within the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exports` field is used to make components available to other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `providers` field is used to configure the dependency injection bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to clarify that Angular's `@NgModule` imports/exports and ES6
    import/export modules are entirely different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/ngmodules](https://angular.io/guide/ngmodules)
    to learn more about modules.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to work with components. We are going
    to learn how to work to implement components and routing, as well as other concepts
    such as how to implement dependency injection in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Our first component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at our first Angular component. Earlier
    in this chapter, we learned how to bootstrap an Angular application, and we used
    the `AppModule`. Later, we learned that the `AppModule` uses the `AppComponent`
    as the root component of our application. We will now look at the `AppComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in Angular, a component is a class decorated with the `@Component`
    decorator. The `@Component` decorator takes some settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we use the `selector` setting to declare the name used to reference
    this component within a template. The `AppComponent` is the root component in
    our application; this means that it must be displayed as the root element in our
    `index.html` page. We can achieve this by adding a reference to the selector of
    our component in our `index.html` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the page loads it will display Loading... within the `<app-root>` DOM element
    at first. As soon as the vendor and main bundle files are loaded, the Angular
    application will be executed, and the `bootstrap` function will render the template
    of the `AppComponent` within the `<app-root>` DOM element, which will cause the
    `Loading...` label to disappear.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `template` setting to define the output that we wish to be generated
    when the component is rendered. In this case, the template is rendering another
    component that uses `app-layout` as its selector. We defined the template in-line,
    but it is also possible to define the template in a separate HTML file and reference
    it by using the `templateUrl` setting.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that we can only use a component in a template if both
    components have been configured correctly within an `NgModule`, as explained in
    the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the components will use additional settings; we will not explain all
    the available settings in this chapter because our goal is only to provide a basic
    introduction to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to mention that, in Angular, a component is always a
    class. In React, it was possible to implement a component as a function or as
    a class, but in Angular components are always classes, which means that there
    are no functional stateless components in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/architecture-components](https://angular.io/guide/architecture-components)
    to learn more about Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: Components and directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The existing Angular literature contains a lot of references to what are known
    as directives. Sometimes directives are mentioned as something that can be used
    together with components as if they were the same thing. The truth is that components
    are a kind of directive. The following has been extracted from the official Angular
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of directives in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Components-directives with a template.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Structural directives-change the DOM layout by adding and removing DOM elements.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attribute directives-change the appearance or behavior of an element, component,
    or another directive.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to learn how to create custom attribute directives in this
    chapter. However, is it important to understand that components are a kind of
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives)
    to learn more about directives.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Angular, we use data binding to coordinate the application''s state with
    the content rendered on screen. Angular supports three kinds of binding, distinguished
    by the direction of data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data direction** | **Syntax** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| One-way from data source'
  prefs: []
  type: TYPE_NORMAL
- en: to view target | `{{expression}} [target]="expression"` |
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| One-way from view target'
  prefs: []
  type: TYPE_NORMAL
- en: to data source | `(target)="statement"` | Event |
  prefs: []
  type: TYPE_NORMAL
- en: '| Two-way | `[(target)]="expression"` | Two-way |'
  prefs: []
  type: TYPE_TB
- en: Binding types other than interpolation have a target name to the left of the
    equals sign, surrounded by punctuation (`[]` and `()`).
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/template-syntax](https://angular.io/guide/template-syntax)
    to learn more about the data binding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Working with @Attribute and @Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we learned that the `AppComponent` renders the `AppLayout`
    component. In this section, we are going to look at the `AppLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Layout` component uses the `app-layout`Â selector and declares an inline
    template. The template uses two other components with the `app-header`Â and `router-outlet`Â selectors.
    We will ignore the component with theÂ `router-outlet`Â selectorÂ for now because
    we will learn more about it later, in the *Working with the Angular router* section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on the component with the selector `app-header`Â for now. As we can
    see in the preceding code snippet, some arguments are passed to the `HeaderComponent`.
    However, not all the arguments are passed in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some arguments passed as follows (one-way data binding from data source
    to view target):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are passing the string value primary as what is known as an
    attribute. We also have some arguments passed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are binding the value of the property `appRoutes` and passing
    it to the `AppHeader` component. This means that any changes to the `appRoutes`
    value will trigger the `AppHeader` component to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now look at the `AppHeader` component to see how attributes and inputs
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HeaderComponent` takes some attributes, which are defined with the `@Attribute`
    decorator. The `HeaderComponent` also takes one input, which is defined with the
    `@Input` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Input` decorator is used to pass values into the component or to pass
    data from one component to another (typically parent to child)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Attribute` directory is used to retrieve the constant value of an attribute
    available in the host element of the component, and it must be used with a parameter
    of a component's constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we looked at the `HeaderComponent`. However, we skipped
    some details about its template. The `HeaderComponent` uses what is known as a
    structural directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Structural directives are responsible for HTML layout. They shape or reshape
    the DOM's structure, typically by adding, removing, or manipulating elements.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the documentation at [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
    to learn more about structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: Using the <ng-content> directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `ng-content` directive to <indexentry content="Angular components:
    directive, using">render the child of a component. For example, the following
    component can be used to define a row in <indexentry content=" directive:using">the
    application''s layout. However, when we define the `RowComponent`, we don''t know
    which content will be placed into the row. We use the `ng-content` directive to
    refer the yet to be known child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RowComponent` can then be used within a template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Working with @Output and EventEmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Angular, we can handle user events using a property whose value is an event
    emitter. The property must be decorated with the `@Output` decorator as demonstrated
    by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our template, we have linked an event with one of the methods in the component
    as follows (one-way data binding from view target to data source):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `onEdit` method will receive an event object that allows access to the target
    (the DOM element that started the event). We can use the event target to access
    the attributes of the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we invoke the `emit` method of our output to pass some data to the
    parent component as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the parent component can set one of its methods as the event handler
    for the `onChange` output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the documentation at [https://angular.io/guide/component-interaction](https://angular.io/guide/component-interaction)
    to learn more about event handlers in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the component's host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to demonstrate how we can use the `host`Â setting
    in our components to control how the component host is rendered. When a component
    is rendered, Angular will always create a DOM element that matches the name of
    the component selector. This DOM element is known as the host. For example, take
    a look at the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be consumed by other components as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it will be rendered as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is an additional DOM node. Sometimes, having an additional
    node can lead to some layout issues and it would be much better if we could control
    how the host is rendered to achieve the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve this by using the `host` setting when we declare a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Working with the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we mentioned a component known as the `router-outlet`.
    The component was used by the `Layout` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this component was not defined by us because it is defined by the
    `@angular/router`Â npm module. In order to use the module, we must import it and
    declare a `NgModule` that exports `RouteModule`. We must also declare the configuration
    for the router. The configuration is a map or a dictionary that links a given
    path with a given component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When the browser URL matches one of the paths in the router configuration,
    the corresponding component is rendered into the `router-outlet` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can trigger a change in the URL using a `routerLink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have provided the path that we wish to navigate to and the CSS class to be
    used when the link is active. When we click on a router link, the browser URL
    will change, and the router will render the matching component under the `router-outlet`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Angular component life cycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular allows us to declare multiple component life cycle hooks. For example,
    in the companion source code, the `Movie` component extends the `OnInit` interface,
    which declares the `ngOnInit` method. The `ngOnInit` method is one of the available
    component life cycle hooks in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` of the component class is called before any other component
    life cycle hook. The constructor is the best place to inject dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ngOnInit` method is invoked immediately after the constructor and after
    the `ngOnChange` is triggered for the first time, which is the perfect time for
    initialization work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ngOnChanges` method is invoked first when the value of a bound property
    changes. It executes every time the value of an input property changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ngDestroy` method is invoked just before the instance of the component
    is finally destroyed. It is the perfect place to clean a componentâ (for example,
    canceling background tasks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more life cycle hooks available, but they are out of the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the Angular documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
    to learn more about all the available life cycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Working with services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular, it is a common practice toÂ use a service to interact with a REST
    API or with other resources, such as the localStorage API. The class below defines
    a service named `MovieService`, which can be used to send HTTP requests to the
    backend Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: A service is just a class, and it doesn't require any special decorators. However,
    the following code snippet uses the `@Injectable` decorator because it is going
    to be injected into the `MovieComponent`. We will learn more about dependency
    injection later, in the *Dependency injection in Angular* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods perform some HTTP requests to the server using the Fetch
    API. There is a method to fetch all movies from the movies REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a method to create a new movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a method to delete a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will learn how the movie service is consumed by
    the `Movie` component.
  prefs: []
  type: TYPE_NORMAL
- en: Smart components and dumb components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular components don't draw a clear separation between properties and
    states like React does, but we can still use the same mental model. A component
    renders some data. If the data is mutated by the component, we are talking about
    a smart component. If the component only reads the data, we are talking about
    a dumb component.
  prefs: []
  type: TYPE_NORMAL
- en: Just like we did in the React example, we have organized our project using multiple
    directories in a way that allows us to have very clear differentiation between
    smart and dumb components. The `components` directory contains only dumb components
    while the `pages` directory contains smart components.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, the dumb components, most of the time, don't require life cycle
    hooks, and they also don't require services. On the other hand, the smart components
    will most likely require some services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a smart component named `MoviePages`. In
    our Angular application, the pages are smart components and the components are
    simply dumb components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The component renders a list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also renders a modal window that allows us to create a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also renders a modal window that allows us to confirm that we
    wish to delete a movie from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MoviesPageComponent` is a smart component. As we can see in the following
    code snippet, it holds and manages the entire state required for all the dumb
    components used in its template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MovieService` is injected into the component. We can ignore the details
    about this for now because it will be explained in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'WeÂ thenÂ use the `ngOnInit` event hook to trigger the initial data fetching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the properties, the constructor, and the `ngOnInit` event of
    the component, we are going to declare some methods. As you can see in the following
    code snippet, these methods are used to mutate the state of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding chapter, we learned the basics about the MobX architecture.
    There are some significant differences between the MobX architecture and the Angular
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: In MobX, the application state belongs to the `Store`. The smart component talks
    to the `Store` via actions. The `Store` is the entity that ultimately mutates
    the state, not the smart component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Angular, the application state belongs to the smart component, which is the
    entity that ultimately mutates the state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Angular, we used a service to perform the Ajax calls; on the other hand,
    in MobX, we performed the Ajax calls inside the `Store`. This is a minor difference
    because we can create a service in MobX to perform the Ajax calls. The `Store`
    could then talk to the service. The key takeaway here is the difference in state
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods use the `MovieService` to perform some Ajax calls and
    to mutate the state of the `MovieComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dependency injection in Angular requires us to define some unique identifiers
    using the `InjectionToken` class. Injection tokens are unique identifiers used
    to represent a type at runtime. The concept of `InjectionToken` in Angular is
    very similar to the concept of symbols in InversifyJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating an `InjectionToken`, we must decorate the class that we wish
    to inject with the `@injectable` decorator, as demonstrated by the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also must declare a binding between the `InjectionToken` and an implementation
    of the type that it represents. This can be achieved using the `providers` setting
    when we declare an `NgModule` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet binds the `InjectionToken MOVIE_SERVICE` to the
    implementation `MovieService`. Finally, we can use the `@Inject` decorator to
    declare a dependency in one of our Angular components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the documentation at [https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)
    to learn more about dependency injection in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the basic principles of component-based web
    development and how to use Angular. We learned how to bootstrap an Angular application,
    how to implement routing, and how to create components.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to implement dumb and smart components as well as how to
    work with services and implement dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about application performance.
  prefs: []
  type: TYPE_NORMAL
