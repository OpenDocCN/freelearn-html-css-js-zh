<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Leveraging Flux Libraries</h1></div></div></div><p>Flux, first and foremost, is a set of architectural guidelines, specified as patterns for us to follow. While this affords the ultimate flexibility, it can be paralyzing sometimes, when it comes to deciding how to implement a given Flux component. Thankfully, there are some really good Flux libraries out there that provide opinionated implementations of Flux components, which remove the need for a lot of the boilerplate code we would have to write. The idea of this chapter is to look at two of these libraries, to show just how different Flux implementations can be. The goal isn't compliance, but rather a solid architecture that helps our application get the job done.</p><div><div><div><div><h1 class="title"><a id="ch12lvl1sec70"/>Implementing core Flux components</h1></div></div></div><p>In this section, we're going to reiterate the idea that we can change the implementation specifics of the various Flux components in our architecture. We'll start by talking about the dispatcher itself, and think about the various changes that we might make. Then, we'll think about stores and the enhancements we might want to make there. Finally, we'll discuss actions and action creator functions.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec146"/>Customizing the dispatcher</h2></div></div></div><p>In Chapter 10, <em>Implementing a Dispatche</em>
<em>r</em>, we implemented our own dispatcher component. The reference implementation by Facebook is perfectly fine to use, but it's not meant to be the de-facto <a id="id439" class="indexterm"/>component found in every production Flux architecture. Instead, it's meant to be a jumping off point, so we can see how the Flux dispatcher specification is supposed to work.</p><p>Our solution was to expose the <code class="literal">dispatch()</code> and <code class="literal">register()</code> functions from the dispatcher module. By doing so, we made using the dispatcher a little more direct in other areas of our code. There was no longer a dispatcher instance to think about—everything was encapsulated within the dispatcher module.</p><p>A generic Flux library might want to take this a step further and completely dissolve the dispatcher, which might sound nuts—it's an essential Flux component. However, we can still achieve the same<a id="id440" class="indexterm"/> architectural principle of the dispatcher without explicitly implementing this abstraction. This is the whole point of releasing Flux as a set of specs instead of a concrete implementation. We know conceptually what a Flux architecture should and should not do—we get to pick how to enforce these rules with our implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec147"/>Implementing a base store</h2></div></div></div><p>Another improvement we made in <a class="link" href="ch10.html" title="Chapter 10. Implementing a Dispatcher">Chapter 10</a> , <em>Implementing a Dispatcher</em>, was to the store hierarchy. We<a id="id441" class="indexterm"/> had each of our stores inherit from a base class. The main reason we implemented this functionality was to automate the registration of the store with the dispatcher, which is good, because there's not much sense in a Flux store that isn't listening to events emitted from the dispatcher. Perhaps a Flux library should handle this type of base functionality for us.</p><p>We also implemented method action handlers. This was actually a function of the dispatcher itself in our implementation, and it was quite limiting. Perhaps the base store is the appropriate place for this type of functionality. Libraries should contain this type of generic complexity, not our application.</p><p>What's nice about inheriting base functionality with Flux stores is that this is where the brains of our application live. If we were to discover some generic state transformation behavior that applied to more than one store, having a base store in place makes it easy for us to factor out the common code. Maybe a Flux library could ship with some basic transformations in their base store that we would inherit from.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec148"/>Creating actions</h2></div></div></div><p>Constants are a great way to be explicit about actions in Flux architectures. The action module defines the <a id="id442" class="indexterm"/>constant, and the action creator function passes the constant to the dispatcher. Stores also use these constants when determining how to handle actions as they're dispatched. This creates an explicit tie between the action creator and the code in stores that respond to this action.</p><p>In <a class="link" href="ch10.html" title="Chapter 10. Implementing a Dispatcher">Chapter 10</a>, <em>Implementing a Dispatcher</em>, we adopted a different approach. The action creator functions still defined constants and used them when dispatching the action. However, we made changes that allowed for our stores to define method handlers. So instead of one function that listened to the dispatcher, the stores defined methods that matched the constant defined for the action. This is convenient from the store's perspective, but it diminishes the value of having constants if they're only used by the action creator functions.</p><p>A Flux library could help make dispatching and handling actions a little more straightforward. Using constants and <code class="literal">switch</code> statements is good insofar as it makes what's happening explicit. We like explicitness in our Flux architecture. The challenge is that this approach requires<a id="id443" class="indexterm"/> diligence on the part of the programmers implementing the system. In other words, there's plenty of opportunity for human error. A Flux library could remove the error-prone aspects of dealing with constants in two places.</p><p>Another area that a Flux library could help is with asynchronous action creator functions. The asynchronous behavior of our application is likely to follow a similar pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dispatch an action that changes the state of a store before the asynchronous code runs</li><li class="listitem" style="list-style-type: disc">Dispatch an action when the response arrives</li><li class="listitem" style="list-style-type: disc">Dispatch a different action if the asynchronous behavior fails.</li></ul></div><p>It's almost like asynchronous actions have a lifecycle that could be abstracted into a common function by a Flux library.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec71"/>Implementation pain points</h1></div></div></div><p>In the preceding<a id="id444" class="indexterm"/> section, we covered the areas of Flux that might benefit from a custom implementation. Before we dive into <code class="literal">Alt.js</code> and Redux, we'll briefly talk about some of pain points with implementing Flux architectures. Asynchronous actions are tough to get right, in any architecture, let alone Flux. The way we partition our application state into stores can be a tricky design problem. If we get this wrong, it can be hard to recover from. Finally, we have data dependency challenges to think about.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec149"/>Dispatching asynchronous actions</h2></div></div></div><p>As we discussed in the preceding section, asynchronous action creators are difficult to implement. It's challenging<a id="id445" class="indexterm"/> because we usually have to let the stores know that this asynchronous action is about to take place so that the UI can be updated to reflect this. For example, when a button is clicked that sends one or more AJAX requests, we probably want to disable that button before actually sending the request, to prevent duplicate requests. The only way to do this in Flux is to dispatch an action, because everything is unidirectional.</p><p>Libraries can help with this, to an extent. For example, the pre-request actions and success/error response actions can be somewhat abstracted into something that's easier to use, because that's a common pattern. However, even doing this leaves the issue of assembling requests to go fetch all the data that's needed for a given action, synchronize the responses and pass them each to the store so that it can transform them into something that the view needs.</p><p>Maybe it's best if we were to leave this asynchronous problem outside the scope of Flux. Facebook has introduced<a id="id446" class="indexterm"/> GraphQL, for example, a language that simplifies building complex data from backend services and only responding with what the store actually needs. This is all done in one response, so we save on bandwidth and latency as well. This approach isn't for everyone, and so it's up to the Flux implementer to choose how they want to deal with asynchronicity, just as long as the unidirectional data-flow on the client remains intact.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec150"/>Partitioning stores</h2></div></div></div><p>Incorrectly partitioning the stores in our Flux architecture is perhaps one of the biggest design risks we face. What<a id="id447" class="indexterm"/> generally happens is that the stores are roughly balanced; then, as the system evolves, all the new features end up going into one store while the responsibilities of the other stores aren't clear. The stores become unbalanced, in other words. The store that holds onto the majority of the application state gets too complex to maintain.</p><p>Another potential issue with the partitioning of our stores is that they grow to be too fine-grained. We don't want this to happen either. Though the state that's managed by individual stores is simple enough, the complexity resides in the dependencies between all these stores. Even if there aren't too many dependencies, when there's more stores to think about, it's more difficult to hold enough state in our heads as we're trying to reason about something. When related state is all in one place, it's much easier to predict what will happen.</p><p>What if a Flux library, like Redux, took a radical approach and eliminated all sources of confusion by only allowing a single store? This indeed prevents design issues like partitioning stores. Instead, as we'll see later on the chapter, Redux uses reducer functions to transform the state of the single store.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec72"/>Using Alt</h1></div></div></div><p><code class="literal">Alt.js</code> is a Flux library that implements a<a id="id448" class="indexterm"/> lot of the boilerplate code for us. It completely adheres to the Flux concepts and patterns, but let's us focus on the architecture from the perspective of our application, rather than worrying about action constants and <code class="literal">switch</code> statements.</p><p>In this section, we'll touch on the core concepts of Alt before diving into a simple todo list example. The example is<a id="id449" class="indexterm"/> intentionally simple—you'll be able to map the code back to the Flux concepts you've learned about so far in this book.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec151"/>The core ideas</h2></div></div></div><p>The main goal of the Facebook <a id="id450" class="indexterm"/>Flux package is to provide a reference implementation of a basic dispatcher component. This serves well as an aide to the concepts of Flux—actions are dispatched to stores in a synchronous, unidirectional fashion. As we've seen through the book, the dispatcher concept doesn't even necessarily need to be exposed to those who are implementing Flux. We can simplify the Flux abstractions and yet still fall within the constraints of a Flux architecture.</p><p>Alt is a Flux library that's supposed to be used in production applications—it's not a reference implementation. Let's go over a few of it's goals as a Flux library before we jump into the code.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Compliant</strong>: Alt doesn't borrow ideas from<a id="id451" class="indexterm"/> Flux—it's truly meant for Flux systems. For example, the concept of stores, actions, and views are all relevant. Likewise, the principles of Flux architecture are followed closely by Alt. Things like synchronous update rounds and unidirectional data-flow are enforced.</li><li class="listitem" style="list-style-type: disc"><strong>Automates boilerplate</strong>: Some of the more tedious programming tasks associated with implementing Flux are handled nicely by Alt. These include things like automatically <a id="id452" class="indexterm"/>creating action creator functions and action constants. Alt will also take care of store action handler methods for us—reducing the need for long <code class="literal">switch</code> statements.</li><li class="listitem" style="list-style-type: disc"><strong>No dispatcher</strong>: There's no<a id="id453" class="indexterm"/> dispatcher for our code to interface with. Dispatching actions to all the stores is taken care of behind the scenes, when we call our action creator functions. Things like dependency management between stores are handled directly within the stores themselves.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec152"/>Creating stores</h2></div></div></div><p>The simple application that we're <a id="id454" class="indexterm"/>going to create will display two lists for the user. One list is for the todo items, the other list is for the items that have been completed. We'll use two stores—one for each list. Let's take a look at how we create stores using <code class="literal">Alt.js</code>. First, we have the <code class="literal">Todo</code> store:</p><div><pre class="programlisting">import alt from '../alt';
import actions from '../actions';

class Todo {
  constructor() {

    // This is the state of the input element
    // used to create a new Todo item.
    this.inputValue = '';

    // The initial list of todo items...
    this.todos = [
      { title: 'Build this thing' },
      { title: 'Build that thing' },
      { title: 'Build all the things' }
    ];

    // Sets up the handler methods to be called
    // when the corresponding action is dispatched.
    this.bindListeners({
      createTodo: actions.CREATE_TODO,
      removeTodo: actions.REMOVE_TODO,
      updateInputValue: actions.UPDATE_INPUT_VALUE
    });
  }

  // Creates a new Todo using the action "payload"
  // as the title.
  createTodo(payload) {
    this.todos.push({ title: payload });
  }

  // Removes the Todo based on the index, which is
  // passed in as the action payload.
  removeTodo(payload) {
    this.todos.splice(payload, 1);
  }

  // Updates the Todo value that the user is currently
  // entering in the Todo input box.
  updateInputValue(payload) {
    this.inputValue = payload;
  }
}

// The "createStore()" function hooks our store class
// up with all the relevant action dispatching machinery,
// returning an instance of the store.
export default alt.createStore(Todo, 'Todo');</pre></div><p>This probably doesn't look very familiar, relative to what we've seen so far in this book. Not to worry; we'll walk through the moving parts here now. The first question you probably have is—where's the<a id="id455" class="indexterm"/> state? It's not clear by looking at the code, but the state is any instance variables of the class. In this case, it's the <code class="literal">inputValue</code> string and the <code class="literal">todos</code> array.</p><p>Next, we have a call to <code class="literal">bindListeners()</code> with a configuration object passed to it. This is how Alt stores map actions to methods. You can see that we have methods defined that correspond to what's passed into <code class="literal">bindListeners()</code>. Lastly, we have the call to <code class="literal">createStore()</code>. This function instantiates the <code class="literal">Todo</code> store class for us, but it also hooks up the dispatch mechanism.</p><p>That's all there is to the store definition—it's ready to be used by views that need to render it's state. Now let's take a look at the <code class="literal">Done</code> store, which follows the same approach, only with fewer moving parts:</p><div><pre class="programlisting">import alt from '../alt';
import actions from '../actions';
import todo from './todo';

class Done {
  constructor() {

    // The "done" state holds an array of
    // completed items.
    this.done = [];

    // Binds the only listener of this store.
    this.bindListeners({
      createDone: actions.CREATE_DONE
    });
  }

  // This action payload is the index of an item
  // from the "todo" store. This is called when
  // the item is clicked, and the item is added
  // to the "done" array.
  //
  // Note that this action handler does not mutate
  // the "todo" state as that is not allowed.
  createDone(payload) {
    const { todos } = todo.getState();
    this.done.splice(0, 0, todos[payload]);
  }
}

// Creates the store instance, and hooks it
// up with the Alt dispatching machinery.
export default alt.createStore(Done, 'Done');</pre></div><p>You can see here that this store<a id="id456" class="indexterm"/> actually uses the <code class="literal">Todo</code> store to copy over item data when an item is marked as done. However, this store doesn't mutate the <code class="literal">Todo</code> store, as that would violate the unidirectional data-flow.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>These store classes aren't event emitters, so they don't explicitly emit anything when the state changes. For example when a todo is added, how do the views know that anything has changed? Since the <code class="literal">createTodo()</code> method is called automatically for us, the notification mechanism also happens automatically once our method has finished executing. We'll see more on the state change notification semantics momentarily.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec153"/>Declaring action creators</h2></div></div></div><p>We've seen how<a id="id457" class="indexterm"/> stores respond to actions being dispatched. Now we need a means to actually dispatch these actions. This is probably the easiest aspect of our Alt application. Alt can generate the functions we need, as well as the constants that are used by the <code class="literal">bindListeners()</code> call in our stores. Let's take a look at the actions module and see how this works with Alt:</p><div><pre class="programlisting">import alt from './alt';

// Exports an object with functions that accept
// a payload argument. These are the action
// creators. Also creates action constants
// based on the names passed to "generateActions()"
export default alt.generateActions(
  'createTodo',
  'createDone',
  'removeTodo',
  'updateInputValue'
);</pre></div><p>This will export an object with action creator functions that have the same names as the strings passed to <code class="literal">generateActions()</code>. And it'll generate the action constants used by the store. Since our action creator functions are all very similar, <code class="literal">generateActions()</code> has high utility. There's a lot of boilerplate code that we no longer have to maintain. On the other hand, there are more complex cases that involve asynchronous actions that need more code than this. Take a look at the Alt documentation for asynchronous actions if you're interested in using this library for your project.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec154"/>Listening for state changes</h2></div></div></div><p>All throughout this book, we've <a id="id458" class="indexterm"/>added event handler functions to the change event emitted by our stores. With libraries like Alt, this is somewhat managed for us already. Let's take a look at the main module of our application which uses the <code class="literal">AltContainer</code> React component to feed store data into our other React components:</p><div><pre class="programlisting">// The React and Alt components we need...
import React from 'react';
import { render } from 'react-dom';
import AltContainer from 'alt-container';

// The stores and React components from
// this application...
import todo from './stores/todo';
import done from './stores/done';
import TodoList from './views/todo-list';
import DoneList from './views/done-list';

// Renders the "AltContainer" component. This
// is where the stores are tied to the views.
// The "TodoList" and "DoneList" components
// are children of the "AltContainer", so
// they get the "todo" and the "done" stores
// as props.
render(
  &lt;AltContainer stores={{ todo, done }}&gt;
    &lt;TodoList/&gt;
    &lt;DoneList/&gt;
  &lt;/AltContainer&gt;,
  document.getElementById('app')
);</pre></div><p>The <code class="literal">AltContainer</code> component accepts a <code class="literal">stores</code> property. The container will listen to each of these stores and re-render it's children when the state of the any store changes. This is the only setup involved for getting our views to listen to stores—no manual <code class="literal">on()</code> or <code class="literal">listen()</code> calls all over the place. In the next section, we'll look at the <code class="literal">TodoList</code> and the <code class="literal">DoneList</code> components to see how they work with <code class="literal">AltContainer</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec155"/>Rendering views and dispatching actions</h2></div></div></div><p>The job of the <code class="literal">TodoList</code> component is to<a id="id459" class="indexterm"/> render items from the <code class="literal">Todo</code> store. There are two<a id="id460" class="indexterm"/> other things this view needs to handle as well. First, there's the <code class="literal">input</code> element that the user uses to enter new todo items. Second, we also need to mark items as done when they're clicked, by moving them to the done list. These latter two<a id="id461" class="indexterm"/> responsibilities involve event handling and<a id="id462" class="indexterm"/> dispatching actions. Let's take a look at the implementation of the todo list view:</p><div><pre class="programlisting">import React from 'react';
import { Component } from 'react';

import actions from '../actions';

export default class TodoList extends Component {
    render() {

      // The relevant state from the "todo" store
      // that we're rendering here.
      const { todos, inputValue } = this.props.todo;

      // Renders an input for new todos, and the list
      // of current todos. When the user types
      // and then hits enter, the new todo is created.
      // When the user clicks a todo, it's moved to the
      // "done" store.
      return (
        &lt;div&gt;
          &lt;h3&gt;TODO&lt;/h3&gt;
          &lt;div&gt;
            &lt;input
              value={inputValue}
              placeholder="TODO..."
              onKeyUp={this.onKeyUp}
              onChange={this.onChange}
              autoFocus
            /&gt;
          &lt;/div&gt;
          &lt;ul&gt;
            {todos.map(({ title }, i) =&gt;
              &lt;li key={i}&gt;
                &lt;a
                  href="#"
                  onClick={this.onClick.bind(null, i)}
                &gt;{title}&lt;/a&gt;
              &lt;/li&gt;
            )}
          &lt;/ul&gt;
        &lt;/div&gt;
      );
    }

    // An active Todo was clicked. The "key" is the
    // index of the Todo within the store. This is
    // passed as the payload to the "createDone()"
    // action, and next to the "removeTodo()" action.
    onClick(key) {
      actions.createDone(key);
      actions.removeTodo(key);
    }

    // If the user has entered some text and the
    // "enter" key is pressed, we use the
    // "createTodo()" action to create a new
    // item using the entered text. Then we clear
    // the input using the "updateInputValue()"
    // action, passing it an empty string.
    onKeyUp(e) {
      const { value } = e.target;

      if (e.which === 13 &amp;&amp; value) {
        actions.createTodo(value);
        actions.updateInputValue('');
      }
    }

    // The text input value changed - update the store.
    onChange(e) {
      actions.updateInputValue(e.target.value);
    }
}</pre></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>You might be <a id="id463" class="indexterm"/> wondering why we can't just clear <code class="literal">e.target.value</code> when the <strong>Enter</strong> key is pressed. Indeed we could do this, but this would go against the<a id="id464" class="indexterm"/> nature of Flux where state is kept in stores. This includes transient values as they're being entered by the user. What if another part of the application wanted to know about the text input value? Well, all it needs is to depend on the <code class="literal">Todo</code> store. If the state wasn't there, then our code would have to query the DOM, which we don't want to do.</p></div></div><p>Finally, let's look at the done list component. This component is simpler than the todo list because<a id="id465" class="indexterm"/> there's no<a id="id466" class="indexterm"/>  event handling:</p><div><pre class="programlisting">import React from 'react';
import { Component } from 'react';

export default class DoneList extends Component {
  render() {

    // The "done" array is the only state we need
    // from the "done" store.
    const { done } = this.props.done;

    // We want to display these items
    // as strikethrough text.
    const itemStyle = {
      textDecoration: 'line-through'
    }

    // Renders the list of done items, with
    // the "itemStyle" applied to each item.
    return (
      &lt;div&gt;
        &lt;h3&gt;DONE&lt;/h3&gt;
        &lt;ul&gt;
          {done.map(({ title }) =&gt;
            &lt;li style={itemStyle}&gt;{title}&lt;/li&gt;
          )}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec73"/>Using Redux</h1></div></div></div><p>In this section, we're going to look at the Redux library for implementing a Flux architecture. Unlike <code class="literal">Alt.js</code>, Redux <a id="id467" class="indexterm"/>doesn't aim for Flux compliance. The goal of Redux is to borrow the important ideas from Flux, leaving the tedious bits behind. Despite not implementing Flux components as specified in the official documentation, Redux is the go-to solution for React architectures now. Redux is proof that simplicity always wins over advanced features.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec156"/>The core ideas</h2></div></div></div><p>Before implementing some Redux code, let's take<a id="id468" class="indexterm"/> a moment to look at the core ideas of Redux:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>No dispatcher</strong>: This is just like <code class="literal">Alt.js</code>, which also purges the dispatcher concept from it's API. The fact that these Flux libraries don't expose a dispatcher component serves to<a id="id469" class="indexterm"/> illustrate the point that Flux is just a set of ideas and patterns, not an implementation. Both Alt and Redux dispatch actions, they just don't require a dispatcher to do it.</li><li class="listitem" style="list-style-type: disc"><strong>One store to rule them all</strong>: Redux eschews the notion that a Flux architecture requires multiple stores. Instead, one store is used to hold the entire application state. At first<a id="id470" class="indexterm"/> glance, this might sound like the store would get too large and be too difficult to understand. This is just as likely to happen with multiple stores, the only difference there is that the application state is split into different modules.</li><li class="listitem" style="list-style-type: disc"><strong>Dispatch to the store</strong>: When<a id="id471" class="indexterm"/> there's only one store to worry about, we can make design concessions, such as treating the store and the dispatcher as the same concept. This is exactly what Redux does—it dispatches actions directly to the store.</li><li class="listitem" style="list-style-type: disc"><strong>Pure reducers</strong>: The idea behind <a id="id472" class="indexterm"/>multiple Flux stores is to split the application state into a few logically separated domains. We can still do this using Redux, the difference is that we separate our state into domains using reducer functions. These functions are responsible for transforming the state of the store when actions are dispatched. They're pure because they return new data and avoid introducing any side-effects.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec157"/>Reducers and stores</h2></div></div></div><p>We're now going to implement the<a id="id473" class="indexterm"/> same simple todo application that we made using Alt—this time using Redux. There's a lot of overlap between the two libraries, particularly <a id="id474" class="indexterm"/>with the React components themselves; not much needs to change there. Where Redux departs from Alt and Flux in general is with it's single store, and the reducer functions that change it's state. With that said, we'll look at the store and it's reducer functions first.</p><p>We'll create a module for the initial state of the the Redux store. This is an important first step because it provides the initial structure for the reducer functions that transform the store state. Let's take a look at the initial state module:</p><div><pre class="programlisting">import Immutable from 'immutable';

// The initial state of the Redux store. The
// "shape" of the application state includes
// two domains - "Todo" and "Done". Each domain
// is an Immutable.js structure.
const initialState = {
  Todo: Immutable.fromJS({
    inputValue: '',
    todos: [
      { title: 'Build this thing' },
      { title: 'Build that thing' },
      { title: 'Build all the things' }
    ]
  }),
  Done: Immutable.fromJS({
    done: []
  })
};

export default initialState;</pre></div><p>The state is a simple JavaScript object. You can see that the single store isn't just a tangled mess of properties, it's organized by two main properties—<code class="literal">Todo</code> and <code class="literal">Done</code>. This is like having multiple <a id="id475" class="indexterm"/>stores, except they're in one object. Something else you'll notice is that each store property is an <code class="literal">Immutable.js</code> data structure. The reason for this is that <a id="id476" class="indexterm"/>we need to treat the state that's passed into our reducer functions as immutable. This library makes enforcing immutability easy.</p><p>The state transformations that take place with the store state will be divided into two reducer functions. In fact, the two functions map to the two initial properties of the store: <code class="literal">Todo</code> and <code class="literal">Done</code>. Let's look at the <code class="literal">Todo</code> reducer first:</p><div><pre class="programlisting">import Immutable from 'immutable';

import initialState from '../initial-state';
import {
  UPDATE_INPUT_VALUE,
  CREATE_TODO,
  REMOVE_TODO
} from '../constants';

export default function Todo(state = initialState, action) {
  switch (action.type) {

    // When the "UPDATE_INPUT_VALUE" action is dispatched,
    // we set the "inputValue" key of the Immutable.Map.
    case UPDATE_INPUT_VALUE:
      return state.set('inputValue', action.payload);

    // When the "CREATE_TODO" action is dispatched,
    // we push the new item to the end of the
    // Immutable.List
    case CREATE_TODO:
      return state.set('todos',
        state.get('todos').push(Immutable.Map({
          title: action.payload
        }))
      );

    // When the "REMOVE_TODO" action is dispatched,
    // we delete the item at the given index from
    // the Immutable.List.
    case REMOVE_TODO:
      return state.set('todos',
        state.get('todos').delete(action.payload));
    default:
      return state;
  }
}</pre></div><p>The <code class="literal">switch</code> statement that's used here should look familiar—it's the same pattern we've been implementing the<a id="id477" class="indexterm"/> stores throughout this book. In fact, this function is just like a store, with two main differences. The first difference is that it's a function instead of a class. This means<a id="id478" class="indexterm"/> that instead of setting state property values, we return the new state. The second difference is that Redux handles the mechanics of listening to stores and calling this reducer function. With classes, we have to write a lot of this code ourselves.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>It's important that these reducer functions do not mutate the state argument. This is why we're using the <code class="literal">Immutable.js</code> library—to make it easier to transform existing state by creating new data. It's not necessary to use <code class="literal">Immutable.js</code> for transforming Redux store state, but it does help with code brevity.</p></div></div><p>Now let's look at the <code class="literal">Done</code> reducer function:</p><div><pre class="programlisting">import Immutable from 'immutable';

import initialState from '../initial-state';
import { CREATE_DONE } from '../constants';

export default function Done(state = initialState, action) {
  switch (action.type) {

    // When the "CREATE_DONE" action is dispatched,
    // we insert the new item into the beginning
    // of the Immutable.List.
    case CREATE_DONE:
      return state.set('done',
        state.get('done')
          .insert(0, Immutable.Map(action.payload))
      );

    // Nothing to do, return the state "as-is".
    default:
      return state;
  }
}</pre></div><p>We're almost done with our Redux store. At this point, we have two reducer functions, each in their own module. We <a id="id479" class="indexterm"/>need to tie them together using <code class="literal">combineReducers()</code> and <code class="literal">createStore()</code>. Let's take a<a id="id480" class="indexterm"/> look at our store module now:</p><div><pre class="programlisting">import { combineReducers, createStore } from 'redux';

import initialState from './initial-state';
import Todo from './reducers/todo.js';
import Done from './reducers/done.js';

export default createStore(combineReducers({
  Todo,
  Done
}), initialState);</pre></div><p>As you can see, the <code class="literal">combineReducers()</code> function creates a new function. This is the main reducer function that maintains the state of the application. So instead of your typical Flux dispatcher that needs to handle getting actions to several stores, Redux actions are dispatched to this single store, and our reducer functions are called in response.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec158"/>Redux actions</h2></div></div></div><p>As you know, there's a difference<a id="id481" class="indexterm"/> between actions and action creators. Actions are the payloads that get sent to the various Flux stores, whereas action creators are responsible for creating the action payloads, and then sending them to the dispatcher. With Redux, action creator functions are slightly different in that they only create the action payloads, they don't talk directly with the dispatcher.</p><p>We'll see how the action creators are called in the following section when we implement the view components. But for now, here's what <a id="id482" class="indexterm"/>our actions module looks like:</p><div><pre class="programlisting">import {
  CREATE_TODO,
  CREATE_DONE,
  REMOVE_TODO,
  UPDATE_INPUT_VALUE
} from './constants';

// Creates a new Todo item. The "payload" should
// be an object with a "title" property.
export function createTodo(payload) {
  return {
    type: CREATE_TODO,
    payload
  };
}

// Creates a new Done item. The "payload" should
// be an object with a "title" property.
export function createDone(payload) {
  return {
    type: CREATE_DONE,
    payload
  };
}

// Removes the todo and the given "payload" index.
export function removeTodo(payload) {
  return {
    type: REMOVE_TODO,
    payload
  };
}

// Updates the "inputValue" state with the given
// "payload" string value.
export function updateInputValue(payload) {
  return {
    type: UPDATE_INPUT_VALUE,
    payload
  };
}</pre></div><p>These functions just return the data that's going to be dispatched by the store—they don't actually dispatch the data. The exception to this is when asynchronous actions are involved. In this case, we actually<a id="id483" class="indexterm"/> need to dispatch the action once the asynchronous values have resolved. See the official Redux documentation where there are plenty of asynchronous action examples.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec159"/>Rendering components and dispatching actions</h2></div></div></div><p>At this point, we have a Redux store and action creator functions. All that's left to do is implement our React<a id="id484" class="indexterm"/> components and connect them to the store. We'll <a id="id485" class="indexterm"/>start with the <code class="literal">TodoList</code> view:</p><div><pre class="programlisting">import React from 'react';
import { Component } from 'react';
import { connect } from 'react-redux';

import {
  updateInputValue,
  createTodo,
  createDone,
  removeTodo
} from '../actions';

class TodoList extends Component {
  constructor(...args) {
    super(...args);
    this.onClick = this.onClick.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onChange = this.onChange.bind(this);
  }

  render() {

    // The relevant state from the "todo" store
    // that we're rendering here.
    const { todos, inputValue } = this.props;

    // Renders an input for new todos, and the list
    // of current todos. When the user types
    // and then hits enter, the new todo is created.
    // When the user clicks a todo, it's moved to the
    // "done" array.
    return (
      &lt;div&gt;
        &lt;h3&gt;TODO&lt;/h3&gt;
        &lt;div&gt;
          &lt;input
            value={inputValue}
            placeholder="TODO..."
            onKeyUp={this.onKeyUp}
            onChange={this.onChange}
            autoFocus
          /&gt;
        &lt;/div&gt;
        &lt;ul&gt;
          {todos.map(({ title }, i) =&gt;
            &lt;li key={i}&gt;
              &lt;a
                href="#"
                onClick={this.onClick.bind(null, i)}
              &gt;{title}&lt;/a&gt;
            &lt;/li&gt;
          )}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }

  // An active Todo was clicked. The "key" is the
  // index of the Todo within the store. This is
  // passed as the payload to the "createDone()"
  // action, and next to the "removeTodo()" action.
  onClick(key) {
    const { dispatch, todos } = this.props;

    dispatch(createDone(todos[key]));
    dispatch(removeTodo(key));
  }

  // If the user has entered some text and the
  // "enter" key is pressed, we use the
  // "createTodo()" action to create a new
  // item using the entered text. Then we clear
  // the input using the "updateInputValue()"
  // action, passing it an empty string.
  onKeyUp(e) {
    const { dispatch } = this.props;
    const { value } = e.target;

    if (e.which === 13 &amp;&amp; value) {
      dispatch(createTodo(e.target.value));
      dispatch(updateInputValue(''));
    }
  }

  // The text input value changed - update the store.
  onChange(e) {
    this.props.dispatch(
    updateInputValue(e.target.value));
  }
}

// The props that get passed to this component
// from the store. We just need to convert the
// "Todo" Immutable.js structure to plain JS.
function mapStateToProps(state) {
  return state.Todo.toJS();
}

// Exports the "connected" version of the
// component that's connect to the Redux store.
export default connect(mapStateToProps)(TodoList);</pre></div><p>The key thing to note about this module is that it's not the component class that's exported. Instead, we use the <code class="literal">connect()</code> function from the <code class="literal">react-redux</code> package. This function connects the Redux <a id="id486" class="indexterm"/>store to this view. The state from the store passes through the <code class="literal">mapStateToProps()</code> function, which determines how the React component properties are assigned. In this case, we just need to transform the <code class="literal">Immutable.js</code> structure into<a id="id487" class="indexterm"/> a plain JavaScript object.</p><p>The downside of the event handlers is that we need to bind their context in the constructor, because React doesn't auto-bind the context for ES2015 style components. The handlers need access to <code class="literal">this.props</code> because it has the <code class="literal">dispatch()</code> function needed to dispatch our action data to the store, as well as the store data used to construct the action payloads. Now let's look at the <code class="literal">DoneList</code> component:</p><div><pre class="programlisting">import React, { Component } from 'react';
import { connect } from 'react-redux';

class DoneList extends Component {
  render() {

    // The "done" array is the only state we need
    // from the "done" store.
    const { done } = this.props;

    // We want to display these items
    // as strikethrough text.
    constitemStyle = {
      textDecoration: 'line-through'
    }

    // Renders the list of done items, with
    // the "itemStyle" applied to each item.
    return (
      &lt;div&gt;
        &lt;h3&gt;DONE&lt;/h3&gt;
        &lt;ul&gt;
          {done.map(({ title }, i) =&gt;
            &lt;li key={i} style={itemStyle}&gt;{title}&lt;/li&gt;
          )}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

// The props that get passed to this component
// from the store. We just need to convert the
// "Done" Immutable.js structure to plain JS.
function mapStateToProps(state) {
  return state.Done.toJS();
}

// Exports the "connected" version of the
// component that's connect to the Redux store.
export default connect(mapStateToProps)(DoneList);</pre></div><p>As you can see, this works in <a id="id488" class="indexterm"/>much the same way as the <code class="literal">TodoList</code> component. In fact, these <a id="id489" class="indexterm"/> components haven't changed much relative to the Alt implementation of the same application. The last step is to hook up the two components with the Redux store, which can be accomplished using the <code class="literal">Provider</code> component:</p><div><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';
import { Provider } from 'react-redux';

import store from './store';
import TodoList from './views/todo-list';
import DoneList from './views/done-list';

// Renders the "TodoList" and the "DoneList"
// components. The "Provider" component is
// used to connect the store to the components.
// When the store changes state, the children
// of "Provider" are re-rendered.
render(
  &lt;Provider store={store}&gt;
    &lt;div&gt;
      &lt;TodoList/&gt;
      &lt;DoneList/&gt;
    &lt;/div&gt;
  &lt;/Provider&gt;,
  document.getElementById('app')
);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec74"/>Summary</h1></div></div></div><p>In this chapter, you learned about leveraging Flux libraries. In particular, we looked at two of the prevailing libraries that can be used to implement Flux architectures.</p><p>We started the chapter off with a discussion that was mostly a recap of the fundamental principles of Flux and how we implemented them throughout the previous chapters of this book. We then covered some of the various pain points of implementing Flux—like singleton dispatchers, repetitive action code, and partitioning store modules. These are areas that a library like <code class="literal">Alt.js</code> or Redux could address for us.</p><p>We then proceeded to implement a simple todo application using the <code class="literal">Alt.js</code> Flux library. The idea behind Flux is to implement all the relevant Flux components while automating the typical arduous implementation chores behind the scenes for us. After this, we turned our attention to the Redux library. Redux is less concerned with following the Flux patterns exactly. Instead, Redux aims for simplicity while borrowing some of the more important Flux ideas like unidirectional data-flow.</p><p>In the next chapter, we'll cover two very important aspects of any Flux architecture—functional and performance testing.</p></div></body></html>