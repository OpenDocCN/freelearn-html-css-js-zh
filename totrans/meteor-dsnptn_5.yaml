- en: Chapter 5. Testing Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover testing patterns that ensure our code is easy to maintain.
    With these patterns, you will learn how to implement regression testing—a method
    to identify if the new code breaks the old code before the code goes into production.
    Building tests is crucial to maintain code and collaborate with others. You will
    learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in Meteor is still under heavy development, but the functions that we
    will cover are basic and are unlikely to change.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behavior tests are known as end-to-end tests too. The purpose of a behavior
    test is simple: it makes sure that a feature of the project is working. A feature
    refers to the business logic behind the application. For example, a feature of
    our current project is viewing a list of products in our landing page. Another
    feature is the ability to add a variable quantity of products to the order.'
  prefs: []
  type: TYPE_NORMAL
- en: To run behavior tests in Meteor, we essentially need to build a robot that can
    visit our website and try to make these features work. While this sounds complex,
    the Meteor Velocity project simplifies much of this when paired with Cucumber.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity is a project that sets the stage for other testing frameworks to use.
    It works by creating mirrors of the project where tests can run.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber is a specification-by-example testing framework. It is meant to describe
    application features in plain English before they are programmed. In a collaboration
    setting, these tests are the ones that matter most because they make sure that
    the application is behaving as expected. We will use the Cucumber package now
    because it is one of the only testing frameworks that support behavior tests that
    are currently available to Meteor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build tests, we first need to install the `xolvio:cucumber` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This package automatically installs Velocity and all other required packages.
    Now run the Meteor command to start up the server. The following two things are
    going to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: A new browser window will open if there are any tests to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current project will have a dot on the top-right side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new browser window is what we call a **mirror** and is the client that is
    going to run all the behavior tests that we define. While this is great, it is
    annoying to have a second browser window open and close every time we run the
    Meteor command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get rid of the second browser window, we can use `phantomjs` to run tests.
    To do this, we will simply run the Meteor command with some settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PhantomJS is a headless browser. A headless browser is a web browser (such as
    Safari and Chrome) without a **Graphical User Interface** (**GUI**). In other
    words, it's a browser for robots, and this is exactly what our robot needs to
    run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a custom Meteor alias with this command. Open the `~/.bash_profile`
    directory with your favorite text editor. If you use Sublime Text 3, you can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, add this line to the end of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now completely quit your terminal, and then open it again. Go to your project
    and run the `devmeteor` command to start your project.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the project URL. Here, you will notice a blue circle on the top-right
    corner of the project. Click this to reveal the velocity test dashboard. Whenever
    tests fail, here you will see why they failed. All tests are rerun every time
    there is a change in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior tests](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by building our first behavior test. In this test, we are going
    to check whether we can add items to the order. To do this, we need to program
    two key components:'
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps** are, basically, snippets of code in JavaScript or CoffeeScript that
    interpret the **feature**. Step snippets are automatically generated after writing
    a feature. Therefore, we need to start by writing the description of the feature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All our tests are going to be saved under the `/tests` directory. Behavior
    tests will always go under the `/cucumber` folder. At the time of this writing
    book, this has been mandatory because Velocity runs under these special directories
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the file ends in `.feature` and is located under the `/features`
    directory. Placing files under the `features` directory is mandatory as well for
    the testing suite to be able to identify your feature files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is written in the Gherkin language. If you want to add comments,
    you can use the pound sign (`#`) just we do in CoffeeScript. The `Feature` keyword
    describes the feature; this can be anything as long as it helps you to identify
    what the feature is. After this, we can see three lines that describe the purpose
    of the feature. This description can also be anything you want since this does
    not affect the test, but it is common to use the following syntax to help identify
    whether the feature is useful or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will find the `Background` and `Scenario` keywords. Both are a list
    of actions that lead to a result. For each feature, there can be multiple scenarios
    that test the different parts of the feature. The `Background` keyword defines
    a list of actions to be taken before running the ones under the `Scenario` keyword.
    Try to keep backgrounds short and simple, and keep in mind that they will run
    for every scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that we have an `@dev` keyword directly above the `Scenario` keyword;
    this keyword controls where `Scenario` is going to run. If you do not include
    a keyword, it will only run when you run `meteor --test` in your terminal. If
    you include `@dev`, the test will run every time you make changes to your web
    application. Also, you can include `@ignore` to ignore the test completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Given`, `When`, `And`, and `Then` keywords are commands that run the steps
    in our test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: The purpose of `Given` is to put the app in a known state before any
    interaction occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: The purpose of `When` is to describe the key action the user performs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`And`: The purpose of `And` is to write scenarios more fluently. They, basically,
    substitute `And` with the previous keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: The purpose of `Then` is to observe and evaluate outcomes. This phrase
    will always make sure that the system has produced something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have programmed our first feature, let''s generate the steps that
    will execute the feature. Run your alias command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server has started, Velocity will produce a command you can use to
    tail the projects'' `cucumber.log`. Open up a separate terminal without deactivating
    Meteor and run that command. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior tests](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't, you can restart the Meteor project without leaving `cucumber.log`.
    Here, we can see the JavaScript version of the steps that the feature is expecting.
    Let's rewrite these in CoffeeScript under the special `/step_definitions` directory.
    This directory must always be a sibling to the related `.feature` files.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code snippets and create a new file under the `/tests/cucumber/features/cart/step_definitions/steps.coffee`
    directory. We are going to convert these snippets to CoffeeScript, since this
    is what we have been working with all along. You can do this quickly at [http://js2.coffee](http://js2.coffee).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each function passes a `callback` variable at the end and calls
    the `pending()` function. When tests run, this indicates that the function has
    not been built yet and appears as pending in the Cucumber log. We can remove the
    `callback` variable after we have finished working with the function. Notice that
    arguments are passed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running tests with this code will not work; we need to initialize the test
    properly. To do this, we begin by using CoffeeScripts'' `do` function and attaching
    the commands to the `module.exports` function. You need to do this for every test
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the tests are actually running, we can dive deeper. The first function
    that we will address is `Given`. `Given` needs to make sure that the user is completely
    new and has no active order. To do this, we are going to use **fixtures**. Fixtures
    are `Meteor.methods` exclusively available in testing. We can use these methods
    to clear our database or add seed data. Let''s start by making a fixture that
    ensures that the user is anonymous and another fixture that clears all the orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call these methods in the `Given` function (or any other function)
    using the `@server.call` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are using `@server`, but we can use `@client` too since this
    is a call to `Meteor.method`. Now let''s program `When`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `@browser` object gives access to an instance of webdriver. This means that
    we can use the webdriver functions to simulate user clicks, inspect elements,
    and browse the Web. Notice that we can require NPM modules through the `require`
    function as well. In this case, we will require the `url` module to help identify
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `When` function requires a single argument defined by the regular
    expression. In this case, it is the `path` variable. Arguments will always be
    listed one by one as they are defined in the regular expression, and they will
    end with the callback function (which we do not need to use): `(arg1, arg2, arg3,
    callback) ->`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second `When` function needs to wait for the DOM to load before acting on
    it. To do this, we will use the `waitForExist` and `waitForVisible` functions.
    If the elements do not render, then the test will fail due to a timeout in this
    function. Remember that if you ever want to see what the test is doing, you can
    browse to your mirror.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a full list of the available webdriver functions at [http://webdriver.io/api.html](http://webdriver.io/api.html),
    but here is a list of the ones you will use the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `waitForExist(selector[,timeout,reverse])` | Default timeout: `500`, reverse:
    `false`.This waits for an element to render on the DOM. Setting the `reverse`
    flag to `true` will instead wait for the element to stop existing. |'
  prefs: []
  type: TYPE_TB
- en: '| `waitForVisible(selector[,timeout,reverse])` | Default timeout: `500`, reverse:
    `false`.This waits for an element to be visible (checks that the display CSS property
    is not set to any, that the element is not outside the viewport, and that the
    `opacity` CSS property is not set to `0`). Setting the `reverse` flag to `true`
    will instead wait for the element to be invisible. |'
  prefs: []
  type: TYPE_TB
- en: '| `click(selector)``doubleClick(selector)``leftClick(selector)``rightClick(selector)`
    | This clicks an element. Can take in a CSS selector. |'
  prefs: []
  type: TYPE_TB
- en: '| `setValue(selector,values)``addValue(selector,values)` | This sends a sequence
    of keystrokes to an element. Can use unicode characters as well to simulate things
    such as backspace and arrow keys. The `addValue` function will append to a set
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `getText(selector)``getValue(selector)` | This gets the node text or input
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `getCssProperty(selector,property)``getAttribute(selector,attribute)` | This
    gets data on a CSS property or DOM element attribute. The `property` variable
    will return an object instead of a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `then(function(valueFromGet))` | This uses data obtained from any `get` function.
    The first parameter is always the value of the `get` function. |'
  prefs: []
  type: TYPE_TB
- en: 'Now let''s build our `Then` function and use **Chai** to evaluate that everything
    proceeded as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the `then` function to work with the value from the `.quantity`
    node. We use Chai to check whether the value obtained is correct. The list of
    Chai functions is long, and you will find yourself using most of them. They are
    easy to guess though! You can find all of these functions here: [http://chaijs.com/api/bdd](http://chaijs.com/api/bdd).'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are much easier to build than behavior tests. These tests make sure
    that only a section of the web application is working correctly, such as `Meteor.method`
    or a template helper.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests make it quicker to find bugs in broken behavior tests. They should
    be used mostly in parts that you know can break easily, such as a publisher or
    a particular helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run unit tests, we are going to use the `sanjo:jasmine` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create two directories: `/jasmine/client/integration` and `/jasmine/server/integration`.
    These are the special directories where `jasmine` runs tests. Let''s build a quick
    test for the `products` publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Jasmine is simple. First, you use the `describe` function to describe the object
    of the feature, and then you use the `it` function to explain each part of the
    feature that should work. It is common to divide the evaluating function into
    three blocks: `SETUP`, `EXECUTE` and `VERIFY`. At setup, we make sure that everything
    is ready for the test to run, then we execute a series of functions, and finally,
    we use the Chai expressions to verify whether the test passes or fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are great for testing peculiarities in your code that users might
    not see reflected visually. Have a look at the Jasmine documentation at [http://jasmine.github.io/2.3/introduction.html](http://jasmine.github.io/2.3/introduction.html)
    for a collection of great examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build simple tests for our web application.
    In addition, we learned that they are a crucial part of the development process
    in order to maintain the application in both a team and nonteam setting. Behavior
    tests are the tests that make sure that the application is running all the features
    as expected, while unit tests are the tests that make sure that only particular
    weak spots are running as expected. Be careful with testing. While it is important
    to keep tests active for maintenance, it is more important to focus on the programming
    of the product. If you do not have time to write a full behavior test, write at
    least one unit test on a function that is critical for the web application to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to cover how to deploy our web application
    to a production quality server and how to identify errors produced by the application
    easily, once the application is running.
  prefs: []
  type: TYPE_NORMAL
