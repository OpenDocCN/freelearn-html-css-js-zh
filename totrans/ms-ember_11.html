<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Building Real-time Applications</h1></div></div></div><p class="calibre7">Up until now, the applications we created did not require any real-time capabilities. However, today's modern applications strive to offer the best user experience through reduced page reloads, efficient <a id="id528" class="calibre1"/>data transfers, and improved performances. In addition, these applications might also need to send data and receive updates to and from the server as quickly as possible. There are a number of web technologies that can be used to accomplish this need:</p><div><ul class="itemizedlist"><li class="listitem">Adobe Flash sockets</li><li class="listitem">JSONP polling</li><li class="listitem">XHR long polling</li><li class="listitem">XHR multipart streaming</li><li class="listitem">ActiveX HTMLFile</li><li class="listitem">Web sockets</li><li class="listitem">Server-sent events</li><li class="listitem">WebRTC</li></ul></div><p class="calibre7">In this chapter, we will learn how to use the<a id="id529" class="calibre1"/> <strong class="calibre8">Socket.io</strong> (<a class="calibre1" href="http://socket.io">http://socket.io</a>) library, which <a id="id530" class="calibre1"/>enables bidirectional communication between web clients and servers. It does this by providing a similar API between the mechanisms just mentioned, excepting the last two. Additionally, it selects the best mechanism to use depending on a number of factors, such as browser support, among others.</p><p class="calibre7">Before diving into using Socket.io, it's worth noting that server-sent events are a good option if the client app is meant to constantly receive updates from the backend while performing little or no pushes. Facebook newsfeeds and Twitter timelines are good examples of use cases that can benefit from this technology. The following resources can aid in the development of such an application:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">Sse client library</strong> available<a id="id531" class="calibre1"/> at <a class="calibre1" href="https://github.com/segmentio/sse">https://github.com/segmentio/sse</a></li><li class="listitem"><strong class="calibre8">Sse Node.js library</strong> <a id="id532" class="calibre1"/>available at <a class="calibre1" href="https://github.com/segmentio/sse-stream">https://github.com/segmentio/sse-stream</a></li></ul></div><p class="calibre7">
<strong class="calibre8">WebRTC</strong> is a<a id="id533" class="calibre1"/> good choice for applications that require peer-to-peer communication, such as audio and video streaming.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec109" class="calibre1"/>Setting up Socket.io</h1></div></div></div><p class="calibre7">To aid in <a id="id534" class="calibre1"/>mastering Socket.io, we will explore the<a id="id535" class="calibre1"/> bundled chapter sample that is a simple IRC-style chat application and the backend of which is built in Node.js, as shown in the following screenshot:</p><div><img src="img/00020.jpeg" alt="Setting up Socket.io" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The only prerequisite is Node.js, which can be downloaded from <a class="calibre1" href="http://nodejs.org/download">http://nodejs.org/download</a>. The following tests can then be performed to verify the installation:</p><div><pre class="programlisting">
<strong class="calibre8">node --version</strong>
<strong class="calibre8">v0.10.29</strong>

<strong class="calibre8">npm --version</strong>
<strong class="calibre8">1.4.14</strong>
</pre></div><p class="calibre7">Then, boot the <a id="id536" class="calibre1"/>application with the following commands in order:</p><div><pre class="programlisting">
<strong class="calibre8">npm install</strong>
<strong class="calibre8">node server.js</strong>
</pre></div><p class="calibre7">The backend uses the <a id="id537" class="calibre1"/>
<strong class="calibre8">Express.io</strong> (<a class="calibre1" href="http://express.io">http://express.io</a>) library, which integrates the popular <a id="id538" class="calibre1"/>Express.js (<a class="calibre1" href="http://expressjs.com">http://expressjs.com</a>) web application framework with Socket.io to reduce the setup boilerplate code to the following:</p><div><pre class="programlisting">var app = require('express.io')();
app.http().io();
app.listen(3000);</pre></div><p class="calibre7">Express.io ships with the Socket.io client library and serves it at <code class="email">/socket.io/socket.io.js</code> when started. We therefore only need to load it together with the rest of the application files as:</p><div><pre class="programlisting">&lt;script src="img/socket.io.js"&gt;&lt;/script&gt;
&lt;script src="img/moment.js"&gt;&lt;/script&gt;
&lt;script src="img/jquery-1.10.2.js"&gt;&lt;/script&gt;
&lt;script src="img/handlebars-1.1.2.js"&gt;&lt;/script&gt;
&lt;script src="img/ember-1.2.0.js"&gt;&lt;/script&gt;
&lt;script src="img/app.js"&gt;&lt;/script&gt;</pre></div><p class="calibre7">The client library can, of course, alternatively be downloaded from <a class="calibre1" href="http://socket.io/download/">http://socket.io/download/</a> and served likewise. The client library is usually initialized by invoking the <code class="email">connect</code> method on the exposed <code class="email">io</code> global variable, as shown in the following code:</p><div><pre class="programlisting">App = Ember.Application.create({
  rootElement: '#wrap'
});
App.io = io.connect();</pre></div><p class="calibre7">Note that there are other Socket.io libraries implemented in other languages that can be used instead of the official Node.js library.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec110" class="calibre1"/>Connecting the user</h1></div></div></div><p class="calibre7">When the <a id="id539" class="calibre1"/>application is loaded at <code class="email">http://localhost:3000</code>, the user is required to specify the handle to use before joining the chat by submitting the desired nick in the <code class="email">/join &lt;desired nick&gt;</code> format. The<a id="id540" class="calibre1"/> <code class="email">App.MessageField</code> view delegates this event to the <code class="email">index</code> controller <code class="email">chat</code> action as:</p><div><pre class="programlisting">{{view App.MessageField
  required="required"
  placeholder="message"
  action="chat"
  id="message-input"
  value=controller.message}}

App.MessageField = Em.TextField.extend({
  insertNewline: function(){
    this.triggerAction();
  }
});</pre></div><p class="calibre7">This is something that we learned in <a class="calibre1" title="Chapter 6. Views and Event Management" href="part0069_split_000.html#page">Chapter 6</a>, <em class="calibre9">Views and Event Management</em>, under the <em class="calibre9">Emitting actions from views</em> section. As we shall see later, the rest of the application's visibility is obscured until the user connects successfully for the first time. In the <code class="email">chat</code> action of the corresponding controller, <code class="email">App.IndexController</code>, we first make sure that the submitted message is not empty:</p><div><pre class="programlisting">var message = self.get('message');
if (message) message = message.trim();
if (!message || message === '') return;</pre></div><p class="calibre7">We then check to see if the user intends to join the chat:</p><div><pre class="programlisting">var match = message.match(/\/join (\w+)/);
if (match){
  if (nick){
    self.send('tip', 'Already connected!');
  } else {
    self.send('join', match[1], view);
  }
}</pre></div><p class="calibre7">Of course, if the user is already connected, we notify them through a tooltip. This tooltip is displayed via the <code class="email">tip</code> action, which takes the message to be displayed as its only argument:</p><div><pre class="programlisting">$('.tooltip') 
  .text(msg)
  .show()
  .click(function(){
    $(this).fadeOut();
  });</pre></div><p class="calibre7">If a nick is matched, we pass it the <code class="email">join</code> action, which first subscribes to three server updates. The first update is triggered when a new user joins the chat, and it adds this particular user to the controller's <code class="email">nicks</code> array to be displayed on the user, as shown in the following code:</p><div><pre class="programlisting">App.io.on('join', function(data){
  self.get('nicks').pushObject(data.nick);
});</pre></div><p class="calibre7">The next handler, on the other hand, removes a disconnected user from the collection:</p><div><pre class="programlisting">App.io.on('quit', function(data){
  self.get('nicks').removeObject(data.nick);
});</pre></div><p class="calibre7">We also subscribe to incoming messages and store them in the controller's <code class="email">messages</code> property:</p><div><pre class="programlisting">App.io.on('chat', function(data) {
  self.get('messages').pushObject(App.Message.create(data));
});</pre></div><p class="calibre7">The Socket.io <code class="email">.on</code> instance <a id="id541" class="calibre1"/>method is used to perform pull operations by subscribing to events emitted from the backend, as shown in the preceding three handlers. The <code class="email">.emit</code> method, on the other hand, is used to push data to the backend. In this case, we notify the server that a new user wishes to join the chat as:</p><div><pre class="programlisting">App.io.emit('ready', { nick: nick }, function(data) {
});</pre></div><p class="calibre7">The preceding call sends a <code class="email">ready</code> event to the backend alongside the nick. In the same way, the backend also sets up event handlers, the first of which listens to the <code class="email">ready</code> event:</p><div><pre class="programlisting">// server.js
app.io.route('ready', function(req) {
});</pre></div><p class="calibre7">The listener first checks to see if the nick has been taken by an existing user and whether an existing user has taken the nick:</p><div><pre class="programlisting">var success = nicks.indexOf(req.data.nick) === -1;</pre></div><p class="calibre7">If it has indeed been taken, we notify the user of this failure through another update:</p><div><pre class="programlisting">req.io.respond({
  success: success
});</pre></div><p class="calibre7">All that the client app needs to do is display the notice via the tooltip:</p><div><pre class="programlisting">if (data.success){
} else {
  self.send('tip', 'Nick is taken');
}</pre></div><p class="calibre7">However, if the nick is not taken, we first store the nick in <code class="email">session</code> for later reference:</p><div><pre class="programlisting">req.session.nick = req.data.nick;</pre></div><p class="calibre7">In a group <a id="id542" class="calibre1"/>chat application, we expect users already logged in to the chat to be notified when others join, as demonstrated by loading the app on different tabs. Therefore, when the user connects, we first add an appropriate message to the message store:</p><div><pre class="programlisting">var message = {
  isjoin: true,
  nick: req.data.nick,
  message: req.data.nick+' joined',
  date: (new Date).toISOString()
};
messages.push(message);</pre></div><p class="calibre7">We then <em class="calibre9">broadcast</em> this event to the other logged-in users:</p><div><pre class="programlisting">req.io.broadcast('join', req.data);
req.io.broadcast('chat', message);</pre></div><p class="calibre7">Socket.io provides a means of sending events to all active connections, except the current connection, via the <code class="email">.broadcast</code> method. The preceding broadcast events result in the user being added to the nick listing to the right-hand side of the client application, along with the accompanying join notice:</p><div><pre class="programlisting">&lt;ul class="nicks"&gt;
  {{#each nicks}}
  &lt;li&gt; {{this}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">We finally notify the connecting user of the successful connection using the <code class="email">respond</code> method:</p><div><pre class="programlisting">req.io.respond({
  success: success,
  nicks: nicks,
  messages: messages.slice(0, -1) });</pre></div><p class="calibre7">In addition, we send them a list of the currently logged-in users, as well as the five most recent messages. Once connected, we clear the message field and populate the <code class="email">users</code> and <code class="email">nicks</code> collections as:</p><div><pre class="programlisting">self.set('message', '');
self.set('connected', true);
self.set('nick', nick);
self.get('nicks').pushObjects(data.nicks);
self.get('messages').pushObjects(data.messages.map(function(data){
  var message = App.Message.create(data);
  if (message.get('nick') === nick) message.set('isme', true);
  return message;
}));</pre></div><p class="calibre7">When<a id="id543" class="calibre1"/> messages stream in, we make the bottom of the message list visible to the viewport by use of an observer:</p><div><pre class="programlisting">  messagesLengthDidChange: function(){
    Em.run.debounce(this, 'send', 'scrollToBottom', 200);
  }.observes('messages.length'),</pre></div><p class="calibre7">What this does is trigger the controller's <code class="email">scrollToBottom</code> action once in a window of 200 milliseconds, as shown:</p><div><pre class="programlisting">$('html, body')
  .animate({ scrollTop: $(document).height() }, 'slow');</pre></div><p class="calibre7">Once the user connects, the rest of the application visibility is enabled, thanks to bindings:</p><div><pre class="programlisting">&lt;div id="content" {{bind-attr class="connected:show"}}&gt;&lt;/div&gt;</pre></div><p class="calibre7">In this case, the message container element acquires the <code class="email">show</code> property, thereby resetting the opacity to <code class="email">1</code>:</p><div><pre class="programlisting">#title,
#content{
  opacity: 0.1;
}

#title.show,
#content.show{
  opacity: 1;
}</pre></div><p class="calibre7">Subsequent messages are relayed to the server and broadcasted to the other users via the chat action discussed:</p><div><pre class="programlisting">if (!nick) return self.send('tip', '/join &lt;nick&gt;');

var msg = App.Message.create({
  isme: true,
  message: message,
  nick: nick
});
self.get('messages').pushObject(msg);
App.io.emit('chat', msg.toJSON());
self.set('message', '');</pre></div><p class="calibre7">Again, on the backend, we subscribe to this event and relay the message to the other users:</p><div><pre class="programlisting">app.io.route('chat', function(req) {
  messages.push(req.data);
  req.io.broadcast('chat', req.data);
});
In the client app, conveniently use a table, for convenience, to list the messages:
{{#each messages}}
&lt;tr {{bind-attr class="isnotice:notice isjoin:join isquit:quit isme:me"}}&gt;
  &lt;td {{bind-attr class=":nick"}}&gt;
    &lt;span&gt;{{#if isme}}me{{else}}{{nick}}{{/if}}&lt;/span&gt;
  &lt;/td&gt;
  &lt;td class="message"&gt;
    &lt;span&gt;{{message}}&lt;/span&gt;
  &lt;/td&gt;
  &lt;td class="date" data-timestamp="{{timestamp}}"&gt;
    &lt;span&gt;{{message-date date=date}}&lt;/span&gt;
  &lt;/td&gt;
&lt;/tr&gt;
{{/each}}</pre></div><p class="calibre7">You <a id="id544" class="calibre1"/>will notice that we define a <code class="email">message-date</code> component that displays a message's date formatted with the aid of the Moment.js library:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/message-date"&gt;
  {{formatedDate}}
&lt;/script&gt;

App.MessageDateComponent = Ember.Component.extend({

  tagName: 'span',

  didInsertElement: function(){

    var self = this;


    var id = setInterval(fn, 15000);
    this.set('intervalId', id);
    fn();
    function fn(){
      self.set(
'formatedDate', moment((new Date(self.get('date')))).fromNow()
     );
    }

  },

  willDestroyElement: function(){
    clearInterval(this.get('intervalId'));
  }

});</pre></div><p class="calibre7">In<a id="id545" class="calibre1"/> line with a better real-time experience, the component updates the formatted date every 15 seconds to illustrate aging.</p><p class="calibre7">Finally, when the user disconnects, we remove their handle from the <code class="email">nicks</code> collection and notify the rest of the users:</p><div><pre class="programlisting">app.io.route('disconnect', function(req) {

  var nick = req.session.nick;
  if (!nick) return;

  var message = {
    isquit: true,
    nick: nick,
    message: nick+' quit',
    date: (new Date).toISOString()
  };
  messages.push(message);

  var index = nicks.indexOf(nick);
  if (index &gt; -1) {
    nicks.splice(index, 1);
  }

  req.io.broadcast('chat', message);
  req.io.broadcast('quit', {
    nick: nick
  });

});</pre></div><p class="calibre7">You will notice that we referenced the saved user's handle from <code class="email">session</code>.</p><p class="calibre7">There are a few <a id="id546" class="calibre1"/>improvements that can be made to the application, such as multichannel, emoticon, and user-avatar support, among others.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec111" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This was a short introduction to building Ember.js applications that integrate with aiding real-time web technologies. It demonstrated how easy it is to use the third-party library without spending too much time making trivial choices. We learned how to initialize the Socket.io library and subscribe and emit updates to and from the server. In the next chapter, we will learn how to componentize our applications into reusable components.</p></div></body></html>