<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Creational Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Creational Design Patterns</h1></div></div></div><p>Creational design patterns in object-oriented programming are design patterns that are to be applied during the instantiation of objects. In this chapter, we'll be talking about patterns in this category.</p><p>Consider we are building a rocket, which has payload and one or more stages:</p><pre class="programlisting">class Payload { &#13;
  weight: number; &#13;
} &#13;
 &#13;
class Engine { &#13;
  thrust: number; &#13;
} &#13;
 &#13;
class Stage { &#13;
  engines: Engine[]; &#13;
} &#13;
</pre><p>In old-fashioned JavaScript, there are two major approaches to building such a rocket:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Constructor with <code class="literal">new</code> operator</li><li class="listitem" style="list-style-type: disc">Factory function</li></ul></div><p>For the first approach, things could be like this:</p><pre class="programlisting">function Rocket() { &#13;
  this.payload = { &#13;
    name: 'cargo ship' &#13;
  }; &#13;
   &#13;
  this.stages = [ &#13;
    { &#13;
      engines: [ &#13;
        // ... &#13;
      ] &#13;
    } &#13;
  ]; &#13;
} &#13;
 &#13;
var rocket = new Rocket(); &#13;
</pre><p>And for the second approach, it could be like this:</p><pre class="programlisting">function buildRocket() { &#13;
  var rocket = {}; &#13;
   &#13;
  rocket.payload = { &#13;
    name: 'cargo ship' &#13;
  }; &#13;
   &#13;
  rocket.stages = [ &#13;
    { &#13;
      thrusters: [ &#13;
        // ... &#13;
      ] &#13;
    } &#13;
  ]; &#13;
   &#13;
  return rocket; &#13;
} &#13;
 &#13;
var rocket = buildRocket(); &#13;
</pre><p>From a certain angle, they are doing pretty much the same thing, but semantically they differ a lot. The constructor approach suggests a strong association between the building process and the final product. The factory function, on the other hand, implies an interface of its product and claims the ability to build such a product.</p><p>However, neither of the preceding implementations provides the flexibility to modularly assemble rockets based on specific needs; this is what creational design patterns are about.</p><p>In this chapter, we'll cover the following creational patterns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Factory method</strong></span>: By using abstract methods of a factory instead of the constructor to build instances, this allows subclasses to change what's built by implementing or overriding these methods.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract factory</strong></span>: Defining the interface of compatible factories and their <span class="emphasis"><em>products</em></span>. Thus by changing the factory passed, we can change the family of built products.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Builder</strong></span>: Defining the <span class="emphasis"><em>steps</em></span> of building complex objects, and changing what's built either by changing the sequence of steps, or using a different builder implementation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Prototype</strong></span>: Creating objects by cloning parameterized prototypes. Thus by replacing these prototypes, we may build different products.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singleton</strong></span>: Ensuring only one instance (under a certain scope) will be created.</li></ul></div><p>It is interesting to see that even though the factory function approach to creating objects in JavaScript looks primitive, it does have parts in common with some patterns we are going to talk about (although applied to different scopes).</p><div class="section" title="Factory method"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Factory method</h1></div></div></div><p>Under some scenarios, a class cannot predict exactly what objects it will create, or its subclasses may want to create more specified versions of these objects. Then, the Factory Method Pattern can be applied.</p><p>The following picture shows the possible structure of the Factory Method Pattern applied to creating rockets:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="Factory method"/></div><p>
</p><p>A <span class="strong"><strong>factory method</strong></span> is a method of a factory that builds objects. Take building rockets as an example; a factory method could be a method that builds either the entire rocket or a single component. One factory method might rely on other factory methods to build its target object. For example, if we have a <code class="literal">createRocket</code> method under the <code class="literal">Rocket</code> class, it would probably call factory methods like <code class="literal">createStages</code> and <code class="literal">createPayload</code> to get the necessary components.</p><p>The Factory Method Pattern provides some flexibility upon reasonable complexity. It allows extendable usage by implementing (or overriding) specific factory methods. Taking <code class="literal">createStages</code> method, for example, we can create a one-stage rocket or a two-stage rocket by providing different <code class="literal">createStages</code> method that return one or two stages respectively.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Participants</h2></div></div></div><p>The participants of a typical Factory Method Pattern implementation include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Product: <code class="literal">Rocket</code></li></ul></div><p>Define an abstract class or an interface of a rocket that will be created as the product.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Concrete product: <code class="literal">FreightRocket</code></li></ul></div><p>Implement a specific rocket product.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creator: <code class="literal">RocketFactory</code></li></ul></div><p>Define the optionally abstract factory class that creates products.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Concrete creator: <code class="literal">FreightRocketFactory</code></li></ul></div><p>Implement or overrides specific factory methods to build products on demand.</p></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Pattern scope</h2></div></div></div><p>The Factory Method Pattern decouples <code class="literal">Rocket</code> from the constructor implementation and makes it possible for subclasses of a factory to change what's built accordingly. A concrete creator still cares about what exactly its components are and how they are built. But the implementation or overriding usually focuses more on each component, rather than the entire product.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Implementation</h2></div></div></div><p>Let's begin with building a simple one-stage rocket that carries a 0-weight payload as the default implementation:</p><pre class="programlisting">class RocketFactory { &#13;
  buildRocket(): Rocket { } &#13;
   &#13;
  createPayload(): Payload { } &#13;
   &#13;
  createStages(): Stage[] { } &#13;
} &#13;
</pre><p>We start with creating components. We will simply return a payload with 0 weight for the factory method <code class="literal">createPayload</code> and one single stage with one single engine for the factory method <code class="literal">createStages</code>:</p><pre class="programlisting">createPayload(): Payload { &#13;
  return new Payload(0); &#13;
} &#13;
 &#13;
createStages(): Stage[] { &#13;
  let engine = new Engine(1000); &#13;
  let stage = new Stage([engine]); &#13;
   &#13;
  return [stage]; &#13;
} &#13;
</pre><p>After implementing methods to create the components of a rocket, we are going to put them together with the factory method <code class="literal">buildRocket</code>:</p><pre class="programlisting">buildRocket(): Rocket { &#13;
  let rocket = new Rocket(); &#13;
   &#13;
  let payload = this.createPayload(); &#13;
  let stages = this.createStages(); &#13;
   &#13;
  rocket.payload = payload; &#13;
  rocket.stages = stages; &#13;
   &#13;
  return rocket; &#13;
} &#13;
</pre><p>Now we have the blueprint of a simple rocket factory, yet with certain extensibilities. To build a rocket (that does nothing so far), we just need to instantiate this very factory and call its <code class="literal">buildRocket</code> method:</p><pre class="programlisting">let rocketFactory = new RocketFactory(); &#13;
let rocket = rocketFactory.buildRocket(); &#13;
</pre><p>Next, we are going to build two-stage freight rockets that send satellites into orbit. Thus, there are some differences compared to the basic factory implementation.</p><p>First, we have a different payload, satellites, instead of a 0-weight placeholder:</p><pre class="programlisting">class Satellite extends Payload { &#13;
  constructor( &#13;
    public id: number &#13;
  ) { &#13;
    super(200); &#13;
  } &#13;
} &#13;
</pre><p>Second, we now have two stages, probably with different specifications. The first stage is going to have four engines:</p><pre class="programlisting">class FirstStage extends Stage { &#13;
  constructor() { &#13;
    super([ &#13;
      new Engine(1000), &#13;
      new Engine(1000), &#13;
      new Engine(1000), &#13;
      new Engine(1000) &#13;
    ]); &#13;
  } &#13;
} &#13;
</pre><p>While the second stage has only one:</p><pre class="programlisting">class SecondStage extends Stage { &#13;
  constructor() { &#13;
    super([ &#13;
      new Engine(1000) &#13;
    ]); &#13;
  } &#13;
} &#13;
</pre><p>Now we have what this new freight rocket would look like in mind, let's extend the factory:</p><pre class="programlisting">type FreightRocketStages = [FirstStage, SecondStage]; &#13;
 &#13;
class FreightRocketFactory extends RocketFactory { &#13;
  createPayload(): Satellite { } &#13;
   &#13;
  createStages(): FreightRocketStages { } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Here we are using the <span class="emphasis"><em>type alias</em></span> of a <span class="emphasis"><em>tuple</em></span> to represent the stages sequence of a freight rocket, namely the first and second stages. To find out more about type aliases, please refer to <a class="ulink" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>.</p></div></div><p>As we added the <code class="literal">id</code> property to <code class="literal">Satellite</code>, we might need a counter for each instance of the factory, and then create every satellite with a unique ID:</p><pre class="programlisting">nextSatelliteId = 0; &#13;
 &#13;
createPayload(): Satellite { &#13;
  return new Satellite(this.nextSatelliteId++); &#13;
} &#13;
</pre><p>Let's move on and implement the <code class="literal">createStages</code> method that builds first and second stage of the rocket:</p><pre class="programlisting">createStages(): FreightRocketStages { &#13;
  return [ &#13;
    new FirstStage(), &#13;
    new SecondStage() &#13;
  ]; &#13;
} &#13;
</pre><p>Comparing to the original implementation, you may have noticed that we've automatically decoupled specific stage building processes from assembling them into constructors of different stages. It is also possible to apply another creational pattern for the initiation of every stage if it helps.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Consequences</h2></div></div></div><p>In the preceding implementation, the factory method <code class="literal">buildRocket</code> handles the outline of the building steps. We were lucky to have the freight rocket in the same structure as the very first rocket we had defined.</p><p>But that won't always happen. If we want to change the class of products (<code class="literal">Rocket</code>), we'll have to override the entire <code class="literal">buildRocket</code> with everything else but the class name. This looks frustrating but it can be solved, again, by decoupling the creation of a rocket instance from the building process:</p><pre class="programlisting">buildRocket(): Rocket { &#13;
  <span class="strong"><strong>let rocket = this.createRocket();</strong></span> &#13;
   &#13;
  let payload = this.createPayload(); &#13;
  let stages = this.createStages(); &#13;
   &#13;
  rocket.payload = payload; &#13;
  rocket.stages = stages; &#13;
   &#13;
  return rocket; &#13;
} &#13;
 &#13;
<span class="strong"><strong>createRocket(): Rocket { &#13;
  return new Rocket();</strong></span> &#13;
} &#13;
</pre><p>Thus we can change the rocket class by overriding the <code class="literal">createRocket</code> method. However, the return type of the <code class="literal">buildRocket</code> of a subclass (for example, <code class="literal">FreightRocketFactory</code>) is still <code class="literal">Rocket</code> instead of something like <code class="literal">FreightRocket</code>. But as the object created is actually an instance of <code class="literal">FreightRocket</code>, it is valid to cast the type by type assertion:</p><pre class="programlisting">let rocket = FreightRocketFactory.buildRocket() as FreightRocket; &#13;
</pre><p>The trade-off is a little type safety, but that can be eliminated using generics. Unfortunately, in TypeScript what you get from a generic type argument is just a type without an actual value. This means that we may need another level of abstraction or other patterns that can use the help of type inference to make sure of everything.</p><p>The former option would lead us to the Abstract Factory Pattern.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Type safety could be one reason to consider when choosing a pattern but usually, it will not be decisive. Please note we are not trying to switch a pattern for this single reason, but just exploring.</p></div></div></div></div></div>
<div class="section" title="Abstract Factory"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Abstract Factory</h1></div></div></div><p>The Abstract Factory Pattern usually defines the interfaces of a collection of factory methods, without specifying concrete products. This allows an entire factory to be replaceable, in order to produce different products following the same production outline:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="Abstract Factory"/></div><p>
</p><p>The details of the products (components) are omitted from the diagram, but do notice that these products belong to two parallel families: <code class="literal">ExperimentalRocket</code> and <code class="literal">FreightRocket</code>.</p><p>Different from the Factory Method Pattern, the Abstract Factory Pattern extracts another part called <span class="strong"><strong>client</strong></span> that take cares of shaping the outline of the building process. This makes the factory part focused more on producing each component.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Participants</h2></div></div></div><p>The participants of a typical Abstract Factory Pattern implementation include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract factory</strong></span>: <code class="literal">RocketFactory</code></li></ul></div><p>Defines the <span class="emphasis"><em>industrial standards</em></span> of a factory which provide interfaces for manufacturing components or complex products.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete factory</strong></span>: <code class="literal">ExperimentalRocketFactory</code>, <code class="literal">FreightRocketFactory</code></li></ul></div><p>Implements the interfaces defined by the abstract factory and builds concrete products.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract products</strong></span>: <code class="literal">Rocket</code>, <code class="literal">Payload</code>, <code class="literal">Stage[]</code></li></ul></div><p>Define the interfaces of the products the factories are going to build.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete products</strong></span>: <code class="literal">ExperimentalRocket</code>/<code class="literal">FreightRocket</code>, <code class="literal">ExperimentalPayload</code>/<code class="literal">Satellite</code>, and so on.</li></ul></div><p>Presents actual products that are manufactured by a concrete factory.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>:</li></ul></div><p>Arranges the production process across factories (only if these factories conform to <span class="emphasis"><em>industrial standards</em></span>).</p></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Pattern scope</h2></div></div></div><p>Abstract Factory Pattern makes the abstraction on top of different concrete factories. At the scope of a single factory or a single branch of factories, it just works like the Factory Method Pattern. However, the highlight of this pattern is to make a whole family of products interchangeable. A good example could be components of themes for a UI implementation.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Implementation</h2></div></div></div><p>In the Abstract Factory Pattern, it is the client interacting with a concrete factory for building integral products. However, the concrete class of products is decoupled from the client during design time, while the client cares only about what a factory and its products look like instead of what exactly they are.</p><p>Let's start by simplifying related classes to interfaces:</p><pre class="programlisting">interface Payload { &#13;
  weight: number; &#13;
} &#13;
 &#13;
interface Stage { &#13;
  engines: Engine[]; &#13;
} &#13;
 &#13;
interface Rocket { &#13;
  payload: Payload; &#13;
  stages: Stage[]; &#13;
} &#13;
</pre><p>And of course the abstract factory itself is:</p><pre class="programlisting">interface RocketFactory { &#13;
  createRocket(): Rocket; &#13;
  createPayload(): Payload; &#13;
  createStages(): Stage[]; &#13;
} &#13;
</pre><p>The building steps are abstracted from the factory and put into the client, but we still need to implement it anyway:</p><pre class="programlisting">class Client { &#13;
  buildRocket(factory: RocketFactory): Rocket { &#13;
    let rocket = factory.createRocket(); &#13;
     &#13;
    rocket.payload = factory.createPayload(); &#13;
    rocket.stages = factory.createStages(); &#13;
     &#13;
    return rocket; &#13;
  } &#13;
} &#13;
</pre><p>Now we have the same issue we previously had when we implemented the Factory Method Pattern. As different concrete factories build different rockets, the class of the product changes. However, now we have generics to the rescue.</p><p>First, we need a <code class="literal">RocketFactory</code>  interface with a generic type parameter that describes a concrete rocket class:</p><pre class="programlisting">interface <span class="strong"><strong>RocketFactory&lt;T extends Rocket&gt; {</strong></span> &#13;
  createRocket(): T; &#13;
  createPayload(): Payload; &#13;
  createStages(): Stage[]; &#13;
} &#13;
</pre><p>And second, update the <code class="literal">buildRocket</code> method of the client to support generic factories:</p><pre class="programlisting">  buildRocket&lt;T extends Rocket&gt;( &#13;
    factory: RocketFactory&lt;T&gt; &#13;
  ): T { } &#13;
</pre><p>Thus, with the help of the type system, we will have rocket type inferred based on the type of a concrete factory, starting with <code class="literal">ExperimentalRocket</code> and <code class="literal">ExperimentalRocketFactory</code>:</p><pre class="programlisting">class ExperimentalRocket implements Rocket { } &#13;
 &#13;
class ExperimentalRocketFactory &#13;
implements RocketFactory&lt;ExperimentalRocket&gt; { } &#13;
</pre><p>If we call the <code class="literal">buildRocket</code> method of a client with an instance of <code class="literal">ExperimentalRocketFactory</code>, the return type will automatically be <code class="literal">ExperimentalRocket</code>:</p><pre class="programlisting">let client = new Client(); &#13;
let factory = new ExperimentalRocketFactory(); &#13;
let rocket = client.buildRocket(factory); &#13;
</pre><p>Before we can complete the implementation of the <code class="literal">ExperimentalRocketFactory</code> object, we need to define concrete classes for the products of the family:</p><pre class="programlisting">class ExperimentalPayload implements Payload { &#13;
  weight: number; &#13;
} &#13;
 &#13;
class ExperimentalRocketStage implements Stage { &#13;
  engines: Engine[]; &#13;
} &#13;
 &#13;
class ExperimentalRocket implements Rocket { &#13;
  payload: ExperimentalPayload; &#13;
  stages: [ExperimentalRocketStage]; &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Trivial initializations of payload and stage are omitted for more compact content. The same kinds of omission may be applied if they are not necessary for this book.</p></div></div><p>And now we may define the factory methods of this concrete factory class:</p><pre class="programlisting">class ExperimentalRocketFactory &#13;
implements RocketFactory&lt;ExperimentalRocket&gt; { &#13;
  createRocket(): ExperimentalRocket { &#13;
    return new ExperimentalRocket(); &#13;
  } &#13;
   &#13;
  createPayload(): ExperimentalPayload { &#13;
    return new ExperimentalPayload(); &#13;
  } &#13;
   &#13;
  createStages(): [ExperimentalRocketStage] { &#13;
    return [new ExperimentalRocketStage()]; &#13;
  } &#13;
} &#13;
</pre><p>Let's move on to another concrete factory that builds a freight rocket and products of its family, starting with the rocket components:</p><pre class="programlisting">class Satellite implements Payload { &#13;
  constructor( &#13;
    public id: number, &#13;
    public weight: number &#13;
  ) { } &#13;
} &#13;
 &#13;
class FreightRocketFirstStage implements Stage { &#13;
  engines: Engine[]; &#13;
} &#13;
 &#13;
class FreightRocketSecondStage implements Stage { &#13;
  engines: Engine[]; &#13;
} &#13;
 &#13;
type FreightRocketStages = &#13;
  [FreightRocketFirstStage, FreightRocketSecondStage]; &#13;
</pre><p>Continue with the rocket itself:</p><pre class="programlisting">class FreightRocket implements Rocket { &#13;
  payload: Satellite; &#13;
  stages: FreightRocketStages; &#13;
} &#13;
</pre><p>With the structures or classes of the freight rocket family defined, we are ready to implement its factory:</p><pre class="programlisting">class FreightRocketFactory &#13;
implements RocketFactory&lt;FreightRocket&gt; { &#13;
  nextSatelliteId = 0; &#13;
   &#13;
  createRocket(): FreightRocket { &#13;
    return new FreightRocket(); &#13;
  } &#13;
   &#13;
  createPayload(): Satellite { &#13;
    return new Satellite(this.nextSatelliteId++, 100); &#13;
  } &#13;
   &#13;
  createStages(): FreightRocketStages { &#13;
    return [ &#13;
      new FreightRocketFirstStage(), &#13;
      new FreightRocketSecondStage() &#13;
    ]; &#13;
  } &#13;
} &#13;
</pre><p>Now we once again have two families of rockets and their factories, and we can use the same client to build different rockets by passing different factories:</p><pre class="programlisting">let client = new Client(); &#13;
 &#13;
let experimentalRocketFactory = new ExperimentalRocketFactory(); &#13;
let freightRocketFactory = new FreightRocketFactory(); &#13;
 &#13;
let experimentalRocket = &#13;
  client.buildRocket(experimentalRocketFactory); &#13;
 &#13;
let freightRocket = client.buildRocket(freightRocketFactory); &#13;
</pre></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Consequences</h2></div></div></div><p>The Abstract Factory Pattern makes it easy and smooth to change the entire family of products. This is the direct benefit brought by the factory level abstraction. As a consequence, it also brings other benefits, as well as some disadvantages at the same time.</p><p>On the one hand, it provides better compatibility within the products in a specific family. As the products built by a single factory are usually meant to work together, we can assume that they tend to cooperate more easily.</p><p>But on the other hand, it relies on a common outline of the building process, although for a well-abstracted building process, this won't always be an issue. We can also parameterize factory methods on both concrete factories and the client to make the process more flexible.</p><p>Of course, an abstract factory does not have to be a pure interface or an abstract class with no methods implemented. An implementation in practice should be decided based on detailed context.</p><p>Although the Abstract Factory Pattern and Factory Method Pattern have abstractions of different levels, what they encapsulate are similar. For building a product with multiple components, the factories split the products into components to gain flexibility. However, a fixed family of products and their internal components may not always satisfy the requirements, and thus we may consider the Builder Pattern as another option.</p></div></div>
<div class="section" title="Builder"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Builder</h1></div></div></div><p>While Factory Patterns expose the internal components (such as the payload and stages of a rocket), the Builder Pattern encapsulates them by exposing only the building steps and provides the final products directly. At the same time, the Builder Pattern also encapsulates the internal structures of a product. This makes it possible for a more flexible abstraction and implementation of building complex objects.</p><p>The Builder Pattern also introduces a new role called <span class="strong"><strong>director</strong></span>, as shown in the following diagram. It is quite like the client in the Abstract Factory Pattern, although it cares only about build steps or pipelines:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="Builder"/></div><p>
</p><p>Now the only constraint from <code class="literal">RocketBuilder</code> that applies to a product of its subclass is the overall shape of a <code class="literal">Rocket</code>. This might not bring a lot of benefits with the <code class="literal">Rocket</code> interface we previously defined, which exposes some details of the rocket that the clients (by clients I mean those who want to send their satellites or other kinds of payload to space) may not care about that much. For these clients, what they want to know might just be which orbit the rocket is capable of sending their payloads to, rather than how many and what stages this rocket has.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Participants</h2></div></div></div><p>The participants of a typical Builder Pattern implementation include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Builder</strong></span>: <code class="literal">RocketBuilder</code></li></ul></div><p>Defines the interface of a builder that builds products.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete builder</strong></span>: <code class="literal">FalconBuilder</code></li></ul></div><p>Implements methods that build parts of the products, and keeps track of the current building state.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Director</strong></span></li></ul></div><p>Defines the steps and collaborates with builders to build products.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Final product</strong></span>: <code class="literal">Falcon</code></li></ul></div><p>The product built by a builder.</p></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Pattern scope</h2></div></div></div><p>The Builder Pattern has a similar scope to the Abstract Factory Pattern, which extracts abstraction from a complete collection of operations that will finally initiate the products. Compared to the Abstract Factory Pattern, a builder in the Builder Pattern focuses more on the building steps and the association between those steps, while the Abstract Factory Pattern puts that part into the clients and makes its factory focus on producing components.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Implementation</h2></div></div></div><p>As now we are assuming that stages are not the concern of the clients who want to buy rockets to carry their payloads, we can remove the <code class="literal">stages</code> property from the general <code class="literal">Rocket</code> interface:</p><pre class="programlisting">interface Rocket { &#13;
  payload: Payload; &#13;
} &#13;
</pre><p>There is a rocket family called sounding rocket that sends probes to near space. And this means we don't even need to have the concept of stages. <code class="literal">SoundingRocket</code> is going to have only one <code class="literal">engine</code> property other than <code class="literal">payload</code> (which will be a <code class="literal">Probe</code>), and the only engine will be a <code class="literal">SolidRocketEngine</code>:</p><pre class="programlisting">class Probe implements Payload { &#13;
  weight: number; &#13;
} &#13;
 &#13;
class SolidRocketEngine extends Engine { } &#13;
 &#13;
class SoundingRocket implements Rocket { &#13;
  payload: Probe; &#13;
  engine: SolidRocketEngine; &#13;
} &#13;
</pre><p>But still we need rockets to send satellites, which usually use <code class="literal">LiquidRocketEngine</code>:</p><pre class="programlisting">class LiquidRocketEngine extends Engine { &#13;
  fuelLevel = 0; &#13;
   &#13;
  refuel(level: number): void { &#13;
    this.fuelLevel = level; &#13;
  } &#13;
} &#13;
</pre><p>And we might want to have the corresponding  <code class="literal">LiquidRocketStage</code> abstract class that handles refuelling:</p><pre class="programlisting">abstract class LiquidRocketStage implements Stage { &#13;
  engines: LiquidRocketEngine[] = []; &#13;
   &#13;
  refuel(level = 100): void { &#13;
    for (let engine of this.engines) { &#13;
      engine.refuel(level); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Now we can update  <code class="literal">FreightRocketFirstStage</code> and <code class="literal">FreightRocketSecondStage</code> as subclasses of <code class="literal">LiquidRocketStage</code>:</p><pre class="programlisting">class FreightRocketFirstStage extends LiquidRocketStage { &#13;
  constructor(thrust: number) { &#13;
    super(); &#13;
     &#13;
    let enginesNumber = 4; &#13;
    let singleEngineThrust = thrust / enginesNumber; &#13;
     &#13;
    for (let i = 0; i &lt; enginesNumber; i++) { &#13;
      let engine = &#13;
        new LiquidRocketEngine(singleEngineThrust); &#13;
      this.engines.push(engine); &#13;
    } &#13;
  } &#13;
} &#13;
 &#13;
class FreightRocketSecondStage extends LiquidRocketStage { &#13;
  constructor(thrust: number) { &#13;
    super(); &#13;
    this.engines.push(new LiquidRocketEngine(thrust)); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">FreightRocket</code> will remain the same as it was:</p><pre class="programlisting">type FreightRocketStages = &#13;
  [FreightRocketFirstStage, FreightRocketSecondStage]; &#13;
 &#13;
class FreightRocket implements Rocket { &#13;
  payload: Satellite; &#13;
  stages = [] as FreightRocketStages; &#13;
} &#13;
</pre><p>And, of course, there is the builder. This time, we are going to use an abstract class that has the builder partially implemented, with generics applied:</p><pre class="programlisting">abstract class RocketBuilder&lt; &#13;
  TRocket extends Rocket, &#13;
  TPayload extends Payload &#13;
&gt; { &#13;
  createRocket(): void { } &#13;
   &#13;
  addPayload(payload: TPayload): void { } &#13;
   &#13;
  addStages(): void { } &#13;
   &#13;
  refuelRocket(): void { } &#13;
   &#13;
  abstract get rocket(): TRocket; &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>There's actually no abstract method in this abstract class. One of the reasons is that specific steps might be optional to certain builders. By implementing no-op methods, the subclasses can just leave the steps they don't care about empty.</p></div></div><p>Here is the implementation of the <code class="literal">Director</code> class:</p><pre class="programlisting">class Director { &#13;
  prepareRocket&lt; &#13;
    TRocket extends Rocket, &#13;
    TPayload extends Payload &#13;
  &gt;( &#13;
    builder: RocketBuilder&lt;TRocket, TPayload&gt;, &#13;
    payload: TPayload &#13;
  ): TRocket { &#13;
    builder.createRocket(); &#13;
    builder.addPayload(payload); &#13;
    builder.addStages(); &#13;
    builder.refuelRocket(); &#13;
    return builder.rocket; &#13;
  } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Be cautious, without explicitly providing a building context, the builder instance relies on the building pipelines being queued (either synchronously or asynchronously). One way to avoid risk (especially with asynchronous operations) is to initialize a builder instance every time you prepare a rocket.</p></div></div><p>Now it's time to implement concrete builders, starting with <code class="literal">SoundingRocketBuilder</code>, which builds a <code class="literal">SoundingRocket</code> with only one <code class="literal">SolidRocketEngine</code>:</p><pre class="programlisting">class SoundingRocketBuilder &#13;
extends RocketBuilder&lt;SoundingRocket, Probe&gt; { &#13;
  private buildingRocket: SoundingRocket; &#13;
   &#13;
  createRocket(): void { &#13;
    this.buildingRocket = new SoundingRocket(); &#13;
  } &#13;
   &#13;
  addPayload(probe: Probe): void { &#13;
    this.buildingRocket.payload = probe; &#13;
  } &#13;
   &#13;
  addStages(): void { &#13;
    let payload = this.buildingRocket.payload; &#13;
    this.buildingRocket.engine = &#13;
      new SolidRocketEngine(payload.weight); &#13;
  } &#13;
   &#13;
  get rocket(): SoundingRocket { &#13;
    return this.buildingRocket; &#13;
  } &#13;
} &#13;
</pre><p>There are several notable things in this implementation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> addStages</code> method relies on the previously added payload to add an engine with the correct thrust specification.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> refuel</code> method is not overridden (so it remains no-op) because a solid rocket engine does not need to be refueled.</li></ul></div><p>We've sensed a little about the context provided by a builder, and it could have a significant influence on the result. For example, let's take a look at <code class="literal">FreightRocketBuilder</code>. It could be similar to <code class="literal">SoundingRocket</code> if we don't take the <code class="literal">addStages</code> and <code class="literal">refuel</code> methods into consideration:</p><pre class="programlisting">class FreightRocketBuilder &#13;
extends RocketBuilder&lt;FreightRocket, Satellite&gt; { &#13;
  private buildingRocket: FreightRocket; &#13;
   &#13;
  createRocket(): void { &#13;
    this.buildingRocket = new FreightRocket(); &#13;
  } &#13;
   &#13;
  addPayload(satellite: Satellite): void { &#13;
    this.buildingRocket.payload = satellite; &#13;
  } &#13;
   &#13;
  get rocket(): FreightRocket { &#13;
    return this.buildingRocket; &#13;
  } &#13;
} &#13;
</pre><p>Assume that a payload that weighs less than <code class="literal">1000</code> takes only one stage to send into space, while payloads weighing more take two or more stages:</p><pre class="programlisting">addStages(): void { &#13;
  let rocket = this.buildingRocket; &#13;
  let payload = rocket.payload; &#13;
  let stages = rocket.stages; &#13;
   &#13;
  stages[0] = new FreightRocketFirstStage(payload.weight * 4); &#13;
   &#13;
  if (payload.weight &gt;= FreightRocketBuilder.oneStageMax) { &#13;
    stages[1] = FreightRocketSecondStage(payload.weight); &#13;
  } &#13;
} &#13;
 &#13;
static oneStageMax = 1000; &#13;
</pre><p>When it comes to refueling, we can even decide how much to refuel based on the weight of the payloads:</p><pre class="programlisting">refuel(): void { &#13;
  let rocket = this.buildingRocket; &#13;
  let payload = rocket.payload; &#13;
  let stages = rocket.stages; &#13;
   &#13;
  let oneMax = FreightRocketBuilder.oneStageMax; &#13;
  let twoMax = FreightRocketBuilder.twoStagesMax; &#13;
   &#13;
  let weight = payload.weight; &#13;
   &#13;
  stages[0].refuel(Math.min(weight, oneMax) / oneMax * 100); &#13;
   &#13;
  if (weight &gt;= oneMax) { &#13;
    stages[1] &#13;
      .refuel((weight - oneMax) / (twoMax - oneMax) * 100); &#13;
  } &#13;
} &#13;
 &#13;
static oneStageMax = 1000; &#13;
static twoStagesMax = 2000; &#13;
</pre><p>Now we can prepare different rockets ready to launch, with different builders:</p><pre class="programlisting">let director = new Director(); &#13;
 &#13;
let soundingRocketBuilder = new SoundingRocketBuilder(); &#13;
let probe = new Probe(); &#13;
let soundingRocket &#13;
  = director.prepareRocket(soundingRocketBuilder, probe); &#13;
 &#13;
let freightRocketBuilder = new FreightRocketBuilder(); &#13;
let satellite = new Satellite(0, 1200); &#13;
let freightRocket &#13;
  = director.prepareRocket(freightRocketBuilder, satellite); &#13;
</pre></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Consequences</h2></div></div></div><p>As the Builder Pattern takes greater control of the product structures and how the building steps influence each other, it provides the maximum flexibility by subclassing the builder itself, without changing the director (which plays a similar role to a client in the Abstract Factory Pattern).</p></div></div>
<div class="section" title="Prototype"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Prototype</h1></div></div></div><p>As JavaScript is a prototype-based programming language, you might be using prototype related patterns all the time without knowing it.</p><p>We've talked about an example in the Abstract Factory Pattern, and part of the code is like this:</p><pre class="programlisting">class FreightRocketFactory &#13;
implements RocketFactory&lt;FreightRocket&gt; { &#13;
  createRocket(): FreightRocket { &#13;
    return new FreightRocket(); &#13;
  } &#13;
} &#13;
</pre><p>Sometimes we may need to add a subclass just for changing the class name while performing the same <code class="literal">new</code> operation. Instances of a single class usually share the same methods and properties, so we can <code class="literal">clone</code> one existing instance for new instances to be created. That is the concept of a prototype.</p><p>But in JavaScript, with the prototype concept built-in, <code class="literal">new Constructor()</code> does basically what a <code class="literal">clone</code> method would do. So actually a constructor can play the role of a concrete factory in some way:</p><pre class="programlisting">interface Constructor&lt;T&gt; { &#13;
  new (): T; &#13;
} &#13;
 &#13;
function createFancyObject&lt;T&gt;(constructor: Constructor&lt;T&gt;): T { &#13;
  return new constructor(); &#13;
} &#13;
</pre><p>With this privilege, we can parameterize product or component classes as part of other patterns and make creation even more flexible.</p><p>There is something that could easily be ignored when talking about the Prototype Pattern in JavaScript: cloning with the state. With the <code class="literal">class</code> syntax sugar introduced in ES6, which hides the prototype modifications, we may occasionally forget that we can actually modify prototypes directly:</p><pre class="programlisting">class Base { &#13;
  state: number; &#13;
} &#13;
 &#13;
let base = new Base(); &#13;
base.state = 0; &#13;
 &#13;
class Derived extends Base { } &#13;
Derived.prototype = base; &#13;
 &#13;
let derived = new Derived(); &#13;
</pre><p>Now, the <code class="literal">derived</code> object will keep the <code class="literal">state</code> of the <code class="literal">base</code> object. This could be useful when you want to create copies of a specific instance, but keep in mind that properties in a prototype of these copies are not the <span class="emphasis"><em>own properties</em></span> of these cloned objects.</p></div>
<div class="section" title="Singleton"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Singleton</h1></div></div></div><p>There are scenarios in which only one instance of the specific class should ever exist, and that leads to Singleton Pattern.</p><div class="section" title="Basic implementations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Basic implementations</h2></div></div></div><p>The simplest singleton in JavaScript is an object literal; it provides a quick and cheap way to create a unique object:</p><pre class="programlisting">const singleton = { &#13;
  foo(): void { &#13;
    console.log('bar'); &#13;
  } &#13;
}; &#13;
</pre><p>But sometimes we might want private variables:</p><pre class="programlisting">const singleton = (() =&gt; { &#13;
  let bar = 'bar'; &#13;
   &#13;
  return { &#13;
    foo(): void { &#13;
      console.log(bar); &#13;
    } &#13;
  }; &#13;
})(); &#13;
</pre><p>Or we want to take the advantage of an anonymous constructor function or class expression in ES6:</p><pre class="programlisting">const singleton = new class { &#13;
  private _bar = 'bar'; &#13;
   &#13;
  foo(): void { &#13;
    console.log(this._bar); &#13;
  } &#13;
} (); &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Remember that the <code class="literal">private</code> modifier only has an effect at compile time, and simply disappears after being compiled to JavaScript (although of course its accessibility will be kept in <code class="literal">.d.ts</code>).</p></div></div><p>However, it is possible to have the requirements for creating new instances of "singletons" sometimes. Thus a normal class will still be helpful:</p><pre class="programlisting">class Singleton { &#13;
  bar = 'bar'; &#13;
   &#13;
  foo(): void { &#13;
    console.log(bar); &#13;
  } &#13;
   &#13;
  private static _default: Singleton; &#13;
 &#13;
  static get default(): Singleton { &#13;
    if (!Singleton._default) { &#13;
      Singleton._default = new Singleton(); &#13;
    } &#13;
 &#13;
    return Singleton._default; &#13;
  } &#13;
} &#13;
</pre><p>Another benefit brought by this approach is lazy initialization: the object only gets initialized when it gets accessed the first time.</p></div><div class="section" title="Conditional singletons"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Conditional singletons</h2></div></div></div><p>Sometimes we might want to get "singletons" based on certain conditions. For example, every country usually has only one capital city, thus a capital city could be treated as a singleton under the scope of the specific country.</p><p>The condition could also be the result of context rather than explicit arguments. Assuming we have a class <code class="literal">Environment</code> and its derived classes, <code class="literal">WindowsEnvironment</code> and <code class="literal">UnixEnvironment</code>, we would like to access the correct environment singleton across platforms by using <code class="literal">Environment.default</code> and apparently, a selection could be made by the <code class="literal">default</code> getter.</p><p>For more complex scenarios, we might want a registration-based implementation to make it extendable.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we've talked about several important creational design patterns including the Factory Method, Abstract Factory, Builder, Prototype, and Singleton.</p><p>Starting with the Factory Method Pattern, which provides flexibility with limited complexity, we also explored the Abstract Factory Pattern, the Builder Pattern and the Prototype Pattern, which share similar levels of abstraction but focus on different aspects. These patterns have more flexibility than the Factory Method Pattern, but are more complex at the same time. With the knowledge of the idea behind each of the patterns, we should be able to choose and apply a pattern accordingly.</p><p>While comparing the differences, we also found many things in common between different creational patterns. These patterns are unlikely to be isolated from others and some of them can even collaborate with or complete each other.</p><p>In the next chapter, we'll continue to discuss structural patterns that help to form large objects with complex structures.</p></div></body></html>