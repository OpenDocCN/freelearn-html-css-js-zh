<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor134"/>5</h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor135"/>Adding Hooks and Lifecycle  Events to Your Models</h1>
<p>ORM typically provides a way for us to be able to transform states, or objects, throughout events that occur when executing certain operations. These methods are often referred to as hooks, lifecycle events, object lifecycles, or even callbacks (the latter is <em class="italic">not</em> often used within the Node.js community due to a nomenclature conflict against Node.js’ native environment). Usually, these methods have a temporal prefix (for example, <code>before</code> and <code>after</code>) preceding an event’s name. </p>
<p>There are no strict rules as to what an ORM requires as an event throughout its entire lifecycle. The events typically included within an ORM are called: validation, save, create, update, and destroy. Other ORM frameworks offer a wider scope of events or more granular control, such as before/after connecting to your database, defining your models, and calling a finder query.</p>
<p>Sequelize categorizes hooks into global and local hooks. Global hooks<a id="_idIndexMarker510"/> are for defining default lifecycle events for every model, enforce events (referred to as permanent hooks in Sequelize), and connection-related events. The local hooks<a id="_idIndexMarker511"/> entail lifecycle events defined on models for instances/records.</p>
<p>In this chapter, we will go over the following:</p>
<ul>
<li>The order of operations for lifecycle events</li>
<li>Defining, removing, and executing lifecycle events</li>
<li>Using lifecycle events with associations and transactions</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You can always reference Sequelize’s code base to maintain an up-to-date list of available lifecycle events here: <a href="https://sequelize.org/docs/v6/other-topics/hooks/">https://sequelize.org/docs/v6/other-topics/hooks/</a>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>You can find the code files for this chapter at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5">https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5</a>.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor137"/>Order of operations for lifecycle events</h1>
<p>Lifecycle events<a id="_idIndexMarker512"/> are an important feature when we want to introduce project-specific behaviors/constraints<a id="_idIndexMarker513"/> that extend beyond a database engine’s scope. Knowing the lifecycle events is only half of the equation, and the other half consists of knowing when those lifecycle events are triggered. </p>
<p>Suppose we were given the task to offer all of our products for free to employees. The first action could be adding a <code>beforeValidate</code> hook that would set the transaction’s subtotal to <code>0</code> if the user was an employee. That’s easy for us, but unfortunately a nightmare for the accounting department. A better approach would be to add an additional item that represents the employee discount, using the <code>beforeValidate</code> or <code>beforeCreate</code> hook.</p>
<p>The real answer in knowing which lifecycle events to use depends on the project’s requirements. From our previous example, some transactions require moving legal tender, which involves charging the employee and then providing a refund/credit as a separate transaction. In this case, we would not be able to use <code>beforeValidate</code> nor <code>beforeCreate</code>, but <code>afterCreate</code> could be applicable. Under the context of Sequelize, knowing where to place your code’s logic is knowing the order of operations for lifecycle events.</p>
<p>In Sequelize, lifecycle events follow the <code>before</code>/<code>after</code> preface style for hook names, like other ORM frameworks. All of Sequelize’s <em class="italic">connection</em> lifecycle events are defined on the <code>sequelize</code> object itself, and all of the <em class="italic">instance</em> event types are defined on models. The <em class="italic">model</em> event types can be defined in both areas. The exception to these rules is when we want to define an instance event for all of the models globally (examples will be provided in the following section). Here is a table listing lifecycle events in the order that they are executed along<a id="_idIndexMarker514"/> with a signature for the callback function: </p>
<p><strong class="bold">Hook definitions sorted by lifecycle execution</strong></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Event name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Event type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Requires sync*</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeConnect(config)</code></p>
<p><code>beforeDisconnect(connection)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeSync(options)</code></p>
<p><code>afterSync(options)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeBulkSync(options)</code></p>
<p><code>afterBulkSync(options)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeQuery(options, query)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeDefine(attributes, options)</code></p>
<p><code>afterDefine(factory)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection (Model)</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeInit(config, options)</code></p>
<p><code>afterInit(sequelize)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection (Model)</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeAssociate({ source, target, type }, options)</code></p>
<p><code>afterAssociate({ source, target, type, association }, options) </code></p>
</td>
<td class="No-Table-Style">
<p>Connection (Model)</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeBulkCreate(instances, options)</code></p>
<p><code>beforeBulkDestroy(options)</code></p>
<p><code>beforeBulkRestore(options)</code></p>
<p><code>beforeBulkUpdate(options)</code></p>
</td>
<td class="No-Table-Style">
<p>Model</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeValidate(instance, options)</code></p>
</td>
<td class="No-Table-Style">
<p>Instance</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>afterValidate(instance, options)</code></p>
<p><code>validationFailed(instance, options, error)</code></p>
</td>
<td class="No-Table-Style">
<p>Instance</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeCreate(instance, options)</code></p>
<p><code>beforeDestroy(instance, options)</code></p>
<p><code>beforeRestore(instance, options)</code></p>
<p><code>beforeUpdate(instance, options)</code></p>
<p><code>beforeSave(instance, options)</code></p>
<p><code>beforeUpsert(values, options)</code></p>
</td>
<td class="No-Table-Style">
<p>Instance</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>afterCreate(instance, options)</code></p>
<p><code>afterDestroy(instance, options)</code></p>
<p><code>afterRestore(instance, options)</code></p>
<p><code>afterUpdate(instance, options)</code></p>
<p><code>afterSave(instance, options)</code></p>
<p><code>afterUpsert(created, options)</code></p>
</td>
<td class="No-Table-Style">
<p>Instance</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>afterBulkCreate(instances, options)</code></p>
<p><code>afterBulkDestroy(options)</code></p>
<p><code>afterBulkRestore(options)</code></p>
<p><code>afterBulkUpdate(options)</code></p>
</td>
<td class="No-Table-Style">
<p>Instance</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>afterQuery(options, query)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>beforeDisconnect(connection)</code></p>
<p><code>afterDisconnect(connection)</code></p>
</td>
<td class="No-Table-Style">
<p>Connection</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p>*These lifecycle events will be triggered only if <code>sequelize.sync()</code> is invoked.</p>
<p>The majority of these lifecycle events<a id="_idIndexMarker515"/> are explicative in corresponding with their Sequelize function (for example, <code>beforeSave</code> for <code>Model.save()</code>). However, there are two types of events that are implicative and may not be clear initially. The first one is the <code>restore</code> events related to paranoid models (where records are considered <code>delete</code> with a column flag as opposed to being physically deleted). The second one is the <code>Upsert</code> events that are invoked for <code>create</code>, <code>update</code>, and <code>save</code>-related methods, indicating to us whether a record was newly created or updated from a pre-existing record.</p>
<p>Where Sequelize differentiates<a id="_idIndexMarker516"/> from other ORM lifecycle events is, in addition to <em class="italic">instance</em> and <em class="italic">connection</em>-related events, Sequelize will also provide hooks surrounding <em class="italic">finder</em> methods (for example, <code>findAll</code> and <code>findOne</code>). The following is a list<a id="_idIndexMarker517"/> with a brief explanation of each finder event:</p>
<ul>
<li><code>beforeFind(options)</code>: Occurs before any transformation that occurs to options from Sequelize internally</li>
<li><code>beforeFindAfterExpandIncludeAll(options)</code>: An event that is triggered after Sequelize expands the <em class="italic">include</em> attributes (for example, setting proper defaults for specific associations)</li>
<li><code>beforeFindAfterOptions(options)</code>: Before the finder method invokes the query and after Sequelize is finished hydrating/transforming options</li>
<li><code>afterFind(instances, options)</code>: Returns a single instance or an array of instances after a finder method is finished querying</li>
<li><code>beforeCount(options)</code>: This event will trigger before the <code>count()</code> instance method queries the database</li>
</ul>
<p>Now that we have a better understanding of which hooks are available to use and the order of execution through the lifecycle, we can begin building our models with lifecycle events attached to them.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor138"/>Defining, removing, and executing lifecycle events</h1>
<p>There are several ways to attach lifecycle events<a id="_idIndexMarker518"/> to models and Sequelize’s behavior. Each of these methods allows us to change the attribute values that are derived from the hook’s arguments as pass-by-reference. For example, you can add additional properties to the instances returned in <code>afterFind</code> by simply updating the attributes on the objects from within the lifecycle method. By default, Sequelize will treat lifecycle events as synchronous operations, but if you need asynchronous capabilities, you can return a <code>Promise</code> object or an <code>async</code> function.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor139"/>Defining instance and model lifecycle events</h2>
<p>Instance and model lifecycle<a id="_idIndexMarker519"/> events can be defined in several ways, including defining these events<a id="_idIndexMarker520"/> as a local hook (defined directly from the model itself). There are several ways to define a local hook; we will start with the basic example of declaring hooks during the initialization of a model:</p>
<pre class="source-code">
class Receipt extends Model {}
Receipt.init({
  subtotal: DataTypes.DECIMAL(7, 2)
}, {
  hooks: {
    beforeValidate: (receipt, options) =&gt; {
      if (isEmployee(receipt.customer)) {
        receipt.subtotal = 0;
      }
    }
  }
});
// or with the define() method
sequelize.define('Receipts', {
  subtotal: DataTypes.DECIMAL(7, 2)
}, {
  hooks: {
    beforeValidate(receipt, options) =&gt; { … })
  }
});</pre>
<p>To define the same exact hook outside<a id="_idIndexMarker521"/> of initialization, we can either use the <code>addHook()</code> method or invoke<a id="_idIndexMarker522"/> the corresponding lifecycle method directly. This method provides an easy way for plugins and adapters to integrate with your models after defining them. The following is a simple example of how to use this method:</p>
<pre class="source-code">
function employeeDiscount(receipt, options) {
  if (isEmployee(receipt.customer)) {
    receipt.subtotal = 0;
  }
}
class Receipt extends Model {}
Receipt.init({ subtotal: DataTypes.DECIMAL(7, 2) });
Receipt.addHook('beforeValidate',employeeDiscount);
// or you can use the direct method:
Receipt.beforeValidate(employeeDiscount);</pre>
<p>The previous examples provided illustrations for synchronous events. An example of asynchronous hooks involves returning a Promise (as previously stated), like so:</p>
<pre class="source-code">
async function employeeDiscount(receipt, options) {
  if (!customerIsEmployee) {
    return;
  }
  const discountTotal = await 
  getDiscountFromExternalAccountingService(employeeId);
  receipt.subtotal = discountTotal;
}
Receipt.addHook('beforeValidate', employeeDiscount);
// or…
Receipt.beforeValidate(employeeDiscount);</pre>
<p>To throw an error<a id="_idIndexMarker523"/> from a synchronous lifecycle event, you can return<a id="_idIndexMarker524"/> a rejected <code>Promise</code> object:</p>
<pre class="source-code">
Receipt.beforeValidate((receipts, options) =&gt; {
  return Promise.reject(new Error("Invalid receipt"));
});</pre>
<p>For organizational purposes, you can declare names for your lifecycle events using the <code>addHook()</code> or direct methods:</p>
<pre class="source-code">
Receipt.addHook('beforeValidate', 'checkForNegativeSubtotal', (receipt, options) =&gt; { … });
// or
Receipt.beforeValidate('checkForNegativeSubtotal', (receipt, options) =&gt; {…});</pre>
<p>These examples provide us with methods for assigning lifecycle events on the local scope of the model itself. If we wanted to define lifecycle events on a global scope (applicable to all models), we would use the Sequelize constructor to do so:</p>
<pre class="source-code">
const sequelize = new Sequelize(…, {
  define: {
    hooks: {
      beforeValidate() {
     // perform some kind of data transformation/validation
      }
  }
});</pre>
<p>This will generate a default <code>beforeValidate</code> hook for models that do not define their own <code>beforeValidate</code> hooks. If you wish to run a global hook, regardless of whether the model<a id="_idIndexMarker525"/> has its own definition, we can define <strong class="bold">permanent hooks</strong>:</p>
<pre class="source-code">
sequelize.addHook('beforeValidate', () =&gt; { … });</pre>
<p>Even if a model has its own <code>beforeValidate</code> hook definition, Sequelize will still execute the global hook. If we have a global and local hook associated with the same lifecycle event, then Sequelize will execute the local hook(s) first followed by the global hook(s). </p>
<p>For model-specific event<a id="_idIndexMarker526"/> types (such as <code>bulkDestroy</code> and <code>bulkUpdate</code>), Sequelize will not execute individual delete and update hooks<a id="_idIndexMarker527"/> per row by default. To modify this behavior, we can add a <code>{ individualHooks: true }</code> option for when we call these methods, like so:</p>
<pre class="source-code">
await Receipt.destroy({
  where: { … },
  individualHooks: true
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">Using the <code>{ indvidualHooks: true }</code> option could cause a decrease in performance, depending on whether Sequelize will need to retrieve rows, store the rows/additional information in memory (for example, <code>bulkDestroy</code> and <code>bulkUpdate</code> but not <code>bulkCreate</code>), and execute individual hooks per record. </p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor140"/>Removing lifecycle events</h2>
<p>Some projects will require<a id="_idIndexMarker528"/> conditionally invoking lifecycle events. For instance, we may have some sort of validation to check whether a user is still eligible for replying to a comment on a forum. This validation is appropriate for a production environment but not necessary for a development environment.</p>
<p>One method would be to create a conditional logic surrounding the hook definition – for example, the following:</p>
<pre class="source-code">
if (!isDev) {
  User.addHook('beforeValidate', 'checkForPermissions', …);
}</pre>
<p>This would technically<a id="_idIndexMarker529"/> work, but what if we had several stipulations, such as sending an order email in the <code>afterCreate</code> hook or refunding an order in production only? We would have a lot of “<code>if</code> statements” throughout the code base. Sequelize offers a method to remove lifecycle events to help organize this type of workflow called <code>removeHook</code>.</p>
<p>We could load all of the lifecycle events as we normally would, but if our environment is at the development stage, then we can run through all of our models and remove the applicable hooks. All of these granular tunings can be organized in one function given the <code>removeHook</code> method:</p>
<pre class="source-code">
function removeProductionOnlyHooks() {
  // this will remove all matching hooks by event type and 
     name
  User.removeHook('beforeValidate', 'checkForPermissions');
  // this will remove all beforeValidate hooks on the User 
     model
  User.removeHook('beforeValidate');
  // this will remove all of the User model's hooks
  User.removeHook();
}
 // load our models…
if (isDev) {
  removeProductionHooksOnly();
}</pre>
<p>Removing lifecycle events<a id="_idIndexMarker530"/> is useful for timed behavior in an application or for removing explicit debugging hooks. The next section will help us understand the order of operation when executing lifecycle events and when a specific lifecycle event will be executed.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor141"/>Executing lifecycle events</h2>
<p>Sequelize will run the corresponding/applicable lifecycle events<a id="_idIndexMarker531"/> based on the method that you are invoking. Using our previous <code>Transactions</code> model example, if we were to run <code>Transactions.create({ … })</code>, then Sequelize would automatically run the following lifecycle events (in sequential order):</p>
<ol>
<li><code>beforeValidate</code></li>
<li><code>afterValidate</code>/<code>validationFailed</code></li>
<li><code>beforeCreate</code></li>
<li><code>beforeSave</code></li>
<li><code>afterSave</code></li>
<li><code>afterCreate</code></li>
</ol>
<p>One caveat to keep in mind for executing lifecycle events is that when you are using the <code>update()</code> method, it is important to keep in mind that Sequelize will not execute the lifecycle events unless an attribute’s value has changed. </p>
<p>For instance, this will not call the corresponding lifecycle events:</p>
<pre class="source-code">
var post = await Post.findOne();
await Post.update(post.dataValues, {
  where: { id: post.id }
});</pre>
<p>Since the values did not change, Sequelize will ignore the lifecycle events. If we wanted to enforce this behavior, we could add a <code>hooks: true</code> parameter to the update’s configuration:</p>
<pre class="source-code">
await Post.update(post.dataValues, {
  where: { id: post.id },
<strong class="bold">  hooks: true</strong>
});</pre>
<p>Now that we have the basics<a id="_idIndexMarker532"/> of how to define, remove, and execute lifetime events, we can move on to the nuances of utilizing hooks with associations and transactions.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor142"/>Using lifecycle events with associations and transactions</h1>
<p>As the default behavior, Sequelize will execute<a id="_idIndexMarker533"/> lifecycle events without associating a transaction<a id="_idIndexMarker534"/> with any database queries<a id="_idIndexMarker535"/> that are invoked within<a id="_idIndexMarker536"/> the lifecycle’s scope. However, sometimes our project requires transactions to be used within lifecycle events, such as an accountant’s ledger or creating log entries. Sequelize offers a <code>transaction</code> parameter when calling certain methods, such as <code>update</code>, <code>create</code>, <code>destroy</code>, and <code>findAll</code>, that will allow us to use a transaction that was defined outside of the lifecycle’s scope to be used within the lifecycle itself.</p>
<p class="callout-heading">Note</p>
<p class="callout">When calling <code>beforeDestroy</code> and <code>afterDestroy</code> on a model, Sequelize will intentionally skip destroying any associations with that model unless the <code>onDelete</code> parameter is set to <code>CASCADE</code> and the <code>hooks</code> parameter is set to <code>true</code>. This is due to Sequelize needing to explicitly delete each association row by row, which could cause congestion if we are not careful.</p>
<p>If we were to write a naive accounting system and wanted to create logging entries as a separate ledger, we would first define our models like so:</p>
<pre class="source-code">
class Account extends Model {}
Account.init({
    name: {
        type: DataTypes.STRING,
        primaryKey: true,
    },
    balance: DataTypes.DECIMAL,
});
class Book extends Model {}
Book.init({
    from: DataTypes.STRING,
    to: DataTypes.STRING,
    amount: DataTypes.DECIMAL,
});</pre>
<p>Then, we can add our <code>Ledger</code> model, which<a id="_idIndexMarker537"/> is a copy of the <code>Book</code> model<a id="_idIndexMarker538"/> with a naive reference<a id="_idIndexMarker539"/> column (for brevity) and a signature column, to indicate<a id="_idIndexMarker540"/> that the transaction was approved by an external source:</p>
<pre class="source-code">
class Ledger extends Model {}
Ledger.init({
    bookId: DataTypes.INTEGER,
    signature: DataTypes.STRING,
    amount: DataTypes.DECIMAL,
    from: DataTypes.STRING,
    to: DataTypes.STRING,
});</pre>
<p>To automate the <code>Ledger</code> workflow, we can add an <code>afterCreate</code> hook to our Book model to record the account balance changes:</p>
<pre class="source-code">
Book.addHook('afterCreate', async (book, options) =&gt; {
    const from = await Account.findOne(book.from);
    const to = await Account.findOne(book.to);
    // pretend that we have an external service that "signs" 
       our transactions
    const signature = await getSignatureFromOracle(book);
    await Ledger.create({
        transactionId: book.id,
        signature: signature,
        amount: book.amount,
        from: from.name,
        to: to.name,
    });
});</pre>
<p>Now, when we create<a id="_idIndexMarker541"/> a new booking entry, we can pass a <code>transaction</code> reference<a id="_idIndexMarker542"/> so that Sequelize can execute queries<a id="_idIndexMarker543"/> within the lifecycle scopes under the same<a id="_idIndexMarker544"/> transaction. We will be covering transactions more in depth in <a href="B17841_06.xhtml#_idTextAnchor147"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Transactions with Sequelize</em>, but for now, we will give a simple illustrative example of what a transaction would look like:</p>
<pre class="source-code">
const Sequelize = require('@sequelize/core');
const sequelize = new Sequelize('db', 'username',  
                                'password');
await sequelize.transaction(async t =&gt; {
    // validate our balances here and some other work…
 
    await Book.create({
        to: 'Joe',
        from: 'Bob',
        amount: 20.21,
    }, {
        transaction: t,
    });
   // double check our new balances
   await checkBalances(t, 'Joe', 'Bob', 20.21);
});</pre>
<p>The benefit of using a transaction<a id="_idIndexMarker545"/> within the lifecycle event is that if any part of the transaction<a id="_idIndexMarker546"/> workflow fails to execute, we can halt<a id="_idIndexMarker547"/> the rest of the workflow without diluting<a id="_idIndexMarker548"/> the quality of our database’s records. Without the <code>transaction</code> parameter being set within the previous example, Sequelize would still have created a Ledger entry, even if the <code>checkBalances</code> method returned an error and did not commit the transaction.</p>
<p class="callout-heading">Note</p>
<p class="callout">Sequelize will sometimes use its own internal transaction for methods such as <code>findOrCreate</code>. You may always overwrite this parameter with your own transaction.</p>
<p>Now that we have the fundamentals of adding lifecycle events to our models, we can begin updating our Avalon Airlines project.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor143"/>Putting it all together</h1>
<p>For this section, we will only need<a id="_idIndexMarker549"/> to update the <code>BoardingTicket</code> model (located in <code>models/boardingticket.js</code>) by adding two attributes, <code>cost</code> and <code>isEmployee</code>, and some lifecycle events for our boarding seat workflow. Let’s look at the steps:</p>
<ol>
<li value="1">First, we will need to add our attributes within the <code>init</code> method, which should end up looking like this:<pre>  BoardingTicket.init({
    seat: {
      type: DataTypes.STRING,
      validate: {
        notEmpty: {
   msg: 'Please enter in a valid seating arrangement'
        }
      }
<strong class="bold">    },</strong>
<strong class="bold">    cost: {</strong>
<strong class="bold">      type: DataTypes.DECIMAL(7, 2)</strong>
<strong class="bold">    },</strong>
<strong class="bold">    isEmployee: {</strong>
<strong class="bold">      type: DataTypes.VIRTUAL,</strong>
<strong class="bold">      async get() {</strong>
<strong class="bold">        const customer = await this.getCustomer();</strong>
<strong class="bold">        if (!customer || !customer.email) </strong>
<strong class="bold">             return false;</strong>
<strong class="bold">   return customer.email.endsWith('avalonairlines');</strong>
<strong class="bold">      }</strong>
<strong class="bold">    }</strong>
  }, {
    sequelize,
    modelName: 'BoardingTicket'
  });</pre></li>
<li>Below the <code>init</code> function, we will want<a id="_idIndexMarker550"/> to add our lifecycle events. The first one will check whether the ticket is considered to be an employee ticket and, if so, then mark the subtotal as zero:<pre>  // Employees should be able to fly for free
  BoardingTicket.beforeValidate('checkEmployee', 
                                (ticket, options) =&gt; {
    if (ticket.isEmployee) {
       ticket.subtotal = 0;
    }
  });</pre></li>
<li>Next, we will want to ensure our subtotal is never less than zero (the <code>beforeValidate</code> event would also be applicable here):<pre>  // Subtotal should never be less than zero
  BoardingTicket.beforeSave('checkSubtotal', (ticket, options) =&gt; {
    if (ticket.subtotal &lt; 0) {
      throw new Error('Invalid subtotal for this ticket.');
    }
  });</pre></li>
<li>For the last lifecycle event<a id="_idIndexMarker551"/> for our model, we will want to check whether the customer had selected a seat that was considered available:<pre>  // Ensure that the seat the customer has requested 
     is available
  BoardingTicket.beforeSave('checkSeat', async (tick
                             et, options) =&gt; {
  // getDataValue will retrieve the new value (as 
     opposed to the previous/current value)
    const newSeat = ticket.getDataValue('seat');
    if (ticket.changed('seat')) {
      const boardingTicketExists = 
      BoardingTick-et.findOne({
        where: { seat: newSeat }
      });
      if (boardingTicketExists) {
        throw new Error(`The seat ${newSeat} has 
        al-ready been taken.`)
      }
    }
  });</pre></li>
<li>After these changes, whenever we create a new boarding ticket, our application will now perform three lifecycle events prior to saving the record. For reference only, the following is an example of how we would pass the transaction to our <code>BoardingTicket</code> model:<pre>await sequelize.transaction(async t =&gt; {
  await BookingTicket.create({
    seat: 'A1',
    cost: 12,
    customerId: 1,
  }, {
    transaction: t,
  });
});</pre></li>
</ol>
<p>That wraps up our required changes<a id="_idIndexMarker552"/> in this chapter for the Avalon Airlines project. We added a lifecycle event that checks for subtotals and seat availability. We also went through an example of passing a transaction to a specific query, which we will expand upon in the next chapter.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor144"/>Summary</h1>
<p>In this chapter, we went through what a lifecycle event is and how it can be used in day-to-day applications, which lifecycle events are available to Sequelize a<a id="_idTextAnchor145"/>nd in which order they are initiated, and how to add lifecycle events to or remove them from a Sequelize model.</p>
<p>In the next chapter, we will be covering how transactions work, how they are used, and how they can be configured within Sequelize. In addition, the following chapter will also cover different types of locks for transactions and the differences between managed and unmanaged transactions.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor146"/>References</h1>
<p>If you run into issues with lifecycle events, a quick reference can be found here: <a href="https://sequelize.org/master/manual/hooks.xhtml">https://sequelize.org/master/manual/hooks.xhtml</a>.</p>
</div>
</div></body></html>