<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;The Socket.IO Protocol"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Socket.IO Protocol</h1></div></div></div><p>Socket.io provides a very simple <a id="id154" class="indexterm"/>API that is easy to use but exposes a lot of functionality. Moreover, this functionality works uniformly across browsers and the various transport mechanisms provided by socket.io. To achieve this, a socket.io client and server do a lot of work in the background. In this chapter, we will examine and try to understand the communication in socket.io as well as some socket.io internals.</p><div class="section" title="Why do we need another protocol?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Why do we need another protocol?</h1></div></div></div><p>The first question to people familiar with WebSocket is, why do we need another protocol when we already have WebSocket? The answer is twofold; socket.io works in a uniform manner across browsers (dating back to Internet Explorer 6), and socket.io provides a much richer API <a id="id155" class="indexterm"/>
</p><p>The WebSocket specification is still under development and is not supported on many of the browsers that are in use. In fact, any version of Internet Explorer prior to IE10 doesn't have support for WebSocket. There are still many people out there using old browsers that don't support WebSocket.</p><p>Another problem for WebSocket is firewalls and proxies. Most of the firewalls block any communication (apart from standard HTTP 1.0/1.1), and may not allow a WebSocket connection to be established. The same applies to most proxy servers.</p><p>So, if we decide to use just the WebSocket protocol, we have to understand that there will be many people who may not be able to use our application.</p><p>Contrary to this, when we build our application using socket.io, the people who can use WebSocket will continue using it, but those who can't will fall back on the next best available transport mechanism and then the next and so on, until they find one that works in the browser, even through the firewalls and proxies, all the way down to iframes (which is rarely used). The default order is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">WebSocket</li><li class="listitem" style="list-style-type: disc">FlashSocket</li><li class="listitem" style="list-style-type: disc">XHR long polling</li><li class="listitem" style="list-style-type: disc">XHR multipart streaming</li><li class="listitem" style="list-style-type: disc">XHR polling</li><li class="listitem" style="list-style-type: disc">JSONP polling</li><li class="listitem" style="list-style-type: disc">iframe</li></ul></div><p>It's also worth noting that using JSONP polling, socket.io provides support for cross-domain communication without the need for any special configuration on the server or any special code on the client: <a id="id156" class="indexterm"/>
</p><p>Now, let us take a look at the differences in the API. For this, we will see only the JavaScript client-side API, as any server will have its own implementation and API depending on the programming language used.</p><div class="section" title="The WebSocket API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>The WebSocket API</h2></div></div></div><p>Let us begin by taking a quick look at a code snippet showing the skeleton of a WebSocket cliet: <a id="id157" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  var socket = new WebSocket('ws://localhost:8080');

  socket.onopen = function(event) {
    socket.send('Client socket connected');
  };
  
  socket.onmessage = function(event) {
    console.log('Client received a message', event);
  };
  
  socket.onclose = function(event) {
    console.log('Client socket disconnected', event);
  };
  
  //socket.close()
&lt;/script&gt;</pre></div><p>The first step, as can be seen in the previous code snippet, is to create a new instance of WebSocket; in this, we have to pass the URI for the WebSocket server. This URI, like any other, has a part that specifies the protocol, which in this case can be either <code class="literal">ws</code> (unsecured) or <code class="literal">wss</code> (secured); the server address (the server's IP address or valid domain name); and finally, the port.</p><p>Ideally, we also need to check if WebSocket is supported on the browser that the user has, but I have skipped that part to focus on the API.</p><p>Following the creation of the WebSocket object, we can attach event handlers to it. There are three events exposed by WebSocket, with their corresponding event handlers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">open</code>: The <code class="literal">onopen</code> event handler</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: The <code class="literal">onmessage</code> event handler</li><li class="listitem" style="list-style-type: disc"><code class="literal">close</code>: The <code class="literal">onclose</code> event handler</li></ul></div><p>As is evident by their names, these handlers will be called on the opening of a socket connection, when there is a new message on the socket, and on closing the socket connection, respectively.</p><p>For every event, the client receives the event data. In case the event is a message, it contains that message along with other data. The WebSocket client doesn't try to interpret the message or its type, that is to say, it treats all messages as plain text and it is left to the application to interpret and understand it. Also, there is no mention of the namespacing of messages or the multiplexing of socket connections. <a id="id158" class="indexterm"/>
</p><p>If you see the <code class="literal">onopen</code> handler, you will notice the <code class="literal">send</code> method, which is used by the client to send messages. Again, it can send only plain text, so you have to take care of serialization and deserialization.</p><p>Finally, we have the <code class="literal">close</code> method, <a id="id159" class="indexterm"/>which, as the name suggests, can be used to close the socket connection from the client.</p></div><div class="section" title="The Socket.IO API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec15"/>The Socket.IO API</h2></div></div></div><p>Let us see the same code using sockt.io: <a id="id160" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  var socket = io.connect('http://localhost:8080');
  
  socket.on('connect', function() {
    socket.send('Client socket connected');
  });

  socket.on('message', function(data) {
    console.log('Received a message from the server!',data);
  });

  socket.on('disconnect', function() {
    console.log('The client socket disconnected!');
  });

&lt;/script&gt;</pre></div><p>The above code snippet looks similar to the one with WebSockets and, not surprisingly, does the same work as the previous code. However, there are some minor changes: instead of using <code class="literal">onopen</code>, <code class="literal">onmessage</code>, and <code class="literal">onclose</code>, we use socket.io's <code class="literal">on</code> method to attach the handlers. The advantage is that when we use socket.io's custom events functionality, the API to handle the event remains the same. <a id="id161" class="indexterm"/>
</p><p>As we have already seen, you can emit a new event using the following line of code:</p><div class="informalexample"><pre class="programlisting">socket.emit("myevent", {"eventData": "..."});</pre></div><p>And then receive it using the following:</p><div class="informalexample"><pre class="programlisting">socket.on("myevent", function(event){...});</pre></div><p>As you can see, in this case, we are passing a JSON object for the data; socket.io will take care of serializing and deserializing it for us.</p><p>Moreover, socket.io provides support for namespacing of messages, multiplexing of connections, disconnection detection, reconnection, and an API to broadcast messages to all clients.</p><p>Considering everything covered in this section, it is not difficult to conclude that socket.io will need its own protocol and mechanism to work.</p></div></div></div>
<div class="section" title="The Socket.IO socket"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>The Socket.IO socket</h1></div></div></div><p>The socket.io socket emulates a network socket over different transport mechanisms. Just as any other socket, it has various stages in its lifecycle, depending on the status of the connection. These are as follows: <a id="id162" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">connecting</li><li class="listitem" style="list-style-type: disc">connected</li><li class="listitem" style="list-style-type: disc">disconnecting</li><li class="listitem" style="list-style-type: disc">disconnected</li></ul></div><p>The socket is established when the<a id="id163" class="indexterm"/> client sends a connection request to the server and a handshake is initiated.</p><p>Once the handshake is complete, a connection is opened using the transport negotiated during the handshake, and the state of the socket is set to <span class="emphasis"><em>connected</em></span>.</p><p>To check the liveliness of the socket depending on the server configuration, the server may require heartbeat messages to be sent from the client to the server in regular intervals. In the absence of such a message, or the failure of the underlying transport, the socket will be disconnected.</p><p>In this case, the client will initiate a reconnect. If the connection is restored within the connection termination time or the timeout agreed at the time of the handshake, the buffered messages are sent across. In case the connection is not restored, the client will start a new connection request, beginning with a new handshake.</p><p>Also, optionally, to ensure message delivery over the socket, we can make it compulsory for the socket to acknowledge the message delivery.</p><p>The socket is terminated when the <code class="literal">close</code> method is called on either the client or the server.</p></div>
<div class="section" title="The Socket.IO connection"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>The Socket.IO connection</h1></div></div></div><p>The socket.io connection begins with <a id="id164" class="indexterm"/>the handshake. This makes the handshake a special part of the protocol. Apart from the handshake, all the other events and messages in the protocol are transferred over the socket.</p><p>Socket.io is intended for use with web applications, and therefore it is assumed that these applications will always be able to use HTTP. It is because of this reasoning that the socket.io handshake takes place over HTTP.</p><p>To initiate the connection and hence perform the handshake, the client performs a <code class="literal">POST</code> request on the handshake URI (built from the URI passed to the <code class="literal">connect</code> method). Let us take the same socket.io connection URI and try to understand its various parts. Let us say that the URI is as follows:</p><p>
<a class="ulink" href="http://myhost.com:8080/socket.io/1/">http://myhost.com:8080/socket.io/1/</a>
</p><p>Let us break down and understand this URI.</p><p>
<code class="literal">http</code> is the protocol being used. We can set it to use <code class="literal">https</code>, using <code class="literal">https</code> in the client's <code class="literal">connect</code>
<code class="literal">ct</code> method. <a id="id165" class="indexterm"/>
</p><p>
<code class="literal">myhost.com</code> again comes from the <code class="literal">connect</code> method and is the name or IP address of the host you want to connect to. The default i <code class="literal">localhost</code>. <a id="id166" class="indexterm"/>
</p><p>
<code class="literal">8080</code> is the port over which your server is listening. This is also passed to the <code class="literal">connect</code> method when we are invoking it. The default is <code class="literal">80</code>. <a id="id167" class="indexterm"/>
</p><p>
<code class="literal">socket.io</code> is the namespace that handles all the connect requests.</p><p>
<code class="literal">1</code> is the socket.io protocol version number.</p><p>The server can respond to this in one of thee three ways: <a id="id168" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">200 OK</code> – This will be the server's response when the handshake is successful. In addition to the status, the body of the response should be a colon-separated list of the session ID given to this connection, the heartbeat timeout, the connection closing timeout, and the list of supported transports separated by commas. A sample response body looks like this:<div class="informalexample"><pre class="programlisting">8749dke9387:20:10:websocket,flashsocket,xhr-polling</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">401 Unauthorized</code> – <a id="id169" class="indexterm"/>This will be the response from the server in case the authorization handler fails to authorize the client. As we saw in the previous chapter, this is the handler we attach to the <code class="literal">authorize</code> event on the server, and it uses the connection and cookie information to authorize the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">503 Service Unavailable</code> – When the server has any other reason, including errors, to deny service to the client.</li></ul></div><p>If the handshake is successful, based on the transports provided by the server and the one supported by the client the socket.io client will start communicating with the server on a particular URI. This URI has the form <code class="literal">[scheme]://[host]/[namespace]/[version]/[transportId]/[sessionId]</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">[scheme]</code> is the protocol the client will be using to communicate. In the case of WebSockets, this is either <code class="literal">ws</code> or <code class="literal">wss</code>, while in the case of XHR, it is either <code class="literal">http</code> or <code class="literal">https</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[host]</code> is the server name or IP Address.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[namespace]</code> is the socket.io namespace we want to send the message to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[version]</code> is the version of the socket.io protocol that we are using, currently <code class="literal">1</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[transportId]</code> is the the name of the transport mechanism chosen for the communication.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[sessionId]</code> is the session ID given to the client by the server during the handshake.</li></ul></div><p>In the case of bidirectional transport, such as WebSocket, the connection opened at this URI will be used to send and receive messages.</p><p>For unidirectional transports such as XHR long polling, the client will perform a <code class="literal">GET</code> request on this URI, which the server will keep on hold till it has some data to send, while the client will perform a <code class="literal">POST</code> request on this URI whenever it has to send a message or an event to the server.</p></div>
<div class="section" title="Socket.IO messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Socket.IO messages</h1></div></div></div><p>Once the transport's<a id="id170" class="indexterm"/> connection is established, all the communication between the client and server happens using messaging over the socket. The messages need to be encoded in the format specified by socket.io.</p><p>This format enables socket.io to determine the type of the message and the data sent in the message, and some metadata useful for operation. The message format is <code class="literal">[type] : [id ('+')] : [endpoint] (: [data])</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type</code> is a single digit integer, specifying what type of message it is.</li><li class="listitem" style="list-style-type: disc"><code class="literal">id</code> is the message ID, which is an incremental integer; it is used for ACKs. It is optional.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">+</code> sign, if present, tells socket.io not to handle the ACKs, as the application intends to handle it. <a id="id171" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">endpoint</code> is the socket endpoint that the message is intended to be delivered to. This is optional and is used when multiplexing the socket for namespacing. If omitted, the message will be sent to the default socket.</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code> is the associated data to be delivered to the socket. In the case of messages, it is treated as plain text, while in the case of events, it will be parsed as JSON.</li></ul></div><p>In the coming section, we will see what the types of messages are.</p><div class="section" title="Disconnect (0)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Disconnect (0)</h2></div></div></div><p>When the type is zero (<code class="literal">0</code>), <a id="id172" class="indexterm"/>the message is a disconnect signal. This will tell socket.io to close the connection and the mentioned socket. If the endpoint is not specified, the message will be sent to the default socket, which will cause the whole socket to be closed and all the endpoints on that socket will be terminated. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">0</code> – The result is that the socket is closed and all the connections/endpoints are terminated.</li><li class="listitem" style="list-style-type: disc">Message: <code class="literal">0::/endpoint</code> – The socket connection to <code class="literal">/endpoint</code> will be closed and no messages can be sent to or from that endpoint. Other endpoints will continue to operate.</li></ul></div></div><div class="section" title="Connect (1)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Connect (1)</h2></div></div></div><p>This message is only used for multiplexing, and is sent from the client to the server to open a new connection. Thus, <a id="id173" class="indexterm"/> this message must always have an endpoint. The first (default) socket connection is established by the handshake explained earlier. The endpoint may be followed by query parameters in a URL query format. If the connection is successful, the server will echo the same message, else the server can send an error message. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">1::/endpoint</code> – Requests the server to open a multiplexed socket to the endpoint.</li><li class="listitem" style="list-style-type: disc">Message: <code class="literal">0::/endpoint?param=one</code> – Requests the server to open a multiplexed socket to the endpoint, passing a parameter called <code class="literal">param</code> with the value <code class="literal">one</code>.</li></ul></div></div><div class="section" title="Heartbeat (2)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec18"/>Heartbeat (2)</h2></div></div></div><p>This is the heartbeat message. <a id="id174" class="indexterm"/>It must be sent from the client to the server within the timeout negotiated during the handshake. The server will reply with a heartbeat message too. In this case, we don't have an endpoint and nor is any other information required. This is because it serves the whole socket. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">2</code> – Sends a heartbeat message to the other end.</li></ul></div></div><div class="section" title="Message (3)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Message (3)</h2></div></div></div><p>This is the message sent over the socket. In the API, this message will be sent when you are using <code class="literal">socket.send</code>, and will result in a message event on the receiving end. This message will carry data, treating it as plan text. For example: <a id="id175" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">3:1::Some message</code> – This will send a message to the other end, where the message event handler will be triggered with the <code class="literal">Some message</code> message in the event data.</li><li class="listitem" style="list-style-type: disc">Message: <code class="literal">3:1:/endpoint:Some message</code> – Again, the message will be sent to other end of the socket, but on the multiplexed endpoint.</li></ul></div></div><div class="section" title="JSON message (4)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec20"/>JSON message (4)</h2></div></div></div><p>This is similar to sending the message, <a id="id176" class="indexterm"/>but in this case the message has to be serialized using JSON, and it will be parsed at the other end before being sent to the handler. In version 0.6, this was done using the same API as <code class="literal">send()</code> for message, just passing a JSON message instead of a string message. But since this introduces a performance penalty over sending plain text from version 0.7 onwards, we have to use the <code class="literal">json</code> flag to send a JSON message; for example, <code class="literal">socket.json.send</code>. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">4:1::{"some":"content"}</code> – Sends the JSON message to the other end of the socket.</li></ul></div></div><div class="section" title="Event (5)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Event (5)</h2></div></div></div><p>The Event message is a special kind of JSON <a id="id177" class="indexterm"/>message that is used to send events over the socket. In events, the data payload is of the form <code class="literal">{"name":"eventName", "args":{"some":"content"}}</code>.</p><p>Here, <code class="literal">name</code> is the name of the event and <code class="literal">args</code> are the parameters to be sent to the handler. The <code class="literal">socket.emit</code> call is used to send events in the applications. <a id="id178" class="indexterm"/>
</p><p>The following event names are reserved and cannot be used in applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">message</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">connect</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">disconnect</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">open</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">close</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">error</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">retry</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">reconnect</code></li></ul></div><p>For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">5:1::{"name": "myEvent", "args":{"some": "data"}</code> – The result is that the event will be sent to the other end and the appropriate event handler will be invoked, passing the args to it.</li></ul></div></div><div class="section" title="ACK (6)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec22"/>ACK (6)</h2></div></div></div><p>The acknowledgment (ACK) <a id="id179" class="indexterm"/>message will be sent when the message is received, with ACK request enabled; or, it can be sent out by the application. The data section in the ACK message can be the message ID for the message that is being acknowledged. If the message ID is followed by <code class="literal">+</code> and additional data, it is treated as an event packet. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">6:::1</code> – Sends an acknowledgment for the receipt of a message with ID <code class="literal">1</code>.</li><li class="listitem" style="list-style-type: disc">Message: <code class="literal">6:::1+["A", "B"]</code> – This will send an acknowledgment for the message along with the data.</li></ul></div></div><div class="section" title="Error (7)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Error (7)</h2></div></div></div><p>This is sent by the server in case <a id="id180" class="indexterm"/> there's an error, such as failure during the processing of a <code class="literal">connect</code> request to an endpoint. The data section of this message will contain the error message and, optionally, advice, separated by the <code class="literal">+</code> sign. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message: <code class="literal">7:::Unauthorized</code> – The result is that the error will be sent to the client.</li></ul></div></div><div class="section" title="NOOP (8)"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>NOOP (8)</h2></div></div></div><p>This message implies no operation, <a id="id181" class="indexterm"/> and is used to close a poll after the polling times out.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we saw the communication mechanism for the socket.io server and client. Understanding the working and the message formats, helps us in debugging the issues we face during the development of socket.io applications.</p><p>In the next chapter we will learn to deploy and scale socket.io applications in production. Also, we will get a few tips on how to minimize our troubles on the production server.</p></div></body></html>