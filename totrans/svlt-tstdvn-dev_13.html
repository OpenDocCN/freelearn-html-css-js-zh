<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer040">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor148"/>13</h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Adding Cucumber Tests</h1>
<p>Up until now, you have seen two types of automated tests: Vitest unit tests and Playwright end-to-end tests. This chapter adds a third type of test: <span class="No-Break"><strong class="bold">Cucumber</strong></span><span class="No-Break"> (</span><a href="https://cucumber.io"><span class="No-Break">https://cucumber.io</span></a><span class="No-Break">).</span></p>
<p>Just like Playwright, Cucumber has its own test runner, which is typically set up to drive your application in the same way as Playwright does. The difference is that Cucumber tests are not written in <span class="No-Break">JavaScript code.</span></p>
<p>Cucumber tests are contained within <em class="italic">feature files</em> that contain tests formatted in a special syntax known as <strong class="bold">Gherkin</strong>. These tests, known as <strong class="bold">features</strong> and organized into scenarios, read like plain English. That has a couple <span class="No-Break">of advantages.</span></p>
<p>First, they can be written and understood by the whole team, not just developers. That means you can extend test-first practices outside of the <span class="No-Break">development team.</span></p>
<p>Second, the absence of code encourages you to write tests that focus on user behavior rather than the technical details of the software. That, in turn, encourages you to build the right thing for <span class="No-Break">your users.</span></p>
<p>How does Cucumber turn features into executable code? Well, take a look at an example line (or, step) from a <span class="No-Break">feature file:</span></p>
<pre class="source-code">
When I navigate to the "/birthdays" page</pre>
<p>Cucumber takes this step and looks for a matching JavaScript-defined step definition. The step definition, in this case, looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
When(
  'I navigate to the {string} page',
  async function (url) { ... }
);</pre>
<p>Notice that the step definition has an associated code block. Once Cucumber finds a matching step definition, it executes that code block, supplying any parsed arguments. In this case, the <strong class="source-inline">url</strong> parameter will be provided as the <strong class="source-inline">/birthdays</strong> string. Cucumber also supports other data types, such as <strong class="source-inline">int</strong> and <span class="No-Break"><strong class="source-inline">bigdecimal</strong></span><span class="No-Break"> (</span><a href="https://github.com/cucumber/cucumber-expressions#parameter-types"><span class="No-Break">https://github.com/cucumber/cucumber-expressions#parameter-types</span></a><span class="No-Break">).</span></p>
<p>We will cover the following key topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Creating the <span class="No-Break">feature file</span></li>
<li>Setting up a Playwright <span class="No-Break">world object</span></li>
<li>Implementing <span class="No-Break">step definitions</span></li>
</ul>
<p>By the end of the chapter, you’ll be confident in adding Cucumber tests to <span class="No-Break">your application.</span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Creating the feature file</h1>
<p>We begin with <a id="_idIndexMarker441"/>writing an example Cucumber <span class="No-Break">feature file.</span></p>
<p>The Gherkin syntax that’s used to write features is characterized by the three words <em class="italic">Given</em>, <em class="italic">When</em>, and <em class="italic">Then</em>. These are analogous to the <em class="italic">Arrange</em>, <em class="italic">Act</em>, and <em class="italic">Assert</em> sections of all good unit tests, so they should <span class="No-Break">feel familiar.</span></p>
<p>Let’s jump right in with our feature file and see what happens when we execute <span class="No-Break">the test:</span></p>
<ol>
<li>Start by adding a new directory, <strong class="source-inline">features</strong>, with a new <strong class="source-inline">features/birthdays.feature</strong> file with the following content. It describes a user scenario in which the <em class="italic">Birthdays</em> application already supports editing a birthday. Here <span class="No-Break">it is:</span><pre class="source-code">
Feature: Editing a birthday
  Scenario: Correcting the year of birth
    Given An existing birthday for "Hercules" on
      "1992-03-04"
    When I navigate to the "/birthdays" page
    And I edit the birthday for "Hercules" to be
      "1994-04-06"
    Then the birthday for "Hercules" should show
      "1994-04-06"
    And the text "1992-03-04" should not appear on the
      page</pre></li>
<li>Install Cucumber using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">npm install --save-dev @cucumber/cucumber</strong></pre></li>
<li>Then, go ahead and run the test with <strong class="source-inline">npx @cucumber/cucumber</strong>. You should see an <a id="_idIndexMarker442"/>output that starts <span class="No-Break">like this:</span><pre class="source-code">
Failures:
1) Scenario: Correcting the year of birth #
     features/birthdays.feature:2
   ? Given An existing birthday for "Hercules" on
     "1992-03-04"
   Undefined. Implement with the following snippet:
     Given('An existing birthday for {string} on
     {string}', function (string, string2) {
        // Write code here that turns the phrase above
             into concrete actions
           return 'pending';
     });</pre></li>
</ol>
<p>Just as all good test runners should, Cucumber is telling us the next task: defining the step definition. But<a id="_idIndexMarker443"/> before we get there, we need to pull in the <span class="No-Break">Playwright APIs.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Setting up a Playwright world object</h1>
<p>How does <a id="_idIndexMarker444"/>Cucumber execute your test? Just like<a id="_idIndexMarker445"/> with the Playwright tests, we need a running application server and a running browser to drive the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). In this section, we’ll write all the code that gets the environment ready for <span class="No-Break">test execution.</span></p>
<p>Cucumber.js uses the concept of a <strong class="bold">world object</strong> that describes the contextual information that is shared between each scenario step. This is an object that is bound to the <strong class="source-inline">this</strong> variable in each step. We also get access to it in special <strong class="source-inline">Before</strong> and <strong class="source-inline">After</strong> hooks, which are run before and after <span class="No-Break">each scenario.</span></p>
<p>The world object should contain functions (and state) that allow you to drive the UI. Since you’ve already learned and used the Playwright API for locating objects on a page, it would be marvelous if we could use that same API. It turns out we can indeed do this. We can also use the same <strong class="source-inline">expect</strong> API we’re used to as well, and we’ll do that in the next section when we begin writing <span class="No-Break">step definitions.</span></p>
<p>Here’s what we’ll do: we’ll build a world class named <strong class="source-inline">PlaywrightWorld</strong> that has the <span class="No-Break">following functions:</span></p>
<ul>
<li><strong class="source-inline">launchServer</strong> and <strong class="source-inline">killServer</strong> for starting and stopping <span class="No-Break">the server</span></li>
<li><strong class="source-inline">launchBrowser</strong> and <strong class="source-inline">closeBrowser</strong> for opening and closing a headless web browser, and for exposing the Playwright page and <strong class="source-inline">request</strong> APIs on our <span class="No-Break">world object</span></li>
</ul>
<p>Then, we’ll use the <strong class="source-inline">Before</strong> and <strong class="source-inline">After</strong> hooks to start and stop both the server <span class="No-Break">and browser.</span></p>
<p>One final note before we begin: our code files will use the <strong class="source-inline">mjs</strong> extension rather than <strong class="source-inline">js</strong>, to signify to <strong class="source-inline">Cucumber.js</strong> that these files use ECMAScript <span class="No-Break">Module syntax.</span></p>
<p><span class="No-Break">Let’s begin:</span></p>
<ol>
<li>Start by creating a new file, <strong class="source-inline">features/support/world.mjs</strong>, with the following import definitions. We’ll add more later, but these are enough to get us started with launching <span class="No-Break">the server:</span><pre class="source-code">
import * as childProcess from 'child_process';
import {
  setWorldConstructor
} from '@cucumber/cucumber';</pre></li>
<li>Now, define the <strong class="source-inline">removeAnsiColorCodes</strong> function. This is important for execution<a id="_idIndexMarker446"/> environments (Windows, primarily) that<a id="_idIndexMarker447"/> will return color codes in the <strong class="source-inline">stdout</strong> <span class="No-Break">stream data:</span><pre class="source-code">
const removeAnsiColorCodes = (string) =&gt;
  string.replace(/\x1b\[[0-9;]+m/g, '');</pre></li>
<li>We’re ready to define the <strong class="source-inline">PlaywrightWorld</strong> class, starting with a single method, <strong class="source-inline">launchServer</strong>. That method ends with a call to <strong class="source-inline">setWorldConstructor</strong> that makes this the designated <span class="No-Break">world class:</span><pre class="source-code">
class PlaywrightWorld {
  async launchServer() {
    console.log('launching server');
    this.serverProcess = childProcess.spawn(
      config.webServer.command,
      [],
      { shell: true, env: config.webServer.env }
    );
    this.baseUrl = await new Promise((resolve) =&gt; {
      this.serverProcess.stdout.on('data', (data) =&gt; {
      let text = removeAnsiColorCodes(String(data));
      let match = text.match(
        /http[s]?:\/\/[a-z]+:[0-9]+\//
      );
      if (match) {
        resolve(match[0]);
      }
    });
    console.log(`started at ${this.baseUrl}`);
  }
}
setWorldConstructor(PlaywrightWorld);</pre></li>
</ol>
<p>The code<a id="_idIndexMarker448"/> in our <strong class="source-inline">launchServer</strong> function<a id="_idIndexMarker449"/> is very crude, but it does the job. It reads the Playwright configuration file and pulls out the value of <strong class="source-inline">config.webServer.command</strong>, which on my project <span class="No-Break">is this:</span></p>
<pre class="source-code">
<strong class="bold">npm run build &amp;&amp; npm run preview</strong></pre>
<p class="callout-heading">Launching the web server using Playwright config</p>
<p class="callout">Because this is a shell command, we must use the <strong class="source-inline">detached</strong> and <strong class="source-inline">shell</strong> properties when calling Node’s <span class="No-Break"><strong class="source-inline">childProcess.spawn</strong></span><span class="No-Break"> function.</span></p>
<p class="callout">Setting <strong class="source-inline">env</strong> means that any environment variables that Cucumber receives are also passed to this new shell. Once the server is started, we read the <strong class="source-inline">stdout</strong> data stream until we see a line that contains an HTTP URL. This is the URL of our running web server, so we parse that value and return it as the argument <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">resolve</strong></span><span class="No-Break">.</span></p>
<p class="callout">The use of the <strong class="source-inline">Promise</strong> object means that the thread will wait until the value is retrieved, and then set the world’s <strong class="source-inline">baseUrl</strong> property to <span class="No-Break">this value.</span></p>
<ol>
<li value="4">Add the following error handling logic, which simply logs out any non-empty messages <a id="_idIndexMarker450"/>that appear on the <strong class="source-inline">stderr</strong> <span class="No-Break">data </span><span class="No-Break"><a id="_idIndexMarker451"/></span><span class="No-Break">stream:</span><pre class="source-code">
class PlaywrightWorld {
  async launchServer() {
    console.log('launching server');
    this.serverProcess = childProcess.spawn(...);
    <strong class="bold">this.serverProcess.stderr.on('data', (data) =&gt; {</strong>
    <strong class="bold">  const trimmed = String(data).trim();</strong>
    <strong class="bold">  if (trimmed !== '') {</strong>
    <strong class="bold">    console.log(trimmed);</strong>
    <strong class="bold">  }</strong>
    <strong class="bold">});</strong>
    ...
    console.log(`started at ${this.baseUrl}`);
  }</pre></li>
<li>Now let’s move on to <strong class="source-inline">killServer</strong>, starting by adding a new package, <strong class="source-inline">tree-kill-promise</strong>, that will allow us to easily shut down the <span class="No-Break">server process:</span><pre class="source-code">
<strong class="bold">npm install --save-dev tree-kill-promise</strong></pre></li>
<li>Then add that as an import at the top of the same <span class="No-Break">world file:</span><pre class="source-code">
import kill from 'tree-kill-promise';</pre></li>
<li>Define the <strong class="source-inline">killServer</strong> method, <span class="No-Break">shown here:</span><pre class="source-code">
class PlaywrightWorld {
  ...
  <strong class="bold">killServer() {</strong>
    <strong class="bold">await kill(this.serverProcess.pid);</strong>
  <strong class="bold">}</strong>
}</pre></li>
<li>It’s time to launch the browser. Start by bringing in the following Playwright <strong class="source-inline">import</strong> statements at the top of <span class="No-Break">the file:</span><pre class="source-code">
import { chromium, request } from '@playwright/test';</pre></li>
<li>Then define the <strong class="source-inline">launchBrowser</strong> and <strong class="source-inline">closeBrowser</strong> functions, as shown in the <a id="_idIndexMarker452"/>following<a id="_idIndexMarker453"/> code. The crucial piece is that we then end up with the <strong class="source-inline">request</strong> and <strong class="source-inline">page</strong> objects, which are the exact same objects we have in our Playwright <span class="No-Break">end-to-end tests:</span><pre class="source-code">
class PlaywrightWorld {
  ...
  async launchBrowser() {
    this.browser = await chromium.launch();
    this.context = await this.browser.newContext({
      baseURL: this.baseUrl
    });
    this.request = await request.newContext({
      baseURL: `${this.baseUrl}api/`
    });
    this.page = await this.context.newPage();
  }
  async closeBrowser() {
    await this.browser.close();
  }
}</pre></li>
<li>With the world object complete, it’s time for the hooks. Add a new file named <strong class="source-inline">features/support/hooks.mjs</strong> and give it the <span class="No-Break">following content:</span><pre class="source-code">
import { Before, After } from '@cucumber/cucumber';
Before(async function () {
  await this.launchServer();
  await this.launchBrowser();
});
After(async function () {
  await this.killServer();
  this.closeBrowser();
});</pre></li>
</ol>
<p>That’s all <a id="_idIndexMarker454"/>the <a id="_idIndexMarker455"/>setup complete. The only remaining thing is the <span class="No-Break">step definitions.</span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Implementing the step definitions</h1>
<p>The final piece <a id="_idIndexMarker456"/>of the puzzle is the <strong class="source-inline">Given</strong>, <strong class="source-inline">When</strong>, and <strong class="source-inline">Then</strong> functions for matching feature steps with <span class="No-Break">their implementations.</span></p>
<p class="callout-heading">Checking your work as you go along</p>
<p class="callout">In this section we will speed through the definition, but make sure you verify each step is working by running Cucumber (with the <strong class="source-inline">npx @cucumber/cucumber</strong> command) after you’ve implemented <span class="No-Break">each function.</span></p>
<p>Let’s <span class="No-Break">do it!</span></p>
<ol>
<li>Create another new directory, <strong class="source-inline">features/support</strong>, and create a file named <strong class="source-inline">features/support/steps.mjs</strong>, which starts with the <span class="No-Break">following imports:</span><pre class="source-code">
import {
  Given,
  When,
  Then
} from '@cucumber/cucumber';</pre></li>
<li>Then implement the first <strong class="source-inline">Given</strong> step from our feature file. This one calls into the API using the <strong class="source-inline">this.request.post</strong> function from Playwright. Note the use of <strong class="source-inline">failOnStatusCode</strong>, which makes sure that Cucumber fails the test if we don’t get a <strong class="source-inline">200 OK</strong> <span class="No-Break">response back:</span><pre class="source-code">
Given(
  'An existing birthday for {string} on {string}',
  async function (name, dob) {
    await this.request.post('birthdays', {
      data: { name, dob },
      failOnStatusCode: true
    });
  }
);</pre></li>
<li>Now we’re on to the <strong class="source-inline">When</strong> steps. There are two of these; arguably, one could have been <strong class="source-inline">Given</strong>, but I think they work nicely as a group, given that they are both user actions. The first one simply calls <strong class="source-inline">this.page.goto</strong>, which you’ve also <span class="No-Break">seen before:</span><pre class="source-code">
When(
  'I navigate to the {string} page',
  async function (url) {
    await this.page.goto(url);
  }
);</pre></li>
<li>For the remaining<a id="_idIndexMarker457"/> steps, we will use our own <strong class="source-inline">BirthdayListPage</strong> page model object that we defined in <a href="B19611_07.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Tidying up Test Suites</em>. Start by importing that at the top of <span class="No-Break">the file:</span><pre class="source-code">
import {
  BirthdayListPage
} from '../../tests/BirthdayListPage.js';</pre></li>
<li>Then implement the next <strong class="source-inline">When</strong> step definition, which uses our battled-tested <strong class="source-inline">beginEditingFor</strong>, <strong class="source-inline">dateOfBirthField</strong>, and <span class="No-Break"><strong class="source-inline">saveButton</strong></span><span class="No-Break"> functions:</span><pre class="source-code">
When(
  'I edit the birthday for {string} to be {string}',
  async function (name, dob) {
    const birthdayListPage = new BirthdayListPage(
      this.page
    );
    await birthdayListPage.beginEditingFor(name);
    await birthdayListPage
      .dateOfBirthField()
      .fill(dob);
    await birthdayListPage.saveButton().click();
  }
);</pre></li>
<li>It’s time for the <strong class="source-inline">Then</strong> step definitions. These are the ones that have expectations. To begin, add an <strong class="source-inline">import</strong> statement for <strong class="source-inline">expect</strong> at the top of <span class="No-Break">the file:</span><pre class="source-code">
import { expect } from '@playwright/test';</pre></li>
<li>Implement the first <strong class="source-inline">Then</strong> clause, shown in the following code block. This checks that the new<a id="_idIndexMarker458"/> birthday is shown on <span class="No-Break">the page:</span><pre class="source-code">
Then(
  'the birthday for {string} should show {string}',
  async function (name, dob) {
    const birthdayListPage = new BirthdayListPage(
      this.page
    );
    await expect(
      birthdayListPage.entryFor(name)
    ).toContainText(dob);
  }
);</pre></li>
<li>Complete the step definitions with the final <span class="No-Break"><strong class="source-inline">Then</strong></span><span class="No-Break"> clause:</span><pre class="source-code">
Then(
  'the text {string} should not appear on the page',
  async function (text) {
    await expect(
      this.page.getByText(text)
    ).not.toBeVisible();
  }
);</pre></li>
<li>Running the tests now, you should see all of <span class="No-Break">them passing:</span><pre class="source-code">
work/birthdays % npx @cucumber/cucumber
launching server
started at http://localhost:4173/
.......
1 scenario (1 passed)
5 steps (5 passed)</pre></li>
</ol>
<p>You’ve now seen how to write a feature file using the Gherkin syntax, and how to write step definitions that use the same Playwright API that you’ve been using for your end-to-end-tests. You’ve<a id="_idIndexMarker459"/> also seen that the standard <strong class="source-inline">expect</strong> syntax can be used to write assertions that is used across all three types <span class="No-Break">of tests.</span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Summary</h1>
<p>This chapter covered how to use the Cucumber test runner to execute Gherkin feature files. Gherkin’s plain-English syntax makes this an important technique for bringing automated testing to the wider product <span class="No-Break">development team.</span></p>
<p>The feature files are backed by step definitions. These step definitions are implemented using the <strong class="source-inline">Given</strong>, <strong class="source-inline">When</strong>, and <strong class="source-inline">Then</strong> functions, which map Gherkin step descriptions to <span class="No-Break">JavaScript code.</span></p>
<p>You’ve seen how step definitions can re-use the existing Playwright API code to manage <span class="No-Break">browser interactions.</span></p>
<p>This completes our look at automated testing techniques. In <em class="italic">Part 3</em>, we’ll look at how to write unit tests for SvelteKit-specific features, starting with a chapter on strategies for <span class="No-Break">testing authentication.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer041">
<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Part 3: Testing SvelteKit Features</h1>
<p>This part takes a glance at some specific features that require careful testing. These chapters aren’t sequential as in the previous parts. Instead, they are discussions on how you might approach your testing. The code samples included focus only on the novel pieces that haven’t been covered in previous chapters. You can always refer to the online repository for <span class="No-Break">complete implementations.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B19611_14.xhtml#_idTextAnchor156"><em class="italic">Chapter 14</em></a>, <em class="italic">Testing Authentication</em></li>
<li><a href="B19611_15.xhtml#_idTextAnchor168"><em class="italic">Chapter 15</em></a>, <em class="italic">Test-Driving Svelte Stores</em></li>
<li><a href="B19611_16.xhtml#_idTextAnchor175"><em class="italic">Chapter 16</em></a>, <em class="italic">Test-Driving Service Workers</em></li>
</ul>
</div>
<div>
<div id="_idContainer042">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer043">
</div>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
</div></body></html>