<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor148"/>13</h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Adding Cucumber Tests</h1>
<p>Up until now, you have seen two types of automated tests: Vitest unit tests and Playwright end-to-end tests. This chapter adds a third type of test: <strong class="bold">Cucumber</strong> (<a href="https://cucumber.io">https://cucumber.io</a>).</p>
<p>Just like Playwright, Cucumber has its own test runner, which is typically set up to drive your application in the same way as Playwright does. The difference is that Cucumber tests are not written in JavaScript code.</p>
<p>Cucumber tests are contained within <em class="italic">feature files</em> that contain tests formatted in a special syntax known as <strong class="bold">Gherkin</strong>. These tests, known as <strong class="bold">features</strong> and organized into scenarios, read like plain English. That has a couple of advantages.</p>
<p>First, they can be written and understood by the whole team, not just developers. That means you can extend test-first practices outside of the development team.</p>
<p>Second, the absence of code encourages you to write tests that focus on user behavior rather than the technical details of the software. That, in turn, encourages you to build the right thing for your users.</p>
<p>How does Cucumber turn features into executable code? Well, take a look at an example line (or, step) from a feature file:</p>
<pre class="source-code">
When I navigate to the "/birthdays" page</pre>
<p>Cucumber takes this step and looks for a matching JavaScript-defined step definition. The step definition, in this case, looks like this:</p>
<pre class="source-code">
When(
  'I navigate to the {string} page',
  async function (url) { ... }
);</pre>
<p>Notice that the step definition has an associated code block. Once Cucumber finds a matching step definition, it executes that code block, supplying any parsed arguments. In this case, the <code>url</code> parameter will be provided as the <code>/birthdays</code> string. Cucumber also supports other data types, such as <code>int</code> and <code>bigdecimal</code> (<a href="https://github.com/cucumber/cucumber-expressions#parameter-types">https://github.com/cucumber/cucumber-expressions#parameter-types</a>).</p>
<p>We will cover the following key topics in this chapter:</p>
<ul>
<li>Creating the feature file</li>
<li>Setting up a Playwright world object</li>
<li>Implementing step definitions</li>
</ul>
<p>By the end of the chapter, you’ll be confident in adding Cucumber tests to your application.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start</a>.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Creating the feature file</h1>
<p>We begin with <a id="_idIndexMarker441"/>writing an example Cucumber feature file.</p>
<p>The Gherkin syntax that’s used to write features is characterized by the three words <em class="italic">Given</em>, <em class="italic">When</em>, and <em class="italic">Then</em>. These are analogous to the <em class="italic">Arrange</em>, <em class="italic">Act</em>, and <em class="italic">Assert</em> sections of all good unit tests, so they should feel familiar.</p>
<p>Let’s jump right in with our feature file and see what happens when we execute the test:</p>
<ol>
<li>Start by adding a new directory, <code>features</code>, with a new <code>features/birthdays.feature</code> file with the following content. It describes a user scenario in which the <em class="italic">Birthdays</em> application already supports editing a birthday. Here it is:<pre class="source-code">
Feature: Editing a birthday
  Scenario: Correcting the year of birth
    Given An existing birthday for "Hercules" on
      "1992-03-04"
    When I navigate to the "/birthdays" page
    And I edit the birthday for "Hercules" to be
      "1994-04-06"
    Then the birthday for "Hercules" should show
      "1994-04-06"
    And the text "1992-03-04" should not appear on the
      page</pre></li>
<li>Install Cucumber using the following command:<pre class="source-code">
<strong class="bold">npm install --save-dev @cucumber/cucumber</strong></pre></li>
<li>Then, go ahead and run the test with <code>npx @cucumber/cucumber</code>. You should see an <a id="_idIndexMarker442"/>output that starts like this:<pre class="source-code">
Failures:
1) Scenario: Correcting the year of birth #
     features/birthdays.feature:2
   ? Given An existing birthday for "Hercules" on
     "1992-03-04"
   Undefined. Implement with the following snippet:
     Given('An existing birthday for {string} on
     {string}', function (string, string2) {
        // Write code here that turns the phrase above
             into concrete actions
           return 'pending';
     });</pre></li>
</ol>
<p>Just as all good test runners should, Cucumber is telling us the next task: defining the step definition. But<a id="_idIndexMarker443"/> before we get there, we need to pull in the Playwright APIs.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Setting up a Playwright world object</h1>
<p>How does <a id="_idIndexMarker444"/>Cucumber execute your test? Just like<a id="_idIndexMarker445"/> with the Playwright tests, we need a running application server and a running browser to drive the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). In this section, we’ll write all the code that gets the environment ready for test execution.</p>
<p>Cucumber.js uses the concept of a <code>this</code> variable in each step. We also get access to it in special <code>Before</code> and <code>After</code> hooks, which are run before and after each scenario.</p>
<p>The world object should contain functions (and state) that allow you to drive the UI. Since you’ve already learned and used the Playwright API for locating objects on a page, it would be marvelous if we could use that same API. It turns out we can indeed do this. We can also use the same <code>expect</code> API we’re used to as well, and we’ll do that in the next section when we begin writing step definitions.</p>
<p>Here’s what we’ll do: we’ll build a world class named <code>PlaywrightWorld</code> that has the following functions:</p>
<ul>
<li><code>launchServer</code> and <code>killServer</code> for starting and stopping the server</li>
<li><code>launchBrowser</code> and <code>closeBrowser</code> for opening and closing a headless web browser, and for exposing the Playwright page and <code>request</code> APIs on our world object</li>
</ul>
<p>Then, we’ll use the <code>Before</code> and <code>After</code> hooks to start and stop both the server and browser.</p>
<p>One final note before we begin: our code files will use the <code>mjs</code> extension rather than <code>js</code>, to signify to <code>Cucumber.js</code> that these files use ECMAScript Module syntax.</p>
<p>Let’s begin:</p>
<ol>
<li>Start by creating a new file, <code>features/support/world.mjs</code>, with the following import definitions. We’ll add more later, but these are enough to get us started with launching the server:<pre class="source-code">
import * as childProcess from 'child_process';
import {
  setWorldConstructor
} from '@cucumber/cucumber';</pre></li>
<li>Now, define the <code>removeAnsiColorCodes</code> function. This is important for execution<a id="_idIndexMarker446"/> environments (Windows, primarily) that<a id="_idIndexMarker447"/> will return color codes in the <code>stdout</code> stream data:<pre class="source-code">
const removeAnsiColorCodes = (string) =&gt;
  string.replace(/\x1b\[[0-9;]+m/g, '');</pre></li>
<li>We’re ready to define the <code>PlaywrightWorld</code> class, starting with a single method, <code>launchServer</code>. That method ends with a call to <code>setWorldConstructor</code> that makes this the designated world class:<pre class="source-code">
class PlaywrightWorld {
  async launchServer() {
    console.log('launching server');
    this.serverProcess = childProcess.spawn(
      config.webServer.command,
      [],
      { shell: true, env: config.webServer.env }
    );
    this.baseUrl = await new Promise((resolve) =&gt; {
      this.serverProcess.stdout.on('data', (data) =&gt; {
      let text = removeAnsiColorCodes(String(data));
      let match = text.match(
        /http[s]?:\/\/[a-z]+:[0-9]+\//
      );
      if (match) {
        resolve(match[0]);
      }
    });
    console.log(`started at ${this.baseUrl}`);
  }
}
setWorldConstructor(PlaywrightWorld);</pre></li>
</ol>
<p>The code<a id="_idIndexMarker448"/> in our <code>launchServer</code> function<a id="_idIndexMarker449"/> is very crude, but it does the job. It reads the Playwright configuration file and pulls out the value of <code>config.webServer.command</code>, which on my project is this:</p>
<pre class="source-code">
<strong class="bold">npm run build &amp;&amp; npm run preview</strong></pre>
<p class="callout-heading">Launching the web server using Playwright config</p>
<p class="callout">Because this is a shell command, we must use the <code>detached</code> and <code>shell</code> properties when calling Node’s <code>childProcess.spawn</code> function.</p>
<p class="callout">Setting <code>env</code> means that any environment variables that Cucumber receives are also passed to this new shell. Once the server is started, we read the <code>stdout</code> data stream until we see a line that contains an HTTP URL. This is the URL of our running web server, so we parse that value and return it as the argument to <code>resolve</code>.</p>
<p class="callout">The use of the <code>Promise</code> object means that the thread will wait until the value is retrieved, and then set the world’s <code>baseUrl</code> property to this value.</p>
<ol>
<li value="4">Add the following error handling logic, which simply logs out any non-empty messages <a id="_idIndexMarker450"/>that appear on the <code>stderr</code> data <a id="_idIndexMarker451"/>stream:<pre class="source-code">
class PlaywrightWorld {
  async launchServer() {
    console.log('launching server');
    this.serverProcess = childProcess.spawn(...);
    <strong class="bold">this.serverProcess.stderr.on('data', (data) =&gt; {</strong>
    <strong class="bold">  const trimmed = String(data).trim();</strong>
    <strong class="bold">  if (trimmed !== '') {</strong>
    <strong class="bold">    console.log(trimmed);</strong>
    <strong class="bold">  }</strong>
    <strong class="bold">});</strong>
    ...
    console.log(`started at ${this.baseUrl}`);
  }</pre></li>
<li>Now let’s move on to <code>killServer</code>, starting by adding a new package, <code>tree-kill-promise</code>, that will allow us to easily shut down the server process:<pre class="source-code">
<strong class="bold">npm install --save-dev tree-kill-promise</strong></pre></li>
<li>Then add that as an import at the top of the same world file:<pre class="source-code">
import kill from 'tree-kill-promise';</pre></li>
<li>Define the <code>killServer</code> method, shown here:<pre class="source-code">
class PlaywrightWorld {
  ...
  <strong class="bold">killServer() {</strong>
    <strong class="bold">await kill(this.serverProcess.pid);</strong>
  <strong class="bold">}</strong>
}</pre></li>
<li>It’s time to launch the browser. Start by bringing in the following Playwright <code>import</code> statements at the top of the file:<pre class="source-code">
import { chromium, request } from '@playwright/test';</pre></li>
<li>Then define the <code>launchBrowser</code> and <code>closeBrowser</code> functions, as shown in the <a id="_idIndexMarker452"/>following<a id="_idIndexMarker453"/> code. The crucial piece is that we then end up with the <code>request</code> and <code>page</code> objects, which are the exact same objects we have in our Playwright end-to-end tests:<pre class="source-code">
class PlaywrightWorld {
  ...
  async launchBrowser() {
    this.browser = await chromium.launch();
    this.context = await this.browser.newContext({
      baseURL: this.baseUrl
    });
    this.request = await request.newContext({
      baseURL: `${this.baseUrl}api/`
    });
    this.page = await this.context.newPage();
  }
  async closeBrowser() {
    await this.browser.close();
  }
}</pre></li>
<li>With the world object complete, it’s time for the hooks. Add a new file named <code>features/support/hooks.mjs</code> and give it the following content:<pre class="source-code">
import { Before, After } from '@cucumber/cucumber';
Before(async function () {
  await this.launchServer();
  await this.launchBrowser();
});
After(async function () {
  await this.killServer();
  this.closeBrowser();
});</pre></li>
</ol>
<p>That’s all <a id="_idIndexMarker454"/>the <a id="_idIndexMarker455"/>setup complete. The only remaining thing is the step definitions.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Implementing the step definitions</h1>
<p>The final piece <a id="_idIndexMarker456"/>of the puzzle is the <code>Given</code>, <code>When</code>, and <code>Then</code> functions for matching feature steps with their implementations.</p>
<p class="callout-heading">Checking your work as you go along</p>
<p class="callout">In this section we will speed through the definition, but make sure you verify each step is working by running Cucumber (with the <code>npx @cucumber/cucumber</code> command) after you’ve implemented each function.</p>
<p>Let’s do it!</p>
<ol>
<li>Create another new directory, <code>features/support</code>, and create a file named <code>features/support/steps.mjs</code>, which starts with the following imports:<pre class="source-code">
import {
  Given,
  When,
  Then
} from '@cucumber/cucumber';</pre></li>
<li>Then implement the first <code>Given</code> step from our feature file. This one calls into the API using the <code>this.request.post</code> function from Playwright. Note the use of <code>failOnStatusCode</code>, which makes sure that Cucumber fails the test if we don’t get a <code>200 OK</code> response back:<pre class="source-code">
Given(
  'An existing birthday for {string} on {string}',
  async function (name, dob) {
    await this.request.post('birthdays', {
      data: { name, dob },
      failOnStatusCode: true
    });
  }
);</pre></li>
<li>Now we’re on to the <code>When</code> steps. There are two of these; arguably, one could have been <code>Given</code>, but I think they work nicely as a group, given that they are both user actions. The first one simply calls <code>this.page.goto</code>, which you’ve also seen before:<pre class="source-code">
When(
  'I navigate to the {string} page',
  async function (url) {
    await this.page.goto(url);
  }
);</pre></li>
<li>For the remaining<a id="_idIndexMarker457"/> steps, we will use our own <code>BirthdayListPage</code> page model object that we defined in <a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em>. Start by importing that at the top of the file:<pre class="source-code">
import {
  BirthdayListPage
} from '../../tests/BirthdayListPage.js';</pre></li>
<li>Then implement the next <code>When</code> step definition, which uses our battled-tested <code>beginEditingFor</code>, <code>dateOfBirthField</code>, and <code>saveButton</code> functions:<pre class="source-code">
When(
  'I edit the birthday for {string} to be {string}',
  async function (name, dob) {
    const birthdayListPage = new BirthdayListPage(
      this.page
    );
    await birthdayListPage.beginEditingFor(name);
    await birthdayListPage
      .dateOfBirthField()
      .fill(dob);
    await birthdayListPage.saveButton().click();
  }
);</pre></li>
<li>It’s time for the <code>Then</code> step definitions. These are the ones that have expectations. To begin, add an <code>import</code> statement for <code>expect</code> at the top of the file:<pre class="source-code">
import { expect } from '@playwright/test';</pre></li>
<li>Implement the first <code>Then</code> clause, shown in the following code block. This checks that the new<a id="_idIndexMarker458"/> birthday is shown on the page:<pre class="source-code">
Then(
  'the birthday for {string} should show {string}',
  async function (name, dob) {
    const birthdayListPage = new BirthdayListPage(
      this.page
    );
    await expect(
      birthdayListPage.entryFor(name)
    ).toContainText(dob);
  }
);</pre></li>
<li>Complete the step definitions with the final <code>Then</code> clause:<pre class="source-code">
Then(
  'the text {string} should not appear on the page',
  async function (text) {
    await expect(
      this.page.getByText(text)
    ).not.toBeVisible();
  }
);</pre></li>
<li>Running the tests now, you should see all of them passing:<pre class="source-code">
work/birthdays % npx @cucumber/cucumber
launching server
started at http://localhost:4173/
.......
1 scenario (1 passed)
5 steps (5 passed)</pre></li>
</ol>
<p>You’ve now seen how to write a feature file using the Gherkin syntax, and how to write step definitions that use the same Playwright API that you’ve been using for your end-to-end-tests. You’ve<a id="_idIndexMarker459"/> also seen that the standard <code>expect</code> syntax can be used to write assertions that is used across all three types of tests.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Summary</h1>
<p>This chapter covered how to use the Cucumber test runner to execute Gherkin feature files. Gherkin’s plain-English syntax makes this an important technique for bringing automated testing to the wider product development team.</p>
<p>The feature files are backed by step definitions. These step definitions are implemented using the <code>Given</code>, <code>When</code>, and <code>Then</code> functions, which map Gherkin step descriptions to JavaScript code.</p>
<p>You’ve seen how step definitions can re-use the existing Playwright API code to manage browser interactions.</p>
<p>This completes our look at automated testing techniques. In <em class="italic">Part 3</em>, we’ll look at how to write unit tests for SvelteKit-specific features, starting with a chapter on strategies for testing authentication.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Part 3: Testing SvelteKit Features</h1>
<p>This part takes a glance at some specific features that require careful testing. These chapters aren’t sequential as in the previous parts. Instead, they are discussions on how you might approach your testing. The code samples included focus only on the novel pieces that haven’t been covered in previous chapters. You can always refer to the online repository for complete implementations.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19611_14.xhtml#_idTextAnchor156"><em class="italic">Chapter 14</em></a>, <em class="italic">Testing Authentication</em></li>
<li><a href="B19611_15.xhtml#_idTextAnchor168"><em class="italic">Chapter 15</em></a>, <em class="italic">Test-Driving Svelte Stores</em></li>
<li><a href="B19611_16.xhtml#_idTextAnchor175"><em class="italic">Chapter 16</em></a>, <em class="italic">Test-Driving Service Workers</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>