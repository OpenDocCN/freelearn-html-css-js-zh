<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Our RESTful API</h1>
                
            
            
                
<p>A web application is composed of different layers; upto now, you have been developing the client-side layer of the FIFA World Cup project. However, just presenting a user interface to the user is not enough. We need to process some business logic in order to provide an appropriate user experience to our users, such as subscribing to the next matches, retrieving the roaster for the user's favorite team, managing login, and more.</p>
<p>In order to have a full web application, we should implement the following server-side missing pieces in our project:</p>
<ul>
<li>The RESTful API layer</li>
<li>Database layer</li>
</ul>
<p>Once upon a time, developers used to implement all the layers in a single project, and this was because of the adoption of popular open source web platforms such as XAMPP, which configures a PHP/MySQL environment in just a few seconds. So, developers used to write the client-side web pages in PHP and add HTML code in the same file, mixing server-side with client-side code.</p>
<p class="mce-root">With the passing of the years, new techniques were introduced. Now, developers separate client side and server side in different projects, and in addition to separating the project, these layers are deployed in different domains. All of this was possible thanks to the introduction of new client-side and server-side frameworks. All this brings a new challenge—communication—so having separate projects now requires a way to exchange information with each other. RESTful APIs become the right solution to communicate between the client side and backend using the HTTP protocol as the mean of data transportation between these layers.</p>
<p class="mce-root">The following illustration depicts the new way to create web apps:</p>
<div><img src="img/6302213e-bacf-4734-9e9e-c79966070af4.png" style="width:34.33em;height:13.50em;"/></div>
<p>In this chapter, we will implement the RESTful API layer. For this, we will use Node.js and JavaScript to build a robust RESTful API. You will also learn the concepts and how to design robust APIs using an open source framework on top of Node.js called ExpressJS. We will also explore the new MEAN stack and learn about the technologies behind it and why we decided to baptize it as the new MEAN stack. Lastly, you will learn how to improve your RESTful APIs using new techniques to improve the developer experience in your team.</p>
<p>So, we will cover the following topics:</p>
<ul>
<li>Understanding RESTful</li>
<li>Designing APIs</li>
<li>Creating an API with Node.js</li>
<li>Improving our API with ExpressJS</li>
<li>Coding our project</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding RESTful</h1>
                
            
            
                
<p>In this section, we will go through the components HTTP and <strong>CRUD</strong> (<strong>Create</strong>, <strong>Retrieve, Update</strong> and <strong>Delete</strong>), which form the basic building block of RESTful. These components together make possible the communication between different applications over the internet in a distributed environment via a well-defined API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding HTTP</h1>
                
            
            
                
<p>Every time you are navigating on the internet, you are using the HTTP. Even when you are booking a ride on Uber, you are using HTTP. In fact, HTTP is present in almost all the applications that you use on a daily basis.</p>
<p>HTTP is based on the principle of client-server communication. It means that every time you want to access an information or resources, you have to send a request object and the server will send you all the requested information into a response object. The following diagram explains this communication:</p>
<div><img src="img/c8fb1186-0c9e-44a9-abca-42a8d1275bcc.png" style="width:27.17em;height:12.42em;"/></div>
<p>So, in order to really understand how to design a robust HTTP RESTful API we need to know how URLs works and learn about the HTTP protocol.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">URLs</h1>
                
            
            
                
<p>URLs are the way how applications give access to their information assets by defining well-structured endpoints. For example, if you want to search about Peru, you would probably access from a web browser the following URL: <a href="https://www.google.com/search?q=Peru">https://www.google.com/search?q=Peru</a>. Let's divide the previous URL into parts and analyze it in details:</p>
<div><img src="img/919e96ad-ca50-4934-9841-fbdec902b46e.png" style="width:28.33em;height:5.92em;"/></div>
<p>From the diagram, we see that there are basically four parts:</p>
<ul>
<li><strong>Protocol</strong>: This is the HTTP for non-secure connections or HTTPS for secure connections</li>
<li><strong>Domain</strong>: The registered domain that will be translated to the server IP, which contains this resource</li>
<li><strong>Path</strong>: This allows us to separate our resources into segments</li>
<li><strong>Query String</strong>: This is optional but allows us to provide additional data</li>
</ul>
<p>We will always use URLs to access resources hosted on another server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Verbs</h1>
                
            
            
                
<p>The HTTP verbs are the magic behind RESTful APIs. Let's use an example to understand how HTTP verbs works. We want to create an API to manage products; our first version might look like this:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Endpoint</strong></td>
<td><strong>HTTP verb</strong></td>
<td><strong>Goal</strong></td>
</tr>
<tr>
<td><kbd>http://myapp/api/createProduct</kbd></td>
<td>POST</td>
<td>To create a product</td>
</tr>
<tr>
<td><kbd>http://myapp/api/updateProduct/P1</kbd></td>
<td>POST</td>
<td>To update an existing product</td>
</tr>
<tr>
<td><kbd>http://myapp/api/listProducts</kbd></td>
<td>GET</td>
<td>To retrieve the complete list of products</td>
</tr>
<tr>
<td><kbd>http://myapp/api/viewProductDetails/P1</kbd></td>
<td>GET</td>
<td>To retrieve a single product</td>
</tr>
<tr>
<td><kbd>http://myapp/api/deleteProduct/P1</kbd></td>
<td>POST</td>
<td>To delete a product</td>
</tr>
</tbody>
</table>
<p> </p>
<p>From the preceding table, you can note that we need to remember five endpoints, and we are using two HTTP verbs: POST and GET. It might be understood that every time we want to retrieve information, a GET verb is used, and to perform operations that will modify the existing information in our system, a POST verb is used.</p>
<p>So, let's make our endpoints easy to remember using HTTP verbs. After applying a simple refactor, now our table might look as follows:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 38.7052%"><strong>Endpoint</strong></td>
<td style="width: 9.36639%"><strong>HTTP verb</strong></td>
<td style="width: 50.6887%"><strong>Goal</strong></td>
</tr>
<tr>
<td style="width: 38.7052%"><kbd>http://myapp/api/products</kbd></td>
<td style="width: 9.36639%">
<p class="mce-root">GET</p>
<p>POST</p>
</td>
<td style="width: 50.6887%">
<p class="mce-root">To retrieve the full list of products.</p>
<p>To create a new product.</p>
</td>
</tr>
<tr>
<td style="width: 38.7052%"><kbd>http://myapp/api/products/P1</kbd></td>
<td style="width: 9.36639%">
<p class="mce-root">GET</p>
<p>DELETE</p>
<p>PUT</p>
</td>
<td style="width: 50.6887%">
<p class="mce-root">To retrieve a single product.</p>
<p>To delete an existing product.</p>
<p>To modify an existing product. In this case, you must send the full document, not just the fields that have changed.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, we are using the HTTP verbs, and we have reduced from five endpoints to just two. HTTP verbs are sent with every request to the server, so servers can use them to identify what operation a user wants to perform, sending the correct endpoint and verb.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Headers</h1>
                
            
            
                
<p>The headers contain additional information about every request that we send to the server. The headers that you will use more frequently during development are these:</p>
<ul>
<li><strong>Content</strong>-<strong>Type</strong>: To tell the server which type of response you are waiting for</li>
<li><strong>Accept</strong>: To tell the server which type of content the client can process</li>
<li><strong>Authorization</strong>: To send a piece of information to validate the identity of the information consumer</li>
</ul>
<p>Of course, there are more headers. Refer to <a href="https://developer.mozilla.org/es/docs/Web/HTTP/Headers">https://developer.mozilla.org/es/docs/Web/HTTP/Headers</a> to learn more about the HTTP headers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Body</h1>
                
            
            
                
<p>The body is present in the request and response objects. Every time you want to create a new entry in your database, you have to pass the information in the body section of your HTTP Request. The data in the body section is known as <strong>payload</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CRUD over HTTP</h1>
                
            
            
                
<p>As you might have noted when we talked about HTTP verbs, every verb is related to a CRUD operation. Basically, these four operation refers to the basic functions that all the database engines perform.</p>
<p>So, mapping each HTTP verb with its respective CRUD operation, we will have the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>HTTP Verb</strong></td>
<td><strong>CRUD Operation</strong></td>
<td><strong>GOAL</strong></td>
</tr>
<tr>
<td>POST</td>
<td>Create</td>
<td>Create or Insert a new element in our app</td>
</tr>
<tr>
<td>GET</td>
<td>Retrieve</td>
<td>Retrieve or Read elements from our app</td>
</tr>
<tr>
<td>PUT</td>
<td>Update</td>
<td>Update or Modify any existing element into our app</td>
</tr>
<tr>
<td>DELETE</td>
<td>Delete</td>
<td>Delete or Remove any existing element into our app</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing APIs</h1>
                
            
            
                
<p>Now that we are clear about what HTTP is and the building blocks behind it, we need to design a friendly and robust API. Another advantage of this is that we will improve the developer experience in our organization by having a well-defined API.</p>
<p>API documentation is another key practice that you have to apply in every API development you will do. With documentation, the development team and API consumers are aware of the full functionality of the API, because they are defined in an easy-to-read format. For example, the financial team and the logistics team in an organization can share their API documentation between them and start working on a possible integration solution immediately because they now know the full details of the APIs.</p>
<p>Let's learn how to design robust APIs by understanding the API first movement and other design concepts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API first</h1>
                
            
            
                
<p><strong>API first</strong> is one of the most important concepts you should keep in mind while developing a new product or a service, you have to think of it as if it were the user interface for programmers. In fact, APIs are the way how you can expose the functionalities of your products in a distributed big system.</p>
<p>Nowadays, techniques and approaches such as cloud applications and microservices are becoming adopted everywhere, and they suggest a new way to develop software. With microservices, you have to split your application into different independent services; each service contains a specific set of related features of your application, such as taking some Amazon APIs as an example, we can have something like the following:</p>
<div><img src="img/42b387e7-abdf-4f3c-833d-9e0527cd5b4d.png" style="width:44.00em;height:24.83em;"/></div>
<p>As you can see, there are different services that need to exchange information and functionalities. All of those have to define a consistent and self-explained API that the other services have to use in order to either perform an operation in another service that it is not able to do or a client-side application will invoke the APIs directly to access some information.</p>
<p>The main understanding behind API first is that before you implement any code or UI design in your system, you should design your API in such a way that even if you don't have any user interface, developers should be able to navigate and access the information and functionality into your application data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API design</h1>
                
            
            
                
<p>To design a robust, self-explained, friendly, and easy-to-use API, we will follow the set of best practices that have been used and implemented over the years by the internet gurus. Thankfully, some great developers and architects had defined a set of rules that we will cover in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nouns as paths</h1>
                
            
            
                
<p>Have you ever seen some API endpoints that contain a full sentence to access a resource? Some examples might be the following:</p>
<pre>http://myshop.com<strong>/createNewProduct</strong><strong><br/></strong>http://myshop.com<strong>/deleteProduct</strong><br/>http://myshop.com<strong>/updateProduct<br/></strong>http://myshop.com<strong>/getProductDetail/P01</strong><br/>http://myshop.com<strong>/getProductComments/P01</strong></pre>
<p>The first thing to keep in mind is that you should never use verbs in your endpoints. Instead, use nouns in plural to refer to a resource into your API Endpoint. For example, the preceding example can be refactored to this:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="mce-root"><strong>The Rest way</strong> - <strong>Not recommended</strong></p>
</td>
<td><strong>The RESTful way</strong> - <strong>Recommended</strong></td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>http://myshop.com/createNewProduct</kbd></p>
<p class="mce-root"><kbd>http://myshop.com/deleteProduct</kbd></p>
<p><kbd>http://myshop.com/updateProduct</kbd></p>
</td>
<td><kbd>http://myshop.com/products</kbd></td>
</tr>
<tr>
<td><kbd>http://myshop.com/getProductDetail/P01</kbd></td>
<td><kbd>http://myshop.com/products/P01</kbd></td>
</tr>
<tr>
<td><kbd>http://myshop.com/getProductComments/P01</kbd></td>
<td><kbd>http://myshop.com/products/P01/comments</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>A good practice is not to extend the path depth higher than three paths. For example, use this:</p>
<pre>http://myshop.com<strong>/products/P01/comments</strong></pre>
<p>Do that instead of the following:</p>
<pre>http://myshop.com<strong>/products/details/P01/comments/today</strong></pre>
<p>If you want to extend your API to perform additional operations such as getting the first 10 messages published today, use query strings instead of paths. Consider this example:</p>
<pre>http://myshop.com/products/P01/comments<strong>?day=today&amp;count=10</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP verbs for CRUD</h1>
                
            
            
                
<p>Now that you have designed clean endpoints for your API, it is time to take advantage of what we learned about HTTP verbs. You might be asking yourself how do you differentiate when you want to create, update, or delete a product if you are using the same endpoint, <kbd>/products</kbd>? This is the case where we use HTTP verbs. For example, for the <kbd>/products</kbd> endpoint, we will have something like the following verbs:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Endpoint</strong></td>
<td><strong>HTTP Verb</strong></td>
<td><strong>Goal</strong></td>
</tr>
<tr>
<td><kbd>/products</kbd></td>
<td>POST</td>
<td>To create a new product</td>
</tr>
<tr>
<td><kbd>/products</kbd></td>
<td>PUT</td>
<td>To update an existing product</td>
</tr>
<tr>
<td><kbd>/products</kbd></td>
<td>DELETE</td>
<td>To delete an existing product</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So from the preceding table, you can note that the key differentiator is the HTTP Verb. In short, an endpoint is composed by one path and an HTTP Verb.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API documentation</h1>
                
            
            
                
<p>When you are working on a real project, the number of endpoints you will need to design will be higher. You will need a way to remember all your endpoints and the reason they were designed. Similarly, we are confident that documenting software is extremely important for us to remember what a piece of code is supposed to do; API documentation allows us to tell the API consumers how they can use our API by documenting the endpoints and other additional metadata, such as the ones listed:</p>
<ul>
<li>Endpoint path</li>
<li>HTTP verbs</li>
<li>The expected headers</li>
<li>The expected body structure</li>
<li>The expected results</li>
</ul>
<p>There is an awesome open source tool that helps you document and share the documentation with your APIs called <strong>Swagger</strong>. We encourage you to visit the official site and play with it at <a href="https://swagger.io">https://swagger.io</a>.</p>
<p>A possible documentation might be just a simple table that contains the data used in the request and responses. For example, the documentation to create a new product might be this:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Path</strong></td>
<td><strong>Products</strong></td>
</tr>
<tr>
<td>HTTP method</td>
<td>POST</td>
</tr>
<tr>
<td>Expected Results</td>
<td>HTTP 200 OK status code</td>
</tr>
<tr>
<td>Expected Input Headers</td>
<td>Content-type: <kbd>application/json</kbd></td>
</tr>
<tr>
<td>Expected Input Body</td>
<td>{<kbd>id</kbd>: <kbd>Integer</kbd>, <kbd>name</kbd>: <kbd>String</kbd>, <kbd>price</kbd>: <kbd>Decimal</kbd>}</td>
</tr>
<tr>
<td>Goal</td>
<td>Use this endpoint to create a new product</td>
</tr>
<tr>
<td>Authorization</td>
<td>Required Authorization Token</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Having the knowledge of how to design self-explained APIs and how to use HTTP to create endpoints, let's move forward to implement a RESTful API with Node.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an API with Node.js</h1>
                
            
            
                
<p>It's time to start having fun and code our RESTful API. Until now you have seen the theory behind APIs and that knowledge is very important to understand the following sections. So, you might be wondering, why Node.js? The short answer is because it is cool! Haha, just kidding. Node.js has evolved since its creation in 2009 by <em>Ryan Dahl</em>. Node.js is used for leading companies over the world, such as LinkedIn, Facebook, Amazon, and more.</p>
<p>Node.js is not limited to API Development. In fact, you might create any kind of project from command-line tools to <strong>Internet of Things</strong> (<strong>IoT</strong>) applications. So, let's start learning about the advantages of Node.js and coding our API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node advantages</h1>
                
            
            
                
<p>Node.js has a lot of advantages; we will explore the more important ones in the following subtopics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous</h1>
                
            
            
                
<p>In most programming languages, I/O operations are performed synchronously. Synchronous execution will block the program flow until the blocking operation finishes its execution. For example, the following Python code is executed synchronously and blocks the execution:</p>
<pre>file_content = open("my_file.txt") // takes 10 seconds<br/>file_content_2 = open("my_other_files.txt") // takes 20 seconds<br/>print file_content<br/>print file_content_2   </pre>
<p>The total execution time will be approximately 30 seconds. That is because of the I/O Blocking operation. If we represent the synchronous execution as a timeline:</p>
<div><img src="img/75eedb21-1266-4f3b-9f80-69072f285285.png" style="width:31.92em;height:18.83em;"/></div>
<p>Now if we execute the same operation in an asynchronous way using JavaScript:</p>
<pre>open("my_file.txt", (file_content) =&gt; {<br/>  console.log(file_content)<br/>})<br/><br/>open("my_file_2.txt", (file_content_2) =&gt; {<br/>  console.log(file_content_2)<br/>})</pre>
<p>From the previous code, you can note that we use a callback to process the content of the file. Callbacks are functions that are invoked after some events occur. For example, <kbd>(file_content)=&gt; {}</kbd> will be called once the content of <kbd>my_file.txt</kbd> is ready to use.</p>
<p>The two <kbd>open()</kbd> statements will be executed at the same time. Executing the statements in parallel will help us reduce the execution time. For example, let's see the timeline execution for this asynchronous code:</p>
<div><img src="img/33587146-6ad1-4b24-aec8-aeb06e94b7f1.png" style="width:30.83em;height:18.92em;"/></div>
<p class="mce-root">Now the execution will be just 20 seconds, and, with this, we have improved our application performance. This is one of the key advantages that Node.js brings up to the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Single-thread</h1>
                
            
            
                
<p>Every time a new user request arrives at the backend server it will create a new thread for the request, this is the classic behavior for backend servers that don't use Node.js. Once the server sends the response to the user, it releases the thread. Handling just a few threads is not an issue but, imagine what would happen if you need to handle millions of users at the same time? Let's graph this issue:</p>
<div><img src="img/46d145e2-1374-4ba8-b5f2-af04627ef2d8.png" style="width:40.75em;height:17.08em;"/></div>
<p>Node.js does not have this issue because of its single-thread strategy. Instead of starting a new thread for each request, it will use the same main thread to handle all the requests and will be supported by the event-loop. The following diagram depicts this scenario:</p>
<div><img src="img/9301b979-ae59-454d-aaf8-a35bbeaaf4aa.png" style="width:45.00em;height:17.25em;"/></div>
<p>This scenario is better for CPU utilization; multiple threads allow NodeJS to take advantage of multi-core CPUs. However, we need more than a simple chapter to talk about them. We strongly encourage you to visit the official Node.js site at <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>.</p>
<p>Now it's time to code a simple HTTP Server and start the fun part!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple HTTP Server</h1>
                
            
            
                
<p>It is time to start coding and see how we can implement a simple HTTP Server using Node.js. So, open your Terminal and in the working directory of your choice, go ahead and create a new folder called <kbd>my-server</kbd>:</p>
<pre><strong>$ mkdir my-server</strong><br/><strong>$ cd my-server</strong></pre>
<p>Once you move into the <kbd>my-server</kbd> folder, we will need to initialize an NPM module, so run the following command:</p>
<pre><strong>$ npm init -y</strong><br/><br/><strong>{</strong><br/><strong>  "name": "my-server",</strong><br/><strong>  "version": "1.0.0",</strong><br/><strong>  "main": "index.js",</strong><br/><strong>  "scripts": {</strong><br/><strong>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</strong><br/><strong>  },</strong><br/><strong>  "keywords": [],</strong><br/><strong>  "author": "",</strong><br/><strong>  "license": "ISC",</strong><br/><strong>  "description": ""</strong><br/><strong>}</strong><br/><br/></pre>
<p>Now it's time to create the <kbd>server.js</kbd><em> </em>file by executing the <kbd>touch server.js</kbd> command in your Terminal. This file will contain the code for our server. We will start importing the HTTP module:</p>
<pre>const http = require('http')</pre>
<p>We import any module using the <kbd>require</kbd> built-in function, and we define the <kbd>http</kbd> variable to house the module reference. Let's implement a simple handler by writing the following code:</p>
<pre>const myRequestHandler = (<strong>request</strong>, <strong>response</strong>) =&gt; {<br/>    <strong>response.end</strong>('Hello From our Node.js Server !!')<br/>}</pre>
<p>As you can see, a handler is just a function that declares two parameters:</p>
<ul>
<li><kbd>request</kbd>: Used to read the information sent by the client</li>
<li><kbd>response</kbd>: Used to send information to the client</li>
</ul>
<p>Our handler is using the <kbd>response</kbd> parameter to send our friendly message to the client. Now it's time to create a server instance using the <kbd>http</kbd> reference we declared earlier:</p>
<pre>const server = <strong>http.createServer</strong>(<strong>myRequestHandler</strong>)</pre>
<p>We are creating an empty server that does not perform any operation. To make our server useful, we pass the <kbd>request</kbd> handler we declared earlier, <kbd>myRequestHandler</kbd>. With this, our server is able to send our <kbd>Hello</kbd> message every time some client sends an HTTP request to our server. To finish our server implementation, we need to listen to the client request:</p>
<pre>server.listen(5000, () =&gt; {<br/>    console.log("server is running on port 5000")<br/>})</pre>
<p>That's all! Now that we have a simple HTTP, execute the <kbd>node server.js</kbd> command to run the server. Let's test things out. Head over to <a href="http://localhost:5000">http://localhost:5000</a> and you should see something like the following:</p>
<div><img src="img/24f16fb3-ea3a-41a1-adbb-69356cf27bd9.png" style="width:34.33em;height:20.42em;"/></div>
<p>Now you know how to create a simple HTTP server using the native HTTP module that comes along with Node.js. However, in order to create a powerful RESTful backend, we need to use a more sophisticated framework.</p>
<p>In the next section, we will enhance our simple server using Express.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving our API with Express.js</h1>
                
            
            
                
<p>Express.js is an open source web framework created on top of Node.js. We can implement our REST API using the Node.js HTTP module, but we will have to write a lot of code to handle a simple user request. Express.js is very flexible and provides a set of features that will allow us to create robust APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coding our server</h1>
                
            
            
                
<p>It's time to create our FIFA backend folder and start working on the API development. Open your Terminal and run the following command:</p>
<pre><strong>$ mkdir wc-backend</strong><br/><strong>$ cd wc-backend</strong><br/><strong>$ npm init -y</strong><br/><br/><strong>{</strong><br/><strong>  "name": "wc-backend",</strong><br/><strong>  "version": "1.0.0",</strong><br/><strong>  "description": "",</strong><br/><strong>  "main": "index.js",</strong><br/><strong>  "scripts": {</strong><br/><strong>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</strong><br/><strong>  },</strong><br/><strong>  "keywords": [],</strong><br/><strong>  "author": "",</strong><br/><strong>  "license": "ISC"</strong><br/><strong>}</strong><br/><br/></pre>
<p>Once the initialization is done, let's install Express.js. Execute the following command:</p>
<pre><strong>$ npm install --save express</strong></pre>
<p>Next, create the <kbd>server.js</kbd> file in the root folder and write the following code:</p>
<pre>const express = require('express')<br/>const app = <strong>express()</strong><br/><br/>app.<strong>use</strong>((req, res) =&gt; {<br/>    res.<strong>send</strong>("Hello!")<br/>})<br/><br/>app.<strong>listen</strong>(3000, () =&gt; {<br/>    console.log('running on port: 3000')<br/>})</pre>
<p>We start importing the <kbd>express</kbd> module and instantiation of an express application into the <kbd>app</kbd> variable. Next, we use the application instance to configure a simple request handler using the <kbd>app.use</kbd> function. Into this function, we pass another function as a parameter that has two parameters for the request and response: <kbd>req</kbd> and <kbd>res</kbd>. To send a simple message, we use the <kbd>res</kbd> parameter.</p>
<p>Once the server application instance is configured, we bring it to life by calling its <kbd>listen</kbd> function and passing the HTTP port where it will listen to new HTTP requests:</p>
<pre><strong>$ node server.js</strong></pre>
<p>We strongly recommend you to use <strong>nodemon</strong> in development. The nodemon will restart your node application every time it detects a change in your source code automatically. To install nodemon, just execute the <kbd>npm install -g nodemon</kbd> command. To run your server, use the <kbd>nodemon server.js</kbd> command.</p>
<p>Let's test it by opening <kbd>http://localhost:3000</kbd> in your browser or using an HTTP client command-line tool. Consider the given example:</p>
<pre><strong>$ curl http://localhost:3000</strong><br/><br/><strong>Hello!</strong></pre>
<p>So far so good! Let's define a route path to make a self-explanatory API. Apply the following change to the <kbd>server.js</kbd> file:</p>
<pre>...<br/>app.use(<strong>'/hello',</strong> (req, res) =&gt; {<br/>    res.send("Hello!")<br/>})<br/>...</pre>
<p>Now, head over to <kbd>http://localhost:3000/hello</kbd> and you should see the same <kbd>Hello!</kbd> message. You can navigate to <kbd>http://localhost:3000</kbd> to see what you get after the change:</p>
<pre><strong>$ curl http://localhost:3000/hello</strong><br/><br/>Hello!</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using routes</h1>
                
            
            
                
<p>Routes are the magic behind our RESTful API. If you remember when we talked about HTTP verbs, RESTful is composed by combining CRUD operations with the HTTP verbs. Express.js makes easy the definition of these RESTful way. For example, open the <kbd>server.js</kbd><em> </em>file and apply the following change:</p>
<pre>...<br/>app.<strong>get</strong>('/hello'<strong>,</strong> (req, res) =&gt; {<br/>    res.send("Hello!")<br/>})<br/>...</pre>
<p>As you can see, we changed <kbd>use</kbd> for <kbd>get</kbd>. As you are so smart, you know that <kbd>get</kbd> refers to the GET HTTP verb, so let's define our RESTful routes for our Teams API. In the <kbd>server.js</kbd><em>, </em>apply the following changes:</p>
<pre>...<br/><br/>app.<strong>get</strong>('/teams', (req, res) =&gt; {<br/>    res.send("<em>To retrieve the list of teams</em>")<br/>})<br/><br/>app.<strong>post</strong>('/teams', (req, res) =&gt; {<br/>    res.send("<em>To create a new team</em>")<br/>})<br/><br/>app.<strong>put</strong>('/teams', (req, res) =&gt; {<br/>    res.send("<em>To update an existing team</em>")<br/>})<br/><br/>app.<strong>delete</strong>('/teams', (req, res) =&gt; {<br/>    res.send("<em>To delete an existing team</em>")<br/>})<br/><br/>...</pre>
<p>Once we apply these changes, it's time to test them. Run the following commands in your Terminal:</p>
<pre><strong>$ curl -X POST http://localhost:3000/teams</strong><br/><em>  To create a new team<br/></em><br/><strong>$ curl -X GET http://localhost:3000/teams</strong><br/>  <em>To retrieve the list of teams</em></pre>
<p>Cool! our RESTful API is responding correctly. Note that we use the <kbd>-X [HTTP Verb]</kbd> to tell curl which HTTP verb we want to use for the given request. Now that we are ready with the main skeleton of our API, we need to structure our project in a consistent way because we will create a group of files and should always organize our source code. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coding our project</h1>
                
            
            
                
<p>Here we are! We will implement the code of our project. Our application is composed of three domains:</p>
<ul>
<li><strong>Teams</strong>: To manage the information of all the teams that participate in the World Cup competition</li>
<li><strong>Matches</strong>: To manage the information of all the Matches during the competition</li>
<li><strong>Security</strong>: To manage the information of the users and permissions</li>
</ul>
<p>The teams and matches follow the same implementation with a few variants. For that reason, in this section, we will write the code to implement the <kbd>Team</kbd> domain and then expose it via our API, and you will be able to implement the code for the <kbd>Match</kbd> domains yourself. Of course, the complete source code is available in the <a href="https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app">https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app</a> GitHub repository.</p>
<p>So, having said that. Let's start!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Our project structure</h1>
                
            
            
                
<p>Let's start by creating the Project structure for our source code. Create the following directories and files in your working directory, as shown in the following screenshot:</p>
<div><img src="img/26946484-c911-44b4-93e6-93f432fb096c.png" style="width:16.58em;height:25.00em;"/></div>
<p>The <kbd>src</kbd> folder contains three subfolders: <kbd>models</kbd>, <kbd>routes</kbd>, and <kbd>config</kbd>. In this chapter, we will just use the <kbd>routes</kbd> folder and the <kbd>teams-api.js</kbd> file. The other two will be explored in the next chapter when we talk about Databases and MongoDB.</p>
<p>The goal of the routes folder is to host all the API Routes declaration. We have declared our routes in the <kbd>server.js</kbd> file; it might be a good idea if we are working on a small project, but it is not a good idea for a big project, which will have a lot of routes declarations. For that reason, a good strategy is to separate the routes per API functionality; for example, teams-API, matches-API, and auth-API. With this, we will have more easy-to-read and easy-to-maintain code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Teams API</h1>
                
            
            
                
<p>Before we start coding, we have to design our API first. The following table contains the documentation for the API we will implement:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Route</strong></td>
<td><strong>HTTP Verb</strong></td>
<td><strong>Goal</strong></td>
<td><strong>Responses</strong></td>
</tr>
<tr>
<td><kbd>/teams</kbd></td>
<td>GET</td>
<td>List all the teams</td>
<td>Http 200 - OK</td>
</tr>
<tr>
<td><kbd>/teams</kbd></td>
<td>POST</td>
<td>
<p class="mce-root">Create a new team with body</p>
<p class="mce-root">{<kbd>name</kbd>: String}</p>
</td>
<td>Http 201 - Created</td>
</tr>
<tr>
<td><kbd>/teams/:id</kbd></td>
<td>GET</td>
<td>Get a single team</td>
<td>
<p class="mce-root">Http 200 -OK</p>
<p>Http 404 - Not Found</p>
</td>
</tr>
<tr>
<td><kbd>/teams/:id</kbd></td>
<td>PUT</td>
<td>Update an existing team</td>
<td>
<p class="mce-root">Http 200 -OK</p>
<p>Http 404 - Not Found</p>
</td>
</tr>
<tr>
<td><kbd>/teams/:id</kbd></td>
<td>DELETE</td>
<td>Delete an existing team</td>
<td>
<p class="mce-root">Http 200 -OK</p>
<p>Http 404 - Not Found</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Keeping this in mind, let's begin with the fun part!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring the JSON Parser</h1>
                
            
            
                
<p>We will start by configuring our server to be able to parse JSON. This means that Express.js will automatically parse the data that flows in and out of the HTTP Request. The following diagram explains this:</p>
<div><img src="img/bf677a86-a721-409c-ae8c-0519f0504280.png" style="width:41.25em;height:13.92em;"/></div>
<p>As you can see, all the requests will be intercepted by the <strong>JSON Parser</strong>. The <strong>JSON Parser</strong> is better known as a <strong>middleware</strong>. A middleware is just a simple function that is processed before another function. For example, the <strong>GET /teams</strong> function is supposed to be the only function that should be called in every request, but as we have configured the <strong>JSON Parser</strong>, the <strong>GET /teams</strong> will be invoked once the <strong>JSON Parser</strong> function is completed.</p>
<p>To configure this in our code, first we need to install it. Run the <kbd>npm install --save body-parser</kbd> in your terminal and apply the following changes:</p>
<pre>const express = require('express')<br/><strong>const bodyParser = require('body-parser')</strong><br/>const app = express()<br/><br/><strong>app.use(bodyParser.json())</strong><br/><br/>app.get('/teams', (req, res) =&gt; {<br/><br/>    <strong>const teams = [{ "name": "Peru" }, {"name": "Russia"}]</strong><br/><br/>    <strong>res.json</strong>(teams)<br/>})<br/>...</pre>
<p>First, we import the <kbd>body-parser</kbd> module. Then, we configure the application to use our <kbd>bodyParser.json()</kbd> using its <kbd>app.use</kbd> function. All the middleware are configured by calling this function.</p>
<p>Lastly, to test whether the JSON Parser is working, we define the <kbd>teams</kbd> variable containing two teams with their respective names. To send the <kbd>teams</kbd>, we use <kbd>res.json</kbd> instead of <kbd>res.send</kbd>. Let's check the results by executing the following command:</p>
<pre><strong>$ curl -X GET http://localhost:3000/teams</strong><br/><br/><strong>[{"name":"Peru"}, {"name":"Russia"}]</strong></pre>
<p>Now that our API is able to receive and send JSON, let's move our routes to its own file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring routes</h1>
                
            
            
                
<p>We previously created the <kbd>teams-api.js</kbd> file in the <kbd>routes</kbd><em> </em>folder. Open that file and apply the following changes:</p>
<pre>const express = require('express')<br/><strong>const api = new express.Router()</strong><br/><br/>let <strong>teams</strong> = [<br/>    { id: 1, name: "Peru"},<br/>    { id: 2, name: "Russia"}<br/>]</pre>
<p>First, we import the <kbd>express</kbd> module. From this module, we are declaring the <kbd>api</kbd> variable, which is an instance of <kbd>express.Router</kbd>. A <kbd>teams</kbd> variable has been created in order to host some fake data for the teams. We will use this router to configure our CRUD/HTTP handlers, as follows:</p>
<pre>api<br/>  .route(<strong>'/teams'</strong>)<br/>  .<strong>get</strong>((req, res) =&gt; {<br/>    <strong>res.json</strong>(teams)<br/>  })<br/>  .<strong>post</strong>((req, res) =&gt; {<br/>    <br/>  })<br/><br/>app.listen(3000, () =&gt; {<br/>...</pre>
<p>Using the <kbd>api</kbd> route variable, we define the <kbd>'/teams'</kbd> path as root for the HTTP handlers. In the <kbd>get</kbd> handler, we are just sending the list of teams as the response.</p>
<p>Lastly, we need to export the <kbd>api</kbd> route to be used in the <kbd>server.js</kbd><em> </em>file:</p>
<pre>...<br/>module.exports = api</pre>
<p>Once we are ready, open the <kbd>server.js</kbd><em> </em>file to apply the following changes that will configure the server to use this route:</p>
<pre>const express = require('express')<br/>const bodyParser = require('body-parser')<br/><strong>const teamsApi = require('./src/routes/teams-api')</strong><br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/><strong>app.use(teamsApi)<br/><br/>...</strong></pre>
<p>First, we import the Teams API module from the relative path into our project and use the <kbd>app.use</kbd> function to configure our routes. Let's test things out; run the following command in your Terminal:</p>
<pre><strong>$ curl -X GET localhost:3000/teams</strong><br/><br/><strong>[{"id": 1, "name":"Peru"},{"id": 2, "name":"Russia"}]</strong></pre>
<p>Cool! Now we have our code clean and everything is working as we expect. It's time to write some code to implement the POST, PUT, and DELETE handlers. We will use the fake <kbd>teams</kbd> variable to add data in memory until we learn how to use a real database in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a team</h1>
                
            
            
                
<p>To create a team, we need to implement the POST handler. The data to the new team will be sent into the <kbd>body</kbd> parameter into the HTTP Request. Apply the following changes to the <kbd>teams-api.js</kbd><em> </em>file:</p>
<pre>...<br/>api<br/>  .route('/teams')<br/>  ...<br/>  .post((req, res) =&gt; {<br/>    <strong>let team = req.body<br/></strong><br/><strong>    teams.push(team)<br/></strong><br/><strong>    res.status(201).json(team)</strong><br/>  })<br/>  ...<br/>...</pre>
<p>First, we read the data from the <kbd>req.body</kbd> property. Then, we insert the new element into the <kbd>teams</kbd> array. Lastly, we send the <kbd>teams</kbd> array with the new team added and specify the HTTP status 201, which means Resource Created.</p>
<p>You can find the full list of HTTP statuses at <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>.</p>
<p>To test things out, we will call our API using the following command:</p>
<pre><strong>$ curl -X POST -H "Content-Type: application/json" -d '{"id":3, "name": "Brasil"}' localhost:3000/teams</strong></pre>
<p>Our command is a little weird this time. As we are using JSON, we have to explicitly tell the HTTP Request that we are sending JSON data, so we use the <kbd>-H</kbd> header option. To send the information, we use the <kbd>-d</kbd> data option. That's all! It looks difficult but it is not.</p>
<p>Now you can use the GET method to list all the teams and see the new team added to our list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving the list</h1>
                
            
            
                
<p>We already have the list handler, but the listing is not enough. Apart from retrieving the full list, we will need to retrieve a single team. To do this, we will need to add a new GET route and learn how to use params. Apply the following changes into the <kbd>teams-api.js</kbd>:</p>
<pre>...<br/>api<br/>  .route('/teams')<br/>...<br/><br/>api<br/>  <strong>.route('/teams/:id')</strong><br/>  .get((req, res) =&gt; {<br/>      const id = <strong>req.params.id</strong><br/><br/>      for(let team of teams) {<br/>          if (team.id == id)<br/>            <strong>return res.json(team)</strong><br/>      }<br/><br/>      <strong>return res.status(404).send('team not found')</strong><br/>  })<br/><br/>module.exports = api</pre>
<p>First, we declare a new route, which now contains a dynamic param—<kbd>/teams/:api</kbd>. We said dynamic because, of course, it can take any value that will be available as an attribute of the <kbd>req.params</kbd> object. Note that the name you use for your param will be created as a property, for example, <kbd>req.params.id</kbd> in this case.</p>
<p>Next, we create a simple <kbd>for</kbd> loop that iterates across the full list of teams and looks for the team that has the same <kbd>id</kbd> we passed in the route param. If a team is found, we send the team by calling the <kbd>res.json(team)</kbd> statement. As we want to quit the handler immediately after we send the response, we use <kbd>return</kbd> to exit the handler. If a team is not found, we send an error message and mark the response with the HTTP <kbd>status</kbd> 404, which means Resource not found.</p>
<p>Lastly, to test our implementation, execute the following command:</p>
<pre><strong>$ curl http://localhost:3000/teams/1</strong><br/><strong>  {"id":1,"name":"Peru"}</strong><em><br/><br/></em><strong>$ curl http://localhost:3000/teams/2</strong><br/>  <strong>{"id":2,"name":"Russia"}</strong></pre>
<p>Keep in mind that by default, curl always sends a -X GET request if no HTTP verb has been explicitly defined.</p>
<p>Let's continue with our last two implementations for PUT and DELETE.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating a Team</h1>
                
            
            
                
<p>The update process is a combination of two processes—the search for a team and the update process itself. In the previous implementation, we wrote the code to look up an existing team. So, let's reuse the same code by defining a function that can be used for retrieve, update, and delete. Open the <kbd>teams-api.js</kbd><em> </em>file and apply the following changes:</p>
<pre>...<br/>let teams = [<br/>    { id: 1, name: "Peru"},<br/>    { id: 2, name: "Russia"}<br/>]<br/><br/><strong>function lookupTeamIndex(id) {</strong><br/><strong>    for(var i = 0; i &lt; teams.length; i++) {</strong><br/><strong>        let team = teams[i]</strong><br/><strong>        if (team.id == id)</strong><br/><strong>          return i</strong><br/><strong>    }</strong><br/><strong>    return -1</strong><br/><strong>}</strong><br/><br/>api<br/>  .route('/teams')<br/>...</pre>
<p>We created the <kbd>lookupTeam</kbd> function, which expects for the <kbd>id</kbd> as a param and will return a valid team index if it is found. Otherwise, it will return -1. Now we need to refactor our handle to retrieve a Team:</p>
<pre>...<br/>api<br/>  .route('/teams/:id')<br/>  .get((req, res) =&gt; {<br/>      let id = req.params.id<br/>      <strong>let index = lookupTeamIndex(id)</strong><br/><br/><strong>      if (index !== -1)</strong><br/><strong>        return res.json(teams[index])</strong><br/><br/>      return res.status(404).send('team not found')<br/>  })<br/>...</pre>
<p>Having done that, let's implement our update handler. Apply the following changes in the same <kbd>teams-api</kbd><em> </em>file:</p>
<pre>...<br/>api<br/>  .route('/teams/:id')<br/>  .get((req, res) =&gt; {<br/>     ...<br/>  })<br/>  <strong>.put((req, res) =&gt; {</strong><br/><strong>      const id = req.params.id</strong><br/><strong>      const index = lookupTeam(id)</strong><br/><br/><strong>      if (index !== -1) {</strong><br/><strong>        const team = teams[index]</strong><br/><br/><strong>        team.name = req.body.name</strong><br/><strong>        teams[index] = team</strong><br/><br/><strong>        return res.json(team)</strong><br/><strong>      }</strong><br/><br/><strong>      return res.status(404).send('team not found')</strong><br/><strong>  })</strong><br/>...</pre>
<p>So we define a <kbd>.put</kbd> route and look up for a team by passing the <kbd>id</kbd> param. If a valid index is returned, we save the team instance in the <kbd>team</kbd> variable and apply the change to its <kbd>name</kbd> property by reading the data from the <kbd>request.body</kbd> object and finally, we send the updated team. If there is not a valid index for the ID passed, we return a <kbd>Not Found</kbd> message.</p>
<p>Execute the following command to test things out:</p>
<pre><strong>$ curl -X PUT -H "Content-Type: application/json" -d '{"name": "Brasil"}' localhost:3000/teams/999</strong><br/><br/><strong>Team not found</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a Team</h1>
                
            
            
                
<p>The <kbd>delete</kbd> process is similar to the <kbd>update</kbd>. First, we need to retrieve a valid index from the <kbd>teams</kbd> array and then remove it from there. Open the <kbd>teams-api.js</kbd><em> </em>file and apply the following changes:</p>
<pre>...<br/>api<br/>  .route('/teams/:id')<br/>  .get((req, res) =&gt; {<br/>     ...<br/>  })<br/>  .put((req, res) =&gt; {<br/>     ...<br/>  })<br/>  <strong>.delete((req, res) =&gt; {</strong><br/><strong>    const id = req.params.id</strong><br/><strong>    const index = lookupTeam(id)</strong><br/><strong>    const team = teams[index]</strong><br/><br/><strong>    if (index !== -1) {</strong><br/><strong>      teams.splice(index, 1)</strong><br/><strong>      return res.send(team)</strong><br/><strong>    }</strong><br/><br/><strong>    return res.status(404).send('team not found')</strong><br/><strong>  })</strong><br/>...</pre>
<p>So we define a <kbd>.delete</kbd> route and look up for a team by passing the <kbd>id</kbd> param. If a valid index is returned, we save the team instance in the <kbd>team</kbd> variable. Next, we delete the element from the array using the <kbd>splice(index, 1)</kbd> expression. Lastly, we return the deleted <kbd>team</kbd> just for the information purposes.</p>
<p>We are done! We have implemented a RESTful API that exposes HTTP handlers for our Teams feature. We need to apply security to our routes and other advanced features. We will learn all about that in subsequent chapters. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we explored the API's world and understood how APIs are implemented using the HTTP Protocol and CRUD operations. This great combination enables the exchange of information easier than before.</p>
<p>We also learned how to create an API using Node.js and saw how easy it is to build a RESTful API using one of the most popular open source web frameworks—Express.js.</p>
<p>In the next chapter, we will integrate our API with MongoDB in order to save information in a real database instead of sending fake data. It's getting better.</p>


            

            
        
    </body></html>