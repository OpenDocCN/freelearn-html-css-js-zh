["```js\nwhile (y >= t) y = y - 3; \n```", "```js\nexport const enum SyntaxKind { \n    Unknown, \n    EndOfFileToken, \n    SingleLineCommentTrivia, \n    MultiLineCommentTrivia, \n    NewLineTrivia, \n    WhitespaceTrivia, \n    ShebangTrivia, \n    ConflictMarkerTrivia, \n    NumericLiteral, \n    StringLiteral, \n    JsxText, \n    //... \n```", "```js\nfunction Symbol(this: Symbol, flags: SymbolFlags, name: __String) { \n    this.flags = flags; \n    this.escapedName = name; \n    this.declarations = undefined; \n    this.valueDeclaration = undefined; \n    this.id = undefined; \n    this.mergeId = undefined; \n    this.parent = undefined; \n}\n```", "```js\ninterface Person { \n    name: string; \n} \n\ninterface Person { \n    surname: string; \n} \n\nconst person: Person = { name: \"Remo\", surname: \"Jansen\" }; \n```", "```js\ninterface Weapon { \n    tryHit(fromDistance: number): boolean; \n} \n\nclass Katana implements Weapon { \n    public tryHit(fromDistance: number) { \n        return fromDistance <= 2; \n    } \n} \n\nclass Ninja { \n    private _weapon: Weapon; \n    public constructor(weapon: Weapon) { \n        this._weapon = weapon; \n    } \n    public fight(fromDistance: number) { \n        return this._weapon.tryHit(fromDistance); \n    } \n} \n\nconst ninja = new Ninja(new Katana()); \nninja.fight(\"5\"); \n```", "```js\ninterface Weapon { \n    tryHit(fromDistance: number): boolean; \n} \n```", "```js\nNumberKeyword \npos:43 \nstart:44 \nend:50 \nflags:0 \nkind:133 \n```", "```js\nexport interface Weapon { \n    tryHit(fromDistance: number): boolean; \n} \n\nexport interface Named { \n    name: string; \n} \n```", "```js\nimport { Weapon, Named } from \"./interfaces\"; \n\nexport class BaseWeapon { \n    damage = 25; \n} \n\nexport class Katana extends BaseWeapon implements Weapon, Named  { \n    name = \"Katana\"; \n    public tryHit(fromDistance: number) { \n        return fromDistance <= 2; \n    } \n} \n```", "```js\nimport { Weapon } from \"./interfaces\"; \n\nexport class Ninja { \n    private _weapon: Weapon; \n    public constructor(weapon: Weapon) { \n        this._weapon = weapon; \n    } \n    public fight(fromDistance: number) { \n        return this._weapon.tryHit(fromDistance); \n    } \n} \n```", "```js\nimport { Ninja } from \"./ninja\"; \nimport { Katana } from \"./katana\"; \n\nconst ninja = new Ninja(new Katana()); \n\nninja.fight(5); \n```", "```js\nimport { Ninja } from \"./ninja\"; \nimport { Katana } from \"./katana\"; \n\nconst ninja = new Ninja(new Katana()); \n\nninja.fight(\"5\"); \n```", "```js\nimport * as ts from \"typescript\"; \n```", "```js\nconst options = { \n    module: ts.ModuleKind.CommonJS, \n    target: ts.ScriptTarget.ES5, \n}; \n```", "```js\nconst program = ts.createProgram( \n    [ \n        \"./app/interfaces.ts\", \n        \"./app/ninja.ts\", \n        \"./app/katana.ts\", \n        \"./app/main.ts\" \n    ], \n    options \n); \n```", "```js\nconst checker = program.getTypeChecker(); \n```", "```js\ninterface Result { \n    fileName: string; \n    classes: string[]; \n    interfaces: string[]; \n} \n\nconst entities = program.getSourceFiles().map(file => { \n\n    if ( \n        file.fileName.indexOf(\"lib.d.ts\") !== -1 || \n        file.fileName.indexOf(\"node_modules\") !== -1 \n    ) { \n        return null; \n    } \n\n    const result = { \n        fileName: file.fileName, \n        classes: [] as string[], \n        interfaces: [] as string[] \n    }; \n\n    const visit = (node: ts.Node) => { \n        if (node.kind === ts.SyntaxKind.ClassDeclaration) { \n            // Find class identifier \n            node.getChildren().forEach(n => { \n                if (n.kind === ts.SyntaxKind.Identifier) { \n                    const name = (n as ts.Identifier).getFullText(); \n                    result.classes.push(name); \n                } \n            }); \n        } else if (node.kind === ts.SyntaxKind.InterfaceDeclaration) { \n            // Find interface identifier \n            node.getChildren().forEach(n => { \n                if (n.kind === ts.SyntaxKind.Identifier) { \n                    const name = (n as ts.Identifier).getFullText(); \n                    result.interfaces.push(name); \n                } \n            }); \n        } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) { \n            // Iterate module nodes \n            ts.forEachChild(node, visit); \n        } \n    }; \n\n    ts.forEachChild(file, visit); \n    return result; \n\n}).filter(e => e !== null) as Result[]; \n```", "```js\nentities.forEach(e => { \n    console.log(chalk.cyan(` \n        FILE: ${e.fileName}n \n        CLASSES: ${e.classes.length > 0 ? e.classes : \"N/A\"}n \n        INTERFACES: ${e.interfaces.length > 0 ? e.interfaces : \"N/A\"}n \n    `)); \n}); \n```", "```js\nimport chalk from \"chalk\"; \nimport Ast, { DiagnosticMessageChain } from \"ts-simple-ast\"; \n```", "```js\nfunction getAst(tsConfigPath: string, sourceFilesPath: string) { \n  const ast = new Ast({ \n    tsConfigFilePath: tsConfigPath, \n    addFilesFromTsConfig: false \n  }); \n  ast.addExistingSourceFiles(sourceFilesPath); \n  return ast; \n} \n```", "```js\nconst myAst = getAst(\"./tsconfig.json\", \"./app/*.ts\"); \nconst files = myAst.getSourceFiles(); \n```", "```js\nconst entities = files.map(f => { \n  return { \n    fileName: f.getFilePath(), \n    classes: f.getClasses().map(c => c.getName()), \n    interfaces: f.getInterfaces().map(i => i.getName()) \n  }; \n}); \n```", "```js\nentities.forEach(e => { \n  console.log( \n    chalk.cyan(` \n        FILE: ${e.fileName}n \n        CLASSES: ${e.classes.length > 0 ? e.classes : \"N/A\"}n \n        INTERFACES: ${e.interfaces.length > 0 ? e.interfaces : \"N/A\"}n \n    `) \n  ); \n}); \n```", "```js\nimport chalk from \"chalk\"; \nimport Ast, { DiagnosticMessageChain } from \"ts-simple-ast\"; \n```", "```js\nfunction getAst(tsConfigPath: string, sourceFilesPath: string) { \n  const ast = new Ast({ \n    tsConfigFilePath: tsConfigPath, \n    addFilesFromTsConfig: false \n  }); \n  ast.addExistingSourceFiles(sourceFilesPath); \n  return ast; \n} \n```", "```js\nfunction getErrors(ast: Ast) { \n\n  const diagnostics = ast.getDiagnostics(); \n\n  function dmcToString(dmc: DiagnosticMessageChain, msg: string = \"\"): string { \n    const messageText = dmc.getMessageText(); \n    const code = dmc.getCode(); \n    msg += `${code} ${messageText}n`; \n    const next = dmc.getNext(); \n    return next ? dmcToString(next, msg) : msg; \n  } \n\n  const errors = diagnostics.map(diagnostic => { \n    const code = diagnostic.getCode(); \n    const sourceOrUndefined = diagnostic.getSourceFile(); \n    const source = sourceOrUndefined ? sourceOrUndefined.getFilePath() : \"\"; \n    const line = sourceOrUndefined \n      ? sourceOrUndefined.getLineNumberFromPos(diagnostic.getStart() || 0) \n      : \"\"; \n    const stringOrDMC = diagnostic.getMessageText(); \n    const messageText = \n      typeof stringOrDMC === \"string\" ? stringOrDMC : dmcToString(stringOrDMC); \n    return ` \n            ERROR CODE: ${code} \n            DESCRIPTION: ${messageText} \n            FILE: ${source} \n            LINE: ${line} \n        `; \n  }); \n\n  return errors; \n} \n\nconst myAst = getAst(\"./tsconfig.json\", \"./app/broken.ts\"); \n\ngetErrors(myAst).forEach(err => console.log(chalk.red(err))); \n```", "```js\nimport chalk from \"chalk\"; \nimport Ast, { DiagnosticMessageChain } from \"ts-simple-ast\"; \n\nfunction getAst(tsConfigPath: string, sourceFilesPath: string) { \n    const ast = new Ast({ \n      tsConfigFilePath: tsConfigPath, \n      addFilesFromTsConfig: false \n    }); \n    ast.addExistingSourceFiles(sourceFilesPath); \n    return ast; \n} \n\nconst myAst = getAst(\"./tsconfig.json\", \"./app/*.ts\"); \nconst files = myAst.getSourceFiles(); \n\nfiles.forEach(file => { \n\n    // Find all classes \n    const classes = file.getClasses(); \n\n    // Find class by name \n    const class1 = file.getClass(\"Katana\"); \n\n    // Find class with no constructors \n    const firstClassWithConstructor = file.getClass( \n        c => c.getConstructors().length > 0 \n    ); \n\n    // Add a class \n    const classDeclaration = file.addClass({ \n        name: \"ClassName\" \n    }); \n\n    // Get extends \n    const extendsExpression = classDeclaration.getExtends(); \n\n    // Set extends \n    classDeclaration.setExtends(\"BaseClass\"); \n\n    // Remove extends \n    classDeclaration.removeExtends(); \n\n    // Get derived classes \n    const derivedClasses = classDeclaration.getDerivedClasses(); \n\n    // Remove one class \n    if (classDeclaration) { \n        classDeclaration.remove(); \n    } \n\n    // Get instance methods \n    const instanceMethods = classDeclaration.getInstanceMethods(); \n\n    // Get static methods \n    const staticMethods = classDeclaration.getStaticMethods(); \n\n    // Add method \n    const method = classDeclaration.addMethod( \n        { isStatic: true, name: \"myMethod\", returnType: \"string\" } \n    ); \n\n    // Remove method \n    method.remove(); \n\n    // Get instance properties \n    const instanceProperties = classDeclaration.getInstanceProperties(); \n\n    // Get static properties \n    const staticProperties = classDeclaration.getStaticProperties(); \n\n    // Add a property \n    const property = classDeclaration.addProperty({ isStatic: true, name: \"prop\", type: \"string\" }); \n\n    // Remove property \n    property.remove(); \n\n}); \n```", "```js\nimport chalk from \"chalk\"; \nimport Ast, { DiagnosticMessageChain } from \"ts-simple-ast\"; \n\nfunction getAst(tsConfigPath: string, sourceFilesPath: string) { \n    const ast = new Ast({ \n      tsConfigFilePath: tsConfigPath, \n      addFilesFromTsConfig: false \n    }); \n    ast.addExistingSourceFiles(sourceFilesPath); \n    return ast; \n} \n\nconst myAst = getAst(\"./tsconfig.json\", \"./app/*.ts\"); \nconst files = myAst.getSourceFiles(); \n```", "```js\nfiles.forEach(file => { \n\n  const functionDeclaration = file.getFunction(\"someFunction\"); \n\n  if (functionDeclaration) { \n\n    // Is exported \n    functionDeclaration.isExported(); \n    functionDeclaration.isNamedExport(); \n    functionDeclaration.isDefaultExport(); \n\n    // Has export keyword \n    functionDeclaration.hasExportKeyword(); \n    functionDeclaration.hasDefaultKeyword(); \n\n    // Access export keywords \n    functionDeclaration.getExportKeyword(); \n    functionDeclaration.getDefaultKeyword(); \n\n    // Set is export \n    functionDeclaration.setIsDefaultExport(true);  \n    functionDeclaration.setIsDefaultExport(false); \n\n    // Set is exported \n    functionDeclaration.setIsExported(true);  \n    functionDeclaration.setIsExported(false); \n\n  } \n\n  // Get all imports \n  const imports = file.getImportDeclarations(); \n\n  // Add import \n  const importDeclaration = file.addImportDeclaration({ \n      defaultImport: \"MyClass\", \n      moduleSpecifier: \"./file\" \n  }); \n\n  // Remove import \n  importDeclaration.remove(); \n\n  // Get default import \n  const defaultImport = importDeclaration.getDefaultImport(); \n\n  // Get named imports \n  const namedImports = importDeclaration.getNamedImports(); \n\n  // Add named import \n  const namedImport = importDeclaration.addNamedImport({ \n      name: \"MyClass\", \n      alias: \"MyAliasName\" // alias is optional \n  }); \n\n  // Remove named import \n  namedImport.remove(); \n\n}); \n```", "```js\nmyAst.getLanguageService(); \n```", "```js\nimport chalk from \"chalk\"; \nimport { flatten, join } from \"lodash\"; \nimport Ast, { DiagnosticMessageChain } from \"ts-simple-ast\"; \nimport * as ts from \"typescript\"; \n\nfunction getAst(tsConfigPath: string, sourceFilesPath: string) { \n    const ast = new Ast({ \n      tsConfigFilePath: tsConfigPath, \n      addFilesFromTsConfig: false \n    }); \n    ast.addExistingSourceFiles(sourceFilesPath); \n    return ast; \n} \n\nconst myAst = getAst(\"./tsconfig.json\", \"./app/*.ts\"); \nconst languageService = myAst.getLanguageService(); \nconst files = myAst.getSourceFiles(); \nconst interfaceDeclarations = flatten(files.map(f => f.getInterfaces())); \n```", "```js\nconst result = interfaceDeclarations.map(interfaceDeclaration => { \n\n    const interfaceName = interfaceDeclaration.getName(); \n\n    const implementations = languageService.getImplementations( \n        interfaceDeclaration.getNameNode() \n    ); \n\n    const implementationNames = implementations.map(implementation => { \n        const children = implementation.getNode().getChildren(); \n        const identifier = children.filter( \n            child => child.getKind() === ts.SyntaxKind.Identifier \n        )[0]; \n        const implementationName = identifier.getText(); \n        return implementationName; \n    }); \n\n    return { \n        interface: interfaceName, \n        implementations: implementationNames \n    }; \n\n}); \n```", "```js\nconsole.log( \n    result.forEach( \n        o => console.log( \n            `- ${o.interface} is implemented by ${join(o.implementations, \",\")}` \n        ) \n    ) \n); \n```", "```js\n- Weapon is implemented by Katana \n- Named is implemented by Katana \n```", "```js\nimport * as fs from \"fs\"; \nimport { flatten, join } from \"lodash\"; \nimport * as path from \"path\"; \nimport * as request from \"request\"; \nimport Ast, * as SimpleAST from \"ts-simple-ast\"; \nimport * as ts from \"typescript\"; \n```", "```js\ninterface MethodDetails { \n  name: string; \n} \n\ninterface PropertyDetails { \n  name: string; \n} \n```", "```js\nconst templates = { \n  url: (dsl: string) => `http://yuml.me/diagram/scruffy/class/${dsl}`, \n  composition: \"+->\", \n  implementsOrExtends: (abstraction: string, implementation: string) => { \n    return ( \n      `${templates.plainClassOrInterface(abstraction)}` + \n      `^-${templates.plainClassOrInterface(implementation)}` \n    ); \n  }, \n  plainClassOrInterface: (name: string) => `[${name}]`, \n  colorClass: (name: string) => `[${name}{bg:skyblue}]`, \n  colorInterface: (name: string) => `[${name}{bg:palegreen}]`, \n  class: (name: string, props: PropertyDetails[], methods: MethodDetails[]) => { \n    const pTemplate = (property: PropertyDetails) => `${property.name};`; \n    const mTemplate = (method: MethodDetails) => `${method.name}();`; \n    return ( \n      `${templates.colorClass(name)}` + \n      `[${name}|${props.map(pTemplate)}|${methods.map(mTemplate)}]` \n    ); \n  }, \n  interface: ( \n    name: string, \n    props: PropertyDetails[], \n    methods: MethodDetails[] \n  ) => { \n    const pTemplate = (property: PropertyDetails) => `${property.name};`; \n    const mTemplate = (method: MethodDetails) => `${method.name}();`; \n    return ( \n      `${templates.colorInterface(name)}` + \n      `[${name}|${props.map(pTemplate)}|${methods.map(mTemplate)}]` \n    ); \n  } \n}; \n```", "```js\nfunction getAst(tsConfigPath: string, sourceFilesPaths?: string[]) { \n  const ast = new Ast({ \n    tsConfigFilePath: tsConfigPath, \n    addFilesFromTsConfig: !Array.isArray(sourceFilesPaths) \n  }); \n  if (sourceFilesPaths) { \n    ast.addExistingSourceFiles(sourceFilesPaths); \n  } \n  return ast; \n} \n```", "```js\nfunction emitClass(classDeclaration: SimpleAST.ClassDeclaration) { \n\n  const className = classDeclaration.getSymbol()!.getName(); \n  const propertyDeclarations = classDeclaration.getProperties(); \n  const methodDeclarations = classDeclaration.getMethods(); \n\n  const properties = propertyDeclarations.map(property => { \n      const sym = property.getSymbol(); \n      if (sym) { \n          return { \n              name: sym.getName() \n          }; \n      } \n  }).filter((p) => p !== undefined) as PropertyDetails[]; \n\n  const methods = methodDeclarations.map(method => { \n    const sym = method.getSymbol(); \n    if (sym) { \n        return { \n            name: sym.getName() \n        } \n    } \n  }).filter((p) => p !== undefined) as MethodDetails[]; \n\n  return templates.class(className, properties, methods); \n} \n```", "```js\nfunction emitInterface(interfaceDeclaration: SimpleAST.InterfaceDeclaration) { \n\n  const interfaceName = interfaceDeclaration.getSymbol()!.getName(); \n  const propertyDeclarations = interfaceDeclaration.getProperties(); \n  const methodDeclarations = interfaceDeclaration.getMethods(); \n\n  const properties = propertyDeclarations.map(property => { \n      const sym = property.getSymbol(); \n      if (sym) { \n          return { \n              name: sym.getName() \n          } \n      } \n  }).filter((p) => p !== undefined) as PropertyDetails[]; \n\n  const methods = methodDeclarations.map(method => { \n      const sym = method.getSymbol(); \n      if (sym) { \n          return { \n              name: sym.getName() \n          } \n      } \n  }).filter((p) => p !== undefined) as MethodDetails[]; \n\n  return templates.interface(interfaceName, properties, methods); \n} \n```", "```js\nfunction emitInheritanceRelationships( \n  classDeclaration: SimpleAST.ClassDeclaration \n) { \n\n  const className = classDeclaration.getSymbol()!.getName(); \n  const extended =  classDeclaration.getExtends(); \n  const implemented =  classDeclaration.getImplements(); \n  let heritageClauses: HeritageClause[] = []; \n\n  if (extended) { \n      const identifier = extended.getChildrenOfKind(ts.SyntaxKind.Identifier)[0]; \n      if (identifier) { \n          const sym = identifier.getSymbol(); \n          if (sym) { \n              heritageClauses.push( \n                  { \n                      clause: sym.getName(), \n                      className \n                  } \n              ); \n          } \n      } \n  } \n\n  if (implemented) { \n      implemented.forEach(i => { \n          const identifier = i.getChildrenOfKind(ts.SyntaxKind.Identifier)[0]; \n          if (identifier) { \n              const sym = identifier.getSymbol(); \n              if (sym) { \n                  heritageClauses.push( \n                      { \n                          clause: sym.getName(), \n                          className \n                      } \n                  ); \n              } \n          } \n      }); \n  } \n\n  return flatten(heritageClauses).map((c: HeritageClause) => \n    templates.implementsOrExtends(c.clause, c.className) \n  ); \n\n} \n```", "```js\nfunction render(dsl: string) { \n  const download = (uri: string, filename: string, callback: () => void) => { \n    request.head(uri, (err, res, body) => { \n      request(uri) \n        .pipe(fs.createWriteStream(filename)) \n        .on(\"close\", callback); \n    }); \n  }; \n\n  const url = templates.url(dsl); \n  const file = `uml_diagram_${new Date().getTime()}.png`; \n  const absolutePath = path.join(__dirname, file); \n\n  download(url, file, () => \n    console.log(`Saved UML diagram available at ${absolutePath}`) \n  ); \n} \n```", "```js\nfunction yUML(tsConfigPath: string, sourceFilesPaths: string[]) { \n  const ast = getAst(tsConfigPath, sourceFilesPaths); \n  const files = ast.getSourceFiles(); \n\n  const declarations = files.map(f => { \n    return { \n      fileName: f.getFilePath(), \n      classes: f.getClasses(), \n      interfaces: f.getInterfaces() \n    }; \n  }); \n\n  const entities = declarations.map(d => { \n    const classes = d.classes.map(emitClass); \n    const interfaces = d.interfaces.map(emitInterface); \n    const inheritanceRelationships = d.classes.map( \n      emitInheritanceRelationships \n    ); \n    return [...classes, ...interfaces, ...inheritanceRelationships]; \n  }); \n\n  return join(flatten(entities), \",\"); \n} \n```", "```js\nconst yuml = yUML(\"./tsconfig.json\", [ \n  \"./app/interfaces.ts\", \n  \"./app/ninja.ts\", \n  \"./app/katana.ts\", \n  \"./app/main.ts\" \n]); \n```", "```js\nrender(yuml); \n```"]