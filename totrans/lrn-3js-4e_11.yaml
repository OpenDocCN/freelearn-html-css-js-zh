- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Render Postprocessing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染后处理
- en: 'In this chapter, we’ll look at one of the main features of Three.js that we
    haven’t touched upon yet: render postprocessing. With render postprocessing, you
    can add additional effects to your scene after it is rendered. For instance, you
    could add an effect that makes the scene look like it is shown on an old TV, or
    you could add blur and bloom effects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Three.js的一个主要特性，我们之前尚未涉及：渲染后处理。通过渲染后处理，你可以在场景渲染后添加额外的效果。例如，你可以添加一个使场景看起来像是在旧电视上显示的效果，或者你可以添加模糊和光晕效果。
- en: 'The main points we’ll discuss in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的主要内容包括以下几项：
- en: Setting up Three.js for postprocessing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后处理设置Three.js
- en: Some basic postprocessing passes provided by Three.js, such as `BloomPass` and
    `FilmPass`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Three.js提供的某些基本后处理步骤，例如`BloomPass`和`FilmPass`
- en: Applying effects to part of a scene using masks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮罩将效果应用于场景的一部分
- en: Using `ShaderPass` to add even more basic postprocessing effects, such as sepia
    filters, mirror effects, and color adjustments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ShaderPass`添加更多基本的后处理效果，例如棕褐色滤镜、镜像效果和色彩调整
- en: Using `ShaderPass` for various blurring effects and more advanced filters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ShaderPass`实现各种模糊效果和更高级的过滤器
- en: Creating a custom postprocessing effect by writing a simple shader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写简单的着色器创建自定义的后处理效果
- en: In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D
    Scene with Three.js*, in the *Introducing requestAnimationFrame* section, we set
    up a rendering loop that we’ve used throughout the book, in order to render and
    animate our scenes. For postprocessing, we need to make a couple of changes to
    this setup to allow Three.js to postprocess the final rendering. In the first
    section, we’ll look at how to do this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18726_01.xhtml#_idTextAnchor014)，“使用Three.js创建你的第一个3D场景”，在“介绍requestAnimationFrame”部分，我们设置了一个渲染循环，我们在整本书中使用了这个循环来渲染和动画化我们的场景。为了后处理，我们需要对这个设置进行一些修改，以便允许Three.js对最终渲染进行后处理。在第一部分，我们将探讨如何做到这一点。
- en: Setting up Three.js for postprocessing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为后处理设置Three.js
- en: 'To set up Three.js for postprocessing, we have to make a couple of changes
    to our current setup, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要为后处理设置Three.js，我们必须对我们的当前设置进行一些修改，如下所示：
- en: Create `EffectComposer`, which can be used to add postprocessing passes.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`EffectComposer`，它可以用来添加后处理步骤。
- en: Configure `EffectComposer` so that it can render our scene and apply any additional
    postprocessing steps.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`EffectComposer`以便它可以渲染我们的场景并应用任何额外的后处理步骤。
- en: In the render loop, use `EffectComposer` to render the scene, apply the configured
    postprocessing steps, and show the output.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环中，使用`EffectComposer`来渲染场景，应用配置的后处理步骤，并显示输出。
- en: 'As always, we will show an example that you can use to experiment with and
    adapt for your own purposes. The first example in this chapter can be accessed
    from `basic-setup.html`. You can use the menu in the top-right corner to modify
    the properties of the postprocessing step used in this example. In this example,
    we will render the mushroom man from [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148),
    *Animation and Moving the Camera*, and add an RGB shift effect to it, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将展示一个你可以用来实验和适应你自己的目的的示例。本章的第一个示例可以从`basic-setup.html`访问。你可以使用右上角的菜单来修改此示例中使用的后处理步骤的属性。在此示例中，我们将渲染来自[*第9章*](B18726_09.xhtml#_idTextAnchor148)，“动画和移动摄像机”，并添加RGB偏移效果，如下所示：
- en: '![Figure 11.1 – Rendered using a postprocessing pass](img/Figure_11.1_B18726.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 使用后处理步骤渲染](img/Figure_11.1_B18726.jpg)'
- en: Figure 11.1 – Rendered using a postprocessing pass
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 使用后处理步骤渲染
- en: This effect is added after the scene is rendered by using `ShaderPass`, together
    with `EffectComposer`. In the menu on the right side of the screen, you can configure
    this effect and also enable the `DotScreenShader` effect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果是通过使用`ShaderPass`以及`EffectComposer`在场景渲染后添加的。在屏幕右侧的菜单中，你可以配置此效果，并启用`DotScreenShader`效果。
- en: In the following sections, we’ll explain the individual steps from the previous
    list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将解释上一列表中的各个步骤。
- en: Creating THREE.EffectComposer
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建THREE.EffectComposer
- en: 'To get `EffectComposer` to work, we first need effects that we can use with
    it. Three.js comes with a large number of effects and shaders you can use. In
    this chapter, we’ll show most of them, but for a complete overview, check out
    the following two directories on GitHub:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Effect passes: [https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing](https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders: [https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders](https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these effects in your scene, you need to import them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the imports in the preceding code block, we import the main `EffectComposer`
    and a different number of postprocessing passes and shaders that we can use together
    with this `EffectComposer`. Once we’ve got these, setting up `EffectComposer`
    is done like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the only argument an effect composer takes is `renderer`. Next,
    we will add various passes to this composer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Configuring THREE.EffectComposer for postprocessing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each pass is executed in the sequence it is added to `THREE.EffectComposer`.
    The first pass that we add is `RenderPass`. This pass renders our scene using
    the camera provided but doesn’t output it to the screen yet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the `addPass` function, we add `RenderPass` to `EffectComposer`. The next
    step is to add another pass that will take the results from `RenderPass` as its
    input, apply its transformation, and output its result to the screen. Not all
    the available passes allow for this, but the passes we’ve used in this example
    do:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we’ve added two effects to `composer`. First, the scene is
    rendered using `RenderPass`, then `DotScreenShader` is applied, and finally, we
    apply `RGBShiftShader`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do now is update the render loop so that we render using `EffectComposer`
    instead of through the normal `WebGLRenderer`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Updating the render loop
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just need to make a small modification to our render loop to use the composer
    instead of `THREE.WebGLRenderer`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only modification that we made is removing `renderer.render(scene, camera)`
    and replacing it with `composer.render()`. This will call the render function
    on `EffectComposer`, which, in turn, uses the passed-in `THREE.WebGLRenderer`,
    and the result is that we see the output on the screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Rendered using multiple postprocessing passes](img/Figure_11.2_B18726.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Rendered using multiple postprocessing passes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Using controls after applying a render pass
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the normal controls to move around a scene. All of the effects
    that you will see in this chapter are applied after the scene is rendered. With
    this basic setup, we’ll look at the available postprocessing passes in the next
    couple of sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Postprocessing passes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js comes with a number of postprocessing passes that you can use directly
    with `THREE.EffectComposer`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Use a simple GUI to experiment
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Most of the shaders and passes shown in this chapter can be configured. When
    you want to apply one yourself, it is usually easiest to just add a simple UI
    that allows you to play around with the properties. That way, you can see what
    a good setting for your specific scenario is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的大多数着色器和通道都可以配置。当你想要应用一个自己的时，通常最简单的方法是添加一个简单的用户界面，允许你调整属性。这样，你可以看到针对特定场景的良好设置是什么。
- en: 'The following list shows all the postprocessing passes available in Three.js:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 Three.js 中可用的所有后处理通道：
- en: '`AdaptiveToneMappingPass`: This render pass adapts the luminosity of a scene,
    based on the amount of light available in it.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdaptiveToneMappingPass`: 这个渲染通道根据场景中可用的光量调整场景的亮度。'
- en: '`BloomPass`: This is an effect that makes lighter areas bleed into darker areas.
    This simulates an effect wherein the camera is overwhelmed by extremely bright
    light.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BloomPass`: 这是一个效果，使得较亮区域渗透到较暗区域。这模拟了相机被极其明亮的光线淹没的效果。'
- en: '`BokehPass`: This adds a bokeh effect to the scene. With a bokeh effect, the
    foreground of the scene is in focus, while the rest is out of focus.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BokehPass`: 这会给场景添加一个散景效果。有了散景效果，场景的前景是清晰的，而其余部分则模糊。'
- en: '`ClearPass`: This spill pass clears the current texture buffer.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClearPass`: 这个溢出通道清除当前的纹理缓冲区。'
- en: '`CubeTexturePass`: This can be used to render a skybox in the scene.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CubeTexturePass`: 这可以用来在场景中渲染天空盒。'
- en: '`DotScreenPass`: This applies a layer of black dots, representing the original
    image across the screen.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DotScreenPass`: 这会在屏幕上应用一层黑色点，代表原始图像。'
- en: '`FilmPass`: This simulates a TV screen by applying scanlines and distortions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilmPass`: 这通过应用扫描线和扭曲来模拟电视屏幕。'
- en: '`GlitchPass`: This shows an electronic glitch on the screen at a random time
    interval.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlitchPass`: 这在随机的时间间隔内在屏幕上显示电子故障。'
- en: '`HalfTonePass`: This adds a halftone effect to the scene. With a halftone effect,
    the scene is rendered as a set of colored glyphs (circles, squares, and so on)
    of various sizes.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HalfTonePass`: 这会给场景添加半色调效果。有了半色调效果，场景被渲染为各种大小的一组彩色符号（圆形、方形等）。'
- en: '`LUTPass`: With `LUTPass`, you can apply a color correction step to the scene
    after it is rendered (not shown in this chapter).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LUTPass`: 使用 `LUTPass`，你可以在渲染后对场景应用颜色校正步骤（本章中未展示）。'
- en: '`MaskPass`: This allows you to apply a mask to the current image. Subsequent
    passes are only applied to the masked area.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaskPass`: 这允许你将掩码应用于当前图像。后续通道仅应用于掩码区域。'
- en: '`OutlinePass`: This renders the outline of the objects in the scene.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutlinePass`: 这会渲染场景中物体的轮廓。'
- en: '`RenderPass`: This renders a scene based on the scene and camera supplied.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderPass`: 这根据提供的场景和相机渲染场景。'
- en: '`SAOPass`: This provides runtime ambient occlusion.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAOPass`: 这提供运行时环境遮挡。'
- en: '`SMAAPass`: This adds an anti-aliasing effect to the scene.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMAAPass`: 这会给场景添加抗锯齿效果。'
- en: '`SSAARenderPass`: This adds anti-aliasing to the scene.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSAARenderPass`: 这给场景添加抗锯齿。'
- en: '`SSAOPass`: This provides an alternative way to perform runtime ambient occlusion.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSAOPass`: 这提供了一种执行运行时环境遮挡的替代方法。'
- en: '`SSRPass`: This pass allows you to create reflective objects.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSRPass`: 这个通道允许你创建反射物体。'
- en: '`SavePass`: When this pass is executed, it makes a copy of the current rendering
    step that you can use later. This pass isn’t that useful in practice, and we won’t
    use it in any of our examples.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SavePass`: 当这个通道执行时，它会复制当前渲染步骤，你可以稍后使用。在实际应用中，这个通道并不那么有用，我们不会在我们的任何示例中使用它。'
- en: '`ShaderPass`: This allows you to pass in custom shaders for advanced or custom
    postprocessing passes.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShaderPass`: 这允许你为高级或定制的后处理通道传递自定义着色器。'
- en: '`TAARenderPass`: This adds an anti-aliasing effect to the scene.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TAARenderPass`: 这会给场景添加抗锯齿效果。'
- en: '`TexturePass`: This stores the current state of the composer in a texture that
    you can use as input for other `EffectComposer` instances.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TexturePass`: 这会将合成器的当前状态存储在一个纹理中，你可以将其用作其他 `EffectComposer` 实例的输入。'
- en: '`UnrealBloomPass`: This is the same as `THREE.BloomPass` but with an effect
    similar to the effect used in the Unreal 3D engine.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnrealBloomPass`: 这与 `THREE.BloomPass` 相同，但效果类似于在 Unreal 3D 引擎中使用的效果。'
- en: Let’s start with a number of simple passes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的通道开始。
- en: Simple postprocessing passes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的后处理通道
- en: 'For simple passes, we’ll look at what we can do with `FilmPass`, `BloomPass`,
    and `DotScreenPass`. For these passes, an example is available (`multi-passes.html`)
    that will allow you to experiment with these passes and see how they affect the
    original output differently. The following screenshot shows the example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的通道，我们将查看 `FilmPass`、`BloomPass` 和 `DotScreenPass` 可以做什么。对于这些通道，有一个示例（`multi-passes.html`）允许您实验这些通道并查看它们如何以不同的方式影响原始输出。以下截图显示了示例：
- en: '![Figure 11.3 – Three simple passes applied to a scene](img/Figure_11.3_B18726.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 应用到场景中的三个简单通道](img/Figure_11.3_B18726.jpg)'
- en: Figure 11.3 – Three simple passes applied to a scene
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 应用到场景中的三个简单通道
- en: In this example, you can see four scenes at the same time, and in each scene,
    a different postprocessing pass is added. The one in the top-left corner shows
    `BloomPass`, the one in the bottom-right corner shows `DotScreenPass`, and the
    one in the bottom-left corner shows `FilmPass`. The scene in the top-right corner
    shows the original render.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以同时看到四个场景，并且在每个场景中，都添加了不同的后处理通道。左上角显示的是 `BloomPass`，右下角显示的是 `DotScreenPass`，左下角显示的是
    `FilmPass`。右上角显示的是原始渲染。
- en: 'In this example, we also use `THREE.ShaderPass` and `THREE.TexturePass` to
    reuse the output from the original rendering as input for the other three scenes.
    That way, we only need to render the scene once. So, before we look at the individual
    passes, let’s look at these two passes, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们还使用了 `THREE.ShaderPass` 和 `THREE.TexturePass` 来重用原始渲染的输出作为其他三个场景的输入。这样，我们只需要渲染场景一次。因此，在我们查看单个通道之前，让我们看看这两个通道，如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this piece of code, we set up `EffectComposer`, which will output the default
    scene (the one in the top-right corner). This composer has three passes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们设置了 `EffectComposer`，它将输出默认场景（右上角的一个）。此合成器有三个通道：
- en: '`RenderPass`: This pass renders the scene.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderPass`：此通道渲染场景。'
- en: '`ShaderPass` with `GammaCorrectionShader`: Makes sure that the colors of the
    output are correct. If, after applying effects, the color of the scene looks incorrect,
    this shader will correct it.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `GammaCorrectionShader` 的 `ShaderPass`：确保输出的颜色是正确的。如果在应用效果后，场景的颜色看起来不正确，此着色器将对其进行纠正。
- en: '`ShaderPass` with `CopyShader`: Renders the output (without any further postprocessing
    to the screen, if we set the `renderToScreen` property to `true`).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `CopyShader` 的 `ShaderPass`：渲染输出（如果我们将 `renderToScreen` 属性设置为 `true`，则不会对屏幕进行任何进一步的后处理）。
- en: If you look at the example, you can see that we show the same scene four times
    but with a different effect applied each time. We could also render the scene
    from scratch by using `RenderPass` four times, but that would be a bit of a waste,
    since we can just reuse the output from the first composer. To do this, we create
    `TexturePass` and pass in the `composer.renderTarget2.texture` value. This property
    contains the rendered scene as a texture, which we can pass into `TexturePass`.
    We can now use the `texturePass` variable as input for our other composers, without
    having to render the scene from scratch. Let’s look at `FilmPass` first and how
    we can use the results from `TexturePass` as input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看示例，您可以看到我们展示了相同的场景四次，但每次都应用了不同的效果。我们也可以通过使用 `RenderPass` 四次从头开始渲染场景，但这会有些浪费，因为我们可以直接重用第一个合成器的输出。为此，我们创建
    `TexturePass` 并传入 `composer.renderTarget2.texture` 的值。此属性包含作为纹理渲染的场景，我们可以将其传递到
    `TexturePass`。现在，我们可以使用 `texturePass` 变量作为其他合成器的输入，而无需从头开始渲染场景。让我们首先看看 `FilmPass`
    以及我们如何使用 `TexturePass` 的结果作为输入。
- en: Using THREE.FilmPass to create a TV-like effect
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 THREE.FilmPass 创建类似电视的效果
- en: 'To create `FilmPass`, we use the following piece of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `FilmPass`，我们使用以下代码片段：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only step that we need to take to use `TexturePass` is to add it as the
    first pass in our composer. Next, we can just add `FilmPass`, and the effect will
    be applied. `FilmPass` can take four additional parameters, as shown in the following
    list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TexturePass` 的唯一步骤是将它作为我们合成器中的第一个通道添加。接下来，我们只需添加 `FilmPass`，效果就会应用。`FilmPass`
    可以接受四个额外的参数，如下所示列表：
- en: '`noiseIntensity`: This property allows you to control how grainy the scene
    looks.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noiseIntensity`：此属性允许您控制场景看起来有多粗糙。'
- en: '`scanlinesIntensity`: `FilmPass` adds a number of scanlines (see `scanLinesCount`)
    to the scene. With this property, you can define how prominently these scanlines
    are shown.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanlinesIntensity`: `FilmPass` 为场景添加了若干扫描线（见 `scanLinesCount`）。使用此属性，您可以定义这些扫描线显示的突出程度。'
- en: '`scanLinesCount`: The number of scanlines that are shown can be controlled
    with this property.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanLinesCount`：可以通过此属性控制显示的扫描线数量。'
- en: '`grayscale`: If this is set to `true`, the output will be converted to grayscale.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grayscale`：如果将其设置为 `true`，输出将被转换为灰度。'
- en: 'There are actually two ways that you can pass in these parameters. In this
    example, we passed them in as arguments to the constructor, but you can also set
    them directly, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您有两种方法可以传递这些参数。在这个例子中，我们将它们作为构造函数的参数传递，但您也可以直接设置它们，如下所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this approach, we use the `uniforms` property, which communicates directly
    with WebGL. In the *Using THREE.ShaderPass for custom effects* section, where
    we talk about creating a custom shader, we’ll get a bit deeper into `uniforms`;
    for now, all you need to know is that this way, you can update the configuration
    of postprocessing passes and shaders and see the results directly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用 `uniforms` 属性，它直接与 WebGL 通信。在 *使用 THREE.ShaderPass 创建自定义效果* 部分，当我们讨论创建自定义着色器时，我们将更深入地了解
    `uniforms`；现在，您只需要知道，通过这种方式，您可以更新后处理传递和着色器的配置，并直接查看结果。
- en: 'The result of this pass is shown in the following figure:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此次传递的结果显示在以下图中：
- en: '![Figure 11.4 – A film effect provided by FilmPass](img/Figure_11.4_B18726.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – FilmPass 提供的电影效果](img/Figure_11.4_B18726.jpg)'
- en: Figure 11.4 – A film effect provided by FilmPass
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – FilmPass 提供的电影效果
- en: The next effect is the bloom effect, which you can see in the top-left part
    of the screen in *Figure 11**.3*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个效果是 bloom 效果，您可以在 *图 11.3* 的左上角看到。
- en: Adding a bloom effect to the scene with THREE.BloomPass
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 THREE.BloomPass 为场景添加 bloom 效果
- en: 'The effect that you see in the top-left corner is called the bloom effect.
    When you apply the bloom effect, the bright areas of a scene will be made more
    prominent and bleed into the darker areas. The code to create `BloomPass` is as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您在左上角看到的效果被称为 bloom 效果。当您应用 bloom 效果时，场景中的明亮区域将被突出显示并渗透到较暗的区域。创建 `BloomPass`
    的代码如下：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you compare this with `EffectComposer`, which we used with `FilmPass`, you’ll
    notice that we add an additional pass, `effectCopy`. This step doesn’t add any
    special effects but just copies the output from the last pass to the screen. We
    need to add this step, since `BloomPass` doesn’t render directly to the screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将其与 `EffectComposer` 进行比较，后者我们与 `FilmPass` 一起使用，您会注意到我们添加了一个额外的传递，`effectCopy`。这一步不会添加任何特殊效果，只是将最后一步的输出复制到屏幕上。我们需要添加这一步，因为
    `BloomPass` 不会直接渲染到屏幕上。
- en: 'The following table lists the properties that you can set on `BloomPass`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了您可以在 `BloomPass` 上设置的属性：
- en: '`strength`: This is the strength of the bloom effect. The higher this is, the
    more bright the brighter areas are, and the more they will bleed into the darker
    areas.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strength`：这是 bloom 效果的强度。这个值越高，越亮的区域越亮，并且它们将更多地渗透到较暗的区域。'
- en: '`kernelSize`: This is the size of the kernel. This is the size of the area
    that is blurred in a single step. If you set this higher, more pixels will be
    included to determine the effect at a specific point.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernelSize`：这是内核的大小。这是在单步中模糊的区域的大小。如果您将其设置得更高，将包括更多像素以确定特定点的效果。'
- en: '`sigma`: With the `sigma` property, you can control the sharpness of the bloom
    effect. The higher the value, the more blurred the bloom effect will look.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigma`：使用 `sigma` 属性，您可以控制 bloom 效果的锐度。值越高，bloom 效果看起来越模糊。'
- en: '`resolution`: The `resolution` property defines how precisely the bloom effect
    is created. If you make this too low, the result will look blocky.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolution`：`resolution` 属性定义了 bloom 效果创建的精确度。如果您将其设置得太低，结果看起来会像块状。'
- en: 'A better way to understand these properties is to just experiment with them
    by using the aforementioned example, `multi-passes.html`. The following screenshot
    shows the `bloom` effect with a high sigma size and high strength:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解这些属性，最好的方法是通过使用上述示例 `multi-passes.html` 来实验它们。以下截图显示了具有高 sigma 大小和高强度的
    `bloom` 效果：
- en: '![Figure 11.5 – The bloom effect using BloomPass](img/Figure_11.5_B18726.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 使用 BloomPass 的 bloom 效果](img/Figure_11.5_B18726.jpg)'
- en: Figure 11.5 – The bloom effect using BloomPass
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 使用 BloomPass 的 bloom 效果
- en: The next simple effects that we’ll look at are the `DotScreenPass` effects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一个简单效果是 `DotScreenPass` 效果。
- en: Outputting a scene as a set of dots
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将场景输出为点集
- en: 'Using `DotScreenPass` is very similar to using `BloomPass`. We just saw `BloomPass`
    in action. Let’s now look at the code for `DotScreenPass`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DotScreenPass` 与使用 `BloomPass` 非常相似。我们刚刚看到了 `BloomPass` 的作用。现在让我们看看 `DotScreenPass`
    的代码：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this effect, we don’t need `effectCopy` to output the result to the screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个效果，我们不需要 `effectCopy` 将结果输出到屏幕。
- en: '`DotScreenPass` can also be configured with a number of properties, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`DotScreenPass` 也可以配置多个属性，如下所示：'
- en: '`center`: With the `center` property, you can fine-tune the way the dots are
    offset.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`：通过 `center` 属性，你可以微调点的偏移方式。'
- en: '`angle`: The dots are aligned in a certain manner. With the `angle` properties,
    you can change this alignment.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angle`：点以某种方式对齐。通过 `angle` 属性，你可以改变这种对齐方式。'
- en: '`scale`: With this, we can set the sizes of the dots to use. The lower the
    scale, the larger the dots.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`：通过这个，我们可以设置要使用的点的尺寸。缩放值越低，点就越大。'
- en: 'What applies to the other shaders also applies to this shader. It’s much easier
    to get the right settings with experimentation, as seen in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他着色器适用的内容也适用于这个着色器。通过实验，更容易获得正确的设置，如下面的图所示：
- en: '![Figure 11.6 – A dot-screen effect using DotScreenPass](img/Figure_11.6_B18726.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 使用 DotScreenPass 的点阵效果](img/Figure_11.6_B18726.jpg)'
- en: Figure 11.6 – A dot-screen effect using DotScreenPass
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 使用 DotScreenPass 的点阵效果
- en: Before we move on to the next set of simple shaders, we’ll first look at how
    we’ve rendered multiple scenes on the same screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一组简单的着色器之前，我们首先看看我们是如何在同一屏幕上渲染多个场景的。
- en: Showing the output of multiple renderers on the same screen
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在同一屏幕上显示多个渲染器的输出
- en: 'This section won’t go into detail on how to use postprocessing effects but
    will explain how to get the output of all four `EffectComposer` instances on the
    same screen. First, let’s look at the render loop used for this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不会详细介绍如何使用后处理效果，但会解释如何在同一屏幕上获取所有四个 `EffectComposer` 实例的输出。首先，让我们看看这个示例中使用的渲染循环：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing to notice is that we set the `renderer.autoClear` property to
    `false` and then explicitly call the `clear()` function in the render loop. If
    we don’t do this each time we call the `render()` function on a composer, the
    previously rendered parts of the screen will be cleared. With this approach, we
    only clear everything at the beginning of our render loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们将 `renderer.autoClear` 属性设置为 `false`，然后在渲染循环中显式调用 `clear()` 函数。如果我们每次在作曲家上调用
    `render()` 函数时都不这样做，屏幕上之前渲染的部分将被清除。使用这种方法，我们只在渲染循环的开始清除一切。
- en: 'To avoid having all of our composers render in the same space, we set the `viewport`
    function of the renderer, which is used by our composers, to a different part
    of the screen. This function takes four arguments: `x`, `y`, `width`, and `height`.
    As you can see in the code sample, we use this function to divide the screen into
    four areas and make the composers render to their individual areas. Note that
    you can also use this approach with multiple `scene`, `camera`, and `WebGLRenderer`
    instances, if you want. With this setup, the render loop will render each of the
    four `EffectComposer` objects to their own parts of the screen. Let’s quickly
    look at another couple of passes.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有我们的作曲家都在同一空间中渲染，我们将渲染器（我们的作曲家使用的）的 `viewport` 函数设置为屏幕的不同部分。这个函数接受四个参数：`x`、`y`、`width`
    和 `height`。正如你在代码示例中所看到的，我们使用这个函数将屏幕分成四个区域，并让作曲家将渲染输出到它们各自的部分。请注意，如果你愿意，你也可以使用这种方法与多个
    `scene`、`camera` 和 `WebGLRenderer` 实例一起使用。在这种设置下，渲染循环将渲染四个 `EffectComposer` 对象的各自部分。让我们快速看看另外几个通过：
- en: Additional simple passes
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的简单通过
- en: 'If you open the `multi-passes-2.html` example in your browser, you will see
    a number of additional passes in action:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器中的 `multi-passes-2.html` 示例，你会看到一些额外的通过动作：
- en: '![Figure 11.7 – Another set of four passes](img/Figure_11.7_B18726.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 另一组四个通过](img/Figure_11.7_B18726.jpg)'
- en: Figure 11.7 – Another set of four passes
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 另一组四个通过
- en: 'We won’t go into too much detail here, since these passes are configured in
    the same way as those in the previous sections. In this example, you can see the
    following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会过多地详细介绍，因为这些通过与前面章节中的通过配置方式相同。在这个例子中，你可以看到以下内容：
- en: In the bottom-left corner, you can see `OutlinePass`. The outline pass can be
    used to draw an outline for a `THREE.Mesh` object.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左下角，你可以看到 `OutlinePass`。轮廓通过可以用来为 `THREE.Mesh` 对象绘制轮廓。
- en: In the bottom-right corner, `GlitchPass` is shown. As the name implies, this
    pass provides a technical rendering glitch effect.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右下角，显示了 `GlitchPass`。正如其名所示，这个通道提供了一个技术渲染故障效果。
- en: In the top-left corner, the `UnrealBloom` effect is shown.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左上角，显示了 `UnrealBloom` 效果。
- en: In the top-right corner, `HalftonePass` is used to convert the rendering to
    a set of dots.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右上角，使用 `HalftonePass` 将渲染转换为一系列点。
- en: As is the case for all of the examples in this chapter, you can configure the
    individual properties of these passes by using the menu on the right.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有示例一样，你可以通过使用右侧的菜单来配置这些通道的各个属性。
- en: 'To see `OutlinePass` correctly, you can set the scene background to black and
    zoom out a bit:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确查看 `OutlinePass`，你可以将场景背景设置为黑色并稍微放大一些：
- en: '![Figure 11.8 – The outline pass showing the outline of the scene](img/Figure_11.8_B18726.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 显示场景轮廓的轮廓通道](img/Figure_11.8_B18726.jpg)'
- en: Figure 11.8 – The outline pass showing the outline of the scene
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 显示场景轮廓的轮廓通道
- en: So far we’ve seen simple effects, in the next section, we’ll look at how you
    can use masks to apply effects to parts of the screen.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了简单的效果，在下一节中，我们将看看如何使用蒙版将效果应用于屏幕的一部分。
- en: Advanced EffectComposer flows using masks
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上完成起来非常简单。首先，让我们看看 `masks.html` 示例中我们想要达到的结果。以下截图显示了这些步骤的结果：
- en: 'In the previous examples, we applied the postprocessing pass to a complete
    screen. However, Three.js also has the ability to apply passes only to a specific
    area. In this section, we will perform the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将后处理通道应用于整个屏幕。然而，Three.js 也有能力仅将通道应用于特定区域。在本节中，我们将执行以下步骤：
- en: Create a scene to serve as a background image.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置我们将要渲染的各种场景：
- en: Create a scene containing a sphere that looks like Earth.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `EffectComposer`，将这些三个场景渲染成一张单独的图片。
- en: Create a scene containing a sphere that looks like Mars.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含类似火星的球体的场景。
- en: Create `EffectComposer`, which renders these three scenes into a single image.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上完成起来非常简单。首先，让我们看看 `masks.html` 示例中我们想要达到的结果。以下截图显示了这些步骤的结果：
- en: Apply a colorify effect to the sphere rendered as Mars.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色效果应用于渲染为火星的球体。
- en: Apply a sepia effect to the sphere rendered as Earth.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为背景图像的场景。
- en: 'This might sound complex, but it is actually surprisingly easy to accomplish.
    First, let’s look at the result that we’re aiming for in the `masks.html` example.
    The following screenshot shows the results of these steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 使用蒙版将效果应用于屏幕的一部分](img/Figure_11.9_B18726.jpg)'
- en: '![Figure 11.9 – Use a mask to apply an effect to part of the screen](img/Figure_11.9_B18726.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: 将棕褐色效果应用于渲染为地球的球体。
- en: Figure 11.9 – Use a mask to apply an effect to part of the screen
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 使用蒙版将效果应用于屏幕的一部分
- en: 'The first thing that we need to do is set up the various scenes that we’ll
    be rendering:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含类似地球的球体的场景。
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create the Earth and Mars spheres, we just create the spheres with the correct
    material and textures and add them to their specific scenes. For the background
    scene, we load a texture and set it to as the background for `sceneBG`. This is
    shown in the following code (`addEarth` and `addMars` are just helper functions
    to keep the code clear; they create a simple `THREE.Mesh` from `THREE.SphereGeometry`,
    create some lights, and add them all to `THREE.Scene`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地球和火星球体，我们只需创建具有正确材质和纹理的球体并将它们添加到特定的场景中。对于背景场景，我们加载一个纹理并将其设置为 `sceneBG` 的背景。这在上面的代码中显示（`addEarth`
    和 `addMars` 只是辅助函数，用于使代码更清晰；它们从 `THREE.SphereGeometry` 创建一个简单的 `THREE.Mesh`，创建一些灯光并将它们全部添加到
    `THREE.Scene`）：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we use the `background` property of a scene to add the starry
    background. There is an alternative way to create a background. We can use `THREE.OrhoGraphicCamera`.
    With `THREE.OrthographicCamera`, the size of the rendered object doesn’t change
    when it is closer or further away from the camera, so, by positioning a `THREE.PlaneGeometry`
    object directly in front of `THREE.rhoGraphicCamera`, we can create a background
    as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用场景的 `background` 属性添加星空背景。还有另一种创建背景的方法。我们可以使用 `THREE.OrthographicCamera`。使用
    `THREE.OrthographicCamera`，渲染对象的尺寸在它靠近或远离相机时不会改变，因此，通过将 `THREE.PlaneGeometry`
    对象直接放置在 `THREE.OrthographicCamera` 前面，我们也可以创建一个背景。
- en: 'We now have got our three scenes, and we can start to set up our passes and
    `EffectComposer`. Let’s start by looking at the complete chain of passes, after
    which we’ll look at the individual passes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了三个场景，我们可以开始设置我们的通道和 `EffectComposer`。让我们先看看完整的通道链，然后我们将查看单个通道：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To work with masks, we need to create `EffectComposer` in a slightly different
    manner. We need to set the `stencilBuffer` property of the internally used render
    targets to `true`. A stencil buffer, a special type of buffer, is used to limit
    the area of rendering. So, by enabling the stencil buffer, we can use our masks.
    Let’s look at the first three passes that are added. These three passes render
    the background, the Earth scene, and the Mars scene, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要与遮罩一起工作，我们需要以稍微不同的方式创建 `EffectComposer`。我们需要将内部使用的渲染目标的 `stencilBuffer` 属性设置为
    `true`。一个模板缓冲区，一种特殊的缓冲区，用于限制渲染区域。因此，通过启用模板缓冲区，我们可以使用我们的遮罩。让我们看看添加的前三个过程。这三个过程按照以下方式渲染背景、地球场景和火星场景：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s nothing new here, except that we set the `clear` property of two of
    these passes to `false`. If we don’t do this, we’ll only see the output from the
    `marsRenderPass` render, since it will clear everything before it starts rendering.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的内容，只是我们将其中两个过程的 `clear` 属性设置为 `false`。如果我们不这样做，我们只能看到 `marsRenderPass`
    渲染的输出，因为它会在开始渲染之前清除一切。
- en: 'If you look back at the code for `EffectComposer`, the next three passes are
    `marsMask`, `effectColorify`, and `clearMask`. First, we’ll look at how these
    three passes are defined:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下 `EffectComposer` 的代码，接下来的三个过程是 `marsMask`、`effectColorify` 和 `clearMask`。首先，我们将看看这三个过程是如何定义的：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first of these three passes is `MaskPass`. When creating a `MaskPass` object,
    you pass in a scene and a camera, just as you did for `RenderPass`. A `MaskPass`
    object will render this scene internally, but instead of showing this on screen,
    it will use the rendered internal scene to create a mask. When a `MaskPass` object
    is added to `EffectComposer`, all of the subsequent passes will be applied only
    to the mask defined by `MaskPass`, until a `ClearMaskPass` step is encountered.
    In this example, this means that the `effectColorify` pass, which adds a blue
    glow, is only applied to the objects rendered in `sceneMars`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个过程中的第一个是 `MaskPass`。当创建一个 `MaskPass` 对象时，你传递一个场景和一个相机，就像你为 `RenderPass` 做的那样。一个
    `MaskPass` 对象将内部渲染这个场景，但不会在屏幕上显示，而是使用渲染的内部场景来创建一个遮罩。当一个 `MaskPass` 对象被添加到 `EffectComposer`
    中时，所有后续的过程将只应用于由 `MaskPass` 定义的遮罩，直到遇到 `ClearMaskPass` 步骤。在这个例子中，这意味着添加蓝色光芒的 `effectColorify`
    过程只应用于在 `sceneMars` 中渲染的物体。
- en: We use the same approach to apply a sepia filter to the Earth object. We first
    create a mask based on the Earth scene and use this mask in `EffectComposer`.
    After using `MaskPass`, we add the effect that we want to apply (`effectSepia`
    in this case), and, once we’re done with that, we add `ClearMaskPass` to remove
    the mask again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法将棕褐色滤镜应用到地球物体上。我们首先基于地球场景创建一个遮罩，并在 `EffectComposer` 中使用这个遮罩。在使用 `MaskPass`
    之后，我们添加我们想要应用的效果（在这种情况下是 `effectSepia`），完成之后，我们添加 `ClearMaskPass` 来再次移除遮罩。
- en: The last step for this specific `EffectComposer` is one that we’ve already seen.
    We need to copy the final result to the screen, and we once again use the `effectCopy`
    pass for that. With this setup, we can apply the effects that we want to be a
    part of the total screen. Be aware, though, that these effects are applied to
    a part of the rendered image if the Mars scene and the Earth scene overlap.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的 `EffectComposer` 的最后一步，我们已经见过。我们需要将最终结果复制到屏幕上，为此我们再次使用 `effectCopy`
    过程。使用这种设置，我们可以将我们希望成为整个屏幕一部分的效果应用上。但请注意，如果火星场景和地球场景重叠，这些效果将只应用于渲染图像的一部分。
- en: 'The effects of both will be applied to that part of the screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个效果都将应用到屏幕的相应部分：
- en: '![Figure 11.10 – When masks overlap, both effects are applied](img/Figure_11.10_B18726.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 当遮罩重叠时，应用两个效果](img/Figure_11.10_B18726.jpg)'
- en: Figure 11.10 – When masks overlap, both effects are applied
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 当遮罩重叠时，应用两个效果
- en: 'There is one additional property that’s interesting when working with `MaskPass`,
    and that’s the `inverse` property. If this property is set to `true`, the mask
    is inverted. In other words, the effect is applied to everything but the scene
    passed into `MaskPass`. This is shown in the following screenshot, where we set
    the `inverse` property of `earthMask` to `true`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `MaskPass` 时有一个有趣的额外属性，那就是 `inverse` 属性。如果这个属性设置为 `true`，遮罩将被反转。换句话说，效果将应用于除了传递给
    `MaskPass` 的场景之外的所有内容。这在上面的屏幕截图中有显示，我们将 `earthMask` 的 `inverse` 属性设置为 `true`：
- en: '![Figure 11.11 – When masks overlap, both effects are applied](img/Figure_11.11_B18726.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 当遮罩重叠时，应用两个效果](img/Figure_11.11_B18726.jpg)'
- en: Figure 11.11 – When masks overlap, both effects are applied
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 当遮罩重叠时，应用两个效果
- en: 'Before we move on to a discussion of `ShaderPass`, we’re going to look at two
    passes that provide a more advanced effect: `BokehPass` and `SSAOPass`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 `ShaderPass` 之前，我们将查看两个提供更高级效果的过程：`BokehPass` 和 `SSAOPass`。
- en: Advanced pass – bokeh
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级过程 – 模糊效果
- en: 'With the `BokehPass`, you can add a `bokeh` effect to your scene. In a bokeh
    effect, only part of the scene is in focus, and the rest of the scene looks blurry.
    To see this effect in action, you can open the `bokeh.html` example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BokehPass`，您可以为场景添加模糊效果。在模糊效果中，场景中只有一部分是清晰的，其余部分看起来是模糊的。要查看此效果的实际应用，您可以打开
    `bokeh.html` 示例：
- en: '![Figure 11.12 – An unfocussed bokeh effect](img/Figure_11.12_B18726.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 未聚焦的模糊效果](img/Figure_11.12_B18726.jpg)'
- en: Figure 11.12 – An unfocussed bokeh effect
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 未聚焦的模糊效果
- en: 'When you open it, initially, the whole scene will look blurry. With the `aperture`
    property to determine the size of the area that should be in focus. By sliding
    the focus, you can have the set of cubes in the foreground in focus, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开它时，最初，整个场景看起来是模糊的。通过 `aperture` 属性来确定应该聚焦的区域的大小。通过调整焦点，可以使前景中的立方体组清晰，如下所示：
- en: '![Figure 11.13 – Bokeh focussed on the first set of cubes](img/Figure_11.13_B18726.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 模糊效果聚焦于第一组立方体](img/Figure_11.13_B18726.jpg)'
- en: Figure 11.13 – Bokeh focussed on the first set of cubes
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 模糊效果聚焦于第一组立方体
- en: 'Alternatively, if we slide the focus further, we can focus on the red cubes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们进一步滑动焦点，我们还可以聚焦于红色立方体：
- en: '![Figure 11.14 – Bokeh focussed on the second set of cubes](img/Figure_11.14_B18726.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 模糊效果聚焦于第二组立方体](img/Figure_11.14_B18726.jpg)'
- en: Figure 11.14 – Bokeh focussed on the second set of cubes
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 模糊效果聚焦于第二组立方体
- en: 'And, if we slide the focus even further, we can focus on the set of green cubes
    at the far end of the scene:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将焦点进一步滑动，我们还可以聚焦于场景远端的绿色立方体组：
- en: '![Figure 11.15 – Bokeh focussed on the third set of cubes](img/Figure_11.15_B18726.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 模糊效果聚焦于第三组立方体](img/Figure_11.15_B18726.jpg)'
- en: Figure 11.15 – Bokeh focussed on the third set of cubes
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 模糊效果聚焦于第三组立方体
- en: '`BokehPass` can be used just like the other passes we’ve seen so far:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`BokehPass` 可以像我们之前看到的其他过程一样使用：'
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Achieving the desired result might require some fine-tuning of the properties.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所需的结果可能需要调整一些属性。
- en: Advance pass – ambient occlusion
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级过程 – 环境遮挡
- en: 'In [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working with
    Textures*, we discussed using a pre-baked `aoMap` on the material, it is also
    possible to use a pass on `EffectComposer` to get the same effect. If you open
    the `ambient-occlusion.html` example, you will see the result of using `SSAOPass`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 10 章*](B18726_10.xhtml#_idTextAnchor171) *加载和使用纹理* 中，我们讨论了在材质上使用预烘焙的 `aoMap`，也可以在
    `EffectComposer` 上使用过程来获得相同的效果。如果您打开 `ambient-occlusion.html` 示例，您将看到使用 `SSAOPass`
    的结果：
- en: '![Figure 11.16 – An AO pass applied](img/Figure_11.16_B18726.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 应用了 AO 过滤器的场景](img/Figure_11.16_B18726.jpg)'
- en: Figure 11.16 – An AO pass applied
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 应用了景深效果
- en: 'A similar scene, without the application of an ambient occlusion filter, appears
    to be really flat, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用环境遮挡滤镜的类似场景看起来非常平坦，如下所示：
- en: '![Figure 11.17 – The same scene without the AO pass](img/Figure_11.17_B18726.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 没有应用 AO 过滤器的相同场景](img/Figure_11.17_B18726.jpg)'
- en: Figure 11.17 – The same scene without the AO pass
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 没有应用 AO 过滤器的相同场景
- en: Note though that if you use this, you have to keep an eye on the overall performance
    of your application, since this is a very GPU-intensive pass.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，如果您使用此功能，您必须注意应用程序的整体性能，因为这是一个非常占用 GPU 的过程。
- en: Until now, we’ve used the standard passes provided by Three.js for our effects.
    Three.js also provides `THREE.ShaderPass`, which can be used for custom effects
    and comes with a large number of shaders that you can use and experiment with.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用 Three.js 提供的标准过程来实现效果。Three.js 还提供了 `THREE.ShaderPass`，它可以用于自定义效果，并附带大量您可以使用的着色器，您可以进行实验。
- en: Using THREE.ShaderPass for custom effects
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 THREE.ShaderPass 实现自定义效果
- en: With `THREE.ShaderPass`, we can apply a large number of additional effects to
    our scene by passing in a custom shader. Three.js comes with a set of shaders
    that can be used together with this `THREE.ShaderPass`. They will be listed in
    this section. We’ve divided this section into three parts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ShaderPass`，我们可以通过传递自定义着色器来为场景应用大量额外的效果。Three.js 附带了一套可以与 `THREE.ShaderPass`
    一起使用的着色器。它们将在本节中列出。我们将本节分为三个部分。
- en: 'The first set involves simple shaders. All of these shaders can be viewed and
    configured by opening up the `shaderpass-simple.html` example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组涉及简单的着色器。所有这些着色器都可以通过打开`shaderpass-simple.html`示例来查看和配置：
- en: '`BleachBypassShader`: This creates a bleach bypass effect. With this effect,
    a silver-like overlay will be applied to the image.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BleachBypassShader`: 这创建了一个漂白绕过效果。使用此效果，将在图像上应用类似银色的叠加。'
- en: '`BlendShader`: This isn’t a shader that you apply as a single postprocessing
    step, but it allows you to blend two textures together. You can, for instance,
    use this shader to smoothly blend the rendering of one scene into another (not
    shown in `shaderpass-simple.html`).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlendShader`: 这不是一个作为单个后期处理步骤应用的着色器，但它允许你混合两个纹理。例如，你可以使用这个着色器将一个场景的渲染平滑地融合到另一个场景中（在`shaderpass-simple.html`中未显示）。'
- en: '`BrightnessContrastShader`: This allows you to change the brightness and contrast
    of an image.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrightnessContrastShader`: 这允许你改变图像的亮度和对比度。'
- en: '`ColorifyShader`: This applies a color overlay to the screen. We’ve seen this
    one already, in the mask example.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorifyShader`: 这在屏幕上应用了一个颜色叠加。我们已经在遮罩示例中见过这个着色器。'
- en: '`ColorCorrectionShader`: With this shader, you can change the color distribution.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorCorrectionShader`: 使用这个着色器，你可以改变颜色分布。'
- en: '`GammaCorrectionShader`: This applies a gamma correction to the rendered scene.
    This uses a fixed gamma factor of 2\. Note that you can also set the gamma correction
    directly on `THREE.WebGLRenderer` by using the `gammaFactor`, `gammaInput`, and
    `gammaOutput` properties.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GammaCorrectionShader`: 这对渲染的场景应用伽玛校正。它使用一个固定的伽玛因子2。请注意，你也可以通过使用`gammaFactor`、`gammaInput`和`gammaOutput`属性，在`THREE.WebGLRenderer`上直接设置伽玛校正。'
- en: '`HueSaturationShader`: This allows you to change the hue and saturation of
    the colors.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HueSaturationShader`: 这允许你改变颜色的色调和饱和度。'
- en: '`KaleidoShader`: This adds a kaleidoscope effect to the scene that provides
    radial reflection around the center of the scene.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KaleidoShader`: 这为场景添加了一个万花筒效果，该效果在场景中心提供径向反射。'
- en: '`LuminosityShader` and `LuminostyHighPassShader`: This provides a luminosity
    effect, where the luminosity of the scene is shown.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LuminosityShader`和`LuminostyHighPassShader`: 这提供了亮度效果，其中场景的亮度被显示出来。'
- en: '`MirrorShader`: This creates a mirror effect for part of the screen.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MirrorShader`: 这为屏幕的一部分创建了一个镜像效果。'
- en: '`PixelShader`: This creates a pixelated effect.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PixelShader`: 这创建了一个像素化效果。'
- en: '`RGBShiftShader`: This shader separates the red, green, and blue components
    of a color.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGBShiftShader`: 这个着色器将颜色的红、绿和蓝分量分离。'
- en: '`SepiaShader`: This creates a sepia-like effect on the screen.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SepiaShader`: 这在屏幕上创建了一种类似棕褐色效果。'
- en: '`SobelOperatorShader`: This provides edge detection.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SobelOperatorShader`: 这提供了边缘检测。'
- en: '`VignetteShader`: This applies a vignette effect. This effect shows dark borders
    around the center of the image.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VignetteShader`: 这应用了一个晕影效果。此效果在图像中心显示暗色边缘。'
- en: 'Next, we’ll look at the shaders that provide a couple of blur-related effects.
    These effects can be experimented with through the `shaderpass-blurs.html` example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看提供一些模糊相关效果的着色器。这些效果可以通过`shaderpass-blurs.html`示例进行实验：
- en: '`HorizontalBlurShader` and `VerticalBlurShader`: These apply a blur effect
    to the complete scene.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalBlurShader`和`VerticalBlurShader`: 这些着色器将模糊效果应用到整个场景上。'
- en: '`HorizontalTiltShiftShader` and `VerticalTiltShiftShader`: These recreate a
    tilt-shift effect. With the tilt-shift effect, it is possible to create scenes
    that look miniature by making sure that only part of the image is sharp.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalTiltShiftShader`和`VerticalTiltShiftShader`: 这些着色器重新创建了一个倾斜移位效果。通过倾斜移位效果，可以确保只有图像的一部分是清晰的，从而创建出类似微缩景观的场景。'
- en: '`FocusShader`: This is a simple shader that results in a sharply rendered center
    area with blurring along its borders.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FocusShader`: 这是一个简单的着色器，它产生一个边缘模糊的中心区域。'
- en: 'Finally, there are a number of shaders that we won’t look at in detail; we
    are listing them simply for the sake of completeness. These shaders are mostly
    used internally, by either another shader or the shader passes that we discussed
    at the beginning of this chapter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些我们不会详细查看的着色器；我们只是简单地列出它们，以示完整性。这些着色器主要在内部使用，由另一个着色器或我们在本章开头讨论的着色器通道使用：
- en: '`THREE.FXAAShader`: This shader applies an anti-aliasing effect during the
    postprocessing phase. Use this if applying anti-aliasing during rendering is too
    expensive.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.FXAAShader`: 这个着色器在后期处理阶段应用抗锯齿效果。如果你在渲染时应用抗锯齿太昂贵，请使用此着色器。'
- en: '`THREE.ConvolutionShader`: This shader is used internally by the `BloomPass`
    render pass.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ConvolutionShader`: 该着色器在`BloomPass`渲染通道内部使用。'
- en: '`THREE.DepthLimitedBlurShader`: This is used internally by `SAOPass` for ambient
    occlusion.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.DepthLimitedBlurShader`: 该着色器在`SAOPass`用于环境光遮蔽。'
- en: '`THREE.HalftoneShader`: This is used internally by `HalftonePass`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.HalftoneShader`: 该着色器在`HalftonePass`内部使用。'
- en: '`THREE.SAOShader`: This provides ambient occlusion in shader form.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.SAOShader`: 该着色器以着色器形式提供环境光遮蔽。'
- en: '`THREE.SSAOShader`: This provides an alternative approach to ambient occlusion
    in shader form.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.SSAOShader`: 该着色器以着色器形式提供环境光遮蔽的替代方法。'
- en: '`THREE.SMAAShader`: This provides anti-aliasing to the rendered scene.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.SMAAShader`: 该着色器为渲染场景提供抗锯齿。'
- en: '`THREE.ToneMapShader`: This is used internally by `AdaptiveToneMappingPass`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ToneMapShader`: 该着色器在`AdaptiveToneMappingPass`内部使用。'
- en: '`UnpackDepthRGBAShader`: This can be used to visualize encoded depth values
    from an RGBA texture as a visual color.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnpackDepthRGBAShader`: 该着色器可用于将RGBA纹理中编码的深度值可视化为颜色。'
- en: If you look through the `Shaders` directory of the Three.js distribution, you
    might notice a couple of other shaders that we haven’t listed in this chapter.
    These shaders –`FresnelShader`, `OceanShader`, `ParallaxShader`, and `WaterRefractionShader`
    – aren’t shaders that can be used for postprocessing, but they should be used
    with the `THREE.ShaderMaterial` object that we discussed in [*Chapter 4*](B18726_04.xhtml#_idTextAnchor056),
    *Working with Three.js Materials*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看Three.js分发的`Shaders`目录，可能会注意到我们在这章中没有列出的一些其他着色器。这些着色器 – `FresnelShader`、`OceanShader`、`ParallaxShader`和`WaterRefractionShader`
    – 不是用于后期处理的着色器，但它们应该与我们在[*第4章*](B18726_04.xhtml#_idTextAnchor056)中讨论的`THREE.ShaderMaterial`对象一起使用，*使用Three.js材质*。
- en: We will start with a couple of simple shaders.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从几个简单的着色器开始。
- en: Simple shaders
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单着色器
- en: To experiment with the basic shaders, we’ve created an example where you can
    play around with most of the shaders and see the effects directly in the scene.
    You can find this example at `shaders.html`. The following screenshots show some
    of the effects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验基本着色器，我们创建了一个示例，您可以在其中尝试大多数着色器并直接在场景中看到效果。您可以在`shaders.html`中找到此示例。以下截图显示了其中一些效果。
- en: 'The `BrightnessContrastShader` effect is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrightnessContrastShader`效果如下：'
- en: '![Figure 11.18 – The BrightnessContractShader effect](img/Figure_11.18_B18726.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – BrightnessContractShader效果](img/Figure_11.18_B18726.jpg)'
- en: Figure 11.18 – The BrightnessContractShader effect
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – BrightnessContractShader效果
- en: 'The `SobelOperatorShader` effect detects outlines:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`SobelOperatorShader`效果检测轮廓：'
- en: '![Figure 11.19 – The SobelOperatorShader effect](img/Figure_11.19_B18726.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19 – SobelOperatorShader效果](img/Figure_11.19_B18726.jpg)'
- en: Figure 11.19 – The SobelOperatorShader effect
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – SobelOperatorShader效果
- en: 'You can create a kaleidoscope effect using `KaleidoShader`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`KaleidoShader`创建万花筒效果：
- en: '![Figure 11.20 – The KaleidoShader effect](img/Figure_11.20_B18726.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图11.20 – KaleidoShader效果](img/Figure_11.20_B18726.jpg)'
- en: Figure 11.20 – The KaleidoShader effect
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 – KaleidoShader效果
- en: 'You can mirror parts of the scene with `MirrorShader`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`MirrorShader`镜像场景的一部分：
- en: '![Figure 11.21 – The MirrorShader effect](img/Figure_11.21_B18726.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21 – MirrorShader效果](img/Figure_11.21_B18726.jpg)'
- en: Figure 11.21 – The MirrorShader effect
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 – MirrorShader效果
- en: 'The `RGBShiftShader` effect looks like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`RGBShiftShader`效果如下：'
- en: '![Figure 11.22 – The RGBShiftShader effect](img/Figure_11.22_B18726.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图11.22 – RGBShiftShader效果](img/Figure_11.22_B18726.jpg)'
- en: Figure 11.22 – The RGBShiftShader effect
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 – RGBShiftShader效果
- en: 'You can play around with the luminosity in the scene with `LuminosityHighPassShader`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`LuminosityHighPassShader`在场景中调整亮度：
- en: '![Figure 11.23 – The LuminosityHighPassShader effect](img/Figure_11.23_B18726.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图11.23 – LuminosityHighPassShader效果](img/Figure_11.23_B18726.jpg)'
- en: Figure 11.23 – The LuminosityHighPassShader effect
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 – LuminosityHighPassShader效果
- en: To see the other effects, use the menu on the right to see what they do and
    how they can be configured. Three.js also provides a couple of shaders that are
    specifically used to add blurring effects. Those are shown in the next section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其他效果，请使用右侧菜单查看它们的功能以及如何配置。Three.js还提供了一些专门用于添加模糊效果的着色器。这些着色器将在下一节中展示。
- en: Blurring shaders
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊着色器
- en: 'Again in this section, we won’t dive into the code; we’ll just show you the
    results of the various blur shaders. You can experiment with these by using the
    `shaders-blur.html` example. The first two shaders shown are `HorizontalBlurShader`
    and `VerticalBlurShader`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会深入代码；我们只会展示各种模糊着色器的结果。你可以通过使用 `shaders-blur.html` 示例来实验这些着色器。展示的前两个着色器是
    `HorizontalBlurShader` 和 `VerticalBlurShader`：
- en: '![Figure 11.24 – HorizontalBlurShader and VerticalBlurShader](img/Figure_11.24_B18726.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – 水平模糊着色器和垂直模糊着色器](img/Figure_11.24_B18726.jpg)'
- en: Figure 11.24 – HorizontalBlurShader and VerticalBlurShader
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 水平模糊着色器和垂直模糊着色器
- en: 'Another blur-like effect is provided by `HorizontalTiltShiftShader` and `VerticalTiltShiftShader`.
    This shader doesn’t blur the complete scene, only a small area. This provides
    an effect called tilt-shift. This is often used to create miniature-like scenes
    from normal photographs. The following screenshot shows this effect:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类似模糊的效果由 `HorizontalTiltShiftShader` 和 `VerticalTiltShiftShader` 提供。这种着色器不会模糊整个场景，而只是一个小区域。这产生了一种称为倾斜移位的效果。这通常用于从普通照片中创建类似微缩模型的效果。以下截图显示了此效果：
- en: '![Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader](img/Figure_11.25_B18726.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25 – 水平倾斜移位着色器和垂直倾斜移位着色器](img/Figure_11.25_B18726.jpg)'
- en: Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25 – 水平倾斜移位着色器和垂直倾斜移位着色器
- en: 'And the last of the blur-like effects is provided by `FocusShader`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类似模糊的效果由 `FocusShader` 提供：
- en: '![Figure 11.26 – FocusShader](img/Figure_11.26_B18726.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.26 – 聚焦着色器](img/Figure_11.26_B18726.jpg)'
- en: Figure 11.26 – FocusShader
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.26 – 聚焦着色器
- en: So far, we’ve used the shaders provided by Three.js. However, it is also possible
    to write your own shaders for use with `THREE.EffectComposer`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了 Three.js 提供的着色器。然而，你也可以为 `THREE.EffectComposer` 编写自己的着色器。
- en: Creating custom postprocessing shaders
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义后处理着色器
- en: In this section, you’ll learn how to create a custom shader that you can use
    in postprocessing. We’ll create two different shaders. The first one will convert
    the current image to a grayscale image, and the second one will convert the image
    to an 8-bit image by reducing the number of colors that are available.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建一个可以在后处理中使用的自定义着色器。我们将创建两个不同的着色器。第一个将当前图像转换为灰度图像，第二个将通过减少可用的颜色数量将图像转换为
    8 位图像。
- en: Vertex and fragment shaders
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器
- en: 'Creating vertex and fragment shaders is a very broad subject. In this section,
    we will only touch the surface of what can be done by these shaders and how they
    work. For more in-depth information, you can find the WebGL specification at [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/).
    An additional resource, full of examples, is Shadertoy, available at [https://www.shadertoy.com](https://www.shadertoy.com),
    or *The Book of* *Shaders*: [https://thebookofshaders.com/](https://thebookofshaders.com/).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建顶点和片段着色器是一个非常广泛的主题。在本节中，我们只会触及这些着色器可以做什么以及它们是如何工作的表面。对于更深入的信息，你可以在 [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/)
    找到 WebGL 规范。另一个充满示例的资源是 Shadertoy，可在 [https://www.shadertoy.com](https://www.shadertoy.com)
    或 *The Book of* *Shaders* [https://thebookofshaders.com/](https://thebookofshaders.com/)
    找到。
- en: Custom grayscale shader
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义灰度着色器
- en: 'To create a custom shader for Three.js (and also for other WebGL libraries),
    you have to create two components: a vertex shader and a fragment shader. The
    vertex shader can be used to change the position of individual vertices, and the
    fragment shader can be used to determine the colors of individual pixels. For
    a postprocessing shader, we only need to implement a fragment shader, and we can
    keep the default vertex shader provided by Three.js.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Three.js（以及其他 WebGL 库）创建自定义着色器，你必须创建两个组件：一个顶点着色器和一个片段着色器。顶点着色器可以用来改变单个顶点的位置，而片段着色器可以用来确定单个像素的颜色。对于后处理着色器，我们只需要实现一个片段着色器，并且可以保留
    Three.js 提供的默认顶点着色器。
- en: An important point to make before looking at the code is that GPUs support multiple
    shader pipelines. This means that the vertex shaders run in parallel on multiple
    vertices at the same time, and the same goes for the fragment shaders.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之前，一个重要的问题是 GPU 支持多个着色器管线。这意味着顶点着色器可以在多个顶点上同时并行运行，片段着色器也是如此。
- en: 'Let’s start by looking at the complete source code for the shader that applies
    a grayscale effect to our image (`custom-shader.js`):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看应用于我们的图像以产生灰度效果的着色器的完整源代码（`custom-shader.js`）：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An alternative way of defining shaders
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 定义着色器的另一种方法
- en: In [*Chapter 4*](B18726_04.xhtml#_idTextAnchor056), we showed how to define
    the shaders in separate standalone files. In Three.js, most shaders follow the
    structure seen in the previous code fragment. Both methods can be used to define
    the code of the shaders.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18726_04.xhtml#_idTextAnchor056)中，我们展示了如何将着色器定义在独立的单独文件中。在Three.js中，大多数着色器遵循前面代码片段中看到的结构。这两种方法都可以用来定义着色器的代码。
- en: As you can see in the preceding code block, this isn’t JavaScript. When you
    write shaders, you write them in the **OpenGL Shading Language** (**GLSL**), which
    looks a lot like the C programming language. More information on GLSL can be found
    at [http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，这并不是JavaScript。当你编写着色器时，你使用的是**OpenGL着色语言**（**GLSL**），它看起来很像C编程语言。有关GLSL的更多信息，请参阅[http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/)。
- en: 'First, let’s look at the vertex shader:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看顶点着色器：
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For postprocessing, this shader doesn’t really need to do anything. The preceding
    code is the standard way that Three.js implements a vertex shader. It uses `projectionMatrix`,
    which is the projection from the camera, together with `modelViewMatrix`, which
    maps an object’s position into the world position, in order to determine where
    to render a vertex on screen. For postprocessing, the only interesting thing in
    this piece of code is that the `uv` value, which indicates which texel to read
    from a texture, is passed on to the fragment shader using the `varying vec2` `vUv`
    variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后期处理，这个着色器实际上并不需要做任何事情。前面的代码是Three.js实现顶点着色器的标准方式。它使用`projectionMatrix`，这是从相机来的投影，以及`modelViewMatrix`，它将对象的位置映射到世界位置，以确定在屏幕上渲染顶点的位置。对于后期处理，这段代码中唯一有趣的事情是`uv`值，它指示从纹理中读取哪个texel，通过`varying
    vec2` `vUv`变量传递到片段着色器。
- en: 'This can be used to get the pixel to modify in the fragment shader. Now, let’s
    look at the fragment shader and see what the code is doing. We will start with
    the following variable declaration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来在片段着色器中修改像素。现在，让我们来看看片段着色器，看看代码在做什么。我们将从以下变量声明开始：
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we can see four instances of the `uniform` property. The instances of
    the `uniform` property have values that are passed in from JavaScript to the shader,
    which are the same for each fragment that is processed. In this case, we pass
    in three floats, identified by type `float` (which are used to determine the ratio
    of a color to include in the final grayscale image), and a texture (`tDiffuse`)
    is also passed in, identified by type `tDiffuse`. This texture contains the image
    from the previous pass from the `EffectComposer` instance. Three.js makes sure
    this texture gets passed to this shader when `tDiffuse` is used as its name. We
    can also set the other instances of the `uniform` property from JavaScript by
    ourselves. Before we can use these uniforms from JavaScript, we have to define
    which `uniform` properties we want to expose to JavaScript. This is done as follows,
    at the top of the shader file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到四个`uniform`属性的实例。`uniform`属性的实例具有从JavaScript传递到着色器的值，这些值对于每个处理的片段都是相同的。在这种情况下，我们传递了三个由类型`float`（用于确定要包含在最终灰度图像中的颜色的比例）标识的浮点数，以及一个纹理（`tDiffuse`），由类型`tDiffuse`标识。这个纹理包含来自`EffectComposer`实例的前一个传递中的图像。Three.js确保当使用`tDiffuse`作为其名称时，这个纹理会被传递到这个着色器。我们也可以自己设置`uniform`属性的其它实例。在我们能够从JavaScript中使用这些uniform之前，我们必须定义我们想要暴露给JavaScript的`uniform`属性。这是在着色器文件顶部按照以下方式完成的：
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, we can receive configuration parameters from Three.js, which
    will provide the output of the current rendering. Let’s look at the code that
    will convert each pixel to a gray pixel:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以从Three.js接收配置参数，这将提供当前渲染的输出。让我们看看将每个像素转换为灰度像素的代码：
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What happens here is that we get the correct pixel from the passed-in texture.
    We do this by using the `texture2D` function, where we pass in our current image
    (`tDiffuse`) and the location of the pixel (`vUv`) that we want to analyze. The
    result is a texel (a pixel from a texture) that contains a color and an opacity
    (`texel.w`). Next, we use the `r`, `g`, and `b` properties of this texel to calculate
    a gray value. This gray value is set to the `gl_FragColor` variable, which is
    eventually shown on the screen. And, with that, we have our own custom shader.
    This shader is used in the same way that we’ve already seen a couple of times
    in this chapter. First, we just need to set up `EffectComposer`, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是我们从传入的纹理中获取正确的像素。我们通过使用`texture2D`函数来完成这个操作，其中我们传入当前图像（`tDiffuse`）和我们想要分析的像素位置（`vUv`）。结果是包含颜色和不透明度（`texel.w`）的纹理像素（texel，纹理中的像素）。接下来，我们使用这个texel的`r`、`g`和`b`属性来计算一个灰度值。这个灰度值被设置为`gl_FragColor`变量，最终显示在屏幕上。并且，这样我们就有了自己的自定义着色器。这个着色器是以我们在本章中已经看到几次的方式使用的。首先，我们只需要设置`EffectComposer`，如下所示：
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We call `composer.render()` in the render loop. If we want to change the properties
    of this shader at runtime, we can just update the `uniforms` property that we’ve
    defined, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在渲染循环中调用`composer.render()`。如果我们想在运行时更改这个着色器的属性，我们只需更新我们定义的`uniforms`属性，如下所示：
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result can be seen in `custom-shaders-scene.html`. The following screenshot
    shows this example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在`custom-shaders-scene.html`中看到。以下截图显示了此示例：
- en: '![Figure 11.27 – A custom grayscale filter](img/Figure_11.27_B18726.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图11.27 – 自定义灰度过滤](img/Figure_11.27_B18726.jpg)'
- en: Figure 11.27 – A custom grayscale filter
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 – 自定义灰度过滤
- en: Let’s create another custom shader. This time, we’ll reduce the 24-bit output
    to a lower bit count.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个自定义着色器。这次，我们将24位输出减少到更低的位计数。
- en: Creating a custom bit shader
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义位着色器
- en: Normally, colors are represented as a 24-bit value, which gives us about 16
    million different colors. In the early days of computing, this wasn’t possible,
    and the colors were often represented as 8- or 16-bit colors. With this shader,
    we’ll automatically transform our 24-bit output to a color depth of 4 bits (or
    anything that you want).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，颜色以24位值表示，这给我们大约1600万种不同的颜色。在计算机的早期阶段，这是不可能的，颜色通常以8位或16位颜色表示。使用这个着色器，我们将自动将24位输出转换为4位颜色深度（或任何你想要的）。
- en: 'Since the vertex shader is the same as in our previous example, we’ll skip
    the vertex shader and directly list the definition of the `uniforms` property:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶点着色器与我们的前一个示例相同，我们将跳过顶点着色器，直接列出`uniforms`属性的定义：
- en: '[PRE24]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `fragmentShader` code is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragmentShader`代码如下：'
- en: '[PRE25]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We define two instances of the `uniform` property, which can be used to configure
    this shader. The first one is what Three.js uses to pass in the current screen,
    and the second one is defined by us as an integer (`type:"i"`) and serves as the
    color depth that we want to render the result in. The code itself is very straightforward:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个`uniform`属性的实例，可以用来配置这个着色器。第一个是Three.js用来传入当前屏幕的，第二个是我们定义的整数（`type:"i"`），作为我们想要渲染结果的颜色深度。代码本身非常直接：
- en: First, we get `texel` from the `tDiffuse` texture, based on the passed-in `vUv`
    location of the pixel.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们根据传入的像素位置`vUv`从`tDiffuse`纹理中获取`texel`。
- en: We calculate the number of colors that we can have, based on the `bitSize` property,
    by calculating 2 to the power of `bitSize` (`pow(float(bitSize),2.0))`).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据`bitSize`属性计算我们可以拥有的颜色数量，通过计算`2`的`bitSize`次方（`pow(float(bitSize),2.0)`）。
- en: Next, we calculate the new value of the color of `texel` by multiplying this
    value by `n`, rounding it off (`floor(texel.r*n)`), and dividing it again by `n`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将此值乘以`n`，四舍五入（`floor(texel.r*n)`），然后再除以`n`来计算`texel`颜色的新值。
- en: The result is set to `gl_FragColor` (red, green, and blue values and the opacity)
    and shown on the screen.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果被设置为`gl_FragColor`（红色、绿色和蓝色值以及不透明度）并在屏幕上显示。
- en: 'You can view the result for this custom shader in the same example as our previous
    custom shader, `custom-shaders-scene.html`. The following screenshot shows this
    example, where we set the bit size to 4\. This means the model is rendered in
    only 16 colors:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们之前的自定义着色器相同的示例`custom-shaders-scene.html`中查看这个自定义着色器的结果。以下截图显示了此示例，我们将位大小设置为4。这意味着模型只以16种颜色渲染：
- en: '![Figure 11.28 – A custom bit filter](img/Figure_11.28_B18726.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图11.28 – 自定义位过滤](img/Figure_11.28_B18726.jpg)'
- en: Figure 11.28 – A custom bit filter
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 – 自定义位过滤
- en: That’s it for this chapter on postprocessing.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于后处理的介绍到此结束。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed many different postprocessing options in this chapter. As you saw,
    creating `EffectComposer` and chaining passes together is actually very easy.
    You just have to keep a few things in mind. Not all passes will have an output
    on the screen. If you want to output to the screen, you can always use `ShaderPass`
    with `CopyShader`. The sequence in which you add passes to a composer is important.
    The effects are applied in that sequence. If you want to reuse the result from
    a specific `EffectComposer` instance, you can do so by using `TexturePass`. When
    you have more than one `RenderPass` in your `EffectComposer`, make sure to set
    the `clear` property to `false`. If not, you’ll only see the output from the last
    `RenderPass` step. If you want to only apply an effect to a specific object, you
    can use `MaskPass`. When you’re done with the mask, clear the mask with `ClearMaskPass`.
    Besides the standard passes provided by Three.js, there are also many standard
    shaders available. You can use these together with `ShaderPass`. Creating custom
    shaders for postprocessing is very easy, using the standard approach from Three.js.
    You only have to create a fragment shader.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了许多不同的后处理选项。正如你所见，创建`EffectComposer`并将多个步骤链接起来实际上非常简单。你只需记住几点。并非所有步骤都会在屏幕上产生输出。如果你想输出到屏幕，你可以始终使用带有`CopyShader`的`ShaderPass`。你将步骤添加到作曲家的顺序很重要。效果将按照这个顺序应用。如果你想重用特定`EffectComposer`实例的结果，你可以通过使用`TexturePass`来实现。当你有多个`RenderPass`在你的`EffectComposer`中时，确保将`clear`属性设置为`false`。如果不这样做，你将只能看到最后一个`RenderPass`步骤的输出。如果你想只将效果应用到特定的对象上，你可以使用`MaskPass`。当你完成遮罩后，使用`ClearMaskPass`清除遮罩。除了Three.js提供的标准步骤外，还有许多标准着色器可用。你可以将这些与`ShaderPass`一起使用。使用Three.js的标准方法创建自定义后处理着色器非常简单。你只需创建一个片段着色器。
- en: We have now covered pretty much everything there is to know about the core of
    Three.js. In [*Chapter 12*](B18726_12.xhtml#_idTextAnchor212), *Adding Physics
    and Sounds to Your Scene*, we’ll look at a library called Rapier.js, which you
    can use to extend Three.js with physics, in order to apply collisions, gravity,
    and constraints.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了关于Three.js核心的几乎所有知识。在[*第12章*](B18726_12.xhtml#_idTextAnchor212) *向场景添加物理和声音*中，我们将探讨一个名为Rapier.js的库，你可以使用它来扩展Three.js以添加物理效果，以便应用碰撞、重力和约束。
