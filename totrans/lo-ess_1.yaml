- en: Chapter 1. Working with Arrays and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 使用数组和集合
- en: Lo-Dash offers a wide variety of functions that operate on arrays and collections.
    This generally involves iterating over the collection in one form or another.
    Lo-Dash helps make iterative behavior easy to implement, including searching for
    data, as well as building new data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 提供了各种在数组和集合上操作的功能。这通常涉及以某种形式遍历集合。Lo-Dash 帮助使迭代行为易于实现，包括搜索数据以及构建新的数据结构。
- en: Collections are at the heart of applicative programming. This is where we will
    successively apply functions to each element in the collection. This chapter introduces
    the concept of the collection, something Lo-Dash code uses extensively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是应用编程的核心。这是我们将会连续对集合中的每个元素应用函数的地方。本章介绍了集合的概念，这是 Lo-Dash 代码广泛使用的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Iterating over collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合
- en: Sorting data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序数据
- en: Searching for data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索数据
- en: Slicing collections into smaller pieces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合切割成更小的部分
- en: Transforming collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换集合
- en: The difference between arrays and collections
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和集合之间的区别
- en: One of the initial sources of confusion for newcomers to Lo-Dash is the distinction
    between arrays and collections. The Lo-Dash API has a set of functions for arrays,
    and a set of functions for collections. But why? It would appear that these functions
    are interchangeable for any collection. Well, a better definition of what a collection
    actually is according to Lo-Dash might clear things up.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Lo-Dash 新手来说，最初感到困惑的来源之一是数组和集合之间的区别。Lo-Dash API 为数组提供了一套函数，并为集合提供了一套函数。但为什么？这些函数似乎对任何集合都是可互换的。好吧，根据
    Lo-Dash，对集合实际上是什么的更好定义可能会澄清一些事情。
- en: A collection is an abstract concept. That is, we can use the collection functions
    found in Lo-Dash on any JavaScript object that we'd like to iterate over. For
    example, the `forEach()` function will happily iterate over an array, a string,
    or an object. The subtle differences between these types, and what they mean when
    it comes to iterating, are hidden from the developer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个抽象概念。也就是说，我们可以使用 Lo-Dash 中找到的集合函数来迭代我们想要的任何 JavaScript 对象。例如，`forEach()`
    函数会愉快地遍历数组、字符串或对象。这些类型之间的微妙差异以及它们在迭代中的含义对开发者来说是隐藏的。
- en: The array functions provided by Lo-Dash are less abstract, they do, in fact,
    expect an array. In a sense, even these functions are abstract because they don't
    explicitly check for the `Array` type. They require that the object supports numerical
    indices and that it has a numerical `length` property.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 提供的数组函数更少抽象，实际上它们确实期望一个数组。从某种意义上说，即使是这些函数也是抽象的，因为它们并没有明确检查 `Array` 类型。它们要求对象支持数值索引，并且具有数值的
    `length` 属性。
- en: The takeaway is that, in the overwhelming majority of your days as a Lo-Dash
    programmer, the distinction between arrays and collections does not matter. Mainly,
    because the primary collection type will be an array anyway. In a small minority
    of cases, where the distinction does matter, just remember that the array functions
    have a slightly stricter criteria for what they consider acceptable data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的教训是，在作为 Lo-Dash 程序员的大部分日子里，数组和集合之间的区别并不重要。主要是因为主要的集合类型将始终是数组。在极少数情况下，当区别很重要时，只需记住数组函数对它们认为可接受的数据有稍微严格一些的标准。
- en: Iterating over collections
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'Lo-Dash does a lot of iterating over collections, whether it''s done explicitly
    by the developer, or done implicitly through a higher level Lo-Dash function.
    Let''s take a look at the basic `forEach()` function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 在集合上做了很多迭代，无论是开发者明确执行，还是通过高级 Lo-Dash 函数隐式执行。让我们看看基本的 `forEach()` 函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code doesn't do much, aside from logging the value of each item in the
    collection. It does, however, give you a general sense of what iterative functions
    look like in Lo-Dash. As the name implies, for each element in the array, apply
    the function callback. There's more than just the current element that's passed
    to the callback function. We also get the current index.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有做什么，除了记录集合中每个项目的值。然而，它确实给你一个关于 Lo-Dash 中迭代函数外观的一般感觉。正如其名所示，对于数组中的每个元素，应用函数回调。传递给回调函数的不仅仅是当前元素。我们还可以得到当前索引。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt Publishing书籍的账户中下载示例代码文件，网址为[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: 'Take a look at the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Returning `false` tells `forEach()` that this iteration will be the last. The
    index, with each iteration, is incremented and passed to the callback function
    as the second argument.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`false`告诉`forEach()`这个迭代将是最后一个。索引，在每次迭代中，都会递增并作为第二个参数传递给回调函数。
- en: 'The `forEach()` function iterates over the collection in the typical left-to-right
    fashion. If we want the inverse behavior, we can use the cousin function, `forEachRight()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`函数以典型的从左到右的方式遍历集合。如果我们想要相反的行为，我们可以使用其堂兄弟函数，`forEachRight()`：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This type of behavior is useful when we're working with sorted collections,
    as is the case in the preceding code. But, let's say we wanted to render this
    array data in the DOM in descending order. The preceding code shows that we can
    render each item in a given iteration. Using the `forEachRight()` function for
    this scenario has the advantage of not having to reverse-sort the array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在处理已排序的集合时很有用，正如前面代码所示。但是，假设我们想要以降序在DOM中渲染这个数组数据。前面的代码显示我们可以渲染给定迭代中的每个项目。在这种情况下使用`forEachRight()`函数的优势在于不需要对数组进行反转排序。
- en: However, many times this shortcut will not suffice, and you have to sort your
    collections. We'll take a look at the Lo-Dash functions that assist with sorting
    next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很多时候这个快捷方式是不够的，你必须对你的集合进行排序。接下来我们将查看Lo-Dash中帮助排序的函数。
- en: Sorting data
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序数据
- en: In Vanilla JavaScript, the approach to sorting involves arrays and two methods.
    The `sort()` method sorts the array in ascending order, using primitive comparison
    operations between the items. You can customize this behavior by passing `sort()`,
    a **comparator** function. For example, you use this callback function to sort
    an array in descending order. The other method, `reverse()`, simply reverses the
    order of the array. It's the inverse of the current order, whatever that might
    be.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中，排序的方法涉及数组和两种方法。`sort()`方法按升序对数组进行排序，使用原始的比较操作。你可以通过传递`sort()`，一个**比较器**函数来自定义这种行为。例如，你可以使用这个回调函数按降序排序一个数组。另一种方法，`reverse()`，只是简单地反转数组的顺序。它是当前顺序的相反，无论是什么。
- en: The native array `sort()` method sorts the array in-place although you might
    not want that to happen. Immutable operations reduce side effects because they
    don't change the original collection. Specifically, you might have requested the
    API data in a specific order. A region of the UI wants to render this array in
    a different sort order. Well, you don't want to change the order from what was
    requested. In this case, it would be better to have a function that returns a
    new array that contains the items of the original, but in the expected sort order.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原生的数组`sort()`方法在原地排序数组，尽管你可能不希望这样。不可变操作减少了副作用，因为它们不会改变原始集合。具体来说，你可能已经按特定顺序请求了API数据。UI的一个区域想要以不同的排序顺序渲染这个数组。好吧，你不想改变请求的顺序。在这种情况下，有一个返回包含原始项目但按预期排序顺序的新数组的函数会更好。
- en: Using sortBy()
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`sortBy()`
- en: 'The `sortBy()` function is the Lo-Dash answer to the native `Array.sort()`
    method. Since it''s an abstract collection function, it''s not limited to arrays.
    Take a look at the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortBy()`函数是Lo-Dash对原生`Array.sort()`方法的回应。由于它是一个抽象的集合函数，它不仅限于数组。看看下面的代码：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While the function works just fine with strings as the input, the output is
    a sorted array of characters; hence, the call to join them back together. This
    is because the `sortBy()`function always returns an array as the result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数与字符串作为输入正常工作时，输出是一个排序后的字符数组；因此，需要调用它们将它们重新组合在一起。这是因为`sortBy()`函数始终返回一个数组作为结果。
- en: 'The `sortBy()` function is similar to the native `Array.sort()` method, in
    that it sorts collection items in ascending order by default. Also, similar to
    the native method, we can pass in a callback function to `sortBy()` that''ll customize
    the sorting behavior, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortBy()` 函数与原生的 `Array.sort()` 方法类似，默认情况下按升序对集合项进行排序。同样，与原生方法类似，我们可以向 `sortBy()`
    传递一个回调函数来定制排序行为，如下所示：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding callback function passed to `sortBy()` returns the value of an
    object property. By doing this, the sorting behavior will compare the property
    values—in this case, `name`—instead of the objects themselves. There''s actually
    a shorter way to achieve the same result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `sortBy()` 的前面的回调函数返回对象属性的值。通过这样做，排序行为将比较属性值——在这种情况下，`name`——而不是对象本身。实际上，有一种更短的方法可以达到相同的结果：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is what's referred to as the **pluck style** shorthand in Lo-Dash terminology.
    We pass in the name of the property we want to sort the collection by. The value
    of this property is then plucked from each object in the collection. There's actually
    a `pluck()` function we'll look at in more depth later on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Lo-Dash 术语中被称为 **pluck 风格** 简写。我们传入我们想要按其排序集合的属性名称。然后从集合中的每个对象中提取该属性的值。实际上，我们将在稍后更深入地查看
    `pluck()` 函数。
- en: 'The last trick `sortBy()` has up its sleeve takes the pluck shorthand to the
    next level and allows sorting by multiple property names, as shown in the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortBy()` 有一个最后的技巧，它将 pluck 简写提升到了下一个层次，并允许按多个属性名进行排序，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The primary determinant of order here is the `age` property. If we specify a
    second property name, this is used to determine the order of elements that have
    the same primary sort order. It serves as a tie breaker. Here, there are two objects
    where `age` equals `10`. Since the `name` property is the secondary sort order,
    this is how these two objects are sorted. Multiple sort properties is a typical
    use case in web applications, which would require us to write a surprisingly large
    amount of JavaScript to achieve, if not for this Lo-Dash utility.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要排序决定因素是 `age` 属性。如果我们指定第二个属性名，则用于确定具有相同主要排序顺序的元素顺序。它充当决定性因素。这里有两个对象的 `age`
    等于 `10`。由于 `name` 属性是次要排序顺序，这就是这两个对象被排序的方式。在 Web 应用程序中，多个排序属性是一个典型用例，如果没有这个 Lo-Dash
    工具，我们将需要编写大量 JavaScript 代码来实现。
- en: Maintaining the sort order
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护排序顺序
- en: Using the `sortBy()` function is a great tool for changing the sort order of
    an existing collection, especially if we don't want to permanently alter the default
    sort order of that collection. Other times, however, you'll want to permanently
    keep a collection sorted. Sometimes, this is actually done for us by the backend
    API that sends us collections in the form of JSON data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sortBy()` 函数是改变现有集合排序顺序的绝佳工具，尤其是如果我们不希望永久更改该集合的默认排序顺序时。然而，在其他时候，你可能希望永久保持集合排序。有时，这实际上是由发送给我们以
    JSON 数据形式集合的后端 API 完成的。
- en: 'In these situations, sorting is easy because you don''t actually have to sort
    anything. It''s already done. The challenge lies in maintaining the sort order.
    Because, sometimes elements get added to collections in real time. The naive approach
    to maintain sort order here would be to simply add the new element to the collection
    then resort it. The Lo-Dash alternative is to figure out the insertion point that
    will keep the current collection sort order intact. This is shown in the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，排序很简单，因为你实际上不需要对任何东西进行排序。它已经完成了。挑战在于维护排序顺序。因为，有时元素会实时添加到集合中。维护排序顺序的直观方法是将新元素简单地添加到集合中然后重新排序。Lo-Dash
    的替代方案是找出将保持当前集合排序顺序的插入点。这在上面的代码中显示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new `name` variable gets inserted into the second-last position. This is
    really the only function needed to maintain the order of a sorted collection.
    The same `splice()` array method is used to remove items from the collection,
    which doesn't disrupt the order. Adding new items is a challenge because of the
    search that takes place to figure out the insertion index. The `sortedIndex()`
    function does a binary search on the collection to figure out where the new item
    fits.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `name` 变量被插入到倒数第二个位置。这实际上是维护排序集合顺序所需的功能。相同的 `splice()` 数组方法用于从集合中删除项目，这不会破坏顺序。添加新项目是一个挑战，因为需要搜索以确定插入索引。`sortedIndex()`
    函数在集合上执行二分搜索以确定新项目适合的位置。
- en: Searching for data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索数据
- en: Applications don't use entire collections. Rather, they iterate over a collection
    subset, or they look for a specific item in the collection. Lo-Dash has a number
    of functional tools to help the programmer find the data they need.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不使用整个集合。相反，它们遍历集合的子集，或者它们在集合中查找特定的项目。Lo-Dash提供了一些功能工具，帮助程序员找到他们需要的数据。
- en: Filtering collections
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 筛选集合
- en: 'The simplest way to perform a filter operation on a collection using Lo-Dash
    is to use the `where()` function. This function takes an object argument and will
    match its properties against each item in the collection, as shown in the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lo-Dash在集合上执行筛选操作的最简单方法是使用`where()`函数。该函数接受一个对象参数，并将匹配其属性与集合中的每个项目，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code filters the collection on both the `age` and the `gender`
    properties. The query translates to thirty-two year old females. The `Moe` object
    matches with neither property, while the `Dave` object matches with the `age`
    property, but not `gender`. A good way to think about `where()` filtering is that
    each object property you pass in as the filter will be logical *and* joined together.
    For example, match the `age` *and* the `gender` properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在`age`和`gender`属性上对集合进行了筛选。查询结果对应的是32岁的女性。`Moe`对象与这两个属性都不匹配，而`Dave`对象与`age`属性匹配，但与`gender`属性不匹配。关于`where()`筛选的一个好的思考方式是，你传递给筛选器的每个对象属性都将进行逻辑**并且**连接。例如，匹配`age`和`gender`属性。
- en: The `where()` function is great for its concise syntax and intuitive application
    to collections. With this simplicity comes a few limitations. First, the property
    values that we're comparing to each item in the collection must match exactly.
    Sometimes, we need comparisons a little more exotic than strict equality. Second,
    the logical `and` way that `where()` joins query conditions together isn't always
    desirable. Logical `or` conditions are just as common.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`函数因其简洁的语法和对集合的直观应用而非常出色。这种简单性带来了一些限制。首先，我们比较的属性值必须与集合中的每个项目完全匹配。有时，我们需要比严格相等更复杂的比较。其次，`where()`连接查询条件的方式的逻辑`and`并不总是令人满意。逻辑`or`条件同样常见。'
- en: 'For these types of advanced filtering capabilities, you should turn to the
    `filter()` function. Here''s a basic filter operation that''s even simpler than
    the `where()` queries:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些高级筛选功能，你应该转向`filter()`函数。这是一个基本的筛选操作，比`where()`查询还要简单：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the `enabled` property has **truthy** values for two objects in this collection,
    they're returned in a new array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个集合中`enabled`属性对两个对象有**真值**，它们被返回到一个新的数组中。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lo-Dash uses the notion of truthy values everywhere. This simply means that
    a value will test positive if used in an `if` statement or a ternary operator.
    Values don't need to be of Boolean type and `true` to be truthy. An object, an
    array, a string, a number—these are all truthy values. Whereas null, undefined,
    and 0— are all false.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash在所有地方都使用真值的概念。这仅仅意味着，如果在一个`if`语句或三元运算符中使用，值将测试为正。值不需要是布尔类型和`true`才能是真值。一个对象、一个数组、一个字符串、一个数字——这些都是真值。而null、undefined和0——都是假值。
- en: 'As mentioned, the `filter()` function fills gaps in the `where()` function.
    Unlike `where()`,`filter()` accepts a callback function that''s applied to each
    item in the collection, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`filter()`函数填补了`where()`函数的空白。与`where()`不同，`filter()`接受一个回调函数，该函数应用于集合中的每个项目，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The callback function uses an `or` condition to satisfy the `size` constraint
    here—`medium` or `large`. This is simply not doable with the `where` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数使用`or`条件来满足这里的`size`约束——`medium`或`large`。这用`where`函数是无法实现的。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `filter()` function accepts an object argument as well. In Lo-Dash terminology,
    this is called a **where style callback**. There are many functions, not just
    `filter()`, that accept the filter criteria specified as an object and behave
    like `where()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数也接受一个对象参数。在Lo-Dash术语中，这被称为**where风格回调**。许多函数，不仅仅是`filter()`，接受指定为对象的筛选标准，并像`where()`一样表现。'
- en: 'Filtering collections using the `filter()` function is good when we know what
    we''re looking for. The callback function gives the programmer enough flexibility
    to compose elaborate criteria. But sometimes, we don''t know what you need from
    a collection. Instead, you only know what you *don''t* need, as shown in the following
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道我们要找什么时，使用 `filter()` 函数过滤集合是好的。回调函数给程序员足够的灵活性来组合复杂的标准。但有时，我们不知道从集合中需要什么。相反，我们只知道我们不需要什么，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see here that only `enabled` items are returned that are equivalent
    to doing `_.filter(collection, {enabled: true})`,which is a simple inversion of
    `filter()`. Which function you use is a matter of personal preference and the
    context in which they''re used. Go for the one that reads cleaner in your code.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在这里看到，只有 `enabled` 项目被返回，这相当于执行 `_.filter(collection, {enabled: true})`，这是对
    `filter()` 的简单反转。你使用哪个函数取决于个人偏好以及它们被使用的上下文。选择在代码中读起来更清晰的那个。'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`reject()` actually uses the `filter()` function internally. It uses the `negate()`
    function to invert the result of the callback passed to `filter()`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`reject()` 实际上在内部使用了 `filter()` 函数。它使用 `negate()` 函数来反转传递给 `filter()` 的回调函数的结果。'
- en: Finding items in collections
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合中查找项目
- en: Sometimes, we need a specific collection item. Filtering a collection simply
    generates a new collection with less items in it. Conversely, finding items in
    a collection means finding a specific item.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要特定的集合项目。过滤集合只是生成一个包含较少项目的新的集合。相反，在集合中查找项目意味着找到特定的项目。
- en: 'The function used to find items in a collection is aptly named `find()`. This
    function accepts the same arguments as the `filter()` function. You can pass the
    name of the property as a string, an object filled with property names and values
    to execute a where style search, or just a plain callback function to match against
    whatever you want. The following is an example of this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在集合中查找项目的函数被恰当地命名为 `find()`。此函数接受与 `filter()` 函数相同的参数。你可以传递属性名称作为字符串，传递一个包含属性名称和值的对象以执行类似
    `where` 风格的搜索，或者传递一个简单的回调函数以匹配你想要的内容。以下是一个示例：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There're actually two items matching this where style criteria in the collection—`Derek`
    and `Malcolm`. If we were to run this code though, we'd see that only `Derek`
    is returned. That's because `find()` returns as soon as a match is found. Collection
    order matters when searching for items in collections. It doesn't take into consideration
    duplicate values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两个项目符合集合中的样式标准——`Derek` 和 `Malcolm`。如果我们运行这段代码，我们会看到只有 `Derek` 被返回。这是因为
    `find()` 函数一旦找到匹配项就会立即返回。在集合中搜索项目时，集合的顺序很重要。它不考虑重复的值。
- en: 'Let''s look in the other direction and see what we find. Using the same collection
    and the same search criteria, you can search in the opposite direction:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个方向看看我们会找到什么。使用相同的集合和相同的搜索标准，你可以向相反方向搜索：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While `find()` searches for the first occurrence of the matching item in the
    collection, `findLast()` searches for the last occurrence. This is useful when
    we're working with sorted collections—you can better optimize your linear searches.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `find()` 函数在集合中搜索匹配项的第一个出现，但 `findLast()` 函数则搜索最后一个出现。这在处理已排序的集合时非常有用——你可以更好地优化你的线性搜索。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While Lo-Dash heavily optimizes the `while` loops used when iterating over collections,
    searches executed using functions such as `find()` are linear. It's important
    to remember that it's up to the programmer using Lo-Dash to consider the performance
    implications of their unique application data. Lo-Dash functions are optimized
    for the generic common case, they're not going to magically make your code faster
    by virtue of using them. They're tools to *assist* the programmer to make incredibly
    high-performance code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Lo-Dash 对迭代集合时使用的 `while` 循环进行了大量优化，但使用 `find()` 等函数执行搜索是线性的。重要的是要记住，使用 Lo-Dash
    的程序员需要考虑他们独特应用数据带来的性能影响。Lo-Dash 函数针对通用常见情况进行优化，它们不会因为使用它们而神奇地使你的代码更快。它们是帮助程序员制作高性能代码的工具。
- en: Slicing collections into smaller pieces
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集合切割成更小的部分
- en: So far we've seen how collections can be filtered, creating a new smaller collection.
    Lo-Dash supplies you with a number of functions that take existing arrays and
    produce one or more smaller arrays. For example, you might want a portion of the
    first part of any array—or a portion of the last part. Arrays can be divided into
    chunks of smaller arrays that are useful for batched processing. You can also
    use Lo-Dash array tools to remove duplicates, thus ensuring the uniqueness of
    your array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何过滤集合，创建一个新的较小的集合。Lo-Dash 为你提供了一些函数，这些函数接受现有的数组并生成一个或多个较小的数组。例如，你可能想要任何数组的开头部分或结尾部分的一部分。数组可以被分成较小的数组块，这对于批量处理非常有用。你还可以使用
    Lo-Dash 数组工具来删除重复项，从而确保数组的唯一性。
- en: First and last collection portions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首尾集合部分
- en: 'With native JavaScript arrays, you can slice off the first portion of an array
    using the `slice()` array method. Lo-Dash provides abstractions on top of the
    native array `slice()` method that make it a little easier for the developer to
    write intuitive code—this isn''t always the case with the native array approach.
    Further, the Lo-Dash `take()` function operates on collections, so it''ll work
    with both arrays and strings, as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生的 JavaScript 数组，你可以使用 `slice()` 数组方法来截取数组的前一部分。Lo-Dash 在原生的数组 `slice()`
    方法之上提供了抽象，这使得开发者编写直观的代码变得稍微容易一些——这并不总是原生数组方法的情况。此外，Lo-Dash 的 `take()` 函数作用于集合，因此它可以与数组和字符串一起使用，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's a difference in the output when using `take()` on arrays and strings.
    When applying it to an array, it generates a new array, a subset of the original.
    However, when applying `take()` to strings, it returns a new array of individual
    characters. The preceding code will return `[ 'l', 'o' ]`. That's probably not
    what we're after most of the time, so we'll just join these characters back together
    with an empty string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `take()` 对数组进行操作和字符串操作时的输出有所不同。当应用于数组时，它生成一个新的数组，这是原始数组的一个子集。然而，当应用于字符串时，它返回一个包含单个字符的新数组。前面的代码将返回
    `[ 'l', 'o' ]`。这很可能不是我们想要的，所以我们将使用空字符串将这些字符重新组合在一起。
- en: 'We can slice off the last portions of collections and strings using the `takeRight()`
    function. Using the same array and string, you can run the following code to get
    the last portions of the collections:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `takeRight()` 函数来截取集合和字符串的最后部分。使用相同的数组和字符串，你可以运行以下代码来获取集合的最后部分：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The resulting array looks like `[ 'Rebecca', 'Alan']`. The resulting string
    looks like `'dash'`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组看起来像 `[ 'Rebecca', 'Alan']`。结果字符串看起来像 `'dash'`。
- en: Applying `take()` to a collection without any arguments will slice the first
    item. Likewise, applying `takeRight()` without any arguments slices off the last
    item. In both the cases, the returned value is a one item array, not the item
    itself. If you're just after the first or last collection items, use the `first()`
    and `last()` Lo-Dash functions respectively.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `take()` 应用于不带任何参数的集合将截取第一个项目。同样，将 `takeRight()` 应用于不带任何参数将截取最后一个项目。在这两种情况下，返回的值是一个包含一个项目的数组，而不是项目本身。如果你只是想要第一个或最后一个集合项目，请分别使用
    `first()` 和 `last()` Lo-Dash 函数。
- en: Splitting collections into chunks
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将集合分成块
- en: Sometimes, we're faced with large collections. Really large collections. Especially
    when using API data, the frontend doesn't always have control over the size of
    the dataset that's returned. When the API does return a mountain of data, there's
    a good chance that our code that processes it will lock the UI. We can't exactly
    say give me less data to work with so that the UI doesn't freeze. Freezing the
    UI is also unacceptable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会遇到大型集合。真的是非常大的集合。特别是当使用 API 数据时，前端并不总是能控制返回的数据集的大小。当 API 返回大量数据时，我们的代码处理这些数据可能会导致
    UI 冻结。我们无法确切地说给我们更少的数据来工作，这样 UI 就不会冻结。UI 冻结也是不可接受的。
- en: Lo-Dash iterates through collections very efficiently. It doesn't, however,
    have any control over the potentially expensive operations carried out by your
    code. And this is what causes the UI to freeze – not the size of the collection
    by itself, and not by executing an expensive operation once – it's the two factors
    combined together that become lethal for UI responsiveness.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 非常高效地遍历集合。然而，它并没有控制你代码中可能执行的成本高昂的操作。这就是导致 UI 冻结的原因——不是集合本身的大小，也不是执行一次成本高昂的操作——而是这两个因素结合在一起，对
    UI 的响应性构成了致命的威胁。
- en: 'The `chunk()` function is an easy way to split the processing of a really large
    collection into several smaller tasks. This gives the chance for the UI to update—render
    the pending DOM updates and processes the pending events. The usage of this function
    can be seen in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`chunk()` 函数是一种将处理非常大的集合分解为几个较小任务的方法。这给了UI更新的机会——渲染挂起的DOM更新并处理挂起的事件。这个函数的用法可以在以下代码中看到：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the preceding code is a bit of a turn off, don't worry. There're a few new
    concepts introduced here that you might find confusing. Let's start by explaining
    at a high level what the code is actually doing. A large collection is created
    and it's split into chunks of smaller collections. The `process()` function does
    some work with each chunk, then calls itself again to process the next chunk,
    until there are no chunks left.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的代码看起来有点让人望而却步，别担心。这里介绍了一些可能让你感到困惑的新概念。让我们先从高层次上解释一下代码实际上在做什么。创建了一个大集合，并将其分割成更小的集合块。`process()`
    函数对每个块进行一些工作，然后再次调用自身来处理下一个块，直到没有块为止。
- en: The collection itself is generated using the `range()` function, with `10000`
    integers in it. It's not the content that's important, but rather, the large size.
    The `chunk()` function is used to split the large collection into smaller ones.
    We specify the size we want each chunked collection to be and in this case, we
    get 20 smaller collections with 50 items each. The processing work is kicked off
    by the call to `process(chunks, 0)`. The second argument is the first chunk to
    begin with.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 集合本身是通过`range()`函数生成的，其中包含`10000`个整数。重要的是集合的大小，而不是内容。`chunk()`函数用于将大集合分割成更小的集合。我们指定了每个分割集合的大小，在这种情况下，我们得到了20个包含50个项目的较小集合。处理工作是通过调用`process(chunks,
    0)`开始的。第二个参数是要开始的第一个块。
- en: The `process()` function itself grabs the next chunk to process based on the
    `index` argument. If the chunk is undefined, it means that the end has been reached
    and there are no more chunks to process. Otherwise, we can start doing expensive
    processing on the chunk, as illustrated in the example with the `console.log()`
    call. Finally, the `defer()` function will start processing the next chunk. The
    reason we're using `defer()` is so that the call stack has a chance to clear,
    and the DOM operations have a chance to run. If we don't do this, there wouldn't
    be any point in using `chunk()` to split the processing. The `defer()` function
    expects a callback, and we make one using `partial()`, which creates a new function,
    with arguments already supplied to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()` 函数本身根据`index`参数获取下一个要处理的块。如果块未定义，这意味着已经到达了末尾，没有更多的块可以处理。否则，我们可以开始对块进行昂贵的处理，如示例中的`console.log()`调用所示。最后，`defer()`函数将开始处理下一个块。我们使用`defer()`的原因是给调用栈一个清空的机会，也给DOM操作一个运行的机会。如果我们不这样做，使用`chunk()`来分割处理就没有意义了。`defer()`函数期望一个回调，我们使用`partial()`来创建一个新函数，该函数已经提供了参数。'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `defer()` and `partial()` functions are covered in much more depth in [Chapter
    3](ch03.html "Chapter 3. Working with Functions"), *Working with Functions*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer()`和`partial()`函数在[第3章](ch03.html "第3章。使用函数")*使用函数*中有更深入的介绍。'
- en: 'How do we know what size to make our array chunks? In the previous code, we
    chose `50` as the chunk size. But is that an arbitrary decision, or is it based
    on the typical datasets used in the application? The short answer is that we have
    to tinker a little and optimize for the common case. This might mean doing something
    such as figuring out the chunk size based on a percentage of the overall collection
    size, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的数组块的大小？在之前的代码中，我们选择了`50`作为块大小。但这是一个任意决定，还是基于应用程序中使用的典型数据集？简短的答案是，我们必须稍微调整并针对常见情况进行优化。这可能意味着根据整体集合大小的百分比来确定块大小，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The chunk size here turns out to be `3`. The actual size is 2.5, but you take
    the ceiling of that since there's no such thing as 2.5 collection elements. Besides,
    what you're interested in is not the exactness of the chunk size, but rather,
    the proximity to the 25 percent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的块大小最终是`3`。实际大小是2.5，但由于没有2.5个集合元素，所以取其上限。此外，你感兴趣的不是块大小的精确度，而是接近25%的程度。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might have noticed that `3` doesn't divide evenly into 10\. The `chunk()`
    function is smart enough to not leave out items. Any remaining items that do not
    fill the chunk size are still included.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`3`不能整除`10`。`chunk()`函数足够智能，不会遗漏任何项。任何未填满块大小的剩余项仍然被包括在内。
- en: Building unique arrays
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建唯一数组
- en: Collections sometimes have unwanted duplicates in them. This could be a result
    of the API data itself that contains the duplicates, or as a side effect of other
    computations you're performing in the frontend. Regardless of the cause, Lo-Dash
    provides the tools necessary to quickly generate unique collections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中有时会有不想要的重复项。这可能是API数据本身包含重复项的结果，或者是在前端执行的其他计算中的副作用。无论原因如何，Lo-Dash提供了必要的工具，可以快速生成唯一的集合。
- en: 'The `uniq()` function takes a collection as the input and generates a new collection
    as output, with any duplicates removed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq()`函数接受一个集合作为输入，并生成一个新的集合作为输出，其中任何重复项都被移除：'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By default, the potential duplicates are compared against one another using
    the strict equality operator. In the preceding collection, the duplicate is found
    and removed because of `''Walter'' === ''Walter''`. You can specify, in more detail,
    how you want `uniq()` to compare values. For example, if we had a collection of
    objects and we only want unique objects based on the `name` property, we could
    write `_.uniq(collection, ''name'')`. The function also accepts a callback, which
    is used to compute the values before they''re compared. This is useful in situations
    where the uniqueness of an object isn''t so straightforward, as in the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，潜在的重复项使用严格相等运算符进行比较。在先前的集合中，由于`'Walter' === 'Walter'`，找到了重复项并将其移除。您可以更详细地指定您希望`uniq()`如何比较值。例如，如果我们有一个对象集合，我们只想基于`name`属性的唯一对象，我们可以编写`_.uniq(collection,
    'name')`。该函数还接受一个回调，用于在比较之前计算值。这在对象的唯一性不是那么直接的情况下很有用，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code ensures that the uniqueness of each object in the collection is based
    on the full name. There's no full name property, perhaps it's not needed anywhere
    else in the application. So, the `uniq()` function can just construct one on-the-fly,
    which is used for the sole purpose of validating this constraint.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保集合中每个对象的唯一性基于全名。可能没有全名属性，也许在应用程序的其他地方并不需要。因此，`uniq()`函数可以即时构建一个，这仅用于验证此约束的唯一目的。
- en: Transforming collections
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换集合
- en: Lo-Dash has a number of tools for transforming collections into new data structures.
    Additionally, there are tools that can take two or more collections and combine
    them into a single collection. These functions focus on the most common, yet most
    burdensome programming tasks faced by frontend developers. Instead of focusing
    on boilerplate collection transformations, you can get back to making a great
    application—users don't care about awesome compact code as much as you do.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash提供了一系列工具，可以将集合转换为新的数据结构。此外，还有一些工具可以将两个或多个集合组合成一个单一的集合。这些函数专注于前端开发者面临的最常见且最繁重的编程任务。您不必专注于样板集合转换，可以回到制作出色的应用程序——用户对您那样酷炫的紧凑代码的关注程度不如您。
- en: Grouping collection items
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组集合项
- en: 'Items in collections are sometimes grouped implicitly. For example, let''s
    say there''s a `size` property for a given class of objects whose allowable values
    are `''S''`, `''M''`, or `''L''`. The code in your frontend application might
    need to round up the items that contain these various groups for display purposes.
    Rather than writing our own code, we''ll let the `groupBy()` function handle the
    intricacies of constructing such a grouping:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的项有时会隐式分组。例如，假设有一个给定类对象的`size`属性，其允许的值是`'S'`、`'M'`或`'L'`。你的前端应用程序中的代码可能需要将包含这些各种组的项四舍五入以供显示。我们不会编写自己的代码，而是让`groupBy()`函数处理构建此类分组的复杂性：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `groupBy()` function, as you might have noticed by now, doesn't return a
    collection—it takes a collection as the input, but transforms it into an object.
    This object that `groupBy()` returns contains the original items of the input
    collection, they're just organized differently. The properties of the object are
    the values you want to group by. A majority of collection items in the preceding
    code will reside in the `S` property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()` 函数，正如你可能已经注意到的，它并不返回一个集合——它接受一个集合作为输入，但将其转换为一个对象。`groupBy()` 返回的对象包含输入集合的原始项，只是组织方式不同。该对象的属性是你要按其分组的值。前述代码中的大多数集合项将驻留在
    `S` 属性中。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll also see that transformative functions such as `groupBy()` don't actually
    modify the items themselves—just the collections they're in. That's why, in the
    resulting object from the preceding code, each item still has its `size` property,
    despite not really being needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到，像 `groupBy()` 这样的转换函数实际上并没有修改项本身——只是它们所在的集合。这就是为什么在前述代码的结果对象中，每个项仍然有它的
    `size` 属性，尽管实际上并不需要。
- en: 'When you pass in the property name as a string, `groupBy()` will use a pluck
    style callback to grab the value of that property from each item in the collection.
    The unique property values form the keys of the group object. As is often the
    case, object properties aren''t clear-cut and need to be computed at runtime.
    In the context of grouping items, function callbacks can be used to group collection
    items in cases where grouping isn''t a matter of a simple comparison, as in the
    following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以字符串形式传递属性名时，`groupBy()` 将使用 pluck 风格的回调函数从集合中的每个项中获取该属性的值。唯一的属性值形成分组对象的键。正如通常情况那样，对象属性并不明确，需要在运行时计算。在分组项的上下文中，函数回调可以用于在分组不是简单比较的情况下对集合项进行分组，如下述代码所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Rather than test for equality, this callback function tests for approximations.
    That is, anything greater than `65` in the `age` property is assumed to be retired.
    And we return that string as the group label. Keep in mind that it's best if these
    callback functions return primitive types for the keys. For any other values,
    the string `working` is returned. What's nice about these callback functions is
    that they can be used to quickly generate reports on the API data you're working
    with. The preceding example illustrates this with a one-liner callback function
    passed to `groupBy()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试相等性不同，此回调函数测试近似值。也就是说，`age` 属性中大于 `65` 的任何内容都被认为是退休的。我们将其作为分组标签返回。请记住，如果这些回调函数返回原始类型作为键，那就最好了。对于任何其他值，返回字符串
    `working`。这些回调函数的优点是，它们可以用来快速生成关于你正在处理的 API 数据的报告。前述示例通过传递给 `groupBy()` 的单行回调函数说明了这一点。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the `groupBy()` function will accept a where style object as the second
    parameter, this might not be what you're after. For example, if an item in the
    collection passes the test, it'll end up in the `true` group. Otherwise, it's
    a part of the `false` group. Be careful before going too far down the road with
    a pluck or where style callback—they might not do what you expect. Fiddle around
    and get quick results to sanity check your approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `groupBy()` 函数可以接受一个 where 风格的对象作为第二个参数，但这可能不是你想要的。例如，如果集合中的项通过了测试，它最终会进入
    `true` 组。否则，它就是 `false` 组的一部分。在深入使用 pluck 或 where 风格的回调函数之前要小心——它们可能不会按预期工作。尝试一下，快速得到结果以验证你的方法。
- en: Counting collection items
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算集合项数量
- en: 'Lo-Dash helps us find the minimum and maximum values of a collection. We might
    not need any help if we''re working with a lot of arrays that contain only numbers.
    If that''s the case, `Math.min()` is our friend. In nearly any other scenario,
    the `min()` and `max()` functions are the way to go, if for no other reason than
    the callback support. Let''s take a look at the following example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 帮助我们找到集合的最小值和最大值。如果我们处理的是只包含数字的大量数组，我们可能不需要任何帮助。如果是这种情况，`Math.min()`
    就是我们的朋友。在几乎所有其他情况下，`min()` 和 `max()` 函数都是最佳选择，至少因为它们支持回调。让我们看看以下示例：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first call is to `min()` and it gets a string argument—the name of the property
    we want the minimum value of in the collection. This uses the pluck style callback
    shorthand and produces concise code where you know the property you're working
    with. The second call in the preceding code is to `max()`. This function supports
    the same callback shorthand as `min()`, but here, there's no pre-existing property
    value for you to work with. Since what you want is the `age` property plus the
    `experience` property, the callback function supplied to `max()` computes this
    for us and figures out the maximum.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用是`min()`，它接收一个字符串参数——我们想要在集合中获取最小值的属性的名称。这使用了pluck风格的回调简写，并产生了简洁的代码，其中你知道你正在处理的属性。前面代码中的第二个调用是`max()`。这个函数支持与`min()`相同的回调简写，但在这里，没有预先存在的属性值供你使用。由于你想要的是`age`属性加上`experience`属性，提供给`max()`的回调函数为我们计算这个值并找出最大值。
- en: Note that the `min()` and `max()` functions return the actual collection item
    and not the minimum or maximum value. This makes sense because we're probably
    going to want to do something with the item itself, and not just the min/max value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`min()`和`max()`函数返回的是实际的集合项，而不是最小或最大值。这很有道理，因为我们可能想要对项本身进行操作，而不仅仅是获取最小/最大值。
- en: 'Beyond locating the minimum and maximum values of collections is finding the
    actual size of collections. This is easy if you''re working with arrays because
    they already have the built-in `length` property. It is the same with strings.
    However, objects don''t always have a `length` property. The Lo-Dash `size()`
    function tells you how many keys an object has, which is the intuitive behavior
    you''d expect from an object, but isn''t there, by default. Take a look at the
    following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了找到集合的最小和最大值之外，还需要找到集合的实际大小。如果你正在处理数组，这很容易，因为它们已经具有内置的`length`属性。字符串也是如此。然而，对象并不总是具有`length`属性。Lo-Dash的`size()`函数会告诉你对象有多少键，这是从对象中期望的直观行为，但默认情况下并不存在。看看下面的代码：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first call to `size()` returns the length of the collection. It'll look
    for a `length` property, and if the collection has one, this is the value that's
    returned. Since it's an array, the `length` property exists, and has a value of
    `4`. This is what's returned. The `first` variable is an object, so it has no
    `length` property. It'll count the number of keys in the object and return this
    value—in this case, `1`. Lastly, `size()` is called on a string. This has a length
    value of `6`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`函数的第一个调用返回集合的长度。它会寻找`length`属性，如果集合有一个，则返回这个值。由于它是一个数组，`length`属性存在，并且值为`4`。这就是返回的值。`first`变量是一个对象，因此它没有`length`属性。它会计算对象中的键的数量并返回这个值——在这个例子中，`1`。最后，`size()`被调用在一个字符串上。这个字符串的长度值为`6`。'
- en: We can see from all three uses of `size()` that there's little guessing involved.
    Where the default JavaScript behavior is inconsistent and unintuitive, Lo-Dash
    provides a single function to address common use cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从`size()`函数的三种用法中我们可以看出，其中几乎没有猜测的成分。在默认的JavaScript行为不一致且不直观的情况下，Lo-Dash提供了一个单一的功能来处理常见的用例。
- en: Flattening and compacting
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展平和压缩
- en: 'Arrays can nest to arbitrary depth and sometimes contain falsey values that
    are of no practical use. Lo-Dash has functions to deal with both these situations.
    For example, a component of our UI might get passed as an array that has arrays
    nested inside it. But our component doesn''t make use of this structure, and it''s,
    in fact, more of a hindrance than it is helpful. We can *flatten* the array to
    extract and throw away the unnecessary structure your component does not need,
    as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以嵌套到任意深度，有时会包含没有实际用途的假值。Lo-Dash有函数来处理这两种情况。例如，我们的UI组件可能被传递为一个包含嵌套数组的数组。但我们的组件并不使用这种结构，实际上，它更多的是一种阻碍而不是帮助。我们可以*展平*数组以提取并丢弃组件不需要的不必要结构，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, we don't actually alter the structure of the original collection,
    we build a new one on the fly, better suited for the current context. In the preceding
    example, the collection consists of `employer` objects. However, our component
    is more concerned with the `employee` objects. So, the first step is to pluck
    those out of their objects using `pluck()`. This gets us an array of arrays. Because
    what we're actually plucking is the `employee` array from each `employer` array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们实际上并没有改变原始集合的结构，而是在实时构建一个新的集合，使其更适合当前的环境。在先前的例子中，该集合由`employer`对象组成。然而，我们的组件更关注的是`employee`对象。因此，第一步是使用`pluck()`方法将这些对象从其原始对象中提取出来。这会得到一个数组的数组。因为我们实际上提取的是每个`employer`数组中的`employee`数组。
- en: The next step is to flatten this `employee` array into an array of `employee`
    objects, which `flatten()` handles easily. The point of doing all this, which
    isn't really a lot, is now we have an easy structure to filter. Particularly,
    this code uses the flattened collection structure to filter out the employee names
    that start with `b` or `p`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这个`employee`数组扁平化为一个`employee`对象的数组，`flatten()`函数可以轻松处理这一点。做所有这些事情的目的，虽然实际上并不多，现在我们有一个易于过滤的结构。特别是，这段代码使用扁平化的集合结构来过滤掉以`b`或`p`开头的员工姓名。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's another flatten function called `flattenDeep()`, which goes to arbitrary
    nested array depths to create a flattened structure. This is handy when you need
    to go beyond the one level of nesting that `flatten()` looks in. However, it's
    not a good idea to flatten arrays of unknown size and depth, simply due to the
    performance implications. There's a good chance that large array structures can
    lock the UI for your users.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为`flattenDeep()`的扁平化函数，它可以访问任意嵌套数组的深度以创建一个扁平化的结构。当你需要超出`flatten()`函数查看的一级嵌套时，这很有用。然而，由于性能影响，不建议扁平化未知大小和深度的数组。大型数组结构有很大可能锁定用户的UI。
- en: 'A close cousin to `flatten()` is the `compact()` function, often used in conjunction
    with one another. We''ll use `compact()` to remove the falsey values from a flattened
    array, to just use it on a plain array that already exists, or just to take out
    the falsey values before it''s filtered. This is shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten()`函数的近亲是`compact()`函数，通常一起使用。我们将使用`compact()`来从扁平化数组中移除假值，或者仅用于已经存在的普通数组，或者在其过滤之前移除假值。这将在以下代码中展示：'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that this collection has some values in it that we clearly don't
    want to deal with. But, the hopefully-not-so-sad reality is that doing frontend
    development in a dynamically-typed language with backend data means that you have
    no control over a lot of sanity checking. All that the preceding code does with
    the `compact()` function is remove any of the falsey values from the collection.
    These are things such as `0`, `null`, and `undefined`. In fact, this code wouldn't
    even run without compacting the collection since it makes the implicit assumption
    about the `name` property being defined on each object in the collection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个集合中有些值是我们显然不想处理的。但，希望不是那么令人悲伤的现实是，在动态类型语言中进行前端开发，并且使用后端数据意味着你无法控制很多合理性检查。前面代码使用`compact()`函数所做的只是从集合中移除任何假值。这些值包括`0`、`null`和`undefined`。实际上，如果没有压缩集合，这段代码甚至无法运行，因为它对集合中每个对象的`name`属性被定义有隐含的假设。
- en: Not only can `compact()` be used for safety purposes—removing items that violate
    contracts—but also for performance purposes. You'll see that the preceding code
    searches the collection, *inside* a loop. Therefore, any items removed from the
    collection *before* the outer loop is entered, the greater the performance gain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`compact()`不仅可以用于安全目的——移除违反约定的项——还可以用于性能目的。你会看到前面的代码在循环内部搜索集合。因此，在进入外部循环之前从集合中移除的任何项，性能提升就越大。'
- en: 'Going back to the preceding code, there''s one issue that can catch Lo-Dash
    programmers off guard. Let''s say that we don''t want anything that doesn''t have
    a `name` property. Well, we''re only shaving off falsey values—objects without
    `name` properties are still valid, and the `compact()` function lets them through.
    For example, `{}` doesn''t have a `name` property, and neither does `2`, but they''re
    both allowed through in the previous approach. A safer approach might be to pluck
    then compact, as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面的代码，有一个问题可能会让Lo-Dash程序员感到意外。假设我们不想有任何没有`name`属性的东西。嗯，我们只是在移除假值——没有`name`属性的对象仍然是有效的，`compact()`函数允许它们通过。例如，`{}`没有`name`属性，`2`也没有，但它们在上一个方法中都被允许通过。一个更安全的方法可能是先提取再压缩，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we're faced with a similar filtering task but with a slightly different
    collection. It has objects that will cause our code to fail because they don't
    have a name key with a string value. The quick-and-dirty workaround is to pluck
    the `name` property from all items in the collection before performing the `compact()`
    call. This will yield undefined values for objects that don't have a `name` property.
    But that's exactly what we're after, since `compact()` has no trouble excluding
    these values. Moreover, our code is actually simpler now. The caveat being, sometimes
    the simple approach doesn't work. Sometimes, you need the full object and not
    just the name. Cheat only when you can get away with it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们面临一个类似的过滤任务，但集合略有不同。它包含一些会导致我们的代码失败的对象，因为这些对象没有具有字符串值的`name`键。快速而简单的解决方案是在执行`compact()`调用之前从集合中的所有项目提取`name`属性。这将导致没有`name`属性的对象返回`undefined`值。但这正是我们想要的，因为`compact()`可以轻松排除这些值。此外，我们的代码现在实际上更简单了。需要注意的是，有时简单的方法不起作用。有时，你需要完整的对象，而不仅仅是名称。只有在可以逃避的情况下才作弊。
- en: Validating some or all items
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证某些或所有项目
- en: 'Sometimes, sections of our code hinge on the validity of all, or some collection
    items. Lo-Dash provides you with two complementary tools for the job. The `every()`
    function returns `true` if the callback returns `true` for every item in the collection.
    The `some()` function is a lazy brother of `every()`—it gives and returns `true`
    as soon as the callback returns `true` for an item, as shown in the following
    code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的代码的某些部分取决于所有或某些集合项目的有效性。Lo-Dash为您提供了两个互补的工具来完成这项工作。`every()`函数如果回调对集合中的每个项目都返回`true`，则返回`true`。`some()`函数是`every()`的懒惰兄弟——它一旦回调对某个项目返回`true`，就提供并返回`true`，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code checks every item in the collection for a `name` property before doing
    anything with it. Since one of the items is using an incorrect property name,
    the code will return early. The code that runs below the `if` statement can assume
    that each item has a `name` property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在对其进行任何操作之前检查集合中的每个项目是否有`name`属性。由于其中一个项目使用了错误的属性名称，代码将提前返回。在`if`语句下面的代码可以假设每个项目都有一个`name`属性。
- en: 'On the other hand, we might only want to know whether *any* items have a necessary
    value. You can use this technique to greatly increase performance. For example,
    say that you have a loop that performs expensive operations on each collection
    item. You can do a **preflight check**, which is relatively inexpensive, to determine
    whether the expensive loop is worth running. An example for this is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能只想知道是否有任何项目具有必要的值。您可以使用这项技术来显著提高性能。例如，假设您有一个循环，它对每个集合项目执行昂贵的操作。您可以进行一个相对便宜的**预检**，以确定是否值得运行这个昂贵的循环。以下是一个示例：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `some()` call makes it all the way through the collection without any
    `true` callback return values, it means that we can skip the more expensive processing.
    For example, if we have a potentially large collection and we need to filter it
    using some nontrivial comparison operators, perhaps some function calls as well,
    the overhead really starts to add up. Using `some()` is a cheap way to avoid this
    heavy processing if it's needless.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`some()`调用遍历整个集合而没有任何`true`回调返回值，这意味着我们可以跳过更昂贵的处理。例如，如果我们有一个可能很大的集合，并且我们需要使用一些非平凡的比较运算符来过滤它，也许还需要一些函数调用，那么开销真的开始增加。如果不需要，使用`some()`是一种避免这种重处理的好方法。
- en: Unions, intersections, and differences
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并集、交集和差集
- en: The last section of this chapter looks at Lo-Dash functions that compare two
    or more arrays and yield a resulting array. In a way, we're combining several
    collections into a single collection. The `union()` function concatenates collections,
    with duplicate values removed. The `intersection()` function builds a collection
    with values common to all the provided collections. Lastly, the `xor()` function
    builds a collection that contains the differences between all provided collections.
    It's kind of like the inverse of `intersection()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分探讨了 Lo-Dash 函数，这些函数可以比较两个或多个数组并生成一个结果数组。从某种意义上说，我们正在将多个集合合并成一个集合。`union()`
    函数连接集合，同时移除重复值。`intersection()` 函数构建一个包含所有提供集合共有值的集合。最后，`xor()` 函数构建一个包含所有提供集合差异的集合。这有点像是
    `intersection()` 的逆操作。
- en: 'You can use the `union()` function when there are several overlapping collections
    that contain similar items—possibly the same items. Rather than iterate through
    each collection individually, it''s easier to combine the collections, while at
    the same time removing duplicates, as you can see in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个重叠的集合包含相似的项目——可能是相同的项目时，可以使用 `union()` 函数。与其逐个遍历每个集合，不如将集合合并，同时移除重复项，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code takes three arrays and transforms them into a single array. You can
    see in the resulting array that there''s no overlap. That is, any items that exist
    in more than one of the input arrays are only included in the resulting array
    once. Let''s see what the overlap looks like using `intersection()`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将三个数组转换成一个单一的数组。你可以看到在结果数组中没有重叠。也就是说，存在于输入数组中的任何项目在结果数组中只包含一次。让我们看看使用 `intersection()`
    如何查看重叠的情况：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, the intersection is `Ernest` and `Rachel`, since these strings exist
    in all three collections that were passed into `intersection()`. Now it''s time
    to look at comparing the differences between two collections using `xor()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，交集是 `Ernest` 和 `Rachel`，因为这些字符串存在于传递给 `intersection()` 的所有三个集合中。现在，让我们看看如何使用
    `xor()` 比较两个集合之间的差异：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Passing these two arrays to `xor()` will generate a new array that contains
    the difference between the two. In this case, the difference is `Lisa` and `William`.
    Everything else is the intersection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个数组传递给 `xor()` 将会生成一个新的数组，该数组包含两个数组之间的差异。在这种情况下，差异是 `Lisa` 和 `William`。其余的都是交集。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `xor()` function accepts an arbitrary number of collections to compare with.
    Exercise caution, however, when comparing more than two collections. The most
    common case is to compare two collections to figure out the difference between
    the two. Going beyond that is venturing into set theory, and you might not get
    the results you'd expect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor()` 函数可以接受任意数量的集合进行比较。然而，在比较超过两个集合时，请谨慎行事。最常见的情况是比较两个集合以找出它们之间的差异。超出这个范围就是进入集合论领域，你可能会得到你预期的结果。'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the concept of a collection and how they can
    be compared to arrays. Lo-Dash treats collections as an abstract concept—all JavaScript
    arrays are collections, but not all collections are arrays. We were introduced
    to the concept of iterating over collections using the tools provided by Lo-Dash—a
    fundamental concept in applicative programming and will be touched upon frequently
    throughout this book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了集合的概念以及它们如何与数组进行比较。Lo-Dash 将集合视为一个抽象概念——所有 JavaScript 数组都是集合，但并非所有集合都是数组。我们通过
    Lo-Dash 提供的工具了解了遍历集合的概念——这是应用编程中的一个基本概念，本书中将会经常提及。
- en: Collections can be filtered and items can be fetched from the collection. Lo-Dash
    also gives you the tools needed to transform collections into other structures
    you need when implementing frontend UI components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以被过滤，并且可以从集合中检索项目。Lo-Dash 还为你提供了将集合转换为在实现前端 UI 组件时所需的其它结构的工具。
- en: We've been given a taste of some common themes in Lo-Dash programming—like the
    idea that callback functions are central to almost everything, and the various
    shorthands that can save on coding effort, such as the pluck and where callbacks.
    Now it's time to look at how Lo-Dash works with objects, and the various functions
    at our disposal there, which will be covered in the next chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝到了 Lo-Dash 编程中的一些常见主题——比如回调函数几乎在所有事情中都处于核心地位的想法，以及可以节省编码努力的多种简写，例如 pluck
    和 where 回调。现在，让我们看看 Lo-Dash 如何与对象一起工作，以及我们可用的各种函数，这些内容将在下一章中介绍。
