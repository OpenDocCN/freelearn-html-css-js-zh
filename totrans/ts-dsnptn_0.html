<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The Challenge of Increasing Complexity</h1></div></div></div><p>The essence of a program is the combination of possible branches and automated selections based on certain conditions. When we write a program, we define what's going on in a branch, and under what condition this branch will be executed.</p><p>The number of branches usually grows quickly during the evolution of a project, as well as the number of conditions that determine whether a branch will be executed or not.</p><p>This is dangerous for human beings, who have limited brain capacities.</p><p>In this chapter, we are going to implement a data synchronizing service. Starting by implementing some very basic features, we'll keep adding stuff and see how things go.</p><p>The following topics will be covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing a multi-device synchronizing strategy</li><li class="listitem" style="list-style-type: disc">Useful JavaScript and TypeScript techniques and hints that are related, including objects as maps and the string literal type</li><li class="listitem" style="list-style-type: disc">How the Strategy Pattern helps in a project</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Implementing the basics</h1></div></div></div><p>Before we start to write actual code, we need to define what this synchronizing strategy will be like. To keep the implementation from unnecessary distractions, the client will communicate with the server directly through function calls instead of using HTTP requests or Sockets. Also, we'll use <strong>in-memory storage</strong>, namely variables, to store data on both client and server sides.</p><p>Because we are not separating the client and server into two actual applications, and we are not actually using backend technologies, it does not require much Node.js experience to follow this chapter.</p><p>However, please keep in mind that even though we are omitting network and database requests, we hope the core logic of the final implementation could be applied to a real environment without being modified too much. So, when it comes to performance concerns, we still need to assume limited network resources, especially for data passing through the server and client, although the implementation is going to be synchronous instead of asynchronous. This is not supposed to happen in practice, but involving asynchronous operations will introduce much more code, as well as many more situations that need to be taken into consideration. But we will have some useful patterns on asynchronous programming in the coming chapters, and it would definitely help if you try to implement an asynchronous version of the synchronizing logic in this chapter.</p><p>A client, if without modifying what's been synchronized, stores a copy of all the data available on the server, and what we need to do is to provide a set of APIs that enable the client to keep its copy of data synchronized.</p><p>So, it is really simple at the beginning: comparing the last-modified timestamp. If the timestamp on the client is older than what's on the server, then update the copy of data along with new timestamp.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Creating the code base</h2></div></div></div><p>Firstly, let's create <code class="literal">server.ts</code> and <code class="literal">client.ts</code> files containing the <code class="literal">Server</code> class and <code class="literal">Client</code> class respectively:</p><pre class="programlisting">export class Server { &#13;
    // ... &#13;
} &#13;
 &#13;
export class Client { &#13;
    // ... &#13;
} &#13;
</pre><p>I prefer to create an <code class="literal">index.ts</code> file as the package entry, which handles what to export internally. In this case, let's export everything:</p><pre class="programlisting">export * from './server'; &#13;
export * from './client'; &#13;
</pre><p>To import the <code class="literal">Server</code> and <code class="literal">Client</code> classes from a test file (assuming <code class="literal">src/test/test.ts</code>), we can use the following codeto s:</p><pre class="programlisting">import { Server, Client } from '../'; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Defining the initial structure of the data to be synchronized</h2></div></div></div><p>Since we need to compare the timestamps from the client and server, we need to have a <code class="literal">timestamp</code> property on the data structure. I would like to have the data to synchronize as a string, so let's add a <code class="literal">DataStore</code> interface with a <code class="literal">timestamp</code> property to the <code class="literal">server.ts</code> file:</p><pre class="programlisting">export interface DataStore { &#13;
  timestamp: number; &#13;
  data: string; &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Getting data by comparing timestamps</h2></div></div></div><p>Currently, the synchronizing strategy is one-way, from the server to the client. So what we need to do is simple: we compare the timestamps; if the server has the newer one, it responds with data and the server-side timestamp; otherwise, it responds with <code class="literal">undefined</code>:</p><pre class="programlisting">class Server { &#13;
  store: DataStore = { &#13;
    timestamp: 0, &#13;
    data: '' &#13;
  }; &#13;
 &#13;
  getData(clientTimestamp: number): DataStore { &#13;
    if (clientTimestamp &lt; this.store.timestamp) { &#13;
      return this.store; &#13;
    } else { &#13;
      return undefined; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Now we have provided a simple API for the client, and it's time to implement the client:</p><pre class="programlisting">import { Server, DataStore } from './'; &#13;
 &#13;
export class Client { &#13;
  store: DataStore = { &#13;
    timestamp: 0, &#13;
    data: undefined &#13;
  }; &#13;
     &#13;
  constructor( &#13;
    public server: Server &#13;
  ) { } &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="tip8"/>Tip</h3><p>Prefixing a <code class="literal">constructor</code> parameter with access modifiers (including <code class="literal">public</code>, <code class="literal">private</code>, and <code class="literal">protected</code>) will create a property with the same name and corresponding accessibility. It will also assign the value automatically when the constructor is called.</p></div></div><p>Now we need to add a <code class="literal">synchronize</code> method to the <code class="literal">Client</code> class that does the job:</p><pre class="programlisting">synchronize(): void { &#13;
  let updatedStore = this.server.getData(this.store.timestamp); &#13;
   &#13;
  if (updatedStore) { &#13;
    this.store = updatedStore; &#13;
  } &#13;
} &#13;
</pre><p>That's easily done. However, are you already feeling somewhat awkward with what we've written?</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Two-way synchronizing</h2></div></div></div><p>Usually, when we talk about synchronization, we get updates from the server and push changes to the server as well. Now we are going to do the second part, pushing the changes if the client has newer data.</p><p>But first, we need to give the client the ability to update its data by adding an <code class="literal">update</code> method to the <code class="literal">Client</code> class:</p><pre class="programlisting">update(data: string): void { &#13;
  this.store.data = data; &#13;
  this.store.timestamp = Date.now(); &#13;
} &#13;
</pre><p>And we need the server to have the ability to receive data from the client as well. So we rename the <code class="literal">getData</code> method of the <code class="literal">Server</code> class as <code class="literal">synchronize</code> and make it satisfy the new job:</p><pre class="programlisting">synchronize(clientDataStore: DataStore): DataStore { &#13;
  if (clientDataStore.timestamp &gt; this.store.timestamp) { &#13;
      this.store = clientDataStore; &#13;
      return undefined; &#13;
  } else if (clientDataStore.timestamp &lt; this.store.timestamp) { &#13;
      return this.store; &#13;
  } else { &#13;
      return undefined; &#13;
  } &#13;
} &#13;
</pre><p>Now we have the basic implementation of our synchronizing service. Later, we'll keep adding new things and make it capable of dealing with a variety of scenarios.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Things that went wrong while implementing the basics</h2></div></div></div><p>Currently, what we've written is just too simple to be wrong. But there are still some semantic issues.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Passing a data store from the server to the client does not make sense</h3></div></div></div><p>We used <code class="literal">DataStore</code> as the return type of the <code class="literal">synchronize</code> method on <code class="literal">Server</code>. But what we were actually passing through is not a data store, but information that involves data and its timestamp. The information object just <em>happened to</em> have the same properties as a data store <em>at this point in time</em>.</p><p>Also, it will be misleading to people who will later read your code (including yourself in the future). Most of the time, we are trying to eliminate redundancies. But that does not have to mean everything that looks the same. So let's make it two interfaces:</p><pre class="programlisting">interface DataStore { &#13;
  timestamp: number; &#13;
  data: string; &#13;
} &#13;
 &#13;
interface DataSyncingInfo { &#13;
  timestamp: number; &#13;
  data: string; &#13;
} &#13;
</pre><p>I would even prefer to create another instance, instead of directly returning <code class="literal">this.store</code>:</p><pre class="programlisting">return { &#13;
  timestamp: this.store.timestamp, &#13;
  data: this.store.data &#13;
}; &#13;
</pre><p>However, if two pieces of code with different semantic meanings are doing the same thing from the perspective of code itself, you may consider extracting that part as a utility.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Making the relationships clear</h3></div></div></div><p>Now we have two separated interfaces, <code class="literal">DataStore</code> and <code class="literal">DataSyncingInfo</code>, in <code class="literal">server.ts</code>. Obviously, <code class="literal">DataSyncingInfo</code> should be a shared interface between the server and the client, while <code class="literal">DataStore</code> happens to be the same on both sides, but it's not actually shared.</p><p>So what we are going to do is to create a separate <code class="literal">shared.d.ts</code> (it could also be <code class="literal">shared.ts</code> if it contains more than <code class="literal">typings</code>) that exports <code class="literal">DataSyncingInfo</code> and add another <code class="literal">DataStore</code> to <code class="literal">client.ts</code>.</p><div><div><h3 class="title"><a id="note9"/>Note</h3><p>Do not follow this blindly. Sometimes it is designed for the server and the client to have exactly the same stores. If that's the situation, the interface should be shared.</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Growing features</h1></div></div></div><p>What we've done so far is basically useless. But, from now on, we will start to add features and make it capable of fitting in practical needs, including the capability of synchronizing multiple data items with multiple clients, and merging conflicts.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Synchronizing multiple items</h2></div></div></div><p>Ideally, the data we need to synchronize will have a lot of items contained. Directly changing the type of <code class="literal">data</code> to an array would work if there were only very limited number of these items.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Simply replacing data type with an array</h3></div></div></div><p>Now let's change the type of the <code class="literal">data</code> property of <code class="literal">DataStore</code> and <code class="literal">DataSyncingInfo</code> interfaces to <code class="literal">string[]</code>. With the help of TypeScript, you will get errors for unmatched types this change would cause. Fix them by annotating the correct types.</p><p>But obviously, this is far from an efficient solution.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Server-centered synchronization</h3></div></div></div><p>If the data store contains a lot of data, the ideal approach would be only updating items that are not up-to-date.</p><p>For example, we can create a timestamp for every single item and send these timestamps to the server, then let the server decide whether a specific data item is up-to-date. This is a viable approach for certain scenarios, such as checking updates for software extensions. It is okay to occasionally send even hundreds of timestamps with item IDs on a fast network, but we are going to use another approach for different scenarios, or I won't have much to write.</p><p>User data synchronization of offline apps on a mobile phone is what we are going to deal with, which means we need to try our best to avoid wasting network resources.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Here is an interesting question. What are the differences between user data synchronization and checking extension updates? Think about the size of data, issues with multiple devices, and more.</p></div></div><p>The reason why we thought about sending timestamps of all items is for the server to determine whether certain items need to be updated. However, is it necessary to have the timestamps of all data items stored on the client side?</p><p>What if we choose not to store the timestamp of data changing, but of data being synchronized with the server? Then we can get everything up-to-date by only sending the timestamp of the last successful synchronization. The server will then compare this timestamp with the last modified timestamps of all data items and decide how to respond.</p><p>As the title of this part suggests, the process is server-centered and relies on the server to generate the timestamps (though it does not have to, and practically should not, be the stamp of the actual time).</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>If you are getting confused about how these timestamps work, let's try again. The server will store the timestamps of the last time items were synchronized, and the client will store the timestamp of the last successful synchronization with the server. Thus, if no item on the server has a later timestamp than the client, then there's no change to the server data store after that timestamp. But if there are some changes, by comparing the timestamp of the client with the timestamps of server items, we'll know which items are newer.</p></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec19"/>Synchronizing from the server to the client</h4></div></div></div><p>Now there seems to be quite a lot to change. Firstly, let's handle synchronizing data from server to client.</p><p>This is what's expected to happen on the server side:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a timestamp and identity to every data item on the server</li><li class="listitem" style="list-style-type: disc">Compare the client timestamp with every data item on the server</li></ul></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>We don't need to actually compare the client timestamp with every item on server if those items have a sorted index. The performance would be acceptable using a database with a sorted index.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Respond with items newer than what the client has as well as a new timestamp.</li></ul></div><p>And here's what's expected to happen on the client side:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Synchronize with the last timestamp sent to the server</li><li class="listitem" style="list-style-type: disc">Update the local store with new data responded by the server</li><li class="listitem" style="list-style-type: disc">Update the local timestamp of the last synchronization if it completes without error</li></ul></div><p>
<strong>Updating interfaces</strong>
</p><p>First of all, we have now an updated data store on both sides. Starting with the server, the data store now contains an array of data items. So let's define the <code class="literal">ServerDataItem</code> interface and update <code class="literal">ServerDataStore</code> as well:</p><pre class="programlisting">export interface ServerDataItem { &#13;
  id: string; &#13;
  timestamp: number; &#13;
  value: string; &#13;
} &#13;
 &#13;
export interface ServerDataStore { &#13;
  items: { &#13;
    [id: string]: ServerDataItem; &#13;
  }; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note13"/>Note</h3><p>The <code class="literal">{ [id: string]: ServerDataItem }</code> type describes an object with <code class="literal">id</code> of type <code class="literal">string</code> as a key and has the value of type <code class="literal">ServerDataItem</code>. Thus, an item of type <code class="literal">ServerDataItem</code> can be accessed by <code class="literal">items['the-id']</code>.</p></div></div><p>And for the client, we now have different data items and a different store. The response contains only a subset of all data items, so we need IDs and a map with ID as the index to store the data:</p><pre class="programlisting">export interface ClientDataItem { &#13;
  id: string; &#13;
  value: string; &#13;
} &#13;
 &#13;
export interface ClientDataStore { &#13;
  timestamp: number; &#13;
  items: { &#13;
    [id: string]: ClientDataItem; &#13;
  }; &#13;
} &#13;
</pre><p>Previously, the client and server were sharing the same <code class="literal">DataSyncingInfo</code>, but that's going to change. As we'll deal with server-to-client synchronizing first, we care only about the timestamp in a synchronizing request for now:</p><pre class="programlisting">export interface SyncingRequest { &#13;
  timestamp: number; &#13;
} &#13;
</pre><p>As for the response from the server, it is expected to have an updated timestamp with data items that have changed compared to the request timestamp:</p><pre class="programlisting">export interface SyncingResponse { &#13;
  timestamp: number; &#13;
    changes: { &#13;
      [id: string]: string; &#13;
    }; &#13;
} &#13;
</pre><p>I prefixed those interfaces with <em>Server</em> and <em>Client</em> for better differentiation. But it's not necessary if you are not exporting everything from <code class="literal">server.ts</code> and <code class="literal">client.ts</code> (in <code class="literal">index.ts</code>).</p><p>
<strong>Updating the server side</strong>
</p><p>With well-defined data structures, it should be pretty easy to achieve what we expected. To begin with, we have the <code class="literal">synchronize</code> method, which accepts a <code class="literal">SyncingRequest</code> and returns a <code class="literal">SyncingResponse</code>; and we need to have the updated timestamp as well:</p><pre class="programlisting">synchronize(request: SyncingRequest): SyncingResponse { &#13;
  let lastTimestamp = request.timestamp; &#13;
  let now = Date.now(); &#13;
   &#13;
  let serverChanges: ServerChangeMap = Object.create(null); &#13;
   &#13;
  return { &#13;
    timestamp: now, &#13;
    changes: serverChanges &#13;
  }; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>For the <code class="literal">serverChanges</code> object, <code class="literal">{}</code> (an object literal) might be the first thing (if not an ES6 Map) that comes to mind. But it's not absolutely safe to do so, because it would refuse <code class="literal">__proto__</code> as a key. The better choice would be <code class="literal">Object.create(null)</code>, which accepts all strings as its key.</p></div></div><p>Now we are going to add items that are newer than the client to <code class="literal">serverChanges</code>:</p><pre class="programlisting">let items = this.store.items; &#13;
 &#13;
for (let id of Object.keys(items)) { &#13;
  let item = items[id]; &#13;
   &#13;
  if (item.timestamp &gt; lastTimestamp) { &#13;
    serverChanges[id] = item.value; &#13;
  } &#13;
} &#13;
</pre><p>
<strong>Updating the client side</strong>
</p><p>As we've changed the type of <code class="literal">items</code> under <code class="literal">ClientDataStore</code> to a map, we need to fix the initial value:</p><pre class="programlisting">store: ClientDataStore = { &#13;
  timestamp: 0, &#13;
  items: Object.create(null) &#13;
}; &#13;
</pre><p>Now let's update the <code class="literal">synchronize</code> method. Firstly, the client is going to send a request with a timestamp and get a response from the server:</p><pre class="programlisting">synchronize(): void { &#13;
  let store = this.store; &#13;
   &#13;
  let response = this.server.synchronize({ &#13;
    timestamp: store.timestamp &#13;
  }); &#13;
} &#13;
</pre><p>Then we'll save the newer data items to the store:</p><pre class="programlisting">let clientItems = store.items;  &#13;
let serverChanges = response.changes; &#13;
 &#13;
for (let id of Object.keys(serverChanges)) { &#13;
  clientItems[id] = { &#13;
    id, &#13;
    value: serverChanges[id] &#13;
  }; &#13;
} &#13;
</pre><p>Finally, update the timestamp of the last successful synchronization:</p><pre class="programlisting">clientStore.timestamp = response.timestamp; &#13;
</pre><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Updating the synchronization timestamp should be the last thing to do during a complete synchronization process. Make sure it's not stored earlier than data items, or you might have a broken offline copy if there's any errors or interruptions during synchronizing in the future.</p></div></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>To ensure that this works as expected, an operation with the same change information should give the same results even if it's applied multiple times.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec20"/>Synchronizing from client to server</h4></div></div></div><p>For a server-centered synchronizing process, most of the changes are made through clients. Consequently, we need to figure out how to organize these changes before sending them to the server.</p><p>One single client only cares about its own copy of data. What difference would this make when comparing to the process of synchronizing data from the server to clients? Well, think about why we need the timestamp of every data item on the server in the first place. We need them because we want to know which items are new compared to a specific client.</p><p>Now, for changes on a client: if they ever happen, they need to be synchronized to the server without requiring specific timestamps for comparison.</p><p>However, we might have more than one client with changes that need to be synchronized, which means that changes made later in time might actually get synchronized earlier, and thus we'll have to resolve conflicts. To achieve that, we need to add the last modified time back to every data item on the server and the changed items on the client.</p><p>I've mentioned that the timestamps stored on the server for finding out what needs to be synchronized to a client do not need to be (and better not be) an actual stamp of a physical time point. For example, it could be the count of synchronizations that happened between all clients and the server.</p><p>
<strong>Updating the client side</strong>
</p><p>To handle this efficiently, we may create a separated map with the IDs of the data items that have changed as keys and the last modified time as the value in <code class="literal">ClientDataStore</code>:</p><pre class="programlisting">export interface ClientDataStore { &#13;
  timestamp: number; &#13;
  items: { &#13;
    [id: string]: ClientDataItem; &#13;
  }; &#13;
 <strong> changed: { &#13;
    [id: string]: number; &#13;
  };</strong> &#13;
} &#13;
</pre><p>You may also want to initialize its value as <code class="literal">Object.create(null)</code>.</p><p>Now when we update an item in the client store, we add the last modified time to the <code class="literal">changed</code> map as well:</p><pre class="programlisting">update(id: string, value: string): void { &#13;
  let store = this.store; &#13;
   &#13;
  store.items[id] = { &#13;
    id, &#13;
    value &#13;
  }; &#13;
   &#13;
  store.changed[id] = Date.now(); &#13;
} &#13;
</pre><p>A single timestamp in <code class="literal">SyncingRequest</code> certainly won't do the job any more; we need to add a place for the changed data, a map with data item ID as the index, and the changed information as the value:</p><pre class="programlisting">export interface ClientChange { &#13;
  lastModifiedTime: number; &#13;
  value: string; &#13;
} &#13;
 &#13;
export interface SyncingRequest { &#13;
  timestamp: number; &#13;
  changes: { &#13;
    [id: string]: ClientChange; &#13;
  }; &#13;
} &#13;
</pre><p>Here comes another problem. What if a change made to a client data item is done offline, with the system clock being at the wrong time? Obviously, we need some time calibration mechanisms. However, there's no way to make perfect calibration. We'll make some assumptions so we don't need to start another chapter for time calibration:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The system clock of a client may be late or early compared to the server. But it ticks at a normal speed and won't jump between times.</li><li class="listitem" style="list-style-type: disc">The request sent from a client reaches the server in a relatively short time.</li></ul></div><p>With those assumptions, we can add those building blocks to the client-side <code class="literal">synchronize</code> method:</p><div><ol class="orderedlist arabic"><li class="listitem">Add client-side changes to the synchronizing request (of course, before sending it to the server):<pre class="programlisting">      let clientItems = store.items; &#13;
      let clientChanges: ClientChangeMap = Object.create(null); &#13;
       &#13;
      let changedTimes = store.changed; &#13;
       &#13;
      for (let id of Object.keys(changedTimes)) { &#13;
        clientChanges[id] = { &#13;
          lastModifiedTime: changedTimes[id], &#13;
          value: clientItems[id].value &#13;
        }; &#13;
      } &#13;
</pre></li><li class="listitem">Synchronize changes to the server with the current time of the client's clock:<pre class="programlisting">      let response = this.server.synchronize({ &#13;
        timestamp: store.timestamp, &#13;
        clientTime: Date.now(), &#13;
        changes: clientChanges &#13;
      }); &#13;
</pre></li><li class="listitem">Clean the changes after a successful synchronization:<pre class="programlisting">      store.changed = Object.create(null); &#13;
</pre></li></ol></div><p>
<strong>Updating the server side</strong>
</p><p>If the client is working as expected, it should send synchronizing requests with changes. It's time to enable the server to handling those changes from the client.</p><p>There are going to be two steps for the server-side synchronization process:</p><div><ol class="orderedlist arabic"><li class="listitem">Apply the client changes to server data store.</li><li class="listitem">Prepare the changes that need to be synchronized to the client.</li></ol></div><p>First, we need to add <code class="literal">lastModifiedTime</code> to server-side data items, as we mentioned before:</p><pre class="programlisting">export interface ServerDataItem { &#13;
    id: string; &#13;
    timestamp: number; &#13;
    <strong>lastModifiedTime: number;</strong> &#13;
    value: string; &#13;
} &#13;
</pre><p>And we need to update the<code class="literal"> synchronize</code> method:</p><pre class="programlisting">let clientChanges = request.changes; &#13;
let now = Date.now(); &#13;
 &#13;
for (let id of Object.keys(clientChanges)) { &#13;
  let clientChange = clientChanges[id]; &#13;
   &#13;
  if ( &#13;
    hasOwnProperty.call(items, id) &amp;&amp;  &#13;
    items[id].lastModifiedTime &gt; clientChange.lastModifiedTime &#13;
  ) { &#13;
    continue; &#13;
  } &#13;
   &#13;
  items[id] = { &#13;
    id, &#13;
    timestamp: now, &#13;
    lastModifiedTime, &#13;
    value: clientChange.value &#13;
  }; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note17"/>Note</h3><p>We can actually use the <code class="literal">in</code> operator instead of <code class="literal">hasOwnProperty</code> here because the <code class="literal">items</code> object is created with <code class="literal">null</code> as its prototype. But a reference to <code class="literal">hasOwnProperty</code> will be your friend if you are using objects created by object literals, or in other ways, such as maps.</p></div></div><p>We already talked about resolving conflicts by comparing the last modified times. At the same time, we've made assumptions so we can calibrate the last modified times from the client easily by passing the client time to the server while synchronizing.</p><p>What we are going to do for calibration is to calculate the offset of the client time compared to the server time. And that's why we made the second assumption: the request needs to easily reach the server in a relatively short time. To calculate the offset, we can simply subtract the client time from the server time:</p><pre class="programlisting">let clientTimeOffset = now - request.clientTime; &#13;
</pre><div><div><h3 class="title"><a id="note18"/>Note</h3><p>To make the time calibration more accurate, we would want the earliest timestamp after the request hits the server to be recorded as "now". So in practice, you might want to record the timestamp of the request hitting the server before start processing everything. For example, for HTTP request, you may record the timestamp once the TCP connection gets established.</p></div></div><p>And now, the calibrated time of a client change is the sum of the original time and the offset. We can now decide whether to keep or ignore a change from the client by comparing the calibrated last modified time. It is possible for the calibrated time to be greater than the server time; you can choose either to use the server time as the maximum value or accept a small inaccuracy. Here, we will go the simple way:</p><pre class="programlisting">let lastModifiedTime = Math.min( &#13;
  clientChange.lastModifiedTime + clientTimeOffset, &#13;
  now &#13;
); &#13;
 &#13;
if ( &#13;
  hasOwnProperty.call(items, id) &amp;&amp;  &#13;
  items[id].lastModifiedTime &gt; lastModifiedTime &#13;
) { &#13;
  continue; &#13;
} &#13;
</pre><p>To make this actually work, we need to also exclude changes from the server that conflict with client changes in <code class="literal">SyncingResponse</code>. To do so, we need to know what the changes are that survive the conflict resolving process. A simple way is to exclude items with timestamp that equals <code class="literal">now</code>:</p><pre class="programlisting">for (let id of Object.keys(items)) { &#13;
  let item = items[id]; &#13;
   &#13;
  if ( &#13;
    item.timestamp &gt; lastTimestamp &amp;&amp; &#13;
    item.timestamp !== now &#13;
  ) { &#13;
    serverChanges[id] = item.value; &#13;
  } &#13;
} &#13;
</pre><p>So now we have implemented a complete synchronization logic with the ability to handle simple conflicts in practice.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Synchronizing multiple types of data</h2></div></div></div><p>At this point, we've hard coded the data with the <code class="literal">string</code> type. But usually we will need to store varieties of data, such as numbers, booleans, objects, and so on.</p><p>If we were writing JavaScript, we would not actually need to change anything, as the implementation does not have anything to do with certain data types. In TypeScript, we don't need to do much either: just change the type of every related <code class="literal">value</code> to <code class="literal">any</code>. But that means you are losing type safety, which would definitely be okay if you are happy with that.</p><p>But taking my own preferences, I would like every variable, parameter, and property to be typed if it's possible. So we may still have a data item with <code class="literal">value</code> of type <code class="literal">any</code>:</p><pre class="programlisting">export interface ClientDataItem { &#13;
  id: string; &#13;
  value: any; &#13;
} &#13;
</pre><p>We can also have derived interfaces for specific data types:</p><pre class="programlisting">export interface ClientStringDataItem extends ClientDataItem { &#13;
  value: string; &#13;
} &#13;
 &#13;
export interface ClientNumberDataItem extends ClientDataItem { &#13;
  value: number; &#13;
} &#13;
</pre><p>But this does not seem to be good enough. Fortunately, TypeScript provides <em>generics</em>, so we can rewrite the preceding code as follows:</p><pre class="programlisting">export interface ClientDataItem&lt;T&gt; { &#13;
  id: string; &#13;
  value: T; &#13;
} &#13;
</pre><p>Assuming we have a store that accepts multiple types of data items - for example, number and string - we can declare it as follows with the help of the <code class="literal">union</code> type:</p><pre class="programlisting">export interface ClientDataStore { &#13;
  items: { &#13;
    [id: string]: ClientDataItem&lt;number | string&gt;; &#13;
  }; &#13;
} &#13;
</pre><p>If you remember that we are doing something for offline mobile apps, you might be questioning the long property names in changes such as <code class="literal">lastModifiedTime</code>. This is a fair question, and an easy fix is to use <code class="literal">tuple</code> types, maybe along with <code class="literal">enums</code>:</p><pre class="programlisting">const enum ClientChangeIndex { &#13;
  lastModifiedType, &#13;
  value &#13;
} &#13;
 &#13;
type ClientChange&lt;T&gt; = [number, T]; &#13;
 &#13;
let change: ClientChange&lt;string&gt; = [0, 'foo']; &#13;
let value = change[ClientChangeIndex.value]; &#13;
</pre><p>You can apply less or more of the typing things we are talking about depending on your preferences. If you are not familiar with them yet, you can read more here: <a class="ulink" href="http://www.typescriptlang.org/handbook">http://www.typescriptlang.org/handbook</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Supporting multiple clients with incremental data</h2></div></div></div><p>Making the typing system happy with multiple data types is easy. But in the real world, we don't resolve conflicts of all data types by simply comparing the last modified times. An example is counting the daily active time of a user cross devices.</p><p>It's quite clear that we need to have every piece of active time in a day on multiple devices summed up. And this is how we are going to achieve that:</p><div><ol class="orderedlist arabic"><li class="listitem">Accumulate active durations between synchronizations on the client.</li><li class="listitem">Add a UID (unique identifier) to every piece of time before synchronizing with the server.</li><li class="listitem">Increase the server-side value if the UID does not exist yet, and then add the UID to that data item.</li></ol></div><p>But before we actually get our hands on those steps, we need a way to distinguish incremental data items from normal ones, for example, by adding a <code class="literal">type</code> property.</p><p>As our synchronizing strategy is server-centered, related information is only required for synchronizing requests and conflict merging. Synchronizing responses does not need to include the details of changes, but just merged values.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>I will stop telling how to update every interface step by step as we are approaching the final structure. But if you have any problems with that, you can check out the complete code bundle for inspiration.</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Updating the client side</h3></div></div></div><p>First of all, we need the client to support incremental changes. And if you've thought about this, you might already be confused about where to put the extra information, such as UIDs.</p><p>This is because we were mixing up the concept <em>change</em> (noun) with <em>value</em>. It was not a problem before because, besides the last modified time, the value is what a change is about. We used a simple map to store the last modified times and kept the store clean from redundancy, which balanced well under that scenario.</p><p>But now we need to distinguish between these two concepts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Value</strong>: a value describes what a data item is in a static way</li><li class="listitem" style="list-style-type: disc"><strong>Change</strong>: a change describes the information that may transform the value of a data item from one to another</li></ul></div><p>We need to have a general type of changes as well as a new data structure for incremental changes with a numeric value:</p><pre class="programlisting">type DataType = 'value' | 'increment'; &#13;
 &#13;
interface ClientChange { &#13;
  type: DataType; &#13;
} &#13;
 &#13;
interface ClientValueChange&lt;T&gt; extends ClientChange { &#13;
  type: 'value'; &#13;
  lastModifiedTime: number; &#13;
  value: T; &#13;
} &#13;
 &#13;
interface ClientIncrementChange extends ClientChange { &#13;
  type: 'increment'; &#13;
  uid: string; &#13;
  increment: number; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note20"/>Note</h3><p>We are using the <code class="literal">string literal</code> type here, which was introduced in TypeScript 1.8. To learn more, please refer to the TypeScript handbook as we mentioned before.</p></div></div><p>Similar changes to the data store structure should be made. And when we update an item on the client side, we need to apply the correct operations based on different data types:</p><pre class="programlisting">update(id: string, type: 'increment', increment: number): void; &#13;
update&lt;T&gt;(id: string, type: 'value', value: T): void; &#13;
update&lt;T&gt;(id: string, type: DataType, value: T): void; &#13;
update&lt;T&gt;(id: string, type: DataType, value: T): void { &#13;
  let store = this.store; &#13;
   &#13;
  let items = store.items; &#13;
  let storedChanges = store.changes; &#13;
   &#13;
  if (type === 'value') { &#13;
    // ... &#13;
  } else if (type === 'increment') { &#13;
    // ... &#13;
  } else { &#13;
    throw new TypeError('Invalid data type'); &#13;
  } &#13;
} &#13;
</pre><p>Use the following code for normal changes (while <code class="literal">type</code> equals <code class="literal">'value'</code>):</p><pre class="programlisting">let change: ClientValueChange&lt;T&gt; = { &#13;
  type: 'value', &#13;
  lastModifiedTime: Date.now(), &#13;
  value &#13;
}; &#13;
 &#13;
storedChanges[id] = change; &#13;
 &#13;
if (hasOwnProperty.call(items, id)) { &#13;
  items[id].value = value; &#13;
} else { &#13;
  items[id] = { &#13;
    id, &#13;
    type, &#13;
    value &#13;
  }; &#13;
} &#13;
</pre><p>For incremental changes, it takes a few more lines:</p><pre class="programlisting">let storedChange = storedChanges[id] as ClientIncrementChange; &#13;
 &#13;
if (storedChange) { &#13;
  storedChange.increment += &lt;any&gt;value as number; &#13;
} else { &#13;
  storedChange = { &#13;
    type: 'increment', &#13;
    uid: Date.now().toString(), &#13;
    increment: &lt;any&gt;value as number &#13;
  }; &#13;
   &#13;
  storedChanges[id] = storedChange; &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note21"/>Note</h3><p>It's my personal preference to use <code class="literal">&lt;T&gt;</code> for <code class="literal">any</code> casting and <code class="literal">as T</code> for non-<code class="literal">any</code> castings. Though it has been used in languages like C#, the <code class="literal">as</code> operator in TypeScript was originally introduced for compatibilities with XML tags in JSX. You can also write <code class="literal">&lt;number&gt;&lt;any&gt;value</code> or <code class="literal">value as any as number</code> here if you like.</p></div></div><p>Don't forget to update the stored value. Just change <code class="literal">=</code> to <code class="literal">+=</code> comparing to updating normal data items:</p><pre class="programlisting">if (hasOwnProperty.call(items, id)) { &#13;
  items[id].value += value; &#13;
} else { &#13;
  items[id] = { &#13;
    id, &#13;
    type, &#13;
    value &#13;
  }; &#13;
} &#13;
</pre><p>That's not hard at all. But hey, we see branches.</p><p>We are writing branches all the time, but what are the differences between branches such as <code class="literal">if (type === 'foo') { ... }</code> and branches such as <code class="literal">if (item.timestamp &gt; lastTimestamp) { ... }</code>? Let's keep this question in mind and move on.</p><p>With necessary information added by the <code class="literal">update</code> method, we can now update the <code class="literal">synchronize</code> method of the client. But there is a flaw in practical scenarios: a synchronizing request is sent to the server successfully, but the client failed to receive the response from the server. In this situation, when <code class="literal">update</code> is called after a failed synchronization, the increment is added to the might-be-synchronized change (identified by its UID), which will be ignored by the server in future synchronizations. To fix this, we'll need to add a mark to all incremental changes that have started a synchronizing process, and avoid accumulating these changes. Thus, we need to create another change for the same data item.</p><p>This is actually a nice hint: as a change is about information that transforms a value from one to another, several changes pending synchronization might eventually be applied to one single data item:</p><pre class="programlisting">interface ClientChangeList&lt;T extends ClientChange&gt; { &#13;
  type: DataType; &#13;
  changes: T[]; &#13;
} &#13;
 &#13;
interface SyncingRequest { &#13;
  timestamp: number; &#13;
  changeLists: { &#13;
    [id: string]: ClientChangeList&lt;ClientChange&gt;; &#13;
  }; &#13;
} &#13;
 &#13;
interface ClientIncrementChange extends ClientChange { &#13;
  type: 'increment'; &#13;
 <strong> synced: boolean;</strong> &#13;
  uid: string; &#13;
  increment: number; &#13;
} &#13;
</pre><p>Now when we are trying to update an incremental data item, we need to get its last change from the change list (if any) and see whether it has ever been synchronized. If it has ever been involved in a synchronization, we create a new change instance. Otherwise, we'll just accumulate the <code class="literal">increment</code> property value of the last change on the client side:</p><pre class="programlisting">let changeList = storedChangeLists[id]; &#13;
let changes = changeList.changes; &#13;
let lastChange = &#13;
  changes[changes.length - 1] as ClientIncrementChange; &#13;
 &#13;
if (lastChange.synced) { &#13;
  changes.push({ &#13;
    synced: false, &#13;
    uid: Date.now().toString(), &#13;
    increment: &lt;any&gt;value as number &#13;
  } as ClientIncrementChange); &#13;
} else { &#13;
  lastChange.increment += &lt;any&gt;value as number; &#13;
} &#13;
</pre><p>Or, if the change list does not exist yet, we'll need to set it up:</p><pre class="programlisting">let changeList = { &#13;
  type: 'increment', &#13;
  changes: [ &#13;
    { &#13;
      synced: false, &#13;
      uid: Date.now().toString(), &#13;
      increment: &lt;any&gt;value as number &#13;
    } as ClientIncrementChange &#13;
  ] &#13;
}; &#13;
 &#13;
store.changeLists[id] = changeList; &#13;
</pre><p>We also need to update <code class="literal">synchronize</code> method to mark an incremental change as <code class="literal">synced</code> before starting the synchronization with the server. But the implementation is for you to do on your own.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec24"/>Updating server side</h3></div></div></div><p>Before we add the logic for handling incremental changes, we need to make server-side code adapt to the new data structure:</p><pre class="programlisting">for (let id of Object.keys(clientChangeLists)) { &#13;
  let clientChangeList = clientChangeLists[id]; &#13;
   &#13;
  let type = clientChangeList.type; &#13;
  let clientChanges = clientChangeList.changes; &#13;
   &#13;
  if (type === 'value') { &#13;
    // ... &#13;
  } else if (type === 'increment') { &#13;
    // ... &#13;
  } else { &#13;
    throw new TypeError('Invalid data type'); &#13;
  } &#13;
} &#13;
</pre><p>The change list of a normal data item will always contain one and only one change. Thus we can easily migrate what we've written:</p><pre class="programlisting">let clientChange = changes[0] as ClientValueChange&lt;any&gt;; &#13;
</pre><p>Now for incremental changes, we need to cumulatively apply possibly multiple changes in a single change list to a data item:</p><pre class="programlisting">let item = items[id]; &#13;
 &#13;
for ( &#13;
  let clientChange &#13;
  of clientChanges as ClientIncrementChange[] &#13;
) { &#13;
  let { &#13;
    uid, &#13;
    increment &#13;
  } = clientChange; &#13;
   &#13;
  if (item.uids.indexOf(uid) &lt; 0) { &#13;
    item.value += increment; &#13;
    item.uids.push(uid); &#13;
  } &#13;
} &#13;
</pre><p>But remember to take care of the timestamp or cases in which no item with a specified ID exists:</p><pre class="programlisting">let item: ServerDataItem&lt;any&gt;; &#13;
 &#13;
if (hasOwnProperty.call(items, id)) { &#13;
  item = items[id]; &#13;
  item.timestamp = now; &#13;
} else { &#13;
  item = items[id] = { &#13;
    id, &#13;
    type, &#13;
    timestamp: now, &#13;
    uids: [], &#13;
    value: 0 &#13;
  }; &#13;
} &#13;
</pre><p>Without knowing the current value of an incremental data item on the client, we cannot assure that the value is up to date. Previously, we decided whether to respond with a new value by comparing the timestamp with the timestamp of the current synchronization, but that does not work anymore for incremental changes.</p><p>A simple way to make this work is by deleting keys from <code class="literal">clientChangeLists</code> that still need to be synchronized to the client. And when preparing responses, it can skip IDs that are still in <code class="literal">clientChangeLists</code>:</p><pre class="programlisting">if ( &#13;
  item.timestamp &gt; lastTimestamp &amp;&amp; &#13;
  !hasOwnProperty.call(clientChangeLists, id) &#13;
) { &#13;
  serverChanges[id] = item.value; &#13;
} &#13;
</pre><p>Remember to add <code class="literal">delete clientChangeLists[id];</code> for normal data items that did not survive conflicts resolving as well.</p><p>Now we have implemented a synchronizing logic that can do quite a lot jobs for offline applications. Earlier, I raised a question about increasing branches that do not look good. But if you know your features are going to end there, or at least with limited changes, it's not a bad implementation, although we'll soon cross the balance point, as meeting 80% of the needs won't make us happy enough.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Supporting more conflict merging</h2></div></div></div><p>Though we have met the needs of 80%, there is still a big chance that we might want some extra features. For example, we want the ratio of the days marked as available by the user in the current month, and the user should be able to add or remove days from the list. We can achieve that in different ways, and we'll choose a simple way, as usual.</p><p>We are going to support synchronizing a set with operations such as add and remove, and calculate the ratio on the client.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec25"/>New data structures</h3></div></div></div><p>To describe set changes, we need a new <code class="literal">ClientChange</code> type. When we are adding or removing an element from a set, we only care about the last operation to the same element. This means that the following:</p><div><ol class="orderedlist arabic"><li class="listitem">If multiple operations are made to the same element, we only need to keep the last one.</li><li class="listitem">A <code class="literal">time</code> property is required for resolving conflicts.</li></ol></div><p>So here are the new types:</p><pre class="programlisting">enum SetOperation { &#13;
  add, &#13;
  remove &#13;
} &#13;
 &#13;
interface ClientSetChange extends ClientChange { &#13;
  element: number; &#13;
  time: number; &#13;
  operation: SetOperation; &#13;
} &#13;
</pre><p>The set data stored on the server side is going to be a little different. We'll have a map with the element (in the form of a <code class="literal">string</code>) as key, and a structure with <code class="literal">operation</code> and <code class="literal">time</code> properties as the values:</p><pre class="programlisting">interface ServerSetElementOperationInfo { &#13;
  operation: SetOperation; &#13;
  time: number; &#13;
} &#13;
</pre><p>Now we have enough information to resolve conflicts from multiple clients. And we can generate the set by keys with a little help from the last operations done to the elements.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec26"/>Updating client side</h3></div></div></div><p>And now, the client-side <code class="literal">update</code> method gets a new part-time job: saving set changes just like value and incremental changes. We need to update the method signature for this new job (do not forget to add <code class="literal">'set'</code> to <code class="literal">DataType</code>):</p><pre class="programlisting">update( &#13;
  id: string, &#13;
  type: 'set', &#13;
  element: number, &#13;
  operation: SetOperation &#13;
): void; &#13;
update&lt;T&gt;( &#13;
  id: string, &#13;
  type: DataType, &#13;
  value: T, &#13;
  operation?: SetOperation &#13;
): void; &#13;
</pre><p>We also need to add another <code class="literal">else if</code>:</p><pre class="programlisting">else if (type === 'set') { &#13;
  let element = &lt;any&gt;value as number; &#13;
   &#13;
  if (hasOwnProperty.call(storedChangeLists, id)) { &#13;
    // ... &#13;
  } else { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>If there are already operations made to this set, we need to find and remove that last operation to the target element (if any). Then append a new change with the latest operation:</p><pre class="programlisting">let changeList = storedChangeLists[id]; &#13;
let changes = changeList.changes as ClientSetChange[]; &#13;
 &#13;
for (let i = 0; i &lt; changes.length; i++) { &#13;
  let change = changes[i]; &#13;
   &#13;
  if (change.element === element) { &#13;
    changes.splice(i, 1); &#13;
    break; &#13;
  } &#13;
} &#13;
 &#13;
changes.push({ &#13;
  element, &#13;
  time: Date.now(), &#13;
  operation &#13;
}); &#13;
</pre><p>If no change has been made since last successful synchronization, we'll need to create a new change list for the latest operation:</p><pre class="programlisting">let changeList: ClientChangeList&lt;ClientSetChange&gt; = { &#13;
  type: 'set', &#13;
  changes: [ &#13;
    { &#13;
      element, &#13;
      time: Date.now(), &#13;
      operation &#13;
    } &#13;
  ] &#13;
}; &#13;
 &#13;
storedChangeLists[id] = changeList; &#13;
</pre><p>And again, do not forget to update the stored value. This is a little bit more than just assigning or accumulating the value, but it should still be quite easy to implement.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec27"/>Updating the server side</h3></div></div></div><p>Just like we've done with the client, we need to add a corresponding <code class="literal">else if</code> branch to merge changes of type <code class="literal">'set'</code>. We are also deleting the ID from <code class="literal">clientChangeLists</code> regardless of whether there are newer changes for a simpler implementation:</p><pre class="programlisting">else if (type === 'set') { &#13;
  let item: ServerDataItem&lt;{ &#13;
    [element: string]: ServerSetElementOperationInfo; &#13;
  }&gt;; &#13;
   &#13;
  delete clientChangeLists[id]; &#13;
} &#13;
</pre><p>The conflict resolving logic is quite similar to what we do to the conflicts of normal values. We just need to make comparisons to each element, and only keep the last operation.</p><p>And when preparing the response that will be synchronized to the client, we can generate the set by putting together elements with <code class="literal">add</code> as their last operations:</p><pre class="programlisting">if (item.type === 'set') { &#13;
  let operationInfos: { &#13;
    [element: string]: ServerSetElementOperationInfo; &#13;
  } = item.value; &#13;
   &#13;
  serverChanges[id] = Object &#13;
    .keys(operationInfos) &#13;
    .filter(element =&gt; &#13;
      operationInfos[element].operation === &#13;
        SetOperation.add &#13;
    ) &#13;
    .map(element =&gt; Number(element)); &#13;
} else { &#13;
  serverChanges[id] = item.value; &#13;
} &#13;
</pre><p>Finally, we have a working mess (if it actually works). Cheers!</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Things that go wrong while implementing everything</h2></div></div></div><p>When we started to add features, things were actually fine, if you are not obsessive about pursuing the feeling of design. Then we sensed the code being a little awkward as we saw more and more nested branches.</p><p>So now it's time to answer the question, what are the differences between the two kinds of branch we wrote? My understanding of why I am feeling awkward about the <code class="literal">if (type === 'foo') { ... }</code> branch is that it's not strongly related to the context. Comparing timestamps, on the other hand, is a more natural part of a certain synchronizing process.</p><p>Again, I am not saying this is bad. But this gives us a hint about where we might start our surgery from when we start to lose control (due to our limited brain capacity, it's just a matter of complexity).</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec28"/>Piling up similar yet parallel processes</h3></div></div></div><p>Most of the code in this chapter is to handle the process of synchronizing data between a client and a server. To get adapted to new features, we just kept adding new things into methods, such as <code class="literal">update</code> and <code class="literal">synchronize</code>.</p><p>You might have already found that most outlines of the logic can be, and should be, shared across multiple data types. But we didn't do that.</p><p>If we look into what's written, the duplication is actually minor judging from the aspect of code texts. Taking the <code class="literal">update</code> method of the client, for example, the logic of every branch seems to differ. If finding abstractions has not become your built-in reaction, you might just stop there. Or if you are not a fan of long functions, you might refactor the code by splitting it into small ones of the same class. That could make things a little better, but far from enough.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec29"/>Data stores that are tremendously simplified</h3></div></div></div><p>In the implementation, we were playing heavily and directly with ideal <em>in-memory</em> stores. It would be nice if we could have a wrapper for it, and make the real store interchangeable.</p><p>This might not be the case for this implementation as it is based on extremely ideal and simplified assumptions and requirements. But adding a wrapper could be a way to provide useful helpers.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Getting things right</h1></div></div></div><p>So let's get out of the illusion of comparing code one character at a time and try to find an abstraction that can be applied to updating all of these data types. There are two key points of this abstraction that have already been mentioned in the previous section:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">change</code> contains the information that can transform the value of an item from one to another</li><li class="listitem" style="list-style-type: disc">Multiple changes could be generated or applied to one data item during a single synchronization</li></ul></div><p>Now, starting from changes, let's think about what happens when an <code class="literal">update</code> method of a client is called.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Finding abstraction</h2></div></div></div><p>Take a closer look to the method <code class="literal">update</code> of client:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For data of the <code class="literal">'value'</code> type, first we create the change, including a new value, and then update the change list to make the newly created change the only one. After that, we update the value of data item.</li><li class="listitem" style="list-style-type: disc">For data of the <code class="literal">'increment'</code> type, we add a change including the increment in the change list; or if a change that has not be synchronized already exists, update the increment of the existing change. And then, we update the value of the data item.</li><li class="listitem" style="list-style-type: disc">Finally, for data of the <code class="literal">'set'</code> type, we create a change reflecting the latest operation. After adding the new change to the change list, we also remove changes that are no longer necessary. Then we update the value of the data item.</li></ul></div><p>Things are getting clear. Here is what's happening to these data types when <code class="literal">update</code> is called:</p><div><ol class="orderedlist arabic"><li class="listitem">Create new change.</li><li class="listitem">Merge the new change to the change list.</li><li class="listitem">Apply the new change to the data item.</li></ol></div><p>Now it's even better. Every step is different for different data types, but different steps share the same outline; what we need to do is to implement different strategies for different data types.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Implementing strategies</h2></div></div></div><p>Doing all kind of changes with a single <code class="literal">update</code> function could be confusing. And before we move on, let's split it into three different methods: <code class="literal">update</code> for normal values, <code class="literal">increase</code> for incremental values, and <code class="literal">addTo</code>/<code class="literal">removeFrom</code> for sets.</p><p>Then we are going to create a new private method called <code class="literal">applyChange</code>, which will take the change created by other methods and continue with step 2 and step 3. It accepts a strategy object with two methods: <code class="literal">append</code> and <code class="literal">apply</code>:</p><pre class="programlisting">interface ClientChangeStrategy&lt;T extends ClientChange&gt; { &#13;
  append(list: ClientChangeList&lt;T&gt;, change: T): void; &#13;
  apply(item: ClientDataItem&lt;any&gt;, change: T): void; &#13;
} &#13;
</pre><p>For a normal data item, the strategy object could be as follows:</p><pre class="programlisting">let strategy: ClientChangeStrategy&lt;ClientValueChange&lt;any&gt;&gt; = {  &#13;
  append(list, change) { &#13;
    list.changes = [change]; &#13;
  }, &#13;
  apply(item, change) { &#13;
    item.value = change.value; &#13;
  } &#13;
}; &#13;
</pre><p>And for incremental data item, it takes a few more lines. First, the <code class="literal">append</code> method:</p><pre class="programlisting">let changes = list.changes; &#13;
let lastChange = changes[changes.length]; &#13;
 &#13;
if (!lastChange || lastChange.synced) { &#13;
  changes.push(change); &#13;
} else { &#13;
  lastChange.increment += change.increment; &#13;
} &#13;
</pre><p>The <code class="literal">append</code> method is followed by the <code class="literal">apply</code> method:</p><pre class="programlisting">if (item.value === undefined) { &#13;
  item.value = change.increment; &#13;
} else { &#13;
  item.value += change.increment; &#13;
} &#13;
</pre><p>Now in the <code class="literal">applyChange</code> method, we need to take care of the creation of non-existing items and change lists, and invoke different <code class="literal">append</code> and <code class="literal">apply</code> methods based on different data types.</p><p>The same technique can be applied to other processes. Though detailed processes that apply to the client and the server differ, we can still write them together as modules.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Wrapping stores</h2></div></div></div><p>We are going to make a lightweight wrapper around plain in-memory store objects with the ability to read and write, taking the server-side store as an example:</p><pre class="programlisting">export class ServerStore { &#13;
  private items: { &#13;
    [id: string]: ServerDataItem&lt;any&gt;; &#13;
  } = Object.create(null); &#13;
} &#13;
 &#13;
export class Server { &#13;
  constructor( &#13;
    public store: ServerStore &#13;
  ) { } &#13;
} &#13;
</pre><p>To fit our requirements, we need to implement <code class="literal">get</code>, <code class="literal">set</code>, and <code class="literal">getAll</code> methods (or even better, a <code class="literal">find</code> method with conditions) for <code class="literal">ServerStore</code>:</p><pre class="programlisting">get&lt;T, TExtra extends ServerDataItemExtra&gt;(id: string): &#13;
  ServerDataItem&lt;T&gt; &amp; TExtra { &#13;
  return hasOwnProperty.call(this.items, id) ? &#13;
    this.items[id] as ServerDataItem&lt;T&gt; &amp; TExtra : undefined; &#13;
} &#13;
 &#13;
set&lt;T, TExtra extends ServerDataItemExtra&gt;( &#13;
  id: string, &#13;
  item: ServerDataItem&lt;T&gt; &amp; Textra &#13;
): void { &#13;
  this.items[id] = item; &#13;
} &#13;
 &#13;
getAll&lt;T, TExtra extends ServerDataItemExtra&gt;(): &#13;
  (ServerDataItem&lt;T&gt; &amp; TExtra)[] { &#13;
  let items = this.items; &#13;
  return Object &#13;
    .keys(items) &#13;
    .map(id =&gt; items[id] as ServerDataItem&lt;T&gt; &amp; TExtra); &#13;
} &#13;
</pre><p>You may have noticed from the interfaces and generics that I've also torn down <code class="literal">ServerDataItem</code> into intersection types of the common part and extras.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we've been part of the evolution of a simplified yet reality-related project. Starting with a simple code base that couldn't be wrong, we added a lot of features and experienced the process of putting acceptable changes together and making the whole thing a mess.</p><p>We were always trying to write readable code by either naming things nicely or adding semantically necessary redundancies, but that won't help much as the complexity grows.</p><p>During the process, we've learned how offline synchronizing works. And with the help of the most common design patterns, such as the Strategy Pattern, we managed to split the project into small and controllable parts.</p><p>In the upcoming chapters, we'll catalog more useful design patterns with code examples in TypeScript, and try to apply those design patterns to specific issues.</p></div></body></html>