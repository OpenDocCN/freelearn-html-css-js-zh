- en: Chapter 2. The AutoComplete Widget and its Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 自动完成小部件及其用法
- en: The AutoComplete widget from Kendo UI creates the "word wheel" effect on an
    input box as a user types. A word wheel is an effect where words appear beneath
    a textbox as a user types that help suggest possible search terms. You often see
    this on search engines such as Google and Bing. This can be used to give the user
    a list of approved choices from which he or she can choose, or it can also help
    the user type specific keywords accurately, since the canonical form of the item
    appears directly beneath the input box for the user to select. It also saves the
    user's time if he or she only has to type one or two characters of a potentially
    long search term. The AutoComplete widget in Kendo UI is very easy to configure
    and brings this functionality to users of your site with little effort on your
    part.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI中的自动完成小部件在用户输入时会在输入框上创建“单词轮”效果。单词轮是一种效果，当用户输入时，单词会出现在文本框下方，帮助建议可能的搜索词。你经常在像Google和Bing这样的搜索引擎上看到这种效果。这可以用来给用户一个他们可以选择的批准选项列表，或者它也可以帮助用户准确输入特定的关键词，因为项目的规范形式会直接出现在输入框下方供用户选择。如果用户只需要输入可能的长搜索词中的一个或两个字符，这也可以节省用户的时间。Kendo
    UI中的自动完成小部件非常容易配置，并且几乎不需要你做任何工作就能将此功能带给你的网站用户。
- en: '![The AutoComplete Widget and its Usage](img/4346OT_02_08.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![自动完成小部件及其用法](img/4346OT_02_08.jpg)'
- en: AutoComplete widget – basics
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动完成小部件 – 基础
- en: Open the Visual Studio project that you created in the previous chapter and
    then open the `KendoController.cs` class in the `Controllers` folder. Let's add
    a new action method for our initial AutoComplete test page.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 打开上一章中创建的Visual Studio项目，然后打开“Controllers”文件夹中的`KendoController.cs`类。让我们为我们的初始自动完成测试页面添加一个新的操作方法。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Right-click on the action method's name and choose **Add View**. For now, choose
    the defaults that appear in the dialog and this will take you to the web page
    so that we can get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击操作方法的名称，然后选择**添加视图**。现在，选择对话框中出现的默认值，这将带您进入网页，以便我们可以开始操作。
- en: '![AutoComplete widget – basics](img/4346OT_02_01.jpg)![AutoComplete widget
    – basics](img/4346OT_02_02.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![自动完成小部件 – 基础](img/4346OT_02_01.jpg)![自动完成小部件 – 基础](img/4346OT_02_02.jpg)'
- en: Binding AutoComplete to a local source
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自动完成绑定到本地源
- en: Since we are referencing the default layout that we created in the last chapter,
    we will get all of the Kendo and jQuery files that we need in our page header
    without having to retype anything.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在引用上一章中创建的默认布局，因此我们不需要重新输入任何内容就可以在我们的页面标题中获取所有需要的Kendo和jQuery文件。
- en: We will start by demonstrating how to use the AutoComplete widget purely through
    JavaScript with local data binding. We will need an input element, a JavaScript
    array, and some jQuery.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过JavaScript和本地数据绑定来演示如何使用自动完成小部件。我们需要一个输入元素、一个JavaScript数组和一些jQuery。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use a list of the United States and Territories for a nice sampling of
    the alphabet and a list long enough for a demonstration. All that we have done
    so far is created some data in JavaScript for the AutoComplete to use, and then
    wired it up with jQuery and Kendo UI to the input element at the top of the page.
    We have specified that we want to use the `statesAndTerritories` JavaScript array
    as our data source, that we wanted the filter to run in "`startswith`" mode, that
    we want placeholder text in the input element, and that the items in the array
    are separated by a comma. These properties are explained in more detail at the
    end of the chapter. Run this and you should see an input box with some nice looking
    placeholder text in your browser. Type some letters in it and you get an immediate
    result with some state and territory suggestions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用美国和领土的列表来展示字母表，并且列表足够长，可以进行演示。我们到目前为止所做的一切就是为自动完成创建了一些JavaScript数据，然后使用jQuery和Kendo
    UI将其连接到页面顶部的输入元素。我们指定了我们想使用`statesAndTerritories` JavaScript数组作为我们的数据源，我们想要在输入元素中使用占位符文本，并且数组中的项由逗号分隔。这些属性在章节末尾有更详细的解释。运行它，你应该能在浏览器中看到一个带有一些看起来不错的占位符文本的输入框。在它里面输入一些字母，你会立即得到一些州和领土的建议。
- en: '![Binding AutoComplete to a local source](img/4346OT_02_03.jpg)![Binding AutoComplete
    to a local source](img/4346OT_02_04.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![绑定自动完成到本地源](img/4346OT_02_03.jpg)![绑定自动完成到本地源](img/4346OT_02_04.jpg)'
- en: Binding AutoComplete to Remote Data
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自动完成绑定到远程数据
- en: Now that we have seen how to wire up the AutoComplete widget using local JavaScript
    data, let's see how to do it with remote data. Add a new class called `StateTerritory.cs`
    to the `Models` folder in the Visual Studio project. Structure it to hold the
    relevant data about states and territories so that we can use this in our page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用本地JavaScript数据来配置AutoComplete小部件，接下来让我们看看如何使用远程数据来实现。在Visual Studio项目中，将名为`StateTerritory.cs`的新类添加到`Models`文件夹中。将其结构设计为包含关于州和地区的相关数据，以便我们可以在我们的页面上使用它。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now open the `SampleRepository.cs` class file and add some logic to create a
    repository of our state and territory data. Note that I have intentionally counted
    the District of Columbia as both a state and a territory for the purposes of future
    examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`SampleRepository.cs`类文件，并添加一些逻辑来创建我们的州和地区数据仓库。请注意，我故意将哥伦比亚特区既视为一个州又视为一个地区，以便于未来的示例。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have some server-side data that we can play with, but we still need
    to expose it across HTTP. Go back to the `KendoController.cs` class file and add
    a new action method like you see in this code block:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些可以在服务器端操作的数据，但我们仍然需要通过HTTP公开它。回到`KendoController.cs`类文件，并添加一个新动作方法，就像你在这个代码块中看到的那样：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will expose our collection of states and territories as a JSON array of
    `StateTerritory` objects. Remember to set the `JsonRequestBehavior.AllowGet` property
    or this will not work. Now we can modify our `AutoCompletePage.cshtml` file to
    use the transport property to get its data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将暴露我们的州和地区集合，作为`StateTerritory`对象的JSON数组。请记住设置`JsonRequestBehavior.AllowGet`属性，否则这不会工作。现在我们可以修改我们的`AutoCompletePage.cshtml`文件，使用传输属性来获取其数据。
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the page again and watch it pull data from the server. We have to specify
    which field contains the data text field, since our JSON data is structured as
    objects and not simply an array. We also no longer need the separator property.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行页面，并观察它从服务器获取数据。我们必须指定哪个字段包含数据文本字段，因为我们的JSON数据是结构为对象，而不是简单的数组。我们也不再需要分隔符属性。
- en: '![Binding AutoComplete to Remote Data](img/4346OT_02_03.jpg)![Binding AutoComplete
    to Remote Data](img/4346OT_02_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![绑定AutoComplete到远程数据](img/4346OT_02_03.jpg)![绑定AutoComplete到远程数据](img/4346OT_02_04.jpg)'
- en: Using AutoComplete with MVC through Models
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型通过MVC使用AutoComplete
- en: We can take this one step further and transform our code into Razor syntax with
    MVC. First, create a controller action method to return data from the server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这一步更进一步，将我们的代码转换为Razor语法与MVC一起使用。首先，创建一个控制器动作方法，从服务器返回数据。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, open `AutoCompletePage.cshtml` and delete everything in it after the `<h2>`
    tag. At the top of the file, we need to add a declaration so that this **View**
    page becomes strongly-typed to our new model class `StateTerritory.cs`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`AutoCompletePage.cshtml`文件，并在`<h2>`标签之后删除所有内容。在文件顶部，我们需要添加一个声明，以便这个**视图**页面成为我们的新模型类`StateTerritory.cs`的强类型。
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now add this code that utilizes the HTML helper class and the Kendo extension
    methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加这段代码，它利用HTML辅助类和Kendo扩展方法。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recognize the syntax? Except for the `BindTo(Model)` statement, these method
    names are the same as the properties we used in JavaScript (except that they start
    with capital letters, of course). The call to `BindTo(Model)` is how the MVC controller
    passes data into the MVC view. In this case, we strongly-typed our view to a collection
    (`IEnumerable`) of `StateTerritory` objects, and here in the code we are telling
    the Kendo framework that this model contains the data to display in the AutoComplete.
    The data in this model is used while the page is being created by the server,
    and is only accessible through the Razor syntax code statements in the **View**
    page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出语法了吗？除了`BindTo(Model)`语句外，这些方法名与我们在JavaScript中使用的属性名相同（当然，它们的首字母都是大写的）。`BindTo(Model)`的调用是MVC控制器将数据传递到MVC视图的方式。在这种情况下，我们将视图强类型化为`StateTerritory`对象的集合（`IEnumerable`），在这里的代码中，我们告诉Kendo框架这个模型包含要在AutoComplete中显示的数据。这个模型中的数据在服务器创建页面时使用，并且只能通过**视图**页面中的Razor语法代码语句访问。
- en: Even though we just wired up the AutoComplete to the server through MVC, the
    method we used isn't really like a call to remote data. It is actually using local
    data, by saving all of the model data from the server into the JavaScript where
    the AutoComplete is initialized. There isn't anything wrong with this, so long
    as we do not attempt to embed so much data into the page that it loads slowly.
    In fact it is likely a good way to boost performance in some situations, but it
    is important to know where the data is and how the page is accessing it. If we
    want the page to request the data from a URL, we need to make some changes to
    our view.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚通过 MVC 将 AutoComplete 连接到服务器，但我们使用的方法并不真正像是对远程数据的调用。实际上，它是通过将服务器端的所有模型数据保存到
    AutoComplete 初始化的 JavaScript 中来使用本地数据。只要我们不尝试将如此多的数据嵌入到页面中以至于它加载缓慢，这并没有什么问题。实际上，在某些情况下，这可能是提高性能的好方法，但了解数据的位置以及页面如何访问它很重要。如果我们想让页面从
    URL 请求数据，我们需要对我们的视图做一些修改。
- en: Using AutoComplete with MVC through Ajax
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Ajax 使用 AutoComplete 与 MVC 结合
- en: Open the view and make a change to the `AutoComplete()` extension method call
    just like this code block.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开视图并修改 `AutoComplete()` 扩展方法调用，就像这个代码块一样。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have removed the `BindTo(Model)`and replaced it with a call to `DataSource()`
    where we use a lambda expression to define how to create the data source. In this
    case, we have configured it to use the action method that returns the JSON data
    we configured earlier, and also that the server is not performing any filtering.
    This effectively sets our web page up in the same way as our original JavaScript
    page that used the `transport` property to get JSON data from the server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了 `BindTo(Model)` 并用 `DataSource()` 调用替换，我们在这里使用 lambda 表达式来定义如何创建数据源。在这种情况下，我们已将其配置为使用之前配置的返回
    JSON 数据的动作方法，并且服务器没有执行任何过滤。这实际上将我们的网页设置得与原始使用 `transport` 属性从服务器获取 JSON 数据的 JavaScript
    页面相同。
- en: Sending data to the server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器发送数据
- en: We want to be able to filter the data for the AutoComplete widget on the server
    side. We can either use the `data` property within the `transport` JavaScript
    object, or we can continue with our MVC example and specify the data to send inside
    the `DataSource` lambda expression. Let's say, for example, that we want to be
    able to choose what type of states and territories show up in the AutoComplete
    widget. We can accomplish this by sending some data along with the request, then
    having the server revise the data that it sends back. Replace the contents of
    `AutoCompletePage.cshtml` with this updated code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在服务器端过滤 AutoComplete 小部件的数据。我们可以在 `transport` JavaScript 对象中的 `data` 属性中使用，或者我们可以继续使用我们的
    MVC 示例，并在 `DataSource` lambda 表达式中指定要发送的数据。比如说，如果我们想能够选择在 AutoComplete 小部件中显示哪些州和领地类型，我们可以通过在请求中发送一些数据来实现这一点，然后让服务器修改它发送回的数据。用以下更新后的代码替换
    `AutoCompletePage.cshtml` 的内容。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the call to `Data("onAdditionalData")` in the lambda expression and the
    new JavaScript method `onAdditionalData()` with the same name. When the data source
    for the AutoComplete is read, it will fire this JavaScript event and send the
    result to the server with a parameter named `showStates`. In order to receive
    this data into your action method, you need to add a parameter to it with a matching
    name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 lambda 表达式中的 `Data("onAdditionalData")` 调用和同名的新的 JavaScript 方法 `onAdditionalData()`。当读取
    AutoComplete 的数据源时，它将触发这个 JavaScript 事件，并将带有 `showStates` 参数的结果发送到服务器。为了将此数据接收进你的动作方法，你需要添加一个具有匹配名称的参数。
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when the AutoComplete code sends the `showStates` parameter as part of
    its web request, the controller will use the value of that to determine whether
    or not to filter the data that it sends back.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 AutoComplete 代码将其 `showStates` 参数作为其网络请求的一部分发送时，控制器将使用该值来确定是否过滤它发送回的数据。
- en: Using Templates to Customize AutoComplete
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板自定义 AutoComplete
- en: 'Kendo templates can be used to customize the appearance of the items in your
    AutoComplete. This can even get quite fancy with images and special styles. Here
    is a simple example. Update the Razor portion of the `AutoCompletePage.cshtml`
    page to look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo 模板可以用来自定义 AutoComplete 中项目的显示外观。这甚至可以变得相当复杂，包括图片和特殊样式。这里有一个简单的例子。将 `AutoCompletePage.cshtml`
    页面的 Razor 部分更新为如下所示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have added a variable called `template` that is holding our Kendo template
    definition. We then referenced that in our `AutoComplete()` setup code. Run the
    page and take a look.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`template`的变量，它包含我们的Kendo模板定义。然后我们在`AutoComplete()`设置代码中引用了它。运行页面并查看结果。
- en: '![Using Templates to Customize AutoComplete](img/4346OT_02_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![使用模板自定义自动完成](img/4346OT_02_05.jpg)'
- en: Configuring all of the AutoComplete properties
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置所有自动完成属性
- en: The AutoComplete widget has several different properties that can be set during
    its initialization to customize its behavior. Here is a structured code sample
    to show you what is available on the AutoComplete widget.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件在初始化期间可以设置几个不同的属性来定制其行为。以下是一个结构化代码示例，展示了自动完成小部件上可用的功能。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hooking into AutoComplete widget events
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩入自动完成小部件事件
- en: 'The AutoComplete widget has several different events that it fires while performing
    actions on your page. You can bind them after the AutoComplete widget has been
    initialized like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件在执行页面上的操作时将触发几个不同的事件。您可以在自动完成小部件初始化后绑定它们，如下所示：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or you can define them within the properties of the AutoComplete widget itself
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在自动完成小部件本身的属性中定义它们，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In either case, this is the list of events to which you can attach your own
    code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，这都是您可以附加您自己的代码的事件列表。
- en: Change
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改
- en: The `change` event fires as the selection in the AutoComplete widget changes.
    You can bind events after initialization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动完成小部件中的选择更改时，将触发`change`事件。您可以在初始化后绑定事件。
- en: Close
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭
- en: The `close` event fires when the drop-down list is closed from the AutoComplete
    widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当从自动完成小部件关闭下拉列表时，将触发`close`事件。
- en: Open
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开
- en: The `open` event fires every time the drop-down list is opened from the AutoComplete
    widget.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`事件在每次从自动完成小部件打开下拉列表时都会触发。'
- en: Select
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: The `select` event fires when any of the elements is selected from the AutoComplete
    widget. It passes the argument `e.item` to the function that handles it so that
    you can access the item that was selected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当从自动完成小部件中选择任何元素时，将触发`select`事件。它将`e.item`参数传递给处理它的函数，以便您可以访问所选择的项。
- en: Using the API AutoComplete methods
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API自动完成方法
- en: 'To access the AutoComplete widget from within JavaScript code, you can access
    it through the API by calling it this way through jQuery:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要从JavaScript代码内部访问自动完成小部件，您可以通过以下方式通过jQuery调用API：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you have a variable reference to the AutoComplete widget, you will be able
    to call the API methods and manipulate it through code as you wish. These are
    the API methods available on the AutoComplete widget.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了自动完成小部件的变量引用，您就可以通过代码以您希望的方式调用API方法并对其进行操作。这些是自动完成小部件上可用的API方法。
- en: Close
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭
- en: The `close()` method closes the drop-down list on the AutoComplete widget.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()`方法关闭自动完成小部件上的下拉列表。'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: DataItem
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据项
- en: The `dataItem()` method returns the data record at the specified index. This
    `dataItem` object will be the specific object from the AutoComplete widget's data
    source at the specified index. In our examples above, it would be a specific `stateOrTerritory`
    object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataItem()`方法返回指定索引处的数据记录。此`dataItem`对象将是自动完成小部件数据源在指定索引处的特定对象。在我们的示例中，它将是一个特定的`stateOrTerritory`对象。'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Destroy
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁
- en: The `destroy()` method prepares the AutoComplete widget for safe removal from
    the DOM. It detaches all event handlers and removes data attributes. It does not
    actually take the final step of removing it from the DOM; that is an action you
    must program yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy()`方法准备自动完成小部件以安全地从DOM中移除。它断开所有事件处理程序并删除数据属性。它实际上并不执行从DOM中移除的最后一步；这是您必须自己编写的操作。'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Enable
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用
- en: The `enable()` method toggles the AutoComplete widget on and off.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable()`方法切换自动完成小部件的开启和关闭状态。'
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refresh
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新
- en: The `refresh()` method re-renders the items in the drop-down list of the AutoComplete
    widget.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh()`方法重新渲染自动完成小部件下拉列表中的项。'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Search
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: The `search()` method filters the data source of the AutoComplete widget using
    the provided parameter and then rebinds the drop-down list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`方法使用提供的参数过滤自动完成小部件的数据源，然后重新绑定下拉列表。'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Select
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: The `select()` method selects a drop-down list item from the AutoComplete widget
    and sets the text of the AutoComplete input box.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()`方法从自动完成小部件中选择下拉列表项，并设置自动完成输入框的文本。'
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Suggest
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议
- en: The `suggest()` method forces a suggestion onto the text of the AutoComplete
    widget.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`suggest()` 方法将建议强制应用到自动完成小部件的文本上。'
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Value
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 价值
- en: The `value()` method gets or sets the value of the AutoComplete widget.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`value()` 方法获取或设置自动完成小部件的值。'
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The AutoComplete widget is a great way to aid users on your site. Any time an
    input box's values can be predicted, such as when they come from a specific set
    of values or when searching common terms, an AutoComplete widget will immediately
    make your site easier to use and your users are sure to notice and appreciate
    it. Not only that, but the configuration is so straightforward that you can enable
    it without much effort.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件是帮助网站用户的一个很好的方式。任何输入框的值可以被预测的情况，例如当它们来自一组特定的值或搜索常用术语时，自动完成小部件将立即使您的网站更容易使用，并且用户肯定会注意到并欣赏它。不仅如此，配置非常简单，您几乎不需要费力就可以启用它。
- en: In the next chapter we will learn how to use the Calendar widget. This widget
    will allow you to display and configure interactive calendar controls in your
    web pages so that users can easily select dates. It will also give you a way of
    binding data to calendars to show important dates. The Telerik Kendo UI Calendar
    widget will help change a complicated JavaScript calendar into a simple-to-use
    tool for developing great web pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用日历小部件。这个小部件将允许您在网页中显示和配置交互式日历控件，以便用户可以轻松选择日期。它还将为您提供一种将数据绑定到日历上的方法，以显示重要日期。Telerik
    Kendo UI 日历小部件将帮助将复杂的 JavaScript 日历转换为开发出色网页的简单易用工具。
