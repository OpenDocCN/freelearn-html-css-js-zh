- en: Chapter 2. The AutoComplete Widget and its Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AutoComplete widget from Kendo UI creates the "word wheel" effect on an
    input box as a user types. A word wheel is an effect where words appear beneath
    a textbox as a user types that help suggest possible search terms. You often see
    this on search engines such as Google and Bing. This can be used to give the user
    a list of approved choices from which he or she can choose, or it can also help
    the user type specific keywords accurately, since the canonical form of the item
    appears directly beneath the input box for the user to select. It also saves the
    user's time if he or she only has to type one or two characters of a potentially
    long search term. The AutoComplete widget in Kendo UI is very easy to configure
    and brings this functionality to users of your site with little effort on your
    part.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AutoComplete Widget and its Usage](img/4346OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AutoComplete widget – basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the Visual Studio project that you created in the previous chapter and
    then open the `KendoController.cs` class in the `Controllers` folder. Let's add
    a new action method for our initial AutoComplete test page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the action method's name and choose **Add View**. For now, choose
    the defaults that appear in the dialog and this will take you to the web page
    so that we can get started.
  prefs: []
  type: TYPE_NORMAL
- en: '![AutoComplete widget – basics](img/4346OT_02_01.jpg)![AutoComplete widget
    – basics](img/4346OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binding AutoComplete to a local source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are referencing the default layout that we created in the last chapter,
    we will get all of the Kendo and jQuery files that we need in our page header
    without having to retype anything.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by demonstrating how to use the AutoComplete widget purely through
    JavaScript with local data binding. We will need an input element, a JavaScript
    array, and some jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use a list of the United States and Territories for a nice sampling of
    the alphabet and a list long enough for a demonstration. All that we have done
    so far is created some data in JavaScript for the AutoComplete to use, and then
    wired it up with jQuery and Kendo UI to the input element at the top of the page.
    We have specified that we want to use the `statesAndTerritories` JavaScript array
    as our data source, that we wanted the filter to run in "`startswith`" mode, that
    we want placeholder text in the input element, and that the items in the array
    are separated by a comma. These properties are explained in more detail at the
    end of the chapter. Run this and you should see an input box with some nice looking
    placeholder text in your browser. Type some letters in it and you get an immediate
    result with some state and territory suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding AutoComplete to a local source](img/4346OT_02_03.jpg)![Binding AutoComplete
    to a local source](img/4346OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binding AutoComplete to Remote Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to wire up the AutoComplete widget using local JavaScript
    data, let's see how to do it with remote data. Add a new class called `StateTerritory.cs`
    to the `Models` folder in the Visual Studio project. Structure it to hold the
    relevant data about states and territories so that we can use this in our page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `SampleRepository.cs` class file and add some logic to create a
    repository of our state and territory data. Note that I have intentionally counted
    the District of Columbia as both a state and a territory for the purposes of future
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have some server-side data that we can play with, but we still need
    to expose it across HTTP. Go back to the `KendoController.cs` class file and add
    a new action method like you see in this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will expose our collection of states and territories as a JSON array of
    `StateTerritory` objects. Remember to set the `JsonRequestBehavior.AllowGet` property
    or this will not work. Now we can modify our `AutoCompletePage.cshtml` file to
    use the transport property to get its data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the page again and watch it pull data from the server. We have to specify
    which field contains the data text field, since our JSON data is structured as
    objects and not simply an array. We also no longer need the separator property.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding AutoComplete to Remote Data](img/4346OT_02_03.jpg)![Binding AutoComplete
    to Remote Data](img/4346OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using AutoComplete with MVC through Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take this one step further and transform our code into Razor syntax with
    MVC. First, create a controller action method to return data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, open `AutoCompletePage.cshtml` and delete everything in it after the `<h2>`
    tag. At the top of the file, we need to add a declaration so that this **View**
    page becomes strongly-typed to our new model class `StateTerritory.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now add this code that utilizes the HTML helper class and the Kendo extension
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Recognize the syntax? Except for the `BindTo(Model)` statement, these method
    names are the same as the properties we used in JavaScript (except that they start
    with capital letters, of course). The call to `BindTo(Model)` is how the MVC controller
    passes data into the MVC view. In this case, we strongly-typed our view to a collection
    (`IEnumerable`) of `StateTerritory` objects, and here in the code we are telling
    the Kendo framework that this model contains the data to display in the AutoComplete.
    The data in this model is used while the page is being created by the server,
    and is only accessible through the Razor syntax code statements in the **View**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we just wired up the AutoComplete to the server through MVC, the
    method we used isn't really like a call to remote data. It is actually using local
    data, by saving all of the model data from the server into the JavaScript where
    the AutoComplete is initialized. There isn't anything wrong with this, so long
    as we do not attempt to embed so much data into the page that it loads slowly.
    In fact it is likely a good way to boost performance in some situations, but it
    is important to know where the data is and how the page is accessing it. If we
    want the page to request the data from a URL, we need to make some changes to
    our view.
  prefs: []
  type: TYPE_NORMAL
- en: Using AutoComplete with MVC through Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the view and make a change to the `AutoComplete()` extension method call
    just like this code block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the `BindTo(Model)`and replaced it with a call to `DataSource()`
    where we use a lambda expression to define how to create the data source. In this
    case, we have configured it to use the action method that returns the JSON data
    we configured earlier, and also that the server is not performing any filtering.
    This effectively sets our web page up in the same way as our original JavaScript
    page that used the `transport` property to get JSON data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to be able to filter the data for the AutoComplete widget on the server
    side. We can either use the `data` property within the `transport` JavaScript
    object, or we can continue with our MVC example and specify the data to send inside
    the `DataSource` lambda expression. Let's say, for example, that we want to be
    able to choose what type of states and territories show up in the AutoComplete
    widget. We can accomplish this by sending some data along with the request, then
    having the server revise the data that it sends back. Replace the contents of
    `AutoCompletePage.cshtml` with this updated code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice the call to `Data("onAdditionalData")` in the lambda expression and the
    new JavaScript method `onAdditionalData()` with the same name. When the data source
    for the AutoComplete is read, it will fire this JavaScript event and send the
    result to the server with a parameter named `showStates`. In order to receive
    this data into your action method, you need to add a parameter to it with a matching
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the AutoComplete code sends the `showStates` parameter as part of
    its web request, the controller will use the value of that to determine whether
    or not to filter the data that it sends back.
  prefs: []
  type: TYPE_NORMAL
- en: Using Templates to Customize AutoComplete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kendo templates can be used to customize the appearance of the items in your
    AutoComplete. This can even get quite fancy with images and special styles. Here
    is a simple example. Update the Razor portion of the `AutoCompletePage.cshtml`
    page to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added a variable called `template` that is holding our Kendo template
    definition. We then referenced that in our `AutoComplete()` setup code. Run the
    page and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Templates to Customize AutoComplete](img/4346OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring all of the AutoComplete properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AutoComplete widget has several different properties that can be set during
    its initialization to customize its behavior. Here is a structured code sample
    to show you what is available on the AutoComplete widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hooking into AutoComplete widget events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AutoComplete widget has several different events that it fires while performing
    actions on your page. You can bind them after the AutoComplete widget has been
    initialized like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can define them within the properties of the AutoComplete widget itself
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In either case, this is the list of events to which you can attach your own
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `change` event fires as the selection in the AutoComplete widget changes.
    You can bind events after initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Close
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `close` event fires when the drop-down list is closed from the AutoComplete
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Open
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `open` event fires every time the drop-down list is opened from the AutoComplete
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `select` event fires when any of the elements is selected from the AutoComplete
    widget. It passes the argument `e.item` to the function that handles it so that
    you can access the item that was selected.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API AutoComplete methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access the AutoComplete widget from within JavaScript code, you can access
    it through the API by calling it this way through jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a variable reference to the AutoComplete widget, you will be able
    to call the API methods and manipulate it through code as you wish. These are
    the API methods available on the AutoComplete widget.
  prefs: []
  type: TYPE_NORMAL
- en: Close
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `close()` method closes the drop-down list on the AutoComplete widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: DataItem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dataItem()` method returns the data record at the specified index. This
    `dataItem` object will be the specific object from the AutoComplete widget's data
    source at the specified index. In our examples above, it would be a specific `stateOrTerritory`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Destroy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `destroy()` method prepares the AutoComplete widget for safe removal from
    the DOM. It detaches all event handlers and removes data attributes. It does not
    actually take the final step of removing it from the DOM; that is an action you
    must program yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Enable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `enable()` method toggles the AutoComplete widget on and off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Refresh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `refresh()` method re-renders the items in the drop-down list of the AutoComplete
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `search()` method filters the data source of the AutoComplete widget using
    the provided parameter and then rebinds the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `select()` method selects a drop-down list item from the AutoComplete widget
    and sets the text of the AutoComplete input box.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Suggest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `suggest()` method forces a suggestion onto the text of the AutoComplete
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `value()` method gets or sets the value of the AutoComplete widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AutoComplete widget is a great way to aid users on your site. Any time an
    input box's values can be predicted, such as when they come from a specific set
    of values or when searching common terms, an AutoComplete widget will immediately
    make your site easier to use and your users are sure to notice and appreciate
    it. Not only that, but the configuration is so straightforward that you can enable
    it without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn how to use the Calendar widget. This widget
    will allow you to display and configure interactive calendar controls in your
    web pages so that users can easily select dates. It will also give you a way of
    binding data to calendars to show important dates. The Telerik Kendo UI Calendar
    widget will help change a complicated JavaScript calendar into a simple-to-use
    tool for developing great web pages.
  prefs: []
  type: TYPE_NORMAL
