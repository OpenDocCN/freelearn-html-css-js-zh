<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor156"/>14</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Testing Authentication</h1>
<p>Many web applications will involve authenticating users. This chapter shows how you can write tests for this functionality. These tests cover logging in, logging out, and ensuring that your application is only accessible to logged-in users.</p>
<p>This chapter is not a walkthrough and only includes a small amount of detail on the application code required to implement authentication. The book repository uses the <strong class="bold">Auth.js</strong> library, but the same testing techniques will work regardless of the implementation approach.</p>
<p>The chapter covers the following key topics:</p>
<ul>
<li>Testing authentication with Playwright</li>
<li>Testing authentication with Vitest</li>
</ul>
<p>By the end of the chapter, you’ll have seen how to write tests that cover all aspects of authentication.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter14/Complete">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter14/Complete</a>.</p>
<p>If you want to run the code in this sample, you’ll need to create a <code>.env</code> file with some environment variables. There’s an example file named <code>.env.example</code> that you can copy and save as <code>.env</code>, which should work, but if you want to try the GitHub OAuth integration, you’ll need to do some configuration within GitHub.</p>
<p>You’ll find more detailed information in the repository’s <code>README.md</code> file.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Testing authentication with Playwright</h1>
<p>This section <a id="_idIndexMarker460"/>details the groundwork required for effective testing with your Playwright tests. First, we look at how to provide hard-coded authentication credentials for your end-to-end tests. Then we use this to verify that users can log in and log out of the application. Finally, we’ll update the existing tests so that they ensure the user is logged in before attempting to test the application functionality.</p>
<p class="callout-heading">What about Cucumber?</p>
<p class="callout">If you’re using Cucumber tests with Playwright, then the same techniques presented here will also work for you.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Creating an auth profile for dev and test modes</h2>
<p>It’s fairly typical <a id="_idIndexMarker461"/>to<a id="_idIndexMarker462"/> use<a id="_idIndexMarker463"/> OAuth authentication strategies that delegate authentication responsibilities to a third-party provider, such as Google or GitHub. However, when it comes to writing end-to-end tests, it’s impractical to maintain user accounts with these third parties just for the purposes of testing. For one thing, account passwords expire and need to be reset periodically. And that kind of work needs to be documented, tracked and scheduled.</p>
<p>Another solution is to provide a special hard-coded credential that can be used to log in when the application server is run in a specific test mode. Your Playwright tests can then use this credential to log in.</p>
<p>Our solution does this in the following way:</p>
<ol>
<li>Playwright starts the server with an additional environment variable, <code>VITE_ALLOW_CREDENTIALS</code>, that is set to <code>true</code>.</li>
<li>The <code>Auth.js</code> initialization code looks for this credential, and, if it is found, enables login via its credentials mechanism. There is a single user, <code>api</code>, which has no password associated with it.</li>
<li>This user can then be used by both the API tests and your application dev mode.</li>
</ol>
<p>To ensure Playwright starts with the right environment variable, the <code>playwright.config.js</code> file changes like this:</p>
<pre class="source-code">
webServer: {
  command:
    'npm run build &amp;&amp; npm run preview',
  port: 4173<strong class="bold">,</strong>
  <strong class="bold">env: {</strong>
  <strong class="bold">  PATH: process.env.PATH,</strong>
  <strong class="bold">  VITE_ALLOW_CREDENTIALS: true</strong>
  <strong class="bold">}</strong>
},</pre>
<p>Then, the application has a file named <code>src/authProviders.js</code> that checks for the credential, shown in the following code snippet. This sample is specific to <code>Auth.js</code>, but other <a id="_idIndexMarker464"/>authentication libraries <a id="_idIndexMarker465"/>can<a id="_idIndexMarker466"/> be initialized similarly. The key point is that the expected <code>authProviders</code> is an array that may or may not contain the special credentials provider, depending on the value of the environment variable:</p>
<pre class="source-code">
import GitHubProvider from '@auth/core/providers/github';
import CredentialsProvider from '@auth/core/providers/credentials';
import {
  GITHUB_ID,
  GITHUB_SECRET
} from '$env/static/private';
const allowCredentials =
  import.meta.env.VITE_ALLOW_CREDENTIALS === 'true';
const GitHub = GitHubProvider({
  clientId: GITHUB_ID,
  clientSecret: GITHUB_SECRET
});
const credentials = CredentialsProvider({
  credentials: {
    username: { label: 'Username', type: 'text' }
  },
  async authorize({ username }, req) {
    if (username === 'api')
      return { id: '1', name: 'api' };
  }
});
const devAuthProviders = {
  GitHub,
  credentials
};
const prodAuthProviders = { GitHub };
export const authProviders = allowCredentials
  ? devAuthProviders
  : prodAuthProviders;</pre>
<p>With<a id="_idIndexMarker467"/> the application<a id="_idIndexMarker468"/> primed, it’s ready to be used in our tests.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Writing tests for login</h2>
<p>It’s important<a id="_idIndexMarker469"/> to have one test for a successful login flow and one for an unsuccessful one. Having these tests ensures you have automated test coverage of these pages.</p>
<p>Here’s an example of a successful login test. It can be found in the <code>tests/login.test.js</code> repository file. It navigates to the usual <code>/birthdays</code> route, then looks for a button named <code>api</code> user, and clicks the button again (which, this time, acts to submit the login information). It then checks that the user has been redirected to the main page and can see the <strong class="bold">Birthday </strong><strong class="bold">list</strong> heading:</p>
<pre class="source-code">
import { expect, test } from '@playwright/test';
test('logs in and returns to the application', async ({
  page
}) =&gt; {
  await page.goto('/birthdays');
  await page.waitForLoadState('networkidle');
  await page
    .getByRole('button', { name: /Sign in with
      credentials/i })
    .click();
  await page.getByRole('textbox').fill('api');
  await page
    .getByRole('button', { name: /Sign in with
      credentials/i })
    .click();
  await expect(
    page.getByText('Birthday list')
  ).toBeVisible();
});</pre>
<p>Note the use of the <code>page.waitForLoadState</code> Playwright function. This is necessary to ensure that all the relevant <code>Auth.js</code> code has run and eventually renders the sign-in button.</p>
<p>Next is the test for an unsuccessful login. For this, we can give any username other than <code>api</code>, so this test<a id="_idIndexMarker470"/> supplies the <code>unknown user</code> text, which gives the data some useful context:</p>
<pre class="source-code">
test('does not log in if log in fails', async ({
  page
}) =&gt; {
  await page.goto('/birthdays');
  await expect(
    page.getByText('Please login')
  ).toBeVisible();
  await page.waitForLoadState('networkidle');
  await page
    .getByRole('button', { name: /Sign in with
      credentials/i })
    .click();
  await page
    .getByRole('textbox')
    .fill('unknown user');
  await page
    .getByRole('button', { name: /Sign in with
      credentials/i })
    .click();
  await expect(
    page.getByText(
      'Sign in failed. Check the details you provided are
        correct.'
    )
  ).toBeVisible();
});</pre>
<p>That covers the<a id="_idIndexMarker471"/> tests for the new login functionality. Next, we need to update existing tests to ensure they continue to work.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Updating existing tests to authenticate the user</h2>
<p>The existing<a id="_idIndexMarker472"/> tests we have in <code>tests/birthdays.test.js</code> need to be updated so that each test starts with a logged-in user. We can do this using a <code>beforeEach</code> block, which has the advantage that the original tests doesn’t need to be modified.</p>
<p>Auth.js provides a neat API-like endpoint that we can call directly. This means that we don’t need to navigate through the web form for each test, which reduces the amount of work each test needs to do.</p>
<p>The <code>login</code> function is defined in the following code snippet. It mimics the action of clicking the <code>username</code> field value of <code>api</code>. It’s also important to send the <code>origin</code> header <a id="_idIndexMarker474"/>with this request; otherwise, it will be rejected:</p>
<pre class="source-code">
const login = async ({ context, baseURL }) =&gt; {
  const response = await context.request.get(
    '/auth/csrf'
  );
  const { csrfToken } = await response.json();
  const response2 = await context.request.post(
    '/auth/callback/credentials',
    {
      form: {
        username: 'api',
        csrfToken
      },
      headers: {
        origin: baseURL
      }
    }
  );
};</pre>
<p>That can then be triggered for each test in <code>tests/birthday.test.js</code> by sending it to <code>test.beforeEach</code>, like this:</p>
<pre class="source-code">
test.beforeEach(login);</pre>
<p>That completes the Playwright tests. You’ll note I’ve left out any test to check what happens when you go to the <code>/birthday</code> route in an unauthenticated state. We’ll cover that <a id="_idIndexMarker475"/>in the Vitest tests in the next section.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Testing authentication with Vitest</h1>
<p>Now we drop <a id="_idIndexMarker476"/>down a level and get into specifics. Our tests will focus on the <code>/birthdays</code> route and how it is presented given authentication data.</p>
<p>The Auth.js library utilizes SvelteKit’s session mechanism for passing authentication information into components, so what we do is harness that via the <code>parent.session</code> object and the <code>locals.getSession</code> function. All we have to do is use test doubles to mimic the responses we want.</p>
<p>We start by defining a session factory that can be used to set up these session test doubles. Then we’ll update page load tests with new authentication functionality, and finally, we’ll end with updating the form action tests.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>Defining a session factory</h2>
<p>Here’s the <a id="_idIndexMarker477"/>definition of <code>src/factories/session.js</code>, which <a id="_idIndexMarker478"/>defines four exports that are used in the subsequent tests:</p>
<pre class="source-code">
import { vi } from 'vitest';
const validSession = { user: 'api ' };
export const loggedInSession = () =&gt; ({
  session: validSession
});
export const loggedOutSession = () =&gt; ({
  session: null
});
export const loggedInLocalsSession = () =&gt; ({
  getSession: vi.fn().mockResolvedValue(validSession)
});
export const loggedOutLocalsSession = () =&gt; ({
  getSession: vi.fn().mockResolvedValue(null)
});</pre>
<p>A <code>loggedInSession</code> object can be used as the <code>parent</code> property that’s passed to your page<a id="_idIndexMarker479"/> load. The Auth.js authentication<a id="_idIndexMarker480"/> process will run before your route is loaded and merged into this <code>parent</code> value. So, <code>loggedInSession</code> is just a dummy object: in the context of our tests, any value at all constitutes a valid, logged-in user.</p>
<p>The <code>loggedOutSession</code> object is similar: this time, a <code>null</code> value for <code>session</code> means that the user is not authenticated.</p>
<p>The <code>loggedInLocalsSession</code> and <code>loggedOutLocalsSession</code> values are to be used in place of SvelteKit’s <code>locals</code> property that is passed to your form action. This property is a collection of functions that the form action can make use of.</p>
<p>Next, we’ll see how to make use of these tests.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Updating existing tests for page load functions</h2>
<p>Now let’s<a id="_idIndexMarker481"/> update <a id="_idIndexMarker482"/>the page load function so that it has the necessary load function. We’ll also write a test to ensure that the page does <em class="italic">not</em> load any data if the user is not authenticated.</p>
<p>There’s a new import needed in <code>src/routes/birthdays/page.server.test.js</code>, shown in the following code block. These are the two factories that will be used to provide values for the <code>parent</code> property passed to the <code>load</code> function:</p>
<pre class="source-code">
import {
  loggedInSession,
  loggedOutSession,
} from 'src/factories/session.js';</pre>
<p>Then, the <code>describe</code> block is updated to create a <code>parent</code> variable that is defaulted to a logged-in user:</p>
<pre class="source-code">
describe('/birthdays - load', () =&gt; {
  <strong class="bold">const parent = vi.fn();</strong>
  <strong class="bold">beforeEach(() =&gt; {</strong>
    <strong class="bold">parent.mockResolvedValue(loggedInSession());</strong>
  <strong class="bold">});</strong>
  ...
});</pre>
<p>Each of the tests also needs to be updated to pass this new <code>parent</code> property into the <code>load</code> function:</p>
<pre class="source-code">
it('calls fetch with /api/birthdays', async () =&gt; {
  const fetch = vi.fn();
  fetch.mockResolvedValue(fetchResponseOk());
  const result = await load({ fetch<strong class="bold">, parent</strong> });
  expect(fetch).toBeCalledWith('/api/birthdays');
});</pre>
<p>You’ll also want to add a test to check that the endpoint won’t work without the correct authentication. In the following example, we override the default <code>parent</code> property with <code>loggedOutSession</code> and then test that the returned page has a <code>303</code> status, meaning the browser is being redirected. It also checks the page being redirected to is the <code>/</code><code>login</code> route:</p>
<pre class="source-code">
it('redirects if the request is not authorised', async () =&gt; {
  parent.mockResolvedValue(loggedOutSession());
  expect.hasAssertions();
  try {
    await load({ parent });
  } catch (error) {
    expect(error.status).toEqual(303);
    expect(error.location).toEqual('/login');
  }
});</pre>
<p>That<a id="_idIndexMarker483"/> completes <a id="_idIndexMarker484"/>the tests for the <code>load</code> function.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Updating existing tests for form actions</h2>
<p>For the form <a id="_idIndexMarker485"/>action<a id="_idIndexMarker486"/> tests, the <code>import</code> statement is updated with the remaining two factory functions:</p>
<pre class="source-code">
import {
  loggedInSession,
  loggedOutSession,
  <strong class="bold">loggedInLocalsSession,</strong>
  <strong class="bold">loggedOutLocalsSession</strong>
} from 'src/factories/session.js';</pre>
<p>Then, the <code>describe</code> block is updated to include a <code>locals</code> variable that is set within <code>beforeEach</code>. Note that this time the variable is defined as <code>let</code> because the <code>loggedInLocalsSession</code> factory is<a id="_idIndexMarker487"/> responsible<a id="_idIndexMarker488"/> for setting up the <code>vi.fn</code> spy function:</p>
<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  const fetch = vi.fn();
  let locals;
  beforeEach(() =&gt; {
    fetch.mockResolvedValue(fetchResponseOk());
    <strong class="bold">locals = loggedInLocalsSession();</strong>
  });
  ...
});</pre>
<p>Then <code>performFormAction</code> changes to include the <code>locals</code> property. Since this is the function that our tests call to invoke the form action, none of the tests themselves need to change:</p>
<pre class="source-code">
  const performFormAction = (formData) =&gt;
    actions.default({
      request: createFormDataRequest(formData),
      fetch<strong class="bold">,</strong>
      <strong class="bold">locals</strong>
    });</pre>
<p>Finally, we need a test to check what happens if the form is submitted when the user is not authenticated. In this case, we return a <code>300</code> status code rather than a redirect, but you could choose to go back to the previous form page, as you would with a validation error. That would help in the scenario where the user’s session has expired. Here’s the simpler version:</p>
<pre class="source-code">
describe('when not authorised', () =&gt; {
  beforeEach(() =&gt; {
    locals = loggedOutLocalsSession();
  });
  it('returns a failure', async () =&gt; {
    const result = await performFormAction({});
    expect(result.status).toEqual(300);
  });
});</pre>
<p>That completes <a id="_idIndexMarker489"/>the Vitest changes <a id="_idIndexMarker490"/>required to support our authentication implementation.</p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/>Summary</h1>
<p>This chapter briefly looked at the kinds of tests you’ll need for testing authentication.</p>
<p>Playwright end-to-end tests should check the login flows, both successful and unsuccessful. They should also make use of fake credentials where possible and ensure that any routes are accessible only by authenticated users who are logged in using a <code>test.beforeEach</code> call.</p>
<p>Vitest tests for authenticated routes work differently. They focus on the <code>session</code> object that SvelteKit returns: does it have a valid value or not?</p>
<p>While this covers the basics, most applications will have much more complex needs: for example, your application might have individual data stores for each user, not just one global data store such as our Birthdays application.</p>
<p>The Playwright website contains good documentation on how to test specific patterns, such as having multiple user roles interact within one test. That can be found at <a href="https://playwright.dev/docs/auth">https://playwright.dev/docs/auth</a>.</p>
<p>In the next chapter, we’ll look at testing Svelte Stores.</p>
</div>
</div></body></html>