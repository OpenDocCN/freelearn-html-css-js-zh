- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SportsStore: Orders and Validation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continue to build the SportsStore application by adding
    support for placing orders, which includes validating the form data provided by
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `sportsstore` project from *Chapter 17*. No changes are
    required for this chapter. Open a new command prompt, navigate to the `sportsstore`
    folder, and run the command shown in *Listing 18.1* to start the development tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.1: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open a new browser window, navigate to `http://localhost:5000`, and you will
    see the product catalog, as shown in *Figure 18.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_18_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.1: Running the application'
  prefs: []
  type: TYPE_NORMAL
- en: Handling orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data model for handling orders comes in two parts: the order and the user
    profile. The order describes the products that have been selected and provides
    the shipment status of the order. As noted in *Chapter 16*, the SportsStore application
    doesn’t extend to implementing the payment and fulfillment processes, which are
    typically handled by integration with separate platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, add a file named `customer_models.ts` to the `src/data` folder,
    with the content shown in *Listing 18.2*. This is a placeholder to represent customers
    with just enough functionality to start working on orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.2: The contents of the customer_models.ts file in the src/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To describe orders, add a file named `order_models.ts` to the `src/data` folder
    with the content shown in *Listing 18.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.3: The contents of the order_models.ts file in the src/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Order` interface describes a single order, with `ProductSelection` objects
    that represent the products the user has purchased, including the price at the
    time of purchase. The customer is represented by a `Customer` object and the addresses
    for shipping and billing are represented by `Address` objects. The details required
    for real online stores vary based on local laws and customs and the type of products
    being sold, but these interfaces are a reasonable approximation of the basic order
    characteristics that can be adapted as needed.
  prefs: []
  type: TYPE_NORMAL
- en: To describe the access to order data, add a file named `order_repository.ts`
    to the `src/data` folder, with the content shown in *Listing 18.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.4: The contents of the order_repository.ts file in the src/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `getOrder` method returns a single order, identified by its `id` value.
    The `getOrders` method retrieves all orders, with a parameter that allows shipped
    orders to be excluded from the results. The `storeOrder` method stores or updates
    an order.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the model classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am going to extend the existing Sequelize implementation of the `CatalogRepository`
    interface to implement the methods defined by the `OrderRepository` interface,
    which will allow a single database to store both catalog and order data. Add a
    file named `customer_models.ts` to the `src/data/orm/models` folder with the content
    shown in *Listing 18.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '**One versus Many Databases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be appealing from a design perspective to keep each category of data
    in its own database, so that catalog data, for example, is stored separately from
    order or user data. In practice, separate databases are difficult to manage, especially
    since most categories of data used by an application have some kind of relationship:
    orders need to refer to products, user accounts need to be associated with orders,
    and so on. Putting an application’s data in a single database makes it easier
    to use database features like transactions to ensure data integrity and simplifies
    correlating data in queries.'
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to use multiple databases, then you assume responsibility for
    managing transactions across databases, and ensuring that data remains consistent
    so that relationships between databases are consistent. There are tools available
    to help, such as distributed transaction managers, for example, but they can be
    complex and difficult to use.
  prefs: []
  type: TYPE_NORMAL
- en: My advice, from a purely practical perspective, is to use a single database
    for all an application’s data whenever possible. When a single database isn’t
    possible, such as when employee data is stored in a central HR database to which
    your application has read-only access, then you should pay close attention to
    how the relationships between data are managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.5: The contents of the customer_models.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CustomerModel` class implements the `Customer` interface to allow customer
    data to be stored by Sequelize. To tell Sequelize how to initialize the model
    class, add a file named `customer_helpers.ts` to the `src/data/orm/models` folder
    with the content shown in *Listing 18.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.6: The contents of the customer_helpers.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `initializeCustomerModels` function initializes the `CustomerModel` class
    and specifies the SQL datatype and configuration for each model property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the order models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the implementations of the interfaces that describe an order, add
    a file named `order_models.ts` to the `server/data/orm/models` folder, with the
    content shown in *Listing 18.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.7: The contents of the order_models.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The model classes use Sequelize features described in earlier examples and implement
    the `Order`, `ProductSelection`, and `Address` interfaces. As noted in earlier
    chapters, it can be a fiddly process to get the data model just right, and I find
    it easier to define the model classes and the helper code that initializes them
    at the same time. Add a file named `order_helpers.ts` to the `server/data/orm/models`
    folder with the content shown in *Listing 18.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.8: The contents of the order_helpers.ts file in the server/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to initializing the model classes, the `initializeOrderModels` function
    describes the relationship between them, which shapes the structure of the database
    tables that will be created to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in *Chapter 15*, Sequelize adds methods to model classes that allow
    related data to be managed. This is done using the same mixin technique I used
    to build up the repository in *Chapter 16*. One of the methods that will be created
    as a consequence of the one-to-many relationship between the `ProductSelectionModel`
    and `OrderModel` classes will be named `setSelections`, which is why I added this
    `declare` statement to the `OrderModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Sequelize` adds methods for all of the model properties, but this is the only
    one that I need for the SportsStore application. Therefore, it is the only one
    for which I added a `declare` statement. *Listing 18.9* invokes the `initializeCustomerModels`
    and `initializeOrderModels` functions so that the model classes are initialized
    alongside those used by the product catalog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.9: Initializing models in the index.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `initializeModels` function now initializes all three categories of model
    classes used by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create implementations of the methods defined by the `OrderRepository`
    interface. Add a file named `order_queries.ts` to the `src/data/orm` folder with
    the content shown in *Listing 18.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.10: The contents of the order_queries.ts file in the src/data/orm
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `AddOrderQueries` function returns a class that implements the `getOrder`
    and `getOrders` methods required by the `OrderRepository` interface. To keep queries
    consistent, I have used the types provided by Sequelize to describe the options
    used to query the database. Query options for `OrderModel` data are described
    using the `FindOptions<Attributes<OrderModel>>` type. The `queryConfig` object
    uses the `include` property to incorporate related `AddressModel` and `CustomerModel`
    data in the results and sets the `raw` and `nest` properties to specify the format
    of the results. To implement the remaining interface method, add a file named
    `order_storage.ts` to the `src/data/orm` folder with the content shown in *Listing
    18.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.11: The contents of the order_storage.ts file in the src/data/orm
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Sequelize` `upsert` method is used to update or create the order, customer,
    and address data. The product selections are stored using the `bulkCreate` method,
    which allows multiple rows to be stored in a single operation, and the `mixin`
    `setSelections` method is used to associate the stored product selections with
    the order. These operations are all performed within the same transaction to ensure
    data consistency. *Listing 18.12* uses the JavaScript `mixin` feature to incorporate
    the order functionality into the combined repository class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.12: Adding orders to the index.ts file in the src/data/orm folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `CatalogRepoImpl` class exported from this module implements the methods
    required by the `CatalogRepository` and `OrderRepository` interfaces. Even though
    a single class implements all repository methods, I prefer to present the functionality
    separately to the rest of the application, as shown in *Listing 18.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.13: Creating the repository in the index.ts file in the src/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript type annotations will ensure that each of the constants exported
    by this module will present only the methods defined by one of the repository
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the order flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the data model extends to describe and store order data, the next step
    is to create the workflow that allows orders to be created and stored.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of creating an order requires data from the user, which will be
    validated before it is used and stored. To install the validation package and
    its TypeScript descriptions, use a command prompt to run the commands shown in
    *Listing 18.14* in the `sportsstore` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.14: Installing the validation packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These packages are described in *Table 18.1* for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 18.1: The validation packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains validators for common data types. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains TypeScript descriptions of the validator API. |'
  prefs: []
  type: TYPE_TB
- en: To start the validation functionality, create the `src/data/validation` folder
    and add to it a file named `validation_types.ts` with the content shown in *Listing
    18.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.15: The contents of the validation_types.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `ValidationStatus` class represents the validation status of a single model
    property, which will allow rules to validate the data. The `ValidationRule` type
    describes a rule that receives a `ValidationStatus` object and validates the data
    value it defines. The validity of a value can be set using the `setInvalid` method
    defined by the `ValidationStatus` class, which latches so that once a value has
    been marked as `invalid`, it cannot be returned to the `valid` state by another
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidationRuleSet<T>` type describes the set of rules that are applied
    to a model class, `T`. Each property defined by the model class must have at least
    one validation rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidationResults<T>` type describes the validation results for a model
    object, with a `ValidationStatus` object defined for each model property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ValidationRuleSet<T>` and `ValidationResults<T>` types use the TypeScript
    utility types to describe how validation requirements and results are expressed
    for models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This incantation tells the TypeScript compiler that properties are required
    for each property defined by the type `T`, including optional properties, except
    for the property named `id`. TypeScript provides a range of useful utility types
    (described at [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html))
    that can be used to describe how one type relates to another and, in this case,
    the effect is that validation requirements and results are comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: Add a file named `validator.ts` to the `src/data/validation` folder with the
    contents shown in *Listing 18.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.16: The contents of the validator.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Validator<T>` class provides validation for the model type `T`. The constructor
    parameters are a `ValidationRuleSet<T>` value that provides the rules to apply
    and a `boolean` argument that specifies whether validation for a property will
    stop after the rule reports whether a value is invalid, or whether validation
    will continue to apply all of the rules.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate` method accepts a value to validate, applies the rules, and builds
    a `ValidationResult<T>` object that describes the outcome. *Listing 18.16* includes
    a utility function named `isValid` that checks the validation results produced
    for a value and determines whether all of the properties are valid. The `getData`
    method extracts the data from the validation results, which will be used to ensure
    that the application only uses properties for which validation rules have been
    defined and values that have passed validation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining validation rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the basic validation rules for properties, add a file named `basic_rules.ts`
    to the `src/data/validation` folder with the content shown in *Listing 18.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.17: The contents of the basic_rules.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `minLength`, `email`, and `required` functions ensure that a value has
    a minimum length, is a correctly formatted email address, and that a value isn’t
    undefined or an empty string. All three functions use the features provided by
    the `validator` package. The `no_op` function doesn’t perform any validation and
    is a consequence of requiring validation rules for every property defined by a
    model class except the `id` property: some properties won’t require validation
    but must be included in the validation configuration, and the `no_op` (short for
    *no operation*) function can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: To describe the validation requirements for the data the user will provide for
    orders, add a file named `order_rules.ts` to the `src/data/validation` folder
    with the content shown in *Listing 18.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.18: The contents of the order_rules.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18.18* defines the validation rules for the `Customer` and `Address`
    model types, which will be combined with the contents of the user’s cart to create
    an order. Notice that the `zip` property for addresses uses the `no_op` rule,
    which tells the validator that this property is optional and has no specific validation
    requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a more comprehensive way to define validation than the approach I used
    in *Part 2* of this book because it uses TypeScript to ensure that validation
    requirements are specified for every property defined by a type, except for the
    `id` property, which I have omitted because I generally want to let the database
    figure out what IDs are required for objects.
  prefs: []
  type: TYPE_NORMAL
- en: When an id value is provided by the client, I will validate it separately from
    the rest of the data. To complete the validation feature, add a file named `index.ts`
    to the `src/data/validation` folder with the content shown in *Listing 18.19*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.19: The contents of the index.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This file simply exports the contents of the other files in the validation folder
    so the contents can be consumed more easily by the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTTP handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to define the three HTTP handlers that will be used to complete
    the order process: a `GET` handler that renders an HTML form for collecting the
    user’s details, a `POST` handler that receives and validates the user’s details,
    and a `GET` handler that displays a summary message once the order has been completed.
    Add a file named `orders.ts` to the `src/routes` folder with the content shown
    in *Listing 18.20*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.20: The contents of the orders.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `declare` statement tells TypeScript that the session will be used to store
    an object using the name `orderData`, with `customer` and `address` properties
    whose values are validation results.
  prefs: []
  type: TYPE_NORMAL
- en: The first handler accepts `GET` requests sent to the `/checkout` URL and responds
    by rendering a template named `order_details`, passing the `customer` and `address`
    data stored in the session as context data.
  prefs: []
  type: TYPE_NORMAL
- en: This template renders the HTML form, which will be empty the first time the
    user sends a `GET` request because no customer or address data has been stored
    in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second handler accepts `POST` requests to the `/checkout` URL, where the
    customer and address data is read from the request and validated, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `through` assignment used in this statement ensures that the validation
    results are stored in the session and stored in a local constant named `data`,
    just for ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: If the data is invalid, a redirection to the `/checkout` URL renders the form
    but, this time, there will be validation data for the template to display to give
    the user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is valid, then an order is created by calling a function called
    `createAndStoreOrder`, which is defined in *Listing 18.21*, and combines the customer
    and address data with the contents of the user’s cart to create and store an order.
    The data passed to the `createAndStoreOrder` function is extracted from the validation
    results, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that only the properties defined by the model types are used, which
    is one of the reasons why the validation types defined earlier in the chapter
    require validation information for every model property. Once the order is stored,
    a redirection to the third handler is performed, which includes the ID of the
    order in the URL, and which can be used to display a confirmation message to the
    user. The `cart`, customer, and address data are removed from the session so that
    the user can start shopping afresh.
  prefs: []
  type: TYPE_NORMAL
- en: To define the function that combines the customer, address, and cart data and
    stores the order, add a file named `order_helpers.ts` to the `src/routes` folder
    with the content shown in *Listing 18.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.21: The contents of the order_helpers.ts file in the src/routes
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Example applications usually contrive to avoid the messy reality of merging
    and formatting data, but it is something that should be expected in every project.
    In this case, the cart data has to be matched up with product prices, which is
    an awkward process that requires awkward code.
  prefs: []
  type: TYPE_NORMAL
- en: There is often an “Oh, no!” moment when reaching the point where you realize
    that the data you have isn’t the data you need, and that additional queries and
    transforms are required. It can be tempting to go back and smooth out the rough
    edges in the data model, but my advice is not to do that because it just breaks
    up the problem so that none of the data models exactly suit their purpose, which
    leaves little bits of awkwardness all over the place. Instead, my preference is
    to define each model so that it suits the part of the application that it serves
    and accept that there will be crunch points where data from one part of the application
    is bent into the shape required by another part. *Listing 18.22* enables the routes
    required for orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.22: Enabling routes in the index.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Creating the templates and helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New template helpers are required to render the order form. Add a file named
    `order_helpers.ts` to the `src/helpers` folder, with the content shown in *Listing
    18.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.23: The contents of the order_helpers.ts file in the src/helpers
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of each helper will be explained as they are used, but they all
    manipulate data values so they can be included in the template output. *Listing
    18.24* enables the new helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.24: Adding helpers to the index.ts file in the src/helpers folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the simplest templates, add a file named `order_complete.handlebars`
    to the `templates` folder with the content shown in *Listing 18.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.25: The contents of the order_complete.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This template displays a simple confirmation message once an order has been
    placed, which includes the order ID value. The remaining templates relate to the
    form used to collect the customer and address data and present validation feedback.
    Add a file named `validation_messages.handlebars` to the `templates` folder, with
    the content shown in *Listing 18.26*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.26: The contents of the validation_messages.handlebars file in the
    templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The template will receive an array of strings that are displayed using the `each`
    expression, referring to the current string value with `this`. To create the form
    elements for the user’s name and email address, which are required for the `Customer`
    data, add a file named `order_details_customer.handlebars` to the `templates`
    folder with the content shown in *Listing 18.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.27: The contents of the order_details_customer.handlebars in the
    templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The template duplicates the same set of elements for each value and relies on
    a combination of template engine features and helpers that require explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `with` helper is used to change the context, which can simplify
    nested expressions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with` helper is used to change the context to the `order.customer.name`
    value, so that the `value` expression is evaluated as `order.customer.name.value`.
    The `with` helper won’t render content if its expression is undefined, which presents
    a problem the first time that the template is rendered because the user’s session
    doesn’t contain this value until after the first time the form is evaluated. To
    solve this, the `get` helper defined in *Listing 18.23* is used, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses denote a subexpression, which the template engine evaluates
    to obtain the argument for the `with` helper. The `get` helper returns an empty
    object if a value is not defined, which ensures the content contained by the `with`
    helper is always rendered.
  prefs: []
  type: TYPE_NORMAL
- en: To create the form elements for the user’s address, add a file named `order_details_address.handlebars`
    to the `templates` folder, with the content shown in *Listing 18.28*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.28: The contents of order_details_address.handlebars in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the previous template, which repeated the same content for each data
    property, this template generates elements programmatically, using the values
    in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `each` helper repeats sections of content but doesn’t have support
    for literal arrays. This shortcoming is addressed by the `toArray` helper, which
    accepts a series of arguments and combines them into an array that can be processed
    by the `each` helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `with` helper is used to change the context to the data values
    required for each of the form fields. The `getValue` helper is used to produce
    the value for the `with` helper, which is done by looking up a property on a source
    object. The `with` helper changes the context, but it is still possible to get
    values from the original data by using a navigation expression, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `lower` helper is used to set the name of the `input` element, which is
    structured using square brackets so that related values are grouped when read
    by the server from the HTTP request. The overall effect is to create elements
    whose names are `address[street]`, `address[city]`, `address[state]`, and `address[zip]`,
    which will be passed into a JavaScript object named `address` with `street`, `city`,
    `state`, and `zip` properties.
  prefs: []
  type: TYPE_NORMAL
- en: To combine the customer and address templates, create a file named `order_details.handlebars`
    in the `templates` folder, with the content shown in *Listing 18.29*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.29: The contents of the order_details.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `form` element sends a `POST` request to the `/checkout` URL when the user
    clicks the **Place Order** button. There is also a link styled to appear as a
    button that directs the user back to the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000`, add an item to the cart, and
    click the **Checkout** button, which will lead the application to present the
    order details form. Click the **Place Order** button to see the validation errors.
    To complete the order, fill out the form and click the **Place Order** button.
    The sequence is shown in *Figure 18.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_18_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: Creating an order'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the return URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the catalog, the user’s preferences for category, page, and page size are
    preserved using a query string, but these are lost when checking out when data
    is preserved in the session instead. I don’t care too much about preserving the
    category and page, because they are temporary choices, but I would like to preserve
    the page size so that it is used when the user completes an order or cancels the
    order process.
  prefs: []
  type: TYPE_NORMAL
- en: I could store all of the user’s choices in a session or use the query string
    throughout the order process, but I want to preserve these separate approaches
    because they demonstrate different ways of solving similar problems. With this
    in mind, I am going to store the user’s preferred page size in the session at
    the start of the order process and use the value when generating the URLs that
    will return the user to the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to store the page size as session data when the user transitions
    from the cart to the ordering process, as shown in *Listing 18.30*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.30: Storing page size in the orders.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18.31* adds the return URL to the target of the anchor element that
    the user clicks to leave the cart summary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.31: Adding the URL to the cart.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18.32* adds the return URL to the **Back** button on the **Order Details**
    page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.32: Adding the URL in the order_details.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to add the URL to the button the user clicks to return to
    the catalog once an order has been placed, as shown in *Listing 18.33*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 18.33: Adding the URL to the order_complete.handlebars file in the
    templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000` and change the page size to
    **6** items. Add items to the cart and complete the order. Click the **Return**
    **to Store** button displayed with the order summary and the page size will be
    preserved when the catalog is displayed, as shown in *Figure 18.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_18_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: Fixing the return URL'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I continued developing the SportsStore application by adding
    support for placing orders.
  prefs: []
  type: TYPE_NORMAL
- en: The data model for orders is presented through a separate repository interface
    but is implemented using the `ORM mixin` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order data is stored in the same database as the catalog, which simplifies
    data consistency and makes it easier to use transactions for updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data provided by the user is validated before it is stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation system relies on TypeScript to ensure that rules are defined
    for all data model properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The session feature is used to store the user’s pagination preferences during
    the checkout process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will add support for letting users identify themselves
    using their Google accounts, which is done using the `OAuth` protocol.
  prefs: []
  type: TYPE_NORMAL
