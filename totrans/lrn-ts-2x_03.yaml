- en: Working with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml), *Introducing TypeScript*,
    we learned the basics of functions. Functions are the fundamental building blocks
    of any application in TypeScript, and they are powerful enough to deserve the
    dedication of an entire chapter to explore their potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to work with functions in depth.
    The chapter is divided into two main sections. The first section starts with a
    quick recap of some basic concepts, and then moves on to some less commonly known features
    of functions and their use cases. The first section covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations and function expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with optional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with default parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with REST parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized overloading signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately invoked functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag functions and tagged templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second section focuses on TypeScript''s asynchronous programming capabilities
    and includes the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous functions (`async` and `await`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with functions in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on the declaration and use of functions, parameters, and
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations and function expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we introduced the possibility of declaring functions with
    (named functions) or without (unnamed or anonymous functions) explicitly indicating
    their name, but we didn't mention that we were also using two different types
    of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the named function `greetNamed` is a **function declaration**,
    while `greetUnnamed` is a **function expression**. For now, please ignore the
    first two lines, which contain two `console.log` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We might think that the preceding functions are identical, but they behave differently.
    The JavaScript interpreter can evaluate a function declaration as it is being
    parsed. On the other hand, the function expression is part of an assignment and
    will not be evaluated until the assignment has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The main cause of the different behavior of these functions is a process known
    as **variable hoisting**. We will learn more about the variable hoisting process
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If we compile the preceding TypeScript code snippet into JavaScript and try
    to execute it in a web browser, we will observe that the first `console.log` call
    works. This is because JavaScript knows about the declaration function and can
    parse it before the program is executed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the second alert statement will throw an exception, which indicates
    that `greetUnnamed` is not a function. The exception is thrown because the `greetUnnamed`
    assignment must be completed before the function can be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that it is possible to explicitly declare the type of an element
    in our application by using optional type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, we have specified the type of the parameter name
    (string) and its return type (string). Sometimes, we will need to not just specify
    the types of the function elements, but the function itself. Let''s look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared the `greetUnnamed` variable and its
    type. The `greetUnnamed `type is a function type that takes a string variable
    called `name` as its only parameter and returns a string after being invoked.
    After declaring the variable, a function, whose type must be equal to the variable
    type, is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also declare the `greetUnnamed` type and assign a function to it in
    the same line rather than declaring it in two separate lines as we did in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous example, the preceding code snippet also declares
    a variable, `greetUnnamed`, and its type. The `greetUnnamed `type is a function
    type that takes a string variable called `name` as its only parameter and will
    return a string after being invoked. We will assign a function to this variable
    in the same line in which it is declared. The type of the assigned function must
    match the type of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have declared the type of the `greetUnnamed` variable
    and then assigned a function as its value. The type of the function can be inferred
    from the assigned function, and for this reason, it is unnecessary to add a redundant
    type annotation. We have done this to help you understand this section, but it
    is important to mention that adding redundant type annotations can make our code
    harder to read, and it is considered bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas in function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trailing commas are the commas that are used after the last argument of a function.
    Using a comma after the last parameter of a function can be useful because it
    is very common for programmers to forget to add a comma when they modify an existing
    function by adding additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function only takes one parameter and doesn''t use
    trailing commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After some time, we might be required to add a parameter to the preceding function.
    A common mistake is to declare the new parameter and forget to add a comma after
    the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a trailing comma in the first version of the function could have helped
    us to prevent this common mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a trailing comma eliminates the possibility of forgetting the comma when
    adding a new argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript will throw an error if we forget a comma, so trailing commas are
    not needed as much as they are when working with JavaScript. Trailing commas are
    optional, but using them is considered a good practice by many JavaScript and
    TypeScript engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike JavaScript, the TypeScript compiler will throw an error if we attempt
    to invoke a function without providing the exact number and types of parameters
    that its signature declares. Let''s look at a code sample to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is called `add` and will take three numbers as parameters,
    named `foo`, `bar`, and `foobar`. If we attempt to invoke this function without
    providing exactly three numbers, we will get a compilation error indicating that
    the supplied parameters do not match the function''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are scenarios in which we might want to be able to call the function without
    providing all its arguments. TypeScript features optional parameters in functions
    to help us to increase the flexibility of our functions and overcome such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can indicate to the TypeScript compiler that we want a function''s parameter
    to be optional by appending the `?` character to its name. Let''s update the previous
    function to transform the required `foobar` parameter into an optional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we have changed the `foobar` parameter name to `foobar?`, and how
    we are checking the type of `foobar` inside the function to identify whether the
    parameter was supplied as an argument to the function or not. After implementing
    these changes, the TypeScript compiler will allow us to invoke the function without
    errors when we supply two or three arguments to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the optional parameters must always be located
    after the required parameters in the function's parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function has some optional parameters, we must check whether an argument
    has been passed to the function (just like we did in the previous example) to
    prevent potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some scenarios where it would be more useful to provide a default
    value for a parameter when it is not supplied than making it an optional parameter.
    Let''s rewrite the `add` function (from the previous section) using the inline
    `if` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing wrong with the preceding function, but we can improve its
    readability by providing a default value for the `foobar` parameter instead of
    using an optional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate that a function parameter is optional, we need to provide a default
    value using the `=` operator when declaring the function''s signature. After compiling
    the preceding code examples, the TypeScript compiler will generate an `if` structure
    in the JavaScript output to set a default value for the `foobar` parameter if
    it is not passed as an argument to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is great because the TypeScript compiler generated the code necessary for
    us to prevent potential runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `void 0` parameter is used by the TypeScript compiler to check whether
    a variable is undefined. While most developers use the undefined variable to perform
    this kind of check, most compilers use `void 0` because it will always evaluate
    as undefined. Checking against an undefined variable is less secure because its
    value could have been modified, as demonstrated by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function test() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    var undefined = 2; // 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    console.log(undefined === 2); // true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: Just like optional parameters, default parameters must always be located after
    any required parameters in the function's parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with REST parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to use optional and default parameters to increase the
    number of ways that we can invoke a function. Let''s return one more time to the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have learned how to invoke the `add` function with two or three parameters,
    but what if we wanted to allow other developers to pass four or five parameters
    to our function? We would have to add two extra default or optional parameters.
    And what if we wanted to allow them to pass as many parameters as they need? The
    solution to this possible scenario is the use of REST parameters. The REST parameter
    syntax allows us to represent an indefinite number of arguments as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we have replaced the function
    parameters `foo`, `bar`, and `foobar` with just one parameter named `foo`. Note
    that the name of the parameter `foo` is preceded by an ellipsis (a set of three
    periods—not the actual ellipsis character). A REST parameter must be of an array
    type or we will get a compilation error. We can now invoke the `add` function
    with as many parameters as we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Although there is no specific limit to the theoretical maximum number of arguments
    that a function can take, there are, of course, practical limits. These limits
    are entirely implementation-dependent and, most likely, will also depend on exactly how
    we are calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions have a built-in object called the `arguments` object. This
    object is available as a local variable named `arguments`. The `arguments` variable
    contains an object like an array that contains the arguments used when the function
    was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` object exposes some of the methods and properties provided by
    a standard array, but not all of them. Refer to the documentation at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)
    to learn more about its peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the JavaScript output, we will notice that TypeScript iterates
    the `arguments` object to add the values to the `foo` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can argue that this is an extra, unnecessary iteration over the function''s
    parameters. Even though it is hard to imagine this extra iteration becoming a
    performance issue, if you think that this could be a problem for the performance
    of your application, you may want to consider avoiding the use of REST parameters
    and use an array as the only parameter of the function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes an array of numbers as its only parameter. The
    invocation API will be a little bit different from the REST parameters, but we
    will effectively avoid the extra iteration over the function''s argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function overloading, or method overloading, is the ability to create multiple
    methods with the same name and a different number of parameters or types. In TypeScript,
    we can overload a function by specifying all function signatures (known as the **overload
    signatures**) of a function, followed by a signature (known as the **implementation
    signature**). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding example, we have overloaded the function test
    three times by adding a signature that takes a string as its only parameter, another
    function that takes a number, and a final signature that takes a boolean as its
    unique parameter. It is important to note that all function signatures must be
    compatible; so if, for example, one of the signatures tries to return a number
    while another tries to return a string, we will get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The implementation signature must be compatible with all the overloaded signatures,
    always be the last in the list, and take the `any` type or a union type as the
    type of its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking the function providing arguments that don''t match any of the types
    that are declared by the overload signatures will lead us to a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Specialized overloading signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a specialized signature to create multiple methods with the same
    name and number of parameters, but a different return type. To create a specialized
    signature, we must indicate the type of function parameter using a string. The
    string literal is used to identify which of the function overloads is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared three **specialized overloaded signatures**
    and one **nonspecialized signature** for the function named `createElement`.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a specialized signature in an object, it must be assignable
    to at least one nonspecialized signature in the same object. This can be observed
    in the preceding example, as the `createElement` property belongs to a type that
    contains three specialized signatures, all of which are assignable to the nonspecialized
    signature in the type.
  prefs: []
  type: TYPE_NORMAL
- en: When writing overloaded declarations, we must list the nonspecialized signature
    last.
  prefs: []
  type: TYPE_NORMAL
- en: Function scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low-level languages, such as C, have low-level memory management features. In
    programming languages with a higher level of abstraction, such as TypeScript,
    values are allocated when variables are created and automatically cleared from
    memory when they are not used anymore. The process that cleans the memory is known
    as **garbage collection** and is performed by the JavaScript runtime garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector does a great job, but it is a mistake to assume that it
    will always prevent us from facing a memory leak. The garbage collector will clear
    a variable from the memory whenever the variable is out of the scope. It is important
    to understand how the TypeScript scope works, so we will now look at the life
    cycle of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages use the structure of the program source code to determine
    what variables we are referring to (**lexical scoping**), while others use the
    runtime state of the program stack to determine what variable we are referring
    to (**dynamic scoping**). The majority of modern programming languages use lexical
    scoping (including TypeScript). Lexical scoping tends to be dramatically easier
    to understand for both humans and analysis tools than dynamic scoping.
  prefs: []
  type: TYPE_NORMAL
- en: 'While in most lexical-scoped programming languages, variables are scoped to
    a block (a section of code delimited by curly braces `{}`), in TypeScript (and
    JavaScript), variables are scoped to a function, as demonstrated by the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function named `foo` contains an `if` structure. We have declared
    a numeric variable named `bar` inside the `if` structure, and later, we have attempted
    to show the value of the `bar` variable using the `log` function.
  prefs: []
  type: TYPE_NORMAL
- en: We might think that the preceding code sample would throw an error in the fifth
    line because the `var` variable should be out of the scope when the `log` function
    is invoked. However, if we invoke the `foo` function, the `log` function will
    be able to display the `bar` variable without errors because all the variables
    inside a function will be in the scope of the entire function body, even if they
    are inside another block of code (except a function block).
  prefs: []
  type: TYPE_NORMAL
- en: This might seem confusing, but it is easy to understand once we know that at
    runtime, all the variable declarations are moved to the top of a function before
    the function is executed. This behavior is known as **hoisting**.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is compiled to JavaScript and then executed—this means that a TypeScript
    application is a JavaScript application at runtime, and for this reason, when
    we refer to the TypeScript runtime, we are talking about the JavaScript runtime.
    We will learn in depth about the runtime in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the preceding code snippet is executed, the runtime will move the declaration
    of the `bar `variable to the top of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This explains why it is possible to use a variable before it is declared. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have declared a `foo `function, and in its
    body, we have assigned the value `0` to a variable named `bar`. At this point,
    the variable has not been declared. In the second line, we are declaring the variable
    `bar` and its type. In the last line, we are displaying the value of `bar` using
    the alert function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because declaring a variable anywhere inside a function (except another function)
    is equivalent to declaring it at the top of the function, the `foo` function is
    transformed into the following at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because developers with a background in programming languages with block scope,
    such as Java or C#, are not used to the function scope, it is one of the most
    criticized characteristics of JavaScript. The people in charge of the development
    of the ECMAScript 6 specification are aware of this, and as a result, they have
    introduced the keywords `let` and `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `let` keyword allows us to set the scope of a variable to a block (`if`,
    `while`, `for`, and so on) rather than a function. We can update the first example
    in this section to showcase how `let` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `bar` variable is now declared using the `let` keyword, and as a result,
    it is only accessible inside the `if` block. The variable is not hoisted to the
    top of the `foo` function and cannot be accessed by the `alert` function outside
    the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'While variables defined with `const` follow the same scope rules as variables
    declared with `let`, they can''t be reassigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to compile the preceding code snippet, we will get an error because
    the `bar` variable is not accessible outside the `if` statement (just like when
    we used the `let` keyword), and a new error will occur when we try to assign a
    new value to the `bar` variable. The second error occurs because it is not possible
    to assign a new value to a constant variable once the variable has already been
    initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared with the `const` keyword cannot be reassigned, but are not
    immutable. When we say that a variable is immutable, we means that it cannot be
    modified. We will learn more about immutability in [Chapter 7](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml),
    *Functional Programming with TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately invoked functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **immediately invoked function expression** (**IIFE**) is a design pattern
    that produces a lexical scope using function scoping. An IIFE can be used to avoid
    variable hoisting from within blocks, or to prevent us from polluting the global
    scope—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have wrapped the declaration of a variable (`foo`)
    with an IIFE. The `foo` variable is scoped to the IIFE function and is not available
    in the global scope, which explains the error that is thrown when we try to access
    it on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: The `bar` variable is a global. Therefore, it can be accessed from both the
    inside and the outside of the IIFE function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a variable to the IIFE to have better control over the creation
    of variables outside its scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, IIFE can help us to simultaneously allow public access to methods
    while retaining privacy for variables defined within the function. Let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a class named `Counter`, which has a private numeric attribute
    named `_i`. The class also has methods to get and set the value of the private
    `_i `property.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, TypeScript and JavaScript developers usually name private variables
    with names preceded by an underscore (`_`).
  prefs: []
  type: TYPE_NORMAL
- en: We have also created an instance of the `Counter` class and invoked the `set`,
    `get`, and `increment` methods to observe that everything is working as expected.
    If we attempt to access the `_i` property in an instance of `Counter`, we will
    get an error because the variable is `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile the preceding TypeScript code (only the class definition) and
    examine the generated JavaScript code, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This generated JavaScript code will work perfectly in most scenarios, but if
    we execute it in a browser and try to create an instance of `Counter` and access
    its `_i `property, we will not get any errors because TypeScript will not generate
    runtime private properties for us. Sometimes we will need to write our classes
    in such a way that some properties are private at runtime—for example, if we release
    a library that will be used by JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use IIFE to simultaneously allow public access to methods while
    retaining privacy for variables defined within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, everything is almost identical to the TypeScript's
    generated JavaScript, except now the variable `_i` is an object in the `Counter`
    closure instead of a property of the `Counter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure *remembers* the environment (variables
    in the scope) in which it was created. We will discover more about closures in
    [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the generated JavaScript output in a browser and try to invoke the
    `_i` property directly, we will notice that the property is now private at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, we will need to have precise control over scope and closures,
    and our code will end up looking much more like JavaScript. As long as we write
    our application components (classes, modules, and so on) to be consumed by other
    TypeScript components, we will rarely have to worry about implementing runtime
    private properties. We will look in depth at the TypeScript runtime in [Chapter
    6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: Tag functions and tagged templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use template strings such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can use a template string to create a special kind of function known as a
    **tag function**.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a tag function to extend or modify the standard behavior of template
    strings. When we apply a tag function to a template string, the template string
    becomes a tagged template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a tag function named `htmlEscape`. To use a tag function,
    we must use the name of the function followed by a template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A tag template must return a string and take the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A `TemplateStringsArray` that contains all the static literals in the template
    string (`<h1>` and `</h1>` in the preceding example) is passed as the first argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TemplateStringsArray` type is declared by the `lib.d.ts` file. We will
    learn more about the `lib.d.ts` file in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: A REST parameter is passed as the second parameter. The REST parameter contains
    all the values in the template string (`name` and `surname`, in the preceding
    example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature of a tag function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `htmlEscape` tag function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The template string contains values and literals. The `htmlEscape` function
    iterates through them and ensures that the HTML code is escaped in the values
    to avoid possible code injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of using a tagged function is that it allows us to create custom
    template string processors.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to work with functions, we will explore how we can
    use them, together with some native APIs, to write asynchronous applications.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, functions can be passed as arguments to another function. Functions
    can also be returned by another function. A function passed to another as an argument
    is known as a **callback**. Functions that accept functions as parameters (callbacks)
    or return functions are known as **higher-order functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks are usually anonymous functions. They can be declared before they
    are passed to the higher-order function, as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, callbacks are declared inline, at the same point at which they are
    passed to the higher-order function, as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, we can declare a function using a `function` expression or an
    arrow function. An arrow function has a shorter syntax than a function expression,
    and lexically binds the value of the `this` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` operator behaves a little differently in TypeScript and JavaScript
    compared to other popular programming languages. When we define a class in TypeScript,
    we can use the `this` operator to refer to the class. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a `Person` class that contains a property of a string type called
    `name`. The class has a constructor and a `greet `method. We have created an instance
    named `person` and invoked the `greet` method, which uses the `this` operator internally to
    access the `_name `property. Inside the `greet` method, the `this` operator points
    to the object that encloses the `greet` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be careful when using the `this` operator, because in some scenarios
    it can point to the wrong value. Let''s add an extra method to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the `greetDelay` method, we perform an almost identical operation to the
    one performed by the `greet` method. This time, the function takes a parameter
    named `time`, which is used to delay the `greet` message.
  prefs: []
  type: TYPE_NORMAL
- en: To delay a message, we use the `setTimeout` function and a callback. As soon
    as we define an anonymous function (the callback), the `this` keyword changes
    its value and starts pointing to the anonymous function, which explains why the
    TypeScript compiler will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, an arrow function expression lexically binds the value of the
    `this` operator. This means that it `allows` us to add a function without altering
    the value of the `this` operator. Let''s replace the function expression from
    the previous example with an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By using an arrow function, we can ensure that the `this` operator still points
    to the `Person` instance and not to the `setTimeout` callback. If we execute the
    `greetDelay` function, the name property will be displayed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is generated by the TypeScript compiler. When compiling
    an arrow function, the TypeScript compiler will generate an alias for the `this`
    operator named `_this`. The alias is used to ensure that the `this` operator points
    to the right object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We will look at the `this` operator in depth in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that callbacks and higher-order functions are two powerful and
    flexible JavaScript and TypeScript features. However, the use of callbacks can
    lead to a maintainability issue known as **callback hell**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to write an example to showcase callback hell. We are going
    to write three functions with the same behavior, named `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions simulate an asynchronous operation by using the `setTimeout`
    function. Each function takes a success callback, which is invoked if the operation
    is successful, and an error callback, which is invoked if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, asynchronous operations usually involve some interaction
    with hardware (for example, filesystems, networks, and so on). The interactions
    are known as **input/output** (**I**/**O**) operations. I/O operations can fail
    for many different reasons (for example, we get an error when we try to interact
    with the filesystem to save a new file and there is not enough space available
    on the hard disk).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functions generate a random number and throw an error if the number
    is lower than 25; we do this to simulate potential I/O errors.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functions add the random number to an array that is passed as
    an argument to each of the functions. If no errors take place, the result of the
    final function (`doSomethingMoreAsync`) should be an array with three random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the three functions have been declared, we can try to invoke them
    in order. We are going to use callbacks to ensure that `doSomethingMoreAsync`
    is invoked after `do``SomethingElseAsync`, and `doSomethingElseAsync` is invoked
    after `do``SomethingAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example used a few nesting callbacks. The use of these kinds
    of nested callbacks is known as **callback hell** because they can lead to the
    following maintainability issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the code harder to follow and understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the code harder to maintain (refactor, reuse, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making exception handling more difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After seeing how the use of callbacks can lead to some maintainability problems,
    we are now going to learn about promises and how they can be used to write better
    asynchronous code. The core idea behind promises is that a promise represents
    the result of an asynchronous operation. A promise must be in one of the following
    three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: The initial state of a promise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled****/resolved**: The state of a promise representing a successful
    operation. The terms "fulfilled" and "resolved" are both commonly used to refer
    to this state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: The state of a promise representing a failed operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a promise is fulfilled or rejected, its state can never change again.
    Let''s look at the basic syntax of a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A `try...catch` statement is used here to showcase how we can explicitly fulfill
    or reject a promise. The `try...catch` statement is not needed for a `Promise`
    function because when an error is thrown in a promise callback, the promise will
    automatically be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet declares a function named `foo` that returns a promise.
    The promise contains a method named `then`, which accepts a function to be invoked
    when the promise is fulfilled. Promises also provide a method named `catch`, which
    is invoked when a promise is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Promises will not be recognized by the TypeScript compiler if we are targeting
    ES5, because the promises API is part of ES6\. We can solve this by enabling the
    `es2015.promise` type using the `lib` option in the `tsconfig``.json` file. Note
    that enabling this option will disable some types that are included by default
    and therefore break some of the examples. You will be able to solve the problems
    by including the `dom` and `es5` types, as well as by using the `lib` option in
    the `tsconfig``.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"lib": [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.promise",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "dom",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es5",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.generator", // new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.iterable" // new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`]`'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to rewrite the `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync` functions that we wrote during the callback hell example,
    using promises instead of callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can chain the promises that are returned by each of the preceding functions
    using the promises API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a little bit better than the one used in the callback
    example because we only needed to declare one exception handler instead of three
    exception handlers. This is possible because errors are propagated through the
    chain of promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example has introduced some improvements. However, the promises
    API allows us to chain promises in a much less verbose way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is much easier to read and follow than the one used during
    the callback examples, but this is not the only reason to prefer promises over
    callbacks. Using promises also gives us better control over the execution flow
    of operations. Let's look at a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The promises API includes a method named `all`, which allows us to execute
    a series of promises in parallel and get all the results of each of the promises
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The promises API also includes a method named `race`, which allows us to execute
    a series of promises in parallel and get the result of the first promise resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use many different types of asynchronous flow control when working with
    promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrent**: The tasks are executed in parallel (like in the `Promise.all`
    example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race**: The tasks are executed in parallel, and only the result of the fastest
    promise is returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: A group of tasks is executed in sequence, but the preceding tasks
    do not pass arguments to the next task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waterfall**: A group of tasks is executed in sequence, and each task passes
    arguments to the next task (like in the example that preceded the `Promise.all`
    and `Promise.race` examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This is any combination of the preceding concurrent, series,
    and waterfall approaches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariant checking in callback parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript 2.4 changed the way the type system behaves internally to improve
    the error detection in nested callbacks and promises:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript's checking of callback parameters is now covariant concerning immediate
    signature checks. Previously it was bivariant, which could sometimes let incorrect
    types through. Basically, this means that callback parameters and classes that
    contain callbacks are checked more carefully, so TypeScript will require stricter
    types in this release. This is particularly true of Promises and Observables due
    to the way in which their APIs are specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript versions before 2.4, the following example was considered valid,
    and no errors were thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript versions following the 2.4 release, we need to add the complete
    signature of `nestedCallback` to solve this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the internal change in the TypeScript type system, the following
    error is also detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Before TypeScript 2.4, the preceding promise would have been inferred as `Promise<{}>`
    because we forgot to add the generic `<number>` argument when we created an instance
    of the `Promise` class. The `error` string would then have been considered a valid
    instance of `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a clear example of why it is recommended that you upgrade TypeScript
    regularly. Each new version of TypeScript introduces new features that are able
    to detect new errors for us.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we invoke a function in TypeScript, we can assume that once the function
    starts running, it will always run to completion before any other code can run.
    However, a new kind of function that may be paused in the middle of execution—one
    or many times—and resumed later, allowing other code to run during these paused
    periods, has recently been added to the ECMAScript specification. These new kinds
    of functions are known as **generators**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator represents a sequence of values. The interface of a `generator`
    object is just an **iterator**. An iterator implements the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `next()`function can be invoked until it runs out of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a generator by using the `function` keyword followed by an asterisk
    (`*`). The `yield` keyword is used to stop the execution of the function and return
    a value. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that some additional types are required by generators if you are targeting
    ES5\. You will need to add `es2015.generator` and `es2015.iterable` to your `tsconfig.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), **Automating
    Your Development Workflow**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the preceding iterator has five steps. The first time we call
    `next`, the function will be executed until it reaches the first `yield` statement,
    and then it will return the value `1` and stop the execution of the function until
    we invoke the generator''s `next` method again. As we can see, we are now able
    to stop the function''s execution at a given point. This allows us to write infinite
    loops without causing a stack overflow, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The generator will open possibilities for synchronicity, as we can call the
    generator's `next` method after an asynchronous event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions – async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous functions** are a TypeScript feature that arrived with the TypeScript
    1.6 release. Developers can use the `await` keyword to wait for the function results
    without blocking the normal execution of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous functions helps to increase the readability of a piece of
    code when compared with the use of promises or callbacks, but technically, we
    can achieve the same features using both promises and synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a basic `async`/`await` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declares a promise named `p`. This promise is the
    piece of code whose execution we will wait for. While waiting, the program execution
    will not be blocked because JavaScript allows us to wait for an asynchronous function
    named `fn` without blocking it. As we can see, the `fn` function is preceded by
    the `async` keyword, which is used to indicate to the compiler that it is an asynchronous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, the `await` keyword is used to suspend execution until
    the promise `p` is fulfilled or rejected. As we can see, the syntax is less verbose
    and cleaner than it would have been if we used the promises API or callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The `fn `function returns a promise at runtime because it is an `async` function.
    This should explain why we need to use the `then` callback to invoke it at the
    end of the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet showcases how we can declare an asynchronous function
    named `invokeTaskAsync`. The asynchronous function uses the `await` keyword to
    wait for the result of the `doSomethingAsync`, `doSomethingElseAsync`, and `doSomethingMoreAsync`
    functions that we declared during the promises example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invokeTaskAsync` function is asynchronous, and therefore, it will return
    a promise at runtime. This means that we can use the promises API to await a result
    or catch potential errors respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define asynchronous IIFE as a convenient way to use the `async`
    and `await` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an async IIFE is very useful because it is very common to not be able
    to use the `await` keyword outside of a function—for example, in the entry point
    of an application. We can use the async IIFE to overcome this limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned about the interface that is implemented by all iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we haven''t yet learned about the interface that is implemented by
    all asynchronous iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'An asynchronous iterator returns a promise every time we invoke the `next`
    method. The following code snippet demonstrates how asynchronous iterators can
    be very useful when used in conjunction with asynchronous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Some additional types are required by asynchronous iterators if we are targeting
    ES5\. You will need to add `esnext.asynciterable` to your `tsconfig.json` file.
    We are also going to need to enable an additional setting in our `tsconfig.json`
    to provide full support for iterables (for example, using `for...of` control flow
    statements, the spread operator or object destructuring) when targeting ES3 or
    ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"lib": [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.promise",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"dom",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"es5",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.generator",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.iterable",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"esnext.asynciterable" // new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`] `'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous iteration (for await...of)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the new `for...await...of` expression to iterate and await each
    of the promises returned by an asynchronous iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Delegating to another generator (yield*)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `yield*` expression to delegate from one generator to another.
    The following code snippet defines two generator functions named `g1` and `g2`.
    The `g2` generator uses the `yield*` expression to delegate the iteration to the
    iterator created by `g1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `yield*` expression can also be used to delegate the iteration to iterables,
    such as arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to work with functions in depth. We started
    with a quick recap of some basic concepts and then moved on to some lesser-known
    function features and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Once we learned how to work with functions, we focused on the use of callbacks,
    promises, and generators to take advantage of the asynchronous programming capabilities
    of TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to work with classes, interfaces, and
    other object-oriented programming features of the TypeScript programming language.
  prefs: []
  type: TYPE_NORMAL
