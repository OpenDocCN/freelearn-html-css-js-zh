- en: Working with Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与函数一起工作
- en: In [Chapter 1](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml), *Introducing TypeScript*,
    we learned the basics of functions. Functions are the fundamental building blocks
    of any application in TypeScript, and they are powerful enough to deserve the
    dedication of an entire chapter to explore their potential.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml) *介绍TypeScript* 中，我们学习了函数的基础知识。函数是TypeScript中任何应用程序的基本构建块，它们足够强大，值得用整整一章来探索它们的潜力。
- en: 'In this chapter, we are going to learn how to work with functions in depth.
    The chapter is divided into two main sections. The first section starts with a
    quick recap of some basic concepts, and then moves on to some less commonly known features
    of functions and their use cases. The first section covers the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入学习如何与函数一起工作。本章分为两个主要部分。第一部分首先快速回顾一些基本概念，然后转向函数的一些不太常见的特性和用例。第一部分涵盖了以下概念：
- en: Function declarations and function expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: Function types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Functions with optional parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: Functions with default parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: Functions with REST parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可变参数的函数
- en: Function overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: Specialized overloading signatures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊化的重载签名
- en: Function scope
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作用域
- en: Immediately invoked functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用的函数
- en: Tag functions and tagged templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签函数和标签模板
- en: 'The second section focuses on TypeScript''s asynchronous programming capabilities
    and includes the following concepts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分专注于TypeScript的异步编程能力，包括以下概念：
- en: Callbacks and higher-order functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调和高级函数
- en: Arrow functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Callback hell
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Promises
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Generators
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Asynchronous functions (`async` and `await`)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数（`async`和`await`）
- en: Working with functions in TypeScript
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TypeScript中与函数一起工作
- en: This section focuses on the declaration and use of functions, parameters, and
    arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关注函数、参数和参数的声明和使用。
- en: Function declarations and function expressions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: In the first chapter, we introduced the possibility of declaring functions with
    (named functions) or without (unnamed or anonymous functions) explicitly indicating
    their name, but we didn't mention that we were also using two different types
    of functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了显式声明带有（命名函数）或没有（未命名或匿名函数）名称的函数的可能性，但我们没有提到我们也在使用两种不同类型的函数。
- en: 'In the following example, the named function `greetNamed` is a **function declaration**,
    while `greetUnnamed` is a **function expression**. For now, please ignore the
    first two lines, which contain two `console.log` statements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，命名函数`greetNamed`是一个**函数声明**，而`greetUnnamed`是一个**函数表达式**。现在，请忽略前两行，它们包含两个`console.log`语句：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We might think that the preceding functions are identical, but they behave differently.
    The JavaScript interpreter can evaluate a function declaration as it is being
    parsed. On the other hand, the function expression is part of an assignment and
    will not be evaluated until the assignment has been completed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为前面的函数是相同的，但它们的运行方式不同。JavaScript解释器可以在解析时评估函数声明。另一方面，函数表达式是赋值的一部分，只有在赋值完成后才会被评估。
- en: The main cause of the different behavior of these functions is a process known
    as **variable hoisting**. We will learn more about the variable hoisting process
    later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数行为不同的主要原因是一个称为**变量提升**的过程。我们将在本章后面更深入地了解变量提升过程。
- en: If we compile the preceding TypeScript code snippet into JavaScript and try
    to execute it in a web browser, we will observe that the first `console.log` call
    works. This is because JavaScript knows about the declaration function and can
    parse it before the program is executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的TypeScript代码片段编译成JavaScript并在网页浏览器中尝试执行它，我们将观察到第一个`console.log`调用是有效的。这是因为JavaScript了解声明函数，可以在程序执行之前解析它。
- en: However, the second alert statement will throw an exception, which indicates
    that `greetUnnamed` is not a function. The exception is thrown because the `greetUnnamed`
    assignment must be completed before the function can be evaluated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个警报语句将抛出异常，这表明`greetUnnamed`不是一个函数。异常抛出是因为`greetUnnamed`的赋值必须在函数可以评估之前完成。
- en: Function types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'We already know that it is possible to explicitly declare the type of an element
    in our application by using optional type annotations:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，可以通过使用可选类型注解显式地声明应用程序中元素的类型：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding function, we have specified the type of the parameter name
    (string) and its return type (string). Sometimes, we will need to not just specify
    the types of the function elements, but the function itself. Let''s look at an
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们已经指定了参数名称的类型（字符串）及其返回类型（字符串）。有时，我们不仅需要指定函数元素的类型，还需要指定函数本身。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have declared the `greetUnnamed` variable and its
    type. The `greetUnnamed `type is a function type that takes a string variable
    called `name` as its only parameter and returns a string after being invoked.
    After declaring the variable, a function, whose type must be equal to the variable
    type, is assigned to it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经声明了`greetUnnamed`变量及其类型。`greetUnnamed`类型是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。在声明变量之后，一个类型必须等于变量类型的函数被分配给它。
- en: 'We can also declare the `greetUnnamed` type and assign a function to it in
    the same line rather than declaring it in two separate lines as we did in the
    previous example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在单行中声明`greetUnnamed`类型并将函数分配给它，而不是像上一个例子那样在两行中分别声明：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like in the previous example, the preceding code snippet also declares
    a variable, `greetUnnamed`, and its type. The `greetUnnamed `type is a function
    type that takes a string variable called `name` as its only parameter and will
    return a string after being invoked. We will assign a function to this variable
    in the same line in which it is declared. The type of the assigned function must
    match the type of the variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个例子一样，前面的代码片段也声明了一个变量`greetUnnamed`及其类型。`greetUnnamed`类型是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。我们将在声明变量的同一行中将函数分配给这个变量。分配的函数的类型必须与变量的类型匹配。
- en: In the preceding example, we have declared the type of the `greetUnnamed` variable
    and then assigned a function as its value. The type of the function can be inferred
    from the assigned function, and for this reason, it is unnecessary to add a redundant
    type annotation. We have done this to help you understand this section, but it
    is important to mention that adding redundant type annotations can make our code
    harder to read, and it is considered bad practice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了`greetUnnamed`变量的类型，然后将其值分配给一个函数。函数的类型可以从分配的函数中推断出来，因此添加冗余的类型注解是不必要的。我们这样做是为了帮助您理解这一部分，但重要的是要提到，添加冗余的类型注解可能会使我们的代码更难阅读，并且被认为是不良的实践。
- en: Trailing commas in function arguments
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数中的尾随逗号
- en: Trailing commas are the commas that are used after the last argument of a function.
    Using a comma after the last parameter of a function can be useful because it
    is very common for programmers to forget to add a comma when they modify an existing
    function by adding additional parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随逗号是指在函数最后一个参数之后使用的逗号。在函数的最后一个参数后使用逗号可能很有用，因为程序员在通过添加额外的参数修改现有函数时，常常会忘记添加逗号。
- en: 'For example, the following function only takes one parameter and doesn''t use
    trailing commas:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数只接受一个参数，并且没有使用尾随逗号：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After some time, we might be required to add a parameter to the preceding function.
    A common mistake is to declare the new parameter and forget to add a comma after
    the first parameter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，我们可能需要向前面的函数添加一个参数。一个常见的错误是在声明新参数时忘记在第一个参数后添加逗号：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using a trailing comma in the first version of the function could have helped
    us to prevent this common mistake:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一个版本中使用尾随逗号可以帮助我们避免这个常见的错误：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using a trailing comma eliminates the possibility of forgetting the comma when
    adding a new argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尾随逗号消除了在添加新参数时忘记添加逗号的可能性：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: TypeScript will throw an error if we forget a comma, so trailing commas are
    not needed as much as they are when working with JavaScript. Trailing commas are
    optional, but using them is considered a good practice by many JavaScript and
    TypeScript engineers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记添加逗号，TypeScript将抛出错误，因此与使用JavaScript相比，尾随逗号不是那么必要。尾随逗号是可选的，但许多JavaScript和TypeScript工程师认为使用它们是一种良好的实践。
- en: Functions with optional parameters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: 'Unlike JavaScript, the TypeScript compiler will throw an error if we attempt
    to invoke a function without providing the exact number and types of parameters
    that its signature declares. Let''s look at a code sample to demonstrate this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 不同，如果尝试调用一个函数而没有提供其签名声明的确切参数数量和类型，TypeScript 编译器将抛出一个错误。让我们看一个代码示例来演示这一点：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding function is called `add` and will take three numbers as parameters,
    named `foo`, `bar`, and `foobar`. If we attempt to invoke this function without
    providing exactly three numbers, we will get a compilation error indicating that
    the supplied parameters do not match the function''s signature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数名为 `add`，它将接受三个数字作为参数，参数名称分别为 `foo`、`bar` 和 `foobar`。如果我们尝试调用此函数而不提供恰好三个数字，我们将得到一个编译错误，表明提供的参数与函数的签名不匹配：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are scenarios in which we might want to be able to call the function without
    providing all its arguments. TypeScript features optional parameters in functions
    to help us to increase the flexibility of our functions and overcome such scenarios.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望能够在不提供所有参数的情况下调用函数。TypeScript 在函数中提供了可选参数，以帮助我们增加函数的灵活性并克服这些情况。
- en: 'We can indicate to the TypeScript compiler that we want a function''s parameter
    to be optional by appending the `?` character to its name. Let''s update the previous
    function to transform the required `foobar` parameter into an optional parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在参数名称后附加 `?` 字符来向 TypeScript 编译器指示我们希望函数的参数是可选的。让我们更新前面的函数，将必需的 `foobar`
    参数转换为可选参数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note how we have changed the `foobar` parameter name to `foobar?`, and how
    we are checking the type of `foobar` inside the function to identify whether the
    parameter was supplied as an argument to the function or not. After implementing
    these changes, the TypeScript compiler will allow us to invoke the function without
    errors when we supply two or three arguments to it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `foobar` 参数名称更改为 `foobar?`，以及我们如何在函数内部检查 `foobar` 的类型，以确定该参数是否作为参数传递给了函数。在实施这些更改后，TypeScript
    编译器将允许我们在提供两个或三个参数时调用该函数而不会出错：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to note that the optional parameters must always be located
    after the required parameters in the function's parameter list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可选参数必须始终位于函数参数列表中的必选参数之后。
- en: Functions with default parameters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: When a function has some optional parameters, we must check whether an argument
    has been passed to the function (just like we did in the previous example) to
    prevent potential errors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有一些可选参数时，我们必须检查是否向函数传递了参数（就像我们在前面的例子中所做的那样），以防止潜在的错误。
- en: 'There are some scenarios where it would be more useful to provide a default
    value for a parameter when it is not supplied than making it an optional parameter.
    Let''s rewrite the `add` function (from the previous section) using the inline
    `if` structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为参数提供一个默认值（而不是将其作为可选参数）可能更有用。让我们重写 `add` 函数（来自上一节），使用内联 `if` 结构：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is nothing wrong with the preceding function, but we can improve its
    readability by providing a default value for the `foobar` parameter instead of
    using an optional parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数本身没有问题，但我们可以通过为 `foobar` 参数提供一个默认值来提高其可读性，而不是使用可选参数：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To indicate that a function parameter is optional, we need to provide a default
    value using the `=` operator when declaring the function''s signature. After compiling
    the preceding code examples, the TypeScript compiler will generate an `if` structure
    in the JavaScript output to set a default value for the `foobar` parameter if
    it is not passed as an argument to the function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个函数参数是可选的，我们需要在声明函数签名时使用 `=` 运算符提供默认值。在编译前面的代码示例后，TypeScript 编译器将在 JavaScript
    输出中生成一个 `if` 结构，以设置 `foobar` 参数的默认值，如果它没有被作为函数的参数传递：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is great because the TypeScript compiler generated the code necessary for
    us to prevent potential runtime errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为 TypeScript 编译器为我们生成了防止潜在运行时错误的代码。
- en: 'The `void 0` parameter is used by the TypeScript compiler to check whether
    a variable is undefined. While most developers use the undefined variable to perform
    this kind of check, most compilers use `void 0` because it will always evaluate
    as undefined. Checking against an undefined variable is less secure because its
    value could have been modified, as demonstrated by the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`function test() {`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`    var undefined = 2; // 2`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`    console.log(undefined === 2); // true`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Just like optional parameters, default parameters must always be located after
    any required parameters in the function's parameter list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Functions with REST parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to use optional and default parameters to increase the
    number of ways that we can invoke a function. Let''s return one more time to the
    previous example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have learned how to invoke the `add` function with two or three parameters,
    but what if we wanted to allow other developers to pass four or five parameters
    to our function? We would have to add two extra default or optional parameters.
    And what if we wanted to allow them to pass as many parameters as they need? The
    solution to this possible scenario is the use of REST parameters. The REST parameter
    syntax allows us to represent an indefinite number of arguments as an array:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the preceding code snippet, we have replaced the function
    parameters `foo`, `bar`, and `foobar` with just one parameter named `foo`. Note
    that the name of the parameter `foo` is preceded by an ellipsis (a set of three
    periods—not the actual ellipsis character). A REST parameter must be of an array
    type or we will get a compilation error. We can now invoke the `add` function
    with as many parameters as we need:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although there is no specific limit to the theoretical maximum number of arguments
    that a function can take, there are, of course, practical limits. These limits
    are entirely implementation-dependent and, most likely, will also depend on exactly how
    we are calling the function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions have a built-in object called the `arguments` object. This
    object is available as a local variable named `arguments`. The `arguments` variable
    contains an object like an array that contains the arguments used when the function
    was invoked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` object exposes some of the methods and properties provided by
    a standard array, but not all of them. Refer to the documentation at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)
    to learn more about its peculiarities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the JavaScript output, we will notice that TypeScript iterates
    the `arguments` object to add the values to the `foo` variable:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can argue that this is an extra, unnecessary iteration over the function''s
    parameters. Even though it is hard to imagine this extra iteration becoming a
    performance issue, if you think that this could be a problem for the performance
    of your application, you may want to consider avoiding the use of REST parameters
    and use an array as the only parameter of the function instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争辩说，这是对函数参数的额外、不必要的迭代。尽管很难想象这种额外的迭代会成为性能问题，但如果您认为这可能会影响您应用程序的性能，您可能希望考虑避免使用REST参数，而是使用数组作为函数的唯一参数：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding function takes an array of numbers as its only parameter. The
    invocation API will be a little bit different from the REST parameters, but we
    will effectively avoid the extra iteration over the function''s argument list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能只接受一个数字数组作为其唯一参数。调用API将与REST参数略有不同，但我们将有效地避免在函数参数列表上额外的迭代：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Function overloading
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'Function overloading, or method overloading, is the ability to create multiple
    methods with the same name and a different number of parameters or types. In TypeScript,
    we can overload a function by specifying all function signatures (known as the **overload
    signatures**) of a function, followed by a signature (known as the **implementation
    signature**). Let''s look at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载，或方法重载，是创建具有相同名称但参数数量或类型不同的多个方法的能力。在TypeScript中，我们可以通过指定一个函数的所有函数签名（称为**重载签名**），然后是一个签名（称为**实现签名**）来重载一个函数。让我们看一个例子：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding example, we have overloaded the function test
    three times by adding a signature that takes a string as its only parameter, another
    function that takes a number, and a final signature that takes a boolean as its
    unique parameter. It is important to note that all function signatures must be
    compatible; so if, for example, one of the signatures tries to return a number
    while another tries to return a string, we will get a compilation error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在前面的例子中看到的那样，我们通过添加一个只接受字符串作为唯一参数的签名、另一个接受数字的函数和一个最终接受布尔值作为唯一参数的签名，三次重载了函数test。重要的是要注意，所有函数签名都必须兼容；因此，如果例如，一个签名试图返回一个数字，而另一个试图返回一个字符串，我们将得到一个编译错误：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The implementation signature must be compatible with all the overloaded signatures,
    always be the last in the list, and take the `any` type or a union type as the
    type of its parameters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实现签名必须与所有重载签名兼容，始终是列表中的最后一个，并且其参数的类型必须是`any`类型或联合类型。
- en: 'Invoking the function providing arguments that don''t match any of the types
    that are declared by the overload signatures will lead us to a compilation error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数并提供不匹配重载签名中声明的任何类型的参数将导致我们得到一个编译错误：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specialized overloading signature
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用重载签名
- en: 'We can use a specialized signature to create multiple methods with the same
    name and number of parameters, but a different return type. To create a specialized
    signature, we must indicate the type of function parameter using a string. The
    string literal is used to identify which of the function overloads is invoked:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用专用签名创建具有相同名称和参数数量但不同返回类型的多个方法。要创建专用签名，我们必须使用字符串指示函数参数的类型。字符串字面量用于识别调用了哪个函数重载：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we have declared three **specialized overloaded signatures**
    and one **nonspecialized signature** for the function named `createElement`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为名为`createElement`的函数声明了三个**专用重载签名**和一个**非专用签名**。
- en: When we declare a specialized signature in an object, it must be assignable
    to at least one nonspecialized signature in the same object. This can be observed
    in the preceding example, as the `createElement` property belongs to a type that
    contains three specialized signatures, all of which are assignable to the nonspecialized
    signature in the type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在对象中声明一个专用签名时，它必须可以分配给该对象中至少一个非专用签名。这可以从前面的例子中观察到，因为`createElement`属性属于一个包含三个专用签名的类型，所有这些都可以分配给该类型的非专用签名。
- en: When writing overloaded declarations, we must list the nonspecialized signature
    last.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写重载声明时，我们必须将非专用签名放在最后。
- en: Function scope
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作用域
- en: Low-level languages, such as C, have low-level memory management features. In
    programming languages with a higher level of abstraction, such as TypeScript,
    values are allocated when variables are created and automatically cleared from
    memory when they are not used anymore. The process that cleans the memory is known
    as **garbage collection** and is performed by the JavaScript runtime garbage collector.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector does a great job, but it is a mistake to assume that it
    will always prevent us from facing a memory leak. The garbage collector will clear
    a variable from the memory whenever the variable is out of the scope. It is important
    to understand how the TypeScript scope works, so we will now look at the life
    cycle of the variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages use the structure of the program source code to determine
    what variables we are referring to (**lexical scoping**), while others use the
    runtime state of the program stack to determine what variable we are referring
    to (**dynamic scoping**). The majority of modern programming languages use lexical
    scoping (including TypeScript). Lexical scoping tends to be dramatically easier
    to understand for both humans and analysis tools than dynamic scoping.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'While in most lexical-scoped programming languages, variables are scoped to
    a block (a section of code delimited by curly braces `{}`), in TypeScript (and
    JavaScript), variables are scoped to a function, as demonstrated by the following
    code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding function named `foo` contains an `if` structure. We have declared
    a numeric variable named `bar` inside the `if` structure, and later, we have attempted
    to show the value of the `bar` variable using the `log` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We might think that the preceding code sample would throw an error in the fifth
    line because the `var` variable should be out of the scope when the `log` function
    is invoked. However, if we invoke the `foo` function, the `log` function will
    be able to display the `bar` variable without errors because all the variables
    inside a function will be in the scope of the entire function body, even if they
    are inside another block of code (except a function block).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This might seem confusing, but it is easy to understand once we know that at
    runtime, all the variable declarations are moved to the top of a function before
    the function is executed. This behavior is known as **hoisting**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is compiled to JavaScript and then executed—this means that a TypeScript
    application is a JavaScript application at runtime, and for this reason, when
    we refer to the TypeScript runtime, we are talking about the JavaScript runtime.
    We will learn in depth about the runtime in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the preceding code snippet is executed, the runtime will move the declaration
    of the `bar `variable to the top of our function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This explains why it is possible to use a variable before it is declared. Let''s
    look at an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code snippet, we have declared a `foo `function, and in its
    body, we have assigned the value `0` to a variable named `bar`. At this point,
    the variable has not been declared. In the second line, we are declaring the variable
    `bar` and its type. In the last line, we are displaying the value of `bar` using
    the alert function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Because declaring a variable anywhere inside a function (except another function)
    is equivalent to declaring it at the top of the function, the `foo` function is
    transformed into the following at runtime:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because developers with a background in programming languages with block scope,
    such as Java or C#, are not used to the function scope, it is one of the most
    criticized characteristics of JavaScript. The people in charge of the development
    of the ECMAScript 6 specification are aware of this, and as a result, they have
    introduced the keywords `let` and `const`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The `let` keyword allows us to set the scope of a variable to a block (`if`,
    `while`, `for`, and so on) rather than a function. We can update the first example
    in this section to showcase how `let` works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `bar` variable is now declared using the `let` keyword, and as a result,
    it is only accessible inside the `if` block. The variable is not hoisted to the
    top of the `foo` function and cannot be accessed by the `alert` function outside
    the `if` statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'While variables defined with `const` follow the same scope rules as variables
    declared with `let`, they can''t be reassigned:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we attempt to compile the preceding code snippet, we will get an error because
    the `bar` variable is not accessible outside the `if` statement (just like when
    we used the `let` keyword), and a new error will occur when we try to assign a
    new value to the `bar` variable. The second error occurs because it is not possible
    to assign a new value to a constant variable once the variable has already been
    initialized.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared with the `const` keyword cannot be reassigned, but are not
    immutable. When we say that a variable is immutable, we means that it cannot be
    modified. We will learn more about immutability in [Chapter 7](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml),
    *Functional Programming with TypeScript*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Immediately invoked functions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **immediately invoked function expression** (**IIFE**) is a design pattern
    that produces a lexical scope using function scoping. An IIFE can be used to avoid
    variable hoisting from within blocks, or to prevent us from polluting the global
    scope—for example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, we have wrapped the declaration of a variable (`foo`)
    with an IIFE. The `foo` variable is scoped to the IIFE function and is not available
    in the global scope, which explains the error that is thrown when we try to access
    it on the last line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The `bar` variable is a global. Therefore, it can be accessed from both the
    inside and the outside of the IIFE function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a variable to the IIFE to have better control over the creation
    of variables outside its scope:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Furthermore, IIFE can help us to simultaneously allow public access to methods
    while retaining privacy for variables defined within the function. Let''s look
    at an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have defined a class named `Counter`, which has a private numeric attribute
    named `_i`. The class also has methods to get and set the value of the private
    `_i `property.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: By convention, TypeScript and JavaScript developers usually name private variables
    with names preceded by an underscore (`_`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We have also created an instance of the `Counter` class and invoked the `set`,
    `get`, and `increment` methods to observe that everything is working as expected.
    If we attempt to access the `_i` property in an instance of `Counter`, we will
    get an error because the variable is `private`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile the preceding TypeScript code (only the class definition) and
    examine the generated JavaScript code, we will see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This generated JavaScript code will work perfectly in most scenarios, but if
    we execute it in a browser and try to create an instance of `Counter` and access
    its `_i `property, we will not get any errors because TypeScript will not generate
    runtime private properties for us. Sometimes we will need to write our classes
    in such a way that some properties are private at runtime—for example, if we release
    a library that will be used by JavaScript developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use IIFE to simultaneously allow public access to methods while
    retaining privacy for variables defined within the function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, everything is almost identical to the TypeScript's
    generated JavaScript, except now the variable `_i` is an object in the `Counter`
    closure instead of a property of the `Counter` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure *remembers* the environment (variables
    in the scope) in which it was created. We will discover more about closures in
    [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the generated JavaScript output in a browser and try to invoke the
    `_i` property directly, we will notice that the property is now private at runtime:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In some cases, we will need to have precise control over scope and closures,
    and our code will end up looking much more like JavaScript. As long as we write
    our application components (classes, modules, and so on) to be consumed by other
    TypeScript components, we will rarely have to worry about implementing runtime
    private properties. We will look in depth at the TypeScript runtime in [Chapter
    6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Tag functions and tagged templates
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use template strings such as the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use a template string to create a special kind of function known as a
    **tag function**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We can use a tag function to extend or modify the standard behavior of template
    strings. When we apply a tag function to a template string, the template string
    becomes a tagged template.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a tag function named `htmlEscape`. To use a tag function,
    we must use the name of the function followed by a template string:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A tag template must return a string and take the following arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: A `TemplateStringsArray` that contains all the static literals in the template
    string (`<h1>` and `</h1>` in the preceding example) is passed as the first argument.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TemplateStringsArray` type is declared by the `lib.d.ts` file. We will
    learn more about the `lib.d.ts` file in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: A REST parameter is passed as the second parameter. The REST parameter contains
    all the values in the template string (`name` and `surname`, in the preceding
    example).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature of a tag function looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s implement the `htmlEscape` tag function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then invoke the function as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The template string contains values and literals. The `htmlEscape` function
    iterates through them and ensures that the HTML code is escaped in the values
    to avoid possible code injection attacks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of using a tagged function is that it allows us to create custom
    template string processors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming in TypeScript
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to work with functions, we will explore how we can
    use them, together with some native APIs, to write asynchronous applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and higher-order functions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, functions can be passed as arguments to another function. Functions
    can also be returned by another function. A function passed to another as an argument
    is known as a **callback**. Functions that accept functions as parameters (callbacks)
    or return functions are known as **higher-order functions**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks are usually anonymous functions. They can be declared before they
    are passed to the higher-order function, as demonstrated by the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, callbacks are declared inline, at the same point at which they are
    passed to the higher-order function, as demonstrated by the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Arrow functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, we can declare a function using a `function` expression or an
    arrow function. An arrow function has a shorter syntax than a function expression,
    and lexically binds the value of the `this` operator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` operator behaves a little differently in TypeScript and JavaScript
    compared to other popular programming languages. When we define a class in TypeScript,
    we can use the `this` operator to refer to the class. Let''s look at an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have defined a `Person` class that contains a property of a string type called
    `name`. The class has a constructor and a `greet `method. We have created an instance
    named `person` and invoked the `greet` method, which uses the `this` operator internally to
    access the `_name `property. Inside the `greet` method, the `this` operator points
    to the object that encloses the `greet` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be careful when using the `this` operator, because in some scenarios
    it can point to the wrong value. Let''s add an extra method to the previous example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `greetDelay` method, we perform an almost identical operation to the
    one performed by the `greet` method. This time, the function takes a parameter
    named `time`, which is used to delay the `greet` message.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: To delay a message, we use the `setTimeout` function and a callback. As soon
    as we define an anonymous function (the callback), the `this` keyword changes
    its value and starts pointing to the anonymous function, which explains why the
    TypeScript compiler will throw an error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, an arrow function expression lexically binds the value of the
    `this` operator. This means that it `allows` us to add a function without altering
    the value of the `this` operator. Let''s replace the function expression from
    the previous example with an arrow function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By using an arrow function, we can ensure that the `this` operator still points
    to the `Person` instance and not to the `setTimeout` callback. If we execute the
    `greetDelay` function, the name property will be displayed as expected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is generated by the TypeScript compiler. When compiling
    an arrow function, the TypeScript compiler will generate an alias for the `this`
    operator named `_this`. The alias is used to ensure that the `this` operator points
    to the right object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will look at the `this` operator in depth in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Callback hell
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that callbacks and higher-order functions are two powerful and
    flexible JavaScript and TypeScript features. However, the use of callbacks can
    lead to a maintainability issue known as **callback hell**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to write an example to showcase callback hell. We are going
    to write three functions with the same behavior, named `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding functions simulate an asynchronous operation by using the `setTimeout`
    function. Each function takes a success callback, which is invoked if the operation
    is successful, and an error callback, which is invoked if something goes wrong.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, asynchronous operations usually involve some interaction
    with hardware (for example, filesystems, networks, and so on). The interactions
    are known as **input/output** (**I**/**O**) operations. I/O operations can fail
    for many different reasons (for example, we get an error when we try to interact
    with the filesystem to save a new file and there is not enough space available
    on the hard disk).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，异步操作通常涉及与硬件的一些交互（例如，文件系统、网络等）。这些交互被称为**输入/输出（I/O）**操作。I/O操作可能因许多不同的原因而失败（例如，当我们尝试与文件系统交互以保存新文件时，硬盘上没有足够的空间）。
- en: The preceding functions generate a random number and throw an error if the number
    is lower than 25; we do this to simulate potential I/O errors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数生成一个随机数，如果数字小于25则抛出错误；我们这样做是为了模拟潜在的I/O错误。
- en: The preceding functions add the random number to an array that is passed as
    an argument to each of the functions. If no errors take place, the result of the
    final function (`doSomethingMoreAsync`) should be an array with three random numbers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将随机数添加到一个数组中，该数组作为参数传递给每个函数。如果没有发生错误，最终函数（`doSomethingMoreAsync`）的结果应该是一个包含三个随机数的数组。
- en: 'Now that the three functions have been declared, we can try to invoke them
    in order. We are going to use callbacks to ensure that `doSomethingMoreAsync`
    is invoked after `do``SomethingElseAsync`, and `doSomethingElseAsync` is invoked
    after `do``SomethingAsync`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在三个函数已经声明，我们可以尝试按顺序调用它们。我们将使用回调来确保`doSomethingMoreAsync`在`doSomethingElseAsync`之后被调用，而`doSomethingElseAsync`在`doSomethingAsync`之后被调用：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding example used a few nesting callbacks. The use of these kinds
    of nested callbacks is known as **callback hell** because they can lead to the
    following maintainability issues:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用了几个嵌套的回调。这类嵌套回调的使用被称为**回调地狱（callback hell）**，因为它们可能导致以下可维护性问题：
- en: Making the code harder to follow and understand
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更难以跟踪和理解
- en: Making the code harder to maintain (refactor, reuse, and so on)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更难以维护（重构、重用等）
- en: Making exception handling more difficult
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使异常处理更加困难
- en: Promises
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: 'After seeing how the use of callbacks can lead to some maintainability problems,
    we are now going to learn about promises and how they can be used to write better
    asynchronous code. The core idea behind promises is that a promise represents
    the result of an asynchronous operation. A promise must be in one of the following
    three states:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到回调的使用如何导致一些可维护性问题之后，我们现在将学习关于承诺（promises）以及如何使用它们来编写更好的异步代码。承诺背后的核心思想是，承诺代表异步操作的结果。承诺必须处于以下三种状态之一：
- en: '**Pending**: The initial state of a promise.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起（Pending）**：承诺的初始状态。'
- en: '**Fulfilled****/resolved**: The state of a promise representing a successful
    operation. The terms "fulfilled" and "resolved" are both commonly used to refer
    to this state.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已实现/已解决（Fulfilled/resolved）**：表示成功操作的承诺状态。术语“已实现”和“已解决”都常用来指代此状态。'
- en: '**Rejected**: The state of a promise representing a failed operation.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已拒绝（Rejected）**：表示失败操作的承诺状态。'
- en: 'Once a promise is fulfilled or rejected, its state can never change again.
    Let''s look at the basic syntax of a promise:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦承诺被实现或拒绝，其状态将无法再改变。让我们看看承诺的基本语法：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A `try...catch` statement is used here to showcase how we can explicitly fulfill
    or reject a promise. The `try...catch` statement is not needed for a `Promise`
    function because when an error is thrown in a promise callback, the promise will
    automatically be rejected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`try...catch`语句来展示我们如何显式地实现或拒绝一个承诺。对于`Promise`函数来说，`try...catch`语句是不必要的，因为当在承诺回调中抛出错误时，承诺将自动被拒绝。
- en: The preceding code snippet declares a function named `foo` that returns a promise.
    The promise contains a method named `then`, which accepts a function to be invoked
    when the promise is fulfilled. Promises also provide a method named `catch`, which
    is invoked when a promise is rejected.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为`foo`的函数，该函数返回一个承诺。承诺包含一个名为`then`的方法，该方法接受一个在承诺实现时将被调用的函数。承诺还提供了一个名为`catch`的方法，该方法在承诺被拒绝时被调用。
- en: 'Promises will not be recognized by the TypeScript compiler if we are targeting
    ES5, because the promises API is part of ES6\. We can solve this by enabling the
    `es2015.promise` type using the `lib` option in the `tsconfig``.json` file. Note
    that enabling this option will disable some types that are included by default
    and therefore break some of the examples. You will be able to solve the problems
    by including the `dom` and `es5` types, as well as by using the `lib` option in
    the `tsconfig``.json` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`"lib": [`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.promise",`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`    "dom",`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es5",`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.generator", // new`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`    "es2015.iterable" // new`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`]`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to rewrite the `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync` functions that we wrote during the callback hell example,
    using promises instead of callbacks:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can chain the promises that are returned by each of the preceding functions
    using the promises API:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code snippet is a little bit better than the one used in the callback
    example because we only needed to declare one exception handler instead of three
    exception handlers. This is possible because errors are propagated through the
    chain of promises.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example has introduced some improvements. However, the promises
    API allows us to chain promises in a much less verbose way:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code is much easier to read and follow than the one used during
    the callback examples, but this is not the only reason to prefer promises over
    callbacks. Using promises also gives us better control over the execution flow
    of operations. Let's look at a couple of examples.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The promises API includes a method named `all`, which allows us to execute
    a series of promises in parallel and get all the results of each of the promises
    at once:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The promises API also includes a method named `race`, which allows us to execute
    a series of promises in parallel and get the result of the first promise resolved:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can use many different types of asynchronous flow control when working with
    promises:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrent**: The tasks are executed in parallel (like in the `Promise.all`
    example)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race**: The tasks are executed in parallel, and only the result of the fastest
    promise is returned'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: A group of tasks is executed in sequence, but the preceding tasks
    do not pass arguments to the next task'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waterfall**: A group of tasks is executed in sequence, and each task passes
    arguments to the next task (like in the example that preceded the `Promise.all`
    and `Promise.race` examples)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This is any combination of the preceding concurrent, series,
    and waterfall approaches'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariant checking in callback parameters
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript 2.4 changed the way the type system behaves internally to improve
    the error detection in nested callbacks and promises:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript's checking of callback parameters is now covariant concerning immediate
    signature checks. Previously it was bivariant, which could sometimes let incorrect
    types through. Basically, this means that callback parameters and classes that
    contain callbacks are checked more carefully, so TypeScript will require stricter
    types in this release. This is particularly true of Promises and Observables due
    to the way in which their APIs are specified.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript versions before 2.4, the following example was considered valid,
    and no errors were thrown:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In TypeScript versions following the 2.4 release, we need to add the complete
    signature of `nestedCallback` to solve this error:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Thanks to the internal change in the TypeScript type system, the following
    error is also detected:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Before TypeScript 2.4, the preceding promise would have been inferred as `Promise<{}>`
    because we forgot to add the generic `<number>` argument when we created an instance
    of the `Promise` class. The `error` string would then have been considered a valid
    instance of `{}`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: This is a clear example of why it is recommended that you upgrade TypeScript
    regularly. Each new version of TypeScript introduces new features that are able
    to detect new errors for us.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we invoke a function in TypeScript, we can assume that once the function
    starts running, it will always run to completion before any other code can run.
    However, a new kind of function that may be paused in the middle of execution—one
    or many times—and resumed later, allowing other code to run during these paused
    periods, has recently been added to the ECMAScript specification. These new kinds
    of functions are known as **generators**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator represents a sequence of values. The interface of a `generator`
    object is just an **iterator**. An iterator implements the following interface:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `next()`function can be invoked until it runs out of values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a generator by using the `function` keyword followed by an asterisk
    (`*`). The `yield` keyword is used to stop the execution of the function and return
    a value. Let''s look at an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that some additional types are required by generators if you are targeting
    ES5\. You will need to add `es2015.generator` and `es2015.iterable` to your `tsconfig.json`
    file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), **Automating
    Your Development Workflow**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the preceding iterator has five steps. The first time we call
    `next`, the function will be executed until it reaches the first `yield` statement,
    and then it will return the value `1` and stop the execution of the function until
    we invoke the generator''s `next` method again. As we can see, we are now able
    to stop the function''s execution at a given point. This allows us to write infinite
    loops without causing a stack overflow, as demonstrated in the following example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The generator will open possibilities for synchronicity, as we can call the
    generator's `next` method after an asynchronous event has occurred.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions – async and await
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous functions** are a TypeScript feature that arrived with the TypeScript
    1.6 release. Developers can use the `await` keyword to wait for the function results
    without blocking the normal execution of the program.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous functions helps to increase the readability of a piece of
    code when compared with the use of promises or callbacks, but technically, we
    can achieve the same features using both promises and synchronous code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a basic `async`/`await` example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code snippet declares a promise named `p`. This promise is the
    piece of code whose execution we will wait for. While waiting, the program execution
    will not be blocked because JavaScript allows us to wait for an asynchronous function
    named `fn` without blocking it. As we can see, the `fn` function is preceded by
    the `async` keyword, which is used to indicate to the compiler that it is an asynchronous
    function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, the `await` keyword is used to suspend execution until
    the promise `p` is fulfilled or rejected. As we can see, the syntax is less verbose
    and cleaner than it would have been if we used the promises API or callbacks.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The `fn `function returns a promise at runtime because it is an `async` function.
    This should explain why we need to use the `then` callback to invoke it at the
    end of the code snippet.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet showcases how we can declare an asynchronous function
    named `invokeTaskAsync`. The asynchronous function uses the `await` keyword to
    wait for the result of the `doSomethingAsync`, `doSomethingElseAsync`, and `doSomethingMoreAsync`
    functions that we declared during the promises example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `invokeTaskAsync` function is asynchronous, and therefore, it will return
    a promise at runtime. This means that we can use the promises API to await a result
    or catch potential errors respectively:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also define asynchronous IIFE as a convenient way to use the `async`
    and `await` keywords:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Using an async IIFE is very useful because it is very common to not be able
    to use the `await` keyword outside of a function—for example, in the entry point
    of an application. We can use the async IIFE to overcome this limitation:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Asynchronous generators
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned about the interface that is implemented by all iterators:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, we haven''t yet learned about the interface that is implemented by
    all asynchronous iterators:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'An asynchronous iterator returns a promise every time we invoke the `next`
    method. The following code snippet demonstrates how asynchronous iterators can
    be very useful when used in conjunction with asynchronous functions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Some additional types are required by asynchronous iterators if we are targeting
    ES5\. You will need to add `esnext.asynciterable` to your `tsconfig.json` file.
    We are also going to need to enable an additional setting in our `tsconfig.json`
    to provide full support for iterables (for example, using `for...of` control flow
    statements, the spread operator or object destructuring) when targeting ES3 or
    ES5:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`"lib": [`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.promise",`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`"dom",`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '`"es5",`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.generator",`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`"es2015.iterable",`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '`"esnext.asynciterable" // new`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`] `'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous iteration (for await...of)
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the new `for...await...of` expression to iterate and await each
    of the promises returned by an asynchronous iterator:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Delegating to another generator (yield*)
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `yield*` expression to delegate from one generator to another.
    The following code snippet defines two generator functions named `g1` and `g2`.
    The `g2` generator uses the `yield*` expression to delegate the iteration to the
    iterator created by `g1`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `yield*` expression can also be used to delegate the iteration to iterables,
    such as arrays:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to work with functions in depth. We started
    with a quick recap of some basic concepts and then moved on to some lesser-known
    function features and use cases.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Once we learned how to work with functions, we focused on the use of callbacks,
    promises, and generators to take advantage of the asynchronous programming capabilities
    of TypeScript.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to work with classes, interfaces, and
    other object-oriented programming features of the TypeScript programming language.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
