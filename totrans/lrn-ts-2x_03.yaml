- en: Working with Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与函数一起工作
- en: In [Chapter 1](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml), *Introducing TypeScript*,
    we learned the basics of functions. Functions are the fundamental building blocks
    of any application in TypeScript, and they are powerful enough to deserve the
    dedication of an entire chapter to explore their potential.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml) *介绍TypeScript* 中，我们学习了函数的基础知识。函数是TypeScript中任何应用程序的基本构建块，它们足够强大，值得用整整一章来探索它们的潜力。
- en: 'In this chapter, we are going to learn how to work with functions in depth.
    The chapter is divided into two main sections. The first section starts with a
    quick recap of some basic concepts, and then moves on to some less commonly known features
    of functions and their use cases. The first section covers the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入学习如何与函数一起工作。本章分为两个主要部分。第一部分首先快速回顾一些基本概念，然后转向函数的一些不太常见的特性和用例。第一部分涵盖了以下概念：
- en: Function declarations and function expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: Function types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Functions with optional parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: Functions with default parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: Functions with REST parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可变参数的函数
- en: Function overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: Specialized overloading signatures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊化的重载签名
- en: Function scope
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作用域
- en: Immediately invoked functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用的函数
- en: Tag functions and tagged templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签函数和标签模板
- en: 'The second section focuses on TypeScript''s asynchronous programming capabilities
    and includes the following concepts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分专注于TypeScript的异步编程能力，包括以下概念：
- en: Callbacks and higher-order functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调和高级函数
- en: Arrow functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Callback hell
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Promises
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Generators
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Asynchronous functions (`async` and `await`)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数（`async`和`await`）
- en: Working with functions in TypeScript
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TypeScript中与函数一起工作
- en: This section focuses on the declaration and use of functions, parameters, and
    arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关注函数、参数和参数的声明和使用。
- en: Function declarations and function expressions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: In the first chapter, we introduced the possibility of declaring functions with
    (named functions) or without (unnamed or anonymous functions) explicitly indicating
    their name, but we didn't mention that we were also using two different types
    of functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了显式声明带有（命名函数）或没有（未命名或匿名函数）名称的函数的可能性，但我们没有提到我们也在使用两种不同类型的函数。
- en: 'In the following example, the named function `greetNamed` is a **function declaration**,
    while `greetUnnamed` is a **function expression**. For now, please ignore the
    first two lines, which contain two `console.log` statements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，命名函数`greetNamed`是一个**函数声明**，而`greetUnnamed`是一个**函数表达式**。现在，请忽略前两行，它们包含两个`console.log`语句：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We might think that the preceding functions are identical, but they behave differently.
    The JavaScript interpreter can evaluate a function declaration as it is being
    parsed. On the other hand, the function expression is part of an assignment and
    will not be evaluated until the assignment has been completed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为前面的函数是相同的，但它们的运行方式不同。JavaScript解释器可以在解析时评估函数声明。另一方面，函数表达式是赋值的一部分，只有在赋值完成后才会被评估。
- en: The main cause of the different behavior of these functions is a process known
    as **variable hoisting**. We will learn more about the variable hoisting process
    later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数行为不同的主要原因是一个称为**变量提升**的过程。我们将在本章后面更深入地了解变量提升过程。
- en: If we compile the preceding TypeScript code snippet into JavaScript and try
    to execute it in a web browser, we will observe that the first `console.log` call
    works. This is because JavaScript knows about the declaration function and can
    parse it before the program is executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的TypeScript代码片段编译成JavaScript并在网页浏览器中尝试执行它，我们将观察到第一个`console.log`调用是有效的。这是因为JavaScript了解声明函数，可以在程序执行之前解析它。
- en: However, the second alert statement will throw an exception, which indicates
    that `greetUnnamed` is not a function. The exception is thrown because the `greetUnnamed`
    assignment must be completed before the function can be evaluated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个警报语句将抛出异常，这表明`greetUnnamed`不是一个函数。异常抛出是因为`greetUnnamed`的赋值必须在函数可以评估之前完成。
- en: Function types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'We already know that it is possible to explicitly declare the type of an element
    in our application by using optional type annotations:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，可以通过使用可选类型注解显式地声明应用程序中元素的类型：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding function, we have specified the type of the parameter name
    (string) and its return type (string). Sometimes, we will need to not just specify
    the types of the function elements, but the function itself. Let''s look at an
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们已经指定了参数名称的类型（字符串）及其返回类型（字符串）。有时，我们不仅需要指定函数元素的类型，还需要指定函数本身。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have declared the `greetUnnamed` variable and its
    type. The `greetUnnamed `type is a function type that takes a string variable
    called `name` as its only parameter and returns a string after being invoked.
    After declaring the variable, a function, whose type must be equal to the variable
    type, is assigned to it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经声明了`greetUnnamed`变量及其类型。`greetUnnamed`类型是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。在声明变量之后，一个类型必须等于变量类型的函数被分配给它。
- en: 'We can also declare the `greetUnnamed` type and assign a function to it in
    the same line rather than declaring it in two separate lines as we did in the
    previous example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在单行中声明`greetUnnamed`类型并将函数分配给它，而不是像上一个例子那样在两行中分别声明：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like in the previous example, the preceding code snippet also declares
    a variable, `greetUnnamed`, and its type. The `greetUnnamed `type is a function
    type that takes a string variable called `name` as its only parameter and will
    return a string after being invoked. We will assign a function to this variable
    in the same line in which it is declared. The type of the assigned function must
    match the type of the variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个例子一样，前面的代码片段也声明了一个变量`greetUnnamed`及其类型。`greetUnnamed`类型是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。我们将在声明变量的同一行中将函数分配给这个变量。分配的函数的类型必须与变量的类型匹配。
- en: In the preceding example, we have declared the type of the `greetUnnamed` variable
    and then assigned a function as its value. The type of the function can be inferred
    from the assigned function, and for this reason, it is unnecessary to add a redundant
    type annotation. We have done this to help you understand this section, but it
    is important to mention that adding redundant type annotations can make our code
    harder to read, and it is considered bad practice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了`greetUnnamed`变量的类型，然后将其值分配给一个函数。函数的类型可以从分配的函数中推断出来，因此添加冗余的类型注解是不必要的。我们这样做是为了帮助您理解这一部分，但重要的是要提到，添加冗余的类型注解可能会使我们的代码更难阅读，并且被认为是不良的实践。
- en: Trailing commas in function arguments
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数中的尾随逗号
- en: Trailing commas are the commas that are used after the last argument of a function.
    Using a comma after the last parameter of a function can be useful because it
    is very common for programmers to forget to add a comma when they modify an existing
    function by adding additional parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随逗号是指在函数最后一个参数之后使用的逗号。在函数的最后一个参数后使用逗号可能很有用，因为程序员在通过添加额外的参数修改现有函数时，常常会忘记添加逗号。
- en: 'For example, the following function only takes one parameter and doesn''t use
    trailing commas:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数只接受一个参数，并且没有使用尾随逗号：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After some time, we might be required to add a parameter to the preceding function.
    A common mistake is to declare the new parameter and forget to add a comma after
    the first parameter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，我们可能需要向前面的函数添加一个参数。一个常见的错误是在声明新参数时忘记在第一个参数后添加逗号：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using a trailing comma in the first version of the function could have helped
    us to prevent this common mistake:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一个版本中使用尾随逗号可以帮助我们避免这个常见的错误：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using a trailing comma eliminates the possibility of forgetting the comma when
    adding a new argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尾随逗号消除了在添加新参数时忘记添加逗号的可能性：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: TypeScript will throw an error if we forget a comma, so trailing commas are
    not needed as much as they are when working with JavaScript. Trailing commas are
    optional, but using them is considered a good practice by many JavaScript and
    TypeScript engineers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记添加逗号，TypeScript将抛出错误，因此与使用JavaScript相比，尾随逗号不是那么必要。尾随逗号是可选的，但许多JavaScript和TypeScript工程师认为使用它们是一种良好的实践。
- en: Functions with optional parameters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: 'Unlike JavaScript, the TypeScript compiler will throw an error if we attempt
    to invoke a function without providing the exact number and types of parameters
    that its signature declares. Let''s look at a code sample to demonstrate this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 不同，如果尝试调用一个函数而没有提供其签名声明的确切参数数量和类型，TypeScript 编译器将抛出一个错误。让我们看一个代码示例来演示这一点：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding function is called `add` and will take three numbers as parameters,
    named `foo`, `bar`, and `foobar`. If we attempt to invoke this function without
    providing exactly three numbers, we will get a compilation error indicating that
    the supplied parameters do not match the function''s signature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数名为 `add`，它将接受三个数字作为参数，参数名称分别为 `foo`、`bar` 和 `foobar`。如果我们尝试调用此函数而不提供恰好三个数字，我们将得到一个编译错误，表明提供的参数与函数的签名不匹配：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are scenarios in which we might want to be able to call the function without
    providing all its arguments. TypeScript features optional parameters in functions
    to help us to increase the flexibility of our functions and overcome such scenarios.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望能够在不提供所有参数的情况下调用函数。TypeScript 在函数中提供了可选参数，以帮助我们增加函数的灵活性并克服这些情况。
- en: 'We can indicate to the TypeScript compiler that we want a function''s parameter
    to be optional by appending the `?` character to its name. Let''s update the previous
    function to transform the required `foobar` parameter into an optional parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在参数名称后附加 `?` 字符来向 TypeScript 编译器指示我们希望函数的参数是可选的。让我们更新前面的函数，将必需的 `foobar`
    参数转换为可选参数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note how we have changed the `foobar` parameter name to `foobar?`, and how
    we are checking the type of `foobar` inside the function to identify whether the
    parameter was supplied as an argument to the function or not. After implementing
    these changes, the TypeScript compiler will allow us to invoke the function without
    errors when we supply two or three arguments to it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `foobar` 参数名称更改为 `foobar?`，以及我们如何在函数内部检查 `foobar` 的类型，以确定该参数是否作为参数传递给了函数。在实施这些更改后，TypeScript
    编译器将允许我们在提供两个或三个参数时调用该函数而不会出错：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to note that the optional parameters must always be located
    after the required parameters in the function's parameter list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可选参数必须始终位于函数参数列表中的必选参数之后。
- en: Functions with default parameters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: When a function has some optional parameters, we must check whether an argument
    has been passed to the function (just like we did in the previous example) to
    prevent potential errors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有一些可选参数时，我们必须检查是否向函数传递了参数（就像我们在前面的例子中所做的那样），以防止潜在的错误。
- en: 'There are some scenarios where it would be more useful to provide a default
    value for a parameter when it is not supplied than making it an optional parameter.
    Let''s rewrite the `add` function (from the previous section) using the inline
    `if` structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为参数提供一个默认值（而不是将其作为可选参数）可能更有用。让我们重写 `add` 函数（来自上一节），使用内联 `if` 结构：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is nothing wrong with the preceding function, but we can improve its
    readability by providing a default value for the `foobar` parameter instead of
    using an optional parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数本身没有问题，但我们可以通过为 `foobar` 参数提供一个默认值来提高其可读性，而不是使用可选参数：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To indicate that a function parameter is optional, we need to provide a default
    value using the `=` operator when declaring the function''s signature. After compiling
    the preceding code examples, the TypeScript compiler will generate an `if` structure
    in the JavaScript output to set a default value for the `foobar` parameter if
    it is not passed as an argument to the function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个函数参数是可选的，我们需要在声明函数签名时使用 `=` 运算符提供默认值。在编译前面的代码示例后，TypeScript 编译器将在 JavaScript
    输出中生成一个 `if` 结构，以设置 `foobar` 参数的默认值，如果它没有被作为函数的参数传递：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is great because the TypeScript compiler generated the code necessary for
    us to prevent potential runtime errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为 TypeScript 编译器为我们生成了防止潜在运行时错误的代码。
- en: 'The `void 0` parameter is used by the TypeScript compiler to check whether
    a variable is undefined. While most developers use the undefined variable to perform
    this kind of check, most compilers use `void 0` because it will always evaluate
    as undefined. Checking against an undefined variable is less secure because its
    value could have been modified, as demonstrated by the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`void 0`参数由TypeScript编译器用于检查变量是否未定义。虽然大多数开发者使用`undefined`变量来执行这种检查，但大多数编译器使用`void
    0`，因为它始终评估为`undefined`。与未定义变量进行比较的安全性较低，因为其值可能已被修改，如下面的代码片段所示：'
- en: '`function test() {`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`function test() {`'
- en: '`    var undefined = 2; // 2`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`    var undefined = 2; // 2`'
- en: '`    console.log(undefined === 2); // true`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`    console.log(undefined === 2); // true`'
- en: '`}`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: Just like optional parameters, default parameters must always be located after
    any required parameters in the function's parameter list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可选参数一样，默认参数必须始终位于函数参数列表中的任何必需参数之后。
- en: Functions with REST parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有REST参数的函数
- en: 'We have learned how to use optional and default parameters to increase the
    number of ways that we can invoke a function. Let''s return one more time to the
    previous example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用可选和默认参数来增加调用函数的方式。让我们再次回到之前的例子：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have learned how to invoke the `add` function with two or three parameters,
    but what if we wanted to allow other developers to pass four or five parameters
    to our function? We would have to add two extra default or optional parameters.
    And what if we wanted to allow them to pass as many parameters as they need? The
    solution to this possible scenario is the use of REST parameters. The REST parameter
    syntax allows us to represent an indefinite number of arguments as an array:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用两个或三个参数调用`add`函数，但如果我们想允许其他开发者向我们的函数传递四个或五个参数呢？我们就必须添加两个额外的默认或可选参数。如果我们想允许他们传递他们需要的任意数量的参数呢？解决这种可能场景的方法是使用REST参数。REST参数语法允许我们将不定数量的参数表示为一个数组：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the preceding code snippet, we have replaced the function
    parameters `foo`, `bar`, and `foobar` with just one parameter named `foo`. Note
    that the name of the parameter `foo` is preceded by an ellipsis (a set of three
    periods—not the actual ellipsis character). A REST parameter must be of an array
    type or we will get a compilation error. We can now invoke the `add` function
    with as many parameters as we need:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个代码片段所示，我们将函数参数`foo`、`bar`和`foobar`替换为只有一个参数名为`foo`。请注意，参数`foo`的名称前面有一个省略号（一组三个点，而不是实际的省略号字符）。REST参数必须是数组类型，否则我们将得到编译错误。现在我们可以使用我们需要的任意数量的参数来调用`add`函数：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although there is no specific limit to the theoretical maximum number of arguments
    that a function can take, there are, of course, practical limits. These limits
    are entirely implementation-dependent and, most likely, will also depend on exactly how
    we are calling the function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数可以接受的理论最大参数数量没有具体限制，但当然存在实际限制。这些限制完全取决于实现，并且很可能会也取决于我们调用函数的确切方式。
- en: JavaScript functions have a built-in object called the `arguments` object. This
    object is available as a local variable named `arguments`. The `arguments` variable
    contains an object like an array that contains the arguments used when the function
    was invoked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数有一个内置对象，称为`arguments`对象。该对象作为名为`arguments`的局部变量可用。`arguments`变量包含一个类似于数组的对象，其中包含函数被调用时使用的参数。
- en: The `arguments` object exposes some of the methods and properties provided by
    a standard array, but not all of them. Refer to the documentation at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)
    to learn more about its peculiarities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`对象暴露了一些标准数组提供的方法和属性，但并非全部。有关其特性的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)文档。'
- en: 'If we examine the JavaScript output, we will notice that TypeScript iterates
    the `arguments` object to add the values to the `foo` variable:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查JavaScript的输出，我们会注意到TypeScript会迭代`arguments`对象，将值添加到`foo`变量中：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can argue that this is an extra, unnecessary iteration over the function''s
    parameters. Even though it is hard to imagine this extra iteration becoming a
    performance issue, if you think that this could be a problem for the performance
    of your application, you may want to consider avoiding the use of REST parameters
    and use an array as the only parameter of the function instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争辩说，这是对函数参数的额外、不必要的迭代。尽管很难想象这种额外的迭代会成为性能问题，但如果您认为这可能会影响您应用程序的性能，您可能希望考虑避免使用REST参数，而是使用数组作为函数的唯一参数：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding function takes an array of numbers as its only parameter. The
    invocation API will be a little bit different from the REST parameters, but we
    will effectively avoid the extra iteration over the function''s argument list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能只接受一个数字数组作为其唯一参数。调用API将与REST参数略有不同，但我们将有效地避免在函数参数列表上额外的迭代：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Function overloading
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'Function overloading, or method overloading, is the ability to create multiple
    methods with the same name and a different number of parameters or types. In TypeScript,
    we can overload a function by specifying all function signatures (known as the **overload
    signatures**) of a function, followed by a signature (known as the **implementation
    signature**). Let''s look at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载，或方法重载，是创建具有相同名称但参数数量或类型不同的多个方法的能力。在TypeScript中，我们可以通过指定一个函数的所有函数签名（称为**重载签名**），然后是一个签名（称为**实现签名**）来重载一个函数。让我们看一个例子：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding example, we have overloaded the function test
    three times by adding a signature that takes a string as its only parameter, another
    function that takes a number, and a final signature that takes a boolean as its
    unique parameter. It is important to note that all function signatures must be
    compatible; so if, for example, one of the signatures tries to return a number
    while another tries to return a string, we will get a compilation error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在前面的例子中看到的那样，我们通过添加一个只接受字符串作为唯一参数的签名、另一个接受数字的函数和一个最终接受布尔值作为唯一参数的签名，三次重载了函数test。重要的是要注意，所有函数签名都必须兼容；因此，如果例如，一个签名试图返回一个数字，而另一个试图返回一个字符串，我们将得到一个编译错误：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The implementation signature must be compatible with all the overloaded signatures,
    always be the last in the list, and take the `any` type or a union type as the
    type of its parameters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实现签名必须与所有重载签名兼容，始终是列表中的最后一个，并且其参数的类型必须是`any`类型或联合类型。
- en: 'Invoking the function providing arguments that don''t match any of the types
    that are declared by the overload signatures will lead us to a compilation error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数并提供不匹配重载签名中声明的任何类型的参数将导致我们得到一个编译错误：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specialized overloading signature
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用重载签名
- en: 'We can use a specialized signature to create multiple methods with the same
    name and number of parameters, but a different return type. To create a specialized
    signature, we must indicate the type of function parameter using a string. The
    string literal is used to identify which of the function overloads is invoked:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用专用签名创建具有相同名称和参数数量但不同返回类型的多个方法。要创建专用签名，我们必须使用字符串指示函数参数的类型。字符串字面量用于识别调用了哪个函数重载：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we have declared three **specialized overloaded signatures**
    and one **nonspecialized signature** for the function named `createElement`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为名为`createElement`的函数声明了三个**专用重载签名**和一个**非专用签名**。
- en: When we declare a specialized signature in an object, it must be assignable
    to at least one nonspecialized signature in the same object. This can be observed
    in the preceding example, as the `createElement` property belongs to a type that
    contains three specialized signatures, all of which are assignable to the nonspecialized
    signature in the type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在对象中声明一个专用签名时，它必须可以分配给该对象中至少一个非专用签名。这可以从前面的例子中观察到，因为`createElement`属性属于一个包含三个专用签名的类型，所有这些都可以分配给该类型的非专用签名。
- en: When writing overloaded declarations, we must list the nonspecialized signature
    last.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写重载声明时，我们必须将非专用签名放在最后。
- en: Function scope
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作用域
- en: Low-level languages, such as C, have low-level memory management features. In
    programming languages with a higher level of abstraction, such as TypeScript,
    values are allocated when variables are created and automatically cleared from
    memory when they are not used anymore. The process that cleans the memory is known
    as **garbage collection** and is performed by the JavaScript runtime garbage collector.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 低级语言，如 C 语言，具有低级内存管理功能。在具有更高抽象级别的编程语言中，如 TypeScript，变量在创建时分配内存，当不再使用时自动从内存中清除。清理内存的过程称为
    **垃圾回收**，由 JavaScript 运行时的垃圾回收器执行。
- en: The garbage collector does a great job, but it is a mistake to assume that it
    will always prevent us from facing a memory leak. The garbage collector will clear
    a variable from the memory whenever the variable is out of the scope. It is important
    to understand how the TypeScript scope works, so we will now look at the life
    cycle of the variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器做得很好，但认为它总能防止我们遇到内存泄漏是错误的。垃圾回收器会在变量超出作用域时从内存中清除变量。理解 TypeScript 作用域的工作方式很重要，因此我们现在将查看变量的生命周期。
- en: Some programming languages use the structure of the program source code to determine
    what variables we are referring to (**lexical scoping**), while others use the
    runtime state of the program stack to determine what variable we are referring
    to (**dynamic scoping**). The majority of modern programming languages use lexical
    scoping (including TypeScript). Lexical scoping tends to be dramatically easier
    to understand for both humans and analysis tools than dynamic scoping.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用程序源代码的结构来确定我们引用的是哪个变量（**词法作用域**），而另一些则使用程序调用栈的运行时状态来确定我们引用的是哪个变量（**动态作用域**）。大多数现代编程语言使用词法作用域（包括
    TypeScript）。词法作用域通常比动态作用域更容易被人类和分析工具理解。
- en: 'While in most lexical-scoped programming languages, variables are scoped to
    a block (a section of code delimited by curly braces `{}`), in TypeScript (and
    JavaScript), variables are scoped to a function, as demonstrated by the following
    code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数词法作用域编程语言中，变量的作用域限定在代码块（由花括号 `{}` 分隔的代码部分）内，而在 TypeScript（和 JavaScript）中，变量的作用域限定在函数内，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding function named `foo` contains an `if` structure. We have declared
    a numeric variable named `bar` inside the `if` structure, and later, we have attempted
    to show the value of the `bar` variable using the `log` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的名为 `foo` 的函数包含一个 `if` 结构。我们在 `if` 结构内部声明了一个名为 `bar` 的数值变量，后来我们尝试使用 `log`
    函数显示 `bar` 变量的值。
- en: We might think that the preceding code sample would throw an error in the fifth
    line because the `var` variable should be out of the scope when the `log` function
    is invoked. However, if we invoke the `foo` function, the `log` function will
    be able to display the `bar` variable without errors because all the variables
    inside a function will be in the scope of the entire function body, even if they
    are inside another block of code (except a function block).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为前面的代码示例在第五行会抛出错误，因为当调用 `log` 函数时 `var` 变量应该超出作用域。然而，如果我们调用 `foo` 函数，`log`
    函数将能够无错误地显示 `bar` 变量，因为函数内部的所有变量都将处于整个函数体的作用域内，即使它们位于另一个代码块内（除了函数块）。
- en: This might seem confusing, but it is easy to understand once we know that at
    runtime, all the variable declarations are moved to the top of a function before
    the function is executed. This behavior is known as **hoisting**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些令人困惑，但一旦我们知道在运行时，所有变量声明都会在函数执行之前移动到函数顶部，这种行为就很容易理解了。这种行为被称为 **提升**。
- en: TypeScript is compiled to JavaScript and then executed—this means that a TypeScript
    application is a JavaScript application at runtime, and for this reason, when
    we refer to the TypeScript runtime, we are talking about the JavaScript runtime.
    We will learn in depth about the runtime in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译成 JavaScript 然后执行——这意味着 TypeScript 应用程序在运行时是一个 JavaScript 应用程序，因此，当我们提到
    TypeScript 运行时，我们实际上是在谈论 JavaScript 运行时。我们将在第 6 章 [理解运行时](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)中深入探讨运行时。
- en: 'Before the preceding code snippet is executed, the runtime will move the declaration
    of the `bar `variable to the top of our function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码片段之前，运行时会将 `bar` 变量的声明移动到我们的函数顶部：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This explains why it is possible to use a variable before it is declared. Let''s
    look at an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么可以在变量声明之前使用变量的原因。让我们来看一个例子：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code snippet, we have declared a `foo `function, and in its
    body, we have assigned the value `0` to a variable named `bar`. At this point,
    the variable has not been declared. In the second line, we are declaring the variable
    `bar` and its type. In the last line, we are displaying the value of `bar` using
    the alert function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个`foo`函数，并在其函数体内将值`0`赋给名为`bar`的变量。此时，该变量尚未声明。在第二行，我们声明了变量`bar`及其类型。在最后一行，我们使用alert函数显示`bar`的值。
- en: 'Because declaring a variable anywhere inside a function (except another function)
    is equivalent to declaring it at the top of the function, the `foo` function is
    transformed into the following at runtime:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在函数内部（除了另一个函数）的任何地方声明变量（等同于在函数顶部声明），`foo`函数在运行时会转换为以下形式：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because developers with a background in programming languages with block scope,
    such as Java or C#, are not used to the function scope, it is one of the most
    criticized characteristics of JavaScript. The people in charge of the development
    of the ECMAScript 6 specification are aware of this, and as a result, they have
    introduced the keywords `let` and `const`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有像Java或C#这样的具有块作用域的编程语言背景的开发者不习惯函数作用域，这是JavaScript最被批评的特性之一。ECMAScript 6规范的开发负责人对此有所了解，因此他们引入了`let`和`const`关键字。
- en: 'The `let` keyword allows us to set the scope of a variable to a block (`if`,
    `while`, `for`, and so on) rather than a function. We can update the first example
    in this section to showcase how `let` works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`关键字允许我们将变量的作用域设置为块（`if`、`while`、`for`等），而不是函数。我们可以更新本节中的第一个示例来展示`let`是如何工作的：'
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `bar` variable is now declared using the `let` keyword, and as a result,
    it is only accessible inside the `if` block. The variable is not hoisted to the
    top of the `foo` function and cannot be accessed by the `alert` function outside
    the `if` statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`bar`变量使用`let`关键字声明，因此它只能在`if`块内部访问。变量不会被提升到`foo`函数的顶部，并且不能在`if`语句外部通过`alert`函数访问。
- en: 'While variables defined with `const` follow the same scope rules as variables
    declared with `let`, they can''t be reassigned:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`const`声明的变量遵循与`let`声明的变量相同的范围规则，但它们不能被重新赋值：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we attempt to compile the preceding code snippet, we will get an error because
    the `bar` variable is not accessible outside the `if` statement (just like when
    we used the `let` keyword), and a new error will occur when we try to assign a
    new value to the `bar` variable. The second error occurs because it is not possible
    to assign a new value to a constant variable once the variable has already been
    initialized.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译前面的代码片段，我们会得到一个错误，因为`bar`变量在`if`语句外部不可访问（就像我们使用`let`关键字时一样），并且当我们尝试给`bar`变量赋新值时，会出现新的错误。第二个错误发生是因为一旦变量已经被初始化，就无法给常量变量赋新值。
- en: Variables declared with the `const` keyword cannot be reassigned, but are not
    immutable. When we say that a variable is immutable, we means that it cannot be
    modified. We will learn more about immutability in [Chapter 7](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml),
    *Functional Programming with TypeScript*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`关键字声明的变量不能重新赋值，但不是不可变的。当我们说一个变量是不可变的，我们的意思是它不能被修改。我们将在[第7章](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml)中了解更多关于不可变性的内容，*使用TypeScript进行函数式编程*。
- en: Immediately invoked functions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调用的函数
- en: 'An **immediately invoked function expression** (**IIFE**) is a design pattern
    that produces a lexical scope using function scoping. An IIFE can be used to avoid
    variable hoisting from within blocks, or to prevent us from polluting the global
    scope—for example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式（**IIFE**）是一种设计模式，它使用函数作用域创建词法作用域。IIFE可以用来避免在块内部提升变量，或者防止我们污染全局作用域——例如：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, we have wrapped the declaration of a variable (`foo`)
    with an IIFE. The `foo` variable is scoped to the IIFE function and is not available
    in the global scope, which explains the error that is thrown when we try to access
    it on the last line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们用立即执行函数表达式（IIFE）包裹了变量的声明（`foo`）。`foo`变量的作用域限定在IIFE函数内部，并且不在全局作用域中，这解释了当我们尝试在最后一行访问它时抛出的错误。
- en: The `bar` variable is a global. Therefore, it can be accessed from both the
    inside and the outside of the IIFE function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar` 变量是全局的。因此，它可以从 IIFE 函数的内部和外部访问。'
- en: 'We can also pass a variable to the IIFE to have better control over the creation
    of variables outside its scope:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将变量传递给 IIFE，以更好地控制其作用域外变量的创建：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Furthermore, IIFE can help us to simultaneously allow public access to methods
    while retaining privacy for variables defined within the function. Let''s look
    at an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IIFE 可以帮助我们同时允许对方法进行公共访问，同时保留函数内部定义的变量的隐私。让我们来看一个例子：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have defined a class named `Counter`, which has a private numeric attribute
    named `_i`. The class also has methods to get and set the value of the private
    `_i `property.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Counter` 的类，该类有一个名为 `_i` 的私有数值属性。该类还具有获取和设置私有 `_i` 属性值的函数。
- en: By convention, TypeScript and JavaScript developers usually name private variables
    with names preceded by an underscore (`_`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，TypeScript 和 JavaScript 开发者通常使用以下划线（`_`）开头命名的名称来命名私有变量。
- en: We have also created an instance of the `Counter` class and invoked the `set`,
    `get`, and `increment` methods to observe that everything is working as expected.
    If we attempt to access the `_i` property in an instance of `Counter`, we will
    get an error because the variable is `private`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个 `Counter` 类的实例，并调用了 `set`、`get` 和 `increment` 方法来观察一切是否按预期工作。如果我们尝试访问
    `Counter` 实例中的 `_i` 属性，我们将得到一个错误，因为该变量是 `private`。
- en: 'If we compile the preceding TypeScript code (only the class definition) and
    examine the generated JavaScript code, we will see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的 TypeScript 代码（仅类定义）编译并检查生成的 JavaScript 代码，我们将看到以下内容：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This generated JavaScript code will work perfectly in most scenarios, but if
    we execute it in a browser and try to create an instance of `Counter` and access
    its `_i `property, we will not get any errors because TypeScript will not generate
    runtime private properties for us. Sometimes we will need to write our classes
    in such a way that some properties are private at runtime—for example, if we release
    a library that will be used by JavaScript developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此生成的 JavaScript 代码在大多数场景下将完美运行，但如果我们在浏览器中执行它并尝试创建 `Counter` 的实例并访问其 `_i` 属性，我们将不会得到任何错误，因为
    TypeScript 不会为我们生成运行时私有属性。有时我们需要以某种方式编写我们的类，以便某些属性在运行时是私有的——例如，如果我们发布一个将被 JavaScript
    开发者使用的库。
- en: 'We can also use IIFE to simultaneously allow public access to methods while
    retaining privacy for variables defined within the function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 IIFE 同时允许对方法进行公共访问，同时保留函数内部定义的变量的隐私：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, everything is almost identical to the TypeScript's
    generated JavaScript, except now the variable `_i` is an object in the `Counter`
    closure instead of a property of the `Counter` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一切几乎与 TypeScript 生成的 JavaScript 相同，但现在 `_i` 变量是 `Counter` 闭包中的一个对象，而不是
    `Counter` 类的一个属性。
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure *remembers* the environment (variables
    in the scope) in which it was created. We will discover more about closures in
    [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是引用独立（自由）变量的函数。换句话说，闭包中定义的函数*记住*了其创建时的环境（作用域内的变量）。我们将在[第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时*中了解更多关于闭包的内容。
- en: 'If we run the generated JavaScript output in a browser and try to invoke the
    `_i` property directly, we will notice that the property is now private at runtime:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行生成的 JavaScript 输出并尝试直接调用 `_i` 属性，我们会注意到该属性现在在运行时是私有的：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In some cases, we will need to have precise control over scope and closures,
    and our code will end up looking much more like JavaScript. As long as we write
    our application components (classes, modules, and so on) to be consumed by other
    TypeScript components, we will rarely have to worry about implementing runtime
    private properties. We will look in depth at the TypeScript runtime in [Chapter
    6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要对作用域和闭包有精确的控制，我们的代码最终会看起来更像 JavaScript。只要我们将应用程序组件（类、模块等）编写为供其他 TypeScript
    组件使用，我们就很少需要担心实现运行时私有属性。我们将在[第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时*中深入探讨
    TypeScript 的运行时。
- en: Tag functions and tagged templates
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签函数和标签模板
- en: 'In TypeScript, we can use template strings such as the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以使用如下模板字符串：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use a template string to create a special kind of function known as a
    **tag function**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模板字符串创建一种特殊类型的函数，称为**标签函数**。
- en: We can use a tag function to extend or modify the standard behavior of template
    strings. When we apply a tag function to a template string, the template string
    becomes a tagged template.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标签函数来扩展或修改模板字符串的标准行为。当我们将标签函数应用于模板字符串时，模板字符串就变成了一个标签模板。
- en: 'We are going to implement a tag function named `htmlEscape`. To use a tag function,
    we must use the name of the function followed by a template string:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个名为 `htmlEscape` 的标签函数。要使用标签函数，我们必须使用函数名后跟一个模板字符串：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A tag template must return a string and take the following arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 标签模板必须返回一个字符串并接受以下参数：
- en: A `TemplateStringsArray` that contains all the static literals in the template
    string (`<h1>` and `</h1>` in the preceding example) is passed as the first argument.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含模板字符串中所有静态字面量（在先前的示例中为 `<h1>` 和 `</h1>`）的 `TemplateStringsArray` 作为第一个参数传递。
- en: The `TemplateStringsArray` type is declared by the `lib.d.ts` file. We will
    learn more about the `lib.d.ts` file in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateStringsArray` 类型由 `lib.d.ts` 文件声明。我们将在第 9 章*自动化您的开发工作流程*中了解更多关于 `lib.d.ts`
    文件的内容。'
- en: A REST parameter is passed as the second parameter. The REST parameter contains
    all the values in the template string (`name` and `surname`, in the preceding
    example).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数作为第二个参数传递。可变参数包含模板字符串中的所有值（在先前的示例中为 `name` 和 `surname`）。
- en: 'The signature of a tag function looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 标签函数的签名如下所示：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s implement the `htmlEscape` tag function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `htmlEscape` 标签函数：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then invoke the function as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按如下方式调用该函数：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The template string contains values and literals. The `htmlEscape` function
    iterates through them and ensures that the HTML code is escaped in the values
    to avoid possible code injection attacks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串包含值和字面量。`htmlEscape` 函数遍历它们，并确保在值中转义 HTML 代码，以避免可能的代码注入攻击。
- en: The main benefit of using a tagged function is that it allows us to create custom
    template string processors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签函数的主要好处是它允许我们创建自定义模板字符串处理器。
- en: Asynchronous programming in TypeScript
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 中的异步编程
- en: Now that we have seen how to work with functions, we will explore how we can
    use them, together with some native APIs, to write asynchronous applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用函数，我们将探讨如何结合一些原生 API 使用它们来编写异步应用程序。
- en: Callbacks and higher-order functions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调与高阶函数
- en: In TypeScript, functions can be passed as arguments to another function. Functions
    can also be returned by another function. A function passed to another as an argument
    is known as a **callback**. Functions that accept functions as parameters (callbacks)
    or return functions are known as **higher-order functions**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，函数可以作为参数传递给另一个函数。函数也可以由另一个函数返回。传递给另一个函数作为参数的函数称为**回调**。接受函数作为参数（回调）或返回函数的函数称为**高阶函数**。
- en: 'Callbacks are usually anonymous functions. They can be declared before they
    are passed to the higher-order function, as demonstrated by the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常是匿名函数。它们可以在传递给高阶函数之前声明，如下面的示例所示：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, callbacks are declared inline, at the same point at which they are
    passed to the higher-order function, as demonstrated by the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回调是在行内声明的，与传递给高阶函数的点相同，如下面的示例所示：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Arrow functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: In TypeScript, we can declare a function using a `function` expression or an
    arrow function. An arrow function has a shorter syntax than a function expression,
    and lexically binds the value of the `this` operator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以使用 `function` 表达式或箭头函数声明一个函数。箭头函数的语法比函数表达式更短，并且词法绑定 `this`
    操作符的值。
- en: 'The `this` operator behaves a little differently in TypeScript and JavaScript
    compared to other popular programming languages. When we define a class in TypeScript,
    we can use the `this` operator to refer to the class. Let''s look at an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 和 JavaScript 中，`this` 操作符的行为与其他流行编程语言略有不同。当我们使用 TypeScript 定义一个类时，我们可以使用
    `this` 操作符来引用该类。让我们看一个例子：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have defined a `Person` class that contains a property of a string type called
    `name`. The class has a constructor and a `greet `method. We have created an instance
    named `person` and invoked the `greet` method, which uses the `this` operator internally to
    access the `_name `property. Inside the `greet` method, the `this` operator points
    to the object that encloses the `greet` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个包含一个名为 `name` 的字符串类型属性的 `Person` 类。该类有一个构造函数和一个 `greet` 方法。我们创建了一个名为
    `person` 的实例并调用了 `greet` 方法，该方法内部使用 `this` 操作符来访问 `_name` 属性。在 `greet` 方法内部，`this`
    操作符指向包含 `greet` 方法的对象。
- en: 'We must be careful when using the `this` operator, because in some scenarios
    it can point to the wrong value. Let''s add an extra method to the previous example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `this` 操作符时，我们必须小心，因为在某些场景中，它可能指向错误值。让我们向之前的示例添加一个额外的方法：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `greetDelay` method, we perform an almost identical operation to the
    one performed by the `greet` method. This time, the function takes a parameter
    named `time`, which is used to delay the `greet` message.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `greetDelay` 方法中，我们执行的操作几乎与 `greet` 方法执行的操作相同。这次，函数接受一个名为 `time` 的参数，该参数用于延迟
    `greet` 消息。
- en: To delay a message, we use the `setTimeout` function and a callback. As soon
    as we define an anonymous function (the callback), the `this` keyword changes
    its value and starts pointing to the anonymous function, which explains why the
    TypeScript compiler will throw an error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要延迟一个消息，我们使用 `setTimeout` 函数和一个回调。一旦我们定义了一个匿名函数（回调），`this` 关键字就会改变其值并开始指向匿名函数，这也解释了为什么
    TypeScript 编译器会抛出错误。
- en: 'As mentioned, an arrow function expression lexically binds the value of the
    `this` operator. This means that it `allows` us to add a function without altering
    the value of the `this` operator. Let''s replace the function expression from
    the previous example with an arrow function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，箭头函数表达式按词法绑定 `this` 操作符的值。这意味着它 `允许` 我们在不改变 `this` 操作符的值的情况下添加一个函数。让我们将之前示例中的函数表达式替换为箭头函数：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By using an arrow function, we can ensure that the `this` operator still points
    to the `Person` instance and not to the `setTimeout` callback. If we execute the
    `greetDelay` function, the name property will be displayed as expected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用箭头函数，我们可以确保 `this` 操作符仍然指向 `Person` 实例，而不是 `setTimeout` 回调。如果我们执行 `greetDelay`
    函数，将按预期显示名称属性。
- en: 'The following piece of code is generated by the TypeScript compiler. When compiling
    an arrow function, the TypeScript compiler will generate an alias for the `this`
    operator named `_this`. The alias is used to ensure that the `this` operator points
    to the right object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是由 TypeScript 编译器生成的。当编译箭头函数时，TypeScript 编译器将为 `this` 操作符生成一个名为 `_this`
    的别名。该别名用于确保 `this` 操作符指向正确的对象：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will look at the `this` operator in depth in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml) 中深入探讨 `this` 操作符，*理解运行时*。
- en: Callback hell
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调地狱
- en: We have learned that callbacks and higher-order functions are two powerful and
    flexible JavaScript and TypeScript features. However, the use of callbacks can
    lead to a maintainability issue known as **callback hell**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到回调和高级函数是 JavaScript 和 TypeScript 中的两个强大且灵活的功能。然而，回调的使用可能导致一个称为 **回调地狱**
    的可维护性问题。
- en: 'We are now going to write an example to showcase callback hell. We are going
    to write three functions with the same behavior, named `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个示例来展示回调地狱。我们将编写三个具有相同行为的函数，分别命名为 `doSomethingAsync`、`doSomethingElseAsync`
    和 `doSomethingMoreAsync`：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding functions simulate an asynchronous operation by using the `setTimeout`
    function. Each function takes a success callback, which is invoked if the operation
    is successful, and an error callback, which is invoked if something goes wrong.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能通过使用 `setTimeout` 函数模拟异步操作。每个函数都接受一个成功回调，如果操作成功则调用该回调，以及一个错误回调，如果发生错误则调用该回调。
- en: In real-world applications, asynchronous operations usually involve some interaction
    with hardware (for example, filesystems, networks, and so on). The interactions
    are known as **input/output** (**I**/**O**) operations. I/O operations can fail
    for many different reasons (for example, we get an error when we try to interact
    with the filesystem to save a new file and there is not enough space available
    on the hard disk).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，异步操作通常涉及与硬件的一些交互（例如，文件系统、网络等）。这些交互被称为**输入/输出（I/O）**操作。I/O操作可能因许多不同的原因而失败（例如，当我们尝试与文件系统交互以保存新文件时，硬盘上没有足够的空间）。
- en: The preceding functions generate a random number and throw an error if the number
    is lower than 25; we do this to simulate potential I/O errors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数生成一个随机数，如果数字小于25则抛出错误；我们这样做是为了模拟潜在的I/O错误。
- en: The preceding functions add the random number to an array that is passed as
    an argument to each of the functions. If no errors take place, the result of the
    final function (`doSomethingMoreAsync`) should be an array with three random numbers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将随机数添加到一个数组中，该数组作为参数传递给每个函数。如果没有发生错误，最终函数（`doSomethingMoreAsync`）的结果应该是一个包含三个随机数的数组。
- en: 'Now that the three functions have been declared, we can try to invoke them
    in order. We are going to use callbacks to ensure that `doSomethingMoreAsync`
    is invoked after `do``SomethingElseAsync`, and `doSomethingElseAsync` is invoked
    after `do``SomethingAsync`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在三个函数已经声明，我们可以尝试按顺序调用它们。我们将使用回调来确保`doSomethingMoreAsync`在`doSomethingElseAsync`之后被调用，而`doSomethingElseAsync`在`doSomethingAsync`之后被调用：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding example used a few nesting callbacks. The use of these kinds
    of nested callbacks is known as **callback hell** because they can lead to the
    following maintainability issues:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用了几个嵌套的回调。这类嵌套回调的使用被称为**回调地狱（callback hell）**，因为它们可能导致以下可维护性问题：
- en: Making the code harder to follow and understand
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更难以跟踪和理解
- en: Making the code harder to maintain (refactor, reuse, and so on)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更难以维护（重构、重用等）
- en: Making exception handling more difficult
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使异常处理更加困难
- en: Promises
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: 'After seeing how the use of callbacks can lead to some maintainability problems,
    we are now going to learn about promises and how they can be used to write better
    asynchronous code. The core idea behind promises is that a promise represents
    the result of an asynchronous operation. A promise must be in one of the following
    three states:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到回调的使用如何导致一些可维护性问题之后，我们现在将学习关于承诺（promises）以及如何使用它们来编写更好的异步代码。承诺背后的核心思想是，承诺代表异步操作的结果。承诺必须处于以下三种状态之一：
- en: '**Pending**: The initial state of a promise.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起（Pending）**：承诺的初始状态。'
- en: '**Fulfilled****/resolved**: The state of a promise representing a successful
    operation. The terms "fulfilled" and "resolved" are both commonly used to refer
    to this state.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已实现/已解决（Fulfilled/resolved）**：表示成功操作的承诺状态。术语“已实现”和“已解决”都常用来指代此状态。'
- en: '**Rejected**: The state of a promise representing a failed operation.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已拒绝（Rejected）**：表示失败操作的承诺状态。'
- en: 'Once a promise is fulfilled or rejected, its state can never change again.
    Let''s look at the basic syntax of a promise:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦承诺被实现或拒绝，其状态将无法再改变。让我们看看承诺的基本语法：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A `try...catch` statement is used here to showcase how we can explicitly fulfill
    or reject a promise. The `try...catch` statement is not needed for a `Promise`
    function because when an error is thrown in a promise callback, the promise will
    automatically be rejected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`try...catch`语句来展示我们如何显式地实现或拒绝一个承诺。对于`Promise`函数来说，`try...catch`语句是不必要的，因为当在承诺回调中抛出错误时，承诺将自动被拒绝。
- en: The preceding code snippet declares a function named `foo` that returns a promise.
    The promise contains a method named `then`, which accepts a function to be invoked
    when the promise is fulfilled. Promises also provide a method named `catch`, which
    is invoked when a promise is rejected.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为`foo`的函数，该函数返回一个承诺。承诺包含一个名为`then`的方法，该方法接受一个在承诺实现时将被调用的函数。承诺还提供了一个名为`catch`的方法，该方法在承诺被拒绝时被调用。
- en: 'Promises will not be recognized by the TypeScript compiler if we are targeting
    ES5, because the promises API is part of ES6\. We can solve this by enabling the
    `es2015.promise` type using the `lib` option in the `tsconfig``.json` file. Note
    that enabling this option will disable some types that are included by default
    and therefore break some of the examples. You will be able to solve the problems
    by including the `dom` and `es5` types, as well as by using the `lib` option in
    the `tsconfig``.json` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们针对 ES5，TypeScript 编译器将不会识别承诺，因为承诺 API 是 ES6 的一部分。我们可以通过在 `tsconfig.json`
    文件中使用 `lib` 选项启用 `es2015.promise` 类型来解决此问题。请注意，启用此选项将禁用默认包含的一些类型，因此会破坏一些示例。您可以通过包含
    `dom` 和 `es5` 类型，以及使用 `tsconfig.json` 文件中的 `lib` 选项来解决这些问题：
- en: '`"lib": [`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`"lib": [`'
- en: '`    "es2015.promise",`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`    "es2015.promise",`'
- en: '`    "dom",`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`    "dom",`'
- en: '`    "es5",`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`    "es5",`'
- en: '`    "es2015.generator", // new`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`    "es2015.generator", // new`'
- en: '`    "es2015.iterable" // new`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`    "es2015.iterable" // new`'
- en: '`]`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`]`'
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章 [自动化您的开发工作流程](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中了解更多关于 `lib`
    设置的信息。
- en: 'We are now going to rewrite the `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync` functions that we wrote during the callback hell example,
    using promises instead of callbacks:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重写我们在回调地狱示例中编写的 `doSomethingAsync`、`doSomethingElseAsync` 和 `doSomethingMoreAsync`
    函数，使用承诺而不是回调：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can chain the promises that are returned by each of the preceding functions
    using the promises API:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用承诺 API 链式调用每个前面函数返回的承诺：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code snippet is a little bit better than the one used in the callback
    example because we only needed to declare one exception handler instead of three
    exception handlers. This is possible because errors are propagated through the
    chain of promises.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段比回调示例中使用的代码要好一些，因为我们只需要声明一个异常处理程序而不是三个异常处理程序。这是可能的，因为错误是通过承诺链传播的。
- en: 'The preceding example has introduced some improvements. However, the promises
    API allows us to chain promises in a much less verbose way:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子介绍了一些改进。然而，承诺 API 允许我们以更简洁的方式链式调用承诺：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code is much easier to read and follow than the one used during
    the callback examples, but this is not the only reason to prefer promises over
    callbacks. Using promises also gives us better control over the execution flow
    of operations. Let's look at a couple of examples.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码比回调示例中使用的代码更容易阅读和跟踪，但这并不是唯一选择承诺而不是回调的原因。使用承诺还使我们能够更好地控制操作的执行流程。让我们看看几个例子。
- en: 'The promises API includes a method named `all`, which allows us to execute
    a series of promises in parallel and get all the results of each of the promises
    at once:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺 API 包含一个名为 `all` 的方法，它允许我们并行执行一系列承诺，并一次性获取每个承诺的所有结果：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The promises API also includes a method named `race`, which allows us to execute
    a series of promises in parallel and get the result of the first promise resolved:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺 API 还包含一个名为 `race` 的方法，它允许我们并行执行一系列承诺，并获取第一个解决的承诺的结果：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can use many different types of asynchronous flow control when working with
    promises:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当与承诺一起工作时，我们可以使用许多不同类型的异步流程控制：
- en: '**Concurrent**: The tasks are executed in parallel (like in the `Promise.all`
    example)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：任务并行执行（就像在 `Promise.all` 示例中）'
- en: '**Race**: The tasks are executed in parallel, and only the result of the fastest
    promise is returned'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞赛**：任务并行执行，只返回最快承诺的结果'
- en: '**Series**: A group of tasks is executed in sequence, but the preceding tasks
    do not pass arguments to the next task'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：一组任务按顺序执行，但前面的任务不会将参数传递给下一个任务'
- en: '**Waterfall**: A group of tasks is executed in sequence, and each task passes
    arguments to the next task (like in the example that preceded the `Promise.all`
    and `Promise.race` examples)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瀑布流**：一组任务按顺序执行，每个任务将参数传递给下一个任务（就像在 `Promise.all` 和 `Promise.race` 示例之前给出的例子）'
- en: '**Composite**: This is any combination of the preceding concurrent, series,
    and waterfall approaches'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：这是前面并发、序列和瀑布方法的任何组合'
- en: Covariant checking in callback parameters
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调参数中的协变检查
- en: 'TypeScript 2.4 changed the way the type system behaves internally to improve
    the error detection in nested callbacks and promises:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 2.4 改变了类型系统内部的行为方式，以改善嵌套回调和承诺中的错误检测：
- en: TypeScript's checking of callback parameters is now covariant concerning immediate
    signature checks. Previously it was bivariant, which could sometimes let incorrect
    types through. Basically, this means that callback parameters and classes that
    contain callbacks are checked more carefully, so TypeScript will require stricter
    types in this release. This is particularly true of Promises and Observables due
    to the way in which their APIs are specified.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript对回调参数的检查现在与立即签名检查是协变的。之前它是双变的，有时可能会让错误类型通过。基本上，这意味着回调参数和包含回调的类将更加仔细地检查，因此TypeScript在这个版本中将要求更严格的类型。这尤其适用于Promises和Observables，因为它们的API指定方式。
- en: 'In TypeScript versions before 2.4, the following example was considered valid,
    and no errors were thrown:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 2.4之前的版本中，以下示例被认为是有效的，并且没有抛出错误：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In TypeScript versions following the 2.4 release, we need to add the complete
    signature of `nestedCallback` to solve this error:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 2.4版本之后的版本中，我们需要添加`nestedCallback`的完整签名来解决这个错误：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Thanks to the internal change in the TypeScript type system, the following
    error is also detected:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了TypeScript类型系统的内部变化，以下错误也被检测到了：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Before TypeScript 2.4, the preceding promise would have been inferred as `Promise<{}>`
    because we forgot to add the generic `<number>` argument when we created an instance
    of the `Promise` class. The `error` string would then have been considered a valid
    instance of `{}`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 2.4之前，前面的promise会被推断为`Promise<{}>`，因为我们创建`Promise`类的实例时忘记了添加泛型`<number>`参数。然后`error`字符串会被认为是`{}`的有效实例。
- en: This is a clear example of why it is recommended that you upgrade TypeScript
    regularly. Each new version of TypeScript introduces new features that are able
    to detect new errors for us.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个清晰的例子，说明了为什么建议您定期升级TypeScript。TypeScript的每个新版本都引入了新的功能，能够为我们检测到新的错误。
- en: Generators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: If we invoke a function in TypeScript, we can assume that once the function
    starts running, it will always run to completion before any other code can run.
    However, a new kind of function that may be paused in the middle of execution—one
    or many times—and resumed later, allowing other code to run during these paused
    periods, has recently been added to the ECMAScript specification. These new kinds
    of functions are known as **generators**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在TypeScript中调用一个函数，我们可以假设一旦函数开始运行，它将始终运行到完成，然后其他代码才能运行。然而，一种新的函数类型最近被添加到ECMAScript规范中，这种函数可以在执行过程中暂停——一次或多次——并在稍后恢复，允许在这些暂停期间运行其他代码。这些新类型的函数被称为**生成器**。
- en: 'A generator represents a sequence of values. The interface of a `generator`
    object is just an **iterator**. An iterator implements the following interface:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器代表一系列值。`generator`对象的接口只是一个**迭代器**。迭代器实现了以下接口：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `next()`function can be invoked until it runs out of values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用`next()`函数，直到它耗尽值。
- en: 'We can define a generator by using the `function` keyword followed by an asterisk
    (`*`). The `yield` keyword is used to stop the execution of the function and return
    a value. Let''s look at an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`function`关键字后跟一个星号（`*`）来定义一个生成器。`yield`关键字用于停止函数的执行并返回一个值。让我们看一个例子：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that some additional types are required by generators if you are targeting
    ES5\. You will need to add `es2015.generator` and `es2015.iterable` to your `tsconfig.json`
    file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您针对ES5，生成器需要一些额外的类型。您需要将`es2015.generator`和`es2015.iterable`添加到您的`tsconfig.json`文件中：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), **Automating
    Your Development Workflow**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章[自动化您的开发工作流程](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中了解更多关于`lib`设置的内容。
- en: 'As we can see, the preceding iterator has five steps. The first time we call
    `next`, the function will be executed until it reaches the first `yield` statement,
    and then it will return the value `1` and stop the execution of the function until
    we invoke the generator''s `next` method again. As we can see, we are now able
    to stop the function''s execution at a given point. This allows us to write infinite
    loops without causing a stack overflow, as demonstrated in the following example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的迭代器有五个步骤。第一次调用`next`时，函数将执行直到遇到第一个`yield`语句，然后它将返回值`1`并停止函数的执行，直到我们再次调用生成器的`next`方法。如我们所见，我们现在能够在给定点停止函数的执行。这允许我们编写不会导致栈溢出的无限循环，如下面的例子所示：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The generator will open possibilities for synchronicity, as we can call the
    generator's `next` method after an asynchronous event has occurred.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器将打开同步的可能性，因为我们可以在异步事件发生后调用生成器的`next`方法。
- en: Asynchronous functions – async and await
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数 – async 和 await
- en: '**Asynchronous functions** are a TypeScript feature that arrived with the TypeScript
    1.6 release. Developers can use the `await` keyword to wait for the function results
    without blocking the normal execution of the program.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步函数**是TypeScript 1.6版本引入的一个特性。开发者可以使用`await`关键字等待函数结果，而不会阻塞程序的正常执行。'
- en: Using asynchronous functions helps to increase the readability of a piece of
    code when compared with the use of promises or callbacks, but technically, we
    can achieve the same features using both promises and synchronous code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步函数有助于提高代码的可读性，与使用promises或回调函数相比，但技术上我们可以使用两者都实现相同的功能。
- en: 'Let''s take a look at a basic `async`/`await` example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的`async`/`await`示例：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code snippet declares a promise named `p`. This promise is the
    piece of code whose execution we will wait for. While waiting, the program execution
    will not be blocked because JavaScript allows us to wait for an asynchronous function
    named `fn` without blocking it. As we can see, the `fn` function is preceded by
    the `async` keyword, which is used to indicate to the compiler that it is an asynchronous
    function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为`p`的promise。这个promise是我们将要等待的代码片段的执行。在等待的过程中，程序执行不会被阻塞，因为JavaScript允许我们在不阻塞的情况下等待名为`fn`的异步函数。正如我们所见，`fn`函数前面有`async`关键字，它用来告诉编译器这是一个异步函数。
- en: Inside the function, the `await` keyword is used to suspend execution until
    the promise `p` is fulfilled or rejected. As we can see, the syntax is less verbose
    and cleaner than it would have been if we used the promises API or callbacks.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`await`关键字用于挂起执行，直到promise `p`被实现或拒绝。正如我们所见，语法比使用promises API或回调函数时的语法更简洁。
- en: The `fn `function returns a promise at runtime because it is an `async` function.
    This should explain why we need to use the `then` callback to invoke it at the
    end of the code snippet.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn`函数在运行时返回一个promise，因为它是一个`async`函数。这应该解释了为什么我们需要在代码片段的末尾使用`then`回调来调用它。'
- en: 'The following code snippet showcases how we can declare an asynchronous function
    named `invokeTaskAsync`. The asynchronous function uses the `await` keyword to
    wait for the result of the `doSomethingAsync`, `doSomethingElseAsync`, and `doSomethingMoreAsync`
    functions that we declared during the promises example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何声明一个名为`invokeTaskAsync`的异步函数。这个异步函数使用`await`关键字等待我们在promise示例中声明的`doSomethingAsync`、`doSomethingElseAsync`和`doSomethingMoreAsync`函数的结果：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `invokeTaskAsync` function is asynchronous, and therefore, it will return
    a promise at runtime. This means that we can use the promises API to await a result
    or catch potential errors respectively:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeTaskAsync`函数是异步的，因此它在运行时会返回一个promise。这意味着我们可以使用promises API来等待结果或分别捕获潜在的错误：'
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also define asynchronous IIFE as a convenient way to use the `async`
    and `await` keywords:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将异步IIFE定义为使用`async`和`await`关键字的一种方便方式：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Using an async IIFE is very useful because it is very common to not be able
    to use the `await` keyword outside of a function—for example, in the entry point
    of an application. We can use the async IIFE to overcome this limitation:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步IIFE非常有用，因为通常我们无法在函数之外使用`await`关键字——例如，在应用程序的入口点。我们可以使用异步IIFE来克服这个限制：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Asynchronous generators
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步生成器
- en: 'We have already learned about the interface that is implemented by all iterators:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了所有迭代器实现的接口：
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, we haven''t yet learned about the interface that is implemented by
    all asynchronous iterators:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有学习到所有异步迭代器实现的接口：
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'An asynchronous iterator returns a promise every time we invoke the `next`
    method. The following code snippet demonstrates how asynchronous iterators can
    be very useful when used in conjunction with asynchronous functions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用`next`方法时，异步迭代器都会返回一个promise。以下代码片段演示了异步迭代器如何与异步函数结合使用时非常有用：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Some additional types are required by asynchronous iterators if we are targeting
    ES5\. You will need to add `esnext.asynciterable` to your `tsconfig.json` file.
    We are also going to need to enable an additional setting in our `tsconfig.json`
    to provide full support for iterables (for example, using `for...of` control flow
    statements, the spread operator or object destructuring) when targeting ES3 or
    ES5:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们针对ES5，异步迭代器需要一些额外的类型。您需要在`tsconfig.json`文件中添加`esnext.asynciterable`。我们还需要在`tsconfig.json`中启用一个额外的设置，以提供对可迭代的全面支持（例如，使用`for...of`控制流语句、扩展运算符或对象解构）当针对ES3或ES5时：
- en: '`"lib": [`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`"lib": [`'
- en: '`"es2015.promise",`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`"es2015.promise",`'
- en: '`"dom",`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`"dom",`'
- en: '`"es5",`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`"es5",`'
- en: '`"es2015.generator",`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`"es2015.generator",`'
- en: '`"es2015.iterable",`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`"es2015.iterable",`'
- en: '`"esnext.asynciterable" // new`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`"esnext.asynciterable" // new`'
- en: '`] `'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`] `'
- en: We will learn more about the `lib` setting in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章[自动化你的开发工作流程](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中了解更多关于`lib`设置的内容。
- en: Asynchronous iteration (for await...of)
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步迭代（for await...of）
- en: 'We can use the new `for...await...of` expression to iterate and await each
    of the promises returned by an asynchronous iterator:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新的`for...await...of`表达式来迭代并等待异步迭代器返回的每个承诺：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Delegating to another generator (yield*)
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将迭代委托给另一个生成器（yield*）
- en: 'We can use the `yield*` expression to delegate from one generator to another.
    The following code snippet defines two generator functions named `g1` and `g2`.
    The `g2` generator uses the `yield*` expression to delegate the iteration to the
    iterator created by `g1`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`yield*`表达式将一个生成器委托给另一个生成器。以下代码片段定义了两个名为`g1`和`g2`的生成器函数。`g2`生成器使用`yield*`表达式将迭代委托给由`g1`创建的迭代器：
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `yield*` expression can also be used to delegate the iteration to iterables,
    such as arrays:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield*`表达式也可以用来将迭代委托给可迭代的对象，例如数组：'
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to work with functions in depth. We started
    with a quick recap of some basic concepts and then moved on to some lesser-known
    function features and use cases.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入学习了如何使用函数。我们从一个基本概念快速回顾开始，然后转向一些不太为人所知的函数特性和用例。
- en: Once we learned how to work with functions, we focused on the use of callbacks,
    promises, and generators to take advantage of the asynchronous programming capabilities
    of TypeScript.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们学会了如何使用函数，我们就专注于回调函数、承诺和生成器在TypeScript异步编程能力中的应用。
- en: In the next chapter, we will look at how to work with classes, interfaces, and
    other object-oriented programming features of the TypeScript programming language.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用TypeScript编程语言中的类、接口和其他面向对象编程特性。
