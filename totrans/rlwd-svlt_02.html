<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor032"/>2</h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Implementing Styling and Theming</h1>
<p>Without styling, an <strong class="source-inline">h1</strong> element within a component will look the same as another <strong class="source-inline">h1</strong> element from another component. Svelte allows you to use <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), a language <a id="_idIndexMarker035"/>used for styling and formatting web content, to style your elements, giving them a different look <span class="No-Break">and feel.</span></p>
<p>In this chapter, we will start by talking about different ways to style a Svelte component. We will then see some examples, including<a id="_idIndexMarker036"/> integrating a popular CSS framework, <strong class="bold">Tailwind CSS</strong>, <span class="No-Break">into Svelte.</span></p>
<p>Following that, we will talk about themes. When you have a set of styles consistently applied throughout Svelte components, you’ll see an overall styling theme in your components. We will talk about how to synchronize the styles across components, as well as how to let users of the components <span class="No-Break">customize them.</span></p>
<p>By the end of the chapter, you will have learned various methods of styling and will be comfortable in choosing the right approach and applying the right methods, depending on <span class="No-Break">the scenario.</span></p>
<p>This chapter includes sections on <span class="No-Break">the following:</span></p>
<ul>
<li>Ways to style a <span class="No-Break">Svelte component</span></li>
<li>Ways to style a Svelte component with <span class="No-Break">Tailwind CSS</span></li>
<li>Applying themes to <span class="No-Break">Svelte components</span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Technical requirements</h1>
<p>You can find the code used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Styling Svelte components in six different ways</h1>
<p>In a Svelte component, you<a id="_idIndexMarker037"/> have elements that define the structure and content. With styling, you can change the look and feel of the elements beyond the <span class="No-Break">browser default.</span></p>
<p>Svelte components can be styled in six different ways. Let’s explore the different ways to apply a style to elements within a <span class="No-Break">Svelte component.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Styling with the style attribute</h2>
<p>Firstly, you <a id="_idIndexMarker038"/>can add inline styles to an element with the <span class="No-Break"><strong class="source-inline">style</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="source-code">
&lt;div style="color: blue;" /&gt;</pre> <p>The preceding snippet will turn the color of the text within <strong class="source-inline">div</strong> <span class="No-Break">to blue.</span></p>
<p>Similar to the <strong class="source-inline">style</strong> attribute in HTML elements, you can add multiple CSS <span class="No-Break">styling declarations:</span></p>
<pre class="source-code">
&lt;div style="color: blue; font-size: 2rem;" /&gt;</pre> <p>The syntax of adding multiple CSS styling declarations in Svelte is the same as you would do in HTML. In the preceding snippet, we change the text within <strong class="source-inline">div</strong> to be blue in color and 2 rem <span class="No-Break">in size.</span></p>
<p>The value of the <strong class="source-inline">style</strong> attribute is a string. You can form the <strong class="source-inline">style</strong> attribute with <span class="No-Break">dynamic expressions:</span></p>
<pre class="source-code">
&lt;div style="color: {color};" /&gt;</pre> <p>Sometimes it gets messy when you have multiple CSS styling declarations within the <span class="No-Break"><strong class="source-inline">style</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="source-code">
&lt;div style="color: {color}; font-size: {fontSize}; background: {background}; border-top: {borderTop};" /&gt;</pre> <h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Using style: directives</h2>
<p>Svelte <a id="_idIndexMarker039"/>provides <strong class="source-inline">style:</strong> directives, which allow you to split the <strong class="source-inline">style</strong> attribute into several attributes, which is hopefully more readable after adding line breaks <span class="No-Break">and indentations:</span></p>
<pre class="source-code">
&lt;div
  style:color={color}
  style:font-size={fontSize}
  style:background={background}
  style:border-top={borderTop}
/&gt;</pre> <p>The <strong class="source-inline">style:</strong> directive follows the <span class="No-Break">following syntax:</span></p>
<pre class="source-code">
style:css-property-name={value}</pre> <p>The<a id="_idIndexMarker040"/> CSS property name can be any CSS property, including CSS <span class="No-Break">custom properties:</span></p>
<pre class="source-code">
&lt;div style:--main-color={color} /&gt;</pre> <p>And if the name of the style matches the name of the value it depends on, then you can use the shorthand form of the <span class="No-Break"><strong class="source-inline">style:</strong></span><span class="No-Break"> directive:</span></p>
<pre class="source-code">
&lt;div
  style:color
  style:font-size={fontSize}
  style:background
  style:border-top={borderTop}
/&gt;</pre> <p>A style declared in the <strong class="source-inline">style:</strong> directive has higher priority than the <strong class="source-inline">style</strong> attribute. In the following example, the <strong class="source-inline">h1</strong> text color is red instead <span class="No-Break">of blue:</span></p>
<pre class="source-code">
&lt;div style:color="red" style="color: blue;" /&gt;</pre> <p>Besides adding inline styles to style an element one by one, the next approach allows us to write CSS selectors to target multiple elements and style <span class="No-Break">them together.</span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Adding the &lt;style&gt; block</h2>
<p>In<a id="_idIndexMarker041"/> each Svelte component, you can have one top-level <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">style&gt;</strong></span><span class="No-Break"> block.</span></p>
<p>Within the <strong class="source-inline">&lt;style&gt;</strong> block, you can have CSS rules, targeting elements within <span class="No-Break">the component:</span></p>
<pre class="source-code">
&lt;div&gt;First div&lt;/div&gt;
&lt;div&gt;Second div&lt;/div&gt;
&lt;style&gt;
  div {
    color: blue;
  }
&lt;/style&gt;</pre> <p>This approach is useful when you want to apply the same style across multiple elements within <span class="No-Break">the component.</span></p>
<p>In the preceding code, would the CSS rule turn all the <strong class="source-inline">div</strong> elements in the document <span class="No-Break">to blue?</span></p>
<p>No. The CSS rules within the <strong class="source-inline">&lt;style&gt;</strong> block are scoped to the component, meaning the CSS rules will only be applied to the elements within the component, and not <strong class="source-inline">div</strong> elsewhere in <span class="No-Break">your application.</span></p>
<p>So you do not have to worry about the CSS rule inside the <strong class="source-inline">&lt;style&gt;</strong> block changing elements outside <span class="No-Break">the component.</span></p>
<p>But, how does this work? How does Svelte make sure that the CSS rules only apply to the element within the <span class="No-Break">same component?</span></p>
<p>Let’s <span class="No-Break">explore that.</span></p>
<h3>How Svelte scopes CSS rules within a component</h3>
<p>Let’s digress for a <a id="_idIndexMarker042"/>bit to understand how Svelte makes sure that the CSS rules within a component <span class="No-Break">are scoped.</span></p>
<p>When Svelte compiles a component, the Svelte compiler goes through each CSS rule and attempts to match each element with the selector of the <span class="No-Break">CSS rule:</span></p>
<pre class="source-code">
&lt;div&gt;row&lt;/div&gt;
&lt;style&gt;
  div { color: red; }
&lt;/style&gt;</pre> <p>Whenever<a id="_idIndexMarker043"/> an element matches the selector, the Svelte compiler will generate a CSS class name that is unique to the component and apply it to the element. At the same time, Svelte limits the scope of the elements being selected by the CSS rule by including a class selector of the generated class name in <span class="No-Break">the selector.</span></p>
<p>The transformation of the element and the CSS rule looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;div class="svelte-q5jdbb"&gt;row&lt;/div&gt;
&lt;style&gt;
  div.svelte-q5jdbb { color: red; }
&lt;/style&gt;</pre> <p>Here, <strong class="source-inline">"svelte-g5jdbb"</strong> is the unique CSS class name that is generated by calculating the hash value of the CSS content. The hash value will be different when the CSS content changes. Since the Svelte compiler only applies the CSS class name to the elements within the component, it is unlikely that the style will be applied to other elements outside <span class="No-Break">the component.</span></p>
<p>This transformation happens during compilation by default. There’s nothing additional that you need to do. The example here is more for illustration <span class="No-Break">purposes only.</span></p>
<p>Knowing that the CSS rules within the <strong class="source-inline">&lt;style&gt;</strong> block are scoped, when you want to apply styles to all of the elements of the same node name, using the CSS type selector for your CSS rule is sufficient most of the time. However, if you want to style only some of the elements, say only the second <strong class="source-inline">div</strong> element in the preceding example, you can add a <strong class="source-inline">class</strong> attribute to the second <strong class="source-inline">div</strong> element to differentiate between other <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> elements.</span></p>
<p>And yes, adding a <strong class="source-inline">class</strong> attribute is our next way of styling our <span class="No-Break">Svelte component.</span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Adding the class attribute</h2>
<p>The <a id="_idIndexMarker044"/>CSS class selector in CSS works the same way <span class="No-Break">in Svelte.</span></p>
<p>When you add a <strong class="source-inline">class</strong> attribute to an element, you can target it using the CSS <span class="No-Break">class selector.</span></p>
<p>In the following example, we added the <strong class="source-inline">highlight</strong> class to the second <strong class="source-inline">div</strong>, and thus only the second <strong class="source-inline">div</strong> has a <span class="No-Break">yellow background:</span></p>
<pre class="source-code">
&lt;div&gt;First div&lt;/div&gt;
&lt;div class="highlight"&gt;Second div&lt;/div&gt;
&lt;style&gt;
  .highlight {
    background-color: yellow;
  }
&lt;/style&gt;</pre> <p>The value of the <strong class="source-inline">class</strong> attribute can be a string or a <span class="No-Break">dynamic expression.</span></p>
<p>You can conditionally apply classes to <span class="No-Break">the element:</span></p>
<pre class="source-code">
&lt;div class="{toHighlight ? "highlight" : ""} {toBold ? "bold" : ""}" /&gt;</pre> <p>In the preceding example, when the value of both <strong class="source-inline">toHighlight</strong> and <strong class="source-inline">toBold</strong> is <strong class="source-inline">true</strong>, the <strong class="source-inline">class</strong> attribute value evaluates to <strong class="source-inline">"highlight bold"</strong>. Thus, two classes, <strong class="source-inline">highlight</strong> and <strong class="source-inline">bold</strong>, are applied to the <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> element.</span></p>
<p>This pattern of conditionally applying classes to an element based on a variable is so common that Svelte provides the <strong class="source-inline">class:</strong> directive to <span class="No-Break">simplify it.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Simplifying the class attribute with the class: directive</h2>
<p>In the previous example, we <a id="_idIndexMarker045"/>conditionally applied the <strong class="source-inline">highlight</strong> class when the <strong class="source-inline">toHighlight</strong> variable was truthy, and <strong class="source-inline">bold</strong> when the <strong class="source-inline">toBold</strong> variable <span class="No-Break">was truthy.</span></p>
<p>This can be simplified with the <strong class="source-inline">class:</strong> directive, where you have <span class="No-Break">the following:</span></p>
<pre class="source-code">
class:class-name={condition}</pre> <p>To simplify<a id="_idIndexMarker046"/> the previous example with the <strong class="source-inline">class:</strong> directive, we have <span class="No-Break">the following:</span></p>
<pre class="source-code">
&lt;div class:highlight={toHighlight} class:bold={toBold} /&gt;</pre> <p>Just like the <strong class="source-inline">style:</strong> attribute, you can further simplify to a <strong class="source-inline">class:</strong> directive shorthand if the name of the class is the same as the name of the variable for <span class="No-Break">the condition.</span></p>
<p>If the condition for adding the <strong class="source-inline">highlight</strong> class is instead a variable named <strong class="source-inline">highlight</strong>, then the preceding example can be rewritten <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;div class:highlight /&gt;</pre> <p>Putting all of them together, in the following code example, the <strong class="source-inline">div</strong> element has a yellow background when the <strong class="source-inline">highlight</strong> variable is <strong class="source-inline">true</strong>, and a transparent <span class="No-Break">background otherwise:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let highlight = true;
&lt;/script&gt;
&lt;div class:highlight /&gt;
&lt;style&gt;
  .highlight {
    background-color: yellow;
  }
&lt;/style&gt;</pre> <p>All the approaches of applying styles to an element that we’ve explored so far have the CSS declarations written within the Svelte component. However, it is possible to define styles outside of the <span class="No-Break">Svelte component.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Applying styles from external CSS files</h2>
<p>Let’s say <a id="_idIndexMarker047"/>you add a style element to the HTML of your application, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;.title { color: blue }&lt;/style&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre> <p>Alternatively, you could include external CSS files in the HTML of your application, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel="stylesheet" href="external.css"&gt;
  &lt;head&gt;
&lt;/html&gt;</pre> <p>In both cases, the CSS rules written in them are applied globally to all elements in the application, including elements within your <span class="No-Break">Svelte component.</span></p>
<p>If you are using build tools such as webpack, Rollup, or Vite to bundle your application, it is common to configure your build tools to import CSS files using the <strong class="source-inline">import</strong> statement, just like importing any JS files (some tools, such as Vite, even have been configured to allow importing CSS files such as any JS files <span class="No-Break">by default!):</span></p>
<pre class="source-code">
import './style.css';</pre> <h3>Importing CSS Modules</h3>
<p>In Vite, when<a id="_idIndexMarker048"/> you name your CSS files ending <a id="_idIndexMarker049"/>with <strong class="source-inline">.module.css</strong>, the CSS file is considered a <strong class="bold">CSS Modules</strong> file. A CSS Module is a CSS file where all the class names defined within the file are <span class="No-Break">locally scoped:</span></p>
<pre class="source-code">
/* filename: style.module.css */
.highlight {
  background-color: yellow;
}</pre> <p>This means<a id="_idIndexMarker050"/> that the CSS class names specified<a id="_idIndexMarker051"/> within a CSS Module will not conflict with any class names specified elsewhere, even with class names that have the <span class="No-Break">same name.</span></p>
<p>This is because the build tool will transform the class names within CSS Modules to something unique that is unlikely to have conflicts with any <span class="No-Break">other names.</span></p>
<p>The following is an example of how the CSS rules in the preceding CSS Modules would turn out after <span class="No-Break">the build:</span></p>
<pre class="source-code">
/* the class name 'highlight' transformed into 'q3tu41d' */
.q3tu41d {
  background-color: yellow;
}</pre> <p>When importing a CSS Module from a JavaScript module, the CSS Module exports an object, containing the mapping of the original class name to the transformed <span class="No-Break">class name:</span></p>
<pre class="source-code">
import styles from './style.module.css';
styles.highlight; // 'q3tu41d'</pre> <p>In the preceding snippet, the imported <strong class="source-inline">styles</strong> module is an object, and we can get the transformed class name, <strong class="source-inline">'q3tu41d'</strong>, <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">styles.highlight</strong></span><span class="No-Break">.</span></p>
<p>This allows you to use the transformed class name in your <span class="No-Break">Svelte component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import styles from './style.module.css';
&lt;/script&gt;
&lt;div class="{styles.highlight}" /&gt;</pre> <p>We’ve seen six different ways of styling a Svelte component, but how do you choose when to use <span class="No-Break">which one?</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Choosing which method to style Svelte components</h2>
<p>Each <a id="_idIndexMarker052"/>method that we’ve seen so far has its pros and cons. Most of the time, choosing which method to style your Svelte component is up to personal preference <span class="No-Break">and convenience.</span></p>
<p>Here are some of my personal preferences when choosing the method to style my <span class="No-Break">Svelte component:</span></p>
<ul>
<li>&lt;style&gt; block over <span class="No-Break">inline styles:</span><p class="list-inset">Most of the time, I find that the style I am writing has less to do with the logic of showing the elements, and more with how the elements look. So, I find it clutters my flow of reading the component when having the styles in line along with the elements. I prefer to have all my styles in one place in the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">style&gt;</strong></span><span class="No-Break"> block.</span></p></li>
<li>Controlling styles using the <strong class="source-inline">style:</strong> directive and the <span class="No-Break"><strong class="source-inline">class:</strong></span><span class="No-Break"> directive:</span><p class="list-inset">When the style property of an element is dependent on a variable, I would use the <strong class="source-inline">style:</strong> directive or the <strong class="source-inline">class:</strong> directive instead of the <strong class="source-inline">style</strong> attribute or the <strong class="source-inline">class</strong> attribute. I find this cleaner to read, as well as finding it a strong signal telling me that the style of the element <span class="No-Break">is dynamic.</span></p><p class="list-inset">When I am changing only one style property based on one variable, I would use the <strong class="source-inline">style:</strong> directive. However, when changing more than one style property with the same variable, I prefer declaring a CSS class to group all the styles together and controlling it via the <span class="No-Break"><strong class="source-inline">class:</strong></span><span class="No-Break"> directive.</span></p></li>
<li>CSS Modules for reusing CSS declarations in multiple <span class="No-Break">Svelte components:</span><p class="list-inset">At the time of writing this book, there’s no built-in method in Svelte to share the same CSS declarations in multiple Svelte components. So, you might want to share the CSS declarations through <span class="No-Break">CSS Modules.</span></p><p class="list-inset">However, more often than not, when you need the same CSS declarations for elements across multiple Svelte components, you have a less-than-perfect component structure. It may be possible to abstract the elements out into a <span class="No-Break">Svelte component.</span></p></li>
</ul>
<p>We’ve seen <a id="_idIndexMarker053"/>how we can define our own styles within and outside of a Svelte component; however, sometimes it’s much easier to adopt styles written by others, rather than designing our <span class="No-Break">own styles.</span></p>
<p>In the next section, we are going to explore using a popular CSS framework, Tailwind CSS, <span class="No-Break">in Svelte.</span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Styling Svelte with Tailwind CSS</h1>
<p>Tailwind CSS is a <a id="_idIndexMarker054"/>utility-first CSS framework. It comes<a id="_idIndexMarker055"/> with predefined classes, such as <strong class="source-inline">flex</strong>, <strong class="source-inline">pt-4</strong>, and <strong class="source-inline">text-center</strong>, which you can use directly in <span class="No-Break">your markup:</span></p>
<pre class="source-code">
&lt;div class="flex pt-4 text-center" /&gt;</pre> <p>We are going to use Vite’s Svelte template as a base to set up Tailwind CSS. If you are not familiar with setting up Vite’s Svelte template, here are the quick steps to set <span class="No-Break">it up:</span></p>
<ol>
<li>Run the Vite <span class="No-Break">setup tool:</span><pre class="source-code">
<strong class="bold">npm create vite@latest my-project-name -- --template svelte</strong></pre><p class="list-inset">This will generate a new folder named <strong class="source-inline">my-project-name</strong> containing the basic files necessary for a <span class="No-Break">Svelte project.</span></p></li> <li>Step into the <strong class="source-inline">my-project-name</strong> folder and install <span class="No-Break">the dependencies:</span><pre class="source-code">
<strong class="bold">cd my-project-name</strong>
<strong class="bold">npm install</strong></pre></li> <li>Once the dependencies are installed, you can start the <span class="No-Break">development server:</span><pre class="source-code">
<strong class="bold">npm run dev</strong></pre></li> </ol>
<p>With the Svelte project up and running, let’s look at what we need to do to set up <span class="No-Break">Tailwind CSS.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Setting up Tailwind CSS</h2>
<p>Tailwind CSS<a id="_idIndexMarker056"/> has come up with a <strong class="source-inline">tailwindcss</strong> CLI tool that has made the setup so much easier. Follow <a id="_idIndexMarker057"/><span class="No-Break">these steps:</span></p>
<ol>
<li>To set up Tailwind CSS in a Svelte + Vite project, we first install the dependencies that <span class="No-Break">are needed:</span><pre class="source-code">
<strong class="bold">npm install -D tailwindcss postcss autoprefixer</strong></pre><p class="list-inset">PostCSS is a tool that transforms CSS files. PostCSS supports plugins, which extend the functionality of PostCSS to perform different transformations. Tailwind CSS is a PostCSS plugin that will transform the <strong class="source-inline">@tailwind</strong> directive – a Tailwind CSS directive, which you’ll <span class="No-Break">see later.</span></p></li> <li>After <strong class="source-inline">tailwindcss</strong> is installed, run the command to generate <strong class="source-inline">tailwind.config.js</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">postcss.config.js</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">npx tailwindcss init -p</strong></pre><p class="list-inset">The <strong class="source-inline">tailwind.config.js</strong> file keeps the configuration for Tailwind CSS. Tailwind CSS works by scanning template files for class names and generating the corresponding styles into a <span class="No-Break">CSS file.</span></p></li> <li>Specify the location of where our Svelte components are in <strong class="source-inline">tailwind.config.js</strong> so that Tailwind CSS knows where to scan Svelte components for <span class="No-Break">class names:</span><pre class="source-code">
module.exports = {
  content: [
    // all files ends with .svelte in the src folder
    "./src/**/*.svelte"
  ],
};</pre><p class="list-inset">The <strong class="source-inline">postcss.config.js</strong> file keeps the configuration for PostCSS. The default configuration generated is good <span class="No-Break">for now.</span></p></li> <li>Create<a id="_idIndexMarker058"/> a CSS file in <strong class="source-inline">./src/main.css</strong> to add the <span class="No-Break">Tailwind directives:</span><pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre></li> <li>Import the<a id="_idIndexMarker059"/> newly created <strong class="source-inline">./src/main.css</strong> in the <strong class="source-inline">./</strong><span class="No-Break"><strong class="source-inline">src/main.js</strong></span><span class="No-Break"> file:</span><pre class="source-code">
import './src/main.css';</pre><p class="list-inset">This is similar to importing external CSS files, which we saw <span class="No-Break">earlier on.</span></p></li> <li>Start the Vite <span class="No-Break"><strong class="source-inline">dev</strong></span><span class="No-Break"> server:</span><pre class="source-code">
<strong class="bold">npm run dev</strong></pre><p class="list-inset">And you can start using <span class="No-Break">Tailwind CSS!</span></p><p class="list-inset">Try adding the <strong class="source-inline">text-center</strong> and <strong class="source-inline">text-sky-400</strong> Tailwind CSS classes onto the elements in your <span class="No-Break">Svelte component.</span></p><p class="list-inset">For example, head over to <strong class="source-inline">./src/App.svelte</strong> and add the following: <strong class="source-inline">&lt;h1 class="text-center </strong><span class="No-Break"><strong class="source-inline">text-sky-400"&gt;Hello World&lt;/h1&gt;</strong></span></p></li> </ol>
<p>You just created an <strong class="source-inline">&lt;h1&gt;</strong> element with two Tailwind CSS classes applied: <strong class="source-inline">text-center</strong> and <strong class="source-inline">text-sky-400</strong>. This will make the text in the <strong class="source-inline">&lt;h1&gt;</strong> element center-aligned and in a sky-blue color. As you use Tailwind CSS utility class names in your Svelte component, the style declarations for those classes are generated and replace the <strong class="source-inline">@tailwind </strong><span class="No-Break"><strong class="source-inline">utilities</strong></span><span class="No-Break"> directive.</span></p>
<p>Tailwind CSS is able to extract class names from both the <strong class="source-inline">class</strong> attribute and the <strong class="source-inline">class:</strong> directive, allowing you to statically or conditionally apply the Tailwind CSS styles to <span class="No-Break">the elements:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let condition = false;
&lt;/script&gt;
&lt;h1 class="text-center"&gt;Center aligned title&lt;/h1&gt;
&lt;h1 class:text-center={condition}&gt;
  Conditionally center aligned
&lt;/h1&gt;</pre> <p>Tailwind CSS comes with a lot of <a id="_idIndexMarker060"/>utility classes: you can learn more about Tailwind CSS <span class="No-Break">at </span><a href="https://tailwindcss.com/"><span class="No-Break">https://tailwindcss.com/</span></a><span class="No-Break">.</span></p>
<p>Since <a id="_idIndexMarker061"/>Tailwind CSS <a id="_idIndexMarker062"/>classes are globally available, you can apply the same CSS classes to maintain the same look and feel across Svelte components within the same application. However, if you are doing so with your own style declarations, you may have to re-specify the same colors or dimensions in the style declarations across components to maintain the same look. Changing the value in the future would also be a problem, as we would have to search for usages by the value and <span class="No-Break">update them.</span></p>
<p>CSS custom properties are a solution for this. They allow us to define a value in one place and then reference it in multiple other places. Let’s look at how we can use CSS custom properties in <span class="No-Break">Svelte components.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Theming Svelte components with CSS custom properties</h1>
<p>Let’s take a quick <a id="_idIndexMarker063"/>knowledge<a id="_idIndexMarker064"/> check on CSS <span class="No-Break">custom properties:</span></p>
<ul>
<li>You define CSS custom properties like any other CSS properties, except that the name of the CSS custom property starts with <span class="No-Break">two dashes:</span><pre class="source-code">
--text-color: blue;</pre></li> <li>To reference the CSS custom property, use the <span class="No-Break"><strong class="source-inline">var()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
color: var(--text-color);</pre></li> <li>CSS custom properties cascade like any other <span class="No-Break">CSS properties:</span><pre class="source-code">
.foo {
  --text-color: blue;
}
div {
  --text-color: red;
}</pre><p class="list-inset">The <a id="_idIndexMarker065"/>value of the <strong class="source-inline">--text-color</strong> CSS custom property for <strong class="source-inline">&lt;div&gt;</strong> elements is red, except for the <strong class="source-inline">&lt;div&gt;</strong> elements with a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">foo</strong></span><span class="No-Break">.</span></p></li> <li>The <a id="_idIndexMarker066"/>value of CSS custom properties is inherited from <span class="No-Break">their parent:</span><pre class="source-code">
&lt;div&gt;
  &lt;span /&gt;
&lt;/div&gt;</pre><p class="list-inset">If the value of <strong class="source-inline">--text-color</strong> for <strong class="source-inline">&lt;div&gt;</strong> in the preceding example is red, then without other CSS rules applied to <strong class="source-inline">&lt;span&gt;</strong>, the value of <strong class="source-inline">--text-color</strong> for <strong class="source-inline">&lt;span&gt;</strong> is <span class="No-Break">also red.</span></p></li> </ul>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Defining CSS custom properties</h2>
<p>To specify a set <a id="_idIndexMarker067"/>of dimensions and colors for the Svelte components, we can define them as CSS custom properties at the root component of <span class="No-Break">our application:</span></p>
<pre class="source-code">
&lt;div&gt;
 &lt;ChildComponent /&gt;
&lt;/div&gt;
&lt;style&gt;
 div {
  --text-color: #eee;
  --background-color: #333;
  --text-size: 14px;
 }
&lt;/style&gt;</pre> <p>In the <a id="_idIndexMarker068"/>preceding example, we define the CSS custom property at the root element of the component, the <strong class="source-inline">&lt;div&gt;</strong> element. As a CSS custom property value inherits from a parent, the child elements and elements within the child components inherit the value from the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>As we are defining the CSS custom property at the <strong class="source-inline">&lt;div&gt;</strong> element of the component, elements that are not the descendant of the <strong class="source-inline">&lt;div&gt;</strong> element will not be able to access <span class="No-Break">the value.</span></p>
<p>If, instead, you would like to define the variable for all elements, even elements that are not the descendant of the root element of our root component, you can define the CSS custom property at the root of the document using the <strong class="source-inline">:</strong><span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break"> selector:</span></p>
<pre class="source-code">
&lt;style&gt;
  :root {
    --text-color: #eee;
    --background-color: #333;
    --text-size: 14px;
  }
&lt;/style&gt;</pre> <p>You do not need to use the <strong class="source-inline">:global()</strong> pseudo-selector for <strong class="source-inline">:root</strong>, as it will always refer to the root of the document, and never be scoped to <span class="No-Break">the component.</span></p>
<p>The <strong class="source-inline">:global()</strong> pseudo-selector is used in CSS Modules to define styles that apply globally, outside the local module scope. In Svelte, when used within a component’s <strong class="source-inline">&lt;style&gt;</strong> block, it allows you to define CSS rules that won’t be scoped to the component, making them available and applicable to elements across the entire <span class="No-Break">Svelte application.</span></p>
<p>As an alternative <a id="_idIndexMarker069"/>to defining the CSS custom properties in the <strong class="source-inline">&lt;style&gt;</strong> block, you can define them directly on the element itself through the <span class="No-Break"><strong class="source-inline">style</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="source-code">
&lt;div style="--text-color: #eee; --background-color: #333; --text-size: 14px;"&gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>As you may recall, doing so with the <strong class="source-inline">style:</strong> directive makes the code <span class="No-Break">look tidier:</span></p>
<pre class="source-code">
&lt;div
  style:--text-color="#eee"
  style:--background-color="#333"
  style:--text-size="14px"&gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>To reference the value in the child component, you use the <span class="No-Break"><strong class="source-inline">var()</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
&lt;style&gt;
  div {
   color: var(--text-color);
  }
&lt;/style&gt;</pre> <p>The great thing about using the CSS custom property is that we could dynamically change the value of the CSS custom property, and the element’s style referencing the CSS custom property will be <span class="No-Break">updated automatically.</span></p>
<p>For example, I can specify the value of <strong class="source-inline">--text-color</strong> of <strong class="source-inline">&lt;div&gt;</strong> to be <strong class="source-inline">#222</strong> or <strong class="source-inline">#eee</strong>, based on <span class="No-Break">a condition:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let condition = false;
&lt;/script&gt;
&lt;div style:--text-color={condition ? '#222' : '#eee'} &gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>When the <a id="_idIndexMarker070"/>condition is <strong class="source-inline">true</strong>, the value of <strong class="source-inline">var(--text-color)</strong> is <strong class="source-inline">#222</strong>, and the value changes to <strong class="source-inline">#eee</strong> when the condition changes <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>As you can see, CSS custom properties make it much easier to synchronize the style <span class="No-Break">of elements.</span></p>
<p>Now, let’s look at a<a id="_idIndexMarker071"/> real-world example of using CSS custom properties: creating a dark/light <span class="No-Break">theme mode.</span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Example – implementing a dark/light theme mode</h2>
<p>Dark mode is <a id="_idIndexMarker072"/>a color scheme where you have light-colored text on a dark-colored background. The idea behind dark mode is that it reduces the light coming from the screen while maintaining color contrast ratios so that the content is still readable. Less light coming from the device makes it more comfortable to read, especially in a <span class="No-Break">low-light environment.</span></p>
<p>Most operating systems allow users to set their preference on whether to use a dark or light theme, and major browsers support a media query, <strong class="source-inline">prefers-color-scheme</strong>, to indicate a user’s <span class="No-Break">system preference:</span></p>
<pre class="source-code">
@media (prefers-color-scheme: dark) {
  /* Dark theme styles go here */
}
@media (prefers-color-scheme: light) {
  /* Light theme styles go here */
}</pre> <p>Before we start, let’s decide on the <span class="No-Break">variables needed.</span></p>
<p>To simplify things, we only change the background color and text color, so that would be <strong class="source-inline">--background-color</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">--text-color</strong></span><span class="No-Break">.</span></p>
<p>It is possible <a id="_idIndexMarker073"/>that your application has other colors, such as accent colors, shadow colors, and border colors, which would need to have different colors for dark and <span class="No-Break">light themes.</span></p>
<p>Since these colors are going to be applied everywhere, we are going to define that on the root element with the <strong class="source-inline">:</strong><span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break"> pseudo-class:</span></p>
<pre class="source-code">
&lt;style&gt;
  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: black;
      --text-color: white;
    }
  }
  @media (prefers-color-scheme: light) {
    :root {
      --background-color: white;
      --text-color: black;
    }
  }
&lt;/style&gt;</pre> <p>Now, in our Svelte components, we will need to start setting the color of the text to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">var(--text-color)</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;style&gt;
  * {
    color: var(--text-color);
  }
&lt;/style&gt;</pre> <p>And that’s it; the <a id="_idIndexMarker074"/>color of the text will be white when the system preference is on the dark theme, and black when it is on the <span class="No-Break">light theme.</span></p>
<p>With the inheriting nature of CSS custom properties, the value of the CSS custom property will be determined by the closest parent element that has set <span class="No-Break">the value.</span></p>
<p>This opens the door to allowing component users to specify the style of a component without having to override style declarations through CSS rules of <span class="No-Break">higher specificity.</span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Allowing users to change the styles of a component</h2>
<p>Let’s say you style<a id="_idIndexMarker075"/> your component with CSS in the <strong class="source-inline">&lt;style&gt;</strong> block, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
   color: red;
  }
&lt;/style&gt;</pre> <p>If you want to modify the color of the <strong class="source-inline">p</strong> element from outside of the component, you’ll need to know <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">The CSS selector that has a higher specificity to override </strong><span class="No-Break"><strong class="bold">the styles</strong></span><span class="No-Break">:</span><p class="list-inset">Here, we attempt to use the <strong class="source-inline">div :global(p)</strong> selector to override the color; however, without knowing the implementation detail of the component, we do not know for sure whether our selector has a <span class="No-Break">higher specificity:</span></p><pre class="source-code">
&lt;div&gt;
  &lt;Component /&gt;
&lt;/div&gt;
&lt;style&gt;
  div :global(p) {
    color: blue;
  }
&lt;/style&gt;</pre></li> <li><strong class="bold">The element structure of </strong><span class="No-Break"><strong class="bold">the component</strong></span><span class="No-Break">:</span><p class="list-inset">To know <a id="_idIndexMarker076"/>which element’s color to override, we would have to know the element structure of the component and whether the element containing the text whose color we would like to change is a <span class="No-Break">paragraph element.</span></p><p class="list-inset">The CSS rules and element structure of a component should not be part of the component’s public API. Overriding the style of a component via a higher specificity CSS rule is not recommended. Small tweaks on the CSS rules or element structure will most likely break our CSS <span class="No-Break">rule overrides.</span></p><p class="list-inset">A better approach is to expose a list of CSS custom properties that can be used to override the styles of <span class="No-Break">the component:</span></p><pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
   color: var(--text-color, red);
  }
&lt;/style&gt;</pre><p class="list-inset">The <strong class="source-inline">var()</strong> function accepts an optional second parameter, which is the fallback value if the variable name in the first parameter does <span class="No-Break">not exist.</span></p><p class="list-inset">If you use the component without defining <strong class="source-inline">--text-color</strong>, then the color of the paragraph will fall back <span class="No-Break">to red.</span></p><p class="list-inset">The color of the paragraph in the following code snippet <span class="No-Break">is red:</span></p><pre class="source-code">&lt;div&gt;
  &lt;Component /&gt;
&lt;/div&gt;</pre><p class="list-inset">However, if <strong class="source-inline">--text-color</strong> is set, then the value of <strong class="source-inline">--text-color</strong> is <span class="No-Break">used instead:</span></p><pre class="source-code">&lt;div style:--text-color="blue"&gt;
  &lt;Component /&gt;
&lt;/div&gt;</pre><p class="list-inset">In the <a id="_idIndexMarker077"/>preceding code snippet, the color of the paragraph is blue instead <span class="No-Break">of red.</span></p><p class="list-inset">Setting CSS custom properties outside of a component is so common that Svelte provides a shorthand to pass CSS custom properties into a component directly, without needing to create a <strong class="source-inline">div</strong> element to wrap the <span class="No-Break">component yourself:</span></p><pre class="source-code">&lt;Component --text-color="blue" /&gt;</pre><p class="list-inset">This is equivalent to <span class="No-Break">the following:</span></p><pre class="source-code">&lt;div style="display:contents;--text-color:blue;"&gt;
  &lt;Component /&gt;
&lt;/div&gt;</pre><p class="list-inset">Here, <strong class="source-inline">"display:contents"</strong> is to make sure that the extra <strong class="source-inline">div</strong> does not participate in the layout of the contents of <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Component /&gt;</strong></span><span class="No-Break">.</span></p></li> </ul>
<p>If we are specifying a fallback value whenever we are using the CSS custom properties, we may find ourselves repeating the fallback value a few more times. It would be a hassle if we are going to change the fallback value. Let’s see how we can align the <span class="No-Break">fallback value.</span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Aligning the fallback value</h2>
<p>If we <a id="_idIndexMarker078"/>are using <strong class="source-inline">var(--text-color, red)</strong> across elements, you may quickly realize that we should also define a CSS custom property for the fallback value, lest we will be repeating the value multiple times, and it will potentially be troublesome to find and replace all of them in <span class="No-Break">the future.</span></p>
<p>To define another CSS custom property, you will have to define it at the root element of your component. If the value is local to your component and its descendent components only, then you should not define the CSS custom property at the document root element <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">:root</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
    --fallback-color: red;
    color: var(--text-color, var(--fallback-color));
  }
&lt;/style&gt;</pre> <p>This approach, however, requires us to use <strong class="source-inline">var(--fallback-color)</strong> wherever we are <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">var(--text-color)</strong></span><span class="No-Break">.</span></p>
<p>A slightly better approach is to define a new CSS custom property that will have the value of <strong class="source-inline">--text-color</strong> if defined, or red as <span class="No-Break">a fallback:</span></p>
<pre class="source-code">
&lt;style&gt;
  p {
   --internal-text-color: var(--text-color, red);
   color: var(--internal-text-color);
  }
&lt;/style&gt;</pre> <p>This way, the value of <strong class="source-inline">var(--internal-text-color)</strong> will always be defined, and it is more <a id="_idIndexMarker079"/>convenient to use just one CSS custom property for <span class="No-Break">elements thereafter.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Summary</h1>
<p>In this chapter, we went through six different methods to style a Svelte component. So, do you know which method you are going to use to style your Svelte component? You should now know to choose the approach that is best suited for <span class="No-Break">the scenario.</span></p>
<p>We then saw how to use Tailwind CSS in a Svelte project. It takes some initial setup to get Tailwind up and running at the beginning, but CSS frameworks such as Tailwind CSS usually come with predefined CSS classes, and most of the time, you use a <strong class="source-inline">class</strong> attribute or the <strong class="source-inline">class:</strong> directive to <span class="No-Break">apply them.</span></p>
<p>Finally, we covered how we can use the CSS custom property to theme Svelte components and how to allow component users to customize the style of a component. You can now create and share Svelte components while allowing others to have different styling than the default styles that <span class="No-Break">you’ve created.</span></p>
<p>In the next chapter, we will look at how to manage the props and states of a <span class="No-Break">Svelte component.</span></p>
</div>
</div></body></html>