<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor032"/>2</h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Implementing Styling and Theming</h1>
<p>Without styling, an <code>h1</code> element within a component will look the same as another <code>h1</code> element from another component. Svelte allows you to use <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), a language <a id="_idIndexMarker035"/>used for styling and formatting web content, to style your elements, giving them a different look and feel.</p>
<p>In this chapter, we will start by talking about different ways to style a Svelte component. We will then see some examples, including<a id="_idIndexMarker036"/> integrating a popular CSS framework, <strong class="bold">Tailwind CSS</strong>, into Svelte.</p>
<p>Following that, we will talk about themes. When you have a set of styles consistently applied throughout Svelte components, you’ll see an overall styling theme in your components. We will talk about how to synchronize the styles across components, as well as how to let users of the components customize them.</p>
<p>By the end of the chapter, you will have learned various methods of styling and will be comfortable in choosing the right approach and applying the right methods, depending on the scenario.</p>
<p>This chapter includes sections on the following:</p>
<ul>
<li>Ways to style a Svelte component</li>
<li>Ways to style a Svelte component with Tailwind CSS</li>
<li>Applying themes to Svelte components</li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Technical requirements</h1>
<p>You can find the code used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02</a>.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Styling Svelte components in six different ways</h1>
<p>In a Svelte component, you<a id="_idIndexMarker037"/> have elements that define the structure and content. With styling, you can change the look and feel of the elements beyond the browser default.</p>
<p>Svelte components can be styled in six different ways. Let’s explore the different ways to apply a style to elements within a Svelte component.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Styling with the style attribute</h2>
<p>Firstly, you <a id="_idIndexMarker038"/>can add inline styles to an element with the <code>style</code> attribute:</p>
<pre class="source-code">
&lt;div style="color: blue;" /&gt;</pre> <p>The preceding snippet will turn the color of the text within <code>div</code> to blue.</p>
<p>Similar to the <code>style</code> attribute in HTML elements, you can add multiple CSS styling declarations:</p>
<pre class="source-code">
&lt;div style="color: blue; font-size: 2rem;" /&gt;</pre> <p>The syntax of adding multiple CSS styling declarations in Svelte is the same as you would do in HTML. In the preceding snippet, we change the text within <code>div</code> to be blue in color and 2 rem in size.</p>
<p>The value of the <code>style</code> attribute is a string. You can form the <code>style</code> attribute with dynamic expressions:</p>
<pre class="source-code">
&lt;div style="color: {color};" /&gt;</pre> <p>Sometimes it gets messy when you have multiple CSS styling declarations within the <code>style</code> attribute:</p>
<pre class="source-code">
&lt;div style="color: {color}; font-size: {fontSize}; background: {background}; border-top: {borderTop};" /&gt;</pre> <h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Using style: directives</h2>
<p>Svelte <a id="_idIndexMarker039"/>provides <code>style:</code> directives, which allow you to split the <code>style</code> attribute into several attributes, which is hopefully more readable after adding line breaks and indentations:</p>
<pre class="source-code">
&lt;div
  style:color={color}
  style:font-size={fontSize}
  style:background={background}
  style:border-top={borderTop}
/&gt;</pre> <p>The <code>style:</code> directive follows the following syntax:</p>
<pre class="source-code">
style:css-property-name={value}</pre> <p>The<a id="_idIndexMarker040"/> CSS property name can be any CSS property, including CSS custom properties:</p>
<pre class="source-code">
&lt;div style:--main-color={color} /&gt;</pre> <p>And if the name of the style matches the name of the value it depends on, then you can use the shorthand form of the <code>style:</code> directive:</p>
<pre class="source-code">
&lt;div
  style:color
  style:font-size={fontSize}
  style:background
  style:border-top={borderTop}
/&gt;</pre> <p>A style declared in the <code>style:</code> directive has higher priority than the <code>style</code> attribute. In the following example, the <code>h1</code> text color is red instead of blue:</p>
<pre class="source-code">
&lt;div style:color="red" style="color: blue;" /&gt;</pre> <p>Besides adding inline styles to style an element one by one, the next approach allows us to write CSS selectors to target multiple elements and style them together.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Adding the &lt;style&gt; block</h2>
<p>In<a id="_idIndexMarker041"/> each Svelte component, you can have one top-level <code>&lt;</code><code>style&gt;</code> block.</p>
<p>Within the <code>&lt;style&gt;</code> block, you can have CSS rules, targeting elements within the component:</p>
<pre class="source-code">
&lt;div&gt;First div&lt;/div&gt;
&lt;div&gt;Second div&lt;/div&gt;
&lt;style&gt;
  div {
    color: blue;
  }
&lt;/style&gt;</pre> <p>This approach is useful when you want to apply the same style across multiple elements within the component.</p>
<p>In the preceding code, would the CSS rule turn all the <code>div</code> elements in the document to blue?</p>
<p>No. The CSS rules within the <code>&lt;style&gt;</code> block are scoped to the component, meaning the CSS rules will only be applied to the elements within the component, and not <code>div</code> elsewhere in your application.</p>
<p>So you do not have to worry about the CSS rule inside the <code>&lt;style&gt;</code> block changing elements outside the component.</p>
<p>But, how does this work? How does Svelte make sure that the CSS rules only apply to the element within the same component?</p>
<p>Let’s explore that.</p>
<h3>How Svelte scopes CSS rules within a component</h3>
<p>Let’s digress for a <a id="_idIndexMarker042"/>bit to understand how Svelte makes sure that the CSS rules within a component are scoped.</p>
<p>When Svelte compiles a component, the Svelte compiler goes through each CSS rule and attempts to match each element with the selector of the CSS rule:</p>
<pre class="source-code">
&lt;div&gt;row&lt;/div&gt;
&lt;style&gt;
  div { color: red; }
&lt;/style&gt;</pre> <p>Whenever<a id="_idIndexMarker043"/> an element matches the selector, the Svelte compiler will generate a CSS class name that is unique to the component and apply it to the element. At the same time, Svelte limits the scope of the elements being selected by the CSS rule by including a class selector of the generated class name in the selector.</p>
<p>The transformation of the element and the CSS rule looks like this:</p>
<pre class="source-code">
&lt;div class="svelte-q5jdbb"&gt;row&lt;/div&gt;
&lt;style&gt;
  div.svelte-q5jdbb { color: red; }
&lt;/style&gt;</pre> <p>Here, <code>"svelte-g5jdbb"</code> is the unique CSS class name that is generated by calculating the hash value of the CSS content. The hash value will be different when the CSS content changes. Since the Svelte compiler only applies the CSS class name to the elements within the component, it is unlikely that the style will be applied to other elements outside the component.</p>
<p>This transformation happens during compilation by default. There’s nothing additional that you need to do. The example here is more for illustration purposes only.</p>
<p>Knowing that the CSS rules within the <code>&lt;style&gt;</code> block are scoped, when you want to apply styles to all of the elements of the same node name, using the CSS type selector for your CSS rule is sufficient most of the time. However, if you want to style only some of the elements, say only the second <code>div</code> element in the preceding example, you can add a <code>class</code> attribute to the second <code>div</code> element to differentiate between other <code>div</code> elements.</p>
<p>And yes, adding a <code>class</code> attribute is our next way of styling our Svelte component.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Adding the class attribute</h2>
<p>The <a id="_idIndexMarker044"/>CSS class selector in CSS works the same way in Svelte.</p>
<p>When you add a <code>class</code> attribute to an element, you can target it using the CSS class selector.</p>
<p>In the following example, we added the <code>highlight</code> class to the second <code>div</code>, and thus only the second <code>div</code> has a yellow background:</p>
<pre class="source-code">
&lt;div&gt;First div&lt;/div&gt;
&lt;div class="highlight"&gt;Second div&lt;/div&gt;
&lt;style&gt;
  .highlight {
    background-color: yellow;
  }
&lt;/style&gt;</pre> <p>The value of the <code>class</code> attribute can be a string or a dynamic expression.</p>
<p>You can conditionally apply classes to the element:</p>
<pre class="source-code">
&lt;div class="{toHighlight ? "highlight" : ""} {toBold ? "bold" : ""}" /&gt;</pre> <p>In the preceding example, when the value of both <code>toHighlight</code> and <code>toBold</code> is <code>true</code>, the <code>class</code> attribute value evaluates to <code>"highlight bold"</code>. Thus, two classes, <code>highlight</code> and <code>bold</code>, are applied to the <code>div</code> element.</p>
<p>This pattern of conditionally applying classes to an element based on a variable is so common that Svelte provides the <code>class:</code> directive to simplify it.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Simplifying the class attribute with the class: directive</h2>
<p>In the previous example, we <a id="_idIndexMarker045"/>conditionally applied the <code>highlight</code> class when the <code>toHighlight</code> variable was truthy, and <code>bold</code> when the <code>toBold</code> variable was truthy.</p>
<p>This can be simplified with the <code>class:</code> directive, where you have the following:</p>
<pre class="source-code">
class:class-name={condition}</pre> <p>To simplify<a id="_idIndexMarker046"/> the previous example with the <code>class:</code> directive, we have the following:</p>
<pre class="source-code">
&lt;div class:highlight={toHighlight} class:bold={toBold} /&gt;</pre> <p>Just like the <code>style:</code> attribute, you can further simplify to a <code>class:</code> directive shorthand if the name of the class is the same as the name of the variable for the condition.</p>
<p>If the condition for adding the <code>highlight</code> class is instead a variable named <code>highlight</code>, then the preceding example can be rewritten as follows:</p>
<pre class="source-code">
&lt;div class:highlight /&gt;</pre> <p>Putting all of them together, in the following code example, the <code>div</code> element has a yellow background when the <code>highlight</code> variable is <code>true</code>, and a transparent background otherwise:</p>
<pre class="source-code">
&lt;script&gt;
  export let highlight = true;
&lt;/script&gt;
&lt;div class:highlight /&gt;
&lt;style&gt;
  .highlight {
    background-color: yellow;
  }
&lt;/style&gt;</pre> <p>All the approaches of applying styles to an element that we’ve explored so far have the CSS declarations written within the Svelte component. However, it is possible to define styles outside of the Svelte component.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Applying styles from external CSS files</h2>
<p>Let’s say <a id="_idIndexMarker047"/>you add a style element to the HTML of your application, like so:</p>
<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;.title { color: blue }&lt;/style&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre> <p>Alternatively, you could include external CSS files in the HTML of your application, like so:</p>
<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel="stylesheet" href="external.css"&gt;
  &lt;head&gt;
&lt;/html&gt;</pre> <p>In both cases, the CSS rules written in them are applied globally to all elements in the application, including elements within your Svelte component.</p>
<p>If you are using build tools such as webpack, Rollup, or Vite to bundle your application, it is common to configure your build tools to import CSS files using the <code>import</code> statement, just like importing any JS files (some tools, such as Vite, even have been configured to allow importing CSS files such as any JS files by default!):</p>
<pre class="source-code">
import './style.css';</pre> <h3>Importing CSS Modules</h3>
<p>In Vite, when<a id="_idIndexMarker048"/> you name your CSS files ending <a id="_idIndexMarker049"/>with <code>.module.css</code>, the CSS file is considered a <strong class="bold">CSS Modules</strong> file. A CSS Module is a CSS file where all the class names defined within the file are locally scoped:</p>
<pre class="source-code">
/* filename: style.module.css */
.highlight {
  background-color: yellow;
}</pre> <p>This means<a id="_idIndexMarker050"/> that the CSS class names specified<a id="_idIndexMarker051"/> within a CSS Module will not conflict with any class names specified elsewhere, even with class names that have the same name.</p>
<p>This is because the build tool will transform the class names within CSS Modules to something unique that is unlikely to have conflicts with any other names.</p>
<p>The following is an example of how the CSS rules in the preceding CSS Modules would turn out after the build:</p>
<pre class="source-code">
/* the class name 'highlight' transformed into 'q3tu41d' */
.q3tu41d {
  background-color: yellow;
}</pre> <p>When importing a CSS Module from a JavaScript module, the CSS Module exports an object, containing the mapping of the original class name to the transformed class name:</p>
<pre class="source-code">
import styles from './style.module.css';
styles.highlight; // 'q3tu41d'</pre> <p>In the preceding snippet, the imported <code>styles</code> module is an object, and we can get the transformed class name, <code>'q3tu41d'</code>, through <code>styles.highlight</code>.</p>
<p>This allows you to use the transformed class name in your Svelte component:</p>
<pre class="source-code">
&lt;script&gt;
  import styles from './style.module.css';
&lt;/script&gt;
&lt;div class="{styles.highlight}" /&gt;</pre> <p>We’ve seen six different ways of styling a Svelte component, but how do you choose when to use which one?</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Choosing which method to style Svelte components</h2>
<p>Each <a id="_idIndexMarker052"/>method that we’ve seen so far has its pros and cons. Most of the time, choosing which method to style your Svelte component is up to personal preference and convenience.</p>
<p>Here are some of my personal preferences when choosing the method to style my Svelte component:</p>
<ul>
<li>&lt;style&gt; block over inline styles:<p class="list-inset">Most of the time, I find that the style I am writing has less to do with the logic of showing the elements, and more with how the elements look. So, I find it clutters my flow of reading the component when having the styles in line along with the elements. I prefer to have all my styles in one place in the <code>&lt;</code><code>style&gt;</code> block.</p></li>
<li>Controlling styles using the <code>style:</code> directive and the <code>class:</code> directive:<p class="list-inset">When the style property of an element is dependent on a variable, I would use the <code>style:</code> directive or the <code>class:</code> directive instead of the <code>style</code> attribute or the <code>class</code> attribute. I find this cleaner to read, as well as finding it a strong signal telling me that the style of the element is dynamic.</p><p class="list-inset">When I am changing only one style property based on one variable, I would use the <code>style:</code> directive. However, when changing more than one style property with the same variable, I prefer declaring a CSS class to group all the styles together and controlling it via the <code>class:</code> directive.</p></li>
<li>CSS Modules for reusing CSS declarations in multiple Svelte components:<p class="list-inset">At the time of writing this book, there’s no built-in method in Svelte to share the same CSS declarations in multiple Svelte components. So, you might want to share the CSS declarations through CSS Modules.</p><p class="list-inset">However, more often than not, when you need the same CSS declarations for elements across multiple Svelte components, you have a less-than-perfect component structure. It may be possible to abstract the elements out into a Svelte component.</p></li>
</ul>
<p>We’ve seen <a id="_idIndexMarker053"/>how we can define our own styles within and outside of a Svelte component; however, sometimes it’s much easier to adopt styles written by others, rather than designing our own styles.</p>
<p>In the next section, we are going to explore using a popular CSS framework, Tailwind CSS, in Svelte.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Styling Svelte with Tailwind CSS</h1>
<p>Tailwind CSS is a <a id="_idIndexMarker054"/>utility-first CSS framework. It comes<a id="_idIndexMarker055"/> with predefined classes, such as <code>flex</code>, <code>pt-4</code>, and <code>text-center</code>, which you can use directly in your markup:</p>
<pre class="source-code">
&lt;div class="flex pt-4 text-center" /&gt;</pre> <p>We are going to use Vite’s Svelte template as a base to set up Tailwind CSS. If you are not familiar with setting up Vite’s Svelte template, here are the quick steps to set it up:</p>
<ol>
<li>Run the Vite setup tool:<pre class="source-code">
<code>my-project-name</code> containing the basic files necessary for a Svelte project.</p></li> <li>Step into the <code>my-project-name</code> folder and install the dependencies:<pre class="source-code">
<strong class="bold">cd my-project-name</strong>
<strong class="bold">npm install</strong></pre></li> <li>Once the dependencies are installed, you can start the development server:<pre class="source-code">
<strong class="bold">npm run dev</strong></pre></li> </ol>
<p>With the Svelte project up and running, let’s look at what we need to do to set up Tailwind CSS.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Setting up Tailwind CSS</h2>
<p>Tailwind CSS<a id="_idIndexMarker056"/> has come up with a <code>tailwindcss</code> CLI tool that has made the setup so much easier. Follow <a id="_idIndexMarker057"/>these steps:</p>
<ol>
<li>To set up Tailwind CSS in a Svelte + Vite project, we first install the dependencies that are needed:<pre class="source-code">
<code>@tailwind</code> directive – a Tailwind CSS directive, which you’ll see later.</p></li> <li>After <code>tailwindcss</code> is installed, run the command to generate <code>tailwind.config.js</code> and <code>postcss.config.js</code>:<pre class="source-code">
<code>tailwind.config.js</code> file keeps the configuration for Tailwind CSS. Tailwind CSS works by scanning template files for class names and generating the corresponding styles into a CSS file.</p></li> <li>Specify the location of where our Svelte components are in <code>tailwind.config.js</code> so that Tailwind CSS knows where to scan Svelte components for class names:<pre class="source-code">
module.exports = {
  content: [
    // all files ends with .svelte in the src folder
    "./src/**/*.svelte"
  ],
};</pre><p class="list-inset">The <code>postcss.config.js</code> file keeps the configuration for PostCSS. The default configuration generated is good for now.</p></li> <li>Create<a id="_idIndexMarker058"/> a CSS file in <code>./src/main.css</code> to add the Tailwind directives:<pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre></li> <li>Import the<a id="_idIndexMarker059"/> newly created <code>./src/main.css</code> in the <code>./</code><code>src/main.js</code> file:<pre class="source-code">
import './src/main.css';</pre><p class="list-inset">This is similar to importing external CSS files, which we saw earlier on.</p></li> <li>Start the Vite <code>dev</code> server:<pre class="source-code">
<code>text-center</code> and <code>text-sky-400</code> Tailwind CSS classes onto the elements in your Svelte component.</p><p class="list-inset">For example, head over to <code>./src/App.svelte</code> and add the following: <code>&lt;h1 class="text-center </code><code>text-sky-400"&gt;Hello World&lt;/h1&gt;</code></p></li> </ol>
<p>You just created an <code>&lt;h1&gt;</code> element with two Tailwind CSS classes applied: <code>text-center</code> and <code>text-sky-400</code>. This will make the text in the <code>&lt;h1&gt;</code> element center-aligned and in a sky-blue color. As you use Tailwind CSS utility class names in your Svelte component, the style declarations for those classes are generated and replace the <code>@tailwind </code><code>utilities</code> directive.</p>
<p>Tailwind CSS is able to extract class names from both the <code>class</code> attribute and the <code>class:</code> directive, allowing you to statically or conditionally apply the Tailwind CSS styles to the elements:</p>
<pre class="source-code">
&lt;script&gt;
  export let condition = false;
&lt;/script&gt;
&lt;h1 class="text-center"&gt;Center aligned title&lt;/h1&gt;
&lt;h1 class:text-center={condition}&gt;
  Conditionally center aligned
&lt;/h1&gt;</pre> <p>Tailwind CSS comes with a lot of <a id="_idIndexMarker060"/>utility classes: you can learn more about Tailwind CSS at <a href="https://tailwindcss.com/">https://tailwindcss.com/</a>.</p>
<p>Since <a id="_idIndexMarker061"/>Tailwind CSS <a id="_idIndexMarker062"/>classes are globally available, you can apply the same CSS classes to maintain the same look and feel across Svelte components within the same application. However, if you are doing so with your own style declarations, you may have to re-specify the same colors or dimensions in the style declarations across components to maintain the same look. Changing the value in the future would also be a problem, as we would have to search for usages by the value and update them.</p>
<p>CSS custom properties are a solution for this. They allow us to define a value in one place and then reference it in multiple other places. Let’s look at how we can use CSS custom properties in Svelte components.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Theming Svelte components with CSS custom properties</h1>
<p>Let’s take a quick <a id="_idIndexMarker063"/>knowledge<a id="_idIndexMarker064"/> check on CSS custom properties:</p>
<ul>
<li>You define CSS custom properties like any other CSS properties, except that the name of the CSS custom property starts with two dashes:<pre class="source-code">
--text-color: blue;</pre></li> <li>To reference the CSS custom property, use the <code>var()</code> function:<pre class="source-code">
color: var(--text-color);</pre></li> <li>CSS custom properties cascade like any other CSS properties:<pre class="source-code">
.foo {
  --text-color: blue;
}
div {
  --text-color: red;
}</pre><p class="list-inset">The <a id="_idIndexMarker065"/>value of the <code>--text-color</code> CSS custom property for <code>&lt;div&gt;</code> elements is red, except for the <code>&lt;div&gt;</code> elements with a class named <code>foo</code>.</p></li> <li>The <a id="_idIndexMarker066"/>value of CSS custom properties is inherited from their parent:<pre class="source-code">
&lt;div&gt;
  &lt;span /&gt;
&lt;/div&gt;</pre><p class="list-inset">If the value of <code>--text-color</code> for <code>&lt;div&gt;</code> in the preceding example is red, then without other CSS rules applied to <code>&lt;span&gt;</code>, the value of <code>--text-color</code> for <code>&lt;span&gt;</code> is also red.</p></li> </ul>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Defining CSS custom properties</h2>
<p>To specify a set <a id="_idIndexMarker067"/>of dimensions and colors for the Svelte components, we can define them as CSS custom properties at the root component of our application:</p>
<pre class="source-code">
&lt;div&gt;
 &lt;ChildComponent /&gt;
&lt;/div&gt;
&lt;style&gt;
 div {
  --text-color: #eee;
  --background-color: #333;
  --text-size: 14px;
 }
&lt;/style&gt;</pre> <p>In the <a id="_idIndexMarker068"/>preceding example, we define the CSS custom property at the root element of the component, the <code>&lt;div&gt;</code> element. As a CSS custom property value inherits from a parent, the child elements and elements within the child components inherit the value from the <code>&lt;</code><code>div&gt;</code> element.</p>
<p>As we are defining the CSS custom property at the <code>&lt;div&gt;</code> element of the component, elements that are not the descendant of the <code>&lt;div&gt;</code> element will not be able to access the value.</p>
<p>If, instead, you would like to define the variable for all elements, even elements that are not the descendant of the root element of our root component, you can define the CSS custom property at the root of the document using the <code>:</code><code>root</code> selector:</p>
<pre class="source-code">
&lt;style&gt;
  :root {
    --text-color: #eee;
    --background-color: #333;
    --text-size: 14px;
  }
&lt;/style&gt;</pre> <p>You do not need to use the <code>:global()</code> pseudo-selector for <code>:root</code>, as it will always refer to the root of the document, and never be scoped to the component.</p>
<p>The <code>:global()</code> pseudo-selector is used in CSS Modules to define styles that apply globally, outside the local module scope. In Svelte, when used within a component’s <code>&lt;style&gt;</code> block, it allows you to define CSS rules that won’t be scoped to the component, making them available and applicable to elements across the entire Svelte application.</p>
<p>As an alternative <a id="_idIndexMarker069"/>to defining the CSS custom properties in the <code>&lt;style&gt;</code> block, you can define them directly on the element itself through the <code>style</code> attribute:</p>
<pre class="source-code">
&lt;div style="--text-color: #eee; --background-color: #333; --text-size: 14px;"&gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>As you may recall, doing so with the <code>style:</code> directive makes the code look tidier:</p>
<pre class="source-code">
&lt;div
  style:--text-color="#eee"
  style:--background-color="#333"
  style:--text-size="14px"&gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>To reference the value in the child component, you use the <code>var()</code> function:</p>
<pre class="source-code">
&lt;style&gt;
  div {
   color: var(--text-color);
  }
&lt;/style&gt;</pre> <p>The great thing about using the CSS custom property is that we could dynamically change the value of the CSS custom property, and the element’s style referencing the CSS custom property will be updated automatically.</p>
<p>For example, I can specify the value of <code>--text-color</code> of <code>&lt;div&gt;</code> to be <code>#222</code> or <code>#eee</code>, based on a condition:</p>
<pre class="source-code">
&lt;script&gt;
  export let condition = false;
&lt;/script&gt;
&lt;div style:--text-color={condition ? '#222' : '#eee'} &gt;
  &lt;ChildComponent /&gt;
&lt;/div&gt;</pre> <p>When the <a id="_idIndexMarker070"/>condition is <code>true</code>, the value of <code>var(--text-color)</code> is <code>#222</code>, and the value changes to <code>#eee</code> when the condition changes to <code>false</code>.</p>
<p>As you can see, CSS custom properties make it much easier to synchronize the style of elements.</p>
<p>Now, let’s look at a<a id="_idIndexMarker071"/> real-world example of using CSS custom properties: creating a dark/light theme mode.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Example – implementing a dark/light theme mode</h2>
<p>Dark mode is <a id="_idIndexMarker072"/>a color scheme where you have light-colored text on a dark-colored background. The idea behind dark mode is that it reduces the light coming from the screen while maintaining color contrast ratios so that the content is still readable. Less light coming from the device makes it more comfortable to read, especially in a low-light environment.</p>
<p>Most operating systems allow users to set their preference on whether to use a dark or light theme, and major browsers support a media query, <code>prefers-color-scheme</code>, to indicate a user’s system preference:</p>
<pre class="source-code">
@media (prefers-color-scheme: dark) {
  /* Dark theme styles go here */
}
@media (prefers-color-scheme: light) {
  /* Light theme styles go here */
}</pre> <p>Before we start, let’s decide on the variables needed.</p>
<p>To simplify things, we only change the background color and text color, so that would be <code>--background-color</code> and <code>--text-color</code>.</p>
<p>It is possible <a id="_idIndexMarker073"/>that your application has other colors, such as accent colors, shadow colors, and border colors, which would need to have different colors for dark and light themes.</p>
<p>Since these colors are going to be applied everywhere, we are going to define that on the root element with the <code>:</code><code>root</code> pseudo-class:</p>
<pre class="source-code">
&lt;style&gt;
  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: black;
      --text-color: white;
    }
  }
  @media (prefers-color-scheme: light) {
    :root {
      --background-color: white;
      --text-color: black;
    }
  }
&lt;/style&gt;</pre> <p>Now, in our Svelte components, we will need to start setting the color of the text to use <code>var(--text-color)</code>:</p>
<pre class="source-code">
&lt;style&gt;
  * {
    color: var(--text-color);
  }
&lt;/style&gt;</pre> <p>And that’s it; the <a id="_idIndexMarker074"/>color of the text will be white when the system preference is on the dark theme, and black when it is on the light theme.</p>
<p>With the inheriting nature of CSS custom properties, the value of the CSS custom property will be determined by the closest parent element that has set the value.</p>
<p>This opens the door to allowing component users to specify the style of a component without having to override style declarations through CSS rules of higher specificity.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Allowing users to change the styles of a component</h2>
<p>Let’s say you style<a id="_idIndexMarker075"/> your component with CSS in the <code>&lt;style&gt;</code> block, like so:</p>
<pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
   color: red;
  }
&lt;/style&gt;</pre> <p>If you want to modify the color of the <code>p</code> element from outside of the component, you’ll need to know the following:</p>
<ul>
<li><code>div :global(p)</code> selector to override the color; however, without knowing the implementation detail of the component, we do not know for sure whether our selector has a higher specificity:</p><pre class="source-code">
&lt;div&gt;
  &lt;Component /&gt;
&lt;/div&gt;
&lt;style&gt;
  div :global(p) {
    color: blue;
  }
&lt;/style&gt;</pre></li> <li><strong class="bold">The element structure of </strong><strong class="bold">the component</strong>:<p class="list-inset">To know <a id="_idIndexMarker076"/>which element’s color to override, we would have to know the element structure of the component and whether the element containing the text whose color we would like to change is a paragraph element.</p><p class="list-inset">The CSS rules and element structure of a component should not be part of the component’s public API. Overriding the style of a component via a higher specificity CSS rule is not recommended. Small tweaks on the CSS rules or element structure will most likely break our CSS rule overrides.</p><p class="list-inset">A better approach is to expose a list of CSS custom properties that can be used to override the styles of the component:</p><pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
   color: var(--text-color, red);
  }
&lt;/style&gt;</pre><p class="list-inset">The <code>var()</code> function accepts an optional second parameter, which is the fallback value if the variable name in the first parameter does not exist.</p><p class="list-inset">If you use the component without defining <code>--text-color</code>, then the color of the paragraph will fall back to red.</p><p class="list-inset">The color of the paragraph in the following code snippet is red:</p><pre class="source-code">&lt;div&gt;
  &lt;Component /&gt;
&lt;/div&gt;
<pre><p class="list-inset">Here, <code>"display:contents"</code> is to make sure that the extra <code>div</code> does not participate in the layout of the contents of <code>&lt;</code><code>Component /&gt;</code>.</pre></li> </ul>
<p>If we are specifying a fallback value whenever we are using the CSS custom properties, we may find ourselves repeating the fallback value a few more times. It would be a hassle if we are going to change the fallback value. Let’s see how we can align the fallback value.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Aligning the fallback value</h2>
<p>If we <a id="_idIndexMarker078"/>are using <code>var(--text-color, red)</code> across elements, you may quickly realize that we should also define a CSS custom property for the fallback value, lest we will be repeating the value multiple times, and it will potentially be troublesome to find and replace all of them in the future.</p>
<p>To define another CSS custom property, you will have to define it at the root element of your component. If the value is local to your component and its descendent components only, then you should not define the CSS custom property at the document root element via <code>:root</code>:</p>
<pre class="source-code">
&lt;p&gt;Hello World&lt;/p&gt;
&lt;style&gt;
  p {
    --fallback-color: red;
    color: var(--text-color, var(--fallback-color));
  }
&lt;/style&gt;</pre> <p>This approach, however, requires us to use <code>var(--fallback-color)</code> wherever we are using <code>var(--text-color)</code>.</p>
<p>A slightly better approach is to define a new CSS custom property that will have the value of <code>--text-color</code> if defined, or red as a fallback:</p>
<pre class="source-code">
&lt;style&gt;
  p {
   --internal-text-color: var(--text-color, red);
   color: var(--internal-text-color);
  }
&lt;/style&gt;</pre> <p>This way, the value of <code>var(--internal-text-color)</code> will always be defined, and it is more <a id="_idIndexMarker079"/>convenient to use just one CSS custom property for elements thereafter.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Summary</h1>
<p>In this chapter, we went through six different methods to style a Svelte component. So, do you know which method you are going to use to style your Svelte component? You should now know to choose the approach that is best suited for the scenario.</p>
<p>We then saw how to use Tailwind CSS in a Svelte project. It takes some initial setup to get Tailwind up and running at the beginning, but CSS frameworks such as Tailwind CSS usually come with predefined CSS classes, and most of the time, you use a <code>class</code> attribute or the <code>class:</code> directive to apply them.</p>
<p>Finally, we covered how we can use the CSS custom property to theme Svelte components and how to allow component users to customize the style of a component. You can now create and share Svelte components while allowing others to have different styling than the default styles that you’ve created.</p>
<p>In the next chapter, we will look at how to manage the props and states of a Svelte component.</p>
</div>
</div></body></html>