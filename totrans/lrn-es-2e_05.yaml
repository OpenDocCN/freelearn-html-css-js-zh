- en: Modular Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modular programming is one of the most important and frequently used software
    design techniques. Modular programming basically means splitting your code into
    multiple files that are usually independent of each other. This makes it a cake-walk
    when managing and maintaining different modules of a program. It helps in debugging
    nasty bugs easily, pushing updates to a particular module, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, for a long time, JavaScript didn't support modules natively;
    that led programmers to use alternative techniques to achieve modular programming
    in JavaScript. However, ES6 introduced a native modular technique in JavaScript
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about how to create and import JavaScript modules. In this
    chapter, we will first learn how modules were created earlier, and then we will
    jump to the new built-in JavaScript module system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What is modular programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of modular programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of IIFE modules, AMD, UMD, and CommonJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and importing ES6 modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing modules in browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript modules 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The practice of breaking down programs and libraries into modules is called
    modular programming.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, a **module** is a collection of related objects, functions, and
    other components of a program or library that are wrapped together and isolated
    from the scope of the rest of the program or library.
  prefs: []
  type: TYPE_NORMAL
- en: A module exports some variables to the outside program to let it access the
    components wrapped by the module. To use a module, a program needs to import the
    module and the variables exported by the module.
  prefs: []
  type: TYPE_NORMAL
- en: A module can also be split into further modules called sub-modules, thus creating
    a module hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modular programming has many benefits. Some benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It keeps our code both cleanly separated and organized by splitting it into
    multiple modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular programming leads to fewer global variables, that is, it eliminates
    the problem of global variables, because modules don't interface via the global
    scope, and each module has its own scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes code reusability easier as importing and using the same modules in
    different projects is easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows many programmers to collaborate on the same program or library, by
    making each programmer work on a particular module with a particular functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs in an application can easily be easily identified as they are localized
    to a particular module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing modules – the old way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ES6, JavaScript had never supported modules natively. Developers used
    other techniques and third-party libraries to implement modules in JavaScript.
    Using **Immediately-Invoked Function Expression** (**IIFE**), **Asynchronous Module
    Definition** (**AMD**), CommonJS, and **Universal Module Definition** (**UMD**)
    are various popular ways of implementing modules in ES5\. As these ways were not
    native to JavaScript, they had several problems. Let's take an overview of each
    of these old ways of implementing modules.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately-Invoked Function Expression (IIFE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve briefly discussed IIFE functions in earlier chapters. It is basically
    an anonymous function that is executed automatically. Let''s take a look at one
    example. This is how a typical old JS module that uses IIFE looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a module using IIFE. The `sum` and `sub` variables are global
    to the module, but not visible outside the module. The `math` variable is exported
    by the module to the main program to expose the functionalities that it provides.
  prefs: []
  type: TYPE_NORMAL
- en: This module works completely independently of the program and can be imported
    by any other program by simply copying it into the source code, or importing it
    as a separate file (by including it as script src, or by using external libraries).
  prefs: []
  type: TYPE_NORMAL
- en: The reason it'll work is that ultimately you're attaching the `math` object
    to the window (which is global).
  prefs: []
  type: TYPE_NORMAL
- en: A library using IIFE, such as jQuery, wraps all of its APIs in a single IIFE
    module. When a program uses a jQuery library, it automatically imports the module.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Module Definition (AMD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AMD is a specification for implementing modules in the browser. AMD is designed
    by keeping browser limitations in mind, that is, it imports modules asynchronously
    to prevent blocking the loading of a webpage. As AMD is not a native browser specification,
    we need to use an AMD library.
  prefs: []
  type: TYPE_NORMAL
- en: 'RequireJS is the most popular AMD library. Let''s see an example of how to
    create and import modules using RequireJS. According to the AMD specification,
    every module needs to be represented by a separate file. So first, create a file
    named `math.js` that represents a module. Here is the sample code that will be
    inside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the module exports the `math` variable to expose its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a file named `index.js`,  to act as the main program that
    imports the module and exported variables. Here is the code that will be inside
    the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `math` variable in the first parameter is the name of the file that
    is treated as the AMD module. The `.js` extension added to the file name is added
    automatically by RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: The `math` variable, which is in the second parameter, references the exported
    variable. Here, the module is imported asynchronously, and the callback is also
    executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about RequireJS and its usage here: [http://bit.ly/requirejs-tutorials](http://bit.ly/requirejs-tutorials).
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CommonJS is the most widely used, unofficial spec right now. CommonJS is a specification
    for implementing modules in Node.js. According to the CommonJS specification,
    every module needs to be represented by a separate file. CommonJS modules are
    imported **synchronously**. This is the reason why browsers do not use CommonJS
    as a module loader!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to create and import modules using CommonJS. First,
    we will create a file named `math.js` that represents a module. Here is sample
    code that will be inside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the module exports the `math` variable to expose its functionality. Now,
    let's create a file named `index.js`,  to act as the main program that imports
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that will be inside the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `math` variable is the name of the file that is treated as a module.
    The `.js` extension to the file name is added automatically by CommonJS.
  prefs: []
  type: TYPE_NORMAL
- en: exports versus module.exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we said that you can use `exports.math` or `module.exports.math`
    in order to export a variable from the module. What's the difference between two?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, technically, exports and `module.exports` point to the same object. You
    can think about this in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is how it starts. Now it doesn't matter whether you assign a property value
    to `module.exports` or exports because they both point to the same object. However,
    you must remember that it is **`module.exports` **that is actually exported!
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider `string1.js`, `string2.js`, and `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`string1.js` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`string2.js` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`index.js` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What do you think the output is?
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, as we said previously, `exports` is not exported. Thus, the second
    call (`require('string2.js')()`) throws an error because `require('string2.js')`
    returns an empty object (thus you cannot execute it as a function).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when `module.exports` is changed from an object to a function,
    the function is exported and then invoked by the developer in the first line call
    `(string1.js)`.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Module Definition (UMD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw three different specifications for implementing modules. These three
    specifications have their own respective ways of creating and importing modules.
    Wouldn't it be great if we could create modules that were imported as an IIFE,
    AMD, or CommonJS module?
  prefs: []
  type: TYPE_NORMAL
- en: UMD is a set of techniques that are used to create modules that can be imported
    as an IIFE, CommonJS, or AMD module. Therefore, now a program can import third-party
    modules, irrespective of what module specification it is using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular UMD technique is `returnExports`. According to the `returnExports`
    technique, every module needs to be represented by a separate file. So, let''s
    create a file named `math.js` that represents a module. Here is the sample code
    that will be inside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can successfully import the `math.js` module any way that you wish,
    for instance, by using CommonJS, RequireJS, or IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing modules – the new way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a new way to import and export modules in JavaScript, that is the official
    module system. Since it is supported natively by the language, it can be referred
    to as the standard JavaScript module system. You should consider using the official
    module system in practice because it's native and thus optimized for speed and
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Importing/exporting modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you''re coding a module file and now you''re ready to import it
    into your main file. How will you export it using the official module system?
    Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`#1`: We''ve first coded a function and then, using the `export` keyword, made
    it available to other modules that import this particular module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#2`: You can directly declare, initialize, and export variables/functions
    in a single line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#3`: As `#2` says, you can directly export the functions as you create them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#4`: The previous three are called named exports, whereas this is a default
    export. We''ll soon see the difference between the two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to import this previous module in a separate file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Wait. What happened here? Let's study.
  prefs: []
  type: TYPE_NORMAL
- en: Named versus default exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we saw that we used the export default: *Holy moly this is interesting*.
    What it does is, when we use `import <varname> from ''./module''`, it assigns
    `<varname>` the value of the default export. Therefore, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will console-log *Holy moly this is interesting*.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a default export.
  prefs: []
  type: TYPE_NORMAL
- en: A named export, on the other hand, has a name associated with it (the variable's
    name or the function's name). You'll have to import a named-export variable using
    destructuring syntax. This is because you can think of the `export`keyword as
    exporting a default value *plus* an object that contains all other exports you're
    doing (named exports).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will output `11`.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use `var`/`let`/`const` when doing an export default; just do `export
    default <YOUR VALUE HERE>`. However, you **can** do `export default` followed
    by a function.
  prefs: []
  type: TYPE_NORMAL
- en: Naming named imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also change the name of a named export in the module to which you''re
    importing it. This is achieved by using the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will still produce the output `11`. This is essential when you have long
    module names or names that might conflict with your base code/other imported modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can rename some named imports, and leave the rest as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Wildcard imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you want to import all the exported entities in the whole module? Writing
    each entity's name yourself is cumbersome; also, if you do that, you'll pollute
    the global scope. Let's see how we can fix both of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume our `module.js` looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import everything at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk (`*`) will import everything that is exported under the scope of
    the `myModule` object. It makes accessing all exported variables/methods cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly gather all the information about the import/export syntax in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information on export
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to use the export statement in a module to export variables. The export
    statement comes in many different formats. Here are the formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export {variableName}` - This format exports a variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName1, variableName2, variableName3}` - This format is used
    to export multiple variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName as myVariableName}` - This format is used to export a
    variable with another name, that is, an alias'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName1 as myVariableName1, variableName2 as myVariableName2}`
    - This format is used to export multiple variables with different names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName as default}` - This format uses default as the alias'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName as default, variableName1 as myVariableName1, variableName2}`
    - This format is similar to the fourth format, but it also has the default alias'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export default function(){}` - This format works similarly to the fifth format,
    but here you can place an expression instead of a variable name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export {variableName1, variableName2} from "myAnotherModule"` - This format
    is used to export the exported variables of a submodule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export * from "myAnotherModule"` - This format is used to export all the exported
    variables of a submodule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some important things that you need to know about the export statement:'
  prefs: []
  type: TYPE_NORMAL
- en: An export statement can be used anywhere in a module. It's not compulsory to
    use it at the end of the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be any number of export statements in a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot export variables on demand. For example, placing the export statement
    in the `if`...`else` condition throws an error. Therefore, we can say that the
    module structure needs to be static, that is, exports can be determined at compile
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot export the same variable name or alias multiple times. But you can
    export a variable multiple times with a different alias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code inside a module is executed in strict mode by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values of the exported variables can be changed inside the module that exported
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information on import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To `import` a module, we need to use the `import` statement. The `import` statement
    comes in many different formats. Here are the formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'An `import` statement consists of two parts: the variable names we want to
    `import` and the `relative` path of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the differences in these formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import x from "module-relative-path"` - In this format, the default alias
    is imported. `x` is the alias of the default alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import {x} from "module-relative-path"` - In this format, the `x` variable
    is imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import {x1 as x2} from "module-relative-path"` - This format is the same as
    the second format. It''s just that `x2` is an alias of `x1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import {x1, x2} from "module-relative-path"` - In this format, we import the
    `x1` and `x2` variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import {x1, x2 as x3} from "module-relative-path"` - In this format, we import
    the `x1` and `x2` variables. The `x3` is an alias of the `x2` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import x, {x1, x2} from "module-relative-path"` - In this format, we import
    the `x1` and `x2` variable, and the default alias. The `x` is an alias of the
    default alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import "module-relative-path"` - In this format, we just `import` the module.
    We do not `import` any of the variables exported by the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import * as x from "module-relative-path"` - In this format, we `import` all
    the variables and wrap them in an object called `x`. Even the default alias is
    imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import x1, * as x2 from "module-relative-path"` - The ninth format is the
    same as the eighth format. Here, we give another alias to the default alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some important things that you need to know about the import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: While importing a variable, if we import it with an alias, then to refer to
    that variable we have to use the alias and not the actual variable name; that
    is, the actual variable name will not be visible, only the alias will be visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The import statement doesn't import a copy of the exported variables; rather,
    it makes the variables available in the scope of the program that imports it.
    Therefore, if you make a change to an exported variable inside the module, then
    the change is visible to the program that imports it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imported variables are read-only, that is, you cannot reassign them to something
    else outside the scope of the module that exports them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module can only be imported once in a single instance of a JavaScript engine.
    If we try to import it again, then the already imported instance of the module
    will be used. (In other words, modules are singletons in JavaScript.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot import modules on demand. For example, placing the import statement
    in the `if`…`else` condition throws an error. Therefore, we can say that imports
    should be able to be determined at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree shaking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree shaking is basically a term used by module bundlers such as WebPack and
    Rollup to convey that the import-export module syntax can be used for dead-code
    elimination.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the new module loader system enables these module bundlers to do
    something known as tree shaking, where they shake the tree to get rid of the dead
    leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Your JavaScript is a tree. The modules you import represent the living leaves
    of your tree. The dead (unused) code is represented by the brown, dead leaves
    of the tree. To remove dead leaves, the bundler has to shake the tree and let
    them fall.
  prefs: []
  type: TYPE_NORMAL
- en: How tree shaking is performed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tree shaking, used by a module bundler, eliminates unused code in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the bundler will combine all of the imported module files (like a good
    bundler). Here, exports that are not imported in any file are not exported at
    all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the bundler minifies the bundle and simultaneously removes dead
    code. Thus, variables/functions that are not exported or used inside their respective
    module files are not present in the compressed bundle file. This way, tree shaking
    is performed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using modules on the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern browsers have very recently started to implement module loaders natively.
    To natively use a script that imports modules, you'll have to make its `type="module"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very basic working example in Chrome 63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `index.js` (the main script file) will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the module that `index.js` imports (in the same directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This, when tested, should show `Hello World` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what modular programming is and learned different modular
    programming specifications. We learned about the future of modular programming
    and how to use it in web browsers for real projects. With the evolution of ECMAScript,
    we expect to see a further boost in features and performance, which will ultimately
    benefit both the end user and the developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a look at something known as the **Reflect
    API**,  a shining new collection of methods for interceptable JavaScript operations.
  prefs: []
  type: TYPE_NORMAL
