- en: Modular Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化编程
- en: Modular programming is one of the most important and frequently used software
    design techniques. Modular programming basically means splitting your code into
    multiple files that are usually independent of each other. This makes it a cake-walk
    when managing and maintaining different modules of a program. It helps in debugging
    nasty bugs easily, pushing updates to a particular module, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程是软件设计中最重要的和最常用的技术之一。模块化编程基本上意味着将你的代码拆分成多个文件，这些文件通常彼此独立。这使得管理和维护程序的不同模块变得轻而易举。它有助于轻松调试讨厌的bug，向特定模块推送更新等等。
- en: Unfortunately, for a long time, JavaScript didn't support modules natively;
    that led programmers to use alternative techniques to achieve modular programming
    in JavaScript. However, ES6 introduced a native modular technique in JavaScript
    for the first time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，长期以来，JavaScript没有原生支持模块；这导致程序员使用替代技术来实现JavaScript中的模块化编程。然而，ES6首次在JavaScript中引入了原生的模块技术。
- en: This chapter is all about how to create and import JavaScript modules. In this
    chapter, we will first learn how modules were created earlier, and then we will
    jump to the new built-in JavaScript module system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于如何创建和导入JavaScript模块。在本章中，我们将首先学习模块是如何早期创建的，然后我们将跳转到新的内置JavaScript模块系统。
- en: 'In this chapter, we''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: What is modular programming?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模块化编程？
- en: The benefits of modular programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化编程的好处
- en: The basics of IIFE modules, AMD, UMD, and CommonJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFE模块、AMD、UMD和CommonJS模块的基本原理
- en: Creating and importing ES6 modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和导入ES6模块
- en: Implementing modules in browsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中实现模块
- en: JavaScript modules 101
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模块101
- en: The practice of breaking down programs and libraries into modules is called
    modular programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序和库分解为模块的实践称为模块化编程。
- en: In JavaScript, a **module** is a collection of related objects, functions, and
    other components of a program or library that are wrapped together and isolated
    from the scope of the rest of the program or library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，**模块**是一组相关的对象、函数和程序或库的其他组件的集合，这些组件被封装在一起，并从程序或库的其余部分的作用域中隔离出来。
- en: A module exports some variables to the outside program to let it access the
    components wrapped by the module. To use a module, a program needs to import the
    module and the variables exported by the module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模块导出一些变量到外部程序，以便它能够访问模块封装的组件。要使用模块，程序需要导入模块及其导出的变量。
- en: A module can also be split into further modules called sub-modules, thus creating
    a module hierarchy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块也可以进一步拆分为称为子模块的模块，从而创建模块层次结构。
- en: 'Modular programming has many benefits. Some benefits are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程有许多好处。以下是一些好处：
- en: It keeps our code both cleanly separated and organized by splitting it into
    multiple modules
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将其拆分为多个模块，它既保持了代码的清晰分离，又保持了组织性
- en: Modular programming leads to fewer global variables, that is, it eliminates
    the problem of global variables, because modules don't interface via the global
    scope, and each module has its own scope
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化编程导致全局变量更少，也就是说，它消除了全局变量的问题，因为模块不通过全局作用域进行接口交互，每个模块都有自己的作用域
- en: It makes code reusability easier as importing and using the same modules in
    different projects is easier
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得代码的可重用性更容易，因为在不同项目中导入和使用相同的模块更容易
- en: It allows many programmers to collaborate on the same program or library, by
    making each programmer work on a particular module with a particular functionality
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许许多程序员在同一程序或库上协作，通过让每个程序员专注于具有特定功能的特定模块
- en: Bugs in an application can easily be easily identified as they are localized
    to a particular module
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的bug很容易被识别，因为它们被局部化到特定的模块中
- en: Implementing modules – the old way
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模块 - 旧方法
- en: Before ES6, JavaScript had never supported modules natively. Developers used
    other techniques and third-party libraries to implement modules in JavaScript.
    Using **Immediately-Invoked Function Expression** (**IIFE**), **Asynchronous Module
    Definition** (**AMD**), CommonJS, and **Universal Module Definition** (**UMD**)
    are various popular ways of implementing modules in ES5\. As these ways were not
    native to JavaScript, they had several problems. Let's take an overview of each
    of these old ways of implementing modules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，JavaScript从未原生支持模块。开发者使用其他技术和第三方库在JavaScript中实现模块。使用**立即执行的函数表达式**（**IIFE**）、**异步模块定义**（**AMD**）、CommonJS和**通用模块定义**（**UMD**）是ES5中实现模块的几种流行方式。由于这些方式不是JavaScript的本地特性，它们存在一些问题。让我们概述一下这些旧的模块实现方式。
- en: Immediately-Invoked Function Expression (IIFE)
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即执行的函数表达式（IIFE）
- en: 'We''ve briefly discussed IIFE functions in earlier chapters. It is basically
    an anonymous function that is executed automatically. Let''s take a look at one
    example. This is how a typical old JS module that uses IIFE looks:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中简要讨论了IIFE函数。它基本上是一个自动执行的匿名函数。让我们来看一个例子。这是一个典型的使用IIFE的老式JS模块的例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we created a module using IIFE. The `sum` and `sub` variables are global
    to the module, but not visible outside the module. The `math` variable is exported
    by the module to the main program to expose the functionalities that it provides.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用IIFE创建了一个模块。`sum`和`sub`变量在模块内部是全局的，但在模块外部不可见。`math`变量由模块导出到主程序，以暴露它提供的功能。
- en: This module works completely independently of the program and can be imported
    by any other program by simply copying it into the source code, or importing it
    as a separate file (by including it as script src, or by using external libraries).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块完全独立于程序，可以通过将其复制到源代码中或作为单独的文件导入（通过包括脚本src或使用外部库）来由任何其他程序导入。
- en: The reason it'll work is that ultimately you're attaching the `math` object
    to the window (which is global).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以能工作，是因为最终你将`math`对象附加到了全局的window对象上（即全局作用域）。
- en: A library using IIFE, such as jQuery, wraps all of its APIs in a single IIFE
    module. When a program uses a jQuery library, it automatically imports the module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立即执行函数表达式（IIFE）的库，例如jQuery，会将所有的API封装在一个单独的IIFE模块中。当程序使用jQuery库时，它会自动导入该模块。
- en: Asynchronous Module Definition (AMD)
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步模块定义（AMD）
- en: AMD is a specification for implementing modules in the browser. AMD is designed
    by keeping browser limitations in mind, that is, it imports modules asynchronously
    to prevent blocking the loading of a webpage. As AMD is not a native browser specification,
    we need to use an AMD library.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AMD是为在浏览器中实现模块而设计的规范。AMD在设计时考虑了浏览器的限制，即异步导入模块以防止阻塞网页的加载。由于AMD不是原生的浏览器规范，我们需要使用AMD库。
- en: 'RequireJS is the most popular AMD library. Let''s see an example of how to
    create and import modules using RequireJS. According to the AMD specification,
    every module needs to be represented by a separate file. So first, create a file
    named `math.js` that represents a module. Here is the sample code that will be
    inside the module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS是最流行的AMD库。让我们看看如何使用RequireJS创建和导入模块的例子。根据AMD规范，每个模块都需要由一个单独的文件表示。所以首先，创建一个名为`math.js`的文件来表示模块。以下是模块中的示例代码：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the module exports the `math` variable to expose its functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块导出`math`变量以暴露其功能。
- en: 'Now, let''s create a file named `index.js`,  to act as the main program that
    imports the module and exported variables. Here is the code that will be inside
    the `index.js` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`index.js`的文件，作为导入模块和导出变量的主程序。以下是`index.js`文件中的代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `math` variable in the first parameter is the name of the file that
    is treated as the AMD module. The `.js` extension added to the file name is added
    automatically by RequireJS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数中的`math`变量是作为AMD模块处理的文件名。文件名添加的`.js`扩展名是由RequireJS自动添加的。
- en: The `math` variable, which is in the second parameter, references the exported
    variable. Here, the module is imported asynchronously, and the callback is also
    executed asynchronously.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数中的`math`变量引用了导出的变量。在这里，模块是异步导入的，回调也是异步执行的。
- en: You can learn more about RequireJS and its usage here: [http://bit.ly/requirejs-tutorials](http://bit.ly/requirejs-tutorials).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于RequireJS及其使用的信息：[http://bit.ly/requirejs-tutorials](http://bit.ly/requirejs-tutorials)。
- en: CommonJS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS
- en: CommonJS is the most widely used, unofficial spec right now. CommonJS is a specification
    for implementing modules in Node.js. According to the CommonJS specification,
    every module needs to be represented by a separate file. CommonJS modules are
    imported **synchronously**. This is the reason why browsers do not use CommonJS
    as a module loader!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 是目前最广泛使用的非官方规范。CommonJS 是在 Node.js 中实现模块的规范。根据 CommonJS 规范，每个模块都需要由一个单独的文件表示。CommonJS
    模块是 **同步** 导入的。这也是为什么浏览器不使用 CommonJS 作为模块加载器的原因！
- en: 'Let''s see an example of how to create and import modules using CommonJS. First,
    we will create a file named `math.js` that represents a module. Here is sample
    code that will be inside the module:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 CommonJS 创建和导入模块的示例。首先，我们将创建一个名为 `math.js` 的文件，它代表一个模块。以下是模块内部的示例代码：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the module exports the `math` variable to expose its functionality. Now,
    let's create a file named `index.js`,  to act as the main program that imports
    the module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块导出 `math` 变量以公开其功能。现在，让我们创建一个名为 `index.js` 的文件，作为导入模块的主程序。
- en: 'Here is the code that will be inside the `index.js` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `index.js` 文件内部的代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `math` variable is the name of the file that is treated as a module.
    The `.js` extension to the file name is added automatically by CommonJS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`math` 变量是作为模块处理的文件的名称。CommonJS 会自动为文件名添加 `.js` 扩展名。
- en: exports versus module.exports
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exports 与 module.exports 的区别
- en: Previously, we said that you can use `exports.math` or `module.exports.math`
    in order to export a variable from the module. What's the difference between two?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们说过，你可以使用 `exports.math` 或 `module.exports.math` 来从模块导出一个变量。两者之间有什么区别？
- en: 'Well, technically, exports and `module.exports` point to the same object. You
    can think about this in the following manner:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，exports 和 `module.exports` 指向同一个对象。你可以这样考虑：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is how it starts. Now it doesn't matter whether you assign a property value
    to `module.exports` or exports because they both point to the same object. However,
    you must remember that it is **`module.exports` **that is actually exported!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开始的方式。现在，无论你是否将属性值分配给 `module.exports` 或 exports，因为它们都指向同一个对象。然而，你必须记住，实际上是
    **`module.exports`** 被实际导出！
- en: For example, consider `string1.js`, `string2.js`, and `index.js`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 `string1.js`、`string2.js` 和 `index.js`。
- en: '`string1.js` is shown as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`string1.js` 如下所示：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`string2.js` is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`string2.js` 如下所示：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`index.js` is shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 如下所示：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What do you think the output is?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为输出是什么？
- en: Clearly, as we said previously, `exports` is not exported. Thus, the second
    call (`require('string2.js')()`) throws an error because `require('string2.js')`
    returns an empty object (thus you cannot execute it as a function).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，正如我们之前所说的，`exports` 并没有被导出。因此，第二次调用 (`require('string2.js')()`) 抛出错误，因为
    `require('string2.js')` 返回一个空对象（因此你不能将其作为函数执行）。
- en: On the other hand, when `module.exports` is changed from an object to a function,
    the function is exported and then invoked by the developer in the first line call
    `(string1.js)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当 `module.exports` 从对象更改为函数时，该函数被导出，并由开发者在一行调用 `(string1.js)` 中调用。
- en: Universal Module Definition (UMD)
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用模块定义 (UMD)
- en: We saw three different specifications for implementing modules. These three
    specifications have their own respective ways of creating and importing modules.
    Wouldn't it be great if we could create modules that were imported as an IIFE,
    AMD, or CommonJS module?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了实现模块的三个不同规范。这三个规范都有它们各自创建和导入模块的方式。如果我们能够创建可以被作为 IIFE、AMD 或 CommonJS 模块导入的模块，那岂不是很好？
- en: UMD is a set of techniques that are used to create modules that can be imported
    as an IIFE, CommonJS, or AMD module. Therefore, now a program can import third-party
    modules, irrespective of what module specification it is using.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 是一组用于创建可以作为 IIFE、CommonJS 或 AMD 模块导入的模块的技术。因此，现在一个程序可以导入第三方模块，无论它使用什么模块规范。
- en: 'The most popular UMD technique is `returnExports`. According to the `returnExports`
    technique, every module needs to be represented by a separate file. So, let''s
    create a file named `math.js` that represents a module. Here is the sample code
    that will be inside the module:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的 UMD 技术是 `returnExports`。根据 `returnExports` 技术，每个模块都需要由一个单独的文件表示。所以，让我们创建一个名为
    `math.js` 的文件来表示一个模块。以下是模块内部的示例代码：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, you can successfully import the `math.js` module any way that you wish,
    for instance, by using CommonJS, RequireJS, or IIFE.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以以你希望的方式成功导入 `math.js` 模块，例如，使用 CommonJS、RequireJS 或 IIFE。
- en: Implementing modules – the new way
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模块 – 新方法
- en: There is a new way to import and export modules in JavaScript, that is the official
    module system. Since it is supported natively by the language, it can be referred
    to as the standard JavaScript module system. You should consider using the official
    module system in practice because it's native and thus optimized for speed and
    performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中导入和导出模块的新方法就是官方模块系统。由于它被语言原生支持，因此可以称为标准 JavaScript 模块系统。你应该在实际应用中考虑使用官方模块系统，因为它原生且因此针对速度和性能进行了优化。
- en: Importing/exporting modules
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入/导出模块
- en: 'Let''s say you''re coding a module file and now you''re ready to import it
    into your main file. How will you export it using the official module system?
    Here''s how:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个模块文件，现在你准备好将其导入到主文件中。你将如何使用官方模块系统导出它？以下是方法：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`#1`: We''ve first coded a function and then, using the `export` keyword, made
    it available to other modules that import this particular module.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#1`: 我们首先编写了一个函数，然后使用 `export` 关键字使其对导入此特定模块的其他模块可用。'
- en: '`#2`: You can directly declare, initialize, and export variables/functions
    in a single line.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#2`: 你可以在一行中直接声明、初始化和导出变量/函数。'
- en: '`#3`: As `#2` says, you can directly export the functions as you create them.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#3`: 如 `#2` 所述，你可以在创建函数的同时直接导出它们。'
- en: '`#4`: The previous three are called named exports, whereas this is a default
    export. We''ll soon see the difference between the two.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#4`: 前三个被称为命名导出，而这是默认导出。我们很快就会看到两者之间的区别。'
- en: 'Let''s see how to import this previous module in a separate file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在一个单独的文件中导入这个先前的模块：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Wait. What happened here? Let's study.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。这里发生了什么？让我们来研究一下。
- en: Named versus default exports
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名导出与默认导出
- en: 'Earlier, we saw that we used the export default: *Holy moly this is interesting*.
    What it does is, when we use `import <varname> from ''./module''`, it assigns
    `<varname>` the value of the default export. Therefore, see the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了我们使用了 `export default`：*Holy moly this is interesting*。它所做的，当我们使用 `import
    <varname> from './module'` 时，将 `<varname>` 赋值为默认导出的值。因此，请看以下内容：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will console-log *Holy moly this is interesting*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出 *Holy moly this is interesting*。
- en: This is called a default export.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为默认导出。
- en: A named export, on the other hand, has a name associated with it (the variable's
    name or the function's name). You'll have to import a named-export variable using
    destructuring syntax. This is because you can think of the `export`keyword as
    exporting a default value *plus* an object that contains all other exports you're
    doing (named exports).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命名导出与一个名称相关联（变量的名称或函数的名称）。你必须使用解构语法导入命名导出变量。这是因为你可以将 `export` 关键字视为导出一个默认值
    *加上* 包含所有其他导出（命名导出）的对象。
- en: 'Therefore, see the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请看以下内容：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will output `11`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `11`。
- en: You cannot use `var`/`let`/`const` when doing an export default; just do `export
    default <YOUR VALUE HERE>`. However, you **can** do `export default` followed
    by a function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行默认导出时，你不能使用 `var`/`let`/`const`；只需执行 `export default <YOUR VALUE HERE>`。然而，你可以执行
    `export default` 后跟一个函数。
- en: Naming named imports
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名导入
- en: 'You can also change the name of a named export in the module to which you''re
    importing it. This is achieved by using the `as` keyword:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以更改你导入的模块中命名导出的名称。这是通过使用 `as` 关键字实现的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will still produce the output `11`. This is essential when you have long
    module names or names that might conflict with your base code/other imported modules.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会产生输出 `11`。这在你有长模块名或可能与你基础代码/其他导入模块冲突的名称时是必要的。
- en: 'Similarly, you can rename some named imports, and leave the rest as it is:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你也可以重命名一些命名导入，其余的保持不变：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Wildcard imports
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符导入
- en: What if you want to import all the exported entities in the whole module? Writing
    each entity's name yourself is cumbersome; also, if you do that, you'll pollute
    the global scope. Let's see how we can fix both of these issues.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想导入整个模块中导出的所有实体呢？自己编写每个实体的名称会很麻烦；此外，如果你这样做，你将污染全局作用域。让我们看看我们如何解决这两个问题。
- en: 'Let''s assume our `module.js` looks something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的 `module.js` 看起来像这样：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s import everything at once:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次性导入所有内容：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The asterisk (`*`) will import everything that is exported under the scope of
    the `myModule` object. It makes accessing all exported variables/methods cleaner.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）将导入`myModule`对象作用域下导出的所有内容。这使得访问所有导出的变量/方法更加简洁。
- en: Let's quickly gather all the information about the import/export syntax in the
    following sections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下部分中快速收集有关导入/导出语法的所有信息。
- en: Additional information on export
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于导出的附加信息
- en: 'We need to use the export statement in a module to export variables. The export
    statement comes in many different formats. Here are the formats:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在模块中使用导出语句来导出变量。导出语句有多种不同的格式。以下是这些格式：
- en: '`export {variableName}` - This format exports a variable'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName}` - 这种格式导出一个变量'
- en: '`export {variableName1, variableName2, variableName3}` - This format is used
    to export multiple variables'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName1, variableName2, variableName3}` - 这种格式用于导出多个变量'
- en: '`export {variableName as myVariableName}` - This format is used to export a
    variable with another name, that is, an alias'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName as myVariableName}` - 这种格式用于导出一个具有另一个名称的变量，即别名'
- en: '`export {variableName1 as myVariableName1, variableName2 as myVariableName2}`
    - This format is used to export multiple variables with different names'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName1 as myVariableName1, variableName2 as myVariableName2}`
    - 这种格式用于导出具有不同名称的多个变量'
- en: '`export {variableName as default}` - This format uses default as the alias'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName as default}` - 这种格式使用默认作为别名'
- en: '`export {variableName as default, variableName1 as myVariableName1, variableName2}`
    - This format is similar to the fourth format, but it also has the default alias'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName as default, variableName1 as myVariableName1, variableName2}`
    - 这种格式与第四种格式类似，但它还有一个默认别名'
- en: '`export default function(){}` - This format works similarly to the fifth format,
    but here you can place an expression instead of a variable name'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export default function(){}` - 这种格式与第五种格式类似，但在这里你可以放置一个表达式而不是变量名'
- en: '`export {variableName1, variableName2} from "myAnotherModule"` - This format
    is used to export the exported variables of a submodule'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export {variableName1, variableName2} from "myAnotherModule"` - 这种格式用于导出子模块的导出变量'
- en: '`export * from "myAnotherModule"` - This format is used to export all the exported
    variables of a submodule'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export * from "myAnotherModule"` - 这种格式用于导出子模块的所有导出变量'
- en: 'Here are some important things that you need to know about the export statement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导出语句，以下是一些你需要知道的重要事项：
- en: An export statement can be used anywhere in a module. It's not compulsory to
    use it at the end of the module.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出语句可以在模块的任何位置使用。不需要在模块的末尾使用它。
- en: There can be any number of export statements in a module.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中可以有任意数量的导出语句。
- en: You cannot export variables on demand. For example, placing the export statement
    in the `if`...`else` condition throws an error. Therefore, we can say that the
    module structure needs to be static, that is, exports can be determined at compile
    time.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能按需导出变量。例如，将导出语句放在`if...else`条件中会抛出错误。因此，我们可以说模块结构需要是静态的，即导出可以在编译时确定。
- en: You cannot export the same variable name or alias multiple times. But you can
    export a variable multiple times with a different alias.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能多次导出相同的变量名或别名。但你可以使用不同的别名多次导出同一个变量。
- en: All the code inside a module is executed in strict mode by default.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，模块内的所有代码都在严格模式下执行。
- en: The values of the exported variables can be changed inside the module that exported
    them.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出变量的值可以在导出它们的模块内部更改。
- en: Additional information on import
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于导入的附加信息
- en: 'To `import` a module, we need to use the `import` statement. The `import` statement
    comes in many different formats. Here are the formats:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要`导入`一个模块，我们需要使用`import`语句。`import`语句有多种不同的格式。以下是这些格式：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An `import` statement consists of two parts: the variable names we want to
    `import` and the `relative` path of the module.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 导出语句由两部分组成：我们想要导入的变量名和模块的相对路径。
- en: 'Here are the differences in these formats:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式之间的差异如下：
- en: '`import x from "module-relative-path"` - In this format, the default alias
    is imported. `x` is the alias of the default alias.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import x from "module-relative-path"` - 在这种格式中，默认别名被导入。`x`是默认别名的别名。'
- en: '`import {x} from "module-relative-path"` - In this format, the `x` variable
    is imported.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import {x} from "module-relative-path"` - 在这种格式中，导入`x`变量。'
- en: '`import {x1 as x2} from "module-relative-path"` - This format is the same as
    the second format. It''s just that `x2` is an alias of `x1`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import {x1 as x2} from "module-relative-path"` - 这种格式与第二种格式相同。只是`x2`是`x1`的别名。'
- en: '`import {x1, x2} from "module-relative-path"` - In this format, we import the
    `x1` and `x2` variables.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import {x1, x2} from "module-relative-path"` - 在这种格式中，我们导入`x1`和`x2`变量。'
- en: '`import {x1, x2 as x3} from "module-relative-path"` - In this format, we import
    the `x1` and `x2` variables. The `x3` is an alias of the `x2` variable.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import {x1, x2 as x3} from "module-relative-path"` - 在这种格式中，我们导入`x1`和`x2`变量。`x3`是`x2`变量的别名。'
- en: '`import x, {x1, x2} from "module-relative-path"` - In this format, we import
    the `x1` and `x2` variable, and the default alias. The `x` is an alias of the
    default alias.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import x, {x1, x2} from "module-relative-path"` - 在这种格式中，我们导入`x1`、`x2`变量和默认别名。`x`是默认别名的别名。'
- en: '`import "module-relative-path"` - In this format, we just `import` the module.
    We do not `import` any of the variables exported by the module.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import "module-relative-path"` - 在这种格式中，我们只是导入模块。我们没有导入模块导出的任何变量。'
- en: '`import * as x from "module-relative-path"` - In this format, we `import` all
    the variables and wrap them in an object called `x`. Even the default alias is
    imported.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import * as x from "module-relative-path"` - 在这种格式中，我们导入所有变量并将它们包装在一个名为`x`的对象中。甚至默认别名也被导入。'
- en: '`import x1, * as x2 from "module-relative-path"` - The ninth format is the
    same as the eighth format. Here, we give another alias to the default alias.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import x1, * as x2 from "module-relative-path"` - 第九种格式与第八种格式相同。在这里，我们给默认别名提供了另一个别名。'
- en: 'Here are some important things that you need to know about the import statement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于导入语句的重要事项，你需要了解：
- en: While importing a variable, if we import it with an alias, then to refer to
    that variable we have to use the alias and not the actual variable name; that
    is, the actual variable name will not be visible, only the alias will be visible.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当导入一个变量时，如果我们用别名导入它，那么要引用该变量，我们必须使用别名而不是实际的变量名；也就是说，实际的变量名将不可见，只有别名是可见的。
- en: The import statement doesn't import a copy of the exported variables; rather,
    it makes the variables available in the scope of the program that imports it.
    Therefore, if you make a change to an exported variable inside the module, then
    the change is visible to the program that imports it.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句不会导入导出变量的副本；相反，它使变量在导入它的程序的作用域中可用。因此，如果你在模块内部更改导出变量，那么更改对导入它的程序是可见的。
- en: Imported variables are read-only, that is, you cannot reassign them to something
    else outside the scope of the module that exports them.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的变量是只读的，也就是说，你不能在导出它们的模块作用域之外将它们重新分配给其他东西。
- en: A module can only be imported once in a single instance of a JavaScript engine.
    If we try to import it again, then the already imported instance of the module
    will be used. (In other words, modules are singletons in JavaScript.)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块在单个JavaScript引擎实例中只能导入一次。如果我们再次尝试导入它，那么已经导入的模块实例将被使用。（换句话说，模块在JavaScript中是单例的。）
- en: We cannot import modules on demand. For example, placing the import statement
    in the `if`…`else` condition throws an error. Therefore, we can say that imports
    should be able to be determined at compile time.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能按需导入模块。例如，将导入语句放在`if`…`else`条件中会抛出错误。因此，我们可以这样说，导入应该在编译时确定。
- en: Tree shaking
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树摇动
- en: Tree shaking is basically a term used by module bundlers such as WebPack and
    Rollup to convey that the import-export module syntax can be used for dead-code
    elimination.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 树摇动是模块打包器如Webpack和Rollup用来传达可以使用导入-导出模块语法进行死代码消除的术语。
- en: Essentially, the new module loader system enables these module bundlers to do
    something known as tree shaking, where they shake the tree to get rid of the dead
    leaves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，新的模块加载系统使得这些模块打包器能够执行一种称为树摇动的操作，即摇动树以去除枯叶。
- en: Your JavaScript is a tree. The modules you import represent the living leaves
    of your tree. The dead (unused) code is represented by the brown, dead leaves
    of the tree. To remove dead leaves, the bundler has to shake the tree and let
    them fall.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你的JavaScript就像一棵树。你导入的模块代表树上的活叶。而那些死（未使用）的代码则由树上的棕色枯叶来表示。为了移除枯叶，打包器必须摇动这棵树，让它们落下。
- en: How tree shaking is performed
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树摇动的执行方式
- en: 'Tree shaking, used by a module bundler, eliminates unused code in the following
    manner:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块打包器使用的树摇动以以下方式消除未使用的代码：
- en: Firstly, the bundler will combine all of the imported module files (like a good
    bundler). Here, exports that are not imported in any file are not exported at
    all.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打包器会将所有导入的模块文件合并在一起（就像一个好的打包器一样）。在这里，任何文件都没有导入的导出项都不会被导出。
- en: After that, the bundler minifies the bundle and simultaneously removes dead
    code. Thus, variables/functions that are not exported or used inside their respective
    module files are not present in the compressed bundle file. This way, tree shaking
    is performed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打包器会压缩包并同时移除无效代码。因此，那些未导出或在其各自的模块文件内部未使用的变量/函数不会出现在压缩后的包文件中。这样，就执行了摇树优化。
- en: Using modules on the web
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上使用模块
- en: Modern browsers have very recently started to implement module loaders natively.
    To natively use a script that imports modules, you'll have to make its `type="module"`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器最近才开始原生实现模块加载器。要原生使用导入模块的脚本，您需要将其`type`属性设置为`module`。
- en: 'Here''s a very basic working example in Chrome 63:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在Chrome 63中的非常基础的示例：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how `index.js` (the main script file) will look:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`index.js`（主脚本文件）的外观：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the module that `index.js` imports (in the same directory):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`index.js`（在同一目录下）导入的模块：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This, when tested, should show `Hello World` on the screen.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行测试时，应该在屏幕上显示`Hello World`。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what modular programming is and learned different modular
    programming specifications. We learned about the future of modular programming
    and how to use it in web browsers for real projects. With the evolution of ECMAScript,
    we expect to see a further boost in features and performance, which will ultimately
    benefit both the end user and the developers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了模块化编程是什么，并学习了不同的模块化编程规范。我们了解了模块化编程的未来以及如何在真实项目中使用它在网络浏览器中。随着ECMAScript的发展，我们期待看到更多功能和性能的提升，这将最终惠及最终用户和开发者。
- en: In the next chapter, we're going to take a look at something known as the **Reflect
    API**,  a shining new collection of methods for interceptable JavaScript operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个被称为**Reflect API**的东西，这是一个用于可拦截JavaScript操作的新颖方法集合。
