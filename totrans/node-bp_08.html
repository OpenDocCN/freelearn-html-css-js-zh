<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Developing Web App Workflow with Grunt and Gulp"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Developing Web App Workflow with Grunt and Gulp</h1></div></div></div><p class="calibre7">In the last few chapters, we learned how to use Node.js together with the most popular client-side JavaScript frameworks such as AngularJS<a id="id344" class="calibre1"/> and <a id="id345" class="calibre1"/>Ember.js. We learned how to run a fully functional web server and build a command-line tool.</p><p class="calibre7">In this chapter, we will explore the world of the task runners. Grunt and Gulp are two modules widely used and they have a solid collection of plugins.</p></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Developing Web App Workflow with Grunt and Gulp">
<div class="book" title="Introducing the task runners"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec56" class="calibre1"/>Introducing the task runners</h1></div></div></div><p class="calibre7">Applications<a id="id346" class="calibre1"/> are agreeably complex in nature. More and more logic is put into the browser and it is written with many lines of JavaScript code. The new CSS3 features and the improved performance of native browser animations lead to a lot of CSS code. Of course, at the end, we still want to keep the things separated. Make sure that everything is well-placed in different folders and files. Otherwise, our code will be difficult to maintain. We may need to generate<a id="id347" class="calibre1"/> <code class="email">manifest.json</code>, use a preprocessor, or simply copy files from one location to another. Thankfully, there are instruments that make our life easier. The <span class="strong"><strong class="calibre8">task runner</strong></span> <a id="id348" class="calibre1"/>accepts instructions and performs certain actions. It enables us to set a watcher and monitor files for changes. This is extremely helpful if we have a complex setup and a lot of aspects to handle.</p><p class="calibre7">At the moment, there are two popular task runners for Node.js: Grunt <a id="id349" class="calibre1"/>and Gulp. They are <a id="id350" class="calibre1"/>widely used because of the plugins written specifically for them; the modules themselves don't have many features; however, if we combine them with external plugins, they become our best friends. Even companies such as<a id="id351" class="calibre1"/> Twitter or Adobe<a id="id352" class="calibre1"/> elaborate on them.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Exploring Grunt"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec57" class="calibre1"/>Exploring Grunt</h1></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Grunt</strong></span> <a id="id353" class="calibre1"/>is a Node.js <a id="id354" class="calibre1"/>module, which means it is installed via the Node.js package manager. To get started, we need to install Grunt's command-line tool.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install -g grunt-cli</strong></span>
</pre></div><p class="calibre7">The <code class="email">-g</code> flag sets the module as a global command so that we can run it in every directory. Once the installation finishes, we are able to run <code class="email">grunt</code>, which is executable. The instructions to the task runner are stored in the<a id="id355" class="calibre1"/> <code class="email">Gruntfile.js</code> file. Place this file in the root project's directory and place our tasks inside. Once we have filled the Grunt file, open the terminal, navigate to the directory, and type <code class="email">grunt</code>.</p><p class="calibre7">The Grunt's configuration file is like a rules list. Describe step by step what exactly needs to be done. The following code snippet is the simplest format of the <code class="email">Gruntfile.js</code> file:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.initConfig({
    concat:{
    }
  });
  grunt.registerTask('default', ['concat']);
}</pre></div><p class="calibre7">The tasks are set up in the object passed to the <code class="email">initConfig</code> function. In the preceding example, we have only one task, <code class="email">concat</code>. The same task is added to the <code class="email">default</code> set of rules. These rules will be run when we start Grunt.</p><p class="calibre7">As mentioned, these task runners are so powerful because of the huge collection of plugins made by the developers. To add a plugin to our Grunt setup, include it in our <code class="email">package.json</code> file. This is because the plugin is again a Node.js module. In the next section of this chapter, we will use the<a id="id356" class="calibre1"/> <code class="email">grunt-contrib-concat</code> plugin and merge several JavaScript files into one. The following code snippet is how the <code class="email">package.json</code> file should look like:</p><div class="informalexample"><pre class="programlisting">{
  "name": "GruntjsTest",
  "version": "0.0.1",
  "description": "GruntjsTest",
  "dependencies": {},
  "devDependencies": {
    "grunt-contrib-concat": "0.3.0"
  }
}</pre></div><p class="calibre7">After running <code class="email">npm install</code>, we will be able to request the plugin by calling <code class="email">grunt.loadNpmTasks</code> (<code class="email">grunt-contrib-concat</code>). There is also a <code class="email">grunt.loadTasks</code> method for custom-defined tasks. Now, let's continue and run our first Grunt script.</p></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Concatenating files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec49" class="calibre1"/>Concatenating files</h2></div></div></div><p class="calibre7">Concatenation<a id="id357" class="calibre1"/> is one <a id="id358" class="calibre1"/>of the most common operations. It is the same with the CSS styles. Having many files means more server requests, which could decrease the performance of <a id="id359" class="calibre1"/>your application. The<a id="id360" class="calibre1"/> <code class="email">grunt-contrib-concat</code> plugin is here to help. It accepts a <code class="email">glob</code> pattern of source files and a destination path. It goes through all the folders, finds the files that match the pattern, and merges them. Let's prepare a folder for our small experiment.</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Concatenating files" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">build/scripts.js</code> file will be generated by Grunt. So, we don't have to create it. Add some content to the files in the <code class="email">src</code> folder. Our <code class="email">Gruntfile.js</code> file should contain the following code:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.initConfig({
    concat: {
      javascript: {
        src: 'src/**/*.js',
        dest: 'build/scripts.js'
      }
    }
  });
  grunt.loadNpmTasks('grunt-contrib-concat');
  grunt.registerTask('default', ['concat']);
}</pre></div><p class="calibre7">The <code class="email">concat</code> task <a id="id361" class="calibre1"/>contains a <code class="email">javascript</code> object that holds the configuration for<a id="id362" class="calibre1"/> the concatenation. The source value is actually a <code class="email">glob</code> pattern that matches all the JavaScript files inside the <code class="email">src</code> folder and its subfolders. We have used the <code class="email">glob</code> module in <a class="calibre1" title="Chapter 6. Using Node.js as a Command-line Tool" href="part0046_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre9">Using Node.js as a Command-line Tool</em></span>. With the preceding code, we can run the <code class="email">grunt</code> command in our terminal. We will get a result similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Concatenating files" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">scripts.js</code> file should be generated in the <code class="email">build</code> directory and contain all the files from the <code class="email">src</code> folder.</p><p class="calibre7">Very often, we end up debugging the compiled file. This is mainly because it's the file that we use in the browser and everything is saved together, so we can't really see where the error is initiated. In such cases, it is good to add some text before the content in every file. This will allow us to see the original destination of the code. The new content of the <code class="email">Gruntfile.js</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.initConfig({
    concat: {
      javascript: {
        options: {
          process: function(src, filepath) {
            return '// Source: ' + filepath + '\n' + src;
          }
        },
        src: 'src/**/*.js',
        dest: 'build/scripts.js'
      }
    }
  });
  grunt.loadNpmTasks('grunt-contrib-concat');
  grunt.registerTask('default', ['concat']);
}</pre></div><p class="calibre7">Thus, we pass a <a id="id363" class="calibre1"/>custom <code class="email">process</code> function. It accepts the content of the file and its path. It<a id="id364" class="calibre1"/> should return the code we want to be concatenated. In our case, we just add a short comment at the top.</p></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Minifying your code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec50" class="calibre1"/>Minifying your code</h2></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Minification</strong></span> <a id="id365" class="calibre1"/>is a process <a id="id366" class="calibre1"/>that makes our code smaller. It uses smart <a id="id367" class="calibre1"/>algorithms that replace the names of our variables and functions. It also removes the unnecessary spaces and tabs. That's pretty important for optimization because it normally decreases the file size by half. Grunt's plugin, <code class="email">grunt-contrib-uglify</code>, provides<a id="id368" class="calibre1"/> this functionality. Let's use the example code from the previous pages and modify our <code class="email">Gruntfile.js</code> file as follows:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.initConfig({
    concat: {
      javascript: {
        options: {
          process: function(src, filepath) {
            return '// Source: ' + filepath + '\n' + src;
          }
        },
        src: 'src/**/*.js',
        dest: 'build/scripts.js'
      }
    },
    uglify: {
      javascript: {
        files: {
          'build/scripts.min.js': '&lt;%= concat.javascript.dest %&gt;'
        }
      }
    }
  });
  grunt.loadNpmTasks('grunt-contrib-concat');
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.registerTask('default', ['concat', 'uglify']);
}</pre></div><p class="calibre7">In the preceding code, we do the following important tasks:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We add <code class="email">grunt-contrib-uglify</code> to our <code class="email">package.json</code> file</li><li class="listitem">We run <code class="email">npm install</code> to get the module in the <code class="email">node_modules</code> directory</li><li class="listitem">At the end, we define the minification's options</li></ul></div><p class="calibre7">In the <a id="id369" class="calibre1"/>preceding <a id="id370" class="calibre1"/>code, we set up a new task called <code class="email">uglify</code>. Its property, <code class="email">files</code>, contains a hash of the conversions we want to perform. The key is the destination path and the value is the source file. In our case, the source file is the output of another task so that we can directly use the <code class="email">&lt;% %&gt;</code> delimiters. We are able to set the exact path, but doing it using the delimiters is much more flexible. This is because we may end up with a very long Grunt file and it is always good to keep the code maintainable. If we have the destination in one place only, we are able to correct it without repeating the same change in other places.</p><p class="calibre7">Note that the tasks we defined depend on each other, that is, they should be run in a specific order. Otherwise, we will receive unexpected results. Like in our example, the <code class="email">concat</code> task is performed before <code class="email">uglify</code>. That's because the second one needs the result from the first.</p></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Watching files for changes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec51" class="calibre1"/>Watching files for changes</h2></div></div></div><p class="calibre7">Grunt is really<a id="id371" class="calibre1"/> great <a id="id372" class="calibre1"/>at doing some stuff for us. However, it is a bit annoying if we have to run it every time we change some of our files. Let's take the situation in the previous section. We have a bunch of JavaScript scripts and want to merge them into one file. If we work with the compiled version, then we have to run the concatenation every time we make corrections to the source files. For such cases, the best thing to do is set up a watcher—a task that monitors our filesystems and triggers a specific task. A plugin called <code class="email">grunt-contrib-watch</code> <a id="id373" class="calibre1"/>does exactly this for us. Add this to our <code class="email">package.json</code> file and run <code class="email">npm install</code> again to install it locally. Our file needs only one entry in the configuration. The following code shows the new watch property:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.initConfig({
    concat: {
      javascript: {
        options: {
          process: function(src, filepath) {
            return '// Source: ' + filepath + '\n' + src;
          }
        },
        src: 'src/**/*.js',
        dest: 'build/scripts.js'
      }
    },
    uglify: {
      javascript: {
        files: {
          'build/scripts.min.js': '&lt;%= concat.javascript.dest %&gt;'
        }
      }
    },
    watch: {
      javascript: {
        files: ['&lt;%= concat.javascript.src %&gt;'],
        tasks: ['concat:javascript', 'uglify']
      }
    }
  });
  grunt.loadNpmTasks('grunt-contrib-concat');
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-watch');
  grunt.registerTask('default', ['concat', 'uglify', 'watch']);
}</pre></div><p class="calibre7">There is a <code class="email">watch</code> task <a id="id374" class="calibre1"/>added after <code class="email">concat</code> and <code class="email">uglify</code>. Note that the plugin requires <a id="id375" class="calibre1"/>two options. The first one, <code class="email">files</code>, contains the files we want to monitor and the second one, <code class="email">tasks</code>, defines the processes that will be run. We are also executing a specific part of the <code class="email">concat</code> task. At the moment, we have only one thing to concatenate, but if we work on a big project, we may have several types of files or even different JavaScript sources. So, it is always good to specify our definitions, especially for the watching <code class="email">glob</code> patterns. We really don't want to run unnecessary tasks. For example, we normally don't concatenate JavaScript if some of the CSS files are changed.</p><p class="calibre7">If we use the setup shown in the preceding code and run Grunt, we will see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Watching files for changes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is pretty <a id="id376" class="calibre1"/>good logging that shows what exactly happened. All the<a id="id377" class="calibre1"/> tasks are run and the <code class="email">src\A.js</code> file is changed. Immediately, the <code class="email">concat</code> and <code class="email">uglify</code> plugins are launched.</p></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Ignoring files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec52" class="calibre1"/>Ignoring files</h2></div></div></div><p class="calibre7">Sometimes, we will have<a id="id378" class="calibre1"/> files <a id="id379" class="calibre1"/>that should not occupy a part in the whole process, for example, having a CSS file should not be concatenated with the others. Grunt offers a solution for such cases. Let's say we want to skip the JavaScript in <code class="email">src/lib/D.js</code>. We should update our <code class="email">GruntFile.js</code> file and change the <code class="email">src</code> property of the task:</p><div class="informalexample"><pre class="programlisting">concat: {
  javascript: {
    options: {
      process: function(src, filepath) {
        return '// Source: ' + filepath + '\n' + src;
      }
    },
    src: ['src/**/*.js', '!src/lib/D.js'],
    dest: 'build/scripts.js'
  }
}</pre></div><p class="calibre7">All we have to do<a id="id380" class="calibre1"/> is to use an <a id="id381" class="calibre1"/>array instead of a single string. The exclamation mark in front of the value tells Grunt that we want this file to be ignored.</p></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Creating our own task"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec53" class="calibre1"/>Creating our own task</h2></div></div></div><p class="calibre7">Grunt has an enormous <a id="id382" class="calibre1"/>collection<a id="id383" class="calibre1"/> of plugins and we will probably find what we want. However, there are situations where we need something custom for our projects. In such cases, we will need a custom task. Let's say we need to save the file size of the compiled JavaScript. We should access <code class="email">build/scripts.js</code>, check its size, and write it to a file on the hard disk.</p><p class="calibre7">The first thing we need is a new directory that will host our tasks as shown in the following screenshots:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Creating our own task" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Note the <code class="email">custom</code> folder and the <code class="email">jssize.js</code> file. Its name may not match that of the new task, but it is a good practice to keep them in sync. Before writing the actual code that does the job, we will change our configuration to fire the task. So far, we used <code class="email">grunt.loadNpmTasks</code> to indicate modules we will use during the processing. However, our script is not part of the Node.js' package management and we have to use <code class="email">grunt.loadTasks</code>. The method accepts a path to the folder containing our file as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-concat');
grunt.loadNpmTasks('grunt-contrib-uglify');
grunt.loadNpmTasks('grunt-contrib-watch');
grunt.loadTasks('custom');</pre></div><p class="calibre7">All the files in the <code class="email">custom</code> directory will be fetched and registered as valid, ready-to-use plugins. Now we can add our <code class="email">jssize</code> task to the default tasks list so that it runs along with the others as follows:</p><div class="informalexample"><pre class="programlisting">grunt.registerTask('default', ['concat', 'uglify', 'jssize', 'watch']);</pre></div><p class="calibre7">At the end, we will add a new entry in the object passed to the <code class="email">grunt.initConfig</code> function as follows:</p><div class="informalexample"><pre class="programlisting">jssize: {
  javascript: {
    check: 'build/scripts.js',
    dest: 'build/size.log'
  }
}</pre></div><p class="calibre7">As this is our own task, <a id="id384" class="calibre1"/>we can <a id="id385" class="calibre1"/>pass whatever we think is necessary. In our case, this is the file we will get the size of and the path we will save the result in.</p><p class="calibre7">A Grunt task is actually a Node.js module that exports a function by accepting the Grunt's API object. The following is the content of the <code class="email">custom/jssize.js</code> file:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
module.exports = function(grunt) {
    grunt.registerMultiTask('jssize', 'Checks the JavaScript file size', function() {
        var fileToCheck = this.data.check;
        var destination = this.data.dest;
        var stat = fs.statSync(fileToCheck);
        var result = 'Filesize of ' + fileToCheck + ': ';
        result += stat.size + 'bytes';
        grunt.file.write(destination, result);
    });
};</pre></div><p class="calibre7">The key moment is the <code class="email">grunt.registerMultiTask</code> method. The first argument is the name of the task. This is quite important because the same string is used in the <code class="email">Gruntfile.js</code> file. Immediately after, we pass a description and anonymous function. The body of that function contains the real logic to accomplish the task. The configurations we defined<a id="id386" class="calibre1"/> are <a id="id387" class="calibre1"/>available in the <code class="email">this.data</code> object. The file-size check is done and the result is saved via the <code class="email">grunt.file</code> API.</p></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Generating a cache manifest file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec54" class="calibre1"/>Generating a cache manifest file</h2></div></div></div><p class="calibre7">We found out how to create <a id="id388" class="calibre1"/>our own Grunt task. Let's write something interesting. Let's generate a cache manifest file for the project.</p><p class="calibre7">
<span class="strong"><strong class="calibre8">The Cache manifest</strong></span> file <a id="id389" class="calibre1"/>is a declarative file we use to indicate the static resources of our web application. This could be our CSS files, images, HTML templates, video files, or something that remains consistent. This is a huge optimization trick because the browser will load these resources not from the web, but from the user's device. If we need to update an already cached file, we should change the manifest.</p><p class="calibre7">At the moment, we have only JavaScript files. Let's add a few images and one CSS file. Make the necessary changes so that our project folder looks like the following figure:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Generating a cache manifest file" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <a id="id390" class="calibre1"/>content <a id="id391" class="calibre1"/>of <code class="email">styles.css</code> is not important. The images in the <code class="email">img</code> folder are also not important. We just need different files to test with. The next thing we have to do is add our task to <code class="email">Gruntfile.js</code>. We will use <code class="email">generate-manifest</code> as a name as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">'generate-manifest': {
  manifest: {
    dest: 'cache.manifest',
    files: [
      'build/*.js',
      'css/styles.css',
      'img/*.*'
    ]
  }
}</pre></div><p class="calibre7">Of course, we should not forget to add the task to the <code class="email">default</code> list as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">grunt.registerTask('default', ['concat', 'uglify', 'jssize', 'generate-manifest', 'watch']);</pre></div><p class="calibre7">Note that we are passing several <code class="email">glob</code> patterns; these are the files we want to add. Describing every single file in the configuration will take too much time and we could forget something. Grunt has a really effective API method, <code class="email">grunt.file.expand</code>, that accepts <code class="email">glob</code> patterns and returns the matched files. The rest of our task is to compose the content of the manifest file and save it to the disc. We will register the new task and fill the <code class="email">content</code> variable, which is later written to the file, as follows:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
    grunt.registerMultiTask('generate-manifest', 'Generate manifest file', function() {

        var content = '',
          self = this,
          d = new Date();

        content += 'CACHE MANIFEST\n';
        content += '# created on: ' + d.toString() + '\n';
        content += '# id: ' + Math.floor((Math.random()*1000000000)+1) + '\n';

        var files = grunt.file.expand(this.data.files);
        for(var i=0; i&lt;files.length; i++) {
            content += '/' + files[i] + '\n';
        }
        grunt.file.write(this.data.dest, content, {});

    });
};</pre></div><p class="calibre7">It's a good practice to rely on <a id="id392" class="calibre1"/>the Grunt API in our custom<a id="id393" class="calibre1"/> tasks. It keeps the consistency of our application because we depend only on one module—Grunt. In the preceding code, we used <code class="email">grunt.file.expand</code>, which we already discussed before the code, and <code class="email">grunt.file.write</code> that saves the manifest's content to the disk.</p><p class="calibre7">To provide a workable manifest, the cache file should start with <code class="email">CACHE MANIFEST</code>. That's why we add it at the beginning. It's also a good practice to include the date on which the generation happened. The randomly generated <code class="email">id</code> simplifies the process of an application's development. </p><p class="calibre7">As mentioned, the browser will serve the cached version of the files until the cache manifest file is changed. Setting a different <code class="email">id</code> each time forces the browser to fetch the latest version of the files. However, in the production environment, this should be removed. To use the cache manifest file, add a special attribute in our HTML page as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html manifest="cache.appcache"&gt;</pre></div><p class="calibre7">If everything goes well, we <a id="id394" class="calibre1"/>should see a result similar to that shown<a id="id395" class="calibre1"/> in the following screenshot:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Generating a cache manifest file" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Hence, the content of the cache manifest will be as follows:</p><div class="informalexample"><pre class="programlisting">CACHE MANIFEST
# created on: Fri Feb 14 2014 23:40:46 GMT+0200 (FLE Standard Time)
# id: 585038007
/build/scripts.js
/build/scripts.min.js
/css/styles.css
/img/A.png
/img/B.png
/img/C.png</pre></div></div></div>

<div class="book" title="Exploring Grunt">
<div class="book" title="Documenting our code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch08lvl2sec55" class="calibre1"/>Documenting our code</h2></div></div></div><p class="calibre7">We know that the code should <a id="id396" class="calibre1"/>have documentation. But very often, this is too time consuming and<a id="id397" class="calibre1"/> mundane. There are some good practices out there that we could use. One of them is to write comments into the code and generate the documentation using these comments. Following this approach, we should make our code more understandable for our colleagues. The Grunt plugin, <code class="email">grunt-contrib-yuidoc</code>, will help us create the <code class="email">.doc</code> files. Add it to our <code class="email">package.json</code> and run <code class="email">npm install</code>. Again, all we have to do is to update our <code class="email">Gruntfile.js</code> file.</p><div class="informalexample"><pre class="programlisting">yuidoc: {
  compile: {
    name: 'Project',
    description: 'Description',
    options: {
      paths: 'src/',
      outdir: 'docs/'
    }
  }
}
...
grunt.registerTask('default', ['concat', 'uglify', 'jssize', 'generate-manifest', 'yuidoc', 'watch']);</pre></div><p class="calibre7">There is a <code class="email">paths</code> property<a id="id398" class="calibre1"/> that shows the source code and the <code class="email">outdir</code> property that shows <a id="id399" class="calibre1"/>where the documentation will be saved. If we run Grunt and navigate to the directory with our favorite browser, we will see that there is nothing listed. That's because we didn't add any comment to the code. Open <code class="email">src/A.js</code> and place the following code:</p><div class="informalexample"><pre class="programlisting">/**
* This is the description for my class.
*
* @class A
*/
var A = {
  /**
  * My method description. Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method method
  */
  method: function() {

  }
};</pre></div><p class="calibre7">After relaunching the tasks, we will see the <span class="strong"><strong class="calibre8">A Class</strong></span> in the documentation as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Documenting our code" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Discovering Gulp"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec58" class="calibre1"/>Discovering Gulp</h1></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Gulp</strong></span> <a id="id400" class="calibre1"/>is a build<a id="id401" class="calibre1"/> system that has become quite popular. It's almost the same concept as Grunt. We are able to create tasks that do something for us. Of course, there are a lot of plugins. In fact, most of the main Grunt plugins have equivalent plugins in Gulp. However, there are some differences, which are mentioned in the following points:</p><div class="book"><ul class="itemizedlist"><li class="listitem">There is a configuration file, but it is called<a id="id402" class="calibre1"/> <code class="email">gulpfile.js</code></li><li class="listitem">Gulp uses streams to process the files, which means that it doesn't create any temporary file or folder. This may lead to the better performance of the task runner.</li><li class="listitem">Gulp follows the<a id="id403" class="calibre1"/> <code class="email">code-over-configuration</code> principle, that is, while we set up the Gulp tasks, the process is like coding rather than writing the configurations. This makes Gulp friendly for the developers.</li></ul></div></div>

<div class="book" title="Discovering Gulp">
<div class="book" title="Installing Gulp and fetching plugins"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec56" class="calibre1"/>Installing Gulp and fetching plugins</h2></div></div></div><p class="calibre7">Like Grunt, Gulp<a id="id404" class="calibre1"/> is<a id="id405" class="calibre1"/> available in the<a id="id406" class="calibre1"/> Node.js' package manager.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install -g gulp</strong></span>
</pre></div><p class="calibre7">The preceding command line will set up the task runner globally. Once the installation is complete, we will be able to run the <code class="email">gulp</code> command. Of course, we should do that in the directory containing the <code class="email">gulpfile.js</code> file.</p><p class="calibre7">The plugins for Gulp are also Node.js modules. For example, <code class="email">gulp-concat</code> is the same as <code class="email">grunt-contrib-concat</code> and <code class="email">gulp-uglify</code> is the alternative for <code class="email">grunt-contrib-uglify</code>. It is a good practice to describe them in a <code class="email">package.json</code> file. There is no function such as <code class="email">grunt.loadNpmTasks</code>. We could directly require the module.</p></div></div>

<div class="book" title="Discovering Gulp">
<div class="book" title="Concatenating and minifying with Gulp"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec57" class="calibre1"/>Concatenating and minifying with Gulp</h2></div></div></div><p class="calibre7">Let's use the code <a id="id407" class="calibre1"/>we already<a id="id408" class="calibre1"/> have. There are <a id="id409" class="calibre1"/>a bunch of JavaScript files in the <code class="email">src</code> folder and we want them<a id="id410" class="calibre1"/> concatenated. The task runner should also generate a minified version and watch the files for changes. We will need several modules, and here is how our <code class="email">package.json</code> file looks like:</p><div class="informalexample"><pre class="programlisting">{
  "name": "GulpTest",
  "version": "0.0.1",
  "description": "GulpTest",
  "dependencies": {},
  "devDependencies": {
    "gulp": "3.5.2",
    "gulp-concat": "2.1.7",
    "gulp-uglify": "0.2.0",
    "gulp-rename": "1.0.0"
  }
}</pre></div><p class="calibre7">The <code class="email">gulp</code> command<a id="id411" class="calibre1"/> is needed because we need access to Gulp's API. The <code class="email">gulp-concat</code> plugin<a id="id412" class="calibre1"/> will concatenate the files and <code class="email">gulp-uglify</code> will <a id="id413" class="calibre1"/>minify the result. The <code class="email">gulp-rename</code> plugin<a id="id414" class="calibre1"/> is used because we have to deliver two files—one suitable for reading and one minified, that is, <code class="email">build/scripts.js</code> and <code class="email">build/scripts.min.js</code>.</p><p class="calibre7">The following code is the content of the <code class="email">gulpfile.js</code> file:</p><div class="informalexample"><pre class="programlisting">var gulp = require('gulp');
var concat = require('gulp-concat');
var uglify = require('gulp-uglify');
var rename = require('gulp-rename');
gulp.task('js', function() {
  gulp.src('./src/**/*.js')
  .pipe(concat('scripts.js'))
  .pipe(gulp.dest('./build/'))
  .pipe(rename({suffix: '.min'}))
  .pipe(uglify())
  .pipe(gulp.dest('./build/'))
});

gulp.task('watchers', function() {
  gulp.watch('src/**/*.js', ['js']);
});

gulp.task('default', ['js', 'watchers']);</pre></div><p class="calibre7">With Grunt, we<a id="id415" class="calibre1"/> need a little more knowledge about the task runner and<a id="id416" class="calibre1"/> its <a id="id417" class="calibre1"/>configuration structure. With Gulp, it's slightly different. We<a id="id418" class="calibre1"/> have the usual Node.js modules and the usage of their public APIs. The script starts with the definition of the plugins and the <code class="email">gulp</code> object. A task is defined by using the <code class="email">gulp.task</code> method. The first parameter is the name of the task and the second is a function. Also, instead of the function, we may pass an array of strings representing other tasks.</p><p class="calibre7">Similarly, like in Grunt, we have a <code class="email">default</code> entry. This time, we split the tasks into two parts: JavaScript operations and watchers. Almost every Gulp task starts with <code class="email">gulp.src</code> and ends with <code class="email">gulp.dest</code>. The first method accepts the <code class="email">glob</code> pattern, showing the files that need to be transformed. The <code class="email">gulp.dest</code> plugin saves the result to the desired location. All the actions between them are actually modules that receive and output the streams. In our case, the <code class="email">js</code> task fetches all the files from the <code class="email">src</code> directory and its subfolders, concatenates them, and saves the result to the <code class="email">build</code> folder. We continue by renaming the file, minifying it, and saving it in the same place. The output of our terminal after running <code class="email">gulp</code> in the project's folder should be as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00037.jpeg" alt="Concatenating and minifying with Gulp" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Of course, we <a id="id419" class="calibre1"/>should see the <code class="email">scripts.js</code> and <code class="email">scripts.min.js</code> <a id="id420" class="calibre1"/>files in<a id="id421" class="calibre1"/> the<a id="id422" class="calibre1"/> build directory.</p></div></div>

<div class="book" title="Discovering Gulp">
<div class="book" title="Creating your own Gulp plugin"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec58" class="calibre1"/>Creating your own Gulp plugin</h2></div></div></div><p class="calibre7">The development of the<a id="id423" class="calibre1"/> Gulp plugin looks almost the same as creating a Grunt one. We need a new Node.js module with a proper API. The difference is that we receive a stream and we should then output the stream. This can be a little difficult to code because we need to understand how the streams work. Thankfully, there is a helper package that simplifies the process. We are going to use <code class="email">through2</code>—a tiny wrapper around the Node.js' streams API. So, our <code class="email">package.json</code> file grows a bit with the following content:</p><div class="informalexample"><pre class="programlisting">{
  "name": "GulpTest",
  "version": "0.0.1",
  "description": "GulpTest",
  "dependencies": {},
  "devDependencies": {
    "gulp": "3.5.2",
    "gulp-concat": "2.1.7",
    "gulp-uglify": "0.2.0",
    "gulp-rename": "1.0.0",
    "through2": "0.4.1"
  }
}</pre></div><p class="calibre7">Let's create the same <code class="email">jssize</code> task. It needs to do only one job: measure the file size of the concatenated file. We could recreate the <code class="email">custom</code> directory and place an empty <code class="email">jssize.js</code> file there. Our Gulp file also needs a quick correction. At the top, we require the newly created module as follows:</p><div class="informalexample"><pre class="programlisting">var jssize = require('./custom/jssize');</pre></div><p class="calibre7">We have to pipe the output of the first <code class="email">gulp.dest('./build/')</code> command to the <code class="email">jssize</code> plugin. The following snippet shows the finished task:</p><div class="informalexample"><pre class="programlisting">gulp.task('js', function() {
  gulp.src('./src/**/*.js')
  .pipe(concat('scripts.js'))
  .pipe(gulp.dest('./build/'))
  .pipe(jssize())
  .pipe(rename({suffix: '.min'}))
  .pipe(uglify())
  .pipe(gulp.dest('./build/'));
});</pre></div><p class="calibre7">Now, let's see how our<a id="id424" class="calibre1"/> plugin looks using the following code:</p><div class="informalexample"><pre class="programlisting">var through2 = require('through2');
var path = require('path');
var fs = require("fs");
module.exports = function () {
    function transform (file, enc, next) {
        var stat = fs.statSync(file.path);
        var result = 'Filesize of ' + path.basename(file.path) + ': ';
        result += stat.size + 'bytes';
        fs.writeFileSync(__dirname + '/../build/size.log', result);
        this.push(file);
        next();
    }
    return through2.obj(transform);
};</pre></div><p class="calibre7">The <code class="email">through2.obj</code> object returns a stream used in the Gulp's pipeline. Working with streams is like working with chunks. In other words, we do not receive the entire file, but parts of it again and again till we get the whole data. The <code class="email">through2</code> object simplifies the process and gives us direct access to the entire file. So, the <code class="email">transform</code> method accepts the file, its encoding, and a function that we need to call once we finish our job. Otherwise, the chain will be stopped and the next plugins will not be able to finish their tasks. The actual code that <a id="id425" class="calibre1"/>generates the <code class="email">size.log</code> file is the same as that used in the Grunt version.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec59" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned how to use the task runners. These are tools that make our life easier by simplifying the common tasks. As web developers, we might want to concatenate and minify our production code, and such trivial operations are well-handled by modules such as Grunt and Gulp. The wide range of plugins and the great Node.js community encourage the usage of task runners and change our workflow completely.</p><p class="calibre7">In the next chapter, we will dive into test-driven development and see how Node.js handles such processes.</p></div></body></html>