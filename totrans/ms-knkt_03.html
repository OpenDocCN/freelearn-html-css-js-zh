<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Extending Knockout with Preprocessors and Providers</h1></div></div></div><p class="calibre8">In the previous chapter, we looked at adding custom binding handlers to Knockout in order to add features and integrate them with third-party tools. This capability was part of Knockout when it was first released, and it allows for powerful extensions to Knockout's functionality. In this chapter, we are going to look at some more advanced techniques for extending, or even changing, Knockout binding behaviors. You will learn how to create:</p><div><ul class="itemizedlist"><li class="listitem">Binding handler preprocessors</li><li class="listitem">Node preprocessors</li><li class="listitem">Binding providers</li></ul></div><p class="calibre8">After we cover this, we will take a look at the Knockout Punches library, which is a collection of preprocessors and extensions by Knockout developer Michael Best.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec26" class="calibre1"/>Binding the handler preprocessing</h1></div></div></div><p class="calibre8">So far, we have looked at two <a id="id226" class="calibre1"/>properties of binding handlers: the <code class="literal">init</code> and <code class="literal">update</code> functions. Binding handlers have another optional function, which is <code class="literal">preprocess</code>, that is run before the <code class="literal">init</code> function. A preprocessor's purpose is to modify the <code class="literal">data-binding</code> attribute before Knockout determines what bindings are to be applied.</p><p class="calibre8">Preprocessors don't deal with elements or binding contexts; they just deal with the strings that the binding will evaluate. For example, if we had a preprocessor that converts all text bindings to uppercase, then the following <code class="literal">span</code> element will be processed:</p><div><pre class="programlisting">&lt;span data-bind="text: 'That Guy'"&gt;&lt;/span&gt;</pre></div><p class="calibre8">This <code class="literal">span</code> element would be processed as if it was written like this:</p><div><pre class="programlisting">&lt;span data-bind="text: 'That Guy'.toUpperCase()"&gt;&lt;/span&gt;</pre></div><p class="calibre8">If you were to inspect the HTML after this, you will still see the original <code class="literal">data-bind</code> attribute. This is because preprocessors don't actually deal with elements; they just modify the binding strings before the normal binding handler is applied.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec45" class="calibre1"/>Creating preprocessors</h2></div></div></div><p class="calibre8">Adding a preprocessor is as<a id="id227" class="calibre1"/> simple as adding a <code class="literal">preprocess</code> property to the binding handler, just like we added the <code class="literal">init</code> and <code class="literal">update</code> functions:</p><div><pre class="programlisting">ko.bindingHandlers.thing.preprocess = function(value, name, addBinding) {
    //Do stuff
}</pre></div><p class="calibre8">The three parameters of the <code class="literal">preprocess</code> function are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">value</code>: This is the<a id="id228" class="calibre1"/> expression given to the binding handler. For example, in <code class="literal">text: name</code>, the value is <code class="literal">name</code>; for <code class="literal">text: title() + '. ' + name()</code>, the value is <code class="literal">"title() + '. ' + name()"</code>. This value is always a string.</li><li class="listitem"><code class="literal">name</code>: This is the name<a id="id229" class="calibre1"/> of the binding handler, for example, <code class="literal">text</code> or <code class="literal">click</code>. This can be useful in cases where a single <code class="literal">preprocess</code> function is used by multiple binding handlers.</li><li class="listitem"><code class="literal">addBinding</code>: This is a <a id="id230" class="calibre1"/>callback function that takes the <code class="literal">name</code> and <code class="literal">value</code> string parameters, just like the previous ones. It will add the pair as a binding on the element.</li></ul></div><p class="calibre8">The return value from the preprocessor will be the new value used for the entire binding.</p><p class="calibre8">Let's look at a few examples.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec46" class="calibre1"/>The uppercase preprocessor</h2></div></div></div><p class="calibre8">The Knockout <a id="id231" class="calibre1"/>documentation <a id="id232" class="calibre1"/>provides an example for this preprocessor that, at the time of writing this, returns <code class="literal">value + ".toUpperCase()"</code>. The full preprocessor will look like this:</p><div><pre class="programlisting">ko.bindingHandlers.text.preprocess = function(value) {
  return value + '.toUpperCase()';
};</pre></div><p class="calibre8">The preceding code would work, for example, at the beginning of this section when it took a string directly:</p><div><pre class="programlisting">&lt;span data-bind="text: 'That Guy'"&gt;&lt;/span&gt;</pre></div><p class="calibre8">The result of our preprocessor will be <code class="literal">text: 'That Guy'.toUpperCase()</code> and the text binding will handle this without any error. Unfortunately, this will break in the normal case of binding against observable properties:</p><div><pre class="programlisting">&lt;span data-bind="text: firstName"&gt;&lt;/span&gt;</pre></div><p class="calibre8">Knockout's normal binding process unwraps the expression it gets so that observables don't need parentheses. Preprocessors, on <a id="id233" class="calibre1"/>the other hand, just output strings that are directly consumed by the binding handler. Our uppercase binding will produce an illegal result here:</p><div><pre class="programlisting">&lt;span data-bind="text: firstName.toUpperCase()"&gt;&lt;/span&gt;</pre></div><p class="calibre8">This <a id="id234" class="calibre1"/>will fail, as <code class="literal">firstName</code> is an observable and not a string, and observables don't have a <code class="literal">toUpperCase</code> method.</p><p class="calibre8">Luckily, the solution to this is simple. Our preprocessor can safely handle all value expressions by applying an <code class="literal">unwrap</code> function to the output:</p><div><pre class="programlisting">ko.bindingHandlers.text.preprocess = function(value) {
    return 'ko.unwrap(' + value + ').toUpperCase()';
};</pre></div><p class="calibre8">This will ensure that any value—whether a primitive type, observable, or inline expression—is correctly evaluated by the binding handler.</p><p class="calibre8">You can see an example of this preprocessor in the <code class="literal">cp3-uppercase</code> branch.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec47" class="calibre1"/>Wrapping existing bindings</h2></div></div></div><p class="calibre8">Because Knockout provides <a id="id235" class="calibre1"/>default bindings for most standard scenarios, it's common to want for a custom binding to build on top of them. Preprocessors make wrapping other bindings very easy.</p><p class="calibre8">Let's say that we wanted a binding that caused an element to flash when a property was updated in addition to providing a <code class="literal">value</code> binding on it. Normally, you might want to divide these into two separate bindings, but if you are doing this a lot, a single binding will save time and keystrokes.</p><p class="calibre8">As the <code class="literal">value</code> binding already exists, we can just use a preprocessor to add the binding with the <code class="literal">addBinding</code> callback:</p><div><pre class="programlisting">ko.bindingHandlers.valueFlash = {
  preprocess: function(value, name, addBinding) {
      addBinding('value', value);
      return value;
  },
  update: function(element, valueAccessor) {
        ko.unwrap(valueAccessor());  //unwrap to get dependency
        $(element).css({opacity: 0}).animate({opacity: 1}, 500);
    }
};</pre></div><p class="calibre8">The <code class="literal">addBinding</code> callback takes care of generating the <code class="literal">value</code> binding as if it had been applied normally, which includes running the preprocessor for the new binding (if it has one).</p><p class="calibre8">It's important that we still return the original value after adding the <code class="literal">value</code> binding. If nothing is returned from the <code class="literal">preprocess</code> function, then the original binding is removed. After this, the rest of the binding handler is business as usual: add an <code class="literal">init</code> and <code class="literal">update</code> function (as required) and write your custom behavior. There is an example of this binding in the <code class="literal">cp3-wrap</code> branch.</p><p class="calibre8">That's really all there is to <a id="id236" class="calibre1"/>creating binding handler preprocessors. For the extensibility they allow, they are simple and straightforward to use. We will look at some more real-world possibilities for binding preprocessors when we look at <code class="literal">Knockout.Punches</code> in the last section of this chapter.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Node preprocessors</h1></div></div></div><p class="calibre8">Binding handler <a id="id237" class="calibre1"/>preprocessors are attached to individual binding handlers and work by modifying the binding string. They only apply to nodes of their respective handler.</p><p class="calibre8">Node preprocessors, on the other hand, are called on every DOM node. They run when the UI is first bound and when it is modified by bindings such as <code class="literal">foreach</code> or <code class="literal">template</code>.</p><p class="calibre8">The purpose of a node preprocessor is to modify the DOM before data-binding occurs, as opposed to a binding preprocessor that only modifies the <code class="literal">data-bind</code> attribute. A node preprocessor is defined by adding a <code class="literal">preprocessNode</code> function to the binding provider:</p><div><pre class="programlisting">ko.bindingProvider.instance.preprocessNode = function(node) {
  /* DOM code */
}</pre></div><p class="calibre8">A preprocessor is called once for each node. If no changes need to be made, it should return nothing. Otherwise, it can use the standard DOM API to insert new nodes or remove the current node:</p><div><ul class="itemizedlist"><li class="listitem">New nodes should be inserted before the current node by using:<div><pre class="programlisting">node.parentNode.insertBefore(newNode, node);</pre></div></li><li class="listitem">Replacement can be done with:<div><pre class="programlisting">node.parentnode.replaceChild(newNode, node);</pre></div></li><li class="listitem">Removal can be done with:<div><pre class="programlisting">node.parentNode.removeChild(node);</pre></div></li></ul></div><p class="calibre8">Any nodes that are added <a id="id238" class="calibre1"/>need to be returned from <code class="literal">preprocessNode</code>; otherwise, Knockout will not apply bindings to them. As you do not have the binding context inside <code class="literal">preprocessNode</code> (you only have the current node), it is not possible to apply bindings yourself, unless they are applied to constant or global values. This is not recommended, though, as it creates a new binding context outside of the current context's hierarchy.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec48" class="calibre1"/>Closing virtual template nodes</h2></div></div></div><p class="calibre8">The Knockout<a id="id239" class="calibre1"/> documentation<a id="id240" class="calibre1"/> provides a handy node preprocessor that self-closes virtual template bindings. Normally, when writing a containerless template binding, you would need two comment nodes:</p><div><pre class="programlisting">&lt;!-- template: 'some-template' --&gt;&lt;!-- /ko --&gt;</pre></div><p class="calibre8">As a template binding never contains content when referencing an external template, the closing comment node feels unnecessary. A <code class="literal">preprocess</code> function will allow you to use a template without the closing tag so that you can write the binding like this:</p><div><pre class="programlisting">&lt;!-- template: 'some-template' --&gt;</pre></div><p class="calibre8">Knockout requires a closing comment tag, which is <code class="literal">&lt;!-- /ko --&gt;</code>, for virtual bindings. We can provide this comment node automatically with a preprocessor:</p><div><pre class="programlisting">ko.bindingProvider.instance.preprocessNode = function(node) {
   if (node.nodeType == node.COMMENT_NODE) {
      var match = node.nodeValue.match(/^\s*(template\s*:[\s\S]+)/);
      if (match) {
         // Create a pair of comments to replace the single comment
         var c1 = document.createComment("ko " + match[1]),
            c2 = document.createComment("/ko");
         node.parentNode.insertBefore(c1, node);
         node.parentNode.replaceChild(c2, node);
 
         // Tell Knockout about the new nodes so that it can apply bindings to them
         return [c1, c2];
      }
   }
};</pre></div><p class="calibre8">This sample uses regex to identify template comments and extract the expression from the binding. Then, it replaces the original comment with the standard open/close pair of comments for a <a id="id241" class="calibre1"/>virtual template binding. Finally, it returns the new<a id="id242" class="calibre1"/> comment nodes, allowing Knockout to bind them; this will apply the template to the virtual container created by the comment nodes.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec49" class="calibre1"/>Supporting alternate syntaxes</h2></div></div></div><p class="calibre8">The previous example should<a id="id243" class="calibre1"/> have given you an idea of how node preprocessors work. However, the real power of node preprocessors comes from letting us extend the data binding syntax itself.</p><p class="calibre8">It's not uncommon to see a series of text bindings like this one:</p><div><pre class="programlisting">First Name: &lt;!-- text: firstName --&gt;&lt;!-- /ko --&gt;
Last Name: &lt;!-- text: lastName  --&gt;&lt;!-- /ko --&gt;
Birth Date: &lt;!-- text: birthDate --&gt;&lt;!-- /ko --&gt;</pre></div><p class="calibre8">We want to list out several properties, but these virtual elements are pretty verbose. On top of the property name, they add 29 characters, including spaces. We can also use <code class="literal">span</code> elements, of course, but they are about the same size, considering that they need the <code class="literal">data-bind</code> attributes in addition to the binding name.</p><p class="calibre8">If you've ever used AngularJS or Handlebars, you'll probably appreciate the minimal requirement of using curly braces to access values as strings. The preceding example will look like this:</p><div><pre class="programlisting">First Name: {{ firstName }}
Last Name: {{ lastName }}
Birth Date: {{ birthDate }}</pre></div><p class="calibre8">Look how much shorter and easier to read this is! These Handlebars guys have the right idea. I'm sure you know where we are going with this. A node preprocessor will allow us to take this same HTML and replace it with the HTML from the first example.</p><p class="calibre8">This example is long, so we are going to break it up a bit:</p><div><pre class="programlisting">var expressionRegex = /{{([\s\S]+?)}}/g;
ko.bindingProvider.instance.preprocessNode = function(node) {
    if (node.nodeType === 3 &amp;&amp; node.nodeValue) {
        var newNodes = //Collect new nodes by scanning "node"

        // Insert the resulting nodes into the DOM
        // remove the original unprocessed node
        if (newNodes) {
            for (var i = 0; i &lt; newNodes.length; i++) {
                node.parentNode.insertBefore(newNodes[i], node);
            }
            node.parentNode.removeChild(node);
            return newNodes;
        }
    }
};</pre></div><p class="calibre8">First, we have a regex <a id="id244" class="calibre1"/>pattern that finds these double curly brace chunks. As text nodes will contain any content up to the first real element they encounter, its possible that multiple curly brace chunks might be in a single node, so it needs to match globally. Then, the <code class="literal">preprocess</code> function starts out by checking for the text node type.</p><p class="calibre8">I've omitted the section that actually scans the node to create new ones for now; we will come back to that in just a bit.</p><p class="calibre8">If we have any nodes that need to be added, they get inserted, and then the original node is removed. Finally, the nodes we inserted are returned so that Knockout can bind them.</p><p class="calibre8">This is almost boilerplate code for node preprocessors, and it's a very good pattern to follow. Check for a type, create any new nodes, replace the original nodes if there are any, and return the new nodes. If you are creating a node preprocessor, this is a good template to start with.</p><p class="calibre8">Okay, let's get to the meat. To assign <code class="literal">newNodes</code>, we need to check the node for our regex pattern and build a pair of virtual text bindings for each match:</p><div><pre class="programlisting">var newNodes = replaceExpressionsInText(node.nodeValue, expressionRegex, function(expressionText) {
    return [
        document.createComment("ko text:" + expressionText),
        document.createComment("/ko")
    ];
});</pre></div><p class="calibre8">Here, we are calling <code class="literal">replaceExpressionsInText</code> and passing the node's contents, our regex pattern, and a callback that builds the correct replacements with the expression found by our regex. Then, we just need the actual search:</p><div><pre class="programlisting">function replaceExpressionsInText(text, expressionRegex, callback) {
    var prevIndex = expressionRegex.lastIndex = 0,
        resultNodes = null,
        match;
        
    while (match = expressionRegex.exec(text)) {
        var leadingText = text.substring(prevIndex, match.index);
        prevIndex = expressionRegex.lastIndex;
        resultNodes = resultNodes || [];

        // Preserve leading text
        if (leadingText) {
            resultNodes.push(document.createTextNode(leadingText));
        }

        resultNodes.push.apply(resultNodes, callback(match[1]));
    }

    // Preserve trailing text
    var trailingText = text.substring(prevIndex);
    if (resultNodes &amp;&amp; trailingText) {
        resultNodes.push(document.createTextNode(trailingText));
    }

    return resultNodes;
}</pre></div><p class="calibre8">The search function <a id="id245" class="calibre1"/>loops on the regex pattern and pulls out the first match. It sends the match to the callback function and keeps the result, along with any leading or trailing spaces. When it's finished matching, it returns them.</p><p class="calibre8">That's it. Now, our Handlebars code will be converted to virtual text bindings. You can see this example in the <code class="literal">cp3-interpolate</code> branch.</p><div><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">This code is adapted from the <code class="literal">StringInterpolatingBindingProvider</code> demo<a id="id246" class="calibre1"/> at <a class="calibre1" href="http://blog.stevensanderson.com/2013/07/09/">http://blog.stevensanderson.com/2013/07/09/</a>.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec12" class="calibre1"/>Multiple syntaxes</h3></div></div></div><p class="calibre8">If we wanted to push this example a bit farther, we could support additional interpolation syntaxes. <code class="literal">replaceExpressionsInText</code> is already set up to take regex input, and as it uses a callback, we can even construct nodes differently for different regex patterns.</p><p class="calibre8">Let's add the<a id="id247" class="calibre1"/> embedded Ruby syntax interpolation, which uses <code class="literal">&lt;%= expression %&gt;</code>:</p><div><pre class="programlisting">// Replace &lt;%= expr %&gt; with data bound span's
var erbNodes = replaceExpressionsInText(node.nodeValue, /\&lt;\%=([\s\S]+?)\%\&gt;/g, function(expressionText) {
    var span = document.createElement('span');
    span.setAttribute('data-bind', 'text: ' + expressionText);
    return [span];
});</pre></div><p class="calibre8">This time, we are <a id="id248" class="calibre1"/>replacing a <code class="literal">span</code> element instead of a virtual text element so that we can tell the resulting HTML apart. As this preprocessor can support both syntaxes, you can bind against a mixed syntax template:</p><div><pre class="programlisting">First Name: {{ firstName }}
Last Name: &lt;%= lastName %&gt;
Birth Date: {{ birthDate }}</pre></div><p class="calibre8">The resulting HTML will look like this:</p><div><pre class="programlisting">First Name: &lt;!--ko text: firstName --&gt;&lt;!--/ko--&gt;
Last Name: &lt;span data-bind="text: lastName"&gt;&lt;/span&gt;
Birth Date: &lt;!--ko text: birthDate --&gt;&lt;!--/ko--&gt;</pre></div><p class="calibre8">You can see this example in the <code class="literal">cp3-interpolate2</code> branch.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Binding providers</h1></div></div></div><p class="calibre8">With a binding preprocessor, we <a id="id249" class="calibre1"/>have access to the binding expression and can modify it before the evaluation of bindings. With a node preprocessor, we have access to the node and can modify the DOM before bindings are applied. Both of these just transform things into the normal Knockout syntax. They are also limited to operating on the DOM, and they do not have access to the binding context.</p><p class="calibre8">Knockout binding providers are objects that receive both the DOM node and the binding context and determine which bindings handlers will be applied and what <code class="literal">valueAccessor</code> properties those bindings receive.</p><p class="calibre8">A binding provider is expected to provide the following functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">nodeHasBindings(node)</code>: This <a id="id250" class="calibre1"/>function should return a Boolean that indicates whether or not the node has any bindings defined on it.</li><li class="listitem"><code class="literal">getBindingAccessors(node, bindingContext)</code>: This function should return an object with <a id="id251" class="calibre1"/>a property for each binding to be applied whose value is a function that evaluates the binding expression. This function is used as the <code class="literal">valueAccessor</code> property in binding handlers.</li></ul></div><div><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">If you are targeting 2.x, you will need to support <code class="literal">getBindings</code>, which returns an object whose property values are the final binding values. This function was deprecated with Knockout 3.0.</p></div><p class="calibre8">The default binding<a id="id252" class="calibre1"/> provider operates by looking for <code class="literal">data-bind</code> attributes on an element or a comment node that starts with <code class="literal">ko</code>. If it does, <code class="literal">nodeHasBindings</code> will return <code class="literal">true</code>. When <code class="literal">getBindingAccessors</code> is called, it returns the bindings by evaluating the <code class="literal">data-bind</code> attribute and getting the <code class="literal">valueAccessors</code> property from the binding context.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec50" class="calibre1"/>Custom binding providers</h2></div></div></div><p class="calibre8">We've already seen how we <a id="id253" class="calibre1"/>can use preprocessors to allow for different<a id="id254" class="calibre1"/> syntaxes to be used for data binding. So, to get a better understanding of the capability of binding providers, we are going to look at something preprocessors can't do: choosing bindings based on the data type.</p><p class="calibre8">The Knockout <a id="id255" class="calibre1"/>plugin <code class="literal">Knockout.BindingConventions</code> (<a class="calibre1" href="https://github.com/AndersMalmgren/Knockout.BindingConventions">https://github.com/AndersMalmgren/Knockout.BindingConventions</a>) creates a binding provider that provides bindings on the <code class="literal">data-name</code> attribute by looking at the binding context for clues on the bindings that are to be used, which makes it a great example for a custom provider. As this is a big change from how Knockout works, let's compare this to a standard viewmodel and binding setup:</p><div><pre class="programlisting">var BindingSample = function() {
   var self = this;

   self.name = ko.observable('Timothy');
   self.locations = ['Portland', 'Seattle', 'New York City'];
   self.selectedLocation = ko.observable();
   self.isAdmin = ko.observable(true););
}; </pre></div><p class="calibre8">Binding to this with standard Knockout bindings might look something like this:</p><div><pre class="programlisting">&lt;label&gt;Name
  &lt;input data-bind="value: name" /&gt;
&lt;/label&gt;
&lt;label&gt;LocationLocationName
  &lt;select data-bind="options: locations, value: selectedLocation"&gt;&lt;/select&gt;
&lt;/label&gt;
&lt;label&gt;Admin
  &lt;input data-bind="checked: isAdmin" type="checkbox" /&gt;
&lt;/label&gt;</pre></div><p class="calibre8">We've got three bound elements and four bindings. The first input is a <code class="literal">value</code> that is binding to <code class="literal">name</code>, the <code class="literal">select</code> element is binding to <code class="literal">options</code> on <code class="literal">locations</code> and <code class="literal">value</code> on <code class="literal">selectedLocation</code>, and the last input is binding <code class="literal">checked</code> to <code class="literal">isAdmin</code>. A simple case, such as having to specify that the binding on an input is a value, might seem verbose; in most cases, an input will be binding against the value, or in the case of a checkbox, binding against <code class="literal">checked</code>.</p><p class="calibre8">The convention-over-configuration philosophy aims to remove the need to specify what is happening in a conventional scenario. In other words, perform the standard action unless otherwise specified. Here is how the previous DOM would look using the <code class="literal">BindingConventions</code> plugin:</p><div><pre class="programlisting">&lt;label&gt;Name
  &lt;input data-name="name" /&gt;
&lt;/label&gt;
&lt;label&gt;LocationNameLocation
  &lt;select data-name="locations"&gt;&lt;/select&gt;
&lt;/label&gt;
&lt;label&gt;Admin
  &lt;input data-name="isAdmin" /&gt;
&lt;/label&gt; </pre></div><p class="calibre8">Here, <code class="literal">BindingConventions</code> is doing<a id="id256" class="calibre1"/> all the work of figuring out the<a id="id257" class="calibre1"/> bindings. The <code class="literal">name</code> input is a string observable on our viewmodel, and it's on an input node, so it gets the <code class="literal">value</code> binding. The <code class="literal">isAdmin</code> input is a Boolean observable on our viewmodel, so the input node is converted into a checkbox, and it receives the <code class="literal">checked</code> binding. The <code class="literal">locations</code> property is an array on our viewmodel, so the <code class="literal">select</code> element gets an <code class="literal">options</code> binding. However, this is not all! Our viewmodel has a <code class="literal">selectedLocations</code> observable, which <code class="literal">BindingConventions</code> determines should get a <code class="literal">value</code> binding for the <code class="literal">select</code> element, as singularizing an array name and prepending <code class="literal">selected</code> is a binding convention.</p><p class="calibre8">That last one might seem like magic, and personally, I think it's a bit too non-obvious, but it has a certain appeal to it. If you are following conventions, you can really simplify your bindings. You can see this example in action in the <code class="literal">cp3-provider</code> branch.</p><p class="calibre8">Now that you can see what this binding provider is doing, let's look at how it works.</p><div><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">We will be looking at a simplified version of the binding provider in the <code class="literal">BindingConventions</code> plugin. The real provider supports more conventions and allows for custom conventions to be added. This sample is only meant to illustrate the type detection concept and the basics of creating a custom provider.</p></div><p class="calibre8">The first thing that needs to be decided when creating a custom binding provider is whether you need to extend the default binding provider or replace it. The <code class="literal">BindingConventions</code> provider will support the <code class="literal">data-name</code> attribute. In this case, it makes sense to extend the default provider, as they do not conflict with each other and we will need the standard <code class="literal">data-bind</code> support for scenarios that are nonconventional (such as binding our select value to a <code class="literal">favoriteLocation</code> property).</p><p class="calibre8">The easiest way to do this is to store a reference to the original binding provider and call it in our custom provider:</p><div><pre class="programlisting">ko.bindingConventions = {};
ko.bindingConventions.ConventionBindingProvider = function () {
     this.orgBindingProvider = ko.bindingProvider.instance || new ko.bindingProvider();
 };

var nodeHasBindings = function(node) { /* check node */ };
var conventionBindings = function(node, bindingContext) { /* check node */ };

 ko.bindingConventions.ConventionBindingProvider.prototype = {
     nodeHasBindings: function (node) {
         return this.orgBindingProvider.nodeHasBindings(node) || nodeHasBindings(node);
     },
     getBindingAccessors: function (node, bindingContext) {
         return this.orgBindingProvider.getBindingAccessors(node, bindingContext)
            || conventionBindings(node, bindingContext);
     }
 };
 ko.bindingProvider.instance = new ko.bindingConventions.ConventionBindingProvider();</pre></div><p class="calibre8">This is basically <a id="id258" class="calibre1"/>boilerplate for a binding provider that<a id="id259" class="calibre1"/> extends the default one. It stores the original provider and implements the <code class="literal">nodeHasBindings</code> and <code class="literal">getBindingAccessors</code> functions by calling the default provider first, calling its own implementation if the default provider returns nothing. If you want your provider to check for bindings before the default one, you can switch the order of the calls. Finally, you can combine the two by appending binding handlers to the result of the default provider.</p><p class="calibre8">After setting up the required functions, <code class="literal">ko.bindingProvider.instance</code> is replaced with the new custom provider. It's important to note that this must all be done prior to <code class="literal">ko.applyBindings</code> being called, as the binding provider is only constructed once for the root binding context.</p><p class="calibre8">From here, all we have to do is provide the methods that check for bindings and create them. Checking for bindings just requires you to check for the <code class="literal">data-name</code> attribute:</p><div><pre class="programlisting">var getNameAttribute = function (node) {
   var name = null;
   if (node.nodeType === 1) {
      name = node.getAttribute("data-name");
   }
   return name;
};

var nodeHasBindings = function(node) { 
   return getNameAttribute(node) !== null; 
};</pre></div><p class="calibre8">Getting the value from the binding context is a bit more work. Knockout has utility methods that can parse expressions under the <code class="literal">ko.expressionRewriting</code> object, which can read any of<a id="id260" class="calibre1"/> the supported Knockout binding <a id="id261" class="calibre1"/>syntaxes. The <code class="literal">BindingConventions</code> plugin does not support anything other than property references, but it does support deep references such as <code class="literal">person.firstName</code>. For simplicity's sake, I am not going to cover this, but if you are interested in this, you can look at <code class="literal">getDataFromComplexObjectQuery</code> in the plugin's source code. For now, we will assume that all <code class="literal">data-name</code> attributes refer directly to a property:</p><div><pre class="programlisting">var conventionBindings = function(node, bindingContext) {
   var bindings = {};
   var name = getNameAttribute(node);
   if (name === null) {
      return null;
}

   var data = bindingContext[name] ? bindingContext[name] : bindingContext.$data[name];

   if (data === undefined) {
      throw "Can't resolve member: " + name;
   }

   var unwrapped = ko.utils.peekObservable(data);
   var type = typeof unwrapped;

   //Loop through convention handlers to construct bindings

   return bindings;
};</pre></div><p class="calibre8">First, we get the name of the viewmodel property from the <code class="literal">data-name</code> attribute, and then we perform a sanity check to make sure that it's there to bind against. Then, we get the data with <code class="literal">ko.utils.peekObservable</code> and check its type. All observables have a <code class="literal">peek</code> function that returns the underlying value without triggering dependency detection. The <code class="literal">peekObservable</code> function will call <code class="literal">peek</code> if the first parameter is observable; otherwise, it will just return the first parameter. It's a safety utility that is similar to <code class="literal">ko.uwrap</code>.</p><p class="calibre8">After we have<a id="id262" class="calibre1"/> these two bits of information, we can <a id="id263" class="calibre1"/>build the binding object we need to return. Remember, this binding object should have a property named after the binding to be applied, whose value is the <code class="literal">valueAccessor</code> object for the binding. The bindings are returned to the binding provider's <code class="literal">getBindingAccessors</code> function. To construct the bindings, we will loop over a set of conventions:</p><div><pre class="programlisting">for (var index in ko.bindingConventions.conventionBinders) {
   if (ko.bindingConventions.conventionBinders[index].rules !== undefined) {
      var convention = ko.bindingConventions.conventionBinders[index];
      var shouldApply = true;

      convention.rules.forEach(function (rule) {
         shouldApply = shouldApply &amp;&amp; rule(name, node, bindings, unwrapped, type, data, bindingContext);
      });

      if (shouldApply) {
         convention.apply(name, node, bindings, unwrapped, type, function() { return data }, bindingContext);
         break;
      }
   }
}</pre></div><p class="calibre8">This will look through the <code class="literal">conventionBinders</code> array and check the rules for each one in order to find a match for the current node, data, and data type. If all of the rules for a convention handler pass, then we call <code class="literal">apply</code> for that convention and stop checking—only one convention should apply per node. The <code class="literal">apply</code> function gets all of the information we've collected so far as well as a <code class="literal">valueAccessor</code> property that can be used for the binding.</p><p class="calibre8">Our example is only using two conventions, which are <code class="literal">options</code> and <code class="literal">input</code>:</p><div><pre class="programlisting">ko.bindingConventions.conventionBinders.options = {
  rules: [function (name, element, bindings, unwrapped) { return element.tagName === 'SELECT' &amp;&amp; unwrapped.push; } ],
  apply: function (name, element, bindings, unwrapped, type, valueAccessor, bindingContext) {
      bindings.options = valueAccessor;
      singularize(name, function (singularized) {
         var selectedName = 'selected' + getPascalCased(singularized);
         if (bindingContext.$data[selectedName] !== undefined) {
            bindings['value'] = function() {
               return bindingContext.$data[selectedName];
            };
         }
      });
  }
};</pre></div><p class="calibre8">The options<a id="id264" class="calibre1"/> have just one rule: the element must be a <a id="id265" class="calibre1"/>
<code class="literal">select</code> element, and the data needs to be an array (which is being checked by looking for a <code class="literal">push</code> function).</p><p class="calibre8">The <code class="literal">apply</code> function sets the options binding directly to the <code class="literal">valueAccessor</code> property. Then, it tries to find a property that matches the <code class="literal">'selected' + getPascalCased(singularized)</code> convention on the context. The <code class="literal">singularize</code> and <code class="literal">getPascalCased</code> functions are not included here, but you can see them in the example branch in the following code. Predictably, they find a singular conjugation of a word and capitalize the first letter. If a match is found, a <code class="literal">value</code> binding is added to the <code class="literal">bindings</code> object that was passed in.</p><p class="calibre8">The <code class="literal">input</code> handler is much simpler:</p><div><pre class="programlisting">ko.bindingConventions.conventionBinders.input = {
  rules: [function (name, element) { return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA'; } ],
  apply: function (name, element, bindings, unwrapped, type, valueAccessor, bindingContext) {
      var bindingName = null;
      if (type === 'boolean') {
          element.setAttribute('type', 'checkbox');
          bindingName = 'checked';
      } else {
          bindingName = 'value';
      }
      bindings[bindingName] = valueAccessor;
  }
};</pre></div><p class="calibre8">The <code class="literal">input</code> handler's rules don't check the data type; it's just that the node is either <code class="literal">input</code> or <code class="literal">textarea</code>. The <code class="literal">apply</code> function will use a <code class="literal">value</code> binding if the type is not <code class="literal">Boolean</code>; otherwise, it sets the <code class="literal">checkbox</code> property on the node and uses the <code class="literal">checked</code> binding.</p><p class="calibre8">That's it. This binding provider will allow binding to occur with the <code class="literal">data-name</code> attribute, requiring only a view model property as the value, and it intelligently sets up bindings for the conventional scenario. If we need more control, the regular <code class="literal">data-bind</code> attributes can still be used to apply bindings.</p><p class="calibre8">This simplified implementation of the <code class="literal">BindingConventions</code> binding provider can be seen in the <code class="literal">cp3-provider2</code> branch. The <code class="literal">client/app</code> directory in the branch contains both the simplified implementation discussed here as well as the full implementation from the plugin.</p><p class="calibre8">None of this <a id="id266" class="calibre1"/>would be possible with a binding or node<a id="id267" class="calibre1"/> preprocessor, as it relies on the type of data from the binding context. Hopefully, this will give you a good idea of what is possible with custom binding providers and the flexibility of the overall binding system.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Knockout punches</h1></div></div></div><p class="calibre8">Now that you are familiar with the <a id="id268" class="calibre1"/>techniques that are used to modify the binding syntax and the general use of preprocessors, we are going to look at the popular Knockout plugin <code class="literal">Knockout.Punches (get it?)</code>. Punches is written by Michael Best, who is a Knockout developer and the creator of the Knockout preprocessor functionality and some of the best real-world use cases for preprocessors. We are going to look at some of them and dig in to see how they work. This section is not going to cover everything in Knockout Punches; if you want to learn more about it, you can check out the documentation online.</p><div><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">The documentation for <code class="literal">Knockout.Punches</code> can be<a id="id269" class="calibre1"/> found at <a class="calibre1" href="http://mbest.github.io/knockout.punches">http://mbest.github.io/knockout.punches</a>, which includes an API reference and the source code.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec51" class="calibre1"/>Embedded text bindings</h2></div></div></div><p class="calibre8">Embedded text bindings offer the same <a id="id270" class="calibre1"/>syntax that we created with<a id="id271" class="calibre1"/> the preprocessor in the <em class="calibre12">Supporting alternate syntaxes</em> section—converting curly braces into virtual text nodes:</p><div><pre class="programlisting">&lt;div&gt;Hello {{ name }}.&lt;/div&gt;</pre></div><p class="calibre8">The previous command becomes the following:</p><div><pre class="programlisting">&lt;div&gt;Hello &lt;!--ko text:name--&gt;&lt;!--/ko--&gt;.&lt;/div&gt;</pre></div><p class="calibre8">The method<a id="id272" class="calibre1"/> Knockout Punches uses is more performant<a id="id273" class="calibre1"/> than the one we looked at, but it still offers the same customizability we used. If you want to use something besides virtual text nodes as the interpolation replacement, you can provide your own <code class="literal">node-array</code> returning function as a replacement for the following:</p><div><pre class="programlisting">ko.punches.utils.interpolationMarkup.wrapExpression(expressionText)</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec52" class="calibre1"/>Namespaced bindings</h2></div></div></div><p class="calibre8">Knockout Punches<a id="id274" class="calibre1"/> offers a<a id="id275" class="calibre1"/> shorthand binding syntax that expands <code class="literal">x.y: value</code> to <code class="literal">x : { y: value }</code>. By default, this namespace syntax is available for the <code class="literal">event</code>, <code class="literal">attr</code>, <code class="literal">style</code>, and <code class="literal">css</code> bindings. Using it on the <code class="literal">style</code> binding will cause the following to expand:</p><div><pre class="programlisting">&lt;div data-bind="style.color: textColor"&gt;&lt;/div&gt;</pre></div><p class="calibre8">This will expand to the following:</p><div><pre class="programlisting">&lt;div data-bind="style: { color: textColor }"&gt;&lt;/div&gt;</pre></div><p class="calibre8">This works by overriding the standard <code class="literal">ko.getBindingHandler</code> function, which just returns the binding handler normally. It is replaced by one that looks for a dot in the name of the binding with a matching <code class="literal">getNamespacedHandler</code> property and returns that one instead.</p><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec13" class="calibre1"/>Dynamic namespaced bindings</h3></div></div></div><p class="calibre8">Because <code class="literal">ko.getBindingHandler</code> is overridden<a id="id276" class="calibre1"/> like this, it is possible<a id="id277" class="calibre1"/> to create your own binding namespaces by adding a <code class="literal">getNamespacedHandler</code> property to a binding handler:</p><div><pre class="programlisting">ko.bindingHandlers.customNamespace = {
    getNamespacedHandler: function(binding) {
        return {
           init: function(element, valueAccessor) { },
           update: function(element, valueAccessor) { }
        };
    }
};</pre></div><p class="calibre8">The <code class="literal">binding</code> argument is the name of the binding; for <code class="literal">style.color</code>, it will be <code class="literal">color</code>. The function returns the binding handler to be used. This allows you to provide a single dynamic handler for all bindings in a namespace.</p><p class="calibre8">Let's say that we <a id="id278" class="calibre1"/>want to create a binding <a id="id279" class="calibre1"/>namespace for the Twitter Bootstrap tooltip plugin. We need to supply the text contents and the direction of the tooltip. Normally, we might write a binding that took each of these as options:</p><div><pre class="programlisting">ko.bindingHandlers.tooltip = {
    update: function(element, valueAccessor) {
      //Cleanup previous tooltips
      if (element.attributes['data-original-title']) {
        $(element).tooltip('destroy');
    }
      var options = valueAccessor();
        $(element).tooltip({ 
          placement: options.placement || 'left', 
          title: ko.unwrap(options.title || 'sample') 
        });
    }
};</pre></div><p class="calibre8">Then, we could bind on it with an object:</p><div><pre class="programlisting">data-bind="tooltip: { placement: 'top', title: title}"</pre></div><p class="calibre8">This works fine, but we can rewrite this using a namespaced binding handler in order to get the dot syntax for the placement:</p><div><pre class="programlisting">ko.bindingHandlers.tooltip = {
    getNamespacedHandler: function(binding) {
        return {            
            update: function(element, valueAccessor) {
              //Cleanup previous tooltips
              if (element.attributes['data-original-title']) {
                $(element).tooltip('destroy');
      }
                $(element).tooltip({ 
                  placement: binding, 
                  title: ko.unwrap(valueAccessor()) 
                });
            }
        };
    }
};</pre></div><p class="calibre8">This produces a much shorter binding attribute, which I think is easier to read:</p><div><pre class="programlisting">data-bind="tooltip.top: title"</pre></div><p class="calibre8">An example of<a id="id280" class="calibre1"/> this <a id="id281" class="calibre1"/>can be seen in the <code class="literal">cp3-namespace</code> branch.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec53" class="calibre1"/>Binding filters</h2></div></div></div><p class="calibre8">It's pretty common to perform <a id="id282" class="calibre1"/>filtering on viewmodel properties. The usual<a id="id283" class="calibre1"/> practice is to have a computed property on the viewmodel perform the filtering, but this can become verbose, especially if you have several different filtered properties. Knockout Punches provides syntax that applies filter expressions inside of bindings:</p><div><pre class="programlisting">&lt;span data-bind="text: name | fit:20 | uppercase"&gt;&lt;/span&gt;</pre></div><p class="calibre8">Filters are pipe-delimited, and multiple arguments are separated by colons. For example, <code class="literal">fit</code> takes up to three arguments, which can be specified with <code class="literal">fit:20:'…':'middle'</code>.</p><p class="calibre8">It should be noted that <code class="literal">name</code> does not include the observable parentheses in the preceding example. While the entire binding with the filters is a single expression, which would normally require the parentheses, Knockout Punches intelligently handles each section by calling <code class="literal">ko.unwrap</code> on it. This means that the binding value and each filter are treated as their own expression.</p><p class="calibre8">Filtering is accomplished with a binding preprocessor that parses the expression and recursively unwraps the piped sections into a call to the filter. The preceding example will end up returning the following from the <code class="literal">preprocess</code> function:</p><div><pre class="programlisting">ko.filters['uppercase'](ko.filters['fit'](name,20))</pre></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec14" class="calibre1"/>Writing custom filters</h3></div></div></div><p class="calibre8">Adding your own filters is very <a id="id284" class="calibre1"/>similar to adding binding handlers. Just add a function to the <code class="literal">ko.filters</code> object that takes a value and any number of arguments and returns a modified value:</p><div><pre class="programlisting">ko.filters.translate = function(value, language) {
    return SomeLanguageLibrary.translate(value, language);
}</pre></div><p class="calibre8">The first argument is the current value that is to be processed. All other arguments are those that are given to the filter in the binding expression.</p><p class="calibre8">Filters can have zero arguments—as in the <code class="literal">uppercase</code> example—or optional arguments—as in the <code class="literal">fit</code> example. The filter preprocessor does not check the filter to see whether the number of arguments it's sending make sense; it just calls the filter with everything in the binding expression.</p><p class="calibre8">The filter preprocessor is <a id="id285" class="calibre1"/>simple to extend, and it offers considerable power. I think it is one of the best examples anywhere of the potential of binding preprocessors.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec15" class="calibre1"/>Filters on other bindings</h3></div></div></div><p class="calibre8">By default, filters are enabled for<a id="id286" class="calibre1"/> the <code class="literal">text</code>, <code class="literal">attr</code>, and <code class="literal">html</code> bindings, but additional bindings can use filters by calling <code class="literal">ko.punches.textFilter.enableForBinding(&lt;binding&gt;)</code>. This can be useful if you wanted to take advantage of filters on a custom binding.</p><p class="calibre8">Filters cannot be used in two-way bindings, such as the binding value, as they always produce inline expressions.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec54" class="calibre1"/>Adding additional preprocessors</h2></div></div></div><p class="calibre8">Knockout Punches provides two utility methods in order to add additional binding and node preprocessors that can be accessed from <code class="literal">ko.punches.utils</code>:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">addBindingPreprocessor(bindingKeyOrHandler, preprocessFn)</code></li><li class="listitem"><code class="literal">addNodePreprocessor(preprocessFn)</code></li></ul></div><p class="calibre8">If you call either of these <a id="id287" class="calibre1"/>multiple times, the respective preprocessors will be chained together, with each new preprocessor being called at the end of the chain.</p><p class="calibre8">The binding preprocessors will run until one of them removes the binding or until the end of the chain is reached. This stops the chain from trying to process a binding that no longer exists.</p><p class="calibre8">The node preprocessors will run until one of them returns new nodes to add or until the end of the chain is reached. This stops the chain from trying to process a node that has already been modified. The new nodes will not be walked by the node preprocessors, so they should be added to the DOM and be made ready for data binding.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter was all about how to extend Knockout's binding process and modify its syntax. We covered three ways of doing this:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Binding Preprocessors</strong>: This is used to modify binding strings before binding handlers run</li><li class="listitem"><strong class="calibre9">Node Preprocessors</strong>: This is used to modify the DOM before the binding starts</li><li class="listitem"><strong class="calibre9">Binding Providers</strong>: This is used to control what bindings are applied to each DOM node</li></ul></div><p class="calibre8">Finally, we looked at the <code class="literal">Knockout.Punches</code> plugin to see some real-world Knockout extensions.</p><p class="calibre8">In the next chapter, we will cover Knockout's web component features, which let you tie view and viewmodel together into reusable controls.</p></div></body></html>