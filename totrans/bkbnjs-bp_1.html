<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building a Simple Blog"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Building a Simple Blog</h1></div></div></div><p>We're going to begin by assuming that your experience in Backbone is very minimal; in fact, even if you've never used Backbone before, you should still be able to follow along just fine. The application we're going to build in this chapter is a very simple blog<a id="id0" class="indexterm"/>. As blogs go, it's going to have very few features; there will be posts that viewers can read <a id="id1" class="indexterm"/>and make comments on. However, it will introduce you to every major feature in the Backbone library, get you comfortable with the vocabulary, and how these features work together in general.</p><p>By the end of this chapter, you'll know how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use Backbone's model, collection, and view components</li><li class="listitem" style="list-style-type: disc">Create a Backbone router that controls everything the user sees on the screen</li><li class="listitem" style="list-style-type: disc">Program the server side with Node.js (and Express.js) to create a backend for our Backbone app</li></ul></div><p>So let's get started!</p><div class="section" title="Setting up the application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up the application</h1></div></div></div><p>Every application has to<a id="id2" class="indexterm"/> be set up, so we'll begin with that. Create a folder for your project—I'll call mine <code class="literal">simpleBlog</code>—and inside that, create a file named <code class="literal">package.json</code>. If you've used Node.js before, you know that the <code class="literal">package.json</code> file describes the project; lists the project home page, repository, and other links; and (most importantly for us) outlines the dependencies for the application.</p><p>Here's what the <code class="literal">package.json</code> file looks like:</p><div class="informalexample"><pre class="programlisting">{
  "name": "simple-blog",
  "description": "This is a simple blog.",
  "version": "0.1.0",
  "scripts": {
    "start": "nodemon server.js"
  },
  "dependencies": {
    "express": "3.x.x",
    "ejs"    : "~0.8.4",
    "bourne" : "0.3"
  },
  "devDependencies": {
    "nodemon": "latest"
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>This is a pretty bare-bones <code class="literal">package.json</code> file, but it has all the important bits. The <code class="literal">name</code>, <code class="literal">description</code>, and <code class="literal">version</code> properties should be self-explanatory. The <code class="literal">dependencies</code> object lists all the npm packages that this project needs to run: the key is the name of the <a id="id3" class="indexterm"/>package and the value is the version. Since we're building an ExpressJS backend, we'll need the <code class="literal">express</code> package. The <code class="literal">ejs</code> package is for our server-side templates and <code class="literal">bourne</code> is our database (more on this one later).</p><p>The <code class="literal">devDependencies</code> property is similar to the <code class="literal">dependencies</code> property, except that these packages are only required for someone working on the project. They aren't required to just use the project. For example, a build tool and its components, such as Grunt, would be development dependencies. We want to use a package called <code class="literal">nodemon</code>. This package is really handy when building a Node.js backend: we can have a command line that runs the <code class="literal">nodemon server.js</code> command<a id="id4" class="indexterm"/> in the background while we edit <code class="literal">server.js</code> in our editor. The <code class="literal">nodemon</code> package<a id="id5" class="indexterm"/> will restart the server whenever we save changes to the file. The only problem with this is that we can't actually run the <code class="literal">nodemon server.js</code> command on the command line, because we're going to install <code class="literal">nodemon</code> as a local package and not a global process. This is where the <code class="literal">scripts</code> property in our <code class="literal">package.json</code> file comes in: we can write simple script, almost like a command-line alias, to start <code class="literal">nodemon</code> for us. As you can see, we're creating a script called <code class="literal">start</code>, and it runs <code class="literal">nodemon server.js</code>. On the command line, we can run <code class="literal">npm start</code>; npm knows where to find the <code class="literal">nodemon</code> binary and can start it for us.</p><p>So, now that we<a id="id6" class="indexterm"/> have a <code class="literal">package.json</code> file, we can install the dependencies we've just listed. On the command line, change to the current directory to the project directory, and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install</strong></span>
</pre></div><p>You'll see that all the necessary packages will be installed. Now we're ready to begin writing the code.</p></div></div>
<div class="section" title="Starting with the server"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Starting with the server</h1></div></div></div><p>I know you're <a id="id7" class="indexterm"/>probably eager to get started with the actual Backbone code, but it makes more sense for us to start with the server code. Remember, good Backbone apps will have strong server-side components, so we can't ignore the backend completely.</p><p>We'll begin by creating a <code class="literal">server.js</code> file in our project directory. Here's how that begins:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var path    = require('path');
var Bourne  = require("bourne");</pre></div><p>If you've used Node.js, you know that the <code class="literal">require</code> function can be used to load Node.js components (<code class="literal">path</code>) or npm packages (<code class="literal">express</code> and <code class="literal">bourne</code>). Now that we have these packages in our application, we can begin using them as follows:</p><div class="informalexample"><pre class="programlisting">var app      = express();
var posts    = new Bourne("simpleBlogPosts.json");
var comments = new Bourne("simpleBlogComments.json");</pre></div><p>The first variable here is <code class="literal">app</code>. This is our basic Express application object, which we get when we call the <code class="literal">express</code> function. We'll be using it a lot in this file.</p><p>Next, we'll create two <code class="literal">Bourne</code> objects. As I said earlier, <code class="literal">Bourne</code> is the database we'll use in our projects in this book. This is a simple database that I wrote specifically for this book. To keep the server side as simple as possible, I wanted to use a document-oriented database system, but I wanted something serverless (for example, SQLite), so you didn't have to run both an application server and a database server. What I came up with, <code class="literal">Bourne</code>, is a small package that reads from and writes to a JSON file; the path to that JSON file is the parameter we pass to the constructor function. It's definitely not good for anything bigger than a small learning project, but it should be perfect for this book. In the real world, you can use one of the excellent document-oriented databases. I <a id="id8" class="indexterm"/>recommend MongoDB: it's really easy to get started with, and has a very natural API. Bourne isn't a drop-in replacement for MongoDB, but it's very similar. You can check out the simple documentation for Bourne at <a class="ulink" href="https://github.com/andrew8088/bourne">https://github.com/andrew8088/bourne</a>.</p><p>So, as you<a id="id9" class="indexterm"/> can see here, we need two databases: one for our blog posts and one for comments (unlike most databases, Bourne has only one table or collection per database, hence the need for two).</p><p>The next step is to write a little configuration for our application:</p><div class="informalexample"><pre class="programlisting">app.configure(function(){
  app.use(express.json());
  app.use(express.static(path.join(__dirname, 'public')));
});</pre></div><p>This is a very minimal configuration for an Express app, but it's enough for our usage here. We're adding two layers of middleware to our application; they are "mini-programs" that the HTTP requests that come to our application will run through before getting to our custom functions (which we have yet to write). We add two layers here: the first is<a id="id10" class="indexterm"/> <code class="literal">express.json()</code>, which parses the JSON requests bodies that Backbone will send to the server; the second is<a id="id11" class="indexterm"/> <code class="literal">express.static()</code>, which will statically serve files from the path given as a parameter. This allows us to serve the client-side JavaScript files, CSS files, and images from the <code class="literal">public</code> folder.</p><p>You'll notice that both these middleware pieces are passed to <code class="literal">app.use()</code>, which is the method we call to choose to use these pieces.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>You'll notice that we're using the <code class="literal">path.join()</code> method<a id="id12" class="indexterm"/> to create the path to our public assets folder, instead of just doing <code class="literal">__dirname</code> and <code class="literal">'public'</code>. This is because Microsoft Windows requires the separating slashes to be backslashes. The <code class="literal">path.join()</code> method will get it right for whatever operating system the code is running on. Oh, and <code class="literal">__dirname</code> (two underscores at the beginning) is just a variable for the path to the directory this script is in.</p></div></div><p>The next step is to create a route method:</p><div class="informalexample"><pre class="programlisting">app.get('/*', function (req, res) {
  res.render("index.ejs");
});</pre></div><p>In Express, we can create a route calling a method on the app that corresponds to the desired HTTP verb (get, post, put, and delete). Here, we're calling <code class="literal">app.get()</code> and we pass two parameters to it. The first is the route; it's the portion of the URL that will come after your domain name. In our case, we're using an asterisk, which is a catchall; it will match any route that begins with a forward slash (which will be all routes). This will match every GET request made to our application. If an HTTP request matches the route, then a function, which is the second parameter, will be called. </p><p>This function takes two parameters; the first is the request object from the client and the second is the response object that we'll use to send our response back. These are often abbreviated to <code class="literal">req</code> and <code class="literal">res</code>, but that's just a convention, you could call them whatever you want.</p><p>So, we're going <a id="id13" class="indexterm"/>to use the <a id="id14" class="indexterm"/>
<code class="literal">res.render</code> method, which will render a server-side template. Right now, we're passing a single parameter: the path to the template file. Actually, it's only part of the path, because Express assumes by default that templates are kept in a directory named <code class="literal">views</code>, a convention we'll be using. Express can guess the template package to use based on the file extension; that's why we don't have to select EJS as the template engine anywhere. If we had values that we want to interpolate into our template, we would pass a JavaScript object as the second parameter. We'll come back and do this a little later.</p><p>Finally, we can start up our application; I'll choose to use the port <code class="literal">3000</code>:</p><div class="informalexample"><pre class="programlisting">app.listen(3000);</pre></div><p>We'll be adding a lot more to our <code class="literal">server.js</code> file later, but this is what we'll start with. Actually, at this point, you can run <code class="literal">npm start</code> on the command line and open up <code class="literal">http://localhost:3000</code> in a browser. You'll get an error because we haven't made the view template file yet, but you can see that our server is working.</p></div>
<div class="section" title="Creating the template"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating the template</h1></div></div></div><p>All web <a id="id15" class="indexterm"/>applications will have templates of some kind. <a id="id16" class="indexterm"/>Most Backbone applications will be heavy on the frontend templates. However, we will need a single server-side template, so let's build that.</p><p>While you can choose from different template engines, many folks (and subsequently, tutorials) use<a id="id17" class="indexterm"/> Jade (<a class="ulink" href="http://jade-lang.com/">http://jade-lang.com/</a>), which is like a Node.js version of the Ruby template engine <a id="id18" class="indexterm"/>Haml (<a class="ulink" href="http://haml.info/">http://haml.info/</a>). However, as you already know, we're using EJS (<a class="ulink" href="https://github.com/visionmedia/ejs">https://github.com/visionmedia/ejs</a>), which is similar to Ruby's ERB. Basically, we're writing regular HTML with template variables inside <code class="literal">&lt;%=</code> <code class="literal">%&gt;</code> tags.</p><p>As we saw earlier, <a id="id19" class="indexterm"/>Express will be looking for an <code class="literal">index.ejs</code> file in the <code class="literal">views</code> folder, so let's create that and put the following code inside it:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Simple Blog &lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="main"&gt;&lt;/div&gt;
      &lt;script src="/jquery.js"&gt;&lt;/script&gt;
      &lt;script src="/underscore.js"&gt;&lt;/script&gt;
      &lt;script src="/backbone.js"&gt;&lt;/script&gt;
      &lt;script src="/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>At this point, if you still have the server running (remember <code class="literal">npm start</code> on the command line), you<a id="id20" class="indexterm"/> should be able to load <code class="literal">http://localhost:3000</code> without getting an error. The page will be blank, but you should be able to view the source and see the HTML code that we just wrote. That's a good sign; it means we're successfully sending stuff from the server to the client.</p></div>
<div class="section" title="Adding the public folder"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Adding the public folder</h1></div></div></div><p>Since <a id="id21" class="indexterm"/>Backbone is a <a id="id22" class="indexterm"/>frontend library, it's something we'll need to be serving to the client. We've set up our Express app to statically serve the files in our <code class="literal">public</code> directory, and added several script tags to the <code class="literal">index.ejs</code> file, but we haven't created these things yet.</p><p>So, create a directory named <code class="literal">public</code> in your project directory. Now download the latest versions of Underscore (<a class="ulink" href="http://underscorejs.org">http://underscorejs.org</a>), Backbone (<a class="ulink" href="http://backbonejs.org">http://backbonejs.org</a>), and jQuery (<a class="ulink" href="http://jquery.com">http://jquery.com</a>) and put them in this folder. It's very likely that newer versions of these libraries have come out since this book was written. Since updates to these projects could change the way they work, it's best to stick to the following versions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Backbone: Version 1.1.2</li><li class="listitem" style="list-style-type: disc">Underscore: Version 1.6.0</li><li class="listitem" style="list-style-type: disc">jQuery: Version 2.0.3</li></ul></div><p>I will mention here that we're including Underscore and jQuery because Backbone depends on<a id="id23" class="indexterm"/> them. <a id="id24" class="indexterm"/>Actually, it only really depends on Underscore, but including jQuery does give us a few extra features that we'll be happy to have. If you need to support older versions of Internet Explorer, you'll also want to include the <code class="literal">json2.js</code> library (<a class="ulink" href="https://github.com/douglascrockford/JSON-js">https://github.com/douglascrockford/JSON-js</a>), and switch to a version of jQuery 1 (jQuery 2 doesn't support older versions of IE).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Everything up to this point will be the same for each of the applications we are going to build in this book. In the downloaded files for this book, you can start each chapter by copying the template folder and working from there.</p></div></div></div>
<div class="section" title="Beginning the Backbone code"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Beginning the Backbone code</h1></div></div></div><p>Once you have<a id="id25" class="indexterm"/> these three files in the <code class="literal">public</code> folder, you're ready to create the <code class="literal">app.js</code> file. In most of <a id="id26" class="indexterm"/>our Backbone applications, this is where the  major portion of the work is going to be done. Now that everything else is in place, we can begin the app-specific code.</p><div class="section" title="Creating a model and collection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Creating a model and collection</h2></div></div></div><p>When building a<a id="id27" class="indexterm"/> Backbone app, the first thing I like to think about is this: what data will I be working with? This is my first question because<a id="id28" class="indexterm"/> Backbone is very much a data-driven library: almost everything the user will see and work will in some way <a id="id29" class="indexterm"/>be related to a piece of data. This is<a id="id30" class="indexterm"/> especially true in the simple blog we're creating; every view will either be for viewing data (such as posts) or creating data (such as comments). The individual pieces of data that your application will work on (such as titles, dates, and text) will be grouped into what are usually called <span class="strong"><strong>models</strong></span>: the posts and comments in our blog, the events in a calendar app, or the contacts in an address book. You get the idea.</p><p>To start with, our blog will have a single model: the post. So, we create the appropriate Backbone model and collection classes. The code snippet for our model is as follows:</p><div class="informalexample"><pre class="programlisting">var Post = Backbone.Model.extend({});
var Posts = Backbone.Collection.extend({
  model: Post,
  url: "/posts"
});</pre></div><p>There's actually a <a id="id31" class="indexterm"/>lot going on in these five lines. First, all the main Backbone components are properties of the global variable <code class="literal">Backbone</code>. Each of these <a id="id32" class="indexterm"/>components is a class. JavaScript does not actually have proper classes; the prototype-backed functions pass for classes in JavaScript. They also have an extend method, which allows us to create subclasses. <a id="id33" class="indexterm"/>We pass an object to this <code class="literal">extend</code> method, and all properties or methods inside that object will become part of the new class we're creating, along with the properties and methods that make up the class we're extending.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>I want to mention early in the book that a lot of the similar code you see between Backbone apps is just convention. That's one of the reasons I love Backbone so much; there's a strong set of conventions to use, but you can totally work outside that box just as easily. Throughout the book, I'm going to do my best to show you not only the common conventions, but also how to break them.</p></div></div><p>In this code, we're creating a model class and a collection class. We actually don't need to extend the model <a id="id34" class="indexterm"/>class at all for now; just a basic Backbone model will do. However, for the collection class, we'll add two properties. First, we need to associate this collection with the appropriate model. We do this because a collection instance is basically just a glorified array for a bunch of model instances. The second property is <code class="literal">url</code>: this is the location of the collection on the server. What this means is that if we do a GET request to <code class="literal">/posts</code>, we'll get back a JSON array of the posts in our database. This also means that we will be able to send a POST request to <code class="literal">/posts</code> and store a new post in our database.</p><p>At this point, now that we have our data-handling classes on the frontend, I'd like to head back to the <code class="literal">server.js</code> file to create the routes required by our collection. So, in the file, add the following piece of code:</p><div class="informalexample"><pre class="programlisting">app.get("/posts", function (req, res) {
  posts.find(function (results) {
    res.json(results);
  });
});</pre></div><p>First off, I'll mention that it's important that this call to <code class="literal">app.get</code> goes above our <code class="literal">/*</code> route. This is because of<a id="id35" class="indexterm"/> the fact that Express sends the requests through our routes sequentially and stops (by default, anyway) when it finds a matching one. Since <code class="literal">/posts</code> will match both <code class="literal">/posts</code> and <code class="literal">/*</code>, we need to make sure it hits the <code class="literal">/posts</code> route first.</p><p>Next, you'll recall <a id="id36" class="indexterm"/>our <code class="literal">posts</code> database instance, which we made earlier. Here, we're calling its <code class="literal">find</code> method with only a callback, which will pass the callback an array of all the records in the database. Then, we can use the response object's <code class="literal">json</code> method to send that array back as JSON (the <code class="literal">Content-Type</code> header will be <code class="literal">application/json</code>). That's it!</p><p>While we're here <a id="id37" class="indexterm"/>in the <code class="literal">server.js</code> file, we add the POST method for the same route: this is where the post data will come in from the browser and be saved to our database. The following is the code snippet for the <code class="literal">post()</code> method:</p><div class="informalexample"><pre class="programlisting">app.post("/posts", function (req, res) {
  posts.insert(req.body, function (result) {
    res.json(result);
  });
});</pre></div><p>The <code class="literal">req</code> object has a <a id="id38" class="indexterm"/>body property, which is the JSON data that represents our post data. We can insert it directly into the <code class="literal">posts</code> database. When Backbone saves a model to the server in this way, it expects the response to be the model it sent with an ID added to it. Our database will add the ID for us and pass the updated model to the callback, so we only have to send it as a response to the browser, just as we did when sending all the posts in the previous method using <code class="literal">res.json</code>.</p><p>Of course, this isn't very useful without a form to add posts to the database, right? We'll build a form to create new posts soon, but for now we can manually add a post to the <code class="literal">simpleBlogPosts.json</code> file; this file may not exist yet because we haven't written any data, so you'll have to create it. Just make sure the file you create has the right name, that is, the same name as the parameter we passed to the <code class="literal">Bourne</code> constructor in our <code class="literal">server.js</code> file. I'm going to put the following code in that file:</p><div class="informalexample"><pre class="programlisting">[
  {
    "id": 1,
    "pubDate": "2013-10-20T19:42:46.755Z",
    "title": "Lorem Ipsum",
    "content": "&lt;p&gt;Dolor sit amet . . .&lt;/p&gt;"
  }
]</pre></div><p>Of course, you can make the <code class="literal">content</code> field longer; you get the idea. This is the JSON field that will be sent<a id="id39" class="indexterm"/> to our <code class="literal">Posts</code> collection instance and become a set of the <code class="literal">Post</code> model instance (in this case, a set of only one).</p></div></div>
<div class="section" title="Performing a quick and dirty test"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Performing a quick and dirty test</h1></div></div></div><p>We've <a id="id40" class="indexterm"/>actually written enough code at this point to test things out. Head to <code class="literal">http://localhost:3000</code> in your browser and pop open a JavaScript console; I prefer Chrome and the Developer tools but use whatever you want. Now try the following lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var posts = new Posts();</strong></span>
<span class="strong"><strong>posts.length // =&gt; 0</strong></span>
</pre></div><p>We can create a <code class="literal">Posts</code> collection instance; as you can see, it's empty by default. We can load the data from the server by running the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>posts.fetch();</strong></span>
</pre></div><p>A collection instance's <code class="literal">fetch</code> method will send a GET request to the server (in fact, if your in-browser tools allow you to see a network request, you'll see a GET request to <code class="literal">/posts</code>). It will merge the models that it receives from the server with the ones already in the collection. Give a second to get a response and then run the following lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>posts.length // =&gt; 1</strong></span>
<span class="strong"><strong>var post = posts.get(1);</strong></span>
<span class="strong"><strong>post.get("title"); // Lorem Ipsum</strong></span>
</pre></div><p>Every collection instance has a <code class="literal">get</code> method; we pass it an ID and it will return the model instance with that ID (note that this is the <code class="literal">id</code> field from the database, and not the index number in the collection). Then, each model instance has a <code class="literal">get</code> method that we can use to get properties.</p></div>
<div class="section" title="Writing some views"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Writing some views</h1></div></div></div><p>In simple<a id="id41" class="indexterm"/> applications like the one we're creating in this chapter, <a id="id42" class="indexterm"/>most of the Backbone code that we write will be in views. I think it's fair to say that views can be the most challenging part of a Backbone app, because there are so many ways that almost everything can be done.</p><p>It's important to understand that a <code class="literal">Backbone.View</code> instance and a screen full of web apps aren't the same thing. One view in the browser may actually be many Backbone views. The first view that we want to create is a list of all the posts; these will be links to individual post pages. We could do this in two ways: as one big view or as multiple smaller views put together. In this instance, we're going to be using multiple views. Here's how we'll break it down: each list item will be generated by its own view instance. Then, the wrapper around the list items will be another view. You can picture it as looking something like this:</p><div class="mediaobject"><img src="graphics/6997OS_01_04.jpg" alt="Writing some views"/></div><div class="section" title="The PostListView class"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The PostListView class</h2></div></div></div><p>Let's start<a id="id43" class="indexterm"/> with the child views. We'll call this <code class="literal">PostListView</code> class. <a id="id44" class="indexterm"/>Naming views can be a little tricky. Often, we'll have a view for the collection and a view for the model, and we'll just append <code class="literal">View</code> to the end of their names, for example, <code class="literal">PostView</code> and <code class="literal">PostsView</code>. However, a model or collection will have multiple views. The one we're about to write is to list our models. That's why we're calling it <code class="literal">PostListView</code>:</p><div class="informalexample"><pre class="programlisting">var PostListView = Backbone.View.extend({
  tagName: "li",
  template: _.template("&lt;a href='/posts/{{id}}'&gt;{{title}}&lt;/a&gt;"),
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    return this;
  }
});</pre></div><p>Just like <code class="literal">Backbone.Model</code> and <code class="literal">Backbone.Collection</code>, we create a view class by extending <code class="literal">Backbone.View</code>. We have three properties in the extending object that make up our <code class="literal">PostListView</code>. The first one to look at is the <code class="literal">template</code> property; this property holds the template that our view will render. There are plenty of ways to create a template; in this case, we're using the Underscore's <code class="literal">template</code> function; we pass a string to <code class="literal">_.template</code>, and it returns a function which we can use to generate the correct HTML. Take a look at this template string: it's regular HTML with variables placed within double curly braces.</p><p>Next, let's look at the <code class="literal">render</code> method. By convention, this is the method that we call to actually render the view. Every view instance has a property named <code class="literal">el</code>. This is the base element for the view instance: all other elements for this view go inside it. By default, this is a <code class="literal">div</code> element, but we've set the <code class="literal">tagName</code> property to <code class="literal">li</code>, which means we'll get a list item instead. By the way, there's also a <code class="literal">$el</code> property, which is a jQuery object wrapping the <code class="literal">el</code> property; this only works if we have jQuery included in our application.</p><p>So, inside our <code class="literal">render</code> function, we need to fill in this element. In this case, we'll do that by assigning the <code class="literal">innerHTML</code> property. To get the HTML output, we use the template we just wrote. That's a function, so we call it, and pass <code class="literal">this.model.toJSON()</code>. The <code class="literal">this.model</code> portion comes from when we instantiate this view: we'll pass it a model. Every model has a <code class="literal">toJSON</code> method, which returns a raw object with just the attributes of the model. Since our model will have the <code class="literal">id</code> and <code class="literal">title</code> attributes, passing this to our template function will return a string with those values interpolated into the template string we wrote.</p><p>We end our <code class="literal">render</code> function by returning the view instance. Again, this is just convention. Because of this, we can use the convention where we get the element for this view via <code class="literal">view.render().el</code> ; this will render the view and then get the <code class="literal">el</code> property. Of course, there's no reason you couldn't return <code class="literal">this.el</code> directly from render.</p><p>There's one more thing <a id="id45" class="indexterm"/>to address here, but it's about Underscore and not Backbone. If you've used the Underscore's <code class="literal">template</code> function before, you know that curly braces aren't its normal delimiters. I've switched from the default <code class="literal">&lt;%=</code> <code class="literal">%&gt;</code> delimiters, because those are the delimiters for our server-side template engine. To change Underscore's delimiters, just add the following code snippet to the top of our <code class="literal">app.js</code> file:</p><div class="informalexample"><pre class="programlisting">_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};</pre></div><p>Of course, you realize that we could make the delimiters whatever we want, as long as a regular expression can match it. I like the curly braces.</p></div><div class="section" title="The PostsListView class"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The PostsListView class</h2></div></div></div><p>Now<a id="id46" class="indexterm"/> that <a id="id47" class="indexterm"/>we have the view for our list items, we need the parent view that wraps those list items:</p><div class="informalexample"><pre class="programlisting">var PostsListView = Backbone.View.extend({
  template: _.template("&lt;h1&gt;My Blog&lt;/h1&gt;&lt;ul&gt;&lt;/ul&gt;"),
  render: function () {
    this.el.innerHTML = this.template();
    var ul = this.$el.find("ul");
    this.collection.forEach(function (post) {
      ul.append(new PostListView({ 
        model: post 
      }).render().el);
    });
    return this;
  }
});</pre></div><p>As views go, this is pretty simple, but we can learn a few new things from it. First, you'll notice that our template doesn't actually use any variables, so there's no reason for us to actually use a template. We could directly assign that HTML string as <code class="literal">this.el.innerHTML</code>; however, I like to do the little template dance anyway because I might change the template string to include some variables in the future.</p><p>Notice the second line of the <code class="literal">render</code> function: we're finding an <code class="literal">ul</code> element; the same <code class="literal">ul</code> element that we just made as a child element of our root element, <code class="literal">this.el</code>. However, instead of using <code class="literal">this.el</code>, we're using <code class="literal">this.$el</code>.</p><p>Next, we're<a id="id48" class="indexterm"/> looping <a id="id49" class="indexterm"/>over each item in the collection that we'll associate with this view (when we instantiate it). For each post in the collection, we will create a new <code class="literal">PostListView </code>class. We pass it an <code class="literal">options</code> object, which assigns the view's model as the current post. Then, we render the view and return the view's element. This is then appended to our <code class="literal">ul</code> object.</p><p>We'll end by returning the view object.</p></div></div>
<div class="section" title="Using our views"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Using our views</h1></div></div></div><p>We're<a id="id50" class="indexterm"/> almost ready to actually display some content in<a id="id51" class="indexterm"/> the browser. Our first stop is back in the <code class="literal">server.js</code> file. We need to send the array of posts from the database to our <code class="literal">index.ejs</code> template. We do this by using the following code snippet:</p><div class="informalexample"><pre class="programlisting">app.get('/*', function (req, res) {
  posts.find(function (err, results) {
    res.render("index.ejs", { posts: JSON.stringify(results) });
  });
});</pre></div><p>Just as we do in the <code class="literal">/posts</code> route, we call <code class="literal">posts.find</code>. Once we get the results back, we render the view as before. But this time, we pass an object of values that we want to be able to use inside the template. In this case, that's only the posts. We have to run the results through <code class="literal">JSON.stringify</code>, because we can't serve an actual JavaScript object to the browser; we need a string representation (the JSON form) of the object.</p><p>Now, in the <code class="literal">index.ejs</code> file of the <code class="literal">views</code> folder, we can use these posts. Create a new script tag under the other ones we created before. This time, it will be an inline script:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  var posts = new Posts(&lt;%- posts %&gt;);
  $("#main").append(new PostsListView({ 
    collection: posts 
  }).render().el);
&lt;/script&gt;</pre></div><p>The first line creates our posts collection; notice our use of the template tags. This is how to interpolate our <code class="literal">posts</code> array into the template. There's no typo there by the way; you might have expected an opening tag of <code class="literal">&lt;%=</code>, but that opening tag will escape any possible characters in the string, which wrecks the quotes in our JSON code. So, we use <code class="literal">&lt;%-</code>, which doesn't escape characters.</p><p>The next line<a id="id52" class="indexterm"/> should be pretty straightforward. We're using jQuery <a id="id53" class="indexterm"/>to find our main element and appending the element of a new <code class="literal">PostsListView</code> instance. In the <code class="literal">options</code> object, we'll set the collection for this view. We then render it and find the element to append.</p><p>Now, make sure your server is running, and go to <code class="literal">http://localhost:3000</code> in the browser. You should see the following screenshot:</p><div class="mediaobject"><img src="graphics/6997OS_01_01.jpg" alt="Using our views"/></div><p>You're using the three main Backbone components—collection, models, and views—to create a mini-application! That's great, but we've only just got started.</p></div>
<div class="section" title="Creating a router"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Creating a router</h1></div></div></div><p>Go ahead <a id="id54" class="indexterm"/>and click on the link that we've just rendered. You'll find that the URL changes and the page refreshes, but the content is still the same. This is <a id="id55" class="indexterm"/>because of a choice we've made in how our application works, that is, we made a catchall route that matches every GET request to our server. This means that <code class="literal">/</code>, <code class="literal">/posts/1</code>, and <code class="literal">/not/a/meaningful/link</code> show us the same content. This is what's often called a <span class="strong"><strong>single-page</strong></span> web application, that is, as much as possible is done on the client side, with JavaScript doing the heavy lifting, and not a different language on the server. With this kind of application, the whole thing could work off a single URL that never changes. However, this makes it hard to bookmark parts of the application. So, we want to make sure our application uses good URLs. To do this, we need to create a Backbone router as follows:</p><div class="informalexample"><pre class="programlisting">var PostRouter = Backbone.Router.extend({
  initialize: function (options) {
    this.posts = options.posts;
    this.main  = options.main;
  },
  routes: {
    '': 'index',
    'posts/:id': 'singlePost'
  },
  index: function () {
    var pv = new PostsListView({ collection: this.posts }
    this.main.html(pv.render().el);
  },
  singlePost: function (id) {
    console.log("view post " + id);
  }
});</pre></div><p>Here's the first version of our <code class="literal">PostRouter</code>. You should see a familiar pattern as we begin: we<a id="id56" class="indexterm"/> extend the<a id="id57" class="indexterm"/> component <code class="literal">Backbone.Router</code>. The next important piece is the <code class="literal">initialize</code> method. We never add one of these to our model, collection, or views, but they can all take an <code class="literal">initialize</code> method. This is the constructor function for our router. In good old Backbone convention, we expect to get a single <code class="literal">options</code> parameter. We'll expect this object to have two properties: <code class="literal">posts</code> and <code class="literal">main</code>. These should be the posts collection and the <code class="literal">div#main</code> element, respectively. We'll assign these as properties on our router instance.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Technically, the <code class="literal">initialize</code> function isn't the constructor function. It's a function that is called by the constructor function. To completely replace the default behavior, write a method called <code class="literal">constructor</code>, not <code class="literal">initialize</code>.</p></div></div><p>The next important part is the <code class="literal">routes</code> object. In this object, the keys are routes and the values are the router methods to call when those routes are used. So, the same page will be loaded from the server, but then the client-side router will look at exactly what URL was requested and show the right content.</p><p>The first route is an empty string; this is the <code class="literal">/</code> route (but it's best practice not to include the slash in the front, so that the router will work with both hash URLs and the pushState API). When we load that route, we'll run the router's <code class="literal">index</code> function.</p><p>So what does this function do? It should look familiar; it's like what we put in our <code class="literal">index.ejs</code> file as a quick test. It creates our <code class="literal">PostsListView</code> instance and puts it on the page. Notice that we're using the <code class="literal">this.posts</code> and <code class="literal">this.main</code> properties that we just created.</p><p>The other route <a id="id58" class="indexterm"/>we're creating here is <code class="literal">/posts/:id</code>, which runs the <code class="literal">singlePost</code> function. The colon-label portion of that route will catch the content after that slash and pass it to the route method as a parameter. Right now, all we're doing in the <code class="literal">singlePost</code> method is logging a message to the console, but there's more to come.</p><p>Now that we've written a router, we need to start using it. You know that inline script in the <code class="literal">index.ejs</code> file? Replace its content with the following code:</p><div class="informalexample"><pre class="programlisting">var postRouter = new PostRouter({
  posts: new Posts(&lt;%- posts %&gt;),
  main: $("#main")
});
Backbone.history.start({pushState: true});</pre></div><p>Once again, we're creating the <code class="literal">posts</code> collection and the references to the main <code class="literal">&lt;div&gt;</code> element. This time, however, they're properties of the router. We actually don't have to do anything with the router instance, just create it. However, we do have to start the history tracking: that's what the last line does. Remember, we're using a single-page app, so our URLs are not actual routes on the server. This used to be done with a hash in the URL, but the better and more modern way to do this is with the <code class="literal">pushState</code> API, which is a browser API that let's you change the URL in the browser's address bar without actually changing the contents of the page. So, that's what we do with the <code class="literal">options</code> object, where we set <code class="literal">pushState</code> to <code class="literal">true</code>.</p><p>If you browse <a id="id59" class="indexterm"/>your way over to <code class="literal">http://localhost:3000/</code>, you'll see our post listing. Now, click on the post link, and well, the page still reloads. However, on the new link, you see no page content but a line logged to the console. So, the router is working but it isn't stopping the reload. When the page reloads, the router sees the new route and runs the right method.</p><p>So the question now is, how do we keep the page from refreshing, but still change the URL? To do this, we have to prevent the default behavior of the link that we clicked on. To do this, we need to add the following pieces to our <code class="literal">PostListView</code> (in the <code class="literal">app.js</code> file):</p><div class="informalexample"><pre class="programlisting">events: {
  'click a': 'handleClick'
},
handleClick: function (e) {
  e.preventDefault();
  postRouter.navigate($(e.currentTarget).attr("href"), 
    {trigger: true});
}</pre></div><p>The <code class="literal">events</code> property is important here, as it handles any DOM events that happen within the base element of our view. The keys in this object should follow the pattern <code class="literal">eventName selector</code>. Of course, <code class="literal">eventName</code> can be any DOM event. The selector should be a string<a id="id60" class="indexterm"/> that jQuery can match. Part of the beauty of this selector is that it only matches elements within this view, so you often don't have to make it very specific. In our case, just <code class="literal">'a'</code> is good enough.</p><p>The value of each <code class="literal">events</code> property is the name of the method to call when this event occurs. The next step is to write this method as another property of this same view; it gets the jQuery event object as a parameter. Inside the <code class="literal">handleClick</code> method, we're calling <code class="literal">e.preventDefault</code> to keep the default behavior from happening. Since this is an anchor element, the default behavior is switching to the linked-to page. Instead, we perform that navigation inside our Backbone application: that's the next line.</p><p>What we're doing <a id="id61" class="indexterm"/>here isn't a completely good idea, but it will work for now. We're referencing the <code class="literal">postRouter</code> variable, which isn't created in this file; in fact, it's created after this file is loaded on the client. We can get away with this because this function won't be called until after the <code class="literal">postRouter</code> variable is created. However, in a more serious application, we would probably want better code decoupling. However, for our skill level, this is okay.</p><p>We're calling the router's <code class="literal">navigate</code> method. The first parameter is the route to navigate to: we get this from the anchor element. We also pass an <code class="literal">options</code> object, which sets <code class="literal">trigger</code> to <code class="literal">true</code>. If we don't trigger the navigation, the URL will change in the browser's location bar, but nothing else will change. Since we are triggering the navigation, the appropriate router method will be called, if one exists. One does in our case, <code class="literal">singlePost</code>, so you should see our message printed to the JavaScript console in the browser.</p></div>
<div class="section" title="Viewing a post"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Viewing a post</h1></div></div></div><p>Now<a id="id62" class="indexterm"/> that <a id="id63" class="indexterm"/>we have the right URL for a post page, let's make a view for individual posts:</p><div class="informalexample"><pre class="programlisting">var PostView = Backbone.View.extend({
  template: _.template($("#postView").html()),
  events: {
    'click a': 'handleClick'
  },
  render: function () {
    var model = this.model.toJSON();
    model.pubDate = new Date(Date.parse(model.pubDate)).toDateString();
    this.el.innerHTML = this.template(model);
    return this;
  },
  handleClick: function (e) {
    e.preventDefault();
    postRouter.navigate($(e.currentTarget).attr("href"),
      {trigger: true});
    return false;
  }
});</pre></div><p>This view should mark an important milestone in your Backbone education: you understand most <a id="id64" class="indexterm"/>of the conventions that you're looking at in this code. You should recognize all the properties of the view, as well as most of the method content. I want to point out here there's much more convention going on than you may realize. For example, the <code class="literal">template</code> property is only ever referred to inside the <code class="literal">render</code> method, so you could call it something different, or put it inside the <code class="literal">render</code> method, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">var template = _.template($("#postView").html());</pre></div><p>Even the <code class="literal">render</code> method <a id="id65" class="indexterm"/>is only used by us when rendering the view. It's convention to call it <code class="literal">render</code>, but really, nothing will break if you don't. Backbone never calls it internally.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>You might wonder why we follow these Backbone conventions if we don't have to. I think it's partly because they are very sensible defaults, and because it makes reading other people's Backbone code much easier. However, another good reason to do it is because there are many third-party Backbone components that depend on these conventions. When using them, conventions become expectations that are required for things to work.</p></div></div><p>However, there are a few things in this view that will be new to you. First, instead of putting the template text in a string that gets passed directly to <code class="literal">_.template</code>, we're putting it in the <code class="literal">index.ejs</code> file and using jQuery to pull it in. This is something you'll see often; it's handy to do because most applications will have larger templates, and it's hard to manage a lot of HTML in JavaScript strings. So, put the following code in your <code class="literal">index.ejs</code> file related to your "actual" script tags:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="postView"&gt;
  &lt;a href='/'&gt;All Posts&lt;/a&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;p&gt;{{pubDate}}&lt;/p&gt;
  {{content}}
&lt;/script&gt;</pre></div><p>It's important to give your script tag a <code class="literal">type</code> attribute, so the browser doesn't try to execute it as <a id="id66" class="indexterm"/>JavaScript. What that type is doesn't really matter; I use <code class="literal">text/template</code>. We also give it an <code class="literal">id</code> attribute, so we can reference it from the JavaScript code. Then, in our JavaScript code, we use jQuery to get the element, and then get its content using the <code class="literal">html</code> method.</p><p>The other different piece of this view is that we're not passing <code class="literal">this.model.toJSON()</code> directly to the <code class="literal">render</code> method. Instead, we're saving it to the <code class="literal">model</code> variable, so that we can format the <code class="literal">pubDate</code> property. When stored as JSON, dates aren't very pretty. We use a few built-in <code class="literal">Date</code> methods to fix this up and reassign it to the model. Then, we pass the updated <code class="literal">model</code> object to the <code class="literal">render</code> method.</p><p>If you're wondering<a id="id67" class="indexterm"/> why we're using <code class="literal">events</code> and <code class="literal">handleClick</code> to override the anchor action again, notice the <span class="strong"><strong>All Posts</strong></span> link in our template; this will be displayed above our post content. However, I hope you notice the flaw in this pattern: this will sabotage all links that might be in the content of our post, which might lead outside our blog. This is another reason why, as I said earlier, this pattern of view-changing isn't that great; we'll look at improvements on this in future chapters.</p><p>Now that we've created this view, we can update the <code class="literal">singlePost</code> method in our router:</p><div class="informalexample"><pre class="programlisting">singlePost: function (id) {
  var post = this.posts.get(id);
  var pv = new PostView({ model: post });
  this.main.html(pv.render().el);
}</pre></div><p>Instead of just logging the ID to the console, we find the post with that ID in our <code class="literal">this.posts</code> collection. Then, we create a <code class="literal">PostView</code> instance, giving it that post as a model. Finally, we replace the content of the <code class="literal">this.main</code> element with the rendered content of the post view.</p><p>If you do a simple <a id="id68" class="indexterm"/>click-through test now, you should be able to go to our home page, click on the post's title, and see this:</p><div class="mediaobject"><img src="graphics/6997OS_01_02.jpg" alt="Viewing a post"/></div><p>You should be congratulated! You've just built a complete Backbone application (albeit an application <a id="id69" class="indexterm"/>with an extremely low level of functionality but an application nonetheless).</p></div>
<div class="section" title="Creating new posts"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Creating new posts</h1></div></div></div><p>Now that we<a id="id70" class="indexterm"/> can show posts, let's create a form to make<a id="id71" class="indexterm"/> new posts. It's important to realize that we're just going to create a form. There's no user account and no authentication, just a form that anyone could use to make new posts. We'll start with the template, which we'll put in the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="postFormView"&gt;
  &lt;a href="/"&gt;All Posts&lt;/a&gt;&lt;br /&gt;
  &lt;input type="text" id="postTitle" placeholder="post title" /&gt;
  &lt;br /&gt;
  &lt;textarea id="postText"&gt;&lt;/textarea&gt;
  &lt;br /&gt;
  &lt;button id="submitPost"&gt; Post &lt;/button&gt;
&lt;/script&gt;</pre></div><p>It's a very basic form, <a id="id72" class="indexterm"/>but it will do. So now, we need to create our view; use the following code:</p><div class="informalexample"><pre class="programlisting">var PostFormView = Backbone.View.extend({
  tagName: 'form',
  template: _.template($("#postFormView").html()),
  initialize: function (options) {
    this.posts = options.posts;
  },
  events: {
    'click button': 'createPost'
  },
  render: function () {
    this.el.innerHTML = this.template();
    return this;
  },
  createPost: function (e) {
    var postAttrs = {
      content: $("#postText").val(),
      title: $("#postTitle").val(),
      pubDate: new Date()
    };
    this.posts.create(postAttrs);
    postRouter.navigate("/", { trigger: true });
    return false;
  }
});</pre></div><p>It's pretty big, but you should be able to understand most of it. We start by making the view a <code class="literal">&lt;form&gt;</code> element through the <code class="literal">tagName</code> property. We fetch the template we just created in the <code class="literal">template</code> property. In the <code class="literal">initialize</code> method, we take a <code class="literal">Posts</code> collection as an <a id="id73" class="indexterm"/>option and assign it as a property, much like we did in the router. In the <code class="literal">events</code> property, we listen for a click event on the button. When that happens, we call the <code class="literal">createPost</code> method. Rendering this view is pretty simple. Actually, the real complexity here is in the <code class="literal">createPost</code> method, but even that is pretty simple. We create a <code class="literal">postAttrs</code> object that has all the properties of our post: the content and the text from the form and a date that we add.</p><p>After creating this <code class="literal">postAttrs</code> object, we pass it to the <code class="literal">Posts</code> collection's <code class="literal">create</code> method. This is a convenience method, really, that creates the <code class="literal">Post</code> model instance, saves it to the server, and adds it to the collection. If we wanted to do this "manually", we'd do something similar to the following lines of code:</p><div class="informalexample"><pre class="programlisting">var post = new Post(commentAttrs);
this.posts.add(post);
post.save();</pre></div><p>Every Backbone model <a id="id74" class="indexterm"/>constructor takes an object, which is a hash of attributes. We can add that model to the collection using the <code class="literal">add</code> method. Then, every model instance has a <code class="literal">save</code> method, which sends the model to the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>In this case, it's important to add the model to the collection before saving it, because our model class doesn't know the server route to POST to on its own. If we wanted to be able to save model instances that aren't in a collection, we'd have to give the model class a <code class="literal">urlRoot</code> property:</p><div class="informalexample"><pre class="programlisting">urlRoot: "/posts",</pre></div></div></div><p>Finally, we navigate back to the home page.</p><p>The next step is to add a new route to the router. In the <code class="literal">routes</code> property of the router class, add the following line:</p><div class="informalexample"><pre class="programlisting">'posts/new': 'newPost'</pre></div><p>Then, we add the <code class="literal">newPost</code> method, which is very simple:</p><div class="informalexample"><pre class="programlisting">newPost: function () {
  var pfv = new PostFormView({ posts: this.posts });
  this.main.html(pfv.render().el);
},</pre></div><p>That's all! Like I said, this<a id="id75" class="indexterm"/> isn't how you'd really do blog posting in a proper blog, but it shows us how to send model data back to the server.</p></div>
<div class="section" title="Adding comments"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Adding comments</h1></div></div></div><p>Let's take <a id="id76" class="indexterm"/>things one step further, shall we? Let's add<a id="id77" class="indexterm"/> some (very primitive) commenting functionality.</p><p>Once again, we should start by thinking about the data. It's obvious, in this case: our basic data object, if you will, is the comment. However, we also need to think about how our data needs to interact with other data in the application, that is, every post that we have needs to be able to have multiple comments connected to it. Backbone doesn't have any conventions for inter-model-and-collection relationships, so we'll come up with something on our own.</p><p>We start <a id="id78" class="indexterm"/>with model and collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var Comment = Backbone.Model.extend({});
var Comments = Backbone.Collection.extend({
  initialize: function (models, options) {
    this.post = options.post;
  },
  url: function () {
    return this.post.url() + "/comments";
  }
});</pre></div><p>You remember the <code class="literal">initialize</code> function, right? This will run when we instantiate the collection. Conventionally, it takes two parameters: an array of models and an options object. We'll expect a collection of comments to be related to a single post, and we get that post as an option.</p><p>In our <code class="literal">Posts</code> collection, <code class="literal">url</code> was a string property; however, it can also be a function that returns a string if we need a more dynamic URL. This is exactly what we need for our <code class="literal">Comments</code> collection because the URL is dependent upon the post. As you can see, the server location of a collection of comments is the URL for the post, plus <code class="literal">/comments</code>. So, for a post with ID 1, it's <code class="literal">/posts/1/comments</code>. For a post with ID 42, it's <code class="literal">/posts/42/comments</code>, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">url</code> method on a model instance checks to see whether our model class has the property <code class="literal">urlRoot</code>; if so, it will use that. Otherwise, it uses its collection's <code class="literal">url</code> property. In either case, it will append its <code class="literal">id</code> property to the <code class="literal">url</code> property to get its own unique URL.</p></div></div><p>The next step is to loosely connect the <code class="literal">Comments</code> collection to the <code class="literal">Post</code> model. We need to add an <code class="literal">initialize</code> method to our <code class="literal">Post</code> model as shown here:</p><div class="informalexample"><pre class="programlisting">var Post = Backbone.Model.extend({
  initialize: function () {
    this.comments = new Comments([], { post: this });
  }
});</pre></div><p>I say "loosely" because there's no actual relation here between a post and its own comments (apart from <a id="id79" class="indexterm"/>setting <code class="literal">post: this</code> in the <code class="literal">options</code> object, which helps set the current URL); all this does is create a new <code class="literal">Comments</code> collection <a id="id80" class="indexterm"/>whenever a post is created. It's important to realize that this <code class="literal">comments</code> property is not like the other properties of a model. To be specific, it's a regular JavaScript property of the object, but not an attribute of the post model itself. We can't get it with the model's <code class="literal">get</code> method.</p><div class="section" title="Serving comments"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Serving comments</h2></div></div></div><p>The next<a id="id81" class="indexterm"/> step is to <a id="id82" class="indexterm"/>prepare the server to send and receive comments. Sending comments to the client is actually pretty; see here:</p><div class="informalexample"><pre class="programlisting">app.get("/posts/:id/comments", function (req, res) {
  comments.find(
    { postId: parseInt(req.params.id, 10) },
    function (err, results) {
      res.json(results);
    }
  );
});</pre></div><p>Just like in the Backbone router routes, we can use colon-target-style tokens in our Express routes to take a variable. However, instead of showing up as function parameters, we can get them as a subproperty of the request object <code class="literal">req.param</code>.</p><p>We're using the <code class="literal">comments</code> database object we created previously. The database has a <code class="literal">find</code> method, <a id="id83" class="indexterm"/>which takes a query object as the first parameter. In this case, we just want to find all comment records that have a <code class="literal">postId</code> property that matches the <code class="literal">id</code> parameter from the URL. Since the <code class="literal">id</code> parameter is a string, we'll need to use <code class="literal">parseInt</code> to convert it to a number. When we get the records, we'll send them back as JSON, just like we did with the posts.</p><p>What about saving comments? These will be POSTed back to the server as the request body, and they're POSTed to the same URL, you can see in the following code:</p><div class="informalexample"><pre class="programlisting">app.post("/posts/:id/comments", function (req, res) {
  comments.insert(req.body, function (err, result) {
    res.json(result);
  });
});</pre></div><p>Since we're parsing the request body as JSON (see the middleware we added), we can insert it directly into<a id="id84" class="indexterm"/> our database. In our callback, we're taking a <code class="literal">result</code> parameter and sending it back to the client as JSON. This is important, because the <code class="literal">id</code> property on Backbone models should be set on the server. Our database does this automatically, so the result we send back is the same object we received with a new <code class="literal">id</code> property. This is the response Backbone expects.</p></div><div class="section" title="Comment views"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Comment views</h2></div></div></div><p>Now, we're<a id="id85" class="indexterm"/> ready to create the comment views. This<a id="id86" class="indexterm"/> could be done in many ways, but we're going to do it with three view classes. The first is to display individual comments. The second is the form to create new comments. The third wraps these two views and adds some important functionality.</p><p>The first is the simplest, so let's start with it:</p><div class="informalexample"><pre class="programlisting">var CommentView = Backbone.View.extend({
  template: _.template($("#commentView").html()),
  render: function () {
    var model = this.model.toJSON();
    model.date = new Date(Date.parse(model.date)).toDateString();
    this.el.innerHTML = this.template(model);
    return this;
  }
});</pre></div><p>We're formatting the date, as we did previously, for posts. Also, we're once again putting the template content in a script tag. Here's the script tag that goes in the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="commentView"&gt;
  &lt;hr /&gt;
  &lt;p&gt;&lt;strong&gt;{{name}}&lt;/strong&gt; said on {{date}}: &lt;/p&gt;
  &lt;p&gt;{{text}}&lt;/p&gt;
&lt;/script&gt;</pre></div><p>Pretty straightforward, isn't it?</p><p>Next up is<a id="id87" class="indexterm"/> the <code class="literal">CommentFormView</code> class. This is the form that viewers will use to add a comment to post. We'll start with the template this time by using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="commentFormView"&gt;
  &lt;input type="text" id="cmtName" placeholder="name" /&gt;&lt;br /&gt;
  &lt;textarea id="cmtText"&gt;&lt;/textarea&gt;&lt;br /&gt;
  &lt;button id="submitComment"&gt; Submit &lt;/button&gt;
&lt;/script&gt;</pre></div><p>Nothing too <a id="id88" class="indexterm"/>special: a textbox for the name, a text area for the text, and a submit button. A very basic form, you'll agree. Now we have the class itself:</p><div class="informalexample"><pre class="programlisting">var CommentFormView = Backbone.View.extend({
  tagName: "form",
  initialize: function (options) {
    this.post = options.post;
  },
  template: _.template($("#commentFormView").html()),
  events: {
    'click button': 'submitComment'
  },
  render: function () {
    this.el.innerHTML = this.template();
    return this;
  },
  submitComment: function (e) {
    var name = this.$("#cmtName").val();
    var text = this.$("#cmtText").val();
    var commentAttrs = {
      postId: this.post.get("id"),
      name: name,
      text: text,
      date: new Date()
    };
    this.post.comments.create(commentAttrs);
    this.el.reset();
  }
});</pre></div><p>This form view is long, but pretty similar to the other form, the one for creating posts. The <code class="literal">tagName</code> property <a id="id89" class="indexterm"/>sets the view's base element to a form. Since the comments this form makes need to be related to a post, we set the post as a property via the <code class="literal">options</code> object in the <code class="literal">initialize</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Instead of creating a <code class="literal">post</code> property on this view, we could use the <code class="literal">model</code> property. As you may have noticed, this is a specially-named property that gets assigned automatically when it's part of the <code class="literal">options</code> object (so we wouldn't need an <code class="literal">initialize</code> method). However, that property is usually the model that is displayed in this view. Since that's not what we're using here, I prefer to make a custom property, so someone reading this code wouldn't misunderstand the purpose of the post model in this view.</p></div></div><p>Of course, we'll <a id="id90" class="indexterm"/>need to capture the <code class="literal">click</code> event on the <span class="strong"><strong>Submit</strong></span> button. When that happens, the <code class="literal">submitComment</code> method will be run. The first portion of this method is simple; we're getting the values from the textbox and text area. Then, we're putting together a <code class="literal">commentAttrs</code> object with four properties: the ID of the post this comment belongs to, the name of the commenter, the text, and the date and time of the comment's creation (right now).</p><p>After creating this <code class="literal">commentAttrs</code> object, we pass it to the post's comment collection's <code class="literal">create</code> method, just as we did in the <code class="literal">PostFormView</code>. The final line in the <code class="literal">submitComment</code> method is a built-in DOM method that resets the form; it clears all fields.</p><p>The last view is <code class="literal">CommentsView</code><a id="id91" class="indexterm"/>, which pulls these two view classes together, as shown here:</p><div class="informalexample"><pre class="programlisting">var CommentsView = Backbone.View.extend({
  initialize: function (options) {
    this.post = options.post;
    this.post.comments.on('add', this.addComment, this);
  },
  addComment: function (comment) {
    this.$el.append(new CommentView({ 
      model: comment 
    }).render().el);
  },
  render: function () {
    this.$el.append("&lt;h2&gt; Comments &lt;/h2&gt;");
    this.$el.append(new CommentFormView({ 
      post: this.post 
    }).render().el);
    this.post.comments.fetch();
    return this;
  }
});</pre></div><p>Just like <code class="literal">CommentFormView</code><a id="id92" class="indexterm"/>, this view will be given a <code class="literal">Post</code> instance when it's created. In the <code class="literal">render</code> method, we first append a heading to the view element, and then we render and append our <a id="id93" class="indexterm"/>comment form. All this should look relatively familiar, but the rest is new. The second-last line in <code class="literal">render</code> calls the <code class="literal">fetch</code> method of the post's comments collection. This makes a GET request to the server and fills the collection with the comments that are returned from the server.</p><p>Now, look back<a id="id94" class="indexterm"/> at the <code class="literal">initialize</code> method; the last line is the first we've seen of Backbone's event capabilities. As we perform different tasks and call different methods of Backbone objects, different events are triggered, and we can listen for those events and react when they occur. In this case, we're listening for the comment collection's <code class="literal">add</code> event. This event occurs whenever we add a new model to this collection. If you think about the code we've written, you'll see that there are two places where we add models to this collection:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When calling <code class="literal">comments.create </code>in the <code class="literal">submitComment</code> method in <code class="literal">CommentFormView</code></li><li class="listitem" style="list-style-type: disc">When calling <code class="literal">comments.fetch</code> in the <code class="literal">render</code> method in this view</li></ul></div><p>So, whenever a model is added to our collection, we want to call the <code class="literal">this.addComment</code> method. Notice that we're passing a third parameter to the <code class="literal">on</code> method: <code class="literal">this</code>. This is the context for the function we want to call. By default, there will be no value for <code class="literal">this</code> inside functions called by the <code class="literal">on</code> method, so we want to tell it to use this view instance as context.</p><p>The <code class="literal">addComment</code> method<a id="id95" class="indexterm"/> takes the freshly-added comment as a parameter (the collections object and an <code class="literal">options</code> object are also passed to functions that are responding to an <code class="literal">add</code> event, but we don't need them here). We can then create a <code class="literal">CommentView</code> instance for this model and append its element to our view element.</p><p>Well, it's all there now. You can go ahead and give it a try, that is, load a post page and add a few comments. Each<a id="id96" class="indexterm"/> time, you should see the comment appear below the form. Then, if you refresh the page, the comments you made will again appear under the post. You might notice a little delay in the loading of the comments. This is because we aren't loading them with the initial page load. Instead, they are loaded during the rendering of <code class="literal">CommentsView</code>. Granted, this is milliseconds after the page load, but you might see a quick flash. You will see the following on your screen:</p><div class="mediaobject"><img src="graphics/6997OS_01_03.jpg" alt="Comment views"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Summary</h1></div></div></div><p>This brings us to the end of the first chapter. If you hadn't dug into Backbone much before this, I hope that you're starting to feel comfortable with the basics of the library.</p><p>In this chapter, we looked briefly at all the main components of Backbone. We saw how models and collections are the homes for our data records, and how they drive the web application. We made a handful of views, some to display individual model instances, some to display a collection, and some to display other page components or wrap other views. We created a router and used it to direct almost all the traffic on our web application. We even got a little taste of Backbone's robust events API.</p><p>Besides the nitty-gritty of the Backbone API, I hope you picked up some of the bigger ideas. One of these is the <code class="literal">options</code> object, as almost every Backbone component constructor function takes an <code class="literal">options</code> object as the final parameter, and many functions that interact with the server do as well. There are some magic property names—such as <code class="literal">model</code> or <code class="literal">collection</code>—that Backbone handles automatically, but you can also pass your own options and work with them inside the classes.</p><p>The other big takeaway from this chapter is the balance between convention and choice when coding. Compared to the other similar libraries, Backbone is incredibly light and flexible and enforces very few coding patterns. The good part is that the few conventions that Backbone does strongly support are actually really great ideas that it makes sense to follow. Of course, it's just one programmer's opinion, but I've found that Backbone engenders an almost perfect balance of convention to follow and freedom to code however you want. We'll learn more about this balance when we build a photo-sharing application in the next chapter.</p></div></body></html>