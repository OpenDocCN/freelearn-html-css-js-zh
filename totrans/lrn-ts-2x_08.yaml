- en: Working with Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about annotations and decorators—the
    two new features based on the future ECMAScript 7 specification, but we can use
    them today with TypeScript 1.5 or higher. You will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations and decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reflection metadata API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript features in this chapter require TypeScript 1.5 or higher and
    the following options to be enabled in the `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As indicated by the experimental decorators compilation flag, the decorator's
    API is considered experimental. This doesn't mean that it is not ready for production
    usage. It means that the decorator API is subject to potential breaking changes
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to need a polyfill for the `reflect–metadata` API. We need
    a polyfill because most JavaScript engines don''t support this API yet. We can
    expect that, in the long term, this polyfill will not be required but, currently,
    we can use the `reflect–metadata` npm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reflect-metadata` version was 0.1.12 at the time of writing. Please note
    that the examples are included in the companion source code. The examples can
    be executed with ts node. For example, the first example included in the companion
    source code can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts-node chapters/chapter_08/01_class_decorator.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations versus decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Annotations are a way to add metadata to class declarations. The metadata can
    then be used by libraries and other development tools, such as inversion of control
    containers. The annotations API was originally proposed by the Google AtScript
    team, but annotations are not a standard. However, decorators are a proposed standard
    for the ECMAScript specification, to annotate and modify classes and properties
    at design time. Annotations and decorators are pretty much the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Annotations and decorators are nearly the same thing. From a consumer perspective,
    we have exactly the same syntax. The only thing that differs is that we don''t
    have control over how annotations are added as metadata to our code. A decorator
    is rather an interface to build something that ends up as annotation. Over a long
    term, however, we can just focus on decorators, since those are a real proposed
    standard. AtScript is TypeScript and TypeScript implements decorators".'
  prefs: []
  type: TYPE_NORMAL
- en: – <q>Pascal Precht</q>, The Difference between Annotations and Decorators
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the following class to showcase how to work with decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four types of decorators that can be used to annotate: classes, properties,
    methods, and parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official TypeScript decorator proposal defines a class decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class decorator function is a function that accepts a constructor function
    as its argument, and returns either undefined, the provided constructor function,
    or a new constructor function. Returning undefined is equivalent to returning
    the provided constructor function.                                           
                                                                                 
                               – Ron Buckton, Decorators Proposal - TypeScript
  prefs: []
  type: TYPE_NORMAL
- en: 'A class decorator is used to modify the constructor of a class in some way.
    If the class decorator returns `undefined`, the original constructor remains the
    same. If the decorator returns, the return value will be used to override the
    original class constructor. The following type declares the signature of a class
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts` file in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a class decorator named `logClass`. We can start by
    defining the decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class decorator does not have any logic yet, but we can already
    apply it to a class. To apply a decorator, we need to use the at (`@`) symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile the preceding code snippet into JavaScript, a function named
    `__decorate` will be generated by the TypeScript compiler. We are not going to
    examine the internal implementation of the `__decorate` function, but we need
    to understand that it is used to apply a decorator at runtime because the decorator
    syntax is not supported natively by JavaScript. We can see it in action by examining
    the JavaScript code that is generated when we compile the decorated `Person` class
    mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, the `Person` class is declared,
    but it is then passed to the `__decorate` function. The value returned by the
    `__decorate` function is re-assigned to the `Person` class. Now that we know how
    the class decorator will be invoked, let''s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class decorator takes the constructor of the class being decorated as its
    only argument. This means that the argument (named `target`) is the constructor
    of the `Person` class. The decorator starts by creating a copy of the class constructor,
    then it defines a utility function (named `instanciate`) that can be used to generate
    instances of a class. Decorators are used to add some extra logic or metadata
    to the decorated element. When we try to extend the functionality of a function
    (methods or constructors), we need to wrap the original function with a new function,
    which contains the additional logic and invokes the original function. In the
    preceding decorator, we added extra logic to log in the console, the name of the
    class when a new instance is created. To achieve this, a new class constructor
    (named `newConstructor`) was declared. The new constructor invokes a function
    named `logClassName`, which implements the additional logic and uses the `instanciate`
    function to invoke the original class constructor. At the end of the decorator,
    the prototype of the original constructor function is copied to the new constructor
    function to ensure that the `instanceof` operator continues to work when it is
    applied to an instance of the decorated class. Finally, the new constructor is
    returned, and it is used to override the original class constructor. After decorating
    the class constructor, a new instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On doing so, the following text appears in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The method decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official TypeScript decorator proposal defines a method decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A method decorator function is a function that accepts three arguments: The
    object that owns the property, the key for the property (a string or a symbol),
    and optionally the property descriptor of the property. The function must return
    either undefined, the provided property descriptor, or a new property descriptor.
    Returning undefined is equivalent to returning the provided property descriptor".'
  prefs: []
  type: TYPE_NORMAL
- en: — Ron Buckton, Decorators Proposal - TypeScript
  prefs: []
  type: TYPE_NORMAL
- en: 'The method decorator is like the class decorator, but it is used to override
    a method, as opposed to using it to override the constructor of a class. The following
    type declares the signature of a method decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts` file in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method decorator takes as arguments the class being decorated (target),
    the name of the method being decorated, and a `TypePropertyDescriptor` of the
    property being decorated. A property descriptor is an object used to describe
    the properties of a class. A property descriptor contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that a property descriptor is an object that can be obtained by invoking
    the `Object.getOwnPropertyDescriptor()` method. You can learn more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method decorator returns a property descriptor, the returned value will
    be used to override the property descriptor of the method. Let''s declare a method
    decorator named `logMethod` without any behavior for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the decorator to one of the methods in the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile the preceding code snippet into JavaScript, we will be able to
    observe that the method decorator is invoked using the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The prototype (`Person.prototype`) of the class that contains the method being
    decorated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the method (`saySomething`) being decorated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property descriptor of the method being decorated is `Object.getOwnPropertyDescriptor(Person.prototype,
    saySomething)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know the value of the decorator parameters, we can proceed to implement
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we did when we implemented the class decorator, we start by creating
    a copy of the element being decorated. Instead of accessing the method via the
    class prototype (`target[key]`), we will access it via the property descriptor
    (`descriptor.value`). We then create a new function that will replace the method
    being decorated. The new function invokes the original method but also contains
    some additional logic used to log in the console, the method name, and the value
    of its arguments every time it is invoked. After applying the decorator to the
    method, the method name and arguments will be logged in the console when it is
    invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On doing so, the following text appears in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The property decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official TypeScript decorators proposal defines a method property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A property decorator function is a function that accepts two arguments: The
    object that owns the property and the key for the property (a string or a symbol).
    A property decorator does not return.'
  prefs: []
  type: TYPE_NORMAL
- en: —Ron Buckton, Decorators Proposal - TypeScript
  prefs: []
  type: TYPE_NORMAL
- en: 'The following type declares the signature of a property decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts file` in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property decorator is really like a method decorator. The main differences
    are that a property decorator doesn''t return a value and that the third parameter
    (the property descriptor is missing) is not passed to the property decorator.
    Let''s create a property decorator named `logProperty` to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it in one of the `Person` class''s properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have been doing so far, we are going to implement a decorator that will
    override the decorated property with a new property that will behave exactly as
    the original one, but will perform an additional task—logging the property value
    in the console whenever it changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding decorator, we created a copy of the original property value
    and declared two functions: `getter` (invoked when we change the value of the
    property) and `setter` (invoked when we read the value of the property) respectively.
    The method decorator returned a value used to override the element being decorated.
    Because the property decorator doesn''t return a value, we can''t override the
    property being decorated, but we can replace it. We have manually deleted the
    original property (using the `delete` keyword) and created a new property using
    the `Object.defineProperty` function and the previously declared getter and setter
    functions. After applying the decorator to the `name` property, we will be able
    to observe any changes to its value in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The parameter decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official decorators proposal defines a parameter decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A parameter decorator function is a function that accepts three arguments:
    The object that owns the method that contains the decorated parameter, the property
    key of the property (or undefined for a parameter of the constructor), and the
    ordinal index of the parameter. The return value of this decorator is ignored".'
  prefs: []
  type: TYPE_NORMAL
- en: '- Ron Buckton, Decorators Proposal - TypeScript'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following type declares the signature of a parameter decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts file` in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between the preceding decorators and the parameter decorators
    is that we cannot use a parameter decorator to extend the functionality of a given
    class. Let''s create a parameter decorator named `addMetadata` to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the parameter decorator to a parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter decorator doesn''t return, which means that we will not be able
    to override the original method that takes the parameter being decorated as an
    argument. We can use parameter decorators to link some metadata to the class being
    decorated. In the following implementation, we will add an array named `log_${key}_parameters`
    as a class property, where `key` is the name of the method that contains the parameter
    being decorated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow more than one parameter to be decorated, we check whether the new
    field is an array. If the new field is not an array, we create and initialize
    the new field to be a new array containing the index of the parameter being decorated.
    If the new field is an array, the index of the parameter being decorated is added
    to the array. A parameter decorator is not useful on its own; it needs to be used
    with a method decorator, so the parameter decorator adds the metadata, and the
    method decorator reads it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method decorator works like the method decorator that we implemented
    previously in this chapter, but it will read the metadata added by the parameter
    decorator, and instead of displaying all the arguments passed to the method in
    the console when it is invoked, it will only log the ones that have been decorated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply the `saySomething` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readMetadata` decorator will display the value of the parameters and which
    indices were added to the metadata (class property named `_log_saySomething_parameters`)
    in the console by the `addMetadata` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the previous example, we used a class property to store some metadata.
    However, this is not recommended practice. Later in this chapter, you will learn
    how to use the `reflection-metadata` API; this API has been designed specifically
    to generate and read metadata, and it is, therefore, recommended to use it when
    we need to work with decorators and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a special kind of decorator factory to allow developers to configure
    the behavior of a decorator. For example, we could pass a string to a class decorator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to pass some parameters to a decorator, we need to wrap the decorator
    with a function. The wrapper function takes the options of our choice and returns
    a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This can be applied to all the kinds of decorators that you learned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to **avoid using an arrow function as the inner function**
    to prevent potential problems with the `this` operator at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The reflect metadata API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that decorators can be used to modify and extend the behavior
    of a class's methods or properties. While this is a very good way to get to understand
    decorator in depth, **it is not recommended to use a decorator to modify and extend
    the behavior of a class**. Instead, we should try to use decorators to add metadata
    to the class being decorated. The metadata can then be consumed by other tools.
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation to avoid using a decorator to modify and extend the behavior
    of a class could be reverted in the future if the TypeScript team implements a
    future known as <q>decorator mutation</q>. You can learn more about the status
    of the decorator mutation proposal at [https://github.com/Microsoft/TypeScript/issues/4881](https://github.com/Microsoft/TypeScript/issues/4881).
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibility of adding metadata to a class might not seem useful or exciting,
    but in my opinion, it is one of the greatest things that has happened to JavaScript
    in the past few years. As we already know, TypeScript only uses types at design
    time. However, some features, such as dependency injection, runtime type assertions,
    reflection, and automated mocking during testing are not possible when the type
    information is not available at runtime. The lack of type information at runtime
    is not a problem anymore because we can use decorators to generate metadata and
    that metadata can contain the required type information. The metadata can then
    be processed at runtime. When the TypeScript team started to think about the best
    possible way to allow developers to generate type information metadata, they reserved
    a few special decorator names for this purpose. The idea was that when an element
    was decorated using these reserved decorators, the compiler would automatically
    add the type''s information to the element being decorated. The reserved decorators
    were the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"TypeScript compiler will honor special decorator names and will flow additional
    information into the decorator factory parameters annotated by these decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: '@type - The serialized form of the type of the decorator target'
  prefs: []
  type: TYPE_NORMAL
- en: '@returnType - The serialized form of the return type of the decorator target
    if it is a function type, undefined otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '@parameterTypes - A list of serialized types of the decorator target''s arguments
    if it is a function type, undefined otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '@name - The name of the decorator target  "'
  prefs: []
  type: TYPE_NORMAL
- en: – Decorators brainstorming by Jonathan Turner
  prefs: []
  type: TYPE_NORMAL
- en: 'Shortly after, the team TypeScript decided to use the reflection metadata API
    (one of the proposed ES7 features) instead of the reserved decorators. The idea
    is almost identical, but instead of using the reserved decorator names, we will
    use some reserved metadata keys to retrieve the metadata using the reflection
    metadata API. The TypeScript documentation defines three reserved metadata keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type metadata uses the metadata key design:type.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parameter type metadata uses the metadata key design: paramtypes.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return type metadata uses the metadata key design: returntype.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- Issue #2577 - TypeScript Official Repository at GitHub.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now learn how we to use the reflection metadata API. We need to start
    by installing the `reflect-metadata` npm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to install type definitions for the `reflect-metadata` npm module
    because it includes the type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then import the `reflect-metadata` npm module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `reflect-metadata` module **should be imported only once in your entire
    application** because the `Reflect` object is meant to be a global singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use some of the `reflect-metadata` API from a TypeScript in which
    the `reflect-metadata` module is not imported, you will need to add the following
    option to your `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a class for testing purposes. We are going to get the type
    of one of the class properties at runtime. We are going to decorate the class
    using a `property` decorator named `logType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to invoke the `Reflect.getMetadata()` method using the `design:type`
    as the metadata key. The metadata value will be returned as a function. For example,
    for the type string, the `function String(){}` function is returned. We can use
    the `function.name` property to get the type as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile the preceding code and run the resulting JavaScript code in a
    web browser, we will be able to see the type of the `attr1` property in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that to run this example, the `reflect-metadata` library must be imported
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "reflect-metadata";`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply the other reserved metadata keys similarly. Let''s create a method
    with many parameters to use the `design:paramtypes` reserved metadata key to retrieve
    the types of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will use the `design:paramtypes` reserved metadata key. We are
    querying the types of multiple parameters, so the types will be returned as an
    array by the `Reflect.getMetadata()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run the preceding code in a web browser, we will be able
    to see the types of the parameters in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The types are serialized and follow some rules. We can see that functions are
    serialized as function, and object literals (`{test : string}`) and interfaces
    are serialized as object. The following table showcases how different types are
    serialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Serialized** |'
  prefs: []
  type: TYPE_TB
- en: '| void | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| string | String |'
  prefs: []
  type: TYPE_TB
- en: '| number | Number |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| any | Object |'
  prefs: []
  type: TYPE_TB
- en: '| enum | Number |'
  prefs: []
  type: TYPE_TB
- en: '| Class C{} | C |'
  prefs: []
  type: TYPE_TB
- en: '| Object literal {} | Object |'
  prefs: []
  type: TYPE_TB
- en: '| interface | Object |'
  prefs: []
  type: TYPE_TB
- en: Note that some developers have required the possibility of accessing the type
    of interfaces and the inheritance tree of a class via metadata. This feature is
    known as **complex type serialization** and is not available at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, we are going to create a method with a return type and use the
    `design:returntype` reserved metadata key to retrieve the types of the return
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the two previous decorators, we need to invoke the `Reflect.getMetadata()`
    function passing the `design:returntype` reserved metadata key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run the preceding code in a web browser, we will be able
    to see the types of the return type in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The decorator factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official decorators proposal defines a decorator factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A decorator factory is a function that can accept any number of arguments, and
    must return one of the types of decorator function.
  prefs: []
  type: TYPE_NORMAL
- en: '- Ron Buckton, Decorators Proposal - TypeScript'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learned to implement class, property, method, and parameter decorators.
    However, in most cases, we will consume decorators, not implement them. For example,
    in `InversifyJS`, we use the `@injectable` decorator to declare that a class will
    be injected into other classes, but we don''t need to implement the `@injectable`
    decorator. We can use the decorator factory to make decorators easier to consume.
    Let''s consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with the preceding code is that we, as developers, need to know
    that the `logMethod` decorator can only be applied to a method. This might seem
    trivial because the decorator name used (`logMethod`) makes it easier for us.
    A better solution is to enable developers to use a decorator named `@log` without
    having to worry about using the right kind of decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve this by creating a decorator factory. A decorator factory is
    a function that can identify what kind of decorator is required and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can observe in the preceding code snippet, the decorator factory is a
    factory of decorators. The generated decorator uses the number and type of arguments
    passed to the decorator to identify the required kind of decorator that is appropriate
    for each case. The decorator factory can be used to create a universal decorator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to consume and implement the four available
    types of decorators (class, method, property, and parameter). We used decorators
    to mutate the original classes to understand how they work but we also learned
    that we **should avoid using decorators to mutate the prototype of a class**.
    We also learned how to create a decorator factory to abstract developers from
    the decorator types when they are consumed, how to pass configuration to a decorator,
    and how to use the reflection metadata API to access type information at runtime.
    As we have already mentioned, decorators in TypeScript are still an experimental
    feature, which doesn't mean that they are not ready for their usage in production
    systems but that their public API might be subject to breaking changes in the
    future. Please note that the future TypeScript releases will document how to get
    around these potential breaking changes if they end up happening. In the following
    chapter, we will learn how to configure an advanced TypeScript development workflow.
  prefs: []
  type: TYPE_NORMAL
