["```js\nfunction getAccountById(id) {\n    return Account.findById(id);\n}\n```", "```js\n\"devDependencies\": {\n    \"chai\": \"^5.1.1\",\n    \"mocha\": \"^10.7.0\",\n    «sinon\": \"^18.0.0\"\n  }\n```", "```js\nimport * as chai from 'chai';\nimport sinon from 'sinon';\nconst expect = chai.expect;\nimport * as accountService from '../src/services/account.js';\nimport account from '../src/models/account.js'\nconst { errorCodes } = accountService.default;\n```", "```js\ndescribe('getAccountById service', () => {\n    let findByIdStub;\n    beforeEach(() => {\n        findByIdStub = sinon.stub(account, 'findById');\n    });\n    afterEach(async () => {\n        await findByIdStub.restore();\n    });\n    it('should return the account if found by id', async () => {\n        const expectedAccountId = '12345';\n        const expectedAccount = { name: 'Test Account', \n          number: '123-456-7890' };\n        findByIdStub.withArgs(expectedAccountId)\n          .resolves(expectedAccount);\n        const account = await accountService\n          .getAccountById(expectedAccountId);\n        expect(account).to.deep.equal(expectedAccount);\n        expect(findByIdStub.calledOnceWith(expectedAccountId))\n          .to.be.true;\n    });\n});\n```", "```js\ndescribe('Math operations', function() {\n  describe('Addition', function() {\n    it('should add two numbers correctly', function() {\n      expect(1 + 1).to.equal(2);\n    });\n  });\n  describe('Subtraction', function() {\n    it('should subtract two numbers correctly', function()\n    {\n      expect(2 - 1).to.equal(1);\n    });\n  });\n});\n```", "```js\ndescribe('getAccountById service', () => {\n    .........\n    .........\n    it('should return null if account not found', async () => {\n        const expectedAccountId = '54321';\n        findByIdStub.withArgs(expectedAccountId).resolves(null);\n        const account = await accountService\n          .getAccountById(expectedAccountId);\n        expect(account).to.be.null;\n        expect(findByIdStub.calledOnceWith(expectedAccountId))\n          .to.be.true;\n    });\n    it('should rethrow errors from findById', async () => {\n        const expectedAccountId = '98765';\n        const expectedError = new Error('Database error');\n        findByIdStub.withArgs(expectedAccountId)\n          .rejects(expectedError);\n        try {\n            await accountService.getAccountById(expectedAccountId);\n        } catch (error) {\n            expect(error).to.equal(expectedError);\n            expect(findByIdStub.calledOnceWith(expectedAccountId))\n              .to.be.true;\n        }  }); });\n```", "```js\nasync function updateAccountById(id, { name, number, type, status }) {\n    if (!name && !number && !type && !status) {\n        return { error: 'provide at least one valid data to be updated', code: NO_VALID_DATA_TO_UPDATE };\n    }\n  ........\n}\n```", "```js\ndescribe('updateAccountById service', () => {\n    let findByIdStub, saveStub;\n    beforeEach(() => {\n        findByIdStub = sinon.stub(account, 'findById');\n        saveStub = sinon.stub(account.prototype, 'save');\n    });\n    afterEach(async () => {\n        await findByIdStub.restore();\n        await saveStub.restore();\n    });\n    it('should return error for no data to update', async () => {\n        const id = '12345';\n        const updateData = {};\n        const result = await accountService.updateAccountById(id, \n          updateData);\n        expect(result).to.deep.equal({\n            error: 'provide at least one valid data to be updated',\n            code: errorCodes.NO_VALID_DATA_TO_UPDATE,\n        });\n           expect(findByIdStub.calledOnceWith(id)).to.be.false;\n        expect(saveStub.calledOnce).to.be.false;\n    });\n    ......\n    ....... });\n```", "```js\nasync function updateAccountById(id, { name, number, type, status }) {\n ......\n if (status && !(status in availableAccountStatusesForUpdate)) {\n        return { error: 'invalid status for account', code: INVALID_STATUS_CODE };   }\n  ......\n}\n```", "```js\nit('should return error for invalid status update', async () => {\n        const id = '12345';\n        const updateData = { status: 'invalid_status' };\n        const result = await accountService.updateAccountById(id, \n          updateData);\n        expect(result).to.deep.equal({\n            error: 'invalid status for account',\n            code: errorCodes.INVALID_STATUS_CODE,\n        });\n        expect(findByIdStub.calledOnceWith(id)).to.be.false;\n        expect(saveStub.calledOnce).to.be.false;\n    });\n```", "```js\nnpx mocha .\\tests\\accountservice.tests.mjs\n```", "```js\nnpm install --save-dev jest @nestjs/testing\n```", "```js\nimport { Test, TestingModule } from '@nest.js/testing';\nimport { TransactionService } from '../transaction/transaction.service';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { HttpService } from '@nest.js/axios';\nimport { KafkaService } from '../kafka/kafka.service';\nimport { CreateTransactionDto } from '../transaction/dto/create-transaction.dto';\n```", "```js\ndescribe('TransactionService', () => {\n  let service: TransactionService;\n  let prismaService: PrismaService;\n  let httpService: HttpService;\n  let kafkaService: KafkaService;\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        TransactionService,\n        {\n          provide: PrismaService,\n          useValue: {\n            transaction: {\n              create: jest.fn(),\n              findMany: jest.fn(),\n              findUnique: jest.fn(),\n              update: jest.fn(),\n            },\n          },\n        },\n        {\n          provide: HttpService,\n          useValue: {\n            axiosRef: {\n              get: jest.fn(),\n            },\n          },\n        },\n        {\n          provide: KafkaService,\n          useValue: {\n            send: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n```", "```js\n    service = module.get<TransactionService>(TransactionService);\n    prismaService = module.get<PrismaService>(PrismaService);\n    httpService = module.get<HttpService>(HttpService);\n    kafkaService = module.get<KafkaService>(KafkaService);\n```", "```js\n it(‹should be defined', () => {\n    expect(service).toBeDefined();\n  });\n```", "```js\ndescribe('create', () => {\n    it('should create a transaction with status CREATED if account status is new or active', async () => {\n      const createTransactionDto: CreateTransactionDto = {\n        accountId: '1',\n        description: 'Test transaction',\n      };\n      const accountApiResponse = {\n        data: {\n          account: {\n            id: '1',\n            status: 'active',\n          },\n        },\n      };\n      jest.spyOn(httpService.axiosRef, 'get').mockResolvedValue(accountApiResponse);\n      jest.spyOn(prismaService.transaction, 'create').mockResolvedValue({\n        id: 1,\n        accountId: '1',\n        description: 'Test transaction',\n        status: 'CREATED',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      });\n      const result = await service.create(createTransactionDto);\n      expect(result).toEqual(expect.objectContaining({\n        id: 1,\n        accountId: '1',\n        description: 'Test transaction',\n        status: 'CREATED',\n      }));\n      expect(httpService.axiosRef.get).toHaveBeenCalledWith('http://localhost:3001/v1/accounts/1');\n      expect(prismaService.transaction.create).toHaveBeenCalledWith({\n        data: {\n          accountId: '1',\n          description: 'Test transaction',\n          status: 'CREATED',\n        }, }); });\n```", "```js\nnpm install --save-dev jest @types/jest supertest @nestjs/testing\n```", "```js\n// jest.config.js\nmodule.exports = {\n    moduleFileExtensions: [\n        'js',\n        'json',\n        'ts',\n    ],\n    rootDir: 'src',\n    testRegex: '.*\\\\.spec\\\\.ts$',\n    transform: {\n        '^.+\\\\.(t|j)s$': 'ts-jest',\n    },\n    collectCoverageFrom: [\n        '**/*.(t|j)s',\n    ],\n    coverageDirectory: '../coverage',\n    testEnvironment: 'node',\n    globalSetup: './test/global-setup.js',\n    globalTeardown: './test/global-teardown.js',\n};\n```", "```js\nconst { execSync } = require('child_process');\nmodule.exports = async () => {\n    console.log('Starting Docker Compose...');\n    execSync('docker-compose -f docker-compose.tests.yml up \n      --build -d', { stdio: 'inherit' });\n    // You might need to add a delay here to give services time to initialize\n    await new Promise(resolve => setTimeout(resolve, 15000)); };\n```", "```js\nconst { execSync } = require('child_process');\nmodule.exports = async () => {\n    console.log(‹Stopping Docker Compose...›);\n    execSync('docker-compose -f docker-compose.tests.yml down', \n      { stdio: 'inherit' });\n};\n```", "```js\nnpm install --save @nestjs/microservices @nestjs/testing @nestjs/typeorm\n```", "```js\nimport { INestApplication } from '@nest.js/common';\nimport { testConfiguration } from '../test/test-configuration';\nimport * as request from 'supertest';\ndescribe('AppController (e2e)', () => {\n  let app: INestApplication;\n  beforeAll(async () => {\n    const moduleFixture = await testConfiguration();\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n  afterAll(async () => {\n    await app.close();\n  });\n  it('/transactions (POST) should create a transaction', async () => {\n    const createTransactionDto = {\n      accountId: '6658ae5284432e40604018d5', // UUID\n      description: 'Test transaction',\n    };\n    return request(app.getHttpServer())\n      .post('/transaction')\n      .send(createTransactionDto)\n      .expect(400);\n  }, 10000); });\n```"]