- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the history of WebGL, along with its evolution.
    We discussed the fundamental elements in a 3D application and how to set up a
    WebGL context. In this chapter, we will investigate how geometric entities are
    defined in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL renders objects following a "divide and conquer" approach. Complex polygons
    are decomposed into triangles, lines, and point primitives. Then, each geometric
    primitive is processed in parallel by the GPU in order to create the final scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how WebGL defines and processes geometric information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the relevant API methods that relate to geometry manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine why and how to use **JavaScript Object Notation** (**JSON**) to define,
    store, and load complex geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue our analysis of WebGL as a state machine to describe the attributes
    that are relevant to geometry manipulation that can be set and retrieved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with creating and loading different geometry models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL Rendering Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although WebGL is often thought of as a comprehensive 3D API, it is, in reality,
    just a rasterization engine. It draws points, lines, and triangles based on the
    code you supply. Getting WebGL to do anything else requires you to provide code
    to use points, lines, and triangles to accomplish your task.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL runs on the GPU on your computer. As such, you need to provide code that
    runs on that GPU. The code should be provided in the form of pairs of functions.
    Those two functions are known as the **vertex shader** and **fragment shader**, and
    they are each written in a very strictly-typed C/C++-like language called GLSL (GL
    Shader Language). Together, they are called a **program**.
  prefs: []
  type: TYPE_NORMAL
- en: GLSLGLSL is an acronym for the official OpenGL Shading Language. GLSL is a C/C++-like,
    high-level programming language for several parts of the graphic card. With GLSL,
    you can code short programs, called shaders, which are executed on the GPU. For
    more information, please check out [https://en.wikipedia.org/wiki/OpenGL_Shading_Language](https://en.wikipedia.org/wiki/OpenGL_Shading_Language).
  prefs: []
  type: TYPE_NORMAL
- en: A vertex shader's job is to compute vertex attributes. Based on various positions,
    the function outputs values that can be used to rasterize various kinds of primitives,
    including points, lines, and triangles. When rasterizing these primitives, it
    calls a second user-supplied function known as a fragment shader. A fragment shader's
    job is to compute a color for each pixel of the primitive currently being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all of the WebGL API is about setting up state for these pairs of functions
    to execute. For each thing you want to draw, you need to set up state to run these
    functions by invoking `gl.drawArrays` or `gl.drawElements`, which executes your
    shaders on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, let''s examine what WebGL''s rendering pipeline looks
    like. In subsequent chapters, we will discuss the pipeline in more detail. The
    following is a diagram of a simplified version of WebGL''s rendering pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0131f45f-813f-4251-898d-2b894c1fb4ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a moment to describe each element.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Buffer Objects (VBOs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**VBOs** contain the data that is used to describe the geometry to be rendered.
    Vertex coordinates, which are points that define the vertices of 3D objects, are
    usually stored and processed in WebGL as VBOs. Additionally, there are several
    data elements, such as vertex normals, colors, and texture coordinates, that can
    be modeled as VBOs.'
  prefs: []
  type: TYPE_NORMAL
- en: Index Buffer Objects (IBOs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While VBOs contain vertices describing a geometry, **IBOs** contain information
    about the relationship of the vertices as the rendering pipeline constructs the
    drawing type primitives. It uses the index of each vertex in the vertex buffer
    as a value.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **vertex shader** is called on each vertex. The shader manipulates *per-vertex* data,
    such as vertex coordinates, normals, colors, and texture coordinates. This data
    is represented by attributes inside the vertex shader. Each attribute points to
    a VBO from where it reads vertex data.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every set of three vertices defines a triangle. Each element on the surface
    of that triangle needs to be assigned a color. Without this, our surfaces wouldn't
    have a color. Each surface element is called a **fragment**. Since we are dealing
    with surfaces that will be displayed on your screen, these elements are more commonly
    known as **pixels**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goal of the **fragment shader** is to calculate the color of *individual
    pixels*. The following diagram illustrates this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/461fa06e-78e2-492d-8f53-937e72435b86.png)'
  prefs: []
  type: TYPE_IMG
- en: Framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A two-dimensional buffer contains the fragments that have been processed by
    the fragment shader. Once all of the fragments have been processed, a 2D image
    is formed and displayed on screen. The **framebuffer** is the final destination
    of the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Attributes** are input variables that are used in the vertex shader. Attributes
    are used to specify how to pull data out of buffers and provide them to the vertex
    shader. For example, you may put positions in a buffer as three 32-bit floats
    per position. You would tell a particular attribute which buffer to pull the positions
    out of, what type of data it should pull out (3-component, 32-bit floating point
    numbers), what offset in the buffer the positions start at, and how many bytes
    to get from one position to the next. Since the vertex shader is called on each
    vertex, the attributes will be different every time the vertex shader is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: Uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Uniforms** are input variables that are available to both the vertex shader
    and the fragment shader. Unlike attributes, uniforms are constant during a rendering
    cycle. For example, the position of a light is often modeled as a uniform. Uniforms
    are effectively global variables that you set before executing your shader program.'
  prefs: []
  type: TYPE_NORMAL
- en: Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Textures** are arrays of data that can be accessed in your shader program.
    Image data is the most common thing to put in a texture, but textures are simply
    data and can just as easily contain something other than an array of colors describing
    an image.'
  prefs: []
  type: TYPE_NORMAL
- en: Varyings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Varyings** are used to *pass data* from the vertex shader to the fragment
    shader. Depending on what is being rendered – points, lines, or triangles – the
    values set on a varying by a vertex shader will be interpolated while executing
    the fragment shader.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's cover the principles of creating a simple geometric object.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering in WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL handles geometry in a standard way, independent of the complexity and
    number of points that surfaces can have. There are two data types that are fundamental
    to represent the geometry of any 3D object: *vertices* and *indices*.
  prefs: []
  type: TYPE_NORMAL
- en: Vertices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vertices** are the points that define the corners of 3D objects. Each vertex
    is represented by three floating-point numbers that correspond to the `x`, `y`,
    and `z` coordinates of the vertex. Unlike its cousin, OpenGL, WebGL does not provide
    API methods to pass independent vertices to the rendering pipeline; therefore,
    all of our vertices need to be written in a **JavaScript array**, which can then
    be used to construct a WebGL vertex buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: Indices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Indices** are numeric labels for the vertices in a given 3D scene. Indices
    allow us to tell WebGL how to connect vertices in order to produce a surface.
    As with vertices, indices are stored in a JavaScript array and are then passed
    along to WebGL''s rendering pipeline using a WebGL index buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: VBOs Versus IBOs
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of WebGL buffers used to describe and process geometry. Buffers
    that contain vertex data are known as **VBOs**, and buffers that contain index
    data are known as **IBOs**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use the following steps to render an object in WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a geometry using JavaScript arrays
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the respective WebGL buffers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point a vertex shader attribute to a VBO from the previous step to store vertex
    coordinates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the IBO to render the geometry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a Geometry Using JavaScript Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To practice using the preceding steps, let''s use a trapezoid to see how we
    can define its vertices and indices. We need two JavaScript arrays – one for the
    vertices and one for the indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ccc3e64-684e-4098-b910-505346c4b396.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding illustration, we have placed the coordinates
    sequentially in the vertex array and then indicated how these coordinates are
    used to draw the trapezoid in the index array. So, the first triangle is formed
    with the vertices having the indices `0`, `2`, and `1`; the second, with the vertices
    having the indices `1`, `2`, and `3`; and finally, the third, with the vertices
    having the indices `2`, `4`, and `3`. We will follow the same procedure for all
    possible geometries.
  prefs: []
  type: TYPE_NORMAL
- en: Index Array Order
  prefs: []
  type: TYPE_NORMAL
- en: Triangles in the index array are usually, but not necessarily, defined in counter-clockwise
    order. It's important to pick one approach and keep it consistent to help you
    determine the front and back sides of geometry primitives. Consistency is important,
    because programs may use the clockwise/counter-clockwise order to determine whether
    a face is facing forward or backward for **culling** and rendering purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Culling
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics, back-face culling determines whether a polygon of a graphical
    object is visible. It is a step in the graphical pipeline that tests whether the
    points in the polygon appear in clockwise or counter-clockwise order when projected
    onto the screen. For more information, visit [https://en.wikipedia.org/wiki/Back-face_culling](https://en.wikipedia.org/wiki/Back-face_culling)[.](https://en.wikipedia.org/wiki/Back-face_culling)
  prefs: []
  type: TYPE_NORMAL
- en: Creating WebGL Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand how to define a geometry using vertices and indices,
    let''s render a square. Once we have created the JavaScript arrays that define
    the vertices and indices for our geometry, the next step is to create the respective
    buffers. In this case, we have a simple square on the `x`-`y` plane with the z
    values set as `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Clipspace Coordinates
  prefs: []
  type: TYPE_NORMAL
- en: These vertices are defined in clipspace coordinates, because WebGL only deals
    with clipspace coordinates. Clipspace coordinates always go from `-1` to `+1`,
    regardless of the size of the `canvas`. In later chapters, we will cover coordinates
    in more detail and learn how to convert between different coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting Started*,
    you may remember learning that WebGL operates as a state machine. Now, when `positionBuffer` is
    made the currently-bound WebGL buffer, any subsequent buffer operation will be
    executed on this buffer until it is unbound, or another buffer is made the current
    one with a bound call. We can bind a buffer with the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the type of buffer we are creating. We have two options
    for this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gl.ARRAY_BUFFER`: Vertex data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.ELEMENT_ARRAY_BUFFER`: Index data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, we created the buffer for vertex coordinates; therefore,
    we use `ARRAY_BUFFER`. For indices, the `ELEMENT_ARRAY_BUFFER` type is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bound Buffer Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: WebGL will always access the currently-bound buffer looking for the data. This
    means that we need to ensure that we always have bound a buffer before calling
    any other operation for geometry processing. If there is no buffer bound, you
    will obtain the `INVALID_OPERATION` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that `drawArrays` uses VBOs*.* Once we have bound a buffer, we need
    to pass along its contents. We do this with the `bufferData` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the vertices variable is a normal JavaScript array that contains
    the vertex coordinates. WebGL does not accept JavaScript arrays as a parameter
    for the `bufferData` method. Instead, WebGL requires JavaScript typed array so
    that the buffer data can be processed in its native binary form with the objective
    of speeding up geometry-processing performance.
  prefs: []
  type: TYPE_NORMAL
- en: The typed arrays used by WebGL include `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Int32Array`, `Uint32Array`, `Float32Array`,
    and `Float64Array`.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that vertex coordinates can be float, but indices are *always* integers.
    Therefore, we will use `Float32Array` for VBOs and `Uint16Array` for IBOs in this
    book. These two types represent the largest typed arrays that you can use in WebGL *per
    rendering call*. Other types may or may not be present in your browser, as this
    specification is not yet final at the time of this book's publication.
  prefs: []
  type: TYPE_NORMAL
- en: Since the indices support in WebGL is restricted to 16-bit integers, an index
    array can only be `65,535` elements in length. If you have a geometry that requires
    more indices, you will need to use several rendering calls. More about rendering
    calls will be presented later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Typed Arrays
  prefs: []
  type: TYPE_NORMAL
- en: Specifications for typed arrays can be found at [http://www.khronos.org/registry/typedarray/specs/latest/](http://www.khronos.org/registry/typedarray/specs/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is a good practice to unbind the buffer. We can achieve this by
    calling the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will repeat the same calls described here for every WebGL buffer (VBO or
    IBO) that we will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review what we have just learned with an example. We are going to look
    at an example from `ch02_01_square.html` to see the definition of VBOs and IBOs
    for a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you want to see this scene in action, launch the `ch02_01_square.html` file
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, for every buffer, we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind it to make it the current buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the buffer data using one of the typed arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbind the buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations to Manipulate WebGL Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operations to manipulate WebGL buffers are summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `createBuffer()` | Creates a new buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteBuffer(buffer)` | Deletes the supplied buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `bindBuffer(target, buffer)` | Binds a buffer object. The accepted values
    for target are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARRAY_BUFFER` (for vertices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELEMENT_ARRAY_BUFFER` (for indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `bufferData(target, data, type)` | Provides the buffer data. The accepted
    values for target are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARRAY_BUFFER` (for vertices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELEMENT_ARRAY_BUFFER` (for indices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, WebGL only accepts JavaScript typed arrays for the data.The
    parameter type is a performance hint for WebGL. The accepted values for type are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STATIC_DRAW`: Data in the buffer will not be changed (specified once and used
    many times)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DYNAMIC_DRAW`: Data will be changed frequently (specified many times and used
    many times)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STREAM_DRAW`: Data will change on every rendering cycle (specified once and
    used once)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Associating Attributes to VBOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have created the VBOs, we need to associate these buffers to vertex
    shader attributes. Each vertex shader attribute will refer to *one* an*d* *only
    one *buffer, depending on the correspondence that is established, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef13dc42-3a59-4167-97e1-a8d76ec9ea02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can achieve this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind a VBO
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point an attribute to the currently-bound VBO
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the attribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a look at the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a VBO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Where `myBuffer` is the buffer we want to map.
  prefs: []
  type: TYPE_NORMAL
- en: Pointing an Attribute to the Currently-Bound VBO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of the WebGL API is about setting up state to supply data to our
    GLSL programs. In this case, the only input to our GLSL program is `aVertexPosition`,
    which is an attribute. In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*, we will learn how to define and reference vertex and fragment shader
    attributes. For now, let's assume that we have the `aVertexPosition` attribute,
    which describes the vertex coordinates in the shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebGL function that allows pointing attributes to the currently-bound VBOs
    is `vertexAttribPointer`. The following is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s describe each parameter individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**: An attribute''s index that we are going to map the currently-bound
    buffer to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: Indicates the number of values per vertex that are stored in the
    currently-bound buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: Specifies the data type of the values stored in the current buffer.
    It is one of the following constants: `FIXED`, `BYTE`, `UNSIGNED_BYTE`, `FLOAT`, `SHORT`,
    or `UNSIGNED_SHORT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normalize**: This parameter can be set to `true` or `false`. It handles numeric
    conversions that are beyond the scope of this introductory guide. For our purposes,
    we will set this parameter to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stride**: If stride is `0`, then we are indicating that elements are stored
    sequentially in the buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offset**: The position in the buffer from which we will start reading values
    for the corresponding attribute. It is usually set to `0` to indicate that we
    will start reading values from the first element of the buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer Pointer**'
  prefs: []
  type: TYPE_NORMAL
- en: '`vertexAttribPointer` defines a pointer for reading information *fro**m the
    currently-bound buffer*. Remember that an error will be generated if there is
    no VBO currently bound.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we need to activate the vertex shader attribute. Following our example,
    we just need to add `gl.enableVertexAttribArray(positionAttributeLocation);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the mapping procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e019111-cf3c-4756-97c3-2abce4db9f69.png)'
  prefs: []
  type: TYPE_IMG
- en: Unbinding a VBO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a rule of thumb, we should unbind our buffers after we''re done using them.
    We can do so with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gl.bindBuffer(gl.ARRAY_BUFFER, null);`.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have defined our VBOs and we have mapped them to the corresponding vertex
    shader attributes, we are ready to render! To do this, we can use one of the two
    API functions: `drawArrays` or `drawElements`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `drawArrays` and `drawElements` functions are used for writing to the framebuffer. `drawArrays` uses
    vertex data in the order in which it is defined in the buffer to create the geometry.
    In contrast, `drawElements` uses indices to access the vertex data buffers and
    create the geometry. Both `drawArrays` and `drawElements` will only use **enabled
    arrays**. These are the vertex buffer objects that are mapped to active vertex
    shader attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the buffer that contains the vertex coordinates is the only
    enabled array. However, in a more general scenario, there may be several enabled
    arrays at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can have arrays with information about vertex colors, vertex
    normals, texture coordinates, and any other per-vertex data required by the application.
    In this case, each one of them would be mapped to an active vertex shader attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple VBOs
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, we will
    learn how to use a vertex normal buffer and vertex coordinates to create a lighting
    model for our geometry. In that scenario, we will have two active arrays: vertex
    coordinates and vertex normals.'
  prefs: []
  type: TYPE_NORMAL
- en: Using drawArrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will call `drawArrays` when information about indices is not available. In
    most cases, `drawArrays` is used when the geometry is simple enough that defining
    indices is overkill – for instance, when we want to render a triangle or a rectangle.
    In that case, WebGL will create the geometry in the order in which the vertex
    coordinates are defined in the VBO. If you have contiguous triangles (as we did
    in the trapezoid example), you will have to *repeat* these coordinates in the
    VBO.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to repeat many vertices to create the geometry, `drawArrays` is
    not the optimal method, because the more vertex data you duplicate, the more calls
    you will have on the vertex shader. This can reduce the overall performance, since
    the same vertices must go through the pipeline several times, one for each time
    that they are repeated in the respective VBO:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f878e9ed-961a-454c-9751-4ecb3b96cbe6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The signature for `drawArrays` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: Represents the type of primitive that we are going to render. The possible
    values for mode are `gl.POINTS`, `gl.LINE_STRIP`, `gl.LINE_LOOP`, `gl.LINES`, `gl.TRIANGLE_STRIP`, `gl.TRIANGLE_FAN`,
    and `gl.TRIANGLES`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first`: Specifies the starting element in the enabled arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: The number of elements to be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL drawArrays Specification
  prefs: []
  type: TYPE_NORMAL
- en: When `drawArrays` is called, it uses count sequential elements from each enabled
    array to construct a sequence of geometric primitives, beginning with the element *first*. Mode specifies
    what kinds of primitives are constructed and how the array elements construct
    those primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Using drawElements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the previous case where no IBO was defined, `drawElements` allows us
    to use the IBO to tell WebGL how to render the geometry. Remember that `drawArrays` uses
    VBOs, which means that the vertex shader will process the repeated vertices as
    many times as they appear in the VBO. On the other hand, `drawElements` uses indices.
    Therefore, vertices are only processed once, and can be used as many times as
    they are defined in the IBO. This feature reduces both the memory and processing
    required on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93121f63-2b22-47f1-bccc-337ba09ec6a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we use `drawElements`, we need at least two buffers: a VBO and an IBO.
    As the vertex shader gets executed on each vertex, the rendering pipeline assembles
    the geometry into triangles using the IBO.'
  prefs: []
  type: TYPE_NORMAL
- en: Binding the IBO with `drawElements`
  prefs: []
  type: TYPE_NORMAL
- en: When using `drawElements`, you need to make sure that the corresponding IBO
    is currently bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature for `drawElements` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: Represents the type of primitive we are going to render. The possible
    values for mode are `POINTS`, `LINE_STRIP`, `LINE_LOOP`, `LINES`, `TRIANGLE_STRIP`,
    `TRIANGLE_FAN`, and `TRIANGLES`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Specifies the number of elements to be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Specifies the type of the values in indices. Must be `UNSIGNED_BYTE`
    or `UNSIGNED_SHORT`, as we are handling indices (integer numbers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: Indicates which element in the buffer will be the starting point
    for rendering. It is usually the first element (zero value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL drawElements Specification
  prefs: []
  type: TYPE_NORMAL
- en: When `drawElements` is called, it uses count sequential elements from an enabled
    array, starting at the offset to construct a sequence of geometric primitives. Mode specifies
    what kinds of primitives are constructed and how the array elements construct
    these primitives. If more than one array is enabled, each is used.
  prefs: []
  type: TYPE_NORMAL
- en: Putting Everything Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you've probably been waiting to see how everything works together, let's
    go over a simple WebGL program that renders a square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Rendering a Square'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch02_01_square.html` file in a code editor (ideally one that supports
    syntax highlighting).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the structure of this file with the help of the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6ba7319-03f3-49fb-ad75-89d741e24628.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The web page contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<script id="vertex-shader" type="x-shader/x-vertex">` script contains the
    vertex shader code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<script id="fragment-shader" type="x-shader/x-fragment">` script contains
    the fragment shader code. We won't pay attention to these two scripts as they
    will be the main point of study in the next chapter. For now, simply notice that
    we have a fragment shader and a vertex shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next script on our web page, `<script type="text/javascript">`, contains
    all the JavaScript WebGL code that we will need. This script is divided into the
    following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We list a few global variables that we use throughout our application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`getShader` extracts the contents of a shader present in the HTML web page
    given its `id`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`initProgram` obtains a reference for the vertex shader and the fragment shader
    present in the web page (that is, the first two scripts that we discussed) and
    passes them along to the GPU to be compiled. Lastly, we attach the location of
    the `aVertexPosition` attribute to the `program` object so that it can be easily
    referenced later. Looking up `attribute` and `uniform` locations is expensive;
    therefore, such operations should happen once during initialization. We will cover
    these techniques in later chapters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`initBuffers` contains the API calls to create and initialize buffers, as we
    discussed earlier in this chapter. In this example, we create a VBO to store coordinates
    for the square and an IBO to store the indices of the square:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`draw` maps the VBO to the respective vertex buffer attribute, `program.aVertexPosition`,
    and enables it by calling `enableVertexAttribArray`. It then binds the IBO and
    calls the `drawElements` function. We will cover this in more detail in later
    chapters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`init` is the entry point for the entire application. When the page has loaded,
    `init` is invoked via `window.onload = init`. It''s important to note that the
    order of functions invoked inside of `init` are important to set up and render
    the geometry. We also set the canvas dimension to take the size of the entire
    window (fullscreen). As mentioned previously, in the `draw` function, we are using `canvas.width`
    and `canvas.height` as the source of truth for our drawing dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `ch02_01_square.html` file in the HTML5 browser of your preference
    (Firefox, Safari, Chrome, or Opera), and you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/230dfe04-f3bd-4609-b9f3-90cba1c1efce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open up the code for `ch02_01_square.html` and scroll down to the `initBuffers` function.
    Please pay attention to the diagram that appears as a comment inside of the function.
    This diagram describes how the vertices and indices are organized. You should
    see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Try to modify the existing buffers to turn the square into a pentagon. How would
    you do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the Geometry Definition
  prefs: []
  type: TYPE_NORMAL
- en: Modify the vertex buffer array and index array so that the resulting figure
    is a pentagon instead of a square. To do this, you need to add one vertex to the
    vertex array and define one more triangle in the index array.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file with a different name and open it in the HTML5 browser of your
    preference to test it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about the different code elements that conform to a WebGL app.
    The `initBuffers` function has been examined closely and modified to render a
    different geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Changing the Square Color'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the fragment shader and change the color of your geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Four-Component Color Vector
  prefs: []
  type: TYPE_NORMAL
- en: The format is (red, green, blue, alpha). Alpha is always `1.0` (for now), and
    the first three arguments are float numbers in the range of `0.0` to `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to save the file after making the changes in your text editor before
    opening it in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Rendering Using drawArrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our square was defined using `drawElements` via vertices and indices. Go ahead
    and render the same square using `drawArrays`.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Given that you don't use indices with `drawArrays`, you won't need an `IBO`.
    So, you will need to duplicate vertices to construct this geometry.
  prefs: []
  type: TYPE_NORMAL
- en: HintFor reference, you can find the source code for this exercise in `ch02_02_square-arrays.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Array Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vertex array objects (VAOs)** allow you to store all of the vertex/index
    binding information for a set of buffers in a single, easy to manage object. That
    is, the state of attributes, which buffers to use for each attribute, and how
    to pull data out from those buffers, is collected into a VAO. Although we can
    implement VAOs in WebGL 1 by using extensions, they are available by default in
    WebGL 2.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an important feature that should *always *be used, since it significantly
    reduces rendering times. When not using VAOs, all attributes data is in global
    WebGL state, which means that calling functions such as `gl.vertexAttribPointer`, `gl.enableVertexAttribArray`,
    and `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)` manipulates the global state.
    This leads to performance loss, because before any draw call, we would need to
    set up all vertex attributes and set the `ELEMENT_ARRAY_BUFFER` where indexed
    data is being used. On the other hand, with VAOs, we would set up all attributes
    during our application's initialization and simply bind the data at render, yielding
    much better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can start using VAOs from here on out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Rendering a Square Using a VAO'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s refactor a previous example using VAOs:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `ch02_01_square.html` in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we update our global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've replaced `squareVertexBuffer` with `squareVAO`, as we no longer need to
    reference the vertex buffer directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we update the `initBuffers` functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We create a new VAO instance using `gl.createVertexArray();` and assign it to
    `squareVAO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we bind `squareVAO` with `gl.bindVertexArray(squareVAO);` so that all
    of our attribute settings will apply to that set of attribute state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `squareVertexBuffer` has been configured, we instruct the currently
    bound VAO (i.e. `squareVAO`) on how to extract data given the instructions for
    `aVertexPosition`. These instructions are the same ones that previously sat inside
    of the `draw` function; but now, they happen *once *during initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we need to use this VAO in our `draw` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The updated `draw` function is far simpler! We simply bind the VAO (i.e. `squareVAO`)
    and allow for it to handle the instructions we provided it inside of `initBuffers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, it's good practice to unbind buffers and VAOs after usage by providing
    `null` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the file and open it in your browser. You should see the same square being
    rendered using a VAO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29fb58a7-d500-4205-90eb-6c336690bc22.png)'
  prefs: []
  type: TYPE_IMG
- en: The source code for this exercise can be found in `ch02_03_square-vao.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we're currently rendering a single geometry, using a VAO may seem
    unnecessarily complex. That is a reasonable assessment! However, as the complexity
    of our application grows, using VAOs becomes a foundational feature.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action: Rendering Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the signature of the `drawElements` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter determines the type of primitives that we are rendering.
    In the following section, we will see the different rendering modes with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch02_04_rendering-modes.html` file in your browser. This example follows
    the same structure as in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `ch02_04_rendering-modes.html` in your editor and scroll down to the `initBuffers` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you will see that we are drawing a trapezoid. However, on screen, you
    will see two triangles! Later, we'll see how this happened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the page, there is a settings controller that allows you to select
    the different rendering modes that WebGL provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/142fa15e-666d-4653-bb3e-353f5aa521f0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you select any option from the settings, you are changing the value of
    the `renderingMode` variable defined at the top of the code (scroll up if you
    want to see where it is defined). The code that sets up the settings controller
    is inside the `initControls` function. We will cover this functionality later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see how each option modifies the rendering, scroll to the `draw` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that after binding the IBO `trapezoidIndexBuffer` with the following
    instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You also have a switch statement where there is some code that executes, depending
    on the value of the `renderingMode` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each mode, we define the contents of the JavaScript array indices. Then,
    we pass this array to the currently-bound buffer, `trapezoidIndexBuffer`, by using
    the `bufferData` function. Finally, we call the `drawElements` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what each mode does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `TRIANGLES` | When you use the `TRIANGLES` mode, WebGL will use the first
    three indices defined in your IBO to construct the first triangle, the next three
    to construct the second triangle, and so on.In this example, we are drawing two
    triangles, which can be verified by examining the JavaScript indices array that
    populates the IBO: `indices = [0, 1, 2, 2, 3, 4];`. |'
  prefs: []
  type: TYPE_TB
- en: '| `LINES` | The `LINES` mode will instruct WebGL to take each consecutive pair
    of indices defined in the IBO and draw lines by taking the coordinates of the
    corresponding vertices.For instance, `indices = [1, 3, 0, 4, 1, 2, 2, 3];` will
    draw four lines: from vertex number `1` to vertex number `3`, from vertex number
    `0` to vertex number `4`, from vertex number `1` to vertex number `2`, and from
    vertex number `2` to vertex number `3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `POINTS` | When we use the `POINTS` mode, WebGL will not generate surfaces.
    Instead, it will render the vertices that we had defined using the index array.In
    this example, we will only render vertices number `1`, `2`, and `3` with `indices
    = [1, 2, 3];`. |'
  prefs: []
  type: TYPE_TB
- en: '| `LINE_LOOP` | `LINE_LOOP` draws a closed loop connecting the vertices defined
    in the IBO to the next one.In our case, it will be `indices = [2, 3, 4, 1, 0];`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LINE_STRIP` | `LINE_STRIP` is similar to `LINE_LOOP`. The difference is
    that WebGL does not connect the last vertex to the first one (not a closed loop).The indices JavaScript
    array will be `indices = [2, 3, 4, 1, 0];`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRIANGLE_STRIP` | `TRIANGLE_STRIP` draws connected triangles. Every vertex
    is specified after the first three.In our example, vertices number `0`, number
    `1`, and number `2` create a new triangle. If we have `indices = [0, 1, 2, 3,
    4];`, then we will generate the triangles *(0, 1, 2)*, *(1, 2, 3)*, and *(2, 3,
    4)*. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRIANGLE_FAN` | `TRIANGLE_FAN` creates triangles in a similar way to `TRIANGLE_STRIP`.
    However, the first vertex defined in the IBO is taken as the origin of the fan
    (the only shared vertex among consecutive triangles).In our example, `indices
    = [0, 1, 2, 3, 4];` will create the triangles *(0, 1, 2)* and *(0, 3, 4)*. |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram can be useful in visualizing these various rendering
    modes. That being said, it''s easiest to see these modes in action by changing
    the setting''s drop-down values and seeing the various results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22264ffd-5283-4738-a52a-7ff3b1271121.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's make some changes by editing `ch02_04_rendering-modes.html` so that when
    you select the `TRIANGLES` option, you render the trapezoid instead of two triangles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**'
  prefs: []
  type: TYPE_NORMAL
- en: You need one extra triangle in the indices array.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and test it in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the web page so that you draw the letter **M** using the `LINES` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: You need to define four lines in the indices array.
  prefs: []
  type: TYPE_NORMAL
- en: Just like before, save your changes and test them in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `LINE_LOOP` mode, draw only the boundary of the trapezoid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: This simple exercise helped us see the different rendering modes supported by
    WebGL. These different modes determine how to interpret vertex and index data
    to render an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebGL as a State Machine: Buffer Manipulation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with buffers for the `getParameter`, `getBufferParameter`, and `isBuffer` functions,
    new information about the state of the rendering pipeline becomes available to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting
    Started*, we will use `getParameter(parameter)`, where parameter can have the
    following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARRAY_BUFFER_BINDING`: Retrieves a reference to the currently-bound VBO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELEMENT_ARRAY_BUFFER_BINDING`: Retrieves a reference to the currently-bound
    IBO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also query the size and the usage of the currently-bound VBO and IBO
    using `getBufferParameter(type, parameter)`, where type can have the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARRAY_BUFFER`: To refer to the currently-bound VBO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELEMENT_ARRAY_BUFFER`: To refer to the currently-bound IBO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And parameter can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUFFER_SIZE`: Returns the size of the requested buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUFFER_USAGE`: Returns the usage of the requested buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding Buffers**'
  prefs: []
  type: TYPE_NORMAL
- en: Your VBO and/or IBO needs to be bound when you inspect the state of the currently-bound
    VBO and/or IBO with `getParameter` and `getBufferParameter`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `isBuffer(object)` will return `true` if the object is a WebGL buffer,
    or `false` with an error when the buffer is invalid. Unlike `getParameter` and `getBufferParameter`, `isBuffer` does
    not require any VBO or IBO to be bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Querying the State of Buffers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch02_05_state-machine.html` file in your browser. You should see
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/429910d1-7f7c-4a50-a5d9-abdc8e529cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `ch02_05_state-machine.html` in your editor and scroll down to the `initBuffers` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to how we use the methods discussed in this section to retrieve
    and display information about the current state of the buffers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The information queried by the `initBuffers` function is shown in the settings
    section of the web page when we use `updateInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the settings section of the web page, you will see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43adbdf7-8f9d-48c9-826f-4c328423a54b.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the following line, `gl.bindBuffer(gl.ARRAY_BUFFER, null);`, and paste
    it right before the following line inside of the `initBuffers` function: `coneIndexBuffer
    = gl.createBuffer();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you launch the page in your browser again?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you think this behavior occurs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: You have learned that the currently-bound buffer is a state variable in WebGL.
    The buffer is bound until you unbind it by calling `bindBuffer` again with the
    corresponding type (`ARRAY_BUFFER` or `ELEMENT_ARRAY_BUFFER`) as the first parameter
    and with `null` as the second argument (that is, no buffer to bind). You have
    also learned that you can only query the state of the currently-bound buffer.
    Therefore, if you want to query a different buffer, you need to bind it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Add One Validation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the file so that you can validate and show on screen whether the indices array
    and the `coneIndexBuffer` are WebGL buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to display the values, you will have to modify the table in the HTML
    body and modify the `updateInfo` function accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Geometry-Loading Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve rendered very simple objects. Now, let's investigate how to load
    a geometry (vertices and indices) from a file instead of declaring the vertices
    and indices every time we call `initBuffers`. To do this, we will make asynchronous
    calls to the web server using AJAX. We will retrieve the file with our geometry
    from the web server and then use the built-in JSON parser to convert the context
    of our files into JavaScript objects. In our case, these objects will be the vertices and indices arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JavaScript Object Notation (JSON)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. It is a lightweight, text-based,
    open format used for data interchange. JSON is commonly used as an alternative
    to XML.'
  prefs: []
  type: TYPE_NORMAL
- en: The power of JSON is that it's language-agnostic. This means that there are
    parsers in many languages to read and interpret JSON objects. Also, JSON is a
    subset of the object literal notation of JavaScript. Therefore, we can define
    JavaScript objects using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Defining JSON-Based 3D Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume, for example, that we have a model object with two arrays: vertices and indices.
    Say that these arrays contain the information described in the cone example (`ch02_06_cone.html`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the JSON notation, we would represent these two arrays as an object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this example, we can infer the following syntax rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The extent of a JSON object is defined by curly brackets (`{}`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes in a JSON object are separated by commas (`,`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no comma after the last attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each attribute of a JSON object has two parts: a **key **and a **value.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of an attribute is enclosed by quotation marks (`""`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each attribute key is separated from its corresponding value with a colon (`:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes of the array are defined in the same way you would define them in
    JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time for Action: Encoding and Decoding JSON'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most modern web browsers support native JSON encoding and decoding. Let''s
    examine the methods available inside this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `JSON.stringify(object)` | We use `JSON.stringify` to convert JavaScript
    objects to JSON-formatted text. |'
  prefs: []
  type: TYPE_TB
- en: '| `JSON.parse(string)` | We use `JSON.parse` to convert text into JavaScript
    objects. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s learn how to encode and decode with the JSON notation by creating a
    simple model—a 3D line. Here, we will be focusing on how we do JSON encoding and
    decoding. Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser, open the interactive JavaScript console. Use the following
    table for assistance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Browser** | **Shortcut keys (PC/Mac)** |'
  prefs: []
  type: TYPE_TB
- en: '| Firefox | *Ctrl *+ *Shift *+* K*/*Command *+* Alt *+* K* |'
  prefs: []
  type: TYPE_TB
- en: '| Safari | *Ctrl *+* Shift *+* C*/*Command *+* Alt *+* C* |'
  prefs: []
  type: TYPE_TB
- en: '| Chrome | *Ctrl *+* Shift *+* J*/*Command *+* Alt* +* J* |'
  prefs: []
  type: TYPE_TB
- en: 'Create a JSON object by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the model is an object by writing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript Type-Checking
  prefs: []
  type: TYPE_NORMAL
- en: Since many things in JavaScript are *objects*, it is recommended that you are
    more rigorous with type-checking. We will just use `typeof`for demonstration purposes.
    Additionally, there are many utility libraries, such as Lodash ([https://lodash.com](https://lodash.com/)), that
    extend JavaScript features to provide these operations and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the model attributes. Write this in the console (press *Enter* at
    the end of each line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a JSON text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What happens when you type `text.vertices`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, you get a message saying that `text.vertices` is `undefined`.
    This happens because text is not a JavaScript object, but a `string` with the
    peculiarity of being written according to JSON notation to describe an `object`.
    Everything in it is text, and so it does not have any fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s convert the JSON text back into an object. Type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to encode and decode JSON objects. These exercises are relevant
    because we will use the same process to define our geometry to be loaded from
    external files. In the next section, we will see how to download geometric models
    specified with JSON from a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Loading with AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the asynchronous loading of files by the web
    browser using AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c7a9d35-44e1-4c8e-a678-278d6ceb0978.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze this more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request File**: Indicates the path to the file you want to load. Remember
    that this file contains the geometry that we will be loading from the web server
    instead of coding the JavaScript arrays (vertices and indices) directly into the
    web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AJAX Request**: We need to write a function that will perform the AJAX request.
    Let''s call this function `load`. The code looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: AJAX Requests with FetchWe are leveraging `fetch`, an AJAX API provided in modern
    browsers, for fetching resources. It is very convenient with a **Promise**-based
    implementation. To learn more about `fetch`, visit [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's say that this function will perform the AJAX request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieving the file**: The web server will receive and treat our request
    as a regular HTTP request. In fact, the server does not know that this request
    is *asynchronous *(it is asynchronous for the web browser since it does not wait
    for the answer). The server will look for our file and generate a response, regardless
    of whether it finds the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous response**: Once a response is sent to the web browser, the
    `fetch` promise is resolved and the provided callback is invoked. This callback
    corresponds to the `then` request method. If the request is successful, we invoke
    the `then` callback; if it fails, we invoke the `catch` callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling the loaded model**: After our data is received and parsed, we attach
    a new callback to process the file retrieved from the server. Please notice that
    in the previous segment of code, we used the promise-based JSON parser to create
    a JavaScript object from the file before passing it to the next function. The
    code for the `load` function looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look closely, you’ll realize that this function is very similar to one
    of the functions we saw previously: the `initBuffers` function. This is reasonable,
    given that we cannot initialize the buffers until we retrieve the geometry data
    from the server. Just like `initBuffers`, we configure our VAO, VBO, and IBO and
    pass them the information contained in the JavaScript arrays of our model object.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re fetching assets from a server, we need to serve our application
    by using a server. If you do *not* have a web server, we recommend that you install
    a lightweight web server from the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serve: **[https://github.com/zeit/serve](https://github.com/zeit/serve)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighttpd: **[http://www.lighttpd.net](http://www.lighttpd.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python Server: **[https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting ExamplesAlthough any web server will be able to serve these examples,
    `serve` provides simplicity and great functionality. That being said, be sure
    to run your server from the root of the examples directory, since the `common` directory
    is a shared dependency across chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Working Around the Web Server Requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have Firefox and do not want to install a web server, you can change
    `strict_origin_policy` to false in `about:config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Chrome and do not want to install a web server, make sure
    that you run it from the command line with the following modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's use AJAX and JSON to load a cone from our web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Loading a Cone with AJAX'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your web server is running and access the `ch02_07_ajax-cone.html` file
    using your web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web Server Address
  prefs: []
  type: TYPE_NORMAL
- en: You know that you are using the web server if the URL in the address bar starts
    with `localhost/` or `127.0.0.1/` instead of `file://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The folder containing the code for this chapter should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0eb95e36-93cf-4cc9-be0c-19c312fe1a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on `ch02_07_ajax-cone.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The example will load in your browser and you will see something similar to
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f7e96fe-8a28-431d-936a-4f8c32cf6620.png)'
  prefs: []
  type: TYPE_IMG
- en: Please review the `load` functions to better understand the use of AJAX and
    JSON in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the global `model` variable used? *(Check the source code.)*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check what happens when you change the color in the `common/models/geometries/cone.json` file
    and reload the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the coordinates of the cone in the `common/models/geometries/cone.json` file
    and reload the page. Here, you can verify that WebGL reads and renders the coordinates
    from the file. If you modify them in the file, the geometry will be updated on
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use AJAX and JSON to load geometries from a remote location
    (web server) instead of specifying these geometries (using JavaScript arrays)
    inside the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Loading a Nissan GTR'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch02_08_ajax-car.html` file using your web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce4fd31d-c4eb-4701-abcd-416ccd53f68e.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason we selected the `LINES` model instead of the `TRIANGLES` model is
    to easily visualize the structure of the car.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the line where the rendering mode is being selected and make sure that
    you understand what the code does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `draw` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `drawElements` instruction, change the mode from `gl.LINES` to `gl.TRIANGLES`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the page in the web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you see? Can you guess why the visuals are different? What is your rationale?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lights
  prefs: []
  type: TYPE_NORMAL
- en: Illumination helps us visualize complex geometries more clearly. Without lights,
    all of our volumes will look opaque, and it will be difficult to distinguish their
    parts when changing from `LINES` to `TRIANGLES`.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover some useful functions that we can refactor for use in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `common/js/utils.js` in your editor to see the following changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have added two additional methods, `autoResizeCanvas` and `getShader`, to `utils.js` that
    look very similar to the code we implemented earlier in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `autoResizeCanvas` method takes a `canvas` element and dynamically resizes
    it to be fullscreen by watching browser-resizing events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getShader` function takes a `gl` instance and an `id` script to compile
    and return the shader source. Internally, `getShader` reads the source code of
    the script and stores it in a local variable. Then, it creates a new shader by
    using the WebGL `createShader` function. After that, it will add the source code
    to it using the `shaderSource` function. Finally, it will try to compile the shader
    using the `compileShader` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ch02_09_ajax-car-final.html` in your editor to see the following changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the `init` function where the necessary changes were made to use
    the `utils.autoResizeCanvas` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll to the `initProgram` function inside of `ch02_09_ajax-car-final.html`,
    where the necessary changes were made to use the `utils.getShader` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Open `ch02_09_ajax-car-final.html` in a browser to see these changes in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we’ve learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The WebGL API itself is just a rasterizer and, conceptually, is fairly simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL's rendering pipeline describes how the WebGL buffers are used and passed
    in the form of attributes to be processed by the vertex shader. The vertex shader
    parallelizes vertex processing in the GPU. Vertices define the surface of the
    geometry that is going to be rendered. Every element on this surface is known
    as a fragment. These fragments are processed by the fragment shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragment processing also occurs in parallel in the GPU. When all fragments have
    been processed, the framebuffer, a two-dimensional array, contains the image that
    is then displayed on your screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL is actually a pretty simple API. Its job is to execute two user-supplied
    functions, a vertex shader and fragment shader, and draw triangles, lines, or
    points. While it can get more complicated to do 3D, that complication is added
    by you, the programmer, in the form of more complex shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fine details of how WebGL renders geometry. Remember that there are two
    kinds of WebGL buffers that deal with geometry rendering: VBOs and IBOs*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL works as a state machine. As such, properties referring to buffers are
    available and their values depend on the currently-bound buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON and AJAX are two JavaScript technologies that integrate well with WebGL
    by enabling us to load large and complex assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about shaders and use them to implement
    light sources in our WebGL scene by passing information back and forth between
    the WebGL JavaScript API and the attributes, uniforms, and varyings.
  prefs: []
  type: TYPE_NORMAL
