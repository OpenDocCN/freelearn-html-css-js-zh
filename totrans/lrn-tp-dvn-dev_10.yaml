- en: Bringing It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explored the different tools and techniques available
    for doing type-driven development in ReasonML.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, using a final example, we are going to develop a sense for
    when to use each type-driven technique to solve problems. Let's see how we could,
    at least partly, create code that handles input (within a small JavaScript app)
    for social, productivity, and business applications. To be precise, what we mean
    here are the kinds of successful applications, such as Gmail, Facebook, Twitter,
    Skype, Airbnb, or Uber, launched by Internet or platform companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a variant type (version 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using more pattern matching (version 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching to polymorphic variant types (version 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using records (version 4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modules for code structure (version 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative code structure (version 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An improvement: Using lists as output (version 7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another improvement: Using mutable records (version 8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing our code (final version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with a variant type (version 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need a `type` to represent the companies, which are internet-powered
    apps. Based on that `type`, we can think of writing functions that will help us
    build our logic in a type-safe manner. Let's see how it goes.
  prefs: []
  type: TYPE_NORMAL
- en: As a first attempt, we start small, defining a variant type for the internet
    companies we are interested in. As we have seen in previous chapters, we will
    use pattern matching to show the list of apps each of these companies delivers
    to their users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the internet company type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the function that shows the applications, based on the company,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will show some apps from Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the whole code (generated from `src/Ch10/Ch10_PlatformCompany_V1.re`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are different categories of applications involved (social, business,
    communication, entertainment, and so on), we could enrich our type-driven logic
    by using more pattern matching code to differentiate the list of applications.
    Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Using more pattern matching (version 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we change the variants'' constructors to pass a string to them to represent
    each possible category (for example `Facebook(string)`, which could give `Facebook("social")`
    or `Facebook("business")`), we can do the trick. The additional pattern matching
    could then be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s start the second version of our code by defining the internet company
    variant type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as we planned, our function''s pattern matching code could evolve, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the following code will show some result data, so we can see whether things
    work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output we get when executing this version (`src/Ch10/Ch10_PlatformCompany_V2.bs.js`,
    generated from `src/Ch10/Ch10_PlatformCompany_V2.re`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that our type only accounts for internet companies, but our logic should
    also apply to other modern companies that use technology (web mobile, databases,
    AI) to build and deliver services in a scalable way. We can call them **platform
    companies**. So, we could add a type for platform companies too.
  prefs: []
  type: TYPE_NORMAL
- en: We can even consider that some internet companies (the big ones at least) are
    also platform companies or have launched platform businesses. So, we could change
    from *normal variant types* to *polymorphic variant types* to use their capability
    for type reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the third version based on these new ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to polymorphic variant types (version 3)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this new version, we define the two types we build our logic around, reusing
    the first one inside the second one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on that, we make our function evolve as follows (using `platformCompany`
    to allow all the variants to be accepted for the `company` parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s add the usual quick data display code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems like a good improvement, but let''s see whether it works. Testing
    the generated JavaScript code (based on `src/Ch10/Ch10_PlatformCompany_V3.re`)
    gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nice! What could we add to that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this implementation is nice, you can quickly see it lacks the ability
    to handle a richer data structure. Basically, we would like to represent an *app*
    with all the needed information, such as *the name*, and *the URL* (at least for
    web apps). For that, Reason has a convenient tool we can use: *records*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it goes with the next version, using records to handle apps.
  prefs: []
  type: TYPE_NORMAL
- en: Using records (version 4)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing changes from our first variant types, but we will add the `webapp`
    record type definition to them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can input some data for the rest of the program, using that record
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we just defined a few of those values for a minimal test. The real
    production-ready code should include all the record values needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal `apps` function would then look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some output display code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output for that minimal testing case (code from the `src/Ch10/Ch10_PlatformCompany_V4.re`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the next version, we will also use the URL of each app and show it in the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We can also improve the global code structure by packaging some types and functions
    in modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules for code structure (version 5)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first improvement we can make is to create a module to contain the record
    for the web apps and a function that would return their string representation.
    Let''s call that module `WebApp`. Its definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as in the previous version, we have our example web app values. The only
    thing that changes is that the type annotation is done using `WebApp.t`. That
    part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We then create a module, called `Platform`, for the rest of the logic. It could
    contain the definition of the types for companies and the `apps` function. To
    make things simple, let's choose to have a unique polymorphic variant type that
    contains all the companies. Within the module, we can call it `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a similar code that shows some possible output, and the code execution
    (JS code generated from the `src/Ch10/Ch10_PlatformCompany_V5.re` file) gives
    us an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our result is encouraging. There may be different possibilities, so let's continue
    experimenting by trying an alternative code structure and later adding improvements.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative code structure (version 6)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it's actually possible to write comprehensive code while using
    fewer modules in our code file. Let's keep the platform module, but move out what
    we had in the `WebApp` module in *Using modules for code structure (version 5)*,
    thus eliminating that module. At the same time, we will adjust some names and
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have fewer modules, we can improve our type-based code by introducing
    an interface file (`src/Ch10/Ch10_PlatformCompany_V6.rei`) to hold type information
    for the `.re` file (`src/Ch10/Ch10_PlatformCompany_V6.re`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `webapp` and `pfcompany` types and adjust the `appToString`
    function accordingly (in `src/Ch10/Ch10_PlatformCompany_V6.re`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there is no algorithmic change in the part where we do the *let bindings*
    to have input data for the web apps, so because of readability, we will not repeat
    that part of the code here. You can see the complete set of record values in the
    `src/Ch10/Ch10_PlatformCompany_V6.re` file, and you will notice that we added
    input for some Google apps, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we improve the `Platform` module code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the `Platform` module, which is preceded by its signature, `PlatformType`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're using `pfcompany` now as the type for the `company` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the case of Google (and their apps) in the code for pattern matching
    in the `apps` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The improvised part of the platform module code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this version of the implementation easily testable, we add the usual
    input and output printing code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To recap, we improved the type declarations using a `.rei` file (which helps
    with code documentation), we added a module signature (`PlatformType`) for platform,
    and we improved the coverage of the input by adding the Google case.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is encouraged to add input data (for the other companies in the variant
    type, such as Twitter, Amazon, and Uber).
  prefs: []
  type: TYPE_NORMAL
- en: An improvement – using lists as output (version 7)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You noticed that in our output, we are just using strings (via concatenation).
    From the beginning, we could have returned a real list of the apps from each company.
    No problem, let's change the code to do that now.
  prefs: []
  type: TYPE_NORMAL
- en: The change is limited to the `Platform` module. In the signature, for the `apps`
    function, we change the output type from `string` to `list(string)`. And, in the
    pattern matching part of the function, we change the implementation accordingly,
    for example, by returning the `[appToString(facebook), appToString(messenger),
    appToString(instagram)]` list for Facebook apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main part of the new version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now output lists, it is a good idea to use `Array.of_list` to print
    them, since it is a  nice and quick  solution. We change the last part of the
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the resulting code with my input data gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Nice! This was an interesting improvement. Let's continue adding to it.
  prefs: []
  type: TYPE_NORMAL
- en: Another improvement – using mutable records (version 8)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we could use a mutable record for the `webapp` type, so that we use it
    for interesting app data that keeps updating. One such data point is the number
    of accounts created. Another one could be the number of downloads of the corresponding
    mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s see how we can improve our implementation by adding
    the *number of accounts* parameter to the record. This is done by using `mutable
    numberOfAccounts: int` as the entry for that parameter in the record definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So that''s the only change for now, but let''s recap the definitions for the
    `webapp` type, the `pfcompany` type, and the `appToString` function for better
    readability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let''s add a function that increments the value of `numberofAccounts` in
    the record corresponding to a web app each time there is a new sign-up. This function
    could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as before, we have the input data part. But now we have the new parameter
    `newSignUp` which we have to keep updating. To make things simple, let''s pretend
    that all these apps currently have the same number of accounts, and we choose
    10,000 as an arbitrary number. So, now the record definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no change in the `Platform` module part, so let''s move to the next
    and last part, the code that tests things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the code compiled from the `src/Ch10/Ch10_PlatformCompany_V5.re` file
    gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, we just took an interesting use case where mutable records can be used,
    and saw how easy it is to add that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing our code (final version)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is the time to add tests to our code! For a complete demonstration, let's
    create a new package in which we will do the necessary setup for writing unit
    tests with the `Jest` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Another web technology used at Facebook, `Jest` is a framework for writing tests
    for JavaScript code, which also works with compile-to-JavaScript languages, such
    as TypeScript or ReasonML. For Reason, we also need to install the `bs-jest` package,
    which provides bindings for Jest in BuckleScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our final package and setting up for tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To quickly get things working, we create a folder, called `Ch10-final`, which
    contains the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the `package.json` file by copying the one we were using, generated
    by the ReasonML or BuckleScript code starter, and adapting it. The first version
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can add `Jest` and `bs-jest` (the one referenced by `glennsl/bs-jest`,
    to be precise) as development dependencies to our package using `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: To install `bs-jest`, run the `npm install @glennsl/bs-jest --save-dev` command.
  prefs: []
  type: TYPE_NORMAL
- en: To install `Jest`, run the `npm install jest --save-dev` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these installations, the required files are installed in the usual `node_modules`
    subdirectory and our `package.json` file changes to reference both dependencies
    with the versions that were installed. The updated `devDependencies` in the `package.json`
    file shows the two additions, as seen in the following extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bsconfig.json` file is also copied (and adapted) from the one we were
    using for the previous code setup (which allows the `bsb -w` command to work,
    and our `.re` files to be compiled on the fly). We adjust the `sources` list to
    reference both the `src` directory for the usual code and the `__tests__` directory
    for the *test code* (notice the `"type": "dev"` part), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to add is the `@glennsl/bs-jest` reference to the `bs-dev-dependencies`
    parameter. We will see why in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bsconfig.json` file for our `ch10final` package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the `src` subdirectory, we can add our final Reason code file (`src/Ch10-final/src/Ch10_PlatformCompany.re`).
    Our ReasonML code is exactly the same as in the previous version (the `src/Ch10/Ch10_PlatformCompany_V8.re` file),
    except that we simplify it by removing the last bit (the snippet that prints some
    output).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's write the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test code using `Jest`, we must start by opening the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a `describe` function to encapsulate the tests suite. We need
    to open the `Expect` module, part of `Jest`, which provides the `expect` function
    with other things where we need to check that some values meet certain conditions.
    We also open the module file, which contains our implementation code. So far,
    our test function contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add a first test to verify the data returned by the `apps` function
    in the `Platform` module. The test suite code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let's not stop here and add a second test that verifies that the number of accounts
    is the previous number incremented by `1` after the `newSignUp` function has been
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete tests suite code is as follows (in the `src\Ch10-final\__tests__\Platform_test.re` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can execute the tests, we need to build the code using the `bsb -make-world`
    command. This finds the test code and compiles it. If everything goes well, that
    process copies the resulting files in the `lib` part (generated) of the package
    structure (under `src\Ch10-final\lib\bs\__tests__`). We are now ready to run the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: To run the tests, we use the `Jest` command. In my case, running this on Windows,
    the executable is actually located at `node_modules\.bin\jest`, but in your case,
    you could just type `jest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the `Jest` test runner command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a good structure, including a test suite, and we can
    build on it. We can extend the input part of the code to take all the *platform
    companies* into account and add more functionalities. And we can add more tests
    as we go. This is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built some type-safe code that is also relatively easy to
    maintain and extend, using Reason's core features. We could go further to have
    more generic code using advanced techniques, such as functors, but that is not
    necessary for this small example.
  prefs: []
  type: TYPE_NORMAL
- en: This was the final chapter. We iterated through a type-driven process of solving
    coding problems. While doing so, we improved our understanding of ReasonML's features
    and techniques, in particular variant types, functions, modules, and records.
    We also looked at how to test ReasonML code directly using the `Jest` framework.
  prefs: []
  type: TYPE_NORMAL
- en: I hope the book was useful as an introduction to the world of ML languages,
    and that it will help you go further with the ReasonML techniques and tools, and
    maybe even with React if you are a web developer with additional skills.
  prefs: []
  type: TYPE_NORMAL
