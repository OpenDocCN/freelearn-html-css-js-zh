<html><head></head><body>
        

                            
                    <h1 class="header-title">Managing States and Props</h1>
                
            
            
                
<p>In the previous chapter, we talked about reusability and how to publish apps on the internet. We also looked into slots and how they can be helpful in extending our Web Components. </p>
<p>In this chapter, we will look into state management. State management lets you keep track of the state a Web Component is in. It is a very useful technique. We will also be looking into attributes to create even better Web Components. We have been using attributes since <a href="1a17ddb1-2db0-4704-80ca-d1b1b452028a.xhtml">Chapter 2</a>, <em>Web Components Life Cycle Callback Methods</em>. But in this chapter, we will look at it from a state management perspective. Then we will be looking into events and event management and how these events can be used to notify users of a Web Component's state.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h1">Introduction to State management</li>
<li class="h1">Managing attributes and properties</li>
<li class="h1">Event handling</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to state management</h1>
                
            
            
                
<p>Anything that can be used to manage the state of a <strong>User Interface</strong> (<strong>UI</strong>) can be considered as state management. And we see examples of state management in almost every site that we use on a daily basis. You use Gmail or any other email service. And emails have a state of <em>read</em> or <em>unread</em>. If you are playing a song on Spotify, the song that you are listening to has a state of <em>liked</em> or <em>not liked</em>. Based on these states, the UI can be shown in a different manner. </p>
<p>Web Components follow a similar approach. We can use a variable inside our Web Component to keep track of the state. Let's say that we want to create a Web Component that tells the user whether the device that the user is using is online or not. So, the state here will be <kbd>isOnline</kbd> and its value could be either <kbd>online</kbd> or <kbd>offline</kbd>. So let's begin.</p>
<p>Let's call this component <kbd>&lt;online-checker&gt;</kbd>, and let's say its state is managed by an internal variable <kbd>_isOnline</kbd>. The definition of this component would look something like this:</p>
<pre>export default class OnlineChecker extends HTMLElement {<br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    this._isOnline = false;<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/>  }<br/>}</pre>
<p>Here, we are setting the initial value of <kbd>_isOnline</kbd> to <kbd>false</kbd>, because we do not know whether we are online or not.</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;span class="online-status online-${this._isOnline ? 'true' : 'false'}"&gt;&lt;/span&gt;<br/>    &lt;span&gt;${this._isOnline ? 'Online' : 'Offline'}&lt;/span&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>The <kbd>render()</kbd> method is the same as our previous examples, nothing special. The special part is the <kbd>getTemplate()</kbd> method. Here, we are adding a class <kbd>online-true</kbd> or <kbd>online-false</kbd> based on the <kbd>_isOnline</kbd> variable. We are also adding the text <kbd>online</kbd> or <kbd>offline</kbd> based on the same.</p>
<p>The <kbd>getStyle()</kbd> method looks something like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: inline-block;<br/>        border: 1px solid #cac6c6;<br/>        padding: 10px;<br/>        border-radius: 5px;<br/>      }<br/>      .online-status {<br/>        height: 10px;<br/>        width: 10px;<br/>        border-radius: 50%;<br/>        display: inline-block;<br/>      }<br/>      .online-true {<br/>        background-color: green;<br/>      }<br/>      .online-false {<br/>        background-color: red;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>The class <kbd>.online-true</kbd> shows a green circle and <kbd>.online-false</kbd> shows a red color. </p>
<p>We still have not added the code to check whether the browser is online or not. So let's add it:</p>
<pre>connectedCallback() {<br/>  this.isOnline = navigator.onLine;<br/>  this.render();<br/>}<br/><br/>set isOnline(value) {<br/>  if(value !== this._isOnline) {<br/>    this._isOnline = value;<br/>    this.render();<br/>  }<br/>}<br/><br/>get isOnline(){<br/>  return this._isOnline;<br/>}</pre>
<p>Here, we are using <kbd>connectedCallback()</kbd> to see whether we are online or not. We are using <kbd>connectedCallback()</kbd> because we want to make sure that this code triggers when the Web Component is on the page.</p>
<p>The <kbd>get isOnline()</kbd> and <kbd>set isOnline()</kbd> methods create a property for the component that can be used outside of the component. So, say you have code that looks something like this:</p>
<pre>document.querySelector('online-checker').isOnline;</pre>
<p>This will return <kbd>true</kbd> or <kbd>false</kbd>, based on the <kbd>isOnline</kbd> property. </p>
<p>So, we are keeping a track of the online or offline state of the browser inside the <kbd>_isOnline</kbd> variable and making this value available with the help of the <kbd>isOnline</kbd> property:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ae36e608-5120-40ea-81da-344645758e14.png" style="width:13.92em;height:4.08em;"/></p>
<p>This is a very small introduction to properties inside Web Components as well. We will be looking at more examples in the coming sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attributes and properties</h1>
                
            
            
                
<p class="mce-root">We have been playing around with attributes since the first chapter. And we did get a brief overview of properties and how they can work along with state management to provide a more complete Web Component.</p>
<p class="mce-root">But what is the exact difference between the two? If you are a frontend developer, you must have created a form in your career. We will be looking at an example of an <kbd>&lt;input&gt;</kbd> tag:</p>
<pre>&lt;input type="text" value="default value" /&gt;</pre>
<p>If you look at it carefully, we have an attribute called <kbd>value</kbd> giving it some default value. So if you want to get the value of this <kbd>&lt;input&gt;</kbd> tag, you can get it by using the following code:</p>
<pre>document.querySelector('input').getAttribute('value');</pre>
<p>So, you are directly referencing the attribute for this <kbd>&lt;input&gt;</kbd> tag to get the value. But there is another way in which you can get this value. And that is as follows:</p>
<pre>document.querySelector('input').value;</pre>
<p>This time, we are grabbing the value from the property <kbd>value</kbd> of the <kbd>&lt;input&gt;</kbd> tag.</p>
<p>Now the question is, what is the difference? The difference is whether to show it in an attribute or not. There will always be a value that you might not want to show to the HTML code. It may be too long, such as a playlist in a music player Web Component, where the list contains a JSON-style data structure of song names and URLs, or a tax ID number like SSN in a tax registration component, where the data is too sensitive to be put as an attribute. </p>
<p>Let's try to look at this with the help of an example. Let's say we have a Web Component called <kbd>&lt;student-list&gt;</kbd> where we have an input field that is used to enter student names and a button that lets you add students to the student list. This is what the component looks like:</p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // Initially, the list is empty<br/>  this._list = [];<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/>  this.render();<br/>}</pre>
<p>Here, we are managing the student list inside the <kbd>_list</kbd> variable. The rest is the same as usual:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="student-list__form"&gt;<br/>      &lt;input type="text" name="student-name"<br/>        class="student-list__input"<br/>        placeholder="Enter Student Name here"/&gt;<br/>      &lt;button class="js-addButton student-list__add-button"&gt;Add Student&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="student-list__student-container"&gt;<br/>      &lt;div class="student-list__student-container-heading"&gt;Student List&lt;/div&gt;<br/>      &lt;div class="student-list__student-list"&gt;<br/>        ${this.getStudents()}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>As you can see, we have an input field, a button, and a <kbd>div student-list__student-list</kbd> to put our students in the form of a list:</p>
<pre>getStudents() {<br/>  return this._list.map((item, num) =&gt; {<br/>    return `&lt;div class="student-list__student"&gt;${num + 1}. ${item}&lt;/div&gt;`;<br/>  }).join('');<br/>}</pre>
<p>This <kbd>getStudents()</kbd> method shows the students by running over the <kbd>_list</kbd> variable that we declared in the <kbd>constructor()</kbd> method. Let's take a look at our styles before we move on to other sections of this Web Component:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .student-list__form {<br/>        display: flex;<br/>        align-items: center;<br/>      }<br/>      .student-list__input {<br/>        height: 44px;<br/>        margin: 0 25px;<br/>        width: 300px;<br/>        border-radius: 10px;<br/>        border-width: 1px;<br/>        font-size: 18px;<br/>        padding: 0 20px;<br/>      }<br/>      .student-list__add-button {<br/>        height: 50px;<br/>        width: 200px;<br/>        border-radius: 5px;<br/>        display: inline-block;<br/>        border: 1px solid #cac6c6;<br/>      }<br/>      .student-list__student-container {<br/>        margin-top: 50px;<br/>        border-top: 1px solid black;<br/>        padding-top: 50px;<br/>        font-size: 25px;<br/>      }<br/>      .student-list__student-container-heading {<br/>        margin-bottom: 20px;<br/>      }<br/>      .student-list__student {<br/>        padding: 10px;<br/>        margin-bottom: 10px;<br/>        border-bottom: 1px solid #bfbfbf;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>It's basic CSS, nothing complex. Now, let's add an event listener to our button so that it can add the students to our <kbd>_list</kbd> variable:</p>
<pre>connectedCallback() {<br/><br/>  // what should happen when the button is clicked<br/>  this.shadowObj.querySelector('.js-addButton')<br/>    .addEventListener("click", (e) =&gt; {<br/>      this.handleAdd(e);<br/>    });<br/>}<br/><br/>handleAdd() {<br/>  let value = this.shadowObj.querySelector('input[name=student-name]').value;<br/>  this._list.push(value);<br/>  this.renderList();<br/>}<br/><br/>renderList() {<br/>  this.shadowObj.querySelector('.student-list__student-list').innerHTML <br/>    = this.getStudents();<br/>}</pre>
<p>Here, we are adding a click event listener to the button <kbd>.js-addButton</kbd>. When a user clicks on the button, it grabs the value of the input field, and pushes it to our <kbd>_list</kbd> variable. After that, we are simply re-rending the list; in other words, rather than setting the inner HTML of our component again from scratch, we are simply changing the HTML of the section that needs to be updated.</p>
<p>But what if the user wants to see the student list, or grab it from the component? For this, let's add a property <kbd>students</kbd> for our user:</p>
<pre>set students (value) {<br/>  this._list = value;<br/>  this.renderList();<br/>}<br/><br/>get students (){<br/>  return this._list;<br/>}</pre>
<p>This way, the user can get the student list by using the following code:</p>
<pre>document.querySelector('student-list').students;</pre>
<p>This would give the user all the students that have been added in the form of an array:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bebccfb1-3769-4f86-9155-bf03de5f54f0.png" style="width:28.92em;height:3.25em;"/></p>
<p>But now you must be thinking, what if we were to make this available in the attributes? The answer is yes, we can do that. We can update our <kbd>handleAdd()</kbd> method to something like this:</p>
<pre>handleAdd() {<br/>  let value = this.shadowObj.querySelector('input[name=student-name]').value;<br/>  this._list.push(value);<br/>  this.setAttribute("students", this._list);<br/>  this.renderList();<br/>}</pre>
<p>This will make the list available in an attribute called <kbd>students</kbd>. But this is what the attribute will look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1a3311e8-d22c-42c6-8edd-0601530b4d2d.png" style="width:60.33em;height:12.08em;"/></p>
<p>Do you really want your users to manually parse a string to get an array? What if this data was a little bit more complex? Would the user know what needs to be parsed? In order to solve these complications, we use properties. </p>
<p>I hope this use case will help you decide what to put in properties and what to put in attributes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Event handling</h1>
                
            
            
                
<p>Till now, we have only looked into button-click events inside our Web Components. This section deals with event handlers from a different perspective.</p>
<p>Let's say we have a Web Component <kbd>&lt;custom-clicker&gt;</kbd> that has a button and a number that shows the number of times that button has been clicked. Let's take a look at the definition of this Web Component:</p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // Initially, the list is empty<br/>  this._num = 0;<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/>  this.render();<br/>}</pre>
<p>We are setting the value of <kbd>_num</kbd> to <kbd>0</kbd>. The rest is the same as usual:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="custom-clicker__container"&gt;<br/>      &lt;div class="custom-clicker_num"&gt;${this.getTimesClicked()}&lt;/div&gt;<br/>      &lt;button class="js-button custom-clicker__button"&gt;Click Me&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>The <kbd>render()</kbd> and <kbd>getTemplate()</kbd> methods are pretty much the same as well. We are simply showing text that is obtained via the <kbd>getTimesClicked()</kbd> method and a button that says <strong>Click Me</strong>: </p>
<pre>getTimesClicked() {<br/>  return `${this._num} times clicked.`;<br/>}</pre>
<p>Here, we are simply getting the value of <kbd>_num</kbd> and adding informational text. The <kbd>getStyle()</kbd> method looks something like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .custom-clicker__button {<br/>        height: 50px;<br/>        width: 200px;<br/>        border-radius: 5px;<br/>        display: inline-block;<br/>        border: 1px solid #cac6c6;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>We also want to increase the value of <kbd>_num</kbd> when the user clicks on the button:</p>
<pre>connectedCallback() {<br/><br/>  // what should happen when the button is clicked<br/>  this.shadowObj.querySelector('.js-button')<br/>    .addEventListener("click", (e) =&gt; {<br/>      this.handleClick(e);<br/>    });<br/>}<br/><br/>handleClick() {<br/>  this._num++;<br/>  this.shadowObj.querySelector('.custom-clicker_num').innerHTML <br/>        = this.getTimesClicked();<br/>}</pre>
<p>We are simply calling the <kbd>handleClick()</kbd> method when the user clicks on the button. Then we are simply adding 1 to this <kbd>_num</kbd> variable and updating the <kbd>.custom-clicker__num</kbd> <kbd>div</kbd>.</p>
<p>Now, we want to let our user know the value when this button is clicked. We can do so with the help of a custom event. We can do so with the help of <kbd>dispatchEvent()</kbd>:</p>
<pre>handleClick() {<br/>  this._num++;<br/>  this.shadowObj.querySelector('.custom-clicker__num').innerHTML <br/>        = this.getTimesClicked();<br/><br/>  this.dispatchEvent(new CustomEvent('change', {<br/>    detail: {<br/>      num: this._num,<br/>    },<br/>    bubbles: true,<br/>  }));<br/>}</pre>
<p>This notifies the listener to a change in the <kbd>num</kbd> variable and can be listened by the following code:</p>
<pre>&lt;custom-clicker onchange="handleChange(event.detail)"&gt;&lt;/custom-clicker&gt;<br/><br/>&lt;script type="text/javascript"&gt;<br/>  function handleChange(e) {<br/>    console.log(e);<br/>  }<br/>&lt;/script&gt;</pre>
<p>Alternatively, we can use the following code:</p>
<pre>&lt;custom-clicker&gt;&lt;/custom-clicker&gt;<br/><br/>&lt;script type="text/javascript"&gt;<br/>  document.querySelector('custom-clicker').addEventListener('change', (e) =&gt; {<br/>    console.log(e.detail);<br/>  });<br/>&lt;/script&gt;</pre>
<p>We can do anything we want with the <kbd>e.detail.num</kbd> variable.</p>
<p>This way, we can add any number of custom events to notify the user of any changes to the Web Component. The information that needs to be passed on can be put in the <kbd>detail</kbd> object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked into various aspects of state management. We went over how attributes and properties can be used to enhance a Web Component. Lastly, we created custom events for our Web Components.</p>
<p>In the next chapter, we will be creating a full fledged single page web app using all the concepts we have learned till now. We will be creating page level Web Components, implement routing and much more.</p>


            

            
        
    </body></html>