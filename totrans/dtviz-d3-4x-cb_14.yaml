- en: Chapter Appendix. Building Interactive Analytics in Minutes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this appendix we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning Crossfilter.js library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charting with dimensions using dc.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You have finished an entire book on data visualization with
    D3\. Together we have explored various topics and techniques. At this point you
    will probably agree that building interactive, accurate, and aesthetically appealing
    data visualization is not a trivial matter even with the help of a powerful library
    like D3\. It typically takes days or even weeks to finish a professional data
    visualization project even without counting the effort usually required on the
    backend. What if you need to build an interactive visualization quickly, or a
    proof-of-concept before a full-fledged visualization project can be commenced,
    and you need to do just that not in weeks or days, but minutes. In this appendix
    we will introduce you to two interesting JavaScript libraries that allow you to
    do just that: building quick in-browser interactive multidimensional data visualization
    in minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: The crossfilter.js library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crossfilter is also a library created by D3's author *Mike Bostock*, initially
    used to power analytics for Square Register.
  prefs: []
  type: TYPE_NORMAL
- en: '*Crossfilter is a JavaScript library for exploring large multivariate datasets
    in browser. Crossfilter supports extremely fast (<30ms) interaction with coordinated
    views, even with datasets containing a million or more records.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*-Crossfilter Wiki (August 2013)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In other words, Crossfilter is a library that you can use to generate data
    dimensions on large and typically flat multivariate datasets. So what is a data
    dimension? A data dimension can be considered as a type of data grouping or categorization
    while each dimensional data element is a categorical variable. Since this is still
    a pretty abstract concept, let''s take a look at the following JSON dataset and
    see how it can be transformed into dimensional dataset using Crossfilter. Assume
    that we have the following flat dataset in JSON describing payment transactions
    in a bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sample dataset borrowed from Crossfilter Wiki: [https://github.com/square/crossfilter/wiki/API-Reference](https://github.com/square/crossfilter/wiki/API-Reference)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'How many dimensions do we see here in this sample dataset? The answer is: it
    has as many dimensions as the number of different ways that you can categorize
    the data. For example, since this data is about customer payment, which is observation
    on time series, obviously the `date` is a dimension. Secondly, the payment type
    is naturally a way to categorize data; therefore, `type` is also a dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next dimension is bit tricky since technically we can model any of the
    field in the dataset as dimension or its derivatives; however, we don''t want
    to make something as a dimension if it does not help us slice the data more efficiently
    or provide more insight into what the data is trying to say. The total and tip
    fields have very high cardinality, which usually is an indicator for poor dimension
    unless we group them into different buckets (though tip/total, that is, tip in
    percentage could be an interesting dimension); however, the `quantity` field is
    likely to have a relatively small cardinality assuming people don''t buy thousands
    of drinks in this bar, therefore, we choose to use quantity as our third dimension.
    Now, here is what the dimensional logical model looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The crossfilter.js library](img/image_65_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dimensional Dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'These dimensions allow us to look at the data from a different angle, and if
    combined will allow us to ask some pretty interesting questions, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Are customers who pay by tab more likely to buy in larger quantity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are customers more likely to buy larger quantity on Friday night?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are customers more likely to tip when using tab versus cash?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you can see why dimensional dataset is such a powerful idea. Essentially,
    each dimension gives you a different lens to view your data, and when combined,
    they can quickly turn raw data into knowledge. A good analyst can quickly use
    this kind of tool to formulate a hypothesis, hence gaining knowledge from data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we understand why we would want to establish dimensions with our dataset;
    let''s see how this can be done using Crossfilter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in the preceding section, creating dimensions and groups are quite
    straight-forward in Crossfilter. First step before we can create anything is to
    feed our JSON dataset, loaded using D3, through Crossfilter by calling the `crossfilter`
    function (line `A`). Once that''s done, you can create your dimension by calling
    the `dimension` function and pass in an accessor function that will retrieve the
    data element that can be used to define the dimension. In the case for `type`
    we will simply pass in `function(d){return d.type;}`. You can also perform data
    formatting or other task in dimension function (for example, date formatting on
    line `B`). After creating the dimensions, we can perform the categorization or
    grouping by using the dimension, so `totalByHour` is a grouping that sums up total
    amount of the sale for each hour, while `salesByQuantity` is a grouping of counting
    the number of transactions by quantity. To better understand how `group` works,
    we will take a look at what the group object looks like. If you invoke the `all`
    function on the `transactionsByType` group you will get the following objects
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5530_App_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Crossfilter group objects
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that `transactionByType` group is essentially a grouping
    of the data element by its type while counting the total number of data elements
    within each group since we had called `reduceCount` function when creating the
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the description for functions we used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crossfilter`: Creates a new crossfilter with given records if specified. Records
    can be any array of objects or primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimension`: Creates a new dimension using the given value accessor function.
    The function must return naturally-ordered values, that is, values that behave
    correctly with respect to JavaScript''s `<`, `<=`, `>=`, and `>` operators. This
    typically means primitives: Booleans, numbers, or strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimension.group`: Creates a new grouping for the given dimension, based on
    the given `groupValue` function, which takes a dimension value as input and returns
    the corresponding rounded value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group.all`: Returns all groups, in ascending natural order by key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group.reduceCount`: A shortcut function to count the records; returns this
    group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group.reduceSum`: A shortcut function to sum records using the specified value
    accessor function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only touched a very limited number of Crossfilter functions. Crossfilter
    provides a lot more capability when it comes to how dimension and group can be
    created; for more information please check out its API reference: [https://github.com/square/crossfilter/wiki/API-Reference](https://github.com/square/crossfilter/wiki/API-Reference)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data Dimension: [http://en.wikipedia.org/wiki/Dimension_(data_warehouse)](http://en.wikipedia.org/wiki/Dimension_(data_warehouse))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cardinality: [http://en.wikipedia.org/wiki/Cardinality](http://en.wikipedia.org/wiki/Cardinality)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point we have everything we want to analyze. Now, let's see how this
    can be done in minutes instead of hours or days.
  prefs: []
  type: TYPE_NORMAL
- en: Dimensional charting - dc.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizing Crossfilter dimensions and groups is precisely the reason why `dc.js`
    was created. This handy JavaScript library was created by your humble author and
    is designed to allow you to visualize Crossfilter dimensional dataset easily and
    quickly. This library was originally created by your humble author now maintained
    by a group of community contributor led by Gordon Woodhull.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: dc.js version 2.0 beta that we used in this chapter has not yet been upgrade
    to D3 v4.x therefore you will notice usage and references to old D3 v3 API which
    is somewhat different from what we have witnessed so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file as reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/appendix-a/dc.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/appendix-a/dc.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example we will create three charts:'
  prefs: []
  type: TYPE_NORMAL
- en: A line chart for visualizing total amount of transaction on time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pie chart to visualize number of transactions by payment type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bar chart showing number of sales by purchase quantity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates a group of coordinated interactive charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_65_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interactive dc.js charts
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click or drag your mouse across these charts you will see the underlying
    Crossfilter dimensions being filtered accordingly on all charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_65_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Filtered dc.js charts
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen through this example, `dc.js` is designed to generate standard
    chart-based visualization on top of Crossfilter. Each `dc.js` chart is designed
    to be interactive so user can apply dimensional filter by simply interacting with
    the chart. `dc.js` is built entirely on D3, therefore, its API is very D3-like
    and I am sure with the knowledge you have gained from this book you will feel
    quite at home when using `dc.js`. Charts are usually created in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First step creates a chart object by calling one of the chart creation functions
    while passing in a D3 selection for its anchor element, which in our example is
    the `div` element to host the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we set the `width`, `height`, `dimension`, and `group` for each chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For coordinate charts rendered on a Cartesian plane you also need to set the
    `x` and `y` scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this first case, we explicitly set the x axis scale while letting the chart
    automatically calculate the y-scale for us. While in the next case we set both
    x and y scale explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different charts have different functions for customizing their look-and-feel
    and you can see the complete API reference at [https://github.com/dc-js/dc.js/blob/master/web/docs/api-latest.md](https://github.com/dc-js/dc.js/blob/master/web/docs/api-latest.md)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Leveraging `crossfilter.js` and `dc.js` allows you to build sophisticated data
    analytics dashboard fairly quickly. The following is a demo dashboard for analyzing
    the NASDAQ 100 Index for the last 20 years [https://dc-js.github.io/dc.js/](https://dc-js.github.io/dc.js/)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/image_65_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: dc.js NASDAQ demo
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, `dc.js` supports the following chart types:'
  prefs: []
  type: TYPE_NORMAL
- en: Bar chart (stackable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line chart (stackable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area chart (stackable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choropleth map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxplot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heatmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparkline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble overlay chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more, see this page for a complete list of supported chart types [http://dc-js.github.io/dc.js/examples/](http://dc-js.github.io/dc.js/examples/)
    . For more information on the `dc.js` 'library please check out our Wiki page
    at [https://github.com/dc-js/dc.js](https://github.com/dc-js/dc.js) .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some other useful D3 based reusable charting libraries. Although,
    unlike `dc.js` they are not designed to work with Crossfilter natively nevertheless
    they tend to be richer and more flexible when tackling general visualization challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NVD3: [http://nvd3.org/](http://nvd3.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rickshaw: [http://code.shutterstock.com/rickshaw/](http://code.shutterstock.com/rickshaw/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
