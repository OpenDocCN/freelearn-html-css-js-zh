<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;CSS Concepts and Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. CSS Concepts and Applications</h1></div></div></div><p>
<span class="strong"><strong>Cascading Style Sheet</strong></span> (<span class="strong"><strong>CSS</strong></span>) is the preferred way to style HTML. HTML has a style element and a <a class="indexterm" id="id567"/>global style attribute. These make it very easy to write unmaintainable HTML. For example, let's imagine that we have 10 elements on an HTML page for which we want the font color to be red. We create a <code class="literal">span</code> element to wrap the text that has the font color red, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;span style="color: #ff0000;"&gt;&lt;/span&gt;</pre></div><p>Later, if we decide to change the color to blue, we will have to change 10 instances of that element and then multiply this by the number of pages we have used the <code class="literal">span</code> element on. This is completely unmaintainable.</p><p>This is where CSS comes in. We can target specific elements/groups of elements to which we wish to apply a specific style. CSS allows us to define these styles, easily update them, and change them from one place to another.</p><p>This book will focus on the most used CSS selectors, units, rules, functions, and properties from CSS1, CSS2.1, and CSS3. For the most part, these should all work in any browser, but there are exceptions. A great rule of thumb is that newer browsers will have fewer issues.</p><p>We will get started with a quick overview of the different types of basic selectors.</p><div class="section" title="Basic selectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Basic selectors</h1></div></div></div><p>A selector <a class="indexterm" id="id568"/>represents a structure. This representation is then used in a CSS rule to determine what elements are selected to be styled by this rule. CSS style rules apply in the form of a waterfall effect. Each rule that is matched is also passed on to each of its children, matched and applied based on the weight of the selector. This section will only focus on the most basic of selectors.</p><p>The basic selectors are either type selectors, universal selectors, attribute selectors, class selectors, ID selectors, or pseudo-classes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>All CSS selectors are case-insensitive. Selectors can also be grouped together to share rules. To group selectors, you just have to split them with commas. Consider the following example:</p><div class="informalexample"><pre class="programlisting">p { color: #ffffff; }
article { color: #ffffff }</pre></div><p>Here, the following <a class="indexterm" id="id569"/>is the same as the preceding declaration </p><div class="informalexample"><pre class="programlisting">p, article { color: #ffffff }</pre></div></div></div><div class="section" title="The simple selector"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec147"/>The simple selector</h2></div></div></div><p>The <a class="indexterm" id="id570"/>following selectors are all the simple selectors for CSS.</p></div><div class="section" title="The type selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec148"/>The type selectors</h2></div></div></div><p>The <code class="literal">type</code> selectors <a class="indexterm" id="id571"/>selects based on the element name:</p><div class="informalexample"><pre class="programlisting">E
ns|E</pre></div><p>Here, <code class="literal">E</code> is the <a class="indexterm" id="id572"/>element name and <code class="literal">ns</code> is a namespace.</p><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec258"/>Description</h3></div></div></div><p>This is the simplest way to select elements—using their name. For the most part, when using just HTML, you not need to worry about the namespace, as all of the HTML elements are in the default namespace. An <a class="indexterm" id="id573"/>asterisk can be used to specify all namespaces, for example, <code class="literal">*|Element</code>.</p><p>When this selector is used, it will match all of the elements in the document. For example, if you have fifteen <code class="literal">h2</code> elements and use a single <code class="literal">h2</code> element, then this rule will match all fifteen.</p><p>Here are a few examples of the <code class="literal">type</code> selector. The first code sets all the <code class="literal">h1</code> elements' font color to red. The next code applies red as the background color for all <code class="literal">p</code> elements:</p><div class="informalexample"><pre class="programlisting">h1 { color: #ff0000; }
p { background: #ff0000; }</pre></div></div></div><div class="section" title="The universal selector"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec149"/>The universal selector</h2></div></div></div><p>The asterisk (<code class="literal">*</code>) represents <a class="indexterm" id="id574"/>any and all qualified elements:</p><div class="informalexample"><pre class="programlisting">*
ns|*
*|*</pre></div><p>Here, <code class="literal">ns</code> is a <a class="indexterm" id="id575"/>namespace.</p><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec259"/>Description</h3></div></div></div><p>This is essentially a <a class="indexterm" id="id576"/>wildcard selector. It will match every element. This is <code class="literal">true</code> even when used with other selectors. For example, <code class="literal">*.my-class</code> and <code class="literal">.my-class</code> are the same.</p><p>While you can use it as a single selector to match every element, it is most useful when used with other selectors. Following along with our preceding example, we may want to select any element that is a descendant of an <code class="literal">article</code> element. This selector is very explicit and easy to read, take a look at the following syntax:</p><div class="informalexample"><pre class="programlisting">article *</pre></div><p>Here is an example. The first example uses attribute selectors to select any elements with <code class="literal">hreflang</code> in English, and the second example will select all elements in the document:</p><div class="informalexample"><pre class="programlisting">*[hreflang="en"] { display: block; background:url(flag_of_the_UK); }
* { padding: 0; }</pre></div></div></div><div class="section" title="The attribute selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec150"/>The attribute selectors</h2></div></div></div><p>These selectors <a class="indexterm" id="id577"/>will match against attributes of an element. There are <a class="indexterm" id="id578"/>seven different types of attribute selector and they are as follows:</p><div class="informalexample"><pre class="programlisting">[attribute]
[attribute=value]
[attribute~=value]
[attribute|=value]
[attribute^=value]
[attribute$=value]
[attribute*=value]</pre></div><p>These selectors are usually preceded by a type selector or universal selector.</p><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec260"/>Description</h3></div></div></div><p>This selector is a way to use a regular expression syntax in a selector rule. Each of the selectors will act differently based on the use, so they are listed with the differences here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">[attribute]</code>: This matches an element that has the <code class="literal">[attribute]</code> attribute, irrespective of the value of the attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[=]</code>: The value has to be an exact match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[~=]</code>: This is used when the attribute takes a list of values. One of the values in the list must match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[|=]</code>: This attribute must either be an exact match or the value must begin with the value followed immediately by a <code class="literal">-</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[^=]</code>: This attribute matches the value that has this prefix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[$=]</code>: This attribute matches the value that has this suffix.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[*=]</code>: This attribute matches any substring of the value.</li></ul></div><p>The best way to really show <a class="indexterm" id="id579"/>the difference between these is to use some examples. We will look at the <code class="literal">lang</code> and <code class="literal">href</code> attributes. The examples will be in the same order in which they were introduced.</p><p>Here is the HTML file that the examples will be selecting.</p><div class="informalexample"><pre class="programlisting">&lt;span lang="en-us en-gb"&gt;Attribute Selector&lt;/span&gt;
&lt;span lang="es"&gt;selector de atributo&lt;/span&gt;
&lt;span lang="de-at de"&gt;German (Austria)&lt;/span&gt;
&lt;a href="https://example.com"&gt;HTTPS&lt;/a&gt;
&lt;a href="http://google.com"&gt;Google&lt;/a&gt;
&lt;a href="http://example.com/example.pdf"&gt;Example PDF&lt;/a&gt;</pre></div><p>Using the following, we should have all the spans with a <code class="literal">lang</code> attribute with a black background, Spanish will be grey, German will be red, English will be blue, anchor elements that have <code class="literal">https</code> attribute will be yellow, any PDFs will be red, and any anchor to Google will be green. Here are the preceding styles described:</p><div class="informalexample"><pre class="programlisting">span[lang] { background-color: #000000; color: #ffffff; }
span[lang="es"] { color: #808080; }
span[lang~="de-at"] { color: #ff0000; }
span[lang|="en"] { color: #0000ff; }
a[href^="https"] { color: #ffff00; }
a[href$="pdf"] { color: #ff0000; }
a[href*="google"] { color: #00ff00; }</pre></div></div></div><div class="section" title="The class selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec151"/>The class selectors</h2></div></div></div><p>This selector will <a class="indexterm" id="id580"/>match the HTML elements based on the class attribute of the <a class="indexterm" id="id581"/>element.</p><div class="informalexample"><pre class="programlisting">element.class
.class or *.class
element.class.another-class</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec261"/>Description</h3></div></div></div><p>This is the most commonly used selector. Selecting based on the <code class="literal">class</code> attribute allows you to style elements in an orthogonal manner. Classes can be applied to many different elements and we can style each of those elements in the same manner.</p><p>The <code class="literal">class</code> selector can be stacked so that both classes will have to be present.</p><p>Here is some HTML with different elements that have a class attribute:</p><div class="informalexample"><pre class="programlisting">&lt;h1 class="red"&gt;Red Text&lt;/h1&gt;
&lt;span class="red"&gt;Red Text&lt;/span&gt;
&lt;span class="green black"&gt;Green text, black background&lt;/span&gt;
&lt;span class="green"&gt;Normal text&lt;/span&gt;</pre></div><p>Here is the CSS to <a class="indexterm" id="id582"/>style the HTML:</p><div class="informalexample"><pre class="programlisting">.red { color: #ff0000; }
.green.black { color: #00ff00; background-color: #000000; }</pre></div><p>When the <code class="literal">red</code> class is applied to <a class="indexterm" id="id583"/>an element, it will change the color of the text to red. The compound green and black will only select elements that have both classes defined.</p></div></div><div class="section" title="The ID selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec152"/>The ID selectors</h2></div></div></div><p>This selector will <a class="indexterm" id="id584"/>match <a class="indexterm" id="id585"/>based on the <code class="literal">ID</code> attribute of the element:</p><div class="informalexample"><pre class="programlisting">#id
element#id or *#id</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec262"/>Description</h3></div></div></div><p>The <code class="literal">ID</code> attribute should be unique <a class="indexterm" id="id586"/>for the document, so the <code class="literal">ID</code> selector should only ever target one element. This is in contrast to the <code class="literal">class</code> selector, which can be used to select multiple elements. As an example, you can use a <code class="literal">class</code> selector to make every image on your page have a certain amount of margin and have a rule that specifically targets just your logo to have a different amount of margin.</p><p>Here is an example CSS rule that targets an ID of a logo:</p><div class="informalexample"><pre class="programlisting">#logo { margin: 10px; }</pre></div></div></div></div></div>
<div class="section" title="Combinators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Combinators</h1></div></div></div><p>Combinators <a class="indexterm" id="id587"/>are used to select more complex structures. They can help target specific elements or groups of elements that would be difficult to target otherwise.</p><div class="section" title="Descendant combinator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec153"/>Descendant combinator</h2></div></div></div><p>This selector <a class="indexterm" id="id588"/>specifies that an element must be contained by <a class="indexterm" id="id589"/>another element.</p><p>The combinator is the whitespace character. We are explicitly defining it here so that it is clear:</p><div class="informalexample"><pre class="programlisting">selector-a selector-b</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec263"/>Description</h3></div></div></div><p>The two or more statements used in this selector can be any valid selector statement. For example, the first could be a <code class="literal">class</code> selector followed by a <code class="literal">type</code> selector. The distance between the selectors does not <a class="indexterm" id="id590"/>matter. Each intermediate element will not have to be listed for the selector to work.</p><p>The combinator can be stacked. Each statement will have a whitespace character around it. This list of selectors does not need to be all inclusive, but for the selector to match the hierarchy, it does need to exist.</p><p>This selector is best used when you only want to style elements in certain situations. The following example highlights this.</p><p>In this first example, we will target images that are in an ordered list with the ID of presidents and give them a red border. Here is its HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;ol id="presidents"&gt;
  &lt;li&gt;&lt;img src="pres01.png" alt="PortraitProtrait of George Washington" /&gt;George Washington&lt;/li&gt;
  &lt;li&gt;&lt;img src="pres02.png" alt="PortraitProtrait of John Adams" /&gt;John Adams&lt;/li&gt;
&lt;/ol&gt;
&lt;img src="not_pres.png" alt="not a President - no border" /&gt;</pre></div><p>Here is the CSS rule:</p><div class="informalexample"><pre class="programlisting">ol#presidents img { border: 1px solid #ff0000; }</pre></div><p>Here is an example that demonstrates that there can be many elements between selectors. Here is the very arbitrary HTML.</p><div class="informalexample"><pre class="programlisting">&lt;div class="example"&gt;
  I am normal.
  &lt;div&gt;
    &lt;div class="select-me"&gt;
      I am red.
      &lt;span class="select-me"&gt;I am red as well.&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Here is the CSS rule:</p><div class="informalexample"><pre class="programlisting">.example .select-me { color: #ff0000; }</pre></div><p>Finally, here is an example <a class="indexterm" id="id591"/>of a multiple selector hierarchy, which has the following HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div class="first"&gt;Not the target
  &lt;div class="second"&gt;Not the target
    &lt;div class="third"&gt;I am the target.&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The CSS rule:</p><div class="informalexample"><pre class="programlisting">.first .second .third { color: #ff0000; }</pre></div></div></div><div class="section" title="The child combinator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec154"/>The child combinator</h2></div></div></div><p>This <a class="indexterm" id="id592"/>selector <a class="indexterm" id="id593"/>targets a specific child:</p><div class="informalexample"><pre class="programlisting">element-a &gt; element-b</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec264"/>Description</h3></div></div></div><p>This is very similar <a class="indexterm" id="id594"/>to the descendant combinatory except for the fact that this only targets a child relationship. The second selector must be a direct descendant of the parent directly contained by the first.</p><p>Here is an example that will only target the first span in this HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;Here is an &lt;span&gt;arbitrary&lt;/span&gt; &lt;p&gt;&lt;span&gt;structure.&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</pre></div><p>Here is the CSS rule that only sets the first span's color to red:</p><div class="informalexample"><pre class="programlisting">div &gt; span { color: #ff0000; }</pre></div></div></div><div class="section" title="The adjacent sibling combinator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec155"/>The adjacent sibling combinator</h2></div></div></div><p>This <a class="indexterm" id="id595"/>selector targets elements that are next to <a class="indexterm" id="id596"/>each other in the hierarchy:</p><div class="informalexample"><pre class="programlisting">element-a + element-b</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec265"/>Description</h3></div></div></div><p>The two elements must <a class="indexterm" id="id597"/>have the same parent, and the first element must be immediately followed by the second.</p><p>Here is an example that highlights how the selector works. Only the second span will have the rule applied. The final span's preceding sibling is not another span so it is not matched by the selector. Here is the HTML.</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Here are a few spans in a row: &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;em&gt;3&lt;/em&gt; &lt;span&gt;4&lt;/span&gt;&lt;/p&gt;</pre></div><a class="indexterm" id="id598"/><p>
<span class="strong"><strong>CSS</strong></span>:</p><div class="informalexample"><pre class="programlisting">span + span { color: #ff0000; }</pre></div></div></div><div class="section" title="The general sibling combinator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec156"/>The general sibling combinator</h2></div></div></div><p>This <a class="indexterm" id="id599"/>selector targets any element that has the same <a class="indexterm" id="id600"/>parent and follows the first:</p><div class="informalexample"><pre class="programlisting">element-a ~ element-b</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec266"/>Description</h3></div></div></div><p>This is similar to the <a class="indexterm" id="id601"/>adjacent sibling combinatory; in that, both elements need the same parent. The difference is that the two elements can be separated by other elements.</p><p>Here is an example that shows that both the second and third spans will be targeted even though there is an <code class="literal">em</code> element between them. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Here are a few spans in a row: &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;em&gt;3&lt;/em&gt; &lt;span&gt;4&lt;/span&gt;&lt;/p&gt;</pre></div><p>Here is the CSS rule:</p><div class="informalexample"><pre class="programlisting">span ~ span { color: #ff0000; }</pre></div></div></div><div class="section" title="The selector specificity"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec157"/>The selector specificity</h2></div></div></div><p>This is not a <a class="indexterm" id="id602"/>selector rule like the others in this section. An element can be targeted by multiple rules, so how do you know which rule takes precedence? This is where specificity comes in. You can calculate which rule will be applied. Here is how it is calculated. Keep in mind that an inline style will trump any selector specificity:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of <code class="literal">ID</code> selectors in the selector is denoted by <code class="literal">a</code></li><li class="listitem" style="list-style-type: disc">The number of <code class="literal">class</code> selectors, <code class="literal">attribute</code> selectors, and pseudo-classes in the selector is denoted by <code class="literal">b</code></li><li class="listitem" style="list-style-type: disc">The number of <code class="literal">type</code> selectors and pseudo-elements in the selector is denoted by <code class="literal">c</code></li><li class="listitem" style="list-style-type: disc">Any <code class="literal">universal</code> selectors are ignored</li></ul></div><p>The numbers are then concatenated together. The larger the value, the more precedence the rule has. Let's look at some selector examples. The examples will be composed of the selector and then the calculated value:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">h1</code>: <code class="literal">a=0</code> <code class="literal">b=0</code> <code class="literal">c=1</code>, <code class="literal">001</code> or <code class="literal">1</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1 span</code>: <code class="literal">a=0</code> <code class="literal">b=0</code> <code class="literal">c=2</code>, <code class="literal">002</code> or <code class="literal">2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1 p &gt; span</code>: <code class="literal">a=0</code> <code class="literal">b=0</code> <code class="literal">c=3</code>, <code class="literal">003</code> or <code class="literal">3</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1 *[lang="en"]</code>: <code class="literal">a=0</code> <code class="literal">b=1</code> <code class="literal">c=1</code>, <code class="literal">011</code> or <code class="literal">11</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1 p span.green</code>: <code class="literal">a=0</code> <code class="literal">b=1</code> <code class="literal">c=3</code>, <code class="literal">013</code> or <code class="literal">13</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1 p.example span.green</code>: <code class="literal">a=0</code> <code class="literal">b=2</code> <code class="literal">c=3</code>, <code class="literal">023</code> or <code class="literal">23</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">#title</code>: <code class="literal">a=1</code> <code class="literal">b=0</code> <code class="literal">c=0</code>, <code class="literal">100</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">h1#title</code>: <code class="literal">a=1</code> <code class="literal">b=0</code> <code class="literal">c=1</code>, <code class="literal">101</code></li></ul></div><p>The easiest way to think about this is that each grouping (<code class="literal">a</code>, <code class="literal">b</code>, or <code class="literal">c</code>) should be a smaller group of elements to choose from. This means that each step has more weight. For example, there can <a class="indexterm" id="id603"/>be many instances of <code class="literal">h1</code> on a page. So, just selecting <code class="literal">h1</code> is a little ambiguous. Next, we can add a <code class="literal">class</code>, <code class="literal">attribute</code>, or pseudo-class selector. This should be a subset of the instances of <code class="literal">h1</code>. Next, we can search by ID. This carries the most weight because there should only be one in the entire document.</p><p>Here is an example HTML that has three headings:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;First Heading&lt;/h1&gt;
&lt;h1 class="headings"&gt;&lt;span&gt;Second Heading&lt;/span&gt;&lt;/h1&gt;
&lt;h1 class="headings" id="third"&gt;Third Heading&lt;/h1&gt;</pre></div><p>Here is the CSS rule that will target each heading differently. The first rule targets all the elements, but it has the lowest specificity, the next rule is in the middle, and the last rule only targets one element. In the following example, <code class="literal">/* */</code> denotes text that is a comment:</p><div class="informalexample"><pre class="programlisting">h1 { color: #ff0000; } /* 001 */
h1.headings span { color: #00ff00; } /* 012 */
h1#third { color: #0000ff; } /* 101 */</pre></div></div></div>
<div class="section" title="Pseudo-classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Pseudo-classes</h1></div></div></div><p>Pseudo-classes <a class="indexterm" id="id604"/>are selectors that use information that is outside of the document tree. The information that is not in the attributes of the element. This information can change between visits or even during the visit. Pseudo-classes always have a colon followed by the name of the pseudo-class.</p><div class="section" title="The link pseudo-classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec158"/>The link pseudo-classes</h2></div></div></div><p>There are <a class="indexterm" id="id605"/>two mutually exclusive link pseudo-classes, namely, <code class="literal">:link</code> and <code class="literal">:visited</code>.</p><div class="section" title=":link"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec267"/>:link</h3></div></div></div><p>This selects links <a class="indexterm" id="id606"/>that have not been visited. The syntax is as <a class="indexterm" id="id607"/>follows:</p><div class="informalexample"><pre class="programlisting">:link</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec17"/>Description</h4></div></div></div><p>This pseudo-class exists on any anchor element that has not been visited. The browser may decide to switch a <a class="indexterm" id="id608"/>link back after some time.</p><p>Here is an example along with the <code class="literal">:visited</code> pseudo-class. Here is its HTML:</p><div class="informalexample"><pre class="programlisting">&lt;a href="#test"&gt;Probably not visited&lt;/a&gt;
&lt;a href="https://www.google.com"&gt;Probably visited&lt;/a&gt;</pre></div><p>Here is the CSS. We can make an assumption that you have visited Google, so the link would likely be green in color:</p><div class="informalexample"><pre class="programlisting">a:link { color: #ff0000; }
a:visited { color: #00ff00; }</pre></div></div></div><div class="section" title=":visited"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec268"/>:visited</h3></div></div></div><p>This selects <a class="indexterm" id="id609"/>links that have been visited. The syntax is as <a class="indexterm" id="id610"/>follows:</p><div class="informalexample"><pre class="programlisting">:visited</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec18"/>Description</h4></div></div></div><p>This pseudo-class exists on <a class="indexterm" id="id611"/>any anchor element that has been visited.</p><p>Here is an example along with the <code class="literal">:link</code> pseudo-class. Here is its HTML:</p><div class="informalexample"><pre class="programlisting">&lt;a href="#test"&gt;Probably not visited&lt;/a&gt;
&lt;a href="https://www.google.com"&gt;Probably visited&lt;/a&gt;</pre></div><p>Here is the CSS. We can make the same assumption that you have visited Google, so the first link should be red and <a class="indexterm" id="id612"/>the second link will be green in color:</p><div class="informalexample"><pre class="programlisting">a:link { color: #ff0000; }
a:visited { color: #00ff00; }</pre></div></div></div></div><div class="section" title="User action pseudo-classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec159"/>User action pseudo-classes</h2></div></div></div><p>These <a class="indexterm" id="id613"/>classes take effect based on actions of the user. These <a class="indexterm" id="id614"/>selectors are not mutually exclusive, and an element can have several matches at once.</p><div class="section" title=":active"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec269"/>:active</h3></div></div></div><p>This is used <a class="indexterm" id="id615"/>when the element is being activated:</p><div class="informalexample"><pre class="programlisting">:active</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec19"/>Description</h4></div></div></div><p>The :<code class="literal">active</code> selector <a class="indexterm" id="id616"/>is most commonly used when the mouse button is pressed but not released. This style can be superseded by the other user actions or link pseudo-classes.</p><p>Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;a href="https://www.google.com"&gt;Google&lt;/a&gt;</pre></div><p>The link will turn green while you are clicking on it. Here is its CSS:</p><div class="informalexample"><pre class="programlisting">a:active { color: #00ff00; }</pre></div></div></div><div class="section" title=":focus"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec270"/>:focus</h3></div></div></div><p>This selector targets <a class="indexterm" id="id617"/>the element that has to be focused on. The <a class="indexterm" id="id618"/>syntax is as follows:</p><div class="informalexample"><pre class="programlisting">:focus</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec20"/>Description</h4></div></div></div><p>An element is considered to have focus when it accepts keyboard input. For example, a text input element that you <a class="indexterm" id="id619"/>have either tabbed to or have clicked inside.</p><p>Here is a text input example:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" value="Red when focused"&gt;</pre></div><p>Here is the CSS. This also <a class="indexterm" id="id620"/>highlights the fact that you can use a pseudo-class, which allows use of more complex selectors:</p><div class="informalexample"><pre class="programlisting">input[type="text"]:focus { color: #ff0000; }</pre></div></div></div><div class="section" title=":hover"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec271"/>:hover</h3></div></div></div><p>This selector targets <a class="indexterm" id="id621"/>the elements when a user hovers their mouse <a class="indexterm" id="id622"/>over an element:</p><div class="informalexample"><pre class="programlisting">:hover</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec21"/>Description</h4></div></div></div><p>This is used when a user has their cursor hovering over an element. Some browsers (a great example being mobile touch <a class="indexterm" id="id623"/>devices, such as mobile phones) may not implement this pseudo-class, as there is no way to determine whether a user is hovering over an element.</p><p>Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;span&gt;Hover over me!&lt;/span&gt;</pre></div><p>The text in the span will be red in color when hovered over. Here is its CSS:</p><div class="informalexample"><pre class="programlisting">span:hover { color: #ff0000; }</pre></div></div></div></div><div class="section" title="The structural selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec160"/>The structural selectors</h2></div></div></div><p>These <a class="indexterm" id="id624"/>selectors allow you to select elements based on the document tree; this is very difficult or impossible to do with other selectors. This only selects nodes that are elements and does not include text that is not inside an element. The numbering is <code class="literal">1-</code> based indexing.</p></div><div class="section" title=":first-child"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec161"/>:first-child</h2></div></div></div><p>This targets an <a class="indexterm" id="id625"/>element that is the first child of another <a class="indexterm" id="id626"/>element:</p><div class="informalexample"><pre class="programlisting">:first-child</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec272"/>Description</h3></div></div></div><p>This is the same as <code class="literal">:nth-child(1)</code>. This selector is straightforward, the first child of the element type this is applied <a class="indexterm" id="id627"/>to will be selected.</p><p>Here is an example that will only select the first paragraph element. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;First paragraph.&lt;/p&gt;
&lt;p&gt;Second paragraph.&lt;/p&gt;</pre></div><p>Here is the CSS. This will change the text of the first paragraph red:</p><div class="informalexample"><pre class="programlisting">p:first-child { color: #ff0000; }</pre></div></div></div><div class="section" title=":first-of-type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec162"/>:first-of-type</h2></div></div></div><p>This <a class="indexterm" id="id628"/>targets the first element type that is a child of another <a class="indexterm" id="id629"/>element:</p><div class="informalexample"><pre class="programlisting">:first-of-type</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec273"/>Description</h3></div></div></div><p>The <code class="literal">:first-of-type</code> <a class="indexterm" id="id630"/>attribute is different from <code class="literal">:first-child</code> because it will not select the element unless it is the first child. This is the same as <code class="literal">:nth-of-type(1)</code>.</p><p>Here is an example that will target the first paragraph element even though it is not the first child. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;article&gt;
  &lt;h1&gt;Title of Article&lt;/h1&gt;
  &lt;p&gt;First paragraph.&lt;/p&gt;
  &lt;p&gt;Second paragraph.&lt;/p&gt;
&lt;/article&gt;</pre></div><p>Here is the CSS:</p><div class="informalexample"><pre class="programlisting">p:first-of-type { color: #ff0000; }</pre></div></div></div><div class="section" title=":last-child"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec163"/>:last-child</h2></div></div></div><p>This <a class="indexterm" id="id631"/>targets <a class="indexterm" id="id632"/>an element that is the last child of another element:</p><div class="informalexample"><pre class="programlisting">:last-child</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec274"/>Description</h3></div></div></div><p>This is the same <a class="indexterm" id="id633"/>as <code class="literal">:nth-last-child(1)</code>. This selector is straightforward, the last child of the element type this is applied to will be selected.</p><p>Here is an example that will only select the last paragraph element. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;First paragraph.&lt;/p&gt;
&lt;p&gt;Second paragraph.&lt;/p&gt;</pre></div><p>Here is the CSS. This will change the color of the second and first paragraph red. This selector works because even on the most basic of pages, the <code class="literal">p</code> element is a child of the <code class="literal">body</code> element:</p><div class="informalexample"><pre class="programlisting">p:last-child { color: #ff0000; }</pre></div></div></div><div class="section" title=":last-of-type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec164"/>:last-of-type</h2></div></div></div><p>This <a class="indexterm" id="id634"/>targets the last element type that is a child of another <a class="indexterm" id="id635"/>element:</p><div class="informalexample"><pre class="programlisting">:last-of-type</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec275"/>Description</h3></div></div></div><p>The <code class="literal">:last-of-type</code> attribute is different from <code class="literal">:last-child</code> because it will not select the element unless it is the first <code class="literal">last-child</code> attribute. This is the same as <code class="literal">:nth-last-of-type(1)</code>.</p><p>Here is an example that will <a class="indexterm" id="id636"/>target the last paragraph element. Here is its HTML:</p><div class="informalexample"><pre class="programlisting">&lt;article&gt;
  &lt;p&gt;First paragraph.&lt;/p&gt;
  &lt;p&gt;Second paragraph.&lt;/p&gt;
  &lt;a href="#"&gt;A link&lt;/a&gt;
&lt;/article&gt;</pre></div><p>Here is the CSS:</p><div class="informalexample"><pre class="programlisting">p:last-of-type { color: #ff0000; }</pre></div></div></div><div class="section" title=":nth-child()"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec165"/>:nth-child()</h2></div></div></div><p>This <a class="indexterm" id="id637"/>will divide all of the child elements and select them based on <a class="indexterm" id="id638"/>where they exist:</p><div class="informalexample"><pre class="programlisting">:nth-child(an+b)</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec276"/>Description</h3></div></div></div><p>This selector has a parameter that is very expressive in what you can select. This also means that it is more complex <a class="indexterm" id="id639"/>than most other CSS rules. Here is the technical specification of the parameter. This selects elements based on its preceding elements.</p><p>The parameter can be split into two parts: part <code class="literal">a</code> Part <code class="literal">b</code>. The part <code class="literal">a</code> is an integer that is followed by the character <code class="literal">n</code>. Part <code class="literal">b</code> has an optional plus or minus sign followed by an integer. The parameter also accepts two keywords: even and odd. Consider <span class="emphasis"><em>2n+1</em></span> for example.</p><p>This is much easier to understand when you look at it this way. The first part, <code class="literal">an</code>, is what the children are divided by. The <code class="literal">2n</code> value would make groups of two elements and <code class="literal">3n</code> value would make groups of three elements, and so on. The next part <code class="literal">+1</code> will then select that element in the grouping. <span class="emphasis"><em>2n+1</em></span> would select every odd item row because it is targeting the first element in every grouping of two elements. <span class="emphasis"><em>2n+0</em></span> or <span class="emphasis"><em>2n+2</em></span> would select every even item row. The first part, part <code class="literal">a</code>, can be omitted, and then it would just select the <span class="emphasis"><em>n</em></span>th child out of the entire group. For example, <span class="emphasis"><em>:nth-child(5)</em></span> would only select the fifth child and no other.</p><p>Table rows are a great example <a class="indexterm" id="id640"/>of using this selector, so we will target every odd row. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;First (will be red)&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Second&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Third (will be red)&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</pre></div><p>Here is the CSS:</p><div class="informalexample"><pre class="programlisting">tr:nth-child(2n+1) { color: #ff0000; }</pre></div></div></div><div class="section" title=":nth-last-child"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec166"/>:nth-last-child</h2></div></div></div><p>This <a class="indexterm" id="id641"/>will <a class="indexterm" id="id642"/>target the nth element from the end:</p><div class="informalexample"><pre class="programlisting">:nth-last-child(an+b)</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec277"/>Description</h3></div></div></div><p>This selector counts <a class="indexterm" id="id643"/>the succeeding elements. The counting logic is the same as it is for <code class="literal">:nth-child</code>.</p><p>Here is an example using a table. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;First&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Second&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Third&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Fourth&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</pre></div><p>The first CSS rule will change the color of every other row to red, but because it counts from the end, the first and third row will be selected. The second CSS rule will only target the last row:</p><div class="informalexample"><pre class="programlisting">tr:nth-last-child(even) { color: #ff0000; }
tr:nth-last-child(-n+1) { color: #ff0000; }</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec278"/>See also</h3></div></div></div><p>The previous section <code class="literal">:nth-child</code>.</p></div></div><div class="section" title=":nth-last-of-type and :nth-of-type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec167"/>:nth-last-of-type and :nth-of-type</h2></div></div></div><p>This <a class="indexterm" id="id644"/>selects elements based on their type <a class="indexterm" id="id645"/>and <a class="indexterm" id="id646"/>where they exist in the document:</p><div class="informalexample"><pre class="programlisting">:nth-last-of-type(an+b)
:nth-of-type(an+b)</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec279"/>Description</h3></div></div></div><p>Like all the other <span class="emphasis"><em>n</em></span>th selectors, this one uses the same logic as <code class="literal">:nth-child</code>. The difference nth-of-type being that <code class="literal">:nth-last-of-type</code> only groups by elements of the same type.</p><p>Here is an example <a class="indexterm" id="id647"/>that uses paragraphs and spans:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;First&lt;/p&gt;
&lt;span&gt;First Span&lt;/span&gt;
&lt;span&gt;Second Span&lt;/span&gt;
&lt;p&gt;Second&lt;/p&gt;
&lt;p&gt;Third&lt;/p&gt;</pre></div><p>Here is the CSS. This rule will only target the paragraphs and make the odd ones red:</p><div class="informalexample"><pre class="programlisting">p:nth-of-type(2n+1) { color: #ff0000; }</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec280"/>See also</h3></div></div></div><p>The previous section <code class="literal">:nth-child</code>.</p></div></div><div class="section" title=":only-child"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec168"/>:only-child</h2></div></div></div><p>This targets <a class="indexterm" id="id648"/>an <a class="indexterm" id="id649"/>element that has no siblings:</p><div class="informalexample"><pre class="programlisting">:only-child</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec281"/>Description</h3></div></div></div><p>This will match when the <code class="literal">:only-child</code> attribute is the only child of an element.</p><p>Here is an example with two <a class="indexterm" id="id650"/>tables, where one has multiple rows and the other has only one:</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;First&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Second&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Third&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Only&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</pre></div><p>Here is the CSS to <a class="indexterm" id="id651"/>target the only row in the second table:</p><div class="informalexample"><pre class="programlisting">tr:only-child { color: #ff0000; }</pre></div></div></div><div class="section" title=":only-of-type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec169"/>:only-of-type</h2></div></div></div><p>This targets <a class="indexterm" id="id652"/>when <a class="indexterm" id="id653"/>there is only one of this element:</p><div class="informalexample"><pre class="programlisting">:only-of-type</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec282"/>Description</h3></div></div></div><p>This will only match when <a class="indexterm" id="id654"/>there are no other siblings of the same type under a parent element.</p><p>Here is an example that uses arbitrary divisions to create a structure where one paragraph element is the only one of its type. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
  &lt;p&gt;Only p.&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Not the &lt;/p&gt;
    &lt;p&gt;only one.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Here is the CSS rule that will only target the first paragraph's element:</p><div class="informalexample"><pre class="programlisting">p:only-of-type { color: #ff0000; }</pre></div></div></div></div>
<div class="section" title="Validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Validation</h1></div></div></div><p>These are pseudo-classes that can be used to target the state of input elements and more.</p><div class="section" title=":checked"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec170"/>:checked</h2></div></div></div><p>This <a class="indexterm" id="id655"/>attribute targets the checked radio button or checkbox:</p><div class="informalexample"><pre class="programlisting">:checked</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec283"/>Description</h3></div></div></div><p>Any <a class="indexterm" id="id656"/>element that can be toggled on or off can use this selector. As of now, these are radio buttons, checkboxes, and options in a selective list.</p><p>Here is an example with a <code class="literal">checkbox</code> and a <code class="literal">label</code> value:</p><div class="informalexample"><pre class="programlisting">&lt;input type="checkbox" checked value="check-value" name="test" /&gt;
&lt;label for="test"&gt;Check me out&lt;/label&gt;</pre></div><p>Here is a <a class="indexterm" id="id657"/>CSS rule that will target the label only when the checkbox is checked:</p><div class="informalexample"><pre class="programlisting">input:checked + label { color: #ff0000; }</pre></div></div></div><div class="section" title=":default"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec171"/>:default</h2></div></div></div><p>This <a class="indexterm" id="id658"/>targets the default element from many similar elements:</p><div class="informalexample"><pre class="programlisting">:default</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec284"/>Description</h3></div></div></div><p>Use <a class="indexterm" id="id659"/>this selector to help define the default element from a group of elements. In a form, this would be the default button or the initially selected option from a <code class="literal">select</code> element.</p><p>Here is an example using a form:</p><div class="informalexample"><pre class="programlisting">&lt;form method="post"&gt;
  &lt;input type="submit" value="Submit" /&gt;
  &lt;input type="reset" value="Reset" /&gt;
&lt;/form&gt;</pre></div><p>Here is the CSS. This will only target the submit input as it is the default:</p><div class="informalexample"><pre class="programlisting">:default { color: #ff0000; }</pre></div></div></div><div class="section" title=":disabled and :enabled"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec172"/>:disabled and :enabled</h2></div></div></div><p>These <a class="indexterm" id="id660"/>will <a class="indexterm" id="id661"/>target elements based on their enabled state:</p><div class="informalexample"><pre class="programlisting">:disabled
:enabled</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec285"/>Description</h3></div></div></div><p>There is a <a class="indexterm" id="id662"/>disabled attribute that is available on interactive elements. Using <code class="literal">:disabled</code> will target elements where the <code class="literal">:disabled</code> attribute is present and <code class="literal">:enabled</code> <a class="indexterm" id="id663"/>will do the opposite.</p><p>Here is some HTML with two inputs out of which one is disabled:</p><div class="informalexample"><pre class="programlisting">&lt;input type="submit" value="Submit" disabled/&gt;
&lt;input type="reset" value="Reset" /&gt;</pre></div><p>Here is the CSS. The disabled input will have its text color set as red and the other as green:</p><div class="informalexample"><pre class="programlisting">input:disabled { color: #ff0000; }
input:enabled { color: #00ff00; }</pre></div></div></div><div class="section" title=":empty"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec173"/>:empty</h2></div></div></div><p>This targets <a class="indexterm" id="id664"/>elements that have no children:</p><div class="informalexample"><pre class="programlisting">:empty</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec286"/>Description</h3></div></div></div><p>This targets nodes <a class="indexterm" id="id665"/>without any children. Children can be any other element including text nodes. This means that even one space will count as a child. However, comments will not count as children.</p><p>Here is an example with three <code class="literal">div</code> tags. The first is empty, the next has text, and the final one has one space in it. Here is the HTML:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Not Empty&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</pre></div><p>Here is the CSS. Only the first div will have a red background:</p><div class="informalexample"><pre class="programlisting">div { height: 100px; width: 100px; background-color: #00ff00; }
div:empty { background-color: #ff0000; }</pre></div></div></div><div class="section" title=":in-range and :out-of-range"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec174"/>:in-range and :out-of-range</h2></div></div></div><p>These <a class="indexterm" id="id666"/>selectors <a class="indexterm" id="id667"/>target elements that have a range limitation:</p><div class="informalexample"><pre class="programlisting">:in-range
:out-of-range</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec287"/>Description</h3></div></div></div><p>Some elements now have range limitations that can be applied. When the value is outside of this range, the <code class="literal">:out-of-range</code> selector will target it, and when the value is within the range, <code class="literal">:in-range</code> will target it.</p><p>Here is an <a class="indexterm" id="id668"/>example that uses an input that is the number type:</p><div class="informalexample"><pre class="programlisting">&lt;input type="number" min="1" max="10" value="11" /&gt;
&lt;input type="number" min="1" max="10" value="5" /&gt;</pre></div><p>Here is the CSS. The <a class="indexterm" id="id669"/>first input will have red text because it is beyond the maximum range and the second will have green text:</p><div class="informalexample"><pre class="programlisting">:in-range {color: #00ff00; }
:out-of-range { color: #ff0000; }</pre></div></div></div><div class="section" title=":invalid and :valid"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec175"/>:invalid and :valid</h2></div></div></div><p>The <code class="literal">:invalid</code> <a class="indexterm" id="id670"/>and <code class="literal">:valid</code> <a class="indexterm" id="id671"/>attribute targets an element based on the validity of the data:</p><div class="informalexample"><pre class="programlisting">:invalid
:valid</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec288"/>Description</h3></div></div></div><p>Certain <a class="indexterm" id="id672"/>input elements have data validity, a great example being the e-mail element. The selectors select based on whether the data is valid or not. You should note that <a class="indexterm" id="id673"/>some elements are always valid, for example, a text input, and some elements will never be targeted by these selectors, for example, a <code class="literal">div</code> tag.</p><p>Here is an example with an e-mail input:</p><div class="informalexample"><pre class="programlisting">&lt;input type="email" value="test@test.com" /&gt;
&lt;input type="email" value="not a valid email" /&gt;</pre></div><p>Here is the CSS. The first input will be green as it is valid and the other will be red:</p><div class="informalexample"><pre class="programlisting">:valid {color: #00ff00; }
:invalid { color: #ff0000; }</pre></div></div></div><div class="section" title=":not or negation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec176"/>:not or negation</h2></div></div></div><p>The <code class="literal">:not</code> attribute <a class="indexterm" id="id674"/>negates a selector:</p><div class="informalexample"><pre class="programlisting">:not(selector)</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec289"/>Description</h3></div></div></div><p>The <code class="literal">:not</code> parameter <a class="indexterm" id="id675"/>must be a simple selector and will target the elements where the <code class="literal">:not</code> parameter is not <code class="literal">true</code>. This selector does not add to specificity of the rule.</p><p>Here is an example using paragraphs:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Targeted Element&lt;/p&gt;
&lt;p class="not-me"&gt;Non targeted element&lt;/p&gt;</pre></div><p>Here is the CSS. Only the first paragraph will be targeted:</p><div class="informalexample"><pre class="programlisting">p:not(.not-me) {color: #ff0000; }</pre></div></div></div><div class="section" title=":optional and :required"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec177"/>:optional and :required</h2></div></div></div><p>The <code class="literal">:optional</code> <a class="indexterm" id="id676"/>and <code class="literal">:required</code> attributes target elements that are either <a class="indexterm" id="id677"/>optional or required, respectively.</p><div class="informalexample"><pre class="programlisting">:optional
:required</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec290"/>Description</h3></div></div></div><p>This is used for <a class="indexterm" id="id678"/>any input element that is required or optional.</p><p>Here is an example <a class="indexterm" id="id679"/>that has two inputs—one that is required and one that is not:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" value="Required" required /&gt;
&lt;input type="text" value="Optional" /&gt;</pre></div><p>Here is the CSS. The required input will have red text and the optional input will have green text:</p><div class="informalexample"><pre class="programlisting">:required { color: #ff0000; }
:optional { color: #00ff00; }</pre></div></div></div><div class="section" title=":lang()"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec178"/>:lang()</h2></div></div></div><p>The <code class="literal">:lang()</code> attribute <a class="indexterm" id="id680"/>targets based on the language:</p><div class="informalexample"><pre class="programlisting">:lang(language)</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec291"/>Description</h3></div></div></div><p>This selector works <a class="indexterm" id="id681"/>differently to the attribute selector; in that, this will target all elements that are in a specific language even if they are not explicitly defined. The attribute selector will only target elements that have a <code class="literal">lang</code> attribute.</p><p>Here is an example with a <code class="literal">span</code> element that does not have a <code class="literal">lang</code> attribute, but it is the child of the body which does:</p><div class="informalexample"><pre class="programlisting">&lt;body lang="en-us"&gt;
&lt;span&gt;This is English.&lt;/span&gt;
&lt;/body&gt;</pre></div><p>Here is the CSS. The first rule will match the element, but the second will not match anything:</p><div class="informalexample"><pre class="programlisting">:lang(en) { color: #ff0000; }
span[lang|=en] { color: #00ff00; }</pre></div></div></div></div>
<div class="section" title="Pseudo-elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Pseudo-elements</h1></div></div></div><p>These are <a class="indexterm" id="id682"/>selectors that go beyond what is specified in the document. The selectors select things that may not even be elements in the document. Pseudo-elements are not considered part of a simple selector. This means that you cannot use a pseudo-element as part of the <code class="literal">:not()</code> selector. Finally, only one pseudo-element can be present per selector.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Note that all of the pseudo-elements start with a double colon (<code class="literal">::</code>). This was introduced in CSS3 to help differentiate between pseudo-classes that have a single colon (<code class="literal">:</code>). This is important because in CSS2, pseudo-elements only had the single colon. For the most part, you should use the double colon.</p></div></div><div class="section" title="::before and ::after"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec179"/>::before and ::after</h2></div></div></div><p>These are used <a class="indexterm" id="id683"/>to insert generated content before <a class="indexterm" id="id684"/>or after the selected element:</p><div class="informalexample"><pre class="programlisting">::before
::after e</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec292"/>Description</h3></div></div></div><p>This will insert content into the document based on the selector. Whether the content is placed before or after the element targeted <a class="indexterm" id="id685"/>depends on the pseudo-element used. Refer to the <span class="emphasis"><em>Generated content</em></span> section to see what you can insert.</p><p>Here is an example that uses both <code class="literal">::before</code> and <code class="literal">::after</code>. This will create a turkey sandwich. Here is the HTML.</p><div class="informalexample"><pre class="programlisting">&lt;p class="sandwich"&gt;Turkey&lt;/p&gt;</pre></div><p>Here is the CSS that will put a slice of bread before and after the turkey:</p><div class="informalexample"><pre class="programlisting">p.sandwich::before, p.sandwich::after 
{ content: ":Slice of Bread:"; }</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec293"/>See also</h3></div></div></div><p>
<span class="emphasis"><em>Generated content</em></span>
</p></div></div><div class="section" title="::first-letter"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec180"/>::first-letter</h2></div></div></div><p>This <a class="indexterm" id="id686"/>targets <a class="indexterm" id="id687"/>the first letter of an element:</p><div class="informalexample"><pre class="programlisting">::first-letter</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec294"/>Description</h3></div></div></div><p>This will select the <a class="indexterm" id="id688"/>first letter of an element as long as it does not have any other content before it, for example an <code class="literal">img</code> element before a character would make <code class="literal">::first-letter</code> not select the first character. Any punctuation that either precedes or follows the first letter would be included with the first letter. This will select any character, including not just letters but also numbers.</p><p>This only applies to block-like containers such as block, <code class="literal">list-item</code>, <code class="literal">table-cell</code>, <code class="literal">table-caption</code>, and <code class="literal">inline-block</code> elements.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">::first-letter</code> pseudo-element will only match if the first letter is on the first formatted line. If there is a line break before the first letter appears, it will not be selected.</p><p>Here is an example, which will not select the first letter:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;&lt;br /&gt;First letter&lt;/p&gt;</pre></div><p>Here is the CSS:</p><div class="informalexample"><pre class="programlisting">p::first-letter { font-size: 2em; }</pre></div></div></div><p>Here is an <a class="indexterm" id="id689"/>example:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;This is a long line of text that may or may not be broken up across lines.&lt;/p&gt;</pre></div><p>Here is the CSS. The T in This will be two times the font size of all the other characters:</p><div class="informalexample"><pre class="programlisting">p::first-letter { font-size: 2em; }</pre></div></div></div><div class="section" title="::first-line"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec181"/>::first-line</h2></div></div></div><p>The <a class="indexterm" id="id690"/>
<code class="literal">::first-line</code> <a class="indexterm" id="id691"/>attribute targets the first line of an element:</p><div class="informalexample"><pre class="programlisting">::first-line</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec295"/>Description</h3></div></div></div><p>This will <a class="indexterm" id="id692"/>target the first formatted line of a block-like container such as a <code class="literal">block box</code>, <code class="literal">inline-block</code>, <code class="literal">table-caption</code>, or <code class="literal">table-cell</code>.</p><p>Here is an <a class="indexterm" id="id693"/>example, with the following HTML:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;This is a long line of text that may or may not be broken up across lines based on the width of the page and the width of the element it is in.&lt;/p&gt;
&lt;p&gt;This is the entire first line.&lt;/p&gt;</pre></div><p>Here is the CSS. This will make the first line, whatever it may be, red:</p><div class="informalexample"><pre class="programlisting">p::first-line { color: #ff0000; }</pre></div></div></div><div class="section" title="::selection"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec182"/>::selection</h2></div></div></div><p>This targets <a class="indexterm" id="id694"/>text <a class="indexterm" id="id695"/>highlighted by the user:</p><div class="informalexample"><pre class="programlisting">::selection</pre></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec296"/>Description</h3></div></div></div><p>This pseudo-element allows you to style any text that is highlighted by the user. This pseudo-element does not exist in CSS3, but it is part of the next version. Most browsers will still honor this <a class="indexterm" id="id696"/>pseudo-element.</p><p>Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Highlight this to text.&lt;/p&gt;</pre></div><p>Here is the CSS. When the text is selected, the text will be white on a red background:</p><div class="informalexample"><pre class="programlisting">::selection { color: #ffffff; background: #ff0000; }</pre></div></div></div></div>
<div class="section" title="Generated content"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Generated content</h1></div></div></div><p>This is not a selector, but is used with the pseudo-elements <code class="literal">::before</code> and <code class="literal">::after</code>. There are only <a class="indexterm" id="id697"/>certain types of content that you can generate. Here is a rundown.</p><div class="section" title="content"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec183"/>content</h2></div></div></div><p>This is the content that <a class="indexterm" id="id698"/>will be placed either before or after <a class="indexterm" id="id699"/>elements:</p><div class="informalexample"><pre class="programlisting">content(none, &lt;string&gt;, &lt;uri&gt;, &lt;counter&gt;, open-quote, close-quote, no-open-quote, no-close-quote, attr(x))</pre></div><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec297"/>Parameters</h3></div></div></div><p>Following are the <a class="indexterm" id="id700"/>parameters and their description:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">none</code>: This parameter does not generate any content</li><li class="listitem" style="list-style-type: disc"><code class="literal">normal</code>: This is the default parameter and is the same as none</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;string&gt;</code>: This is any string text content</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;uri&gt;</code>: This will map to a resource, for example, an image</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;counter&gt;</code>: This can be used as either the <code class="literal">counter()</code> or <code class="literal">counters()</code> function to put a counter before or after each element</li><li class="listitem" style="list-style-type: disc"><code class="literal">open-quote</code> and <code class="literal">close-quote</code>: This is used with the quotes generated content property</li><li class="listitem" style="list-style-type: disc"><code class="literal">no-open-quote</code> and <code class="literal">no-close-quote</code>: This does not add content, but increments or decrements the nesting level of quotes</li><li class="listitem" style="list-style-type: disc"><code class="literal">attr(x)</code>:This <a class="indexterm" id="id701"/>returns the value of the attribute of the element this is targeting</li></ul></div></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec298"/>Description</h3></div></div></div><p>This property is used to add content to the document. The output is controlled by the value used. The values can be combined to create more complex content.</p><p>A new line can be inserted <a class="indexterm" id="id702"/>with the characters <code class="literal">\A</code>. Just remember that HTML will ignore a line break by default.</p><p>Here are some examples. These will demonstrate how to use many of the content values:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;First&lt;/h1&gt;
&lt;h1&gt;Second&lt;/h1&gt;
&lt;h1 class="test"&gt;Attribute&lt;/h1&gt;
&lt;h2&gt;Line Break&lt;/h2&gt;
&lt;blockquote&gt;Don't quote me on this.&lt;/blockquote&gt;</pre></div><p>Here is the CSS. The <code class="literal">h1</code> elements will have the word "<code class="literal">chapter</code>" along with a number before each. The <code class="literal">h2</code> element will have a line break in its content. Finally, the <code class="literal">blockquote</code> will have an opening quote and a closing quote:</p><div class="informalexample"><pre class="programlisting">h1 { counter-increment: chapter; }
h1::before { content: "Chapter" counter(chapter) ": " attr(class) ; }
h2::before { content: "New\A Line"; white-space: pre; }
blockquote::before { content: open-quote; }
blockquote::after { content: close-quote; }</pre></div></div></div><div class="section" title="Quotation marks"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec184"/>Quotation marks</h2></div></div></div><p>Quotation <a class="indexterm" id="id703"/>marks specify which characters are used as <a class="indexterm" id="id704"/>open and close quotes:</p><div class="informalexample"><pre class="programlisting">quotes: [&lt;string&gt; &lt;string&gt;]+</pre></div><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec299"/>Parameters</h3></div></div></div><p>
<code class="literal">&lt;string&gt; &lt;string&gt;</code>: These <a class="indexterm" id="id705"/>are pairs of characters that will represent an open and close quote. You can use this multiple times to create levels of quotes.</p></div><div class="section" title="Description"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec300"/>Description</h3></div></div></div><p>We can use this property <a class="indexterm" id="id706"/>to set which quotation marks are used.</p><p>Here is an example that has a nested quote:</p><div class="informalexample"><pre class="programlisting">&lt;blockquote&gt;Don't quote me &lt;blockquote&gt;on&lt;/blockquote&gt; this.&lt;/blockquote&gt;</pre></div><p>The quotation marks are completely arbitrary. Here is the CSS:</p><div class="informalexample"><pre class="programlisting">blockquote { quotes: ":" "!" "&amp;" "*"; }</pre></div></div></div></div></body></html>