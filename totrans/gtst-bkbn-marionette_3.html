<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Marionette View Types and Their Use"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Marionette View Types and Their Use</h1></div></div></div><p>In the previous chapter, we learned about components that help us provide a structure to our application; however, none of these components interacted with the DOM. This responsibility belongs to the views in Backbone development; however, the interaction and manipulation of the DOM can quickly become complicated inside our views. With the intention of having cleaner and meaningful objects to manipulate, the DOM Marionette introduces a powerful set of views. The following is a description of each one of those views provided in the official documentation at <a class="ulink" href="https://github.com/marionettejs/backbone.marionette">https://github.com/marionettejs/backbone.marionette</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.ItemView</code>: This <a id="id35" class="indexterm"/>is the view that renders a single model</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.CollectionView</code>: <a id="id36" class="indexterm"/>This is the view that iterates over a collection and renders the individual <code class="literal">ItemView</code> instances for each model</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.CompositeView</code>: This is <a id="id37" class="indexterm"/>the collection view and item view for rendering leaf-branch/composite model hierarchies</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.Layout</code>: This <a id="id38" class="indexterm"/>is the view that renders a layout and creates region managers to manage areas within it</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.View</code>: This is the base <a id="id39" class="indexterm"/>view type that other Marionette views extend from (not intended to be used directly)</li></ul></div><p>In this chapter, we will learn the intention behind each one of them and how to start using them.</p><div class="section" title="Marionette.View and Marionette.ItemView"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Marionette.View and Marionette.ItemView</h1></div></div></div><p>The <code class="literal">Marionette.View</code> extends <a id="id40" class="indexterm"/>the <code class="literal">Backbone.View</code>, and it's important to remember this, because all the knowledge that we already <a id="id41" class="indexterm"/>have on creating a view will be useful while working with these new set of views of Marionette.</p><p>Each of them aims to provide a specific out of the box functionality so that you spend less time focusing on the glue code needed to make things work, and more time on things that are related to the needs of your application. This allows you to focus all your attention on the specific logic of your application.</p><p>We will start by describing the <code class="literal">Marionette.View</code> part of Marionette, as all of the other views extend from it; the reason we do this is because this view provides a very useful functionality. But it's important to notice that this view is not intended to be used directly. As it is the base view from which all the other views inherit from, it is an excellent place to contain some of the glue code that we just talked about.</p><p>A good example of that functionality is the <a id="id42" class="indexterm"/>
<code class="literal">close</code> method, which will be responsible for removing <code class="literal">.el</code> from DOM. This method will also take care of calling unbind to all your events, thus avoiding the problem called <a id="id43" class="indexterm"/>Zombie views. This an issue that you can have if you don't do this carefully in a regular Backbone view, where new instantiations of previously closed fire events are present. These events remain bound to the HTML elements used in the view. These are now present again in the DOM now that the view has been re-rendered, and during the recreation of the view, new event listeners are attached to these HTML elements.</p><p>From the documentation of the <code class="literal">Marionette.View</code>, we exactly know what the <code class="literal">close</code> method does.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It calls an <code class="literal">onBeforeClose</code> <a id="id44" class="indexterm"/>event on the view, if one is provided</li><li class="listitem" style="list-style-type: disc">It calls an <code class="literal">onClose</code> event on the view, if one is provided</li><li class="listitem" style="list-style-type: disc">It unbinds all custom view events</li><li class="listitem" style="list-style-type: disc">It unbinds all DOM events</li><li class="listitem" style="list-style-type: disc">It removes <a id="id45" class="indexterm"/><code class="literal">this.el</code> from the DOM</li><li class="listitem" style="list-style-type: disc">It unbinds all <a id="id46" class="indexterm"/><code class="literal">listenTo</code> events</li></ul></div><p>The link to the official documentation of <a id="id47" class="indexterm"/>the <code class="literal">Marionette.View</code> object is <a class="ulink" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md">https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md</a>.</p><p>It's important to mention that the third point, <span class="emphasis"><em>unbind all custom view events</em></span>, will unbind events created using the <code class="literal">modelEvents</code> hash, those created on the events hash, and events created via <a id="id48" class="indexterm"/>
<code class="literal">this.listenTo</code>.</p><p>As the <code class="literal">close</code> method is already <a id="id49" class="indexterm"/>provided and implemented, you don't need to perform the unbind and remove previously listed tasks. While most of the time this would be enough, at times, one of your views will need you to perform extra work in order to properly close it; in this case, two events will be fired at the same time to close a view.</p><p>The event <a id="id50" class="indexterm"/>
<code class="literal">onBeforeClose</code>, as the name indicates, will be fired just before the <code class="literal">close</code> method. It will call a function of the same name, <code class="literal">onBeforeClose</code>, where we can add the code that needs to be executed at this point.</p><div class="informalexample"><pre class="programlisting">function : onBeforeClose () {
  //  code to be run before closing the view
}</pre></div><p>The second event will be <code class="literal">onClose</code>, <a id="id51" class="indexterm"/>which will be fired after the <code class="literal">close</code> method so that the <code class="literal">.el</code> of the view won't be present anymore and all the unbind tasks will have been performed.</p><div class="informalexample"><pre class="programlisting"> function : onClose () {
  //  code to be run after closing the view
 }</pre></div><p>One of the core ideas behind Marionette is to reduce the boilerplate code that you have to write when building apps with Backbone. A perfect example of which is the <code class="literal">render</code> method that you have to implement in every Backbone view, and the code there is pretty much the same in each of your views. Load the template with the underscore <code class="literal">_.template</code> function and then <a id="id52" class="indexterm"/>pass the model converted to JSON to the template.</p><p>The following is an example of repetitive code needed to render a view in Backbone:</p><div class="informalexample"><pre class="programlisting">render : function () {
  var template = $( '#mytemplate' ).html(); 
  var templateFunction = _.template( template ); 
  var modelToJSON = this.model.toJSON();
  var result = templateFunction(modelToJSON); 
  var myElement = $( '#MyElement' ); 
  myElement.html( result );
}</pre></div><p>As Marionette defining a <code class="literal">render</code> <a id="id53" class="indexterm"/>function is no longer required, just like the <code class="literal">close</code> method, the <a id="id54" class="indexterm"/>preceding code will be called for you behind the scenes. In order to render a view, we just need to declare it with a template property set.</p><div class="informalexample"><pre class="programlisting">var SampleView = Backbone.Marionette.ItemView.extend({
  template : '#sample-template'
});</pre></div><p>Next, we just create a Backbone <a id="id55" class="indexterm"/>model, and we pass it to the <code class="literal">ItemView</code> constructor.</p><div class="informalexample"><pre class="programlisting">var SampleModel = Backbone.Model.extend({
  defaults : {
    value1 : "A random Value",
    value2 : "Another Random Value"
  }
})
var sampleModel = new SampleModel();
var sampleView = new SampleView({model:sampleModel);</pre></div><p>And then the only thing left is to call the <a id="id56" class="indexterm"/>
<code class="literal">render</code> function.</p><div class="informalexample"><pre class="programlisting">sampleView.render();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>If you want to see it running, please go through this <a id="id57" class="indexterm"/>JSFiddle that illustrates the previous code:</p><p>
<a class="ulink" href="http://jsfiddle.net/rayweb_on/VS9hA/">http://jsfiddle.net/rayweb_on/VS9hA/</a>
</p></div></div><p>One thing to note is that we just needed one line to specify the template, and Marionette did the rest by rendering our view with the specified template. Notice that in this example, we used the <code class="literal">ItemView</code> <a id="id58" class="indexterm"/>constructor; we should not use <code class="literal">Marionette.View</code> directly, as it does not have many functionalities of its own. It just serves as the base for other views.</p><p>So some of the following examples of the functionalities provided by <code class="literal">Marionette.View</code> will be demonstrated using <code class="literal">ItemView</code>, as this view inherits all of these functionalities through extension.</p><p>As we saw in the previous example, <code class="literal">ItemView</code> works perfectly for rendering a single model using a template, but what about rendering a collection of models?</p><p>If you just need to render, for example, a list of books or categories, you still can use <code class="literal">ItemView</code>. To accomplish this, the template that you would assign to <code class="literal">ItemView</code> must know how to handle the creation of the DOM to properly display that list of items.</p><p>Let's render a list of books.</p><p>The Backbone model will have <a id="id59" class="indexterm"/>two properties: the book name and the book ID. We just want to create a list of links using the book name as the value to be displayed; the ID of the book will be used to create a link to see the specific book.</p><p>First, let's create the book Backbone model for this example and its collection:</p><div class="informalexample"><pre class="programlisting">var BookModel = Backbone.Model.extend({
  defaults : {
    id : "1",
    name : "First",
  }
});

var BookCollection = Backbone.Collection.extend({
  model : BookModel
});</pre></div><p>Now let's instantiate the collection and add three models to it:</p><div class="informalexample"><pre class="programlisting">var bookModel = new BookModel();
var bookModel2 = new BookModel({id:"2",name:"second"});
var bookModel3 = new BookModel({id:"3",name:"third"});
var bookCollection = new BookCollection();
bookCollection.add(bookModel);
bookCollection.add(bookModel2);
bookCollection.add(bookModel3);</pre></div><p>In our HTML, let's create the template to be used in this view; the template should look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;script id="books-template" type="text/html"&gt;
  &lt;ul&gt;
    &lt;% _.each(items, function(item){ %&gt;
    &lt;li&gt;&lt;a href="book/'+&lt;%= item.id %&gt; +"&gt;&lt;%= item.name %&gt; &lt;/li&gt;
    &lt;% }); %&gt;
  &lt;/ul&gt;
&lt;/script&gt;</pre></div><p>Now we could render the book list using the following code snippet:</p><div class="informalexample"><pre class="programlisting">var BookListView = Marionette.ItemView.extend({
  template: "#books-template"
});

var view = new BookListView ({
  collection: bookCollection
});
view.Render();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>If you want to see it in action, go to the working code in JSFiddle at <a class="ulink" href="http://jsfiddle.net/rayweb_on/8QAgQ/">http://jsfiddle.net/rayweb_on/8QAgQ/</a>.</p></div></div><p>The previous code would produce an unordered list of books with links to the specific book. Again, we gained the benefit of writing very little code once again, as we didn't need to specify the <code class="literal">Render</code> <a id="id60" class="indexterm"/>function, which could be misleading, because the <code class="literal">ItemView</code> is perfectly capable of rendering a model or a collection. Whether to use <code class="literal">CollectionView</code> or <code class="literal">ItemView</code> will depend on what we are trying to accomplish. If we need a set of individual views with its own functionality, <a id="id61" class="indexterm"/>
<code class="literal">CollectionView</code> is the right choice, as we will see when we get to the point of reviewing it. But if we just need to render the values of a collection, <code class="literal">ItemView</code> would be the perfect choice.</p><div class="section" title="Handling events in the views"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Handling events in the views</h2></div></div></div><p>To keep track of <a id="id62" class="indexterm"/>model events or collection events, we must write the following code snippet <a id="id63" class="indexterm"/>on a regular Backbone view:</p><div class="informalexample"><pre class="programlisting">this.listenTo(this.model, "change:title", this.titleChanged);
this.listenTo(this.collection, "add", this.collectionChanged);</pre></div><p>To start these events, we use the following handler functions:</p><div class="informalexample"><pre class="programlisting">titleChanged: function(model, value){alert("changed");},
collectionChanged: function(model, value){alert("added");},</pre></div><p>This still works fine in Marionette, but we can accomplish the same thing by declaring these events using the following configuration hash:</p><div class="informalexample"><pre class="programlisting">modelEvents: {
  "change:title": "titleChanged" 
},
collectionEvents: {
  "add": "collectionChanged" 
},</pre></div><p>This will give us exactly the same result, but the configuration hash is very convenient as we can keep adding events to our model or collection, and the code is cleaner and very easy to follow.</p><p>The <code class="literal">modelEvents</code> <a id="id64" class="indexterm"/>and <a id="id65" class="indexterm"/>
<code class="literal">collectionEvents</code> are not the only configuration hash sets that we have available in each one of the Marionette views; the UI configuration hash is also available. It may be the case that one of the DOM elements on your view will be used many times to read its value, and doing this using jQuery can not be optimal in terms of performance. Also, we would have the <a id="id66" class="indexterm"/>jQuery reference in several places, repeating ourselves and making our code less DRY.</p><p>Inside a Backbone view, we can define a <a id="id67" class="indexterm"/>set of events that will be fired once an action is taken in the DOM; for instance, we pass the function that we want to handle in this event at the click of a button.</p><div class="informalexample"><pre class="programlisting">events : { 
  "click #button2" : "updateValue" 
},</pre></div><p>This will invoke the <code class="literal">updateValue</code> <a id="id68" class="indexterm"/>function once we click on <code class="literal">button2</code>. This works fine, but what about calling a method that is not inside the view?</p><p>To accomplish this, Marionette provides the <code class="literal">triggers</code> functionality that will fire events which can be listened to outside of your view. To declare a <code class="literal">trigger</code>, we can use the same syntax used in the <code class="literal">events</code> object as follows:</p><div class="informalexample"><pre class="programlisting">triggers : { "click #button1": "trigger:alert"},</pre></div><p>And then, we can listen to that event somewhere else using the following code:</p><div class="informalexample"><pre class="programlisting">sampleView.on("trigger:alert", function(args){
  alert(args.model.get("value2"));
});</pre></div><p>In the previous code, we used the model to alert and display the value of the property, <code class="literal">value2</code>.</p><p>The <code class="literal">args</code> parameter received by the function will contain objects that you can use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The view that fired the trigger</li><li class="listitem" style="list-style-type: disc">The Backbone model or collection of that view</li></ul></div></div><div class="section" title="UI and templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>UI and templates</h2></div></div></div><p>While working with a view, <a id="id69" class="indexterm"/>you will need a reference to a particular HTML element through jQuery in more than one place in your view. This means you will make a reference to a button during initialization and in few other methods of the view. To avoid <a id="id70" class="indexterm"/>having the jQuery selector duplicated on each of these methods, you can map that UI element in a hash so that the selector is preserved. If you need to change it, the change will be done in a single place.</p><p>To create this mapping of UI elements, we need to add the following declaration:</p><div class="informalexample"><pre class="programlisting">ui: {
  quantity: "#quantity"
  saveButton : "#Save"
},</pre></div><p>And to make use of these mapper UI elements, we just need to refer them inside any function by the name given in the configuration.</p><div class="informalexample"><pre class="programlisting">validateQuantity: function() {
  if (this.ui.quantity.val() &gt; 0 {
    this.ui.saveButton.addClass('active');
  }
}</pre></div><p>There will be times when you need to pass a different template to your view. To do this in Marionette, we remove the template declaration and instead add a function called <code class="literal">getTemplate</code>.</p><p>The following code snippet would illustrate the use of this function:</p><div class="informalexample"><pre class="programlisting">getTemplate: function(){
  if (this.model.get("foo"){
    return "#sample-template";
  }else {     
    return "#a-different-template";
  }
},</pre></div><p>In this case, we check the existence of the property <code class="literal">foo</code>; if it's not present, we use a different template and that will be it. You don't need to specify the <code class="literal">render</code> function because it will work the same way as declaring a template variable as seen in one of the previous examples.</p><p>If you want to learn more about all the concepts that we have discussed so far, please refer to the JSFiddle link <a class="ulink" href="http://jsfiddle.net/rayweb_on/NaHQS/">http://jsfiddle.net/rayweb_on/NaHQS/</a>.</p><p>If you find yourself needing to make calculations involving a complicated process while rendering a value, you can make use of <code class="literal">templeteHelpers</code> that are functions contained in an object called <a id="id71" class="indexterm"/>
<code class="literal">templateHelpers</code>. Let's look at an example that will illustrate its use better.</p><p>Suppose we need to show the value of a book but are offering a discount that we need to calculate, use the following code:</p><div class="informalexample"><pre class="programlisting">var PriceView = Backbone.Marionette.ItemView.extend({
  template: "#price-template",

  templateHelpers: {
    calculatePrice: function(){
    // logic to calculate the price goes here
      return price; 
    }
  }
});</pre></div><p>As you can see the in the previous code, we <a id="id72" class="indexterm"/>declared an object <code class="literal">literal</code> that will contain functions that can be called from the templates.</p><div class="informalexample"><pre class="programlisting">&lt;script id="my-template" type="text/html"&gt;
  Take this book with you for just : &lt;%= calculatePrice () %&gt;
&lt;/script&gt;</pre></div></div><div class="section" title="Marionette.CollectionView"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Marionette.CollectionView</h2></div></div></div><p>Rendering a list of things like <a id="id73" class="indexterm"/>books inside one view is possible, but we want to be able to interact with each item. The solution for this will be to create a view one-by-one with the help of a loop. But Marionette solves this in a very elegant way by introducing the concept of <code class="literal">CollectionView</code> that will render a child view for each of the elements that we have in the collection we want to display.</p><p>A good example to put into practice could be to list the books by category and create a Collection view. This is incredible easy.</p><p>First, you need to define how each of your items should be displayed; this means how each item will be transformed in a view.</p><p>For our categories example, we want each item to be a list <code class="literal">&lt;li&gt;</code> element and part of our collection; the <code class="literal">&lt;ul&gt;</code> list will contain each category view.</p><p>We first declare <code class="literal">ItemView</code> as follows:</p><div class="informalexample"><pre class="programlisting">var CategoryView = Backbone.Marionette.ItemView.extend({
        tagName : 'li',
        template: "#categoryTemplate",
});</pre></div><p>Then we declare <code class="literal">CollectionView</code>, which specifies the view item to use.</p><div class="informalexample"><pre class="programlisting">var CategoriesView = Backbone.Marionette.CollectionView.extend({
        tagName : 'ul',
        className : 'unstyled',
        itemView: CategoryView
}); </pre></div><p>A good thing to notice is that even when we are using Marionette views, we are still able to use the standard properties that Backbone views offer, such as <code class="literal">tagName</code> and <code class="literal">ClassName</code>.</p><p>Finally, we create a collection and we instantiate <code class="literal">CollectionView</code> by passing the collection as a parameter.</p><div class="informalexample"><pre class="programlisting">var categoriesView = new CategoriesView({collection:categories);
categoriesView.render();</pre></div><p>And that's it. Simple huh?</p><p>The advantage of using this view is that <a id="id74" class="indexterm"/>it will render a view for each item, and it can have a lot of functionality; we can control all those views in the <code class="literal">CollectionView</code> <a id="id75" class="indexterm"/>that serves as a container.</p><p>You can see it in action at <a class="ulink" href="http://jsfiddle.net/rayweb_on/7usdJ/">http://jsfiddle.net/rayweb_on/7usdJ/</a>.</p></div><div class="section" title="Marionette.CompositeView"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Marionette.CompositeView</h2></div></div></div><p>The <code class="literal">Marionette.Composite</code> view <a id="id76" class="indexterm"/>offers the possibility of not only rendering a model or collection models, but also the possibility of rendering both a model and a collection. That's why this view fits perfectly in our BookStore website. We will be adding single items to the shopping cart, books in this case, and we will be storing these books in a collection. But we need to calculate the subtotal of the order, show the calculated tax, and an order total; all of these properties will be part of our <code class="literal">totals</code> model that we will be displaying along with the ordered books.</p><p>But there is a problem. What should we display in the order region when there are no items added? Well, in the <code class="literal">CompositeView</code> and the <code class="literal">CollectionView</code>, we can set an <code class="literal">emptyView</code> property, which will be a view to show in case there are no models in the collection. Once we add a model, we can then render the item and the <code class="literal">totals</code> model.</p><p>Perhaps at this point, you may think that you lost control over your render functionality, and there will be cases where you need to do things to modify your HTML. Well, in that scenario, you should use the <a id="id77" class="indexterm"/>
<code class="literal">onRender()</code> function, which is a very helpful method that will allow you to manipulate the DOM just after your <code class="literal">render</code> method was called.</p><p>Finally, we would like to set a template with some headers. These headers are not part of an <code class="literal">ItemView</code>, so how can we display it?</p><p>Let's have a look at part of the code <a id="id78" class="indexterm"/>snippet that explains how each part solves our needs.</p><div class="informalexample"><pre class="programlisting">var OrderListView = Backbone.Marionette.CompositeView.extend({
        tagName: "table",
        template: "#orderGrid",
        itemView: CartApp.OrderItemView,
        emptyView: CartApp.EmptyOrderView,
        className: "table table-hover table-condensed",

        appendHtml: function (collectionView, itemView) {
            collectionView.$("tbody").append(itemView.el);
        },</pre></div><p>So far we defined the view and set the template; the <code class="literal">Itemview</code> and <code class="literal">EmptyView</code> properties will be used to render our view.</p><p>The <code class="literal">onBeforeRender</code> is a <a id="id79" class="indexterm"/>function that will be called, as the name indicates, before the <code class="literal">render</code> <a id="id80" class="indexterm"/>method; this function will allow us to calculate the totals that will be displayed in the <code class="literal">total</code> model.</p><div class="informalexample"><pre class="programlisting">        onBeforeRender: function () {
            var subtotal = this.collection.getTotal();
            var tax = subtotal * .08;
            var total = subtotal + tax;
            this.model.set({ subtotal: subtotal });
            this.model.set({ tax: tax });
            this.model.set({ total: total });
        },</pre></div><p>The <code class="literal">onRender</code> method is used here to check whether there are no models in the collection (that is, the user hasn't added a book to the shopping cart). If not, we should not display the header and footer regions of the view.</p><div class="informalexample"><pre class="programlisting">        onRender: function () {
            if (this.collection.length &gt; 0) {
                this.$('thead').removeClass('hide');
                this.$('tfoot').removeClass('hide');
            }
        },</pre></div><p>As we can see, Marionette does a great job offering functions that can remove a lot of boilerplate code and also give us full <a id="id81" class="indexterm"/>control over what is being rendered.</p></div></div></div>
<div class="section" title="Building the layout of our application with Marionette.Layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Building the layout of our application with Marionette.Layout</h1></div></div></div><p>The final view that we <a id="id82" class="indexterm"/>need to review is the <code class="literal">Marionette.Layout</code> view. This view is the combination of <code class="literal">Itemview</code> and <code class="literal">Region</code>; we haven't reviewed the <code class="literal">Marionette.Region</code> component, but for now, it's enough to say that it's a component that will be in charge of rendering a view on its <code class="literal">el</code>.</p><p>So the layout works as an <code class="literal">ItemView</code> because it requires a template to render itself. This template can be your initial <a id="id83" class="indexterm"/>HTML divided by logical regions, such as the navigation region that will contain a view which will display the navigation section of your site, the footer view that should be displayed at the footer region, and so on. You can start by rendering your layout and then rendering the view properly on each of the regions.</p><p>Let's create the <code class="literal">Marionette.Layout</code> view.</p><div class="informalexample"><pre class="programlisting">varCatalogLayout = Backbone.Marionette.Layout.extend({
        template: "#CatalogLayout",
        regions: {
            categories : '#categories',
            products : '#products',
            order : '#order',
            book: '#book'
        }
    });</pre></div><p>In the HTML that you copied in <a class="link" href="ch02.html" title="Chapter 2. Our First Application">Chapter 2</a>, <span class="emphasis"><em>Our First Application</em></span>, you will find the corresponding <code class="literal">&lt;div&gt;</code> tags with the IDs of the regions.</p><p>In this view, we specified the script/template that the view will use to render. This specified template was added to the initial HTML, and inside it were <code class="literal">&lt;div&gt;</code> tags that will serve as regions. Each of the regions is given a name that makes sense with the view that it will be displaying, and we used an object <code class="literal">literal</code> to define the regions.</p><p>The <code class="literal">Layout</code> view <a id="id84" class="indexterm"/>inherits the same functionality as for all the other views, so in case you want to listen to events, you can do it just like in any other view.</p><p>To render this initial layout, we just need to instantiate it and render it as any other view.</p><div class="informalexample"><pre class="programlisting">var catalogLayout = new CatalogLayout();
catalogLaout.render();</pre></div><p>You can still add and remove regions to your layout at runtime by calling the <code class="literal">addRegion</code> and <code class="literal">removeRegion</code> <a id="id85" class="indexterm"/>methods.</p><div class="informalexample"><pre class="programlisting">layout.addRegion("footer", "#footer");
layout.removeRegion("footer ");</pre></div><p>To add multiple regions, the <code class="literal">Layout</code> view provides an <code class="literal">addRegions</code> method that receives an object <code class="literal">literal</code> with the regions to be added.</p><div class="informalexample"><pre class="programlisting">layout.addRegions({
  favoriteBooks: "#favoritebooks",
  bestRated: "#best"
});</pre></div><p>The behavior of the <code class="literal">Close</code> function on this view will be a little different as it will call <code class="literal">close</code> on all of the regions. These regions will then call close on the views that they contain, making sure all of the <a id="id86" class="indexterm"/>views contained are closed properly.</p><p>A good way to start your application is to define a <code class="literal">Body</code> region; this region will then contain the application <code class="literal">Layout</code> that will contain all of the logical regions of the application. Maybe you need to <a id="id87" class="indexterm"/>display a sublayout in one of these regions, which is perfectly fine. There is no limit of nested layouts; use them as your application requires.</p></div>
<div class="section" title="Extending Marionette views"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Extending Marionette views</h1></div></div></div><p>A common need while working with <a id="id88" class="indexterm"/>Backbone and Marionette and in pretty much every language is to re-use code as much as possible. If you want all your views to behave in a certain way, you can achieve it by extending your Marionette views. In the following example, we will add a <code class="literal">log</code> method to all the item views by extending the <code class="literal">Marionette.ItemView</code>.</p><div class="informalexample"><pre class="programlisting">var HandyView = Backbone.Marionette.ItemView.extend({
  initialize:function(){
  Backbone.Marionette.ItemView.prototype.initialize.apply(this,arguments);
  },
  logMessage : function (message){
    console.log(message);
  }
});</pre></div><p>Now you just need to start using your <code class="literal">HandyView</code> in order to get the benefit of the <code class="literal">logMessage</code> <a id="id89" class="indexterm"/>function.</p><div class="informalexample"><pre class="programlisting">  var BookView = HandyView.extend({
  alertMessage : function () {
    alert(message);
  }
  });
  
  var bookView = new BookView();
  bookView.logMessage("Hi");
  bookView.alertMessage("Bye");</pre></div><p>The idea here is to let you know that you can extend Marionette views just like you can extend Backbone views, and take <a id="id90" class="indexterm"/>advantage of the benefits of inheritance.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we got to learn about all the kinds of views that Marionette offers, when to use them, how to advantageously make use of its handy methods that will allow us to manage the DOM creation and interaction better, and finally how to extend them.</p><p>In the next chapter, we will learn about how to manage a set of views with the help of the <code class="literal">Regions</code>, <code class="literal">RegionManager</code>, and <code class="literal">BabySitter</code> objects of Marionette.</p></div></body></html>