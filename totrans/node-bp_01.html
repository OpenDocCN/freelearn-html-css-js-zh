<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Common Programming Paradigms</h1></div></div></div><p class="calibre7">Node.js<a id="id0" class="calibre1"/> is a JavaScript-driven technology. The language has been in development for more than 15 years, and it was first used in Netscape. Over the years, they've found interesting and useful design patterns, which will be of use to us in this book. All this knowledge is now available to Node.js coders. Of course, there are some differences because we are running the code in different environments, but we are still able to apply all these good practices, techniques, and paradigms. I always say that it is important to have a good basis to your applications. No matter how big your application is, it should rely on flexible and well-tested code. The chapter contains proven solutions that guarantee you a good starting point. Knowing design patterns doesn't make you a better developer because in some cases, applying the principles strictly won't work. What you actually get is ideas, which will help you in thinking out of the box. Sometimes, programming is all about managing complexity. We all meet problems, and the key to a well-written application is to find the best suitable solutions. The more paradigms we know, the easier our work is because we have proven concepts that are ready to be applied. That's why this book starts with an introduction to the most common programming paradigms.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>Node.js fundamentals</h1></div></div></div><p class="calibre7">Node.js is a <a id="id1" class="calibre1"/>single-threaded technology. This means that every request is processed in only one thread. In other languages, for example, Java, the web server instantiates a new thread for every request. However, Node.js is meant to use asynchronous processing, and there is a theory that doing this in a single thread could bring good performance. The problem of the single-threaded applications is the blocking I/O operations; for example, when we need to read a file from the hard disk to respond to the client. Once a new request lands on our server, we open the file and start reading from it. The problem occurs when another request is generated, and the application is still processing the first one. Let's elucidate the issue with the following example:</p><div><pre class="programlisting">var http = require('http');
var getTime = function() {
  var d = new Date();
  return  d.getHours() + ':' + d.getMinutes() + ':' + 
      d.getSeconds() + ':' + d.getMilliseconds();
}
var respond = function(res, str) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end(str + '\n');
  console.log(str + ' ' + getTime());
}
var handleRequest = function (req, res) {
  console.log('new request: ' + req.url + ' - ' + getTime());
  if(req.url == '/immediately') {
    respond(res, 'A');
  } else {
    var now = new Date().getTime();
    while(new Date().getTime() &lt; now + 5000) {
      // synchronous reading of the file
    }
    respond(res, 'B');
  }
}
http.createServer(handleRequest).listen(9000, '127.0.0.1');</pre></div><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">
<strong class="calibre8">Downloading the example code</strong>
</p><p class="calibre7">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre7">The <code class="email">http</code> module<a id="id2" class="calibre1"/>, which we initialize on the first line, is needed for running the web server. The <code class="email">getTime</code> function returns the current time as a string, and the <code class="email">respond</code> function sends a simple text to<a id="id3" class="calibre1"/> the browser of the client and reports that the incoming request is processed. The most interesting function is <code class="email">handleRequest</code>, which is the entry point of our logic. To simulate the reading of a large file, we will create a <code class="email">while</code> cycle for 5 seconds. Once we run the server, we will be able to make an HTTP request to <code class="email">http://localhost:9000</code>. In order to demonstrate the single-thread behavior we will send two requests at the same time. These requests are as follows:</p><div><ul class="itemizedlist"><li class="listitem">One request will be sent to <code class="email">http://localhost:9000</code>, where the server will perform a synchronous operation that takes 5 seconds</li><li class="listitem">The other request will be sent to <code class="email">http://localhost:9000/immediately</code>, where the server should respond immediately</li></ul></div><p class="calibre7">The following screenshot is the output printed from the server, after pinging both the URLs:</p><div><img src="img/00002.jpeg" alt="Node.js fundamentals" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As we can see, the first request came at <code class="email">16:58:30:434</code>, and its response was sent at <code class="email">16:58:35:440</code>, that is, 5 seconds later. However, the problem is that the second request is registered when the first one finishes. That's because the thread belonging to Node.js was busy processing the <code class="email">while</code> loop.</p><p class="calibre7">Of course, <a id="id4" class="calibre1"/>Node.js has a solution for the blocking I/O operations. They are transformed to asynchronous functions that accept callback. Once the operation finishes, Node.js fires the callback, notifying that the job is done. A huge benefit of this approach is that while it waits to get the result of the I/O, the server can process another request. The entity that handles the external events and converts them into callback invocations is called the <code class="email">event</code> loop. The <code class="email">event</code> loop acts as a really good manager and delegates tasks to various workers. It never blocks and just waits for something to happen; for example, a notification that the file is written successfully.</p><p class="calibre7">Now, instead of reading a file synchronously, we will transform our brief example to use asynchronous code. The modified example looks like the following code:</p><div><pre class="programlisting">var handleRequest = function (req, res) {
  console.log('new request: ' + req.url + ' - ' + getTime());
  if(req.url == '/immediately') {
    respond(res, 'A');
  } else {
    setTimeout(function() {
      // reading the file
      respond(res, 'B');	
      }, 5000);	  	
    }
}</pre></div><p class="calibre7">The <code class="email">while</code> loop is <a id="id5" class="calibre1"/>replaced with the <code class="email">setTimeout</code> invocation. The result of this change is clearly visible in the server's output, which can be seen in the following screenshot:</p><div><img src="img/00003.jpeg" alt="Node.js fundamentals" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The first request still gets its response after 5 seconds. However, the second one is processed immediately.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Organizing your code logic in modules</h1></div></div></div><p class="calibre7">If we write a lot of code, sooner or later, we will start realizing that our logic should be split into different modules. In most languages, this is done through classes, packages, or some other <a id="id6" class="calibre1"/>language-specific syntax. However, in JavaScript, we don't have classes natively. Everything is an object, and in practice, objects inherit other objects. There are several ways to achieve object-oriented programming within JavaScript. You can use prototype inheritance, object literals, or play with function calls. Thankfully, Node.js has a standardized way of defining modules. This is approached by implementing <strong class="calibre8">CommonJS</strong><a id="id7" class="calibre1"/>, which is a project that specifies an ecosystem for JavaScript.</p><p class="calibre7">So, you have some logic, and you want to encapsulate it by providing useful API methods. If you reach that moment, you are definitely in the right direction. This is really important, and maybe it is one of the most challenging aspects of programming nowadays. The ability to split our applications into different parts and delegate functions to them is not<a id="id8" class="calibre1"/> always an easy task. Very often, this is undervalued, but it's the key to good architecture. If a module contains a lot of dependencies, operates with different data storages, or has several responsibilities, then we are doing something wrong. Such code cannot be tested and is difficult to maintain. Even if we take care about these two things, it is still difficult to extend the code and continue working with it. That's why it's good to define different modules for different functionalities. In the context of Node.js, this is done via the <code class="email">exports</code> keyword, which is a reference to <code class="email">module.exports</code>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Building a car construction application</h2></div></div></div><p class="calibre7">Let's elucidate <a id="id9" class="calibre1"/>the process with a simple example. Assume that we are building an application that constructs a car. We need one main module (<code class="email">car</code>) and a few other modules, which are responsible for the different parts of the car (<code class="email">wheels</code>, <code class="email">windows</code>, <code class="email">doors</code>, and so on). Let's start with the definition of a module representing the wheels of the car, with the following code:</p><div><pre class="programlisting">// wheels.js
var typeOfTires;
exports.init = function(type) {
    typeOfTires = type;
}
exports.info = function() {
  console.log("The car uses " + typeOfTires + " tires.");
}</pre></div><p class="calibre7">The preceding code could be the content of <code class="email">wheels.js</code>. It contains two methods. The first method, <code class="email">init</code>, should be called first and accepts one setting, that is, the type of the wheels' tires. The second method simply outputs some information. In our main file, <code class="email">car.js</code>, we have to get an instance of the wheels and use the provided API methods. This can be done as follows:</p><div><pre class="programlisting">// cars.js
  var wheels = require("./wheels.js");
  wheels.init("winter");
  wheels.info();</pre></div><p class="calibre7">When you run the application with <code class="email">node car.js</code>, you will get the following output:</p><div><pre class="programlisting">The car uses winter tires.</pre></div><p class="calibre7">So, everything that you want to expose to the outside world should be attached to the <code class="email">export</code> object. <a id="id10" class="calibre1"/>Note that <code class="email">typeOfTires</code> is a local variable for the module. It is available only in <code class="email">wheels.js</code> and not in <code class="email">car.js</code>. It's also a common practice to apply an object or a function to the <code class="email">exports</code> object directly, as shown in the following code for example:</p><div><pre class="programlisting">// engine.js
var Class = function() {
    // ...
}
Class.prototype = {
  forward: function() {
    console.log("The car is moving forward.");
  },
  backward: function() {
    console.log("The car is moving backward.");	
  } 
}
module.exports = Class;</pre></div><p class="calibre7">In JavaScript, everything is an object and that object has a <code class="email">prototype</code> property. It's like a storage that keeps the available variables and methods. The <code class="email">prototype</code> property is heavily used during inheritance in JavaScript, because it provides a mechanism for transferring logic.</p><p class="calibre7">We will also clear the difference between <code class="email">module.exports</code> and <code class="email">exports</code>. As you can see, in <code class="email">wheels.js</code>, we assigned two functions, <code class="email">init</code> and <code class="email">info</code>, directly to the <code class="email">exports</code> global object. In fact, that object is a reference to <code class="email">module.exports</code>, and every function or variable attached to it is available to the outside world. However, if we assign a new object or function directly to the <code class="email">export</code> object, we should not expect to get an access to it after requiring the file. This should be done with <code class="email">module.exports</code>. Let's take the following code as an example:</p><div><pre class="programlisting">// file.js
module.exports.a = 10;
exports.b = 20;

// app.js
var file = require('./file');
console.log(file.a, file.b);</pre></div><p class="calibre7">Let's say that both the files, <code class="email">app.js</code> and <code class="email">file.js</code>, are in the same directory. If we run <code class="email">node app.js</code>, we will get <code class="email">10 20</code> as the result. However, consider what would happen if we changed the code of <code class="email">file.js</code> to the following code:</p><div><pre class="programlisting">module.exports = { a: 10 };
exports.b = 20;</pre></div><p class="calibre7">Then, in this case, <a id="id11" class="calibre1"/>we would get <code class="email">10 undefined</code> as the result. That's because <code class="email">module.exports</code> has a new object assigned and <code class="email">exports</code> still points to the old one.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Using the car's engine</h2></div></div></div><p class="calibre7">Let's say that the<a id="id12" class="calibre1"/> module in <code class="email">engine.js</code> controls the car. It has methods for moving the car forward and backward. It is a little different because the logic is defined in a separate class and that class is directly passed as a value of <code class="email">module.exports</code>. In addition, as we are exporting a function, and not just an object, our instance should be created with the <code class="email">new</code> keyword. We will see how the car's engine works with the <code class="email">new</code> keyword as shown in the following code:</p><div><pre class="programlisting">var Engine = require("./engine.js");
var e = new Engine();
e.forward();</pre></div><p class="calibre7">There is a significant difference between using JavaScript functions as constructors and calling them directly. When we call the function as a constructor, we get a new object with its own prototype. If we miss the <code class="email">new</code> keyword, the value which we get at the end is the result of the function's invocation.</p><p class="calibre7">Node.js caches the modules returned by the <code class="email">require</code> method. It's done to prevent the blocking of the <code class="email">event</code> loop and increase the performance. It's a synchronous operation, and if there is no cache, Node.js will have to do the same job repeatedly. It's also good to know that we can call the method with just a folder name, but there should be a <code class="email">package.json</code> or an <code class="email">index.js</code> file inside the directory. All these mechanisms are described well in the official documentation of <a id="id13" class="calibre1"/>Node.js at <a class="calibre1" href="http://nodejs.org/">http://nodejs.org/</a>. What is important to note here is that the environment encourages modular programming. All we need is native implementation into the system, and we don't have to use a third-party solution that provides modularity.</p><p class="calibre7">Like in the client-side code, every Node.js module can be extended. Again, as we are writing the code in plain JavaScript, we can use the well-known approaches for inheritance. For example, take a look at the following code:</p><div><pre class="programlisting">var Class = function() { }
Class.prototype = new require('./engine.js')();
Class.prototype.constructor = Class;</pre></div><p class="calibre7">Node.js even offers<a id="id14" class="calibre1"/> a helper method for this purpose. Let's say that we want to extend our <code class="email">engine.js</code> class and add API methods to move the car in the left and right directions. We can do this with the following piece of code:</p><div><pre class="programlisting">// control.js
var util = require("util");
var Engine = require("./engine.js");
var Class = function() { }
util.inherits(Class, Engine); 
Class.prototype.left = function() {
  console.log("The car is moving to left.");
};
Class.prototype.right = function() {
  console.log("The car is moving to right.");  
}
module.exports = Class;</pre></div><p class="calibre7">The first line gets a reference to the Node.js native <code class="email">utils</code> module. It's full of useful functions. The fourth line is where the magic happens. By calling the <code class="email">inherits</code> method, we have actually set a new prototype of our <code class="email">Class</code> object. Keep in mind that every new method should use the already applied prototype. That's why the <code class="email">left</code> and <code class="email">right</code> methods are defined after the inheritance. At the end, our car will move in four directions, as shown in the following code snippet:</p><div><pre class="programlisting">var Control = require("./control.js");
var c = new Control();
c.forward();
c.right();</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Understanding inter-module communication</h1></div></div></div><p class="calibre7">We've found <a id="id15" class="calibre1"/>out how to put our code logic into modules. Now, we need to know how to make them communicate with each other. Very often, people describe Node.js as an event-driven system. It's also called non-blocking because as we have seen earlier in the chapter, it can accept a new request even before the previous request is fully complete. That's very efficient and highly scalable. The events are very powerful and are good means to inform the other modules of what is going on. They bring about encapsulation, which is very important in modular programming. Let's add some events to the car example we discussed earlier. Let's say that we have air <a id="id16" class="calibre1"/>conditioning, and we need to know when it is started. The implementation of such logic consists of two parts. The first one is the air conditioning module. It should dispatch an event that indicates the start of the action. The second part is the other code that listens for that event. We will create a new file called <code class="email">air.js</code> containing the logic responsible for the air conditioning, as follows:</p><div><pre class="programlisting">// air.js
var util = require("util");
var EventEmitter = require('events').EventEmitter;
var Class = function() { }
util.inherits(Class, EventEmitter);
Class.prototype.start = function() {
  this.emit("started");
};
module.exports = Class;</pre></div><p class="calibre7">Our class extends a Node.js module called <code class="email">EventEmitter</code><a id="id17" class="calibre1"/>. It contains methods such as <code class="email">emit</code> or <code class="email">on</code>, which help us to establish event-based communication. There is only one custom method defined: <code class="email">start</code>. It simply dispatches an event that indicates that the air conditioning is turned on. The following code shows how we can attach a listener:</p><div><pre class="programlisting">// car.js
var AirConditioning = require("./air.js");
var air = new AirConditioning();
air.on("started", function() {
  console.log("Air conditioning started");
});
air.start();</pre></div><p class="calibre7">A new instance of the <code class="email">AirConditioning</code> class is created. We attached an event listener and fired the <code class="email">start</code> method. The handler is called, and the message is printed to the console. The example is a simple one but shows how two modules communicate. It's a really powerful approach because it offers encapsulation. The module knows its responsibilities and is not interested in the operations in the other parts of the system. It simply does its job and dispatches notifications (events). For example, in the previous code, the <code class="email">AirConditioning</code> class doesn't know that we will output a message when it is started. It only knows that one particular event should be dispatched.</p><p class="calibre7">Very often, we need to send data during the emitting of an event. This is really easy. We just have to pass another parameter along with the name of the event. Here is how we send a <code class="email">status</code> property:</p><div><pre class="programlisting">Class.prototype.start = function() {
  this.emit("started", { status: "cold" });
};</pre></div><p class="calibre7">The object<a id="id18" class="calibre1"/> attached to the event contains some information about the air conditioning module. The same object will be available in the listener of the event. The following code shows us how to get the value of the <code class="email">status</code> variable mentioned previously:</p><div><pre class="programlisting">air.on("started", function(data) {
  console.log("Status: " + data.status);
});</pre></div><p class="calibre7">There is a design pattern that illustrates the preceding process. It's called the <strong class="calibre8">Observer</strong><a id="id19" class="calibre1"/>. In the context of that pattern, our air conditioning module is called <strong class="calibre8">subject</strong><a id="id20" class="calibre1"/>, and the car module is called the observer. The subject broadcasts messages or events to its observers, notifying them that something has changed.</p><p class="calibre7">If we need to remove a listener, Node.js has a method for that called <code class="email">removeListener</code><a id="id21" class="calibre1"/>. We can even allow a specific number of observers using <code class="email">setMaxListeners</code>. Overall, the events are one of the best ways to wire your logical parts. The main benefit is that you isolate the module, but it is still highly communicative with the rest of your application.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Asynchronous programming</h1></div></div></div><p class="calibre7">As we already learned, <a id="id22" class="calibre1"/>in nonblocking<em class="calibre9"> </em>environments, such as Node.js, most of the processes are asynchronous. A request comes to our code, and our server starts processing it but at the same time continues to accept new requests. For example, the following is a simple file reading:</p><div><pre class="programlisting">fs.readFile('page.html', function (err, content) {
  if (err) throw err;
  console.log(content);
});</pre></div><p class="calibre7">The <code class="email">readFile</code> method accepts two parameters. The first one is a path to the file we want to read, and the second one is a function that will be called when the operation finishes. The callback is <a id="id23" class="calibre1"/>fired even if the reading fails. Additionally, as everything can be done via that asynchronous matter, we may end up with a very long callback chain. There is a term for that—callback hell. To elucidate the problem, we will extend the previous example and do some operations with the file's content. In the following code, we are nesting several asynchronous operations:</p><div><pre class="programlisting">fs.readFile('page.html', function (err, content) {
  if(err) throw err;
  getData(function(data) {
    applyDataToTheTemplate(content, data, function(resultedHTML) {
      renderPage(resultedHTML, function() {
        showPage(function() {
          // finally, we are done
        });
     });
  });
  });
});</pre></div><p class="calibre7">As you can see, our code looks bad. It's difficult to read and follow. There are a dozen instruments that can help us to avoid such situations. However, we can fix the problem ourselves. The very first step to do is to spot the issue. If we have more than four or five nested callbacks, then we definitely should refactor our code. There is something very simple, which normally helps, that makes the code <strong class="calibre8">shallow</strong><a id="id24" class="calibre1"/>. The previous code could be translated to a more friendly and readable format. For example, see the following code:</p><div><pre class="programlisting">var onFileRead = function(content) {
  getData(function(data) {
    applyDataToTheTemplate(content, data, dataApplied);
  });
}
var dataApplied = function(resultedHTML) {
  renderPage(resultedHTML, function() {
    showPage(weAreDone);
  });
}
var weAreDone = function() {
  // finally, we are done
}
fs.readFile('page.html', function (err, content) {
  if (err) throw err;
    onFileRead(content);
});</pre></div><p class="calibre7">Most of the callbacks are just defined separately. It is clear what is going on because the functions have <a id="id25" class="calibre1"/>descriptive names. However, in more complex situations, this technique may not work because you will need to define a lot of methods. If that's the case, then it is good to combine the functions in an external module. The previous example can be transformed to a module that accepts the name of a file and the callback function. The module is as follows:</p><div><pre class="programlisting">var renderTemplate = require("./renderTemplate.js");
renderTemplate('page.html', function() {
  // we are done
});</pre></div><p class="calibre7">You still have a callback, but it looks like the helper methods are hidden and only the main functionality is visible.</p><p class="calibre7">Another popular instrument for dealing with asynchronous code is the <strong class="calibre8">promises</strong> paradigm<a id="id26" class="calibre1"/>. We already talked about events in JavaScript, and the promises are something similar to them. We are still waiting for something to happen and pass a callback. We can say that the promises represent a value that is not available at the moment but will be available in the future. The syntax of promises makes the asynchronous code look synchronous. Let's see an example where we have a simple module that loads a Twitter feed. The example is as follows:</p><div><pre class="programlisting">var TwitterFeed = require('TwitterFeed');
TwitterFeed.on('loaded', function(err, data) {
  if(err) {
      // ...
   } else {
      // ...
   }
});
TwitterFeed.getData();</pre></div><p class="calibre7">We attached a listener for the <code class="email">loaded</code> event and called the <code class="email">getData</code> method, which connects to Twitter and fetches the information. The following code is what the same example will look like if the <code class="email">TwitterFeed</code> class supports promises:</p><div><pre class="programlisting">var TwitterFeed = require('TwitterFeed');
var promise = TwitterFeed.getData();
promise.then(function(data) {
  // ...
}, function(err) {
  // ...
});</pre></div><p class="calibre7">The <code class="email">promise</code> object represents our data. The first function, which is sent to the <code class="email">then</code> method, is called when the <code class="email">promise</code> object succeeds. Note that the callbacks are registered after <a id="id27" class="calibre1"/>calling the <code class="email">getData</code> method. This means that we are not rigid to actual process of getting the data. We are not interested in when the action occurs. We only care when it finishes and what its result is. We can spot a few differences from the event-based implementation. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem">There is a separate function for error handling.</li><li class="listitem">The <code class="email">getData</code> method can be called before calling the <code class="email">then</code> method. However, the same thing is not possible with events. We need to attach the listeners before running the logic. Otherwise, if our task is synchronous, the event may be dispatched before our listener attachment.</li><li class="listitem">The <strong class="calibre8">promise</strong> method<a id="id28" class="calibre1"/> can only succeed or fail once, while one specific event may be fired multiple times and its handlers can be called multiple times.</li></ul></div><p class="calibre7">The promises get really handy when we chain them. To elucidate this, we will use the same example and save the tweets to a database with the following code:</p><div><pre class="programlisting">var TwitterFeed = require('TwitterFeed');
var Database = require('Database');
var promise = TwitterFeed.getData();
promise.then(function(data) {
  var promise = Database.save(data);
  return promise;
}).then(function() {
  // the data is saved
  // into the database
}).catch(function(err) {
  // ...
});</pre></div><p class="calibre7">So, if our successful callback returns a new promise, we can use <code class="email">then</code> for the second time. Also, we have the possibility to set only one error handler. The <code class="email">catch</code> method at the end is fired if some of the promises are rejected.</p><p class="calibre7">There are four states of every promise, and we should mention them here because it's a terminology that is widely used. A promise could be in any of the following states:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">Fulfilled</strong>: A promise is in the fulfilled state<a id="id29" class="calibre1"/> when the action related to the promise succeeds</li><li class="listitem"><strong class="calibre8">Rejected</strong>: A promise is in the rejected state<a id="id30" class="calibre1"/> when the action related to the promise fails</li><li class="listitem"><strong class="calibre8">Pending</strong>: A promise is in the pending state<a id="id31" class="calibre1"/> if it hasn't been fulfilled or rejected yet</li><li class="listitem"><strong class="calibre8">Settled</strong>: A promise is in a settled state<a id="id32" class="calibre1"/> when it has been fulfilled or rejected</li></ul></div><p class="calibre7">The asynchronous nature<a id="id33" class="calibre1"/> of JavaScript makes our coding really interesting. However, it could sometimes lead to a lot of problems. Here is a wrap up of the discussed ideas to deal with the issues:</p><div><ul class="itemizedlist"><li class="listitem">Try to use more functions instead of closures</li><li class="listitem">Avoid the pyramid-looking code by removing the closures and defining top-level functions</li><li class="listitem">Use events</li><li class="listitem">Use promises</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Exploring middleware architecture</h1></div></div></div><p class="calibre7">The Node.js framework <a id="id34" class="calibre1"/>is based on the middleware architecture. That's because this architecture brings modularity. It's really easy to add or remove functionalities from the system without breaking the application because the different modules do not depend on each other. Imagine that we have several modules that are all stored in an array, and our application starts using them one by one. We are controlling the whole process, that is, the execution continues only if we want it to. The concept<a id="id35" class="calibre1"/> is demonstrated in the following diagram:</p><div><img src="img/00004.jpeg" alt="Exploring middleware architecture" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">
<strong class="calibre8">Connect</strong> (<a class="calibre1" href="https://github.com/senchalabs/connect">https://github.com/senchalabs/connect</a>) is one of <a id="id36" class="calibre1"/>the first frameworks that implements this pattern. In the context of Node.js, the middleware is a function that accepts the request, response, <a id="id37" class="calibre1"/>and the next callbacks. The first two parameters represent the input and output of the middleware. The last one is a way to pass the flow to the next middleware in the list. The following is a short example of this:</p><div><pre class="programlisting">var connect = require('connect'),
    http = require('http');
 
var app = connect()
  .use(function(req, res, next) {
    console.log("That's my first middleware");
    next();
  })
  .use(function(req, res, next) {
    console.log("That's my second middleware");
    next();
  })
  .use(function(req, res, next) {
    console.log("end");
    res.end("hello world");
  });
 
http.createServer(app).listen(3000);</pre></div><pre>data</code> property.</pre><div><pre class="programlisting">.use(function(req, res, next) {
    req.data = { value: "middleware"};
    next();
})
.use(function(req, res, next) {
    console.log(req.data.value);
})</pre></div><p class="calibre7">The request and response objects are identical in every function. Thus, the middleware share the same scope. At the same time, they are completely independent. This pattern provides a really flexible development environment. We can combine modules that do different tasks written by different developers.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Composition versus inheritance</h1></div></div></div><p class="calibre7">In the<a id="id39" class="calibre1"/> previous section, we learned how to create modules, how to make them communicate, and how to use them. Let's talk a bit about how to architect modules. There are dozens of ways to build a good application. There are also some great books written only on this subject, but we will focus on two of the most commonly used techniques: composition and inheritance. It's really important to understand the difference between the two. They both have pros and cons. In most of the cases, their usage depends on the current project.</p><p class="calibre7">The <code class="email">car</code> class from the previous sections is a perfect example of composition. The functionalities of the <code class="email">car</code> object are built by other small objects. So, the main module actually delegates its jobs to other classes. For example, the wheels or the air conditioning of the car are controlled by externally defined modules:</p><div><pre class="programlisting">var wheels = require("./wheels.js")();
var control = require("./control.js")();
var airConditioning = require("./air.js")();
module.export = {
  run: function() {
    wheels.init();
    control.forward();
    airConditioning.start();
  }
}</pre></div><p class="calibre7">For the outside world, the car has only one method: <code class="email">run</code>. However, what happens is that we perform three different operations, and they are defined in other modules. Often, the composition is<a id="id40" class="calibre1"/> preferred over the inheritance because while using this approach, we can easily add as many modules as we want. It's also interesting that we cannot only include modules but also other compositions.</p><p class="calibre7">On the other side is the inheritance. The following code is a typical example of inheritance:</p><div><pre class="programlisting">var util = require("util");
var EventEmitter = require('events').EventEmitter;
var Class = function() { }
util.inherits(Class, EventEmitter);</pre></div><p class="calibre7">This code implies that our class needs to be an event emitter, so it simply inherits that functionality from another class. Of course, in this case, we can still use composition and create an instance of the <code class="email">EventEmitter</code> class, define methods such as <code class="email">on</code> and <code class="email">dispatch</code>, and delegate the real work. However, here it is much better to use inheritance.</p><p class="calibre7">The truth is somewhere in between—the composition and the inheritance should play together. They are really great tools, but each of them has its own place. It's not only black and white, and sometimes it is difficult to find the right direction. There are three ways to add behavior to our objects. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Writing the functionality into the objects directly</li><li class="listitem">Inheriting the functionality from a class that already has the desired behavior</li><li class="listitem">Creating a local instance of an object that does the job</li></ul></div><p class="calibre7">The second one is related to inheritance and the last one is actually a composition. By using composition, we are adding a few more abstraction layers, which is not a bad thing, but it could lead to unnecessary complexity.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Managing dependencies</h1></div></div></div><p class="calibre7">Dependency management <a id="id41" class="calibre1"/>is one of the biggest problems in complex software. Often, we build our applications around third-party libraries or custom-made modules written for other projects. We do this because we don't want to reinvent the wheel every time. </p><p class="calibre7">In the previous sections of this chapter, we used the <code class="email">require</code> global function. That's how Node.js adds dependencies to the current module. A functionality written in one JavaScript file is included in another file. The good thing is that the <a id="id42" class="calibre1"/>logic in the imported file lives in its own scope, and only the publicly exported functions and variables are visible to the host. With this behavior, we are able to separate our logic modules into Node.js packages. There is an instrument that controls such packages. It's called <strong class="calibre8">Node Package Manager </strong>(<strong class="calibre8">npm</strong>)<a id="id43" class="calibre1"/> and is available as a command-line instrument. Node.js has become so popular mainly because of the existence of its package manager. Every developer can publish their own package and share it with the community. The good versioning helps us to bind our applications to specific versions of the dependencies, which means that we can use a module that depends on other modules. The main rule to make this work is to add a <code class="email">package.json</code> file to our project. We will add this file with the following code:</p><div><pre class="programlisting">{
  "name": "my-awesome-module",
  "version": "0.1.10",
  "dependencies": {
    "optimist": "0.6.1",
    "colors": "0.6.2"
  }
}</pre></div><p class="calibre7">The content of the file should be valid JSON and should contain at least the <code class="email">name</code> and <code class="email">version</code> fields. The <code class="email">name</code> property should also be unique, and there should not be any other module with the same name. The <code class="email">dependencies</code> property contains all the modules and versions that we depend on. To the same file, we can add a lot of other properties. For example, information about the author, a description of the package, the license of the project, or even keywords. Once the module is registered in the registry, we can use it as a dependency. We just need to add it in our <code class="email">package.json</code> file, and after we run <code class="email">npm install</code>, we will be able to use it as a dependency. Since Node.js adopts the module pattern, we don't need instruments such as the dependency injection container or service locater.</p><p class="calibre7">Let's write a <code class="email">package.json</code> file for the car example used in the previous sections, as follows:</p><div><pre class="programlisting">{
  "name": "my-awesome-car",
  "version": "0.0.1",
  "dependencies": {
    "wheels": "2.0.1",
    "control": "0.1.2",
    "air": "0.2.4"
  }
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we went through the most common programming paradigms in Node.js. We learned how Node.js handles parallel requests. We understood how to write modules and make them communicative. We saw the problems of the asynchronous code and their most popular solutions. At the end of the chapter, we talked about how to construct our application. With all this as a basis, we can start thinking about better programs. Software writing is not an easy task and requires strong knowledge and experience. The experience usually comes after years of coding; however, knowledge is something that we can get instantly. Node.js is a young technology; nonetheless, we are able to apply paradigms and concepts from client-side JavaScript and even other languages.</p><p class="calibre7">In the next chapter, we will see how to use one of the most popular frameworks for Node.js, that is, Express.js, and we will build a simple website.</p></div></body></html>