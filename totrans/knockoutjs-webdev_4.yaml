- en: Chapter 4. Coding – AJAX, Binding Properties, Mapping, and Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an aspect of Knockout that takes repeated tasks out of the way. There
    is also the reality that we never expect it to do 100 percent of our work. It
    also makes sense that we do not have Knockout doing so much as it is not good
    at its core strengths. Here, we will learn how to extend our reach into Knockout
    and how to connect to the world outside Knockout and do even more. This chapter
    will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping versus manual ViewModels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with AJAX requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmapping your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be learning about some of the commonly used aspects
    of Knockout—working with JSON and the mapping plugin. These two are simple and
    powerful pivots where we will extend rapid application development with Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: JSON done Knockout style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON is the famous data packaging standard that seems to have taken over the
    Internet. At one time there was XML; RoR has its own packaging standard; and even
    Adobe had perhaps the best performing way to package and deliver data between
    the client and the server called **Action Message Format** (**AMF**). The overall
    winner seems to be JSON because it is simple and based on the most common development
    platform of all: JavaScript. If you would like more information about JSON you
    can visit [http://json.org](http://json.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve our purpose, let''s create a file called, `json.html`. The first thing
    we will do is convert a ViewModel to JSON. Most modern browsers have a function
    called `JSON.stringify` but that is not how we do it in Knockout. There are two
    methods included in Knockout:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ko.toJS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ko.toJSON`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first method, `ko.toJS`, will clone the Knockout data into a plain copy
    that contains no Knockout-related hints or information. The second method, `ko.toJSON`,
    will perform the `ko.toJS` action and then convert it into a serialized JSON string
    according to the JSON standard. If you are using older browsers such as IE7 or
    older, you will need to get a copy of the `json2.js` file, available at [https://github.com/douglascrockford/JSON-js/blob/master/json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter the following code into your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will look at our structure stored in the ViewModel. We will be using
    Chrome as our browser but you can use any browser with development tools that
    support the console command. Here is the result we got by dumping our ViewModel.
    Type `console.log(vm)` in the console to get the results stored in `vm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON done Knockout style](img/1028OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is plainly visible that while a full exposure of our ViewModel is there,
    packaged in functions. You will get used to ignoring the `undefined` item`,` when
    dumping stuff into the console. If you get the results expected then don't get
    distracted by that item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we use the two commands, which are `ko.toJS` and `ko.toJSON`.
    Let''s start by dumping the ViewModel to the console using the structure. Type
    `console.log( ko.toJS(vm) )` in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON done Knockout style](img/1028OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we see `console.log` versus dump. This is great, but if we wanted to
    send this out to an external source or store it using modern browser storage technology
    we would still want to package it as a JSON string in most cases. This can be
    achieved using the helper `ko.toJSON` method, which is what we will be doing next.
    You will see this time our data has been placed in the middle of special characters.
    This is the JSON formatting, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON done Knockout style](img/1028OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will create `json2.html` to pull our JSON data into our app. We will
    need to copy and paste the JSON into our app but we will be doing that from a
    separate file in the same directory as the HTML file. Name that file `json2.txt`
    for this example. Certainly, on a live site don''t store sensitive data in a text
    file. In the `json2.txt` file copy the console output you got in the preceding
    example. This is your JSON data and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While this might look good, we have an issue. JSON doesn''t stand on its own
    feet. It needs to be inside a variable to be managed. We will change it as follows.
    We will use the variable, `myJSON`. We also need to surround the text in quotes.
    Since the JSON tends to use double quotes internally, the traditional way to handle
    this is to use a single quote before the data string and a single quote at the
    end, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used for our `json2.html` file. We will use the `script`
    command to pull the external data into the page. It is also common for people
    to name such a static file `json2.json`. We are using the `.text` extension to
    make a point that JSON is just a text file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out our ViewModel this time with structure but absolutely no data.
    After binding the ViewModel to our data model, we convert our string of JSON data
    into a standard JavaScript structure. We then use the standard JavaScript to pass
    the arrays into the `foodItems` and the `foods` attributes of our ViewModel. While
    that is neat, it doesn''t feel like we actually did something of value. Let''s
    add some View code onto the page above the `script` section, as follows. This
    is the same code we used in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What we see is a web page that pulls the external data in and automatically
    populates the View for us based on that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON done Knockout style](img/1028OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapping – first look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been creating manual maps of our ViewModel so far in this book. With
    smaller datasets this can be practical and productive. As our datasets get larger
    along with the need to update the data, this will become a chore that has an alternative,
    enjoyed by a great number of Knockout developers. This is done through a mapping
    plugin. Knockout is a jQuery-based library in more than one way. It is possible
    to build and use libraries, called plugins, for Knockout also. The most famous
    library is the mapping library. I have included a copy of it in the downloaded
    files for this book. We will be looking again at the preceding code for our example
    but moving it this time using the mapping plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a file called `mapping.html` for our code this time. We will
    need to include one more JavaScript file right after the Knockout call for our
    mapping plugin. You can find these files in the working examples folder in the
    ZIP download. This, in our case, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create both of those files if you wish, but we suggest just copying them from
    the `done` folder in this chapter and making sure they are in the same folder
    as the `mapping.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with AJAX remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a `script` tag to load data is definitely not very sophisticated. We
    are going to improve this by creating the example again, but this time using jQuery
    to make our AJAX request. We will put this code in a file named `ajax.html`. We
    will use the same HTML code as before, but we will add a button to the form using
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pullData` request will be a method/function that we add to our ViewModel.
    It will be used, at this time, to pull the data from the server and update the
    View in our browser. Here is the `script` section of code we will use for this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Please note that I am going to try to get you into the habit of using—this is
    a phrase I made up and like—"selfish coding". Because there is a risk of interaction
    with our code having the `this` value, debugging "this" issue is not fun. We have
    learned to use the `self` alias to make sure this does not become an issue. The
    `.done()` function is a chained command in jQuery to handle the completion of
    a good request to the server. See the jQuery documents for more handlers; you
    can use those docs to make your code even more fully responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a function/method called `pullData`. Inside the data we will
    use a `jQuery.getJSON` request to pull our data back from the server. We have
    copied the JSON structure to a file called `data.json` this time. Make sure you
    do not assign this to a variable; you only want the structure of the JSON as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at our initial screen when we load the page. Here is what you
    should get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting with AJAX remotely](img/1028OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click the **Pull Data** button we will see the results automatically
    update to the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting with AJAX remotely](img/1028OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is already much better coding than a pure JavaScript experience for many
    developers. Yet, what if this form had 40 elements on the page? It would be a
    big block of code to set the ViewModel up for that much binding. We just learned
    about mapping; so what if we included the mapping plugin and reworked our code?
    Take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see a few changes in our approach. We could have just put the filename
    into the `getJSON` request, but we passed it in as a variable just as a matter
    of how we like to code. We also created the `vm` variable to hold our ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: The AJAX has been moved outside the ViewModel while the ViewModel declaration
    has been moved inside the AJAX. It is inside out compared to our last example.
    The difference is that we see the data populate our View immediately as the page
    loads. We have also changed the functionality of our `pullData` function. Now,
    it will be used to make a second call to the server. Normally, we would not reset
    this source file as it would be a typical AJAX request to see whether anything
    was updated. Since we are not coding for a dynamic server we will just show an
    imitation of that scenario here by changing the name of the source for our AJAX
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when doing mapping we have to declare the mapping features before we use
    the `applyBindings` method. This gives us the same results as manually creating
    each individual binding. Again, for a simple form like this the gain is not so
    obvious. When we get to larger, more complex pages, the gain is amazing. Oh, also
    note that when we run additional calls to the server we will be updating the data.
    We need to pass in the ViewModel variable after our data as we map an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take another look at what we get by running our code with a little
    more progressive AJAX. The first load looks like the pulled data from our last
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting with AJAX remotely](img/1028OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We created an additional item; so when we load the update it will be obvious.
    The item is **Ice Cream**. We also preselected this item. Here is our JSON data
    structure for the second load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we push the button now to pull the update this is what we should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting with AJAX remotely](img/1028OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unmapping your data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is coming along good but there is something we are going to need for most
    AJAX-based web applications. We are going to need to store the data back on the
    server. Pulling the data to the browser will not be enough. We will require the
    ability to push the data back to the server as well. Once again, we will be using
    jQuery for this function. Of course, we will show the code to do this but we will
    approach it differently because different readers will be using different backends
    such as ASP.NET, ColdFusion, Node.js, PHP, Python, Ruby, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, just modify the code in the `AJAX.html` file unless, of course,
    you want to create a new file. We will be adding another button to our View to
    connect a push data method this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to put a textbox at the end of our View code to see the data
    that is pulled out of our ViewModel. Create the `textarea` field to hold the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to add another method to our ViewModel now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We saw the code that would be used to send a request back to the server. We
    are assuming in this example that our server was able to respond to the URL in
    the `reqAJAX` variable and handle data coming into the server. If not, all you
    would need to do is set that variable to the target that can take data. The data
    is being sent in this case in the `POST` form of data. This would be the same
    as a form using the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see all we did was add the ability to pull the results back out
    as a variable named `myData`. If we ran the code again, pulled data, and set the
    selections to just eggs and ice cream, we would be able to test the data being
    pushed back to the server. Notice we have the jQuery command to push the `myData`
    results to the `textarea` field. Here are the results we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unmapping your data](img/1028OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have what seems to be an issue with extra data. We don't have to manage that
    but it is not hard to fix. The issue occurs because when data is mapped it creates
    extra details internally. These come back out when unmapping the data. You can
    leave that if you choose or you can fix it using the following code. We will write
    a `console.log` command that will dump the structure to the console. We also need
    to change `myData` to return the JavaScript structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our developer tools console for our browser we will see the following
    structure for our dump. Then we will use `JSON.stringify()` to make it ready for
    AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the change to the `myData` variable and the console log to manage the
    dump. The extra detail in the console log is part of the `__ko_mapping__` data
    structure. Using the JavaScript delete command, we can trim it right off our results.
    Some functions are showing, but when we use the `stringify` function, it does
    not pull them. Here is what we get now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we are doing meaningful AJAX interaction. You may want to send even less
    structure back to the server than we did here. There is the option of trimming
    even more data to keep things as compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, for a live app, *remember* to remove the console log and the `textarea`
    field. Don't say I taught you to leave those in a real world web page!
  prefs: []
  type: TYPE_NORMAL
- en: Merging mapped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times you may want to pull data into your ViewModel from multiple
    sources. When doing this you can create a map for each source. If the source variables
    have the same name they will overwrite the existing variables. As long as the
    base variable is a different name it will merge them into the ViewModel. Do this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What you get is a combination of the `firstData` JavaScript structure, mapped
    with `firstMap`, combined with the `nextData` JavaScript structure, and with the
    `nextMap` mapping. If there are any duplicate base structures in `nextData`, they
    will override the same structures in the existing `firstData` JavaScript structure.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when you are loading data into a page application that doesn''t
    need to be changed. This is just static data and making it observable spends extra
    processor time and memory resources for no gain. When passing data into the mapping
    handler, you can set which items are mapped as observable items, using the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The results we get from the `result` and `result2` variables will be the same.
    Why? This is because when we declare the `observe` items the other items are assumed
    to be copied items. If a single item is passed in we can declare it outside an
    array, as we did with `a`. If multiple items are passed in we would declare them
    in an array, as `["a","c"]`. This would make both `a` and `c` observable items.
  prefs: []
  type: TYPE_NORMAL
- en: If we just wanted to declare an item to copy we would pass in the copy and that
    is the only item that would be directly copied. We also have the ability to ignore
    items from being copied in during the mapping using `ignore`, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Utility functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of functions in `ko.utils`. Let's start by looking at the
    special array methods in standard Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: ko.utils.arrayFilter()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.utils.arrayFilter` function allows us to filter items in an array.
    We are going to run these as straight code examples. We will create a sample JSON
    file and load it via AJAX to keep the focus on learning the methods and not waste
    time creating an example code set. We will create a page called `utility.html`
    for these pieces of code and run the filtering code from there. Our markup for
    this example is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `script` code is as follows. We will be adding more for each example as
    we go, but here are the basics for the utility examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We set our mapping using the data and then we begin adding our custom features.
    These could be custom functions or computed values. Lastly, after adding all our
    customizations to the mapping we apply our bindings.
  prefs: []
  type: TYPE_NORMAL
- en: In our code sample we showed you how to use `arrayFilter`. The `arrayFilter`
    function will pass in the items one at a time and will include the ones in the
    result set in which we send out a true value to let it know that it should be
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the JSON we will use for our examples. We will show the whole dataset
    here. Note that the JSON is also in our `done` folder under the `utility.json`
    file if you do not want to type it in. Normally, I would suggest typing in these
    examples to strengthen your skills on the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we used the following dataset to create our JSON. We just called the
    `JSON.stringify` method on the dataset. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to include our jQuery, Knockout, and Knockout mapping JavaScript
    files. When you get all these pulled together with the preceding code, this is
    what you should see in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.arrayFilter()](img/1028OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see that our filtered results only return two of the six items. This is because
    only two of them were less than 35\. What is even more fun is that this data is
    dynamically wired into the View model. If the arrays change by adding or removing
    items the screen will update automatically. This is just not wired into jQuery
    so it's a great addition. Also, if a value within an array item changes, say one
    of the ages, then the filter here will automatically know to add, remove, or leave
    the item in the view list.
  prefs: []
  type: TYPE_NORMAL
- en: ko.utils.arrayFirst()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.utils.arrayFirst` method will pass items into the function to be searched
    until a match is found or declared. It will only return one item from the array.
    Here is the View code to add for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the logic to add to understand our `arrayFirst` utility command. Add
    it before the binding is set in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the last utility method, the results are triggered by the true value coming
    back out. The difference in this example is that the first true value will be
    the only one ever returned. Here is a screenshot of our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.arrayFirst()](img/1028OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ko.utils.arrayMap()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.utils.arrayMap` method allows creation of a flattened array. What this
    means is that sometimes we have an array of structures and want just a particular
    item for the whole structure to be pulled back into a simple array. Here is the
    markup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the script code we need to add for this example. We will not return
    true or false style results this time. We will return a value that will, in this
    case, create a simple value array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the screen result you will see with our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.arrayMap()](img/1028OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to actually modify the structure that is being passed into the
    process by modifying the item. This is because normally, structures and arrays
    are passed in by setting a reference to the source structure in memory. This means
    even though the name item is what is coming in, the item points to the original
    structure in the ViewModel. Here is another method we could have used if we wanted
    to modify the original structure within the ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The results would be a value nested within the ViewModel array collection, but
    the value would not be observed or computed. This means while it may work, it
    will not work with all the features of Knockout. So it should be tested carefully
    before trying this. If in doubt, avoid this approach to avoid unplanned features.
    Oh, you could also delete item fields, so beware that you are editing the original
    structure and anything connected is at risk if you manually change these things.
  prefs: []
  type: TYPE_NORMAL
- en: ko.utils.arrayGetDistinctValues ()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.utils.arrayGetDistinctValues` method allows you to take an array and
    remove duplicate values, leaving only distinct items. This time we will be dealing
    with a result set that is an array, so again in the View we will be using the
    foreach method on our `data-bind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that we are inserting two segments this time. This is
    because `arrayGetDistintValues` modifies another array. We need the array it is
    going to modify. What we will do is create an array of all the ages using our
    `arrayMap` method, and then create another result with only the distinct values
    in it. In our script code, we again need to set `arrayGetDistinctValues` before
    the `applyBindings` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of both sets of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.arrayGetDistinctValues ()](img/1028OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first set was sorted in the call to the unique value set. This is something
    to watch out for as it can be confusing when something like this happens. We included
    it here for some food for thought and to illustrate, again, the need to be aware
    that you might be performing a command on the original set of data. If you were
    to follow best practice you might sort the results of the unique years, if that
    was your goal, rather than sorting the input data within the method. This is also
    an example of where an external variable is visible even though the sort call
    happened within the method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: ko.utils.arrayForEach()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ko.utils.arrayForEach` method will allow you to loop through an array.
    This can be great for doing totals or other logic pulled from a summary of looking
    at individual objects. You could return all workers with children, for instance.
    While the most ideal place may be to do this coming from the database, this does
    not make it the only place it can ever be done. It is good practice to review
    where and why we do things to make sure our apps are performing and can scale
    as much as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our View code this time will be using a non-array value so we will not be using
    a foreach method. The reason we bring that up again here is if you use a wrong
    method your page will fail to run correctly. Often, the issue is as simple as
    trying to call an array method on a non-array property of the ViewModel. This
    is the kind of routine issue that can challenge any developer. Here is the View
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Just in case you missed me saying this somewhere in this book, let me make
    a point. In Knockout, a little bit of code has a lot of power. Here is the code
    for our total age processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, we get a total of the ages in our screenshot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.arrayForEach()](img/1028OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ko.utils.compareArrays()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This allows you to compare arrays and return a collection, showing all items
    from both arrays. If the item did not exist in the second collection it will be
    shown as deleted. If the item is in the second set but not in the first set it
    will be shown as added. The return set will also show the index of the item where
    it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our View code for the last array example on `compareArrays`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script code is once again simple, and hopefully by working through coding
    each of these by hand, they have become more natural to you also. Here is the
    `script` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of our code running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.compareArrays()](img/1028OS_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We wanted to include a console log from the browser developer tools as we thought
    Chrome showed the structure nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ko.utils.compareArrays()](img/1028OS_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Purifying our computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to redo the `script` section of code using `pureComputed` versus
    `computed`. The term `pureComputed` was inspired by the concept of pure functions
    as a style of programming. It is nothing you need to understand to use so don't
    get caught up with the semantics of the name as there is no practical win as far
    as learning how these pure computations benefit us here.
  prefs: []
  type: TYPE_NORMAL
- en: When Knockout has something watching, a computed item is called a subscriber.
    Thus, it is considered to be a subscriber dependency. If we use the `pureComputed`
    method versus the `computed` method, Knockout will not calculate the value when
    there are no subscribers. This, of course, adds more speed to our processes by
    reducing calculations that aren't needed and unnecessary code from running. It
    is also another way to avoid any chance of memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: When there are no subscribers, a pure computed observable is considered to be
    **sleeping**. When there are subscribers it is considered to be **listening**.
    The term listening is a bit odd for me as to me it would be **responding**. It
    does make sense though, because it is a computing method. So it does need to listen
    to the values it is using to compute with. If any of those values change it needs
    to recalculate its results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated script code moved to the better `pureComputed` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know how many dependencies an item has, you can look at the
    `getDependenciesCount` method. Type the following into your console in your browser
    developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you how many items are subscribing to the `allYears` computed
    method. There is also a function that will tell us the number of items that are
    subscribing to the `allYears` calculation method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Coding documents for computed observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have included the following documents about observables just for reference
    here. While these were available online on the KnockoutJS site, it seemed like
    a good idea to include them here so you don't have to keep jumping between the
    website and the book.
  prefs: []
  type: TYPE_NORMAL
- en: A computed observable can be constructed using one of the following forms.
  prefs: []
  type: TYPE_NORMAL
- en: Form 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.computed( evaluator [, targetObject, options] )` form supports the
    most common case of creating a computed observable. It has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`evaluator`: This is a function that is used to evaluate the computed observable''s
    current value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetObject`: If given, it defines the value of `this` whenever Knockout
    invokes your callback functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is an object with further properties for the computed observable.
    See the full list in the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ko.computed( options )` parameter, is a single parameter form for creating
    a computed observable that accepts a JavaScript object with any of the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read`: This is a required function and used to evaluate the computed observable''s
    current value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`: This is an optional function and if given, this makes the computed
    observable writable. This function receives values that other code is trying to
    write to your computed observable. It''s up to you to supply custom logic to handle
    the incoming values, typically by writing the values to some underlying observable(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner`: This is an optional function and, if given, it defines the value of
    `this` whenever Knockout invokes your `read` or `write` callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pure`: This is optional and if this is true, the computed observable will
    be set up as `purecomputed observable`. This option is an alternative to the `ko.pureComputed`
    constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferEvaluation`: This is optional and if this option is true, then the value
    of the computed observable will not be evaluated until something actually attempts
    to access its value or manually subscribes to it. By default, a computed observable
    has its value determined immediately during creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disposeWhen`: This is an optional function and if given, this function is
    executed before each re-evaluation to determine if the computed observable should
    be disposed. A true-ish result will trigger disposal of the computed observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disposeWhenNodeIsRemoved`: This is an optional function. If given, disposal
    of the computed observable will be triggered when the specified DOM node is removed
    by Knockout. This feature is used to dispose computed observables used in bindings
    when nodes are removed by the template and control-flow bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ko.pureComputed( evaluator [, targetObject] )` form constructs `pure computed
    observable` using the given evaluator function and optional object to use for
    `this`. Unlike `ko.computed`, this method doesn't accept an `options` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Form 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ko.pureComputed( options )` form constructs a pure computed observable
    using an `options` object. This accepts the `read`, `write`, and `owner` options
    described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Using a computed observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A computed observable provides the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dispose()`: This manually disposes the computed observable, clearing all subscriptions
    to dependencies. This function is useful if you want to stop a computed observable
    from being updated or want to clean up memory for a computed observable that has
    dependencies on observables that won''t be cleaned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extend(extenders)`: This applies the given extenders to the computed observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDependenciesCount()`: This returns the current number of dependencies of
    the computed observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSubscriptionsCount()`: This returns the current number of subscriptions
    (either from other computed observables or manual subscriptions) of the computed
    observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isActive()`: This returns whether the computed observable may be updated in
    the future. A computed observable is inactive if it has no dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This returns the current value of the computed observable without
    creating a dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe( callback [,callbackTarget, event] )`: This registers `manual subscription`
    to be notified of changes to the computed observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the computed context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the execution of a computed observable''s evaluator function, you can
    access `ko.computedContext` to get information about the current computed property.
    It provides the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isInitial()`: This is a function that returns true if called during the first
    ever evaluation of the current computed observable, or false otherwise. For `pure`
    computed observables, `isInitial()` is always undefined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDependenciesCount()`: This returns the number of dependencies of the computed
    observable detected so far during the current evaluation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ko.computedContext.getDependenciesCount()` function is equivalent to calling
    `getDependenciesCount()` on the computed observable itself. The reason that it
    also exists on `ko.computedContext` is to provide a way of counting the dependencies
    during the first ever evaluation, before the computed observable has even finished
    being constructed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter opens up a whole load of features and options to make web style
    coding powerful and elegant. Learning to let a library handle things for you is
    hard for some but that perspective is ironic as we are programming computers for
    others to let our work manage things for them. This chapter has added several
    valuable skills and options to our knowledge and experience:'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to integrate data management in Knockout using JSON as an alternate
    way to pass data in and out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen the incredible power of mapping to make our code another magnitude
    of elegant using Knockout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have been introduced to the basics of using AJAX with Knockout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned how to use utility functions for more advanced collection features,
    and again with less lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we learned how to improve the performance of our ViewModel using pure
    oriented compute functions (with a bonus clip of compute documents from the KnockoutJS
    online documents).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our next chapter we will be looking at another way of packaging things to
    make our code shorter, more approachable, and more sustainable. Templates were
    once the domain of backend servers. The next chapter will show you why you need
    to do less on the backend and more on the frontend than ever before!
  prefs: []
  type: TYPE_NORMAL
