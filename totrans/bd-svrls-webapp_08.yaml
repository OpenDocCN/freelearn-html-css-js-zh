- en: Securing the Serverless Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling security is an extensive and complex topic. If you don't do it right,
    you may be hacked. Even if you do everything right, you may be hacked. So it's
    important you understand the common security mechanisms to avoid exposing your
    website to vulnerabilities, and also, always follow the recommended practices
    and methodologies that have been largely tested and proven to be robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic security practices and concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use Amazon Cognito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the signup and login pages of the serverless store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling authorization and authentication of users in the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired basic knowledge on how to
    handle security on AWS to build a serverless website.
  prefs: []
  type: TYPE_NORMAL
- en: Security basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the mantras of security experts is this: *don''t roll your own*. It
    means you should never use in a production system any kind of crypto algorithm
    or security model that you developed by yourself. Always use solutions that have
    been highly used, tested, and recommended by trusted sources. Even experienced
    people may commit errors and expose a solution to attacks, especially in the cryptography
    field, which requires advanced math. However, when a proposed solution is analyzed
    and tested by a great number of specialists, errors are much less frequent.'
  prefs: []
  type: TYPE_NORMAL
- en: In the security world, there is a term called **security through obscurity**.
    It is defined as a security model where the implementation mechanism is not publicly
    known, so there is a belief that it is secure because no one has prior information
    about the flaws it has. It can be indeed secure, but if used as the only form
    of protection, it is considered as a poor security practice. If a hacker is persistent
    enough, he or she can discover flaws even without knowing the internal code. In
    this case again, it's better to use a highly tested algorithm than your own.
  prefs: []
  type: TYPE_NORMAL
- en: Security through obscurity can be compared to someone trying to protect their
    own money by burying it in the backyard when the common security mechanism would
    be to put the money in a bank. The money can be safe while buried, but it will
    be protected only until someone finds about its existence and starts to look for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this reason, when dealing with security, we usually prefer to use open
    source algorithms and tools. Everyone can access and discover flaws in them, but
    there are also a great number of specialists that are involved in finding the
    vulnerabilities and fixing them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss other security concepts that everyone must
    know when building a system.
  prefs: []
  type: TYPE_NORMAL
- en: Information security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with security, there are some attributes that need to be considered.
    The most important ones are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Confirm the user''s identity by validating that the user
    is who they claim to be'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Decide whether the user is allowed to execute the requested
    action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidentiality**: Ensure that data can''t be understood by third-parties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: Protect the message against undetectable modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-repudiation**: Ensure that someone can''t deny the authenticity of their
    own message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Keep the system available when needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These terms will be better explained in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the ability to confirm the user's identity. It can be implemented
    by a login form where you request the user to type their username and password.
    If the hashed password matches what was previously saved in the database, you
    have enough proof that the user is who they claim to be. This model is good enough,
    at least for typical applications. You confirm the identity by requesting the
    user to provide what *they know*. Another kind of authentication is to request
    the user to provide what *they have*. It can be a physical device (like a dongle)
    or access to an e-mail account or phone number.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can't ask the user to type their credentials for *every* request.
    As long as you *authenticate* it in the first request, you must create a security
    token that will be used in the subsequent requests. This token will be saved on
    the client side as a cookie and will be automatically sent to the server in allÂ requests.
  prefs: []
  type: TYPE_NORMAL
- en: On AWS, this token can be created using the Cognito service. How this is done
    will be described later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a request is received in the backend, we need to check if the user is allowed
    to execute the requested action. For example, if the user wants to checkout the
    order with ID `123`, we need to make a query to the database to identify who is
    the owner of the order and compare if it is the same user.
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario is when we have multiple roles in an application and we need
    to restrict data access. For example, a system developed to manage school grades
    may be implemented with two roles, such as `student` and `teacher`. The teacher
    will access the system to insert or update grades, while the students will access
    the system to read those grades. In this case, the authentication system must
    restrict the actions *insert* and *update* for users that are part of the *teachers*
    group and users in the *students* group must be restricted to *read* their own
    grades.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we handle authorization in our own backend, but some serverless
    services don't require a backend and they are responsible by themselves to properly
    check the authorization. For example, in the next chapter, we are going to see
    how serverless notifications are implemented on AWS. When we use AWS IoT, if we
    want a private channel of communication between two users, we must give them access
    to one specific resource known by both and restrict access to other users to avoid
    the disclosure of private messages. This kind of authorization will be detailed
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](274d8aba-8e7e-4c5e-b55b-a8e1797d3057.xhtml), *Hosting the Website*,
    we learned how to use AWS Certificate Manager to request TLS certificates for
    free and how to add them to CloudFront distributions. Developing a website that
    uses HTTPS for *all* requests is the main drive to achieve confidentiality in
    the communication between the users and your site. As the data is encrypted, it's
    very hard for malicious users to decrypt and understand its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are some attacks that can intercept the communication and forge
    certificates (man-in-the-middle), those require the malicious user to have access
    to the machine or network of the victim user. From our side, adding HTTPS support
    is the best thing that we can do to minimize the chance of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrity is related to confidentiality. While confidentiality relies on encrypting
    a message to prevent other users from accessing its contents, integrity deals
    with protecting the messages against modifications by encrypting messages with
    digital signatures (TLS certificates).
  prefs: []
  type: TYPE_NORMAL
- en: Integrity is an important concept when designing low level network systems,
    but all that matters for us is adding HTTPS support.
  prefs: []
  type: TYPE_NORMAL
- en: Non-repudiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-repudiation is a term that is often confused with authentication since both
    of them have the objective to prove who has sent the message. However, the main
    difference is that authentication is more interested in a technical view and the
    non-repudiation concept is interested in legal terms, liability, and auditing.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a login form with user and password input, you can authenticate
    the user who correctly knows the combination, but you can't have 100% certain
    since the credentials can be correctly guessed or stolen by a third-party. On
    the other hand, if you have a stricter access mechanism, such as a biometric entry,
    you have more credibility. However, this is not perfect either. It's just a better
    non-repudiation mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Availability is also a concept of interest in the information security field
    because availability is not restricted to how you provision your hardware to meet
    your user needs. Availability can suffer attacks and can suffer interruptions
    due to malicious users. There are attacks, such as **Distributed Denial of Service**
    (**DDoS**), that aim to create bottlenecks to disrupt site availability. In a
    DDoS attack, the targeted website is flooded with superfluous requests with the
    objective to overload the systems. This is usually accomplished by a controlled
    network of infected machines called a **botnet**.
  prefs: []
  type: TYPE_NORMAL
- en: On AWS, all services run under the AWS Shield service, which was designed to
    protect against DDoS attacks with no additional charge. However, if you run a
    very large and important service, you may be a direct target of advanced and large
    DDoS attacks. In this case, there is a premium tier offered in the AWS Shield
    service to ensure your website's availability even in worst case scenarios. This
    requires an investment of US$ 3,000 per month, and with this, you will have 24x7
    support of a dedicated team and access to other tools for mitigation and analysis
    of DDoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Security on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we use AWS credentials, roles, and policies, but security on AWS
    is much more than handling authentication and authorization of users. This is
    what we will discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Shared responsibility model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security on AWS is based on a shared responsibility model. While Amazon is responsible
    for keeping the infrastructure safe, the customers are responsible for patching
    security updates to software and protecting their own user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS''s responsibilities include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical security of the hardware and facilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure of networks, virtualization, and storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of services respecting **Service Level Agreements** (**SLAs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security of managed services such as Lambda, RDS, DynamoDB, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A customer''s responsibilities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying security patches to the operating system on EC2 machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security of installed applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding disclosure of user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correct configuration of access policies and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network traffic protection (encrypting data to avoid disclosure of sensitive
    information)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption of server-side data and databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the serverless model, we rely only on managed services. In this case, we
    don't need to worry about applying security patches to the operating system or
    runtime, but we do need to worry about third-party libraries that our application
    depends on to execute. Also, of course, we need to worry about all the things
    that we need to configure (firewalls, user policies, and so on), the network traffic
    (supporting HTTPS) and how data is manipulated by the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Trusted Advisor tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS offers a tool named Trusted Advisor, which can be accessed through [https://console.aws.amazon.com/trustedadvisor](https://console.aws.amazon.com/trustedadvisor).
  prefs: []
  type: TYPE_NORMAL
- en: It was created to offer help on how you can optimize costs or improve performance,
    but it also helps identify security breaches and common misconfigurations. It
    searches for unrestricted access to specific ports on your EC2 machines, if Multi-Factor
    Authentication is enabled on the root account and if IAM users were created in
    your account.
  prefs: []
  type: TYPE_NORMAL
- en: You need to pay for AWS premium support to unlock other features, such as cost
    optimization advice. However, security checks are free.
  prefs: []
  type: TYPE_NORMAL
- en: Pen testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A penetration test (or pen test) is a good practice that all big websites must
    perform periodically. Even if you have a good team of security experts, the usual
    recommendation is to hire a specialized third-party company to perform pen tests
    and to find vulnerabilities. This is because they will most likely have tools
    and procedures that your team may not have tried yet.
  prefs: []
  type: TYPE_NORMAL
- en: However, the caveat here is that you can't execute these tests without contacting
    AWS first. To respect their user terms, you can only try to find breaches on your
    own account and assets, in scheduled time frames (so they can disable their intrusion
    detection systems for your assets), and only on restricted services, such as EC2
    instances and RDS.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudTrail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CloudTrail is a service that was designed to record all AWS API calls that
    are executed on your account. The output of this service is a set of log files
    that register the API caller, the date/time, the source IP address of the caller,
    the request parameters, and the response elements that were returned.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of service is pretty important for security analysis, in case there
    are data breaches, and for systems that need the auditing mechanism for compliance
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: MFA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Multi-Factor Authentication** (**MFA**) is an extra security layer that everyone
    must add to their AWS root account to protect against unauthorized access. Besides
    knowing the user and password, a malicious user would also need physical access
    to your smartphone or security token, which greatly restricts the risks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On AWS, you can use MFA through the following means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual devices**: Application installed on Android, iPhone, or Windows phones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical devices**: Six-digit tokens or OTP cards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMS**: Messages received on your phone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to use Amazon Cognito to create the users for
    our application and to be able to handle their login. After authenticating the
    user, we will be able to give proper authorization for the tasks that they are
    allowed to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Cognito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cognito provides two services such as **User Pools** and **Identity Pools**.
    The first is where you create and store user credentials, the latter is where
    you set the permissions for the user to access AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a user pool, so we can add signup and signin features
    to our website. We will add the user pool ID to our frontend code and requests
    will be done directly to the User Pool service, without needing to be executed
    from a Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will configure an identity pool, which will be needed to give to the
    users temporary access to AWS resources. In our example, the user will be able
    to subscribe to IoT notifications directly, without requesting the backend to
    give this authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to create a user pool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a user pool, we will use the console, which can be accessed through
    [https://console.aws.amazon.com/cognito](https://console.aws.amazon.com/cognito).
    Select the Manage your User Pools option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d350df7-a3fe-417d-a42b-a7c9b00cf084.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create a User Pool on the next screen, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c443303-e8fd-4c6c-bd1e-c5d081e88644.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now define a pool name for your user pool resource and check whether you want
    fast creation (using defaults) or whether you want to step through each setting.
    I''ve selected the former (Review defaults):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf555eaf-d3f4-41eb-a31f-2f9f4d61fb0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen will be a list of defaults that you need to revise before hitting
    Create pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/145b7121-247e-437e-a4bf-2027f705f6d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a list of options and what you need to consider in each of
    them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attributes: This displays a list of user attributes that you can select as
    required options for login. Usually, only an e-mail is enough for most applications,
    but you can include attributes like username, phone number, or user picture. Also,
    you may set custom user attributes to be saved in your user profile.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Policies: This defines how strict the user''s password must be. For example,
    if you require a minimum length, special characters, and upper or lower cases.
    Also, you can restrict user creation by admins only.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Verifications: You can request the user to verify the ownership of the e-mail
    address or phone number (SMS) upon registering. Cognito will send a message with
    a code for validation. Also, you can enable MFA for your users as a second layer
    of security. This feature is very important nowadays to prevent accounts being
    hacked and is already implemented by Cognito, making it very easy to integrate
    with your application. You can enable MFA by e-mail or phone.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message customizations: This is related to the previous configuration where
    you can request users to validate their e-mails or phone numbers. The text of
    these messages is configurable here. Besides, you can set the e-mail messages
    to use your domain address, if it was already verified and configured in Amazon
    SES.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tags: This option is useful if you want to associate the user pool with a tag
    that will show up in your billing data. With this option, you can create a tag
    with a cost center or application name for better management of cost allocation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Devices: You can allow the device to be remembered for future accesses. This
    feature is useful as a convenience and you can also suppress MFA requests if the
    device has already been authenticated with MFA in the past.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apps: You need to create an application specification to restrict the applications
    that will be able to handle the login process and handle forgotten passwords for
    your application. This feature creates an application key and secret.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Triggers: You can trigger Lambda functions in pre-signup, pre-authentication,
    post authentication, create authorization challenge, and other options. Basically,
    you can have control of server-side procedures to handle the user authentication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After creating the user pool, you can see the assigned Pool Id and Pool ARN.
    Write down those values because they will be needed later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb5c1830-d1e5-4365-80c9-6ca88922ac3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is still one more thing before we complete this configuration. As we
    want our website to handle signup/signin, we need to create an application ID.
    Browse the App clients field to add an application for our website and uncheck
    the Generate client secret option, since this feature is not supported by the
    JavaScript SDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7dfe4806-0b9a-43d9-8e75-45743c2bca99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating theÂ app client, write down theÂ App client id:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f50673c-0234-4f38-a1c9-7c29d19c0f55.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an identity pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to create an identity pool. Let''s take a look in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to browse to the Federated Identities page that can be found
    in Cognito home or from the user pool that we have just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bae88957-e920-428e-bcf5-63d1f17ef604.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When creating a new identity pool, check the box Enable access to unauthenticated
    identities. We will configure later what resources an unsigned user can access,
    which will be different to the level of access that a signed user can have. Take
    a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba01fc26-87ff-4b04-824f-10569dcb2ec0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next field is to set the Authentication providers parameter. Cognito Identity
    Pool is an *authorization* service that needs to receive as input the users from
    an *authentication* service. In our example, we will use the Cognito User Pool
    that we have just created by filling out the User Pool ID and the App Client ID
    fields, but if you want, you can add support for other providers as well, such
    as Facebook, Google+, or Twitter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5308f479-2279-4520-96d2-6f66a47efb60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to configure the access of our authenticated and unauthenticated
    users. As an example, we could allow access to a folder of a S3 bucket to allow
    the user to directly upload photos from the website, without needing the backend
    to execute this action. In our serverless store, we need to handle notifications
    with IoT. So that''s what we are going to configure next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71a8de15-4c10-49fa-9140-668ec87a5bfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will need to edit the Policy Document option for both types (unauthenticated
    and authenticated). Start modifying the document for authenticated users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`iot:Connect` and `iot:AttachPrincipalPolicy` requires access to every resource
    (`*`), while we need to restrict the `iot:Subscribe` to a `topicfilter/<topic>`
    resource and the `iot:Publish` and `iot:Receive` to a `topic/<topic>`.'
  prefs: []
  type: TYPE_NORMAL
- en: When building the ARNs, replace the `<region>` with the region of the AWS IoT
    that you are going to use, `<account>` with your Account ID, `<public-topic>`
    with `serverless-store-comments` and `<private-topic>` with `serverless-store-${cognito-identity.amazonaws.com:sub}`.
    The private topic will allow the authenticated user to access a topic defined
    by their federated identity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For unauthenticated access, use the same policy document, but remove the extra
    ARN that was added for the private topic. You can also remove the `iot:AttachPrincipalPolicy`
    since it will not be necessary for unauthenticated users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After creating the identity pool, go to the Dashboard option and click on Edit
    identity pool. You will see the Identity pool ID option in this screen. Write
    it down because it will be needed later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c410e65d-ea69-4b0c-80e1-4deba79b7d60.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Cognito in our serverless store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to integrate our React frontend with Cognito to implement
    the signup and login pages. The authentication methods will be done directly with
    Cognito, without using a Lambda function for this. To make this work, we need
    to configure our React application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the module `amazon-cognito-identity-js` in our frontend folder
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `lib` folder, create a `config.js` file to store our Cognito IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in previous chapters, we have created a `services.js` file inside
    the `lib` folder to make all Ajax requests. We need to import the following from
    the Cognito module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we have prepared our frontend to use Cognito.
  prefs: []
  type: TYPE_NORMAL
- en: The Signup page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signup form was created in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*, and it has the appearance as shown in the this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38ca87f0-c359-426c-97fc-3e2937aff779.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to implement the handler for the Signup button by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a method in our `services.js` file that will execute a
    request to Cognito, invoking the `signUp` function that will use the e-mail and
    password provided by the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component will call this function and it will save the resulting
    user object in its state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering the user successfully, we need to re-render the signup component
    to display a confirmation request. The user will be asked to fill the text input
    with the value sent to their e-mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e57e23bc-c4fc-47ba-b592-11e35a82d889.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The request to Cognito will use the same `user` object that was returned in
    the signup result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the confirmation code is correct, we can use the e-mail and password that
    the user has provided and authenticate his access, without asking the user to
    type them again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to authenticate will be defined in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the Login page to authenticate users requires a few steps. Let''s
    see how this is done by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Login page was also created in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend* and it has this look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/46df45d0-e6b3-4986-8608-18f47145a2a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Login` button will trigger a request to Cognito defined in the `services.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This `login` function will be used by the `App` component. After signing successfully,
    we need to save `userToken` in the state of `App`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Persisting the user token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, the Cognito SDK will persist the user token automatically in the
    browser local storage. If the user browses your website again before the token
    expiration, the data will be there, available, without the need to request the
    user to type the e-mail/password again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This token can be retrieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Logging out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the user token is being persisted, we can check its existence in the `App`
    initialization (`componentDidMount`) and display a Logout button instead of a
    Login button in the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23081903-1f51-4f03-9bf4-98e5b23be6fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When clicking in this Logout button, we can clear the token executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Handling authentication in Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API Gateway has a nice integration with Cognito Pools for user authentication.
    We can configure it through the Serverless Framework to retrieve the user data
    from Cognito whenever a request with a token ID is provided. Let''s see how this
    is done by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `serverless.yml` file to use the Cognito User Pool authorizer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Include `Authorization` as a valid header when the Lambda function answer an
    `OPTIONS` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the backend again by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the frontend to always include theÂ `userToken`, if it is available,
    in an `Authorization` header by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have access to the user information in the backend. If we analyze the
    `event` object, we can retrieve the `userId` variable by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userId` term is a **Universally Unique Identifier** (**UUID**). An example
    of `userId` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `claims` object offers more user data, like the e-mail, using the `email`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the basic security concepts and how to apply
    them in a serverless project. For our demo application, we have used Amazon Cognito
    to handle the authentication and authorization of users, so you have learned how
    to implement signup, signin, and logout features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the Cognito credentials to access AWS IoT resources
    to handle serverless notifications. We will see how the backend can send messages
    to an authenticated user and how to provide real-time notifications to anonymous
    users.
  prefs: []
  type: TYPE_NORMAL
