- en: Chapter 5. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 安全
- en: In this chapter we will authenticate users using a GitHub account and **OAuth
    2.0** tokens. This will allow us to secure the site and support multiple users;
    currently we have a single hardcoded token and user. We will also add HTTPS to
    our site and explore some other modules that we can use to secure other common
    security vulnerabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用GitHub账户和**OAuth 2.0**令牌来认证用户。这将允许我们保护网站并支持多个用户；目前我们有一个硬编码的令牌和用户。我们还将向我们的网站添加HTTPS，并探索一些我们可以用来保护其他常见安全漏洞的模块。
- en: Setting up Passport
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Passport
- en: Passport is an authentication middleware for node that supports; via plugin;
    multiple authentication strategies, including Basic Auth, OAuth, and OAuth 2\.
    Passport works by defining a route middleware to be used to authenticate the request.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Passport是Node的认证中间件，通过插件支持多种认证策略，包括基本认证、OAuth和OAuth 2.。Passport通过定义一个用于认证请求的路由中间件来工作。
- en: 'Let''s install Passport:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Passport：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Passport does not include a GitHub strategy; for this we need to install `passport-github`;
    a strategy for authenticating with GitHub using the OAuth 2.0 API:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Passport不包含GitHub策略；为此我们需要安装`passport-github`；这是一个使用OAuth 2.0 API进行GitHub身份验证的策略：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Acceptance testing with Cucumber and Zombie.js
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cucumber和Zombie.js进行验收测试
- en: OAuth authentication uses a callback mechanism; this is messy to test with an
    integration-testing tool such as SuperTest; we require something a little more
    end-to-end.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth认证使用回调机制；这对于使用SuperTest等集成测试工具进行测试来说很麻烦；我们需要一点更端到端的东西。
- en: 'Cucumber allows teams to describe software behavior in a simple plain text
    language called **Gherkin** . The process of describing this behavior aids development;
    the output serves as documentation that can be automated to run as a set of tests.
    Let''s install cucumber:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber允许团队使用一种简单的纯文本语言**Gherkin**来描述软件行为。描述此行为的流程有助于开发；输出作为文档，可以作为一系列测试自动运行。让我们安装cucumber：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Zombie.js is simple, lightweight framework for doing headless full-stack testing.
    Let''s install `Zombie.js`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Zombie.js是一个用于进行无头全栈测试的简单、轻量级框架。让我们安装`Zombie.js`：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s automate running Cucumber with a grunt task:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Grunt任务自动化运行Cucumber：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following to our gruntfile `./gruntfile.js`. The section `files` defines
    the location of our feature files, and `options:steps` defines the location of
    our step definitions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到我们的`gruntfile` `./gruntfile.js`中。`files`部分定义了我们的特征文件的位置，而`options:steps`定义了我们的步骤定义文件的位置：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Feature: Authentication'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：认证
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's create our first feature file `./features/authentication.feature`. The
    following feature file contains a `Feature` section, which for the agile among
    you will know that it defines the story and its value to the business, and a list
    of scenarios. Our acceptance criteria; written in the Gherkin language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个特征文件`./features/authentication.feature`。以下特征文件包含一个`Feature`部分，对于敏捷开发人员来说，这将定义故事及其对业务的价值，以及一系列场景。我们的验收标准；用Gherkin语言编写。
- en: 'The following `Authenticate` feature contains two scenarios, including one
    to log in, titled `User logs in successfully`, and one to log out, titled `User
    logs out successfully`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Authenticate`功能包含两个场景，包括一个用于登录，标题为`用户成功登录`，以及一个用于登出，标题为`用户成功登出`：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s run Cucumber using our grunt task:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的Grunt任务运行Cucumber：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will generate the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the preceding output, you can see that Cucumber has generated a series
    of stubbed steps that are set to `pending`. These steps represent the `Given`,
    `When`, and `Then` scenarios we defined in our feature file `./features/authentication/authentication.feature`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，你可以看到Cucumber生成了一系列设置为`pending`的存根步骤。这些步骤代表我们在`./features/authentication/authentication.feature`特征文件中定义的`Given`、`When`和`Then`场景。
- en: 'We can use these steps to implement our Cucumber tests. Let''s create a step
    definition file `./features/step_definitions/authentication/authenticate.js`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些步骤来实现我们的Cucumber测试。让我们创建一个步骤定义文件`./features/step_definitions/authentication/authenticate.js`：
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run Cucumber using our grunt task:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的Grunt任务运行Cucumber：
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We get the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are now ready to begin implementing our first scenario.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始实现我们的第一个场景。
- en: 'Scenario: User logs in successfully'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景：用户成功登录
- en: Let's begin implementing this scenario. First, we need a GitHub `clientId` and
    `clientSecret`. Visit your GitHub account, click on **Settings** and then **Applications**
    and again on **Register New Application.** Complete the form by adding the `homepage`
    URL and the `callback` URL (same as our homepage), and a `clientId` and a `clientSecret`
    will be generated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现这个场景。首先，我们需要一个GitHub `clientId`和`clientSecret`。访问您的GitHub账户，点击**设置**然后**应用程序**，再次点击**注册新应用程序**。通过添加`homepage`
    URL和`callback` URL（与我们的主页相同）来填写表单，并将生成一个`clientId`和`clientSecret`。
- en: 'Let''s add these details to our config files `./config/*.json`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些详细信息添加到我们的配置文件`./config/*.json`中：
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s remove the temporary login we set up in [Chapter 2](ch02.html "Chapter 2. Building
    a Web API"), *Building a Web API*, and remove the following line and all code
    related to it `./lib/routes/project.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除在[第2章](ch02.html "第2章。构建Web API")中设置的临时登录，*构建Web API*，并移除以下行及其所有相关代码`./lib/routes/project.js`：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are now ready to implement our GitHub strategy `./lib/github/authentication.js`.
    We start by defining a function, `GitHubAuth`; we import the `passport` and `passport-github`
    modules. We instantiate a `GitHubStrategy`, add it to `passport`, and pass a `clientID`,
    `clientSecret`, a `callbackUrl`, and a `verify` function (all passport strategies
    require a verify function), that is called when GitHub authenticates passing back
    an `accessToken`, `refreshToken`, and a `profile`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好实现我们的GitHub策略`./lib/github/authentication.js`。我们首先定义一个函数`GitHubAuth`；我们导入`passport`和`passport-github`模块。我们实例化一个`GitHubStrategy`，将其添加到`passport`中，并传递一个`clientID`、`clientSecret`、一个`callbackUrl`和一个`verify`函数（所有passport策略都需要一个验证函数），当GitHub进行身份验证并返回一个`accessToken`、`refreshToken`和一个`profile`时，该函数将被调用。
- en: Inside this verify function, we have the option of rejecting the user by passing
    a false out of the `callback` function. We will accept anyone with a GitHub access
    token; so simply pass back a user profile; which we create using the profile GitHub
    passed to us. Within the verify function, we instantiate a `GitHubRepo` and call
    `updateTokens`, which updates their access tokens for use by our Redis cache population.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个验证函数内部，我们有通过从`callback`函数传递一个`false`来拒绝用户的选择。我们将接受任何拥有GitHub访问令牌的人；因此只需返回一个用户资料；我们使用GitHub传递给我们的资料创建它。在验证函数内部，我们实例化一个`GitHubRepo`并调用`updateTokens`，这将更新它们的访问令牌，以便用于我们的Redis缓存填充。
- en: 'Our application will support user sessions, so we add two functions to the
    `passport` module, that include `serializeUser` and `deserializeUser`, which serialize
    and deserializes the GitHub user profile into and out of a user session:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将支持用户会话，因此我们在`passport`模块中添加两个函数，包括`serializeUser`和`deserializeUser`，这些函数将GitHub用户资料序列化和反序列化到用户会话中：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s add an `updateTokens` function to `GitHubRepo`, which gets all of a
    users'' projects and `async.each` through `each` one updating its token:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`GitHubRepo`中添加一个`updateTokens`函数，该函数获取所有用户的工程并通过`async.each`遍历每个工程来更新其令牌：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s add configuration to our config files `./config/*.json`, in order to
    support Express sessions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在配置文件`./config/*.json`中添加配置，以支持Express会话：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s wire up our GitHub strategy to our Express server: `./lib/express/index.js`.
    The first change we make it to include our new GitHub `authentication` strategy:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将GitHub策略连接到我们的Express服务器：`./lib/express/index.js`。我们做的第一个更改是包含我们新的GitHub
    `authentication`策略：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We create a `cookieParser` middleware and include it just before the `bodyParser`
    middleware, which will parse the cookie header field and populate `req.cookies`.
    We pass a `secret`; which is a string used to create a signed cookie enabling
    the detection of a modified cookie:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`cookieParser`中间件，并将其包含在`bodyParser`中间件之前，这将解析cookie头字段并填充`req.cookies`。我们传递一个`secret`；这是一个用于创建签名cookie的字符串，以便检测修改过的cookie：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The application will require persistent login sessions, so we will include
    the connect `session` middleware in our Express server in order to provide session
    support. We will use the `sessionStore`, which is an in-memory session store.
    We pass in a `secret` and a value for a cookie `maxAge` (a null value will expire
    the session on closing the browser), `httpOnly` (disallow client-side JavaScript
    access to cookies; XSS attacks), and `secure` (send cookies over HTTPS only):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将需要持久登录会话，因此我们将`connect` `session`中间件包含在我们的Express服务器中，以提供会话支持。我们将使用`sessionStore`，这是一个内存中的会话存储。我们传递一个`secret`和一个用于cookie的`maxAge`值（一个null值将在关闭浏览器时使会话过期），`httpOnly`（不允许客户端JavaScript访问cookie；XSS攻击），以及`secure`（仅通过HTTPS发送cookie）：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Passport module requires we call `passport.initialize()` in order to initialize
    `passport`, and in order to provide session support, we must also call the `passport.session()`
    middleware; we add both to our Express server:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 模块要求我们调用 `passport.initialize()` 以初始化 `passport`，并且为了提供会话支持，我们还必须调用
    `passport.session()` 中间件；我们将两者都添加到我们的 Express 服务器中：
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now define the first of two routes on our Express server; both use the passport
    strategy for GitHub. The first route is a login route `/auth/github`; hitting
    this route will redirect you to GitHub and try to authenticate. If you are not
    logged in to GitHub, you will be asked to log in. If you are doing this for the
    first time, you will be prompted. You will be asked if you would like to grant
    Vision access. The second route; is the route GitHub will callback when authentication
    is complete:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义我们的 Express 服务器上的第一个两个路由；两者都使用 GitHub 策略。第一个路由是登录路由 `/auth/github`；访问此路由将重定向您到
    GitHub 并尝试进行身份验证。如果您未登录到 GitHub，您将被要求登录。如果您是第一次这样做，您将收到提示。您将被询问是否希望授予 Vision 访问权限。第二个路由是
    GitHub 在身份验证完成后将回调的路由：
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have configured our Express server with a GitHub passport strategy. Let''s
    add the two missing routes to our routes, `./lib/routes/auth.js`; one for login
    and one for the callback as described previously:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 GitHub passport 策略配置了我们的 Express 服务器。现在让我们向 `./lib/routes/auth.js` 中的路由添加两个缺失的路由：一个用于登录，另一个用于回调，正如之前所描述的：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In order to simulate the body of our project form containing a `user` and `token`,
    we will add a middleware that simply adds this data to the form for an authenticated
    user. We can add the `projectForm.addToken` middleware to all of our routes easily
    by using `app.all`, which will apply this middleware to all routes that follow
    it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的项目表单包含一个 `user` 和 `token` 的主体，我们将添加一个中间件，该中间件简单地为此数据添加到已认证用户的表单中。我们可以通过使用
    `app.all` 简单地添加 `projectForm.addToken` 中间件到所有我们的路由中，这将应用此中间件到所有后续的路由。
- en: 'Let''s make a further change to our Express server: `./lib/express/index.js`,
    and clean up our middleware by removing all require statements involving it and
    using `require-directory` with an `./lib/middleware/index.js` file, as we did
    with our routes. We can now add this `projectForm` above all the routes that require
    authentication:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的 Express 服务器进行进一步更改：`./lib/express/index.js`，并通过移除涉及它的所有 require 语句和使用
    `require-directory` 与 `./lib/middleware/index.js` 文件来清理我们的中间件，就像我们对路由所做的那样。现在我们可以在所有需要身份验证的路由之上添加此
    `projectForm`：
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s create the `projectForm.addToken` middleware in `./lib/middleware/projectForm.js`.
    The `AddToken` middleware checks if the request is authenticated via `req.isAuthenticated`;
    we add `user` and `token` to the request:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `./lib/middleware/projectForm.js` 中创建 `projectForm.addToken` 中间件。`AddToken`
    中间件检查请求是否通过 `req.isAuthenticated` 进行了身份验证；我们将 `user` 和 `token` 添加到请求中：
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have authentication in place, let''s remove the hardcoded user
    in `./lib/routes/home.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了身份验证，让我们从 `./lib/routes/home.js` 中移除硬编码的用户：
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now when we click on the GitHub logo in our header, we are redirected to GitHub
    which will ask you to log in. Once you have logged in to GitHub, you must grant
    access to our Vision application; however, future attempts to log in will not
    require you to grant access to Vision.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们点击页眉中的 GitHub 标志，我们将被重定向到 GitHub，它将要求您登录。一旦您登录到 GitHub，您必须授权我们的 Vision 应用程序；然而，未来的登录尝试将不需要您授权
    Vision。
- en: 'Let''s complete our Cucumber steps for login using Zombie.js. `./features/step_definitions/authentication/authenticate.js`.
    First, we include zombie and and define a `steps` function. Then, we set `silent`
    and `debug` to enable Zombie.js debugging output. We define `Given = When = Then`
    as Cucumber steps and add a `Before` step, which runs before each test. From here
    we instantiate a zombie `Browser`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Zombie.js 完成我们的 Cucumber 登录步骤。`./features/step_definitions/authentication/authenticate.js`。首先，我们包含
    zombie 并定义一个 `steps` 函数。然后，我们将 `silent` 和 `debug` 设置为启用 Zombie.js 调试输出。我们定义 `Given
    = When = Then` 作为 Cucumber 步骤，并添加一个 `Before` 步骤，该步骤在每个测试之前运行。从这里我们实例化一个 zombie
    `Browser`：
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The step `I have a GitHub Account` uses the zombie browser to visit the GitHub
    login page, and waits for the page to load and fill in the login details; we then
    click on the sign in button:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 `I have a GitHub Account` 使用 zombie 浏览器访问 GitHub 登录页面，并等待页面加载并填写登录详细信息；然后我们点击登录按钮：
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The step `I click the GitHub authentication button` uses the zombie browser
    to visit the GitHub login page and waits for the page to load and fill in the
    login details; we then click on the sign in button:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我点击GitHub认证按钮`使用Zombie浏览器访问GitHub登录页面，等待页面加载并填写登录详细信息；然后我们点击登录按钮：
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The step `I should be logged in` uses the zombie browser to visit the GitHub
    login page and waits for the page to load and fill in the login details; we then
    click on the sign in button:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我应该已登录`使用Zombie浏览器访问GitHub登录页面，等待页面加载并填写登录详细信息；然后我们点击登录按钮：
- en: '[PRE30]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The step `I should see my name and a logout link` uses the zombie browser to
    visit the GitHub login page and waits for the page to load and fill in the login
    details; we then click on the sign in button:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我应看到我的名字和一个登出链接`使用Zombie浏览器访问GitHub登录页面，等待页面加载并填写登录详细信息；然后我们点击登录按钮：
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Scenario: User logs out successfully'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景：用户成功登出
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s add a logout route to our Express server: `./lib/express/index.js`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Express服务器中添加一个登出路由：`./lib/express/index.js`：
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now add the route to our routes: `./lib/routes/auth.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将路由添加到我们的路由中：`./lib/routes/auth.js`：
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's complete our Cucumber steps for logout using Zombie.js in `./features/step_definitions/authentication/authenticate.js`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`./features/step_definitions/authentication/authenticate.js`中使用Zombie.js完成我们的登出步骤。
- en: 'The step `I am logged in to Vision` uses the zombie browser to visit the Vision
    home page, waits for the page to load, and clicks on the login link:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我已登录到Vision`使用Zombie浏览器访问Vision主页，等待页面加载，并点击登录链接：
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The step `I click the logout button` uses the zombie browser to visit the Vision
    home page, waits for the page to load, and clicks on the logout link:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我点击登出按钮`使用Zombie浏览器访问Vision主页，等待页面加载，并点击登出链接：
- en: '[PRE36]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The step `I should see the GitHub login button` checks to see if the browser
    response returns a `success`, and then checks to see if the GitHub login link
    is accessible:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤`我应该看到GitHub登录按钮`检查浏览器响应是否返回`成功`，然后检查GitHub登录链接是否可访问：
- en: '[PRE37]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Securing our site with HTTPS
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS保护我们的站点
- en: 'In order to make our site secure, we will run the entire application under
    HTTPS. We will need two files: a PEM encoded SSL certificate `./lib/secure/cert.pem`,
    and a private key `./lib/secure/key.pem`. In order to create an SSL certificate,
    we first need to generate a private key and a certificate signing request (CSR).
    For development purposes, we will create a self-signed certificate. Run the following
    commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的站点安全，我们将整个应用程序运行在HTTPS下。我们需要两个文件：一个PEM编码的SSL证书`./lib/secure/cert.pem`和一个私钥`./lib/secure/key.pem`。为了创建SSL证书，我们首先需要生成一个私钥和证书签名请求（CSR）。出于开发目的，我们将创建一个自签名证书。运行以下命令：
- en: '[PRE38]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Upon running the second command, you will enter an interactive prompt to generate
    a 2048-bit RSA private key and a certificate signing request (CSR). You will need
    to enter various pieces of information including address details, common name
    or domain name, company details, and an email address.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行第二个命令后，你将进入一个交互式提示，以生成2048位的RSA私钥和证书签名请求（CSR）。你需要输入包括地址详情、通用名称或域名、公司详情和电子邮件地址在内的各种信息。
- en: 'Let''s add a module, `./lib/express/server.js`, that will create a HTTP server
    based on the `key`/`cert` we have just created. We import the `https` module,
    read the `key` and `cert` files from disk, and add them to a options object. Then
    using the `https` module, we create a server passing in these options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个模块，`./lib/express/server.js`，它将基于我们刚刚创建的`key`/`cert`创建一个HTTP服务器。我们导入`https`模块，从磁盘读取`key`和`cert`文件，并将它们添加到选项对象中。然后使用`https`模块，我们创建一个服务器，传入这些选项：
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s use the `server` from within our Express server `./lib/express/index.js`;
    remove the line that creates our HTTP server:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Express服务器`./lib/express/index.js`中使用`server`；删除创建我们的HTTP服务器的行：
- en: '[PRE40]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Replace it with a call to our new HTTPS server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用对新的HTTPS服务器的调用替换它：
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to replace all references to `http://127.0.0.1:3000`; port 3000
    with `https://127.0.0.1:8443`; port 8443\. Our config file contains two references:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将所有对`http://127.0.0.1:3000`；端口3000的引用替换为`https://127.0.0.1:8443`；端口8443。我们的配置文件包含两个引用：
- en: '[PRE42]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have a further reference in our `backbone.js` script `./public/components/vision.js`.
    When connecting to our Socket.IO server, we pass a URL `127.0.0.1:3000`. We make
    another important change here; we pass an options object when connecting to Socket.IO
    with the setting `secure: true, port: ''8443''`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的 `backbone.js` 脚本 `./public/components/vision.js` 中，我们有一个进一步的参考。当我们连接到我们的
    Socket.IO 服务器时，我们传递一个 URL `127.0.0.1:3000`。在这里，我们进行了另一个重要的更改；我们连接到 Socket.IO 时传递一个选项对象，设置
    `secure: true, port: ''8443''`：'
- en: '[PRE43]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Sharing Express sessions with Socket.IO
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Socket.IO 共享 Express 会话
- en: 'Now that we have session support in place, we can share the session with Socket.IO
    allowing us to accept or reject the connection based on this session data. Express
    and Socket.IO do this using a handshake mechanism. When a client connects to the
    server, the handshake is initiated, which consists of executing an authorization
    function on Socket.IO. Here, the cookie associated with the handshake request
    is examined and rejected if invalid. Let''s install `session.socket.io`; a module
    that has wrapped up this process:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了会话支持，我们可以通过 Socket.IO 共享会话，这样我们就可以根据这些会话数据接受或拒绝连接。Express 和 Socket.IO
    使用握手机制来完成此操作。当客户端连接到服务器时，握手被启动，它包括在 Socket.IO 上执行授权函数。在这里，检查与握手请求关联的 cookie，如果无效则拒绝。让我们安装
    `session.socket.io`；这是一个封装了此过程的模块：
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First off, let''s change our Express server, `./lib/express/index.js`, and
    pass to our `SocketHandler` module the `sessionStore` and the `cookieParser`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更改我们的 Express 服务器 `./lib/express/index.js`，并将 `sessionStore` 和 `cookieParser`
    传递给我们的 `SocketHandler` 模块：
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `SocketHandler` module now accepts the parameters `httpServer`, `sessionStore`,
    and `cookieParser`. The `SocketHandler` will now instantiate a `SessionSockets`
    module passing `socketIo`, the `sessionStore` module, and the `cookieParser`.
    We change the `connection` event to listen on the `SessionSockets` module instead
    of the `socket.Io` module so that we can access the `session`. Now from within
    the `subscribe` event, we can check to ensure the `session.passport.user` is valid.
    We call `session.touch` which updates the `maxAge` and `lastAccess` properties
    of a session:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SocketHandler` 模块现在接受参数 `httpServer`、`sessionStore` 和 `cookieParser`。`SocketHandler`
    现在将实例化一个 `SessionSockets` 模块，传递 `socketIo`、`sessionStore` 模块和 `cookieParser`。我们将
    `connection` 事件更改为监听 `SessionSockets` 模块而不是 `socket.Io` 模块，这样我们就可以访问 `session`。现在，在
    `subscribe` 事件内部，我们可以检查以确保 `session.passport.user` 是有效的。我们调用 `session.touch`，它更新会话的
    `maxAge` 和 `lastAccess` 属性：'
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Cross-site request forgery
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '**Cross-site request forgery** (**CRSF**) is an attack that tricks the victim
    into executing malicious actions on a web application in which they are authenticated.
    Connect/Express comes packaged with a Cross-site request forgery protection middleware.
    This middleware allows us to ensure that a request to a mutate state is from a
    valid source. The CRSF middleware creates a token that is stored in the requests
    session as `_csrf`. A request to our Express server will then need to pass the
    token in the header field `X-CSRF-Token`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造** (**CSRF**) 是一种攻击，它欺骗受害者在一个他们已经认证的 Web 应用程序上执行恶意操作。Connect/Express
    随包装提供了跨站请求伪造保护中间件。此中间件允许我们确保对更改状态的请求来自有效源。CSRF 中间件创建一个存储在请求会话中的令牌作为 `_csrf`。然后，我们的
    Express 服务器请求需要通过头部字段 `X-CSRF-Token` 传递令牌。'
- en: Let's create a security `./lib/security/index.js` module that adds the `csrf`
    middleware to our application. We define a function, `Security`, that takes an
    Express `app` as an argument and removes the middleware when in `TEST` or `COVERAGE`
    mode.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个安全模块 `./lib/security/index.js`，该模块将 `csrf` 中间件添加到我们的应用程序中。我们定义一个函数，`Security`，它接受一个
    Express `app` 作为参数，并在 `TEST` 或 `COVERAGE` 模式下移除中间件。
- en: '[PRE47]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s make a change to our Express server `./lib/express/index.js`. The `crsf`
    middleware requires session support, so we add the following line below the `session`
    and `passport` middleware:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改我们的 Express 服务器 `./lib/express/index.js`。`crsf` 中间件需要会话支持，所以我们添加以下行在 `session`
    和 `passport` 中间件下方：
- en: '[PRE48]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we are using `backbone.js` that uses jQuery under the hood to make AJAX
    requests, we will need to make a change to our backbone code `./public/components/vision/vision.js`.
    We will now override the `Backbone.sync` function, so that all requests through
    it pass the `X-CSRF-Token` in the header. The `X-CSRF-Token` is pulled from a
    `meta` tag in the master page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 `backbone.js`，它底层使用 jQuery 来发送 AJAX 请求，因此我们需要更改我们的 backbone 代码 `./public/components/vision/vision.js`。我们现在将覆盖
    `Backbone.sync` 函数，以便所有通过它的请求都在头部传递 `X-CSRF-Token`。`X-CSRF-Token` 从主页面中的 `meta`
    标签中提取：
- en: '[PRE49]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to pass the `X-CSRF-Token` to our master page via the master page
    route. The token is stored in the requests session as `_csrf`, in the following
    code we add the token to `csrftoken` in our view object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过主页面路由将 `X-CSRF-Token` 传递给我们的主页面。令牌存储在请求会话中作为 `_csrf`，在以下代码中我们将令牌添加到我们的视图对象的
    `csrftoken` 中：
- en: '[PRE50]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `csrftoken` is rendered in our master page in a `meta` tag called `csrf-token`;
    the backbone sync method will put it from this meta tag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`csrftoken` 在我们的主页面中以名为 `csrf-token` 的 `meta` 标签中渲染；骨干同步方法将从此 `meta` 标签中获取它：'
- en: '[PRE51]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Improving security with HTTP headers and helmet
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 头和 helmet 提高安全性
- en: Helmet is a collection of middleware that implements various security headers
    for Express; for more information on helmet visit [https://npmjs.org/package/helmet](https://npmjs.org/package/helmet).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet 是一系列中间件，用于为 Express 实现各种安全头；有关 helmet 的更多信息，请访问 [https://npmjs.org/package/helmet](https://npmjs.org/package/helmet)。
- en: 'Helmet supports the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet 支持以下功能：
- en: csp (Content Security Policy)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: csp (内容安全策略)
- en: HSTS (HTTP Strict Transport Security)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HSTS (HTTP Strict Transport Security)
- en: xframe (X-FRAME-OPTIONS)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xframe (X-FRAME-OPTIONS)
- en: iexss (X-XSS-PROTECTION for IE8+)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iexss (X-XSS-PROTECTION for IE8+)
- en: contentTypeOptions (X-Content-Type-Options nosniff)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: contentTypeOptions (X-Content-Type-Options nosniff)
- en: cacheControl (Cache-Control no-store, no-cache)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cacheControl (Cache-Control no-store, no-cache)
- en: 'Let''s extend our security `./lib/security/index.js` module, and add helmet
    security for the previous issues:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的安全模块 `./lib/security/index.js`，并为之前的问题添加 helmet 安全：
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By default, Express uses in-memory sessions. In the next chapter we will move
    our sessions to Redis. We will also configure Socket.IO to use Redis and explore
    some other interesting ways of scaling Express.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express 使用内存中的会话。在下一章中，我们将我们的会话移动到 Redis。我们还将配置 Socket.IO 以使用 Redis，并探索一些其他有趣的扩展
    Express 的方法。
