- en: Chapter 5. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will authenticate users using a GitHub account and **OAuth
    2.0** tokens. This will allow us to secure the site and support multiple users;
    currently we have a single hardcoded token and user. We will also add HTTPS to
    our site and explore some other modules that we can use to secure other common
    security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passport is an authentication middleware for node that supports; via plugin;
    multiple authentication strategies, including Basic Auth, OAuth, and OAuth 2\.
    Passport works by defining a route middleware to be used to authenticate the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Passport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Passport does not include a GitHub strategy; for this we need to install `passport-github`;
    a strategy for authenticating with GitHub using the OAuth 2.0 API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Acceptance testing with Cucumber and Zombie.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth authentication uses a callback mechanism; this is messy to test with an
    integration-testing tool such as SuperTest; we require something a little more
    end-to-end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cucumber allows teams to describe software behavior in a simple plain text
    language called **Gherkin** . The process of describing this behavior aids development;
    the output serves as documentation that can be automated to run as a set of tests.
    Let''s install cucumber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Zombie.js is simple, lightweight framework for doing headless full-stack testing.
    Let''s install `Zombie.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s automate running Cucumber with a grunt task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to our gruntfile `./gruntfile.js`. The section `files` defines
    the location of our feature files, and `options:steps` defines the location of
    our step definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature: Authentication'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's create our first feature file `./features/authentication.feature`. The
    following feature file contains a `Feature` section, which for the agile among
    you will know that it defines the story and its value to the business, and a list
    of scenarios. Our acceptance criteria; written in the Gherkin language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Authenticate` feature contains two scenarios, including one
    to log in, titled `User logs in successfully`, and one to log out, titled `User
    logs out successfully`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run Cucumber using our grunt task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can see that Cucumber has generated a series
    of stubbed steps that are set to `pending`. These steps represent the `Given`,
    `When`, and `Then` scenarios we defined in our feature file `./features/authentication/authentication.feature`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these steps to implement our Cucumber tests. Let''s create a step
    definition file `./features/step_definitions/authentication/authenticate.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run Cucumber using our grunt task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to begin implementing our first scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: User logs in successfully'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin implementing this scenario. First, we need a GitHub `clientId` and
    `clientSecret`. Visit your GitHub account, click on **Settings** and then **Applications**
    and again on **Register New Application.** Complete the form by adding the `homepage`
    URL and the `callback` URL (same as our homepage), and a `clientId` and a `clientSecret`
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these details to our config files `./config/*.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove the temporary login we set up in [Chapter 2](ch02.html "Chapter 2. Building
    a Web API"), *Building a Web API*, and remove the following line and all code
    related to it `./lib/routes/project.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to implement our GitHub strategy `./lib/github/authentication.js`.
    We start by defining a function, `GitHubAuth`; we import the `passport` and `passport-github`
    modules. We instantiate a `GitHubStrategy`, add it to `passport`, and pass a `clientID`,
    `clientSecret`, a `callbackUrl`, and a `verify` function (all passport strategies
    require a verify function), that is called when GitHub authenticates passing back
    an `accessToken`, `refreshToken`, and a `profile`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this verify function, we have the option of rejecting the user by passing
    a false out of the `callback` function. We will accept anyone with a GitHub access
    token; so simply pass back a user profile; which we create using the profile GitHub
    passed to us. Within the verify function, we instantiate a `GitHubRepo` and call
    `updateTokens`, which updates their access tokens for use by our Redis cache population.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will support user sessions, so we add two functions to the
    `passport` module, that include `serializeUser` and `deserializeUser`, which serialize
    and deserializes the GitHub user profile into and out of a user session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an `updateTokens` function to `GitHubRepo`, which gets all of a
    users'' projects and `async.each` through `each` one updating its token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add configuration to our config files `./config/*.json`, in order to
    support Express sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wire up our GitHub strategy to our Express server: `./lib/express/index.js`.
    The first change we make it to include our new GitHub `authentication` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `cookieParser` middleware and include it just before the `bodyParser`
    middleware, which will parse the cookie header field and populate `req.cookies`.
    We pass a `secret`; which is a string used to create a signed cookie enabling
    the detection of a modified cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will require persistent login sessions, so we will include
    the connect `session` middleware in our Express server in order to provide session
    support. We will use the `sessionStore`, which is an in-memory session store.
    We pass in a `secret` and a value for a cookie `maxAge` (a null value will expire
    the session on closing the browser), `httpOnly` (disallow client-side JavaScript
    access to cookies; XSS attacks), and `secure` (send cookies over HTTPS only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Passport module requires we call `passport.initialize()` in order to initialize
    `passport`, and in order to provide session support, we must also call the `passport.session()`
    middleware; we add both to our Express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define the first of two routes on our Express server; both use the passport
    strategy for GitHub. The first route is a login route `/auth/github`; hitting
    this route will redirect you to GitHub and try to authenticate. If you are not
    logged in to GitHub, you will be asked to log in. If you are doing this for the
    first time, you will be prompted. You will be asked if you would like to grant
    Vision access. The second route; is the route GitHub will callback when authentication
    is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have configured our Express server with a GitHub passport strategy. Let''s
    add the two missing routes to our routes, `./lib/routes/auth.js`; one for login
    and one for the callback as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In order to simulate the body of our project form containing a `user` and `token`,
    we will add a middleware that simply adds this data to the form for an authenticated
    user. We can add the `projectForm.addToken` middleware to all of our routes easily
    by using `app.all`, which will apply this middleware to all routes that follow
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a further change to our Express server: `./lib/express/index.js`,
    and clean up our middleware by removing all require statements involving it and
    using `require-directory` with an `./lib/middleware/index.js` file, as we did
    with our routes. We can now add this `projectForm` above all the routes that require
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `projectForm.addToken` middleware in `./lib/middleware/projectForm.js`.
    The `AddToken` middleware checks if the request is authenticated via `req.isAuthenticated`;
    we add `user` and `token` to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have authentication in place, let''s remove the hardcoded user
    in `./lib/routes/home.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now when we click on the GitHub logo in our header, we are redirected to GitHub
    which will ask you to log in. Once you have logged in to GitHub, you must grant
    access to our Vision application; however, future attempts to log in will not
    require you to grant access to Vision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete our Cucumber steps for login using Zombie.js. `./features/step_definitions/authentication/authenticate.js`.
    First, we include zombie and and define a `steps` function. Then, we set `silent`
    and `debug` to enable Zombie.js debugging output. We define `Given = When = Then`
    as Cucumber steps and add a `Before` step, which runs before each test. From here
    we instantiate a zombie `Browser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I have a GitHub Account` uses the zombie browser to visit the GitHub
    login page, and waits for the page to load and fill in the login details; we then
    click on the sign in button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I click the GitHub authentication button` uses the zombie browser
    to visit the GitHub login page and waits for the page to load and fill in the
    login details; we then click on the sign in button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I should be logged in` uses the zombie browser to visit the GitHub
    login page and waits for the page to load and fill in the login details; we then
    click on the sign in button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I should see my name and a logout link` uses the zombie browser to
    visit the GitHub login page and waits for the page to load and fill in the login
    details; we then click on the sign in button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Scenario: User logs out successfully'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a logout route to our Express server: `./lib/express/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the route to our routes: `./lib/routes/auth.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's complete our Cucumber steps for logout using Zombie.js in `./features/step_definitions/authentication/authenticate.js`
  prefs: []
  type: TYPE_NORMAL
- en: 'The step `I am logged in to Vision` uses the zombie browser to visit the Vision
    home page, waits for the page to load, and clicks on the login link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I click the logout button` uses the zombie browser to visit the Vision
    home page, waits for the page to load, and clicks on the logout link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The step `I should see the GitHub login button` checks to see if the browser
    response returns a `success`, and then checks to see if the GitHub login link
    is accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Securing our site with HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our site secure, we will run the entire application under
    HTTPS. We will need two files: a PEM encoded SSL certificate `./lib/secure/cert.pem`,
    and a private key `./lib/secure/key.pem`. In order to create an SSL certificate,
    we first need to generate a private key and a certificate signing request (CSR).
    For development purposes, we will create a self-signed certificate. Run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Upon running the second command, you will enter an interactive prompt to generate
    a 2048-bit RSA private key and a certificate signing request (CSR). You will need
    to enter various pieces of information including address details, common name
    or domain name, company details, and an email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a module, `./lib/express/server.js`, that will create a HTTP server
    based on the `key`/`cert` we have just created. We import the `https` module,
    read the `key` and `cert` files from disk, and add them to a options object. Then
    using the `https` module, we create a server passing in these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `server` from within our Express server `./lib/express/index.js`;
    remove the line that creates our HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with a call to our new HTTPS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to replace all references to `http://127.0.0.1:3000`; port 3000
    with `https://127.0.0.1:8443`; port 8443\. Our config file contains two references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a further reference in our `backbone.js` script `./public/components/vision.js`.
    When connecting to our Socket.IO server, we pass a URL `127.0.0.1:3000`. We make
    another important change here; we pass an options object when connecting to Socket.IO
    with the setting `secure: true, port: ''8443''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Sharing Express sessions with Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have session support in place, we can share the session with Socket.IO
    allowing us to accept or reject the connection based on this session data. Express
    and Socket.IO do this using a handshake mechanism. When a client connects to the
    server, the handshake is initiated, which consists of executing an authorization
    function on Socket.IO. Here, the cookie associated with the handshake request
    is examined and rejected if invalid. Let''s install `session.socket.io`; a module
    that has wrapped up this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'First off, let''s change our Express server, `./lib/express/index.js`, and
    pass to our `SocketHandler` module the `sessionStore` and the `cookieParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SocketHandler` module now accepts the parameters `httpServer`, `sessionStore`,
    and `cookieParser`. The `SocketHandler` will now instantiate a `SessionSockets`
    module passing `socketIo`, the `sessionStore` module, and the `cookieParser`.
    We change the `connection` event to listen on the `SessionSockets` module instead
    of the `socket.Io` module so that we can access the `session`. Now from within
    the `subscribe` event, we can check to ensure the `session.passport.user` is valid.
    We call `session.touch` which updates the `maxAge` and `lastAccess` properties
    of a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Cross-site request forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CRSF**) is an attack that tricks the victim
    into executing malicious actions on a web application in which they are authenticated.
    Connect/Express comes packaged with a Cross-site request forgery protection middleware.
    This middleware allows us to ensure that a request to a mutate state is from a
    valid source. The CRSF middleware creates a token that is stored in the requests
    session as `_csrf`. A request to our Express server will then need to pass the
    token in the header field `X-CSRF-Token`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a security `./lib/security/index.js` module that adds the `csrf`
    middleware to our application. We define a function, `Security`, that takes an
    Express `app` as an argument and removes the middleware when in `TEST` or `COVERAGE`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a change to our Express server `./lib/express/index.js`. The `crsf`
    middleware requires session support, so we add the following line below the `session`
    and `passport` middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using `backbone.js` that uses jQuery under the hood to make AJAX
    requests, we will need to make a change to our backbone code `./public/components/vision/vision.js`.
    We will now override the `Backbone.sync` function, so that all requests through
    it pass the `X-CSRF-Token` in the header. The `X-CSRF-Token` is pulled from a
    `meta` tag in the master page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to pass the `X-CSRF-Token` to our master page via the master page
    route. The token is stored in the requests session as `_csrf`, in the following
    code we add the token to `csrftoken` in our view object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `csrftoken` is rendered in our master page in a `meta` tag called `csrf-token`;
    the backbone sync method will put it from this meta tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Improving security with HTTP headers and helmet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helmet is a collection of middleware that implements various security headers
    for Express; for more information on helmet visit [https://npmjs.org/package/helmet](https://npmjs.org/package/helmet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Helmet supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: csp (Content Security Policy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HSTS (HTTP Strict Transport Security)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xframe (X-FRAME-OPTIONS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iexss (X-XSS-PROTECTION for IE8+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: contentTypeOptions (X-Content-Type-Options nosniff)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cacheControl (Cache-Control no-store, no-cache)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s extend our security `./lib/security/index.js` module, and add helmet
    security for the previous issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Express uses in-memory sessions. In the next chapter we will move
    our sessions to Redis. We will also configure Socket.IO to use Redis and explore
    some other interesting ways of scaling Express.
  prefs: []
  type: TYPE_NORMAL
