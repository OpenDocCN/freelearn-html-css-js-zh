- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Leveraging Behavioral Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用行为设计模式
- en: Behavioral design patterns help to organize communication between objects. This
    includes the ability to extend functionality without modifying these existing
    classes. By implementing the behavioral design patterns covered in this chapter
    and how they’re used in the JavaScript ecosystem, we’ll learn to build JavaScript
    applications that can be extended without touching existing functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式有助于组织对象之间的通信。这包括在不修改这些现有类的情况下扩展功能的能力。通过实现本章中涵盖的行为设计模式以及它们在JavaScript生态系统中的应用，我们将学习如何构建可以扩展而不触及现有功能的JavaScript应用程序。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An understanding of the behavioral design pattern classification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对行为设计模式分类的理解
- en: An implementation of the observer pattern and how the common Web **EventTarget**
    API exposes it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式的实现以及常见的Web **EventTarget** API如何暴露它
- en: Implementations of the state and strategy pattern, both with a class-based approach
    and a function-based approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式和策略模式的实现，包括基于类的方法和基于函数的方法
- en: A simplified visitor example, as well as common usage for the visitor pattern
    in the JavaScript ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简化的访问者示例，以及访问者模式在JavaScript生态系统中的常见用法
- en: By the end of this chapter, you’ll be able to leverage behavioral design patterns
    in JavaScript to scale your code base and expose extension points for functionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够利用JavaScript中的行为设计模式来扩展您的代码库并公开功能扩展点。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: What are behavioral design patterns?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是行为设计模式？
- en: Communicating between objects is key to building software. Behavioral design
    patterns help us organize this communication and usually decouple the possible
    implementations from other objects. This makes us more able to extend our code
    base.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象之间的通信是构建软件的关键。行为设计模式帮助我们组织这种通信，并且通常将可能的实现与其他对象解耦。这使得我们更有能力扩展我们的代码库。
- en: Behavioral design patterns help us follow the open/closed principle, where we
    can extend functionality without modifying the existing implementation modules.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式帮助我们遵循开闭原则，我们可以扩展功能而不修改现有的实现模块。
- en: All the patterns we’ll cover allow us to “add functionality” without modifying
    the existing consumer/concrete implementation. In large software code bases, this
    is useful, since it means we can limit the scope of changes and lower the risk
    of breaking existing functionality. We’re able to effectively de-correlate “adding
    functionality” from “changing the existing code for other unrelated functionality,”
    and new features and behaviors can be added without having to do modifications
    to existing consumers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖的所有模式都允许我们“添加功能”而不修改现有的消费者/具体实现。在大型软件代码库中，这很有用，因为它意味着我们可以限制更改的范围并降低破坏现有功能的风险。我们能够有效地将“添加功能”与“更改其他无关功能的现有代码”解耦，并且可以添加新功能和行为，而无需对现有消费者进行修改。
- en: With behavioral design patterns, new behaviors can be purely additive. The observer
    pattern allows multiple decoupled consumers (also called listeners). With the
    state, strategy, and visitor patterns, new implementations and transitions can
    be added without interfering with the existing ones.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行为设计模式，新的行为可以是纯粹的增加性的。观察者模式允许多个解耦的消费者（也称为监听器）。通过状态、策略和访问者模式，可以添加新的实现和转换，而不会干扰现有的实现。
- en: In the next section, we’ll look at our first behavioral design pattern, the
    observer pattern in JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨我们的第一个行为设计模式，即JavaScript中的观察者模式。
- en: The observer pattern in JavaScript
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的观察者模式
- en: The observer pattern allows an object (the observable or subject) to maintain
    a list of other objects that depend on it (observers). When a state update occurs
    in the subject, such as an entity object being created or updated, it notifies
    the observers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式允许一个对象（可观察的或主题）维护一个依赖于它的其他对象列表（观察者）。当主题的状态更新发生时，例如实体对象被创建或更新，它会通知观察者。
- en: Implementation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: A sample use case for the observer pattern is an in-memory queue. The `Queue`
    instance will have the `subscribe`, `unsubscribe`, and `notify` methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的示例用例是一个内存队列。`Queue`实例将具有`subscribe`、`unsubscribe`和`notify`方法。
- en: '`subscribe` will add an additional “handler” function, `unsubscribe` will remove
    a particular “handler” function if it has been registered, and finally, `notify`
    will call each handler with a “message” payload. This is the “notification of
    the observers” piece, where the observable or subject ensures that each registered
    observer is notified.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`将添加一个额外的“处理”函数，`unsubscribe`将删除已注册的特定“处理”函数，最后，`notify`将使用“消息”有效负载调用每个处理函数。这是“观察者的通知”部分，其中可观察对象或主题确保每个已注册的观察者都被通知。'
- en: '`subscribe` and `unsubscribe` turn “observer” functionality on and off, respectively.
    `subscribe` has to be used to become an “observer,” and `unsubscribe` is useful
    for situations where we don’t want to observe something anymore (for example,
    we’ve reached an end state). Meanwhile, the `notify` method ensures that each
    “subscribed” observer receives an update.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`和`unsubscribe`分别用于开启和关闭“观察者”功能。`subscribe`必须使用来成为“观察者”，而`unsubscribe`在不再需要观察某些情况时（例如，我们已经达到一个结束状态）非常有用。同时，`notify`方法确保每个“已订阅”的观察者都能收到更新。'
- en: 'A “handler” function, as the name suggests, is a function passed to another
    module to be executed at that other module’s discretion, usually in response to
    an “event”:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “处理”函数，正如其名所示，是将传递给另一个模块以供其自行执行的功能，通常是对“事件”的响应：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can implement three simple “subscribers” that will, respectively, only record
    `''CREATE''` messages, only record `''UPDATE''` messages, and record all messages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现三个简单的“订阅者”，分别只记录`'CREATE'`消息、只记录`'UPDATE'`消息和记录所有消息：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we trigger notifications by calling `notify`, we can ensure that the subscribers
    work as expected by inspecting the arrays on which they store the messages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用`notify`来触发通知时，我们可以通过检查它们存储消息的数组来确保订阅者按预期工作：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that our observer implementation takes advantage of first-class support
    for functions in JavaScript, which means we can pass a callback function to the
    `subscribe` method, instead of `notify` having to call a method on an instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的观察者实现利用了JavaScript对函数的一等支持，这意味着我们可以将回调函数传递给`subscribe`方法，而不是`notify`必须在一个实例上调用一个方法。
- en: 'In programming languages with limited or no first-class function support, such
    as older versions of Java and PHP, the approach would’ve required passing an *observer*
    to `subscribe` and `notify` calling a method on each observer instance. In JavaScript,
    if we don’t use “handler” functions, we’ll create an `observer` object that gets
    instantiated and has a `handle` function, which takes a *message* and implements
    some logic around it; in this case, it simply stores it on an instance variable:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持或几乎没有一等函数支持的编程语言中，例如较老的Java和PHP版本，这种方法将需要传递一个*观察者*给`subscribe`和`notify`，并在每个观察者实例上调用一个方法。在JavaScript中，如果我们不使用“处理”函数，我们将创建一个`observer`对象，该对象被实例化并具有一个`handle`函数，该函数接受一个*消息*并围绕它实现一些逻辑；在这种情况下，它只是将其存储在一个实例变量上：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This would require modification of the `Queue` class to work correctly:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要修改`Queue`类以正确工作：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can ensure that it does function as expected by calling `notify` with a
    few messages and checking the contents of `UpdateMessageObserver().updateMessages`,
    as the following code sample shows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`notify`方法并检查`UpdateMessageObserver().updateMessages`的内容来确保它按预期工作，如下面的代码示例所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve now seen how to implement the observer pattern with “handler” functions
    and `Observer` object instances, with a `Queue` observable. Next, we’ll look at
    where the observer pattern is used in JavaScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用“处理”函数和`Observer`对象实例实现观察者模式，使用`Queue`可观察对象。接下来，我们将探讨观察者模式在JavaScript中的使用情况。
- en: Use cases of the observer pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式的用例
- en: The observer pattern is great for dealing with loosely coupled events or messages.
    In the context of a web application, this could be DOM events. `EventTarget.addEventListener()`
    and `EventTarget.removeEventListener()`, which are available (among others) on
    the `Window`, `Document`, and `Element` objects, are a widely used implementation
    of the observer pattern. They’re used by client-side JavaScript applications to
    register handlers for user interactions (for example, click, form submit, hover,
    and mouseover).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式非常适合处理松散耦合的事件或消息。在Web应用程序的上下文中，这可能是DOM事件。`EventTarget.addEventListener()`和`EventTarget.removeEventListener()`，这些方法在`Window`、`Document`和`Element`对象上可用，是观察者模式的一种广泛实现。它们被客户端JavaScript应用程序用于注册用户交互的处理程序（例如，点击、表单提交、悬停和鼠标悬停）。
- en: Limitations and improvements
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性和改进
- en: In our queue implementation, handlers are readable from outside of the instance.
    The handlers are an implementation detail of the queue, which we should be able
    to change without affecting consuming modules. This means we want to encapsulate
    the handlers to make them unavailable for consumption by code outside of the `Queue`
    class. If we keep the `handlers` array available, it’s possible for code outside
    of the `Queue` class to access and modify it, which means the `Queue` abstraction
    breaks down, since consumers integrate against implementation details. This means
    consumers are tightly coupled to the `Queue`’s internal implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的队列实现中，处理程序可以从实例外部读取。处理程序是队列的实现细节，我们应该能够在不影响消费模块的情况下更改它。这意味着我们想要封装处理程序，使它们对于`Queue`类之外的代码不可用。如果我们保持`handlers`数组可用，那么`Queue`类之外的代码就可以访问并修改它，这意味着`Queue`抽象就会崩溃，因为消费者针对实现细节进行集成。这意味着消费者与`Queue`的内部实现紧密耦合。
- en: 'Therefore, we can use a private field; in modern JavaScript, that’s done using
    the `#` syntax. For handlers, it would involve a `#handlers` declaration in the
    class followed by access to `this.#handlers`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用私有字段；在现代JavaScript中，这可以通过使用`#`语法来实现。对于处理程序，它将涉及在类中声明`#handlers`，然后访问`this.#handlers`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another improvement we can make to our queue is to provide a fluent interface
    so that we can “chain” calls. To do this, we simply need to return `this` from
    each of the `subscribe`, `unsubscribe`, and `notify` handlers. This allows us
    to call the instance methods in a single “chain”; instead of using `queue.subscribe()`
    followed by `queue.notify()`, we can write it as a single statement – `queue.subscribe().notify()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的队列进行另一项改进，那就是提供一个流畅的接口，以便我们可以“链式”调用。为此，我们只需从每个`subscribe`、`unsubscribe`和`notify`处理程序中返回`this`即可。这允许我们在单个“链”中调用实例方法；而不是使用`queue.subscribe()`后跟`queue.notify()`，我们可以将其写为单个语句
    - `queue.subscribe().notify()`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can validate that the queue functions as expected with regards to notifying
    observers, as well as being usable with the fluent (“chained”) interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过验证队列在通知观察者方面的功能以及使用流畅（“链式”）接口的可用性来验证队列是否按预期工作：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve now seen how to implement the observer pattern in JavaScript as well as
    how to use private fields and a fluent interface to improve our implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何在JavaScript中实现观察者模式，以及如何使用私有字段和流畅接口来改进我们的实现。
- en: In the next section, we’ll implement the state and strategy patterns.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现状态模式和策略模式。
- en: State and strategy in JavaScript and a simplified approach
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的状态和策略以及简化方法
- en: The state and strategy patterns are closely related, in that they allow the
    extension of a software system‘s functionality by changing decoupled implementation
    objects, instead of changing the core subject object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式和策略模式密切相关，因为它们允许通过更改解耦的实现对象来扩展软件系统的功能，而不是更改核心主题对象。
- en: State allows an object to display different behavior based on what state it’s
    in. This is very useful for modeling state machines. Each state provides the same
    interface, and the core object calls methods on the different states.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 状态允许对象根据其所在的状态显示不同的行为。这对于建模状态机非常有用。每个状态都提供相同的接口，核心对象会在不同的状态上调用方法。
- en: Strategy similarly allows an object to dynamically select an implementation
    at runtime. In order to do this, the implementation is injected into the object
    and used.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式同样允许对象在运行时动态选择一个实现。为了做到这一点，实现被注入到对象中并使用。
- en: We can classify the state pattern as a subset of the strategy pattern, where
    the implementation is dynamically changed by the state instances.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将状态模式归类为策略模式的一个子集，其中实现是通过状态实例动态改变的。
- en: Next, we’ll see how to implement a state machine in JavaScript with the state
    pattern, as well as implement an object, merging abstraction with the strategy
    pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用状态模式在 JavaScript 中实现状态机，以及使用策略模式实现对象合并的抽象。
- en: Implementation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: For our implementation of the state pattern, we’ll use a simplified pull request/merge
    request/change request example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们实现的状态模式，我们将使用简化的拉取请求/合并请求/变更请求示例。
- en: A pull request starts in either a draft or open state. From there, it can transition
    between open and draft, and then transition to a closed or merged state. The merged
    state is a final state; closed can be undone by reopening the pull request, so
    it is not final.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求从草稿或打开状态开始。从那里，它可以在打开和草稿之间转换，然后转换为关闭或合并状态。合并状态是一个最终状态；关闭可以通过重新打开拉取请求来撤销，因此它不是最终状态。
- en: To visualize the transitions from all the states, we can use a state diagram
    representing pull request states and allowed transitions. In *Figure 3**.1*, the
    initial state is either draft or open. Both of these states can transition to
    each other. Open can change to merged or closed, where merged is a valid end state.
    Draft can also change to closed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化所有状态之间的转换，我们可以使用表示拉取请求状态和允许转换的状态图。在 *图 3.1* 中，初始状态是草稿或打开。这两种状态都可以相互转换。打开可以变为合并或关闭，其中合并是一个有效的结束状态。草稿也可以变为关闭。
- en: '![Figure 3.1: A pull request state diagram](img/B19109_03_1.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：拉取请求状态图](img/B19109_03_1.jpg)'
- en: 'Figure 3.1: A pull request state diagram'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：拉取请求状态图
- en: It’s useful to sketch out our `PullRequest` class first. The possible actions
    on our `PullReques`t are `open`, `markDraft`, `markReadyForReview`, `close`, and
    `merge`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先绘制我们的 `PullRequest` 类很有用。在 `PullRequest` 上可能执行的操作有 `open`、`markDraft`、`markReadyForReview`、`close`
    和 `merge`。
- en: 'To implement that state pattern, we also expose a `setState` method. Each state
    will take the `PullRequest` instance as a constructor argument, and the initial
    states of `PullRequest` are either `DraftState` or `OpenState`, based on an `isDraft`
    boolean parameter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现该状态模式，我们还公开了一个 `setState` 方法。每个状态都将 `PullRequest` 实例作为构造函数参数，`PullRequest`
    的初始状态是 `DraftState` 或 `OpenState`，基于一个 `isDraft` 布尔参数：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll implement the state machine, starting with the initial and final states.
    For the initial states, we have `DraftState` and `OpenState`; for the final states,
    we have `MergedState`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现状态机，从初始状态和最终状态开始。对于初始状态，我们有 `DraftState` 和 `OpenState`；对于最终状态，我们有 `MergedState`。
- en: '`DraftState` only implements `markReadyForReview` and `close`, which transition
    `pullRequest` to `OpenState` or `ClosedState`, respectively:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`DraftState` 只实现了 `markReadyForReview` 和 `close`，分别将 `pullRequest` 转换为 `OpenState`
    或 `ClosedState`：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`OpenState` implements `markDraft`, `close`, and `merge`, which transitions
    `pullRequest` to `DraftState`, `ClosedState`, and `MergedState`, respectively:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenState` 实现了 `markDraft`、`close` 和 `merge`，分别将 `pullRequest` 转换为 `DraftState`、`ClosedState`
    和 `MergedState`：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a final state, `MergedState` does not implement any of the methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终状态，`MergedState` 不实现任何方法：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, `ClosedState` implements the `open` method, which transitions `pullRequest`
    to `OpenState`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ClosedState` 实现了 `open` 方法，它将 `pullRequest` 转换为 `OpenState`：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can check that our pull request and states work as expected.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查我们的拉取请求和状态是否按预期工作。
- en: 'A `PullRequest` instantiated with `isDraft` set to `true` will begin in `DraftState`.
    A `markReadyForReview` call will transition it to `OpenState`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isDraft` 设置为 `true` 实例化的 `PullRequest` 将从 `DraftState` 开始。调用 `markReadyForReview`
    将将其转换为 `OpenState`：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once a pull request is merged with `pullRequest.merge()`, no method is available
    (they’ll all throw errors):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用 `pullRequest.merge()` 合并了拉取请求，就没有任何方法可用（它们都会抛出错误）：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A pull request starting in the open state can be closed. Once in `ClosedState`,
    it’s not possible to do anything other than execute `open()` on it – for example,
    `markDraft` will fail with an error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从打开状态开始的拉取请求可以被关闭。一旦进入 `ClosedState`，除了在它上面执行 `open()` 方法之外，无法执行任何其他操作——例如，`markDraft`
    将会因错误而失败：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve now seen how to implement a pull request state machine using the state
    pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用状态模式实现拉取请求状态机。
- en: Next, we’ll have a look at implementing strategy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何实现策略。
- en: 'Our example is an `ObjectMerger` class, which merges JavaScript objects. There
    are multiple ways to achieve this in JavaScript, so we structure our `ObjectMerger`
    to accept a `strategy` object and allow updates to it with a `setStrategy` method.
    Finally, we expose a `combinedObjects` method, which calls the instance’s strategy’s
    `combineObjects` method with two objects:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子是一个`ObjectMerger`类，它合并JavaScript对象。在JavaScript中有多种实现方式，因此我们构建`ObjectMerger`以接受一个`strategy`对象，并允许通过`setStrategy`方法对其进行更新。最后，我们公开一个`combinedObjects`方法，该方法调用实例的策略的`combineObjects`方法，并传入两个对象：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An example strategy in this case would be to use `Object.assign` with `{}`
    (a new object literal) as the target of the assignment. This has the benefit of
    not mutating the `obj1` and `obj2` parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个示例策略是使用`Object.assign`与`{}`（一个新对象字面量）作为赋值的目标。这有一个好处，就是不会修改`obj1`和`obj2`参数：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our `ObjectMerger` can be instantiated with the `PureObjectAssignStrategy`,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ObjectMerger`可以使用`PureObjectAssignStrategy`进行实例化，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It can then be used to merge objects without mutating `obj1` or `obj2`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它可以用来合并对象，而不会修改`obj1`或`obj2`：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An example of a naive implementation using `Object.assign` that doesn’t use
    a new object as the assignment target (and, therefore, mutates `obj1`) looks as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用`Object.assign`的简单实现示例，它不使用新对象作为赋值目标（因此，会修改`obj1`），如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It can be used as follows and does indeed mutate `obj1`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以这样使用，并且确实会修改`obj1`：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An equivalent strategy to our initial `Object.assign({}, obj1, obj2)` strategy
    is to use the spread syntax:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的初始`Object.assign({}, obj1, obj2)`策略等效的策略是使用扩展语法：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can validate that spreading `obj1` and `obj2` yields the same strategy characteristics
    as our earlier `PureObjectAssignStrategy`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证将`obj1`和`obj2`展开会产生与我们的早期`PureObjectAssignStrategy`相同的策略特征：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One interesting aspect is that this approach only creates a shallow clone;
    object references inside of the objects are copied, but the contents of the target
    objects are the same:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的方面是，这种方法只创建了一个浅拷贝；对象内部的对象引用被复制，但目标对象的内容是相同的：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can remediate this by implementing a deep cloning strategy based on `structuredClone`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现基于`structuredClone`的深度克隆策略来解决这个问题：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`DeepCloneObjectAssignStrategy` has all the properties of `PureObjectAssignStrategy`
    and `ObjectSpreadStrategy`, with the addition of doing a deep copy, recursively
    copying the contents of nested objects instead of copying references to those
    objects:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeepCloneObjectAssignStrategy`具有`PureObjectAssignStrategy`和`ObjectSpreadStrategy`的所有属性，并且增加了深度复制的功能，递归地复制嵌套对象的内
    容，而不是复制这些对象的引用：'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ve now seen how to implement the state and strategy patterns. Next, we’ll
    look at where the state and strategy patterns are most often used in JavaScript.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何实现状态和策略模式。接下来，我们将探讨状态和策略模式在JavaScript中最常被使用的地方。
- en: Use cases of the state and strategy patterns
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式和策略模式的使用案例
- en: As mentioned earlier in the chapter, the state pattern is useful for implementing
    state machines.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，状态模式对于实现状态机是有用的。
- en: A key difference between state and strategy is that, in the state pattern, it
    tends to be the case that different states know about each other – for example,
    `ClosedState` creates a new instance of `OpenState` to transition to it. Similarly,
    `OpenState` is aware of all the potential states it can be transitioned to (`DraftState`,
    `ClosedState`, and `MergedState`). In contrast, when implementing the strategy
    pattern, different strategies are self-contained and not aware of each other.
    For example, `PureObjectAssignStrategy` and `MutatingObjectAssignStrategy` don’t
    reference each other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和策略之间的一个关键区别是，在状态模式中，通常不同状态之间是相互了解的——例如，`ClosedState`创建一个`OpenState`的新实例以过渡到它。同样，`OpenState`了解它可以过渡到的所有潜在状态（`DraftState`、`ClosedState`和`MergedState`）。相比之下，在实现策略模式时，不同的策略是自包含的，并且不了解彼此。例如，`PureObjectAssignStrategy`和`MutatingObjectAssignStrategy`不会相互引用。
- en: Strategy is useful to provide a consistent interface with different internal
    implementations. It’s a useful abstraction when different implementing algorithms
    should be swappable without an integrating consumer knowing about it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式有助于提供具有不同内部实现的统一接口。当不同的实现算法应该可互换，而集成消费者不需要了解它时，这是一个有用的抽象。
- en: Limitations and improvements
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性和改进
- en: 'In our state example, note how much of our code is a duplicated class constructor,
    which takes a `pullRequest` instance. We can refactor our code by providing a
    `PullRequestBaseState` class, which throws `IllegalOperationError` for each of
    the state methods:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的国家示例中，请注意我们代码中有多少是重复的类构造函数，它接受一个`pullRequest`实例。我们可以通过提供一个`PullRequestBaseState`类来重构我们的代码，该类为每个状态方法抛出`IllegalOperationError`：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means we can define our different states by extending `PullRequestBaseState`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过扩展`PullRequestBaseState`来定义我们的不同状态：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `PullRequest` class doesn’t change, and these new state implementations
    work the same as our previous implementation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`PullRequest`类没有改变，这些新的状态实现与我们的先前实现工作相同：'
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For strategy, one thing we can leverage is JavaScript’s first-class function
    support. Instead of implementing each strategy as an object, we can make them
    functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于策略，我们可以利用的是JavaScript的一等函数支持。我们不需要将每个策略实现为一个对象，而是可以将其作为函数。
- en: 'Our `ObjectMerger`’s implementation looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ObjectMerger`实现如下：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can then re-implement all our strategies as functions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有策略重新实现为函数：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The function-based strategy `ObjectMerger` class has the same attributes as
    the class-based one that we implemented earlier. The constructor takes a “strategy
    function”, which it sets on the instance; each instance exposes a `setStrategy`
    method, which overrides the strategy function, and a `combineObjects` method,
    which we can call to merge objects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于函数的策略`ObjectMerger`类具有与之前实现的基于类的相同属性。构造函数接受一个“策略函数”，并将其设置在实例上；每个实例公开一个`setStrategy`方法，该方法覆盖策略函数，以及一个`combineObjects`方法，我们可以调用它来合并对象。
- en: 'This means we can use our `ObjectMerger` with all four function-based strategies
    (`pureObjectAssignStrategy`, `mutatingObjectAssignStrategy`, `objectSpreadStrategy`,
    and `deepCloneObjectAssignStrategy`), as the following demonstrates:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用我们的`ObjectMerger`与所有四个基于函数的策略（`pureObjectAssignStrategy`、`mutatingObjectAssignStrategy`、`objectSpreadStrategy`和`deepCloneObjectAssignStrategy`），如下所示：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve shown how to implement the state and strategy patterns in JavaScript,
    as well as their limitations and improvements, which can be done using modern
    JavaScript features.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何在JavaScript中实现状态和策略模式，以及它们的局限性和改进，这些都可以使用现代JavaScript特性来完成。
- en: In the next section, we’ll introduce the visitor pattern and its usage in the
    JavaScript ecosystem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍访问者模式及其在JavaScript生态系统中的应用。
- en: Visitor in JavaScript
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的访问者
- en: The visitor design pattern concerns itself with being able to add functionality
    to objects without modifying the structure of them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者设计模式关注的是在不修改对象结构的情况下向对象添加功能。
- en: With classical inheritance, we often end up with a “base class” that is not
    used directly; it’s used as an “abstract class,” from which “concrete” classes
    inherit from our “base class.” For example, with `BankAccount` and `BankAccountWithInterest`,
    our class diagram would look as follows, where `BankAccountWithInterest` extends
    `BankAccount` and overrides `setBalance`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典继承中，我们经常遇到一个“基类”，它不是直接使用的；它被用作一个“抽象类”，从该“抽象类”继承出我们的“基类”。例如，对于`BankAccount`和`BankAccountWithInterest`，我们的类图如下所示，其中`BankAccountWithInterest`扩展了`BankAccount`并覆盖了`setBalance`。
- en: '![Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount](img/B19109_03_2.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：继承自BankAccount的BankAccountWithInterest类图](img/B19109_03_2.jpg)'
- en: 'Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：继承自BankAccount的BankAccountWithInterest类图
- en: What we can do with the visitor pattern is define `BankAccount`, which accepts
    a visitor and an `InterestRateVisitor` visitor class. As a class diagram, it looks
    as follows. `BankAccount` and `InterestRateVisitor` are not linked via inheritance;
    they will be linked at runtime when `InterestRateVisitor` is called by the `BankAccount().accept`
    method. This means `InterestRateVisitor` knows about the structure of `BankAccount`
    but not the other way around. Furthermore, a visitor might not need to know the
    full structure of what it’s visiting, only what’s relevant to implement the visitor’s
    functionality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用访问者模式定义`BankAccount`，它接受一个访问者和`InterestRateVisitor`访问者类。作为一个类图，它看起来如下。`BankAccount`和`InterestRateVisitor`不是通过继承链接的；它们将在`InterestRateVisitor`被`BankAccount().accept`方法调用时在运行时链接。这意味着`InterestRateVisitor`了解`BankAccount`的结构，但反之则不然。此外，访问者可能不需要了解它访问的完整结构，只需要了解实现访问者功能的相关部分。
- en: '![Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor](img/B19109_03_3.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：BankAccount类和独立的InterestRateVisitor类的类图](img/B19109_03_3.jpg)'
- en: 'Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：BankAccount类和独立的InterestRateVisitor类的类图
- en: We’ll now see how to implement the `BankAccount` and `InterestRateVisitor` scenario.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何实现`BankAccount`和`InterestRateVisitor`场景。
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To implement a visitor, let’s start with a simple `BankAccount` class. The
    constructor sets the account type (either a current account or a savings account),
    the currency, and the initial balance. `BankAccount` has a `setBalance` method
    that can set the value of an account’s balance. The `accept` method will allow
    us to accept visitors and call their `visit` method on the instance:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个访问者，让我们从一个简单的`BankAccount`类开始。构造函数设置账户类型（要么是活期账户，要么是储蓄账户）、货币和初始余额。`BankAccount`有一个`setBalance`方法，可以设置账户余额的值。`accept`方法将允许我们接受访问者并在实例上调用他们的`visit`方法：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A way to structure `InterestVisitor` is to initialize it with an interest rate
    and currency. The `visit` method takes `bankAccount` and, if the account matches
    the currency and is a savings account, applies a new balance, based on the interest
    rate and current balance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一种结构化`InterestVisitor`的方式是使用利率和货币初始化它。`visit`方法接受`bankAccount`，如果账户匹配货币并且是储蓄账户，则根据利率和当前余额应用新的余额：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Given a set of accounts, we can create USD and GBP `InterestVisitor` instances:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组账户，我们可以创建USD和GBP的`InterestVisitor`实例：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can then loop through the accounts and call the `accept` method with the
    relevant visitor:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历账户并使用相关访问者调用`accept`方法：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ve now seen how to implement the visitor pattern in a band account scenario.
    Next, we’ll look at popular use cases for the visitor pattern in JavaScript.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何在银行账户场景中实现访问者模式。接下来，我们将探讨JavaScript中访问者模式的流行用例。
- en: Use cases of the visitor pattern
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的用例
- en: The visitor pattern provides a simple interface for library authors to allow
    consumers to extend a library’s functionality. This is especially effective in
    libraries that deal with trees or other “sets of nodes”. This explains why the
    visitor pattern is popular for custom plugins for parsing systems such as GraphQL
    implementations, or compilers such as Babel.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式为库作者提供了一个简单的接口，允许消费者扩展库的功能。这在处理树或其他“节点集”的库中特别有效。这也解释了为什么访问者模式在自定义解析系统（如GraphQL实现）或编译器（如Babel）的插件中很受欢迎。
- en: 'For example, the way to write a custom directive in Apollo Server v2 is to
    extend `SchemaDirectiveVisitor`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Apollo Server v2中编写自定义指令的方式是扩展`SchemaDirectiveVisitor`：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’ve now seen how the visitor pattern is used for libraries that manipulate
    tree data structures. Next, we’ll recapitulate what we’ve learned in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了访问者模式是如何在操作树数据结构的库中使用的。接下来，我们将回顾本章所学的内容。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw how behavioral design patterns enable the extension
    of functionality by supporting different implementations and decoupling parts
    of the code base.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了行为设计模式如何通过支持不同的实现和解耦代码库的各个部分来扩展功能。
- en: The observer pattern is useful to support communication with loosely coupled
    observable/observer pairs. The state and strategy patterns can be used to implement
    state machines and swap implementations effectively. The visitor pattern is a
    great way to expose an extension mechanism that’s decoupled from the structure
    of the objects it’s operating on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式对于支持松散耦合的可观察/观察者对之间的通信很有用。状态模式和策略模式可以用来实现状态机和有效地交换实现。访问者模式是暴露一个与操作对象的结构解耦的扩展机制的好方法。
- en: Now that we know how to organize communication between different objects and
    classes with behavioral design patterns, in the next chapter, we’ll cover reactive
    view library patterns in React.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用行为设计模式来组织不同对象和类之间的通信，在下一章中，我们将介绍React中的响应式视图库模式。
