- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral design patterns help to organize communication between objects. This
    includes the ability to extend functionality without modifying these existing
    classes. By implementing the behavioral design patterns covered in this chapter
    and how they’re used in the JavaScript ecosystem, we’ll learn to build JavaScript
    applications that can be extended without touching existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An understanding of the behavioral design pattern classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the observer pattern and how the common Web **EventTarget**
    API exposes it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations of the state and strategy pattern, both with a class-based approach
    and a function-based approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simplified visitor example, as well as common usage for the visitor pattern
    in the JavaScript ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to leverage behavioral design patterns
    in JavaScript to scale your code base and expose extension points for functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: What are behavioral design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating between objects is key to building software. Behavioral design
    patterns help us organize this communication and usually decouple the possible
    implementations from other objects. This makes us more able to extend our code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns help us follow the open/closed principle, where we
    can extend functionality without modifying the existing implementation modules.
  prefs: []
  type: TYPE_NORMAL
- en: All the patterns we’ll cover allow us to “add functionality” without modifying
    the existing consumer/concrete implementation. In large software code bases, this
    is useful, since it means we can limit the scope of changes and lower the risk
    of breaking existing functionality. We’re able to effectively de-correlate “adding
    functionality” from “changing the existing code for other unrelated functionality,”
    and new features and behaviors can be added without having to do modifications
    to existing consumers.
  prefs: []
  type: TYPE_NORMAL
- en: With behavioral design patterns, new behaviors can be purely additive. The observer
    pattern allows multiple decoupled consumers (also called listeners). With the
    state, strategy, and visitor patterns, new implementations and transitions can
    be added without interfering with the existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at our first behavioral design pattern, the
    observer pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern allows an object (the observable or subject) to maintain
    a list of other objects that depend on it (observers). When a state update occurs
    in the subject, such as an entity object being created or updated, it notifies
    the observers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sample use case for the observer pattern is an in-memory queue. The `Queue`
    instance will have the `subscribe`, `unsubscribe`, and `notify` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`subscribe` will add an additional “handler” function, `unsubscribe` will remove
    a particular “handler” function if it has been registered, and finally, `notify`
    will call each handler with a “message” payload. This is the “notification of
    the observers” piece, where the observable or subject ensures that each registered
    observer is notified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`subscribe` and `unsubscribe` turn “observer” functionality on and off, respectively.
    `subscribe` has to be used to become an “observer,” and `unsubscribe` is useful
    for situations where we don’t want to observe something anymore (for example,
    we’ve reached an end state). Meanwhile, the `notify` method ensures that each
    “subscribed” observer receives an update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A “handler” function, as the name suggests, is a function passed to another
    module to be executed at that other module’s discretion, usually in response to
    an “event”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement three simple “subscribers” that will, respectively, only record
    `''CREATE''` messages, only record `''UPDATE''` messages, and record all messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we trigger notifications by calling `notify`, we can ensure that the subscribers
    work as expected by inspecting the arrays on which they store the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that our observer implementation takes advantage of first-class support
    for functions in JavaScript, which means we can pass a callback function to the
    `subscribe` method, instead of `notify` having to call a method on an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In programming languages with limited or no first-class function support, such
    as older versions of Java and PHP, the approach would’ve required passing an *observer*
    to `subscribe` and `notify` calling a method on each observer instance. In JavaScript,
    if we don’t use “handler” functions, we’ll create an `observer` object that gets
    instantiated and has a `handle` function, which takes a *message* and implements
    some logic around it; in this case, it simply stores it on an instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This would require modification of the `Queue` class to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ensure that it does function as expected by calling `notify` with a
    few messages and checking the contents of `UpdateMessageObserver().updateMessages`,
    as the following code sample shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to implement the observer pattern with “handler” functions
    and `Observer` object instances, with a `Queue` observable. Next, we’ll look at
    where the observer pattern is used in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of the observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The observer pattern is great for dealing with loosely coupled events or messages.
    In the context of a web application, this could be DOM events. `EventTarget.addEventListener()`
    and `EventTarget.removeEventListener()`, which are available (among others) on
    the `Window`, `Document`, and `Element` objects, are a widely used implementation
    of the observer pattern. They’re used by client-side JavaScript applications to
    register handlers for user interactions (for example, click, form submit, hover,
    and mouseover).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations and improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our queue implementation, handlers are readable from outside of the instance.
    The handlers are an implementation detail of the queue, which we should be able
    to change without affecting consuming modules. This means we want to encapsulate
    the handlers to make them unavailable for consumption by code outside of the `Queue`
    class. If we keep the `handlers` array available, it’s possible for code outside
    of the `Queue` class to access and modify it, which means the `Queue` abstraction
    breaks down, since consumers integrate against implementation details. This means
    consumers are tightly coupled to the `Queue`’s internal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can use a private field; in modern JavaScript, that’s done using
    the `#` syntax. For handlers, it would involve a `#handlers` declaration in the
    class followed by access to `this.#handlers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another improvement we can make to our queue is to provide a fluent interface
    so that we can “chain” calls. To do this, we simply need to return `this` from
    each of the `subscribe`, `unsubscribe`, and `notify` handlers. This allows us
    to call the instance methods in a single “chain”; instead of using `queue.subscribe()`
    followed by `queue.notify()`, we can write it as a single statement – `queue.subscribe().notify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate that the queue functions as expected with regards to notifying
    observers, as well as being usable with the fluent (“chained”) interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to implement the observer pattern in JavaScript as well as
    how to use private fields and a fluent interface to improve our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll implement the state and strategy patterns.
  prefs: []
  type: TYPE_NORMAL
- en: State and strategy in JavaScript and a simplified approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state and strategy patterns are closely related, in that they allow the
    extension of a software system‘s functionality by changing decoupled implementation
    objects, instead of changing the core subject object.
  prefs: []
  type: TYPE_NORMAL
- en: State allows an object to display different behavior based on what state it’s
    in. This is very useful for modeling state machines. Each state provides the same
    interface, and the core object calls methods on the different states.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy similarly allows an object to dynamically select an implementation
    at runtime. In order to do this, the implementation is injected into the object
    and used.
  prefs: []
  type: TYPE_NORMAL
- en: We can classify the state pattern as a subset of the strategy pattern, where
    the implementation is dynamically changed by the state instances.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how to implement a state machine in JavaScript with the state
    pattern, as well as implement an object, merging abstraction with the strategy
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our implementation of the state pattern, we’ll use a simplified pull request/merge
    request/change request example.
  prefs: []
  type: TYPE_NORMAL
- en: A pull request starts in either a draft or open state. From there, it can transition
    between open and draft, and then transition to a closed or merged state. The merged
    state is a final state; closed can be undone by reopening the pull request, so
    it is not final.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the transitions from all the states, we can use a state diagram
    representing pull request states and allowed transitions. In *Figure 3**.1*, the
    initial state is either draft or open. Both of these states can transition to
    each other. Open can change to merged or closed, where merged is a valid end state.
    Draft can also change to closed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: A pull request state diagram](img/B19109_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: A pull request state diagram'
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful to sketch out our `PullRequest` class first. The possible actions
    on our `PullReques`t are `open`, `markDraft`, `markReadyForReview`, `close`, and
    `merge`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement that state pattern, we also expose a `setState` method. Each state
    will take the `PullRequest` instance as a constructor argument, and the initial
    states of `PullRequest` are either `DraftState` or `OpenState`, based on an `isDraft`
    boolean parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ll implement the state machine, starting with the initial and final states.
    For the initial states, we have `DraftState` and `OpenState`; for the final states,
    we have `MergedState`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DraftState` only implements `markReadyForReview` and `close`, which transition
    `pullRequest` to `OpenState` or `ClosedState`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`OpenState` implements `markDraft`, `close`, and `merge`, which transitions
    `pullRequest` to `DraftState`, `ClosedState`, and `MergedState`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final state, `MergedState` does not implement any of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `ClosedState` implements the `open` method, which transitions `pullRequest`
    to `OpenState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can check that our pull request and states work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `PullRequest` instantiated with `isDraft` set to `true` will begin in `DraftState`.
    A `markReadyForReview` call will transition it to `OpenState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a pull request is merged with `pullRequest.merge()`, no method is available
    (they’ll all throw errors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A pull request starting in the open state can be closed. Once in `ClosedState`,
    it’s not possible to do anything other than execute `open()` on it – for example,
    `markDraft` will fail with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to implement a pull request state machine using the state
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll have a look at implementing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is an `ObjectMerger` class, which merges JavaScript objects. There
    are multiple ways to achieve this in JavaScript, so we structure our `ObjectMerger`
    to accept a `strategy` object and allow updates to it with a `setStrategy` method.
    Finally, we expose a `combinedObjects` method, which calls the instance’s strategy’s
    `combineObjects` method with two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An example strategy in this case would be to use `Object.assign` with `{}`
    (a new object literal) as the target of the assignment. This has the benefit of
    not mutating the `obj1` and `obj2` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ObjectMerger` can be instantiated with the `PureObjectAssignStrategy`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It can then be used to merge objects without mutating `obj1` or `obj2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a naive implementation using `Object.assign` that doesn’t use
    a new object as the assignment target (and, therefore, mutates `obj1`) looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used as follows and does indeed mutate `obj1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'An equivalent strategy to our initial `Object.assign({}, obj1, obj2)` strategy
    is to use the spread syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate that spreading `obj1` and `obj2` yields the same strategy characteristics
    as our earlier `PureObjectAssignStrategy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One interesting aspect is that this approach only creates a shallow clone;
    object references inside of the objects are copied, but the contents of the target
    objects are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remediate this by implementing a deep cloning strategy based on `structuredClone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`DeepCloneObjectAssignStrategy` has all the properties of `PureObjectAssignStrategy`
    and `ObjectSpreadStrategy`, with the addition of doing a deep copy, recursively
    copying the contents of nested objects instead of copying references to those
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to implement the state and strategy patterns. Next, we’ll
    look at where the state and strategy patterns are most often used in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of the state and strategy patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, the state pattern is useful for implementing
    state machines.
  prefs: []
  type: TYPE_NORMAL
- en: A key difference between state and strategy is that, in the state pattern, it
    tends to be the case that different states know about each other – for example,
    `ClosedState` creates a new instance of `OpenState` to transition to it. Similarly,
    `OpenState` is aware of all the potential states it can be transitioned to (`DraftState`,
    `ClosedState`, and `MergedState`). In contrast, when implementing the strategy
    pattern, different strategies are self-contained and not aware of each other.
    For example, `PureObjectAssignStrategy` and `MutatingObjectAssignStrategy` don’t
    reference each other.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy is useful to provide a consistent interface with different internal
    implementations. It’s a useful abstraction when different implementing algorithms
    should be swappable without an integrating consumer knowing about it.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations and improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our state example, note how much of our code is a duplicated class constructor,
    which takes a `pullRequest` instance. We can refactor our code by providing a
    `PullRequestBaseState` class, which throws `IllegalOperationError` for each of
    the state methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can define our different states by extending `PullRequestBaseState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PullRequest` class doesn’t change, and these new state implementations
    work the same as our previous implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For strategy, one thing we can leverage is JavaScript’s first-class function
    support. Instead of implementing each strategy as an object, we can make them
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ObjectMerger`’s implementation looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then re-implement all our strategies as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The function-based strategy `ObjectMerger` class has the same attributes as
    the class-based one that we implemented earlier. The constructor takes a “strategy
    function”, which it sets on the instance; each instance exposes a `setStrategy`
    method, which overrides the strategy function, and a `combineObjects` method,
    which we can call to merge objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can use our `ObjectMerger` with all four function-based strategies
    (`pureObjectAssignStrategy`, `mutatingObjectAssignStrategy`, `objectSpreadStrategy`,
    and `deepCloneObjectAssignStrategy`), as the following demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We’ve shown how to implement the state and strategy patterns in JavaScript,
    as well as their limitations and improvements, which can be done using modern
    JavaScript features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll introduce the visitor pattern and its usage in the
    JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visitor design pattern concerns itself with being able to add functionality
    to objects without modifying the structure of them.
  prefs: []
  type: TYPE_NORMAL
- en: With classical inheritance, we often end up with a “base class” that is not
    used directly; it’s used as an “abstract class,” from which “concrete” classes
    inherit from our “base class.” For example, with `BankAccount` and `BankAccountWithInterest`,
    our class diagram would look as follows, where `BankAccountWithInterest` extends
    `BankAccount` and overrides `setBalance`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount](img/B19109_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount'
  prefs: []
  type: TYPE_NORMAL
- en: What we can do with the visitor pattern is define `BankAccount`, which accepts
    a visitor and an `InterestRateVisitor` visitor class. As a class diagram, it looks
    as follows. `BankAccount` and `InterestRateVisitor` are not linked via inheritance;
    they will be linked at runtime when `InterestRateVisitor` is called by the `BankAccount().accept`
    method. This means `InterestRateVisitor` knows about the structure of `BankAccount`
    but not the other way around. Furthermore, a visitor might not need to know the
    full structure of what it’s visiting, only what’s relevant to implement the visitor’s
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor](img/B19109_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now see how to implement the `BankAccount` and `InterestRateVisitor` scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a visitor, let’s start with a simple `BankAccount` class. The
    constructor sets the account type (either a current account or a savings account),
    the currency, and the initial balance. `BankAccount` has a `setBalance` method
    that can set the value of an account’s balance. The `accept` method will allow
    us to accept visitors and call their `visit` method on the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A way to structure `InterestVisitor` is to initialize it with an interest rate
    and currency. The `visit` method takes `bankAccount` and, if the account matches
    the currency and is a savings account, applies a new balance, based on the interest
    rate and current balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a set of accounts, we can create USD and GBP `InterestVisitor` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then loop through the accounts and call the `accept` method with the
    relevant visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to implement the visitor pattern in a band account scenario.
    Next, we’ll look at popular use cases for the visitor pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of the visitor pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The visitor pattern provides a simple interface for library authors to allow
    consumers to extend a library’s functionality. This is especially effective in
    libraries that deal with trees or other “sets of nodes”. This explains why the
    visitor pattern is popular for custom plugins for parsing systems such as GraphQL
    implementations, or compilers such as Babel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the way to write a custom directive in Apollo Server v2 is to
    extend `SchemaDirectiveVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how the visitor pattern is used for libraries that manipulate
    tree data structures. Next, we’ll recapitulate what we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how behavioral design patterns enable the extension
    of functionality by supporting different implementations and decoupling parts
    of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern is useful to support communication with loosely coupled
    observable/observer pairs. The state and strategy patterns can be used to implement
    state machines and swap implementations effectively. The visitor pattern is a
    great way to expose an extension mechanism that’s decoupled from the structure
    of the objects it’s operating on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to organize communication between different objects and
    classes with behavioral design patterns, in the next chapter, we’ll cover reactive
    view library patterns in React.
  prefs: []
  type: TYPE_NORMAL
