<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer134">
<h1 class="chapter-number" id="_idParaDest-261"><a id="_idTextAnchor264"/>13</h1>
<h1 id="_idParaDest-262"><a id="_idTextAnchor265"/>Converting the Application to a PWA</h1>
<p>Over the course of the last couple of chapters, it may have started to become clear that we are closing in on the end of our journey. Passing through the sweeping, vast countryside that is Babylon.js, we’ve seen and done much, and Space-Truckers is a functionally complete game thanks to our efforts. Now, we have one last stretch on the highway to cover in this chapter before we hit the off-ramp to the side-streets of <a href="B17266_14_Final_AM.xhtml#_idTextAnchor290"><em class="italic">Chapter 14</em></a>, <em class="italic">Extended Topics, Extended</em> chapter.</p>
<p>Just because we’re close to the end doesn’t mean we are there yet – close doesn’t count when it comes to Space-Truckers or orbital mechanics, only horseshoes and hand grenades. We’ve still got some road ahead of us, Space-Trucker, and there’s still time before we hit the limit on our hours of service, so let’s drive!</p>
<p>In this chapter, we are going to expose the intersection between Babylon.js and <strong class="bold">Progressive Web Applications</strong> (<strong class="bold">PWAs</strong>). A PWA is a middle space, a hybrid between the <a id="_idIndexMarker1009"/>browser-based traditional web application (whatever that means these days) and a native desktop application. They can be browsed as a website can be, installed as an app can be, and run offline without an internet connection. Users can also find and install PWAs from their device or major app store – whether Google Play, Microsoft, and Apple. This gives developers greater space to allow potential users to discover their app while requiring little cost and effort to achieve.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Apple’s support for PWAs is far behind other providers. There are some serious restrictions and limitations placed on PWAs running on iOS and they can have their own quirks when it comes to support for different features. See the excellent third-party site <a href="https://firt.dev/notes/pwa-ios/">https://firt.dev/notes/pwa-ios/</a> for the latest feature support for Safari and iOS.</p>
<p>Converting our existing web app to a PWA is simple and easy, but it does require some changes to the application. A Service Worker is needed for offline support and a manifest is needed to describe the characteristics of our PWA. This includes icons, a description, and potentially even screenshots for store submissions. However, there is one final feature that Space-Truckers is missing that we’ll be implementing in this chapter (it wouldn’t be a <em class="italic">Going the Distance</em> chapter if we didn’t have something of this sort, would it?).</p>
<p>This feature is one that has historically led to countless arguments and strained relationships among siblings and besties alike. A feature that has enabled bragging rights going back in time to the glory days of classics such as <em class="italic">Galaga</em>, <em class="italic">Pac-Man</em>, and <em class="italic">Donkey Kong</em>. This feature, of course, is a high score board. We’re going for a scoreboard that’s a bit more modern than the ones from those days because our scoreboard will save more than just the top 10 high scores; it will also retain those scores between application launches and computer restarts by saving data to the <strong class="bold">IndexedDB</strong>. </p>
<p>That’s the extent of the plan for this chapter – unlike previous chapters, there’s far less conceptual and theoretical discussion needed, so let’s get started. First though, let’s take a quick glance at the <em class="italic">Technical Requirements section</em> for this chapter. There’s a bit of a change from the previous ones, and that’s because, as we’ll shortly learn, PWAs have a specific set of hosting requirements that must be met.</p>
<p>We will be covering the following topics in this chapter:</p>
<ul>
<li>Introduction to PWAs</li>
<li>Converting the Space-Truckers Application into a PWA</li>
<li>Using IndexDB to Persist Scores </li>
<li>Storing and Displaying High Scores</li>
</ul>
<h1 id="_idParaDest-263"><a id="_idTextAnchor266"/>Technical Requirements</h1>
<p>This chapter has new tech requirements that, although low to no cost, do require some decisions and potentially a bit of research on your part to help get you to the specific outcome that works best for your project. After talking about the <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate requirements, we’ll go over some of the more popular options for hosting your PWA. </p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor267"/>Hosting Requirements</h2>
<p>To explain it briefly, SSL is a mechanism through which a client can verify the identity of a particular server and <a id="_idIndexMarker1010"/>establish an encrypted communications channel. It’s literally the ‘s’ in HTTPS! An SSL connection is a requirement for a PWA without exception. Even <a id="_idIndexMarker1011"/>though there are no exceptions, there actually is one exception, and that is the localhost loop-back address, to make testing easier. Obtaining a valid SSL certificate in most cases is free and easy to carry out. Depending on your hosting setup, SSL support might even be built into the hosting platform! Check the documentation for your specific provider to learn more about how to obtain and bind a site to a certificate.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor268"/>Options for Hosting your PWA</h2>
<p>There’s nothing special about a hosting provider with regards to making an application into a PWA; any <a id="_idIndexMarker1012"/>public-facing website that supports SSL has the capability to host a PWA. Some environments may make the organization and the process around hosting an SSL or HTTPS-based web app harder or easier, so here is a table listing some of the major hosting options:</p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="" height="637" src="image/Table_13.01_B17266.jpg" width="1650"/>
</div>
</div>
<p>GitHub Pages is one of the easiest options if you’re hosting the source of the application in GitHub already. Deploying to a GH page site involves pushing commits to a specially named (and never merged) branch. What <a id="_idIndexMarker1013"/>gets committed in our case is essentially the output of <strong class="source-inline">npm run build</strong> – the <strong class="source-inline">dist/ folder</strong> and all its contents. </p>
<p><strong class="bold">Azure Static Websites</strong> is also a free, easy choice. Though it does require an Azure subscription, creating a static website is free and quick. Integration with source code in GitHub is exceptionally <a id="_idIndexMarker1014"/>clean and useful and is even easier with the VSCode extension for Azure Static Websites. When deploying to a Site, a GH action performs all the work in the background for you whenever a pull request is opened or closed. To see an example of how this works in action, see the Space-Truckers repository’s <strong class="source-inline">.github/workflows</strong> folder for the details.</p>
<p>Google and AWS Static Sites are both unique products that nevertheless perform the same essential services as the previous two. AWS offers static websites via AWS Amplify, while Google also has a similar offering within its Cloud Storage product. The reason for the asterisks on these services is that the base products do not support custom domains nor HTTPS served over those custom domains, at least not out of the box. More work is needed on the developer’s part to add the other infrastructure components (such as an HTTPS proxy) that are necessary to accomplish and fulfill the requirements for custom domains and SSL or HTTPS. See the documentation provided in the next section for more information on how to do this – we don’t have enough road left in front of us to swerve into the weeds following this topic!</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor269"/>Resources and Reading</h2>
<ul>
<li>PWA <a id="_idIndexMarker1015"/>Builder – <a href="https://pwabuilder.com">https://pwabuilder.com</a></li>
<li>The <a id="_idIndexMarker1016"/>IndexedDB API – <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API</a></li>
<li>Azure <a id="_idIndexMarker1017"/>Static Web Apps:<ul><li><a href="https://docs.microsoft.com/en-us/azure/static-web-apps/">https://docs.microsoft.com/en-us/azure/static-web-apps/</a></li><li><a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal">https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal</a></li></ul></li>
<li>AWS <a id="_idIndexMarker1018"/>Amplify – <a href="https://aws.amazon.com/amplify/hosting/">https://aws.amazon.com/amplify/hosting/</a></li>
<li>Google <a id="_idIndexMarker1019"/>Static Sites – <a href="https://cloud.google.com/storage/docs/hosting-static-website">https://cloud.google.com/storage/docs/hosting-static-website</a></li>
<li>GitHub Pages and PWAs - <a href="https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/">https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/</a></li>
<li>Service Workers <a id="_idIndexMarker1020"/>and Workbox:<ul><li><a href="https://developer.chrome.com/docs/workbox/service-worker-overview/">https://developer.chrome.com/docs/workbox/service-worker-overview/</a></li><li><a href="https://developer.chrome.com/docs/workbox/">https://developer.chrome.com/docs/workbox/</a></li></ul></li>
<li>The source code for this chapter is in the <strong class="source-inline">ch13</strong> branch of the Space-Truckers GitHub repository - <a href="https://github.com/jelster/space-truckers/tree/ch13">https://github.com/jelster/space-truckers/tree/ch13</a> </li>
<li>Playground URLs are listed in their relevant sections</li>
</ul>
<h1 id="_idParaDest-267"><a id="_idTextAnchor270"/>Introduction to PWAs</h1>
<p>As mentioned earlier in the introduction, a PWA is a sort of hybrid type of application that bridges the gap <a id="_idIndexMarker1021"/>between a web application and a regular desktop application. Without additional context, it’s a description that comes close to meaninglessness context. It’s not the individual words and it’s not the term “Web App” that lacks clarity, so what does it mean for a web app to be “Progressive”?</p>
<p>Well, as most of us are aware of course, web browsers have a vastly different security model than regular applications or games. JavaScript running in a browser’s sandboxed environment has, by design, extremely limited access to the underlying machine’s hardware and filesystem. Important to our discussion is the limitation placed on scripts, along with the vast range of implementation support in browsers, which means that any given web application may or may not have access to certain device features and functions. In these types of cases, or when an application is being distributed widely across different device and software profiles, it is very important for an application to be able to – wait for it – “Progressively” and gracefully enhance or degrade its <a id="_idIndexMarker1022"/>capabilities on-demand based on what the hosting device has and is willing to share with the browser app.</p>
<p>That takes us to the next question, then: how do PWAs work? There are three main defining requirements that a web application must fulfill to be eligible to be installed as a PWA by a web browser. These requirements are <strong class="bold">SSL</strong>, <strong class="bold">Service Workers</strong>, and <strong class="bold">(Web) Manifests</strong> (<strong class="bold">SSM</strong>). So much word salad to digest, so little time. Let’s prep a salad fork and dig into these in more detail.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you prefer (or if you just really enjoy confusing people), you can use MMS or even SMS for an acronym. You do you!</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor271"/>SSL</h2>
<p>Conducted over HTTPS, this is a non-negotiable requirement – and for good reason! Installing a web app <a id="_idIndexMarker1023"/>as a PWA expands the <a id="_idIndexMarker1024"/>capabilities of the app greatly, but at the same time, commensurately exposes the host machine and its data to a greater risk of malicious or incompetent actors accessing it. Requiring a secure connection between the client and server neither compensates for incompetent or bad coding nor does it guarantee that the server involved is protected from malicious intent. What it does guarantee is that the identity of the hosting site has been verified as being what the site says it is.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor272"/>Service Workers</h2>
<p>Used to fetch and retrieve assets for and from offline use, SW is code loaded from a JavaScript file separate <a id="_idIndexMarker1025"/>from the main application’s code. Running in a DOM-less <a id="_idIndexMarker1026"/>sandbox, an SW is nonetheless the key intermediary between the application and the underlying network. An SW enables offline usage of the app in a transparent fashion – nothing in the application knows that it is really communicating with the SW when it makes a web request for a resource. </p>
<p>Every time a script, HTML tag, or CSS definition triggers a request from the web application, the request is intercepted and handled by the SW. The SW then has the choice of <a id="_idIndexMarker1027"/>either returning the indicated resource to the caller from its <a id="_idIndexMarker1028"/>cache or of refreshing its cache prior to returning the resource. To make this even more effective, the SW’s first job upon installation and activation is to pre-fetch all the resources and put them into its cache ahead of time. </p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor273"/>Web Manifest</h2>
<p>The last element needed to “unlock” the capabilities of a PWA in a browser is a Web Manifest. This is a simple JSON-formatted file that’s usually given an extension of <strong class="source-inline">.webmanifest</strong>, and it tells the web browser and other consumers of the manifest all sorts of neat information about the application. In addition to containing basic information about an <a id="_idIndexMarker1029"/>application, such as the name, description, and version, the manifest contains sections that <a id="_idIndexMarker1030"/>allow a developer to specify icon images at varying sizes and aspects for display by the host OS (e.g., the iOS Home Screen), display orientation preferences, screenshots, and even age and content ratings. View a full listing of possible elements <a id="_idIndexMarker1031"/>and what they mean on the Mozilla Developer docs site at <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">https://developer.mozilla.org/en-US/docs/Web/Manifest</a>. </p>
<p>These different pieces of metadata all work together to describe how the application should be presented and the parameters of its expected behavior. In addition, the Web Manifest is heavily leveraged when listing a PWA in one of the app stores. The benefits of being able to define the application’s metadata once for publication everywhere should be obvious, but how to easily define values for each of those properties is not. Fortunately, as with working with Babylon.js, there are many tools and resources available that can help speed things along.</p>
<p>We’ll cover the tools and the mechanics of PWAs shortly but let’s summarize what we know about PWAs and how they work first. When users browse to a website that is PWA-enabled, an icon appears in the browser indicating that an application can be installed for the current site. Clicking the icon transforms what used to be a regular website into an offline-capable, Start Menu-pinnable application indistinguishable from a native application. </p>
<p>What allows this to happen are the three specific things that a PWA must have properly configured – the SSM trio: (S)SL connections, a (S)ervice Worker to pre-fetch and cache resources for offline use, and a Web (M)anifest. Having an SSL connection means that the website <a id="_idIndexMarker1032"/>hosting the PWA is <a id="_idIndexMarker1033"/>accessed over the HTTPS protocol and requires a valid certificate to be obtained for this purpose. SWs are JavaScript code components that run in a separate sandbox from the rest of the browser’s application code. They intercept requests transparently and return cached resources stored locally. The Web Manifest describes everything that a hosting OS and web browser need to know to install the PWA. In addition, the Web Manifest also serves as an app Store package listing, meaning that for the effort of preparing a single store submission, one can make submissions to all of the major app Stores.</p>
<p>Coming up in the next section, we’re going to power up Space-Truckers: The Web Application and make it into Space-Truckers: The Progressive Web Application. We’ll see how two simple packages, along with a little bit of code and a WebPack configuration, are all that’s needed to get the job done. In a way, the simplicity and ease of making the conversion could be a bit anticlimactic, but don’t worry – we’ll soon thereafter be looking at adding something flashier and with more flare when we come to the high score board! </p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor274"/>Converting the Space-Truckers application into a PWA</h1>
<p>As we discussed shortly prior to this section, a hallmark – or signature – feature of a PWA is its ability to <a id="_idIndexMarker1034"/>gracefully adapt to varying <a id="_idIndexMarker1035"/>conditions and host environments. How should the application behave when a network connection is lost? What happens when a new version of the app is published? When assets change, how do you ensure that any cached versions of the old asset are evicted, and the new ones are stored? </p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor275"/>Putting the “P” in PWA</h2>
<p>These are all good questions and present real technical and engineering challenges that need to be solved. If you are one of those beautiful, curious, intelligent, and slightly mad kinds of people, you should prepare yourself to be disappointed. While, again, these are worthy topics to study and understand, this is a case where tools have evolved to the point where it is possible to accomplish a lot while knowing very little about the underlying technology. It’s possible that the overall brevity of this section – or really, of this entire chapter – hasn’t escaped notice and that’s a hint at just how easy it is to put the ”P” in PWA.</p>
<p>It’s also possible that the author of this book counted the number of pages originally promised and realized that the budgeted page count had been blown quite a while back, but nobody’s here to litigate the issue of which is which, are we? </p>
<p class="callout-heading">Note</p>
<p class="callout"><em class="italic">[Why yes, actually. We are paying quite close attention to the page count. – The Editors]</em></p>
<p>Right then. In the interest of getting to the point, and in not further antagonizing The Editors, let’s walk through the steps that will make Space-Truckers into a PWA.</p>
<h3>Step 1 – Installing the Workbox WebPack Plugin</h3>
<p><strong class="bold">Workbox</strong> is an open source <a id="_idIndexMarker1036"/>project maintained by Google with the purpose of making the <a id="_idIndexMarker1037"/>creation, usage, and management <a id="_idIndexMarker1038"/>of SWs smooth and easy. The project also maintains a plugin that integrates with <strong class="bold">WebPack</strong> (see <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creatingthe Application</em>) and automatically generates the SW code for you. Install it into the project as a developer dependency along with <strong class="bold">CopyPlugin</strong> with this command:</p>
<p class="source-code">npm i workbox-webpack-plugin copy-webpack-plugin --save-dev</p>
<p><strong class="source-inline">copy-webpack-plugin</strong> is a simple plugin that copies static files from a given directory into the output directory with the rest of the webpack output, which is handy for when we want to include icons and a <strong class="bold">Web Manifest</strong> with the build.</p>
<h3>Step 2 – Configuring WebPack Plugins</h3>
<p>We’ve made <a id="_idIndexMarker1039"/>new plugins <a id="_idIndexMarker1040"/>available to WebPack and now we need to import them into <strong class="source-inline">webpack.common.js</strong>:</p>
<pre class="source-code">&#13;
const WorkboxPlugin = require('workbox-webpack-plugin');&#13;
const CopyPlugin = require('copy-webpack-plugin');</pre>
<p>Next, we will instantiate the plugins with their respective options. If you recall from <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Establishing the Development Workflow</em>, WebPack plugins run in the order they are defined. These new plugins need to run after the HTML template has been injected with the bundle and after the destination directory has been cleaned:</p>
<pre class="source-code">&#13;
plugins: [&#13;
    new CleanWebpackPlugin(),&#13;
    new HtmlWebpackPlugin({&#13;
        template: path.resolve(appDirectory, "public/index.xhtml"),&#13;
        inject: true&#13;
    }),&#13;
    <strong class="bold">new WorkboxPlugin.GenerateSW({</strong>&#13;
<strong class="bold">        clientsClaim: true,</strong>&#13;
<strong class="bold">        skipWaiting: true,</strong>&#13;
<strong class="bold">        maximumFileSizeToCacheInBytes: 8388608,</strong>&#13;
<strong class="bold">    }),</strong>&#13;
<strong class="bold">    new CopyPlugin({</strong>&#13;
<strong class="bold">        patterns: [</strong>&#13;
<strong class="bold">            { from: path.resolve(appDirectory,</strong>&#13;
<strong class="bold">              'public/assets/icons'), to:</strong>&#13;
<strong class="bold">              path.resolve(appDirectory,</strong>&#13;
<strong class="bold">              'dist/assets/icons') },</strong>&#13;
<strong class="bold">            { from: path.resolve(appDirectory,</strong>&#13;
<strong class="bold">              'public/manifest.json'), to:</strong>&#13;
<strong class="bold">              path.resolve(appDirectory,</strong>&#13;
<strong class="bold">              'dist/manifest.webmanifest') }</strong>&#13;
        ]&#13;
    })&#13;
]</pre>
<p>The <strong class="bold">Workbox WebPack Plugin</strong> npm package has two primary plugins (modes) of operation, <strong class="source-inline">GenerateSW</strong> and <strong class="source-inline">InjectManifest</strong>, the use cases for which fall under the categories “Basic” and “Advanced”. Our needs are currently quite Basic, so we are using the <strong class="source-inline">GenerateSW</strong> plugin. Its configuration has flags that specify the SW should immediately claim <a id="_idIndexMarker1041"/>matching clients (for upgrade scenarios) as well as skip waiting for older workers to be <a id="_idIndexMarker1042"/>disposed. Most importantly, we set <strong class="source-inline">maximumFileSizeToCacheInBytes</strong> to four times its default value. This is needed because we want as many of our assets to be cached locally as possible. </p>
<p>The <strong class="bold">CopyPlugin</strong> configuration is intended for copying two static assets that don’t yet exist, our app icon sets, and <a id="_idIndexMarker1043"/>the Web Manifest JSON file (which is renamed with the <strong class="source-inline">.webmanifest</strong> extension along the way). We’ll create those files in subsequent steps after we make some changes to our <strong class="source-inline">index.xhtml</strong> file.</p>
<h3>Step 3 – Modifying index.xhtml</h3>
<p>Two important <a id="_idIndexMarker1044"/>modifications <a id="_idIndexMarker1045"/>need to be made to the <strong class="source-inline">index.xhtml</strong> file in the repository’s <strong class="source-inline">/public</strong> folder. The first is to add a <strong class="source-inline">&lt;link&gt;</strong> tag for the Web Manifest to the files’ <strong class="source-inline">&lt;head&gt;</strong> tag. The second is to add a short <strong class="source-inline">&lt;script&gt;</strong> tag that loads and registers the SW on page load:</p>
<pre class="source-code">&#13;
&lt;link rel="manifest" href="./manifest.webmanifest" /&gt;&#13;
&lt;script&gt;&#13;
  if ('serviceWorker' in navigator) {&#13;
    window.addEventListener('load', () =&gt; {&#13;
      navigator.serviceWorker.register('service-worker.js')&#13;
      .then(registration =&gt; {&#13;
        console.log('SW registered: ', registration);&#13;
      }).catch(registrationError =&gt; {&#13;
        console.log('SW registration failed: ',&#13;
          registrationError);&#13;
      });&#13;
    });&#13;
  }&#13;
&lt;/script&gt;</pre>
<p>In keeping with the graceful enhancement strategy that PWA advocates, our script is completely transparent to the rest of the application – when it is present, things just work. After checking to see whether the browser supports SWs, the <strong class="source-inline">navigator.serviceWorker.register</strong> function is called with the name and path of the SW script. This script is generated by <strong class="source-inline">GenerateSW</strong> and output into the <strong class="source-inline">/dist</strong> folder, so it shouldn’t trouble you that the file referenced doesn’t seem to exist!</p>
<p>At this point, running the app should generate the expected console messages indicating successful <a id="_idIndexMarker1046"/>SW registration and operation. Common problems <a id="_idIndexMarker1047"/>that may occur are an incorrect path or file name for the SW, or an incorrect <strong class="source-inline">GenerateSW</strong> configuration. That’s the SW part of the PWA requirements met – let’s fill in the one for the missing Web Manifest.</p>
<h3>Step 4 – Adding the Web Manifest</h3>
<p>The Web Manifest, as <a id="_idIndexMarker1048"/>previously <a id="_idIndexMarker1049"/>mentioned in the <em class="italic">Introduction to PWA</em> section, is the developer-friendly, JSON-formatted file describing the PWA’s attributes and characteristics. To maintain the development-time experience, we place the Web Manifest into the <strong class="source-inline">/public</strong> folder as a sibling to <strong class="source-inline">index.xhtml</strong>. This makes sure that our links work properly when being hosted on <strong class="source-inline">webpack-dev-server</strong> or built for a production environment and hosted from the <strong class="source-inline">/dist</strong> folder.</p>
<p>The file is named <strong class="source-inline">manifest.json</strong> in the <strong class="source-inline">/public</strong> folder, which is then renamed to <strong class="source-inline">manifest.webmanifest</strong> at build-time. Here are some of the more important properties:</p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="" height="587" src="image/Table_13.02_B17266.jpg" width="1650"/>
</div>
</div>
<p>For the <strong class="source-inline">icons</strong> array, each entry in the array specifies an icon whitespace-separated list of sizes, along with a path either directly to a file or to a base file name with sizes prefixed – as in, <strong class="source-inline">myicon</strong>, where the file names are <strong class="source-inline">48x48-myicon</strong> and  <strong class="source-inline">52x52-myicon</strong>. Supplying entries for every possible icon size isn’t necessary, although depending <a id="_idIndexMarker1050"/>on the source image, some <a id="_idIndexMarker1051"/>distortion and unintended display effects could occur. At this point, when the application is run on the local web server, the browser should “light up” with the ability to install the site as a PWA. If it doesn’t, open the browser developer tools and check for relevant console errors. The <strong class="bold">Lighthouse</strong> tab in Google Chrome and Microsoft Edge browsers can scan websites for many types of problems and optimization issues, including those involving PWAs.</p>
<p>A great many other properties are defined for the Web Manifest schema, and although not many <a id="_idIndexMarker1052"/>are required, many <a id="_idIndexMarker1053"/>are recommended. To see more of the properties available in the manifest, see <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">https://developer.mozilla.org/en-US/docs/Web/Manifest</a>. It can be difficult to manually create and manage all the different metadata, not to mention creating the icons, and that’s why there are tools that can help us get the job done fast. One such tool previously discussed was the Workbox project. Another tool we haven’t discussed yet though is the <strong class="bold">PWABuilder Extension</strong> for <strong class="bold">VSCode</strong>.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor276"/>Using the PWABuilder Extension</h2>
<p>Carrying out the previous steps manually has some benefits. You get fine control over every detail of the process while learning the internals of everything along the way. It’s also a tedious <a id="_idIndexMarker1054"/>process prone to error. An alternative to the previous steps is to use <a id="_idIndexMarker1055"/>the official <strong class="bold">PWABuilder Extension for Visual Studio Code</strong>. This extension, built and maintained by the same team that maintains the excellent resource <a href="http://PWABuilder.com">PWABuilder.com</a>, makes setting up a PWA quick and easy. Aside from generating the source code for various PWA components, the extension can validate an existing website to check its PWA readiness status – very useful for debugging. </p>
<p>After installing the extension from the <strong class="bold">VSCode</strong> extension marketplace, open the extension’s left-hand pane to reveal the <strong class="bold">Web Manifest</strong> and <strong class="bold">Service Worker</strong> panes. Click the <strong class="bold">+</strong> icons on the respective panes to generate those resources. When generating the application icons, depending on your settings, the PWA extension may generate the entire range of icon sizes – which can number above 60. For that reason, once the icons have been generated, feel free to go ahead and whittle down those files to whatever set of sizes works best. Make sure to update the manifest to remove the files!</p>
<p>When generating the SW, the extension will ask whether you would like a <strong class="bold">Basic</strong> or <strong class="bold">Advanced</strong> SW; the answer for Space-Truckers is <strong class="bold">Basic</strong>, since we’re not (yet) using PWA features such as push notifications. The extension will install any needed <strong class="source-inline">npm</strong> packages (such as <strong class="source-inline">workbox</strong>) and provide a code snippet to copy-paste into your <strong class="source-inline">index.xhtml</strong>. Does the code look familiar? </p>
<p>The final step when making a PWA is, of course, publishing the application to an HTTPS host. The specifics of this depend on your hosting provider, but Google, AWS, and Microsoft all provide VSCode extensions that can make publishing a breeze. Whichever provider is involved, the goal will be to run the <strong class="source-inline">build</strong> script followed by copying all of the files in the <strong class="source-inline">/dist</strong> folder to the root of the hosting website. </p>
<p>As promised in this section’s introduction, the tools and technologies available make creating and deploying a PWA incredibly simple and fast. A series of four straightforward steps are needed – adding two WebPack plugin packages to generate the Service Worker, modifying <strong class="source-inline">webpack config</strong>, then <strong class="source-inline">index.xhtml</strong> to register the SW and link <a id="_idIndexMarker1056"/>assets, then finally adding a Web Manifest to describe the extent of the changes <a id="_idIndexMarker1057"/>needed. Whether those changes are performed manually or with the help of an extension such as the PWA Builder Extension, there’s a rich world of native application functionality that opens up to application developers. We’re not seeing the full range and extent of the capabilities of PWAs, so head over to <a href="http://PWABuilder.com">PWABuilder.com</a> to read more about the different cool tricks that can be done with them!</p>
<p>Before we wrap things up for the chapter, there’s one more topic to explore. High scores are a staple for arcade-style games such as <strong class="bold">Space-Truckers</strong>, but since we’re running on the web, we need a way to be able to store a player’s high scores that persists beyond reloading the web page. The <strong class="source-inline">IndexedDB</strong> object store built into most modern browsers is a great solution for this type of problem, and in the following section, we’re going to learn how to create a component to make use of it.</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor277"/>Using IndexedDB to Persist Scores</h1>
<p>Web developers needing to store information on a local client have traditionally had a limited <a id="_idIndexMarker1058"/>number of options, most of which have had significant drawbacks. One of the oldest and simplest methods is the humble browser cookie. These little text files stored on the client’s browser are sent to the server alongside every request made by the browser client. Because of that, and for similarly related reasons, cookies aren’t an efficient or practical solution to many if not most client-side storage needs, including our own. For an in-depth examination of the different pros and cons of available client-side storage, see <a href="https://web.dev/storage-for-the-web/">https://web.dev/storage-for-the-web/</a>.</p>
<p>The <strong class="bold">IndexedDb Object Store</strong> (<strong class="bold">IDB</strong>) is a client-side, browser-sandboxed database enjoying a broad <a id="_idIndexMarker1059"/>spectrum of consistently implemented support across major browsers and platforms. While the amount of data a site is allowed to store is limited to the disk space that’s available to the browser, our application has very modest storage space requirements outside of the assets.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">While it is possible to use IDB as an asset cache for textures, meshes, and the like, it is far easier, efficient, and a better fit overall for those assets to use the SW set up earlier in this chapter. </p>
<p>This section’s focus is on the basics of IDB and how we will make use of it in our application. After <a id="_idIndexMarker1060"/>taking a moment to review the foundational elements of <strong class="source-inline">IndexedDb</strong>, we’ll put together some code to wrap the lower-level IDB functions with more application-layer-friendly helpers. Then, we’ll see how to integrate those helpers into a Playground that we’ll use in the next section, <em class="italic">Storing and Displaying High Scores</em>.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor278"/>Learning about IndexedDB</h2>
<p><strong class="source-inline">IndexedDB</strong> is an official API specification maintained by the <strong class="bold">World Wide Web Consortium</strong> (<strong class="bold">w3c</strong>), an <a id="_idIndexMarker1061"/>organization also responsible for most web-based standards such as HTML and CSS. The specification can be found at <a href="https://w3c.github.io/IndexedDB/">https://w3c.github.io/IndexedDB/</a> but we don’t need to go much deeper here to gain an understanding of how IDB works. </p>
<p>The wide support in web browsers for the IDB specification gives us confidence that we can proceed with using the APIs and that the same code should work the same across different browsers – the operative phrase being “should work.” Don’t leave off testing across different browsers and versions. Otherwise, you run a very high potential risk of running into support issues with end users that aren’t using the same setup as you!</p>
<p>When it comes to consuming the IDB API, there are two important things to note. First is that they are asynchronous. The second is that operations produce results via various event handler functions. When an asynchronous operation is invoked, the return value of that function isn’t immediately available – the function doesn’t return anything. Further, the operation may or may not succeed. In the case of the former, the result is produced by an event handler function specific to the operation and object involved. The <strong class="source-inline">IDBOpenRequest</strong> object has event handlers such as <strong class="source-inline">onsuccess</strong>, <strong class="source-inline">onerror</strong>, and <strong class="source-inline">onupgradedneeded</strong>, while the <strong class="source-inline">IDBObjectStore</strong> object has events such as <strong class="source-inline">transaction.oncomplete</strong>. As some of the names suggest, the latter case of an operation failing is handled by the <strong class="source-inline">onerror</strong> handler function. </p>
<p>An important consideration is how the various code paths of the <strong class="source-inline">indexedDB.open</strong> function are managed. The <strong class="source-inline">onsuccess</strong> event produces an instance of <strong class="source-inline">IDBDatabase</strong>, but that’s only part of the story. When a unique combination of the database name and the current schema versions (the first and second parameters to the <strong class="source-inline">Open</strong> operation) is <a id="_idIndexMarker1062"/>requested that does not match any existing object stores, the <strong class="source-inline">onpugradeneeded</strong> event is fired. It is at that time that the specific object store has its schema created, any indexes added, and any version change migrations performed. </p>
<p>That’s enough foundational concepts for us to start writing some code! We need to write some helper code that takes the event-based asynchronous <strong class="source-inline">IndexedDB</strong> functions and makes them easy to use in our application.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor279"/>Using IndexedDB</h2>
<p>All the different needs, scenarios, and data schema definitions involved with <strong class="source-inline">IndexedDB</strong> constitute several moving parts. Therefore, our first task is going to be crafting a <a id="_idIndexMarker1063"/>wrapper around these operations that exposes the desired API in the form of functions returning Promises. There are several libraries available that implement similar helper code, but for our simple needs, it is more illustrative and useful to just write the code ourselves. </p>
<p class="callout-heading">Note</p>
<p class="callout">The following code pattern is common in JavaScript programming as an approach for wrapping lower-level or legacy programming interfaces into forms more friendly to higher-level applications consuming that functionality. If you’re not familiar with this pattern, it’s a useful one to have in your toolbox! </p>
<p>The Playground snippet <strong class="bold">#U20E4X</strong> contains the code we’ll be using for this and the next part, so follow along as we visit some of the more interesting, opaque, and complex parts of the sample. </p>
<p>We will start by declaring and storing the <strong class="source-inline">SpaceTruckersDb</strong> function as our outer scope. The body of this function contains our working set of variables shared across our helper functions to maintain the internal state, as well as a <strong class="source-inline">const</strong> array of seed <strong class="source-inline">scoreData</strong>:</p>
<pre class="source-code">&#13;
let SpaceTruckersDb = function () {&#13;
    const scoreData = [&#13;
        { name: "AAA", score: 10000 },&#13;
        { name: "BBB", score: 7000 },&#13;
        { name: "CCC", score: 5000 },&#13;
        { name: "DDD", score: 3400 },&#13;
        { name: "EEE", score: 3000 },&#13;
        { name: "FFF", score: 2500 },&#13;
        { name: "GGG", score: 2000 },&#13;
        { name: "HHH", score: 1000 },&#13;
        { name: "III", score: 1000 },&#13;
        { name: "JBE", score: 500 },&#13;
    ];&#13;
    let indexedDbIsSupported = window.indexedDB;&#13;
    const currentSchemaVersion = 1;&#13;
    const databaseName = "SpaceTruckersDb";&#13;
    const tableName = "HighScores";&#13;
    var database;&#13;
// ... &#13;
return { retrieveScores, addScore, readyPromise };</pre>
<p>Jumping to the <a id="_idIndexMarker1064"/>bottom of the function, we are returning an object containing the helper functions to retrieve a list of scores as well as to add a new score. Alongside these functions is <strong class="source-inline">readyPromise</strong>, used to check for and ensure full initialization at a time of the caller’s choosing. Because our needs are so simple, we don’t need any additional logic or methods currently. </p>
<p>The most complicated logic of the entire sample is the first step – initializing the IDB object database and the corresponding object store (or table) that we’re using to store the scoring data for our application. This is tricky to handle because there are multiple potential branches that the code might need to take depending on whether the object store already exists, and further, whether the schema version of the object stores matches the most current version requested.</p>
<p>That’s what the <strong class="source-inline">onupgradeneeded</strong> event handler must, uh, handle. We start at the top of the <strong class="source-inline">readyPromise</strong> delegate’s function body by invoking <strong class="source-inline">indexedDb.open</strong>. This returns (one of the only times this happens with the IDB APIs) an <strong class="source-inline">openDbRequest</strong> object <a id="_idIndexMarker1065"/>with its attendant <strong class="source-inline">onerror</strong>, <strong class="source-inline">onsuccess</strong>, and of course, the <strong class="source-inline">onupgradeneeded</strong> events. The error logic is simple – reject <strong class="source-inline">readyPromise</strong> and pass through the thrown error. The success logic is also simple – just set the database variable to <strong class="source-inline">event.target.result</strong> and resolve the promise with it. </p>
<p class="callout-heading">Note</p>
<p class="callout">Remember, the <strong class="source-inline">onsuccess</strong> event is not fired on the first run of the script for a given <strong class="source-inline">currentSchemaVersion</strong> and <strong class="source-inline">databaseName</strong>. Instead, <strong class="source-inline">onupgradeneeded</strong> is raised.</p>
<p>Let’s look at what happens with the <strong class="source-inline">onupgradeneeded</strong> event. After extracting the database from the event object, we create <strong class="source-inline">objectStore</strong> itself. The <strong class="source-inline">autoIncrement</strong> flag indicates that new records should get an autoincremented key assigned and is followed by the creation of the non-unique score index. This is important and needed to ensure that the scores are stored in the proper ranked order:</p>
<pre class="source-code">&#13;
openDbRequest.onupgradeneeded = (event) =&gt; {&#13;
    database = event.currentTarget.result;&#13;
    database.onerror = handleError;&#13;
    let objectStore = database.createObjectStore(tableName,&#13;
      {&#13;
            autoIncrement: true&#13;
      });&#13;
    objectStore.createIndex("score", "score", &#13;
      {unique: false});&#13;
    objectStore.transaction.oncomplete = (event) =&gt; {&#13;
        let scoreStore = database&#13;
       .transaction(tableName, "readwrite")&#13;
            .objectStore(tableName);&#13;
        scoreData.forEach(scoreD =&gt;&#13;
          scoreStore.add(scoreD));&#13;
        resolve(database);&#13;
    };&#13;
};</pre>
<p>To proceed after creating the score index, we attach a function to the <strong class="source-inline">oncomplete</strong> event of <strong class="source-inline">objectStore.transaction</strong>. This function immediately initiates a <strong class="source-inline">readwrite</strong> transaction against the same table (<strong class="source-inline">scoreStore</strong>), which is then used to populate the initially empty score table with a set of initial high scores (<strong class="source-inline">scoreData</strong>). After adding the seed data to the store, we resolve <strong class="source-inline">readyPromise</strong> – there’s no need to wait for the write transaction to complete. That’s the most complicated logic we have for this component. </p>
<p>The <strong class="source-inline">retrieveScores</strong> and <strong class="source-inline">addScore</strong> functions are both simpler variations on the main themes presented with the <strong class="source-inline">onupgradeneeded</strong> event logic. A <strong class="source-inline">txn</strong> object is created with requested <a id="_idIndexMarker1066"/>permissions of either read-only or read-write. <strong class="source-inline">objectStore</strong> is then retrieved from the transaction and used to perform either a <strong class="source-inline">getAll</strong> or <strong class="source-inline">add</strong> operation. For <strong class="source-inline">getAll</strong>, the results are produced in the <strong class="source-inline">onsuccess</strong> handler of the object returned from <strong class="source-inline">objectStore.getAll</strong>, similarly to how the result of <strong class="source-inline">indexedDB.open</strong> is produced in <strong class="source-inline">onsuccess</strong>.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor280"/>Recap</h2>
<p>As simply as this, we’ve created a reusable component that we can drop into the Space-Truckers application as part of a high score screen! Let’s review what we’ve learned about <strong class="source-inline">IndexedDB</strong> before we move on to the next section.</p>
<p>IDB is a browser-based storage mechanism that has the capability of storing very large amounts of data. While the <a id="_idIndexMarker1067"/>basic storage means is object-based, IDB has the concept of databases containing a set of one or more object stores or tables. The schema for each table must be defined at the time of creation or schema version upgrade. This is defined by <strong class="source-inline">currentSchemaVersion</strong> passed to the <strong class="source-inline">indexedDB.open</strong> function. When the current version doesn’t exist or is lower than the version requested, the <strong class="source-inline">onupgradeneeded</strong> event fires.</p>
<p>During this event, object stores are created, their indexes are defined, and their data is populated. When upgrading versions, it’s important to include migration logic in this event handler – otherwise, data will be lost! In our case, we don’t need to migrate score data and it’s unlikely we’ll need to do much substantially to require a schema change soon (see the <em class="italic">Extended Topics</em> section at the end of this chapter for some ideas that might involve doing that). </p>
<p>Because the pattern of accessing the IDB APIs doesn’t natively support Promises, we’ve wrapped the major operations we need in a Promise-capable one. <strong class="source-inline">readyPromise</strong> is where the actual initialization and opening of the object store are performed and is also where the <strong class="source-inline">onupgradeneeded</strong> logic is housed. Once <strong class="source-inline">readyPromise</strong> resolves, the <strong class="source-inline">getScores</strong> and <strong class="source-inline">addScore</strong> methods become operational. These functions also return Promises for their respective operations, producing a list of scores or a confirmation that a new score was added. </p>
<p>Our IDB wrapper functions are the tools that we had to build in order to build the high score screen – now, it’s time to use them. In the last section of this chapter, we’re going to combine what we’ve just learned with the knowledge we’ve gained about coroutines and toss in our reusable GUI DialogBox component to create a tasty salad that is Space-Truckers: The High Scores! </p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor281"/>Storing and Displaying High Scores</h1>
<p>Keeping with the <a id="_idIndexMarker1068"/>cooking theme that we wrapped up the <a id="_idIndexMarker1069"/>previous section on, this section is all about combining our ingredients into a meal. All the hard work and <a id="_idIndexMarker1070"/>learning have already happened, so <a id="_idIndexMarker1071"/>this section will go by quickly – all the better to start feasting! The Playground at <a href="https://playground.babylonjs.com/%23VBMMDZ%2323">https://playground.babylonjs.com/#VBMMDZ#23</a> is what we’ll use as a live example – keep following along or try to replicate the functionality in the sample from the descriptions and snippets mentioned in this section. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">Don’t try to eat your computer, or anything that isn’t food – we are just using a metaphor, albeit one taken a bit further than needed! In fact, let’s just switch themes entirely. For the rest of this section, we’ll go with a classic heist, in the style of <em class="italic">Ocean’s Eleven</em>. </p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor282"/>The Heist</h2>
<p>It won’t be enough to enlist the reluctant aid of the “muscle”, <strong class="source-inline">DialogBox</strong>, to throw a list of scores <a id="_idIndexMarker1072"/>onto the screen and call it a day. Nor is it enough to bring in the quick-witted “safe cracker”, <strong class="source-inline">SpaceTruckersDb</strong>, to finish the job. If we truly want to pull off this major gig, The High Score, each score needs to make a grand entrance. Failing that, they can at least not all appear on the screen at the same time as a crowd of raucous monkeys storming a banana barrel. In the case of a new high score in need of recording, we need to be able to collect the user’s initials in the “traditional” three-letter format used by the arcade cabinets of old. We need “brains”to do the thinking. We need our old friend the <strong class="bold">coroutine</strong> to “come out of retirement for one last job”. </p>
<p>To summarize our plan in exciting sub-sections, imagine of a compelling montage sequence that shows exactly how hard (actually, it’s not hard but roll with it) completing the job will be for The Crew, let’s begin.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor283"/>The Muscle</h2>
<p>We’ll host the <a id="_idIndexMarker1073"/>high score display with the <strong class="source-inline">DialogBox</strong> component (see <em class="italic">section Building a Reusable Dialog Box Component </em>in<em class="italic"> </em><a href="B17266_09_Final_AM.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a><em class="italic">, Calculating and Displaying Scoring Results</em>). Scores themselves are hosted within a <strong class="bold">StackPanel</strong> that gets added to <strong class="source-inline">bodyContainer</strong>. Each score is an object with just the name and score properties. The <strong class="source-inline">getScoreTextLine</strong> helper function takes an individual score object and returns a formatted string that can be displayed in <strong class="source-inline">TextBox</strong>:</p>
<pre class="source-code">&#13;
function getScoreTextLine(s) {&#13;
    if (!s.score) {&#13;
        return s.name;&#13;
    }&#13;
    let scoreText = s.score.toFixed(0);&#13;
    let text = `${s.name}${'.'.repeat&#13;
      (20 - scoreText.length)}${s.score}\n`;&#13;
    return text;&#13;
}</pre>
<p>Though we expect the <strong class="source-inline">s.score</strong> value to be present, we check for its absence anyhow, since the <a id="_idIndexMarker1074"/>process of adding a new score necessarily precludes the entry of a name. We also expect the score to be a whole, integer value, but we convert it to a fixed string with zero points beyond the decimal just to be safe. A format string is returned that considers the length of the score value’s text representation.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor284"/>The Safe Cracker</h2>
<p>Persistence logic will be provided by <strong class="source-inline">SpaceTruckersDb</strong> that we built in the previous section. Its functions <a id="_idIndexMarker1075"/>are called and managed by <strong class="source-inline">scoreBoardCoro</strong>. True to the current thematic form, there’s not much else to be said about the “safe cracker” that won’t be included with our review of the “brains.”</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor285"/>The Brains</h2>
<p>The <strong class="bold">ScoreBoard CoRoutine</strong> (<strong class="bold">ScoreBoardCoRo</strong>) coordinates retrieving scores and displaying <a id="_idIndexMarker1076"/>them in <strong class="source-inline">DialogBox</strong> as well as the <a id="_idIndexMarker1077"/>edit mode for entering new scores. When <strong class="source-inline">scoreBoardCoro</strong> is invoked as a function (as part of preparing to run the coroutine – see <a href="B17266_09_Final_AM.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a><em class="italic">, Calculating and Displaying Scoring Results</em>, for more), the <strong class="source-inline">newScore</strong> parameter is used to pass in the new high score awaiting three-letter branding. If present, the <strong class="source-inline">editHighScores</strong> flag is set and a placeholder, <strong class="source-inline">scoreToAdd</strong>, is added to the scores list already retrieved by <strong class="source-inline">databaseManager</strong> that is <a id="_idIndexMarker1078"/>initialized immediately upon entry. Equally, the <strong class="source-inline">nameInput</strong> <strong class="bold">InputText</strong> control as well as the <strong class="bold">VirtualKeyboard</strong> GUI element are instantiated and added to the dialog’s control tree. An observer function is added to <strong class="source-inline">nameInput.onTextChangedObservable</strong> that limits entries to three characters or fewer. Additionally, it will also take action when detecting that the <em class="italic">Enter</em> key was pressed by setting the <strong class="source-inline">editHighScores</strong> flag to <strong class="source-inline">false</strong>:</p>
<pre class="source-code">&#13;
nameInput.onTextChangedObservable.add((ev, es) =&gt; {&#13;
    if (ev.text.indexOf('↵') &gt;= 0 || ev.text.length &gt;= 3 || &#13;
        ev.currentKey === "Enter") {&#13;
            scene.editHighScores = false;&#13;
    }&#13;
});&#13;
// ...&#13;
while (scene.editHighScores) {&#13;
    yield Tools.DelayAsync(1000);&#13;
}</pre>
<p>Once the coroutine has finished waiting to exit edit mode, if there’s <strong class="source-inline">newScore</strong>, that means the user’s entered their initials and that the score is waiting to be saved. We do that before cleaning up the controls involved in gathering the user input:</p>
<pre class="source-code">&#13;
if (newScore) {&#13;
    scoreToAdd.name = nameInput.text.substring(0,3);&#13;
    await databaseManager.addScore(scoreToAdd);&#13;
    console.log('saved newScore', scoreToAdd);&#13;
    virtualKB.disconnect();&#13;
    virtualKB.dispose();&#13;
    newScore = null;&#13;
    nameInput.dispose();&#13;
    scoreToAdd = null;&#13;
    scores = await databaseManager.retrieveScores();&#13;
    await displayScores(scores);&#13;
}</pre>
<p>After the controls have been cleaned up, we refresh the <strong class="source-inline">scores</strong> list from storage to put everything back into a clean, initial state. If there isn’t a <strong class="source-inline">newScore</strong>, the coroutine’s work is done and <a id="_idIndexMarker1079"/>the job’s complete – the scores were already retrieved and displayed at the beginning of the coroutine’s execution. With such a skilled Crew and exquisite preparation, it shouldn’t surprise anyone following along that the Job of displaying the scores itself is short and sweet. </p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor286"/>The Job</h2>
<p>Assembling The Crew was the crucial first step, planning out The Job was the second, and now <a id="_idIndexMarker1080"/>it’s time to execute that plan. Here’s our shortcut to a montage of the following steps in a linear sequence of events:</p>
<ol>
<li>(<strong class="source-inline">yield</strong>) until the “safe cracker” (<strong class="source-inline">databaseManager</strong>) signals that it’s ready.</li>
<li>Get the <strong class="source-inline">scores</strong> list from the “safe cracker” (<strong class="source-inline">databaseManager</strong>) and put them into the <strong class="source-inline">scores</strong> array.</li>
<li>Show “the muscle” (<strong class="source-inline">DialogBox</strong>). Wait for it to fully make its entrance before continuing.</li>
<li>If “the brains” “sez” there’s another score to add (<strong class="source-inline">newScore</strong>), the following happens:<ul><li>The <strong class="source-inline">editHighScores</strong> flag is set</li><li>A placeholder score entry is created sans a name and added to the <strong class="source-inline">scores</strong> list</li><li>Input elements are put into place to collect the player’s initials (<strong class="source-inline">nameInput</strong> and <strong class="source-inline">virtualKB</strong>)</li><li>A “little bird” (a.k.a an observer) listens for changes in the input element, toggling out of the <strong class="source-inline">editHighScores</strong> mode when the <em class="italic">Enter</em> key is pressed or three elements or greater have been entered</li></ul></li>
<li>“The host” puts on the show of showing the scores (<strong class="source-inline">displayScores</strong> is called).</li>
<li>Tension builds <a id="_idIndexMarker1081"/>on the stakeout as everyone waits for the edit flag to drop (<strong class="source-inline">yield</strong> in use while <strong class="source-inline">editHighScores</strong> is <strong class="source-inline">true</strong>).</li>
<li>Prepare the getaway, but first, have “the brains” scan the newly-“liberated” score (<strong class="source-inline">scoreToAdd</strong>).</li>
<li>Before jumping into the getaway car, “the host” puts on a smoke-and-mirrors show (clears and re-displays the scores from storage).</li>
<li>We see The Crew walking off into the sunset having successfully completed The Job. The credits roll and lights go up.</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer133">
<img alt="Figure 13.1 – The Space-Truckers high score board in add or edit mode&#13;&#10;" height="1136" src="image/Figure_13.01_B17266.jpg" width="1477"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The Space-Truckers high score board in add or edit mode</p>
<p>There are no plans for a sequel (yet…) – however, the extended edition (director’s cut) shows what <a id="_idIndexMarker1082"/>happens after the plucky heisters have finished their job, and that’s the nitty-gritty of integrating the crafted code from the snippet discussed previously with the overall Space-Truckers application.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor287"/>The Integration</h2>
<p>The beauty of the <strong class="source-inline">DialogBox</strong> component is that it can be slotted into an existing Scene. This is a <a id="_idIndexMarker1083"/>good thing because we want to be able to display the screen in two separate places – <strong class="bold">Main Menu</strong>, as a new menu item, and after clicking <strong class="bold">Next</strong> from the <strong class="bold">Scoring Dialog</strong>. <strong class="source-inline">HighScoreScreen</strong> is the high-level wrapper function that instantiates and starts the <strong class="source-inline">ScoreBoard</strong> coroutine, returning the <strong class="source-inline">scoreBo.dialog</strong> instance so that callers can listen for its dismissal. </p>
<p>How this works out in the <strong class="bold">Main Menu</strong> screen is simple, but there are a couple of different pieces involved. First, we make use of the newly-added <strong class="source-inline">onHighScoreActionObservable</strong> that is hooked up to the also newly-added <strong class="bold">High Scores</strong> button, which is defined by this option data:</p>
<pre class="source-code">&#13;
const highScoreOpts = {&#13;
    name: "btHighScores",&#13;
    title: "High Scores",&#13;
    background: "green",&#13;
    color: "black",&#13;
    onInvoked: () =&gt; {&#13;
        logger.logInfo("High Scores button clicked");&#13;
        this._onMenuLeave(1000, () =&gt;&#13;
          this.onHighScoreActionObservable.&#13;
          notifyObservers());&#13;
    }&#13;
}</pre>
<p>This is the same pattern used for the other menu buttons added as part of the <strong class="source-inline">_addMenuItems</strong> private function of the <strong class="source-inline">MainMenuScene</strong> constructor – the menu is faded out for one second before notifying observers of <strong class="source-inline">onHighScoreActionObservable</strong> that something interesting happened.</p>
<p>The subscriber <a id="_idIndexMarker1084"/>of this observable is set up in the constructor function of the <strong class="source-inline">MainMenuScene</strong> constructor, and is responsible for setting up <strong class="source-inline">scoreDialog</strong> and then returning the UI to <strong class="bold">Main Menu</strong> after the user clicks <strong class="bold">Go Back</strong>:</p>
<pre class="source-code">&#13;
this.onHighScoreActionObservable.add(async () =&gt; {&#13;
    this.isTopMost = false;&#13;
    let scoreDialog = HighScoreScreen(this.scene);&#13;
    scoreDialog.onCancelledObservable.add(() =&gt; {&#13;
    this._onMenuEnter(1000);&#13;
    this.isTopMost = true;&#13;
});</pre>
<p>We’ve introduced the <strong class="source-inline">isTopMost</strong> flag to <strong class="source-inline">MainMenuScene</strong> so that we know whether to handle input (see the <strong class="source-inline">MainMenuScene.update</strong> function) or if any <strong class="source-inline">DialogBox</strong> instances are responsible for that task. Once we set that flag, we show and get the <strong class="source-inline">scoreDialog</strong> instance via the <strong class="source-inline">HighScoreScreen</strong> function. Now that the <strong class="source-inline">scoreDialog</strong> instance is available, we can then attach logic to <strong class="source-inline">onCancelledObservable</strong>, which re-displays the menu and sets it to handle input.</p>
<p>Similarly, <strong class="source-inline">scoringDialog</strong> attaches a handler to its <strong class="source-inline">onAcceptedObservable</strong>, which <a id="_idIndexMarker1085"/>does the same as the <strong class="source-inline">MainMenuScreen.onHighScoreActionObservable</strong> handler does:</p>
<pre class="source-code">&#13;
scoreDialog.onAcceptedObservable.add(async () =&gt; {&#13;
    let score = scoreData.finalScores['Final Total'];&#13;
    await scoreDialog.hide();&#13;
    let scoreScreen = HighScoreScreen(scene, score);&#13;
    scoreScreen.onCancelledObservable.add(async () =&gt; {&#13;
        await scoreDialog.show();&#13;
    });&#13;
});</pre>
<p>The major difference here is that before calling <strong class="source-inline">HighScoreScreen</strong>, we are extracting the <strong class="source-inline">Final Total</strong> score value and passing it into the function along with the scene so that it can potentially be added as a new entry to the list. </p>
<p>Being able to meet new requirements by putting together existing components with few modifications is a pinnacle achievement in software architecture and design, which makes it a great place to finish this section. In this section, we’ve gone over the sequence of events and actors involved in the processes of both persisting and displaying high scores. The existing <strong class="source-inline">DialogBox</strong> component is reused to host the scoreboard, while the <strong class="source-inline">IndexedDB</strong> component built in the previous section of this chapter provides the storage and the <strong class="source-inline">ScoreBoard</strong> coroutine orchestrates everything.</p>
<p>Integration is simplest in the case of progressing to the high score screen from the <strong class="bold">Scoring Dialog</strong> but launching the high scores from the main menu isn’t much more complicated. We needed to add an <strong class="source-inline">isTopMost</strong> flag to the menu so that it knew not to handle input when a dialog is being shown, and we also added <strong class="source-inline">onHighScoresActionObserver</strong> to signal when to change screens. The rest is just hooking up <a id="_idIndexMarker1086"/>appropriate show and hide logic to the various dialog events. What else is there that could be done? So much! See the <em class="italic">Extended Topics</em> section at the end of this chapter for some ideas on things to improve that you can contribute.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor288"/>Summary</h1>
<p>We started this chapter by focusing on what is needed to turn our application into a PWA and how this is done. We finished the chapter by implementing a high score board for our application, and in between, we managed to learn a lot.  Let’s recap what we’ve learned.</p>
<p>A PWA is a type of application that blurs the boundaries between a regular website and a traditional native application. As with desktop applications, a PWA can run offline without a network connection. It has access to the host computer’s filesystem and hardware devices. Also, as with desktop applications, a PWA can be published and deployed via an App Store such as the Apple App Store, Google Play, or Microsoft Store. Unlike a desktop app, PWAs can be accessed via a single URL and operate as a regular web application with reduced functionality. When different limitations or restrictions are encountered, the app gracefully enhances or degrades its functionality, making PWAs useful for a wide range of application scenarios. </p>
<p>Three elements are needed for a web application to be considered a PWA: SSL hosting to secure the connection, an SW to pre-cache and intercept requests, and a Web Manifest to define the application’s metadata. Hosting a site under SSL has a widely varying set of steps needed that depend very heavily on the specific hosting provider. For instance, Azure Static Web Apps allows a site with a custom domain name to have SSL without the need for the developer to provide or purchase a certificate, whereas Google and AWS both require additional infrastructure to be provisioned to support some or all SSL scenarios. SWs are pieces of code that run in a sandboxed execution environment in the web browser. They can do all sorts of things, but in our simple application use case, we are using them to perform pre-caching and the loading of assets. When the application requests a particular resource from a remote URL, the SW intercepts the request and supplies the response from the local cache, allowing for a transparent mechanism of going offline without having to modify any application code. The Web Manifest serves as the main descriptor of the application to any interested systems. A JSON document containing a few required and many optional elements, the Web Manifest is what is used to package and publish a PWA to an app store, as well as to specify how the PWA should look and feel when installed.</p>
<p>When it comes to different ways of storing data on the client, there’s no longer any need to rely on mechanisms such as cookies to persist arbitrary amounts of data. The IndexedDb browser service provides an object store for applications that can store an arbitrarily large amount of data. Although not terribly complicated to employ, the programming patterns used to work with IDB are best integrated by wrapping them with more easy-to-handle Promises. Our needs were simple enough that we didn’t need to use one of the many existing libraries that can work with IDB here, as we only needed to be able to add a single score and retrieve a list of scores.</p>
<p>The high score screen displays the beauty and power of the <strong class="bold">Composition Pattern</strong> by combining (composing) together the <strong class="source-inline">DialogBox</strong> component for display, the IDB component for persistence, and a coroutine to manage it all into the <strong class="source-inline">SpaceTruckerHighScores</strong> component. The generic nature of <strong class="source-inline">DialogBox</strong> allows us to easily integrate the new high score screen into the rest of the Space-Truckers application. Both the main menu and the <strong class="bold">Scoring Dialog</strong> play host to the scoreboard, which allows players with scores that make the cut to enter their three-letter initials using either a physical or virtual keyboard. </p>
<p>There’s a lot that can be enhanced and added to the application, but the beauty of an open source project is that anyone can contribute to it – even you! Check out and post on the <strong class="bold">discussion boards</strong> with questions or comments on the game or book. The issues listed in the repository capture various pieces of work that different folks have identified as needing to be addressed or implemented. Different labels denote and categorize the issues in different ways – for example, the <em class="italic">“Good First Issue”</em> label is intended to give new contributors a simple or straightforward task that can get their feet wet and can be done relatively easily without discussion. See the list of issues at <a href="https://github.com/jelster/space-truckers/issues">https://github.com/jelster/space-truckers/issues</a> and discussions at <a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a>. </p>
<p>Our turn signal is on as we prepare to reach the terminal phase of our space-road trip – we’re approaching the end of the line! As we navigate our way through local streets and intersections towards the space docks for delivery, we still have a few loose ends to wrap up. The next chapter is going to be a grab-bag of topics, as we try to fit in as much as possible about all the things that we haven’t previously covered. Local guides will help us navigate these winding and sometimes convoluted streets as we look at cutting-edge topics such as real-time ray tracing (path marching), <strong class="bold">WebXR</strong>, VR and AR applications, and Babylon Native, but also important pragmatic subjects such as using Babylon.js with a CMS or e-commerce application. Keep your seatbelts buckled – this trip isn’t finished yet!</p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor289"/>Extended Topics</h1>
<ul>
<li>Use an SW to do something other than fetch and cache data. Take your framerates to the ultimate by moving the Space-Trucker rendering into an <em class="italic">offscreen canvas</em>. Essentially, you’ll use SW to do the actual rendering work on a different execution thread from the single main thread JavaScript is normally stuck with. The Babylon.js docs go into more detail on this at <a href="https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas">https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas</a>. </li>
<li>Add a button or key combination that clears all existing scores from the database. This is a two-part feature: the first task would be to add the ability to remove or clear the scores in <strong class="source-inline">SpaceTruckerDb</strong> and the second to provide a way for that to be invoked.</li>
<li>Animate the entrance of each individual score in the list. Bonus points for effects that change with the rank of the score. Even more bonus points for giving players a nice fireworks display when they get a top score.</li>
<li>Split the entry JavaScript module so that the landing page, scores, and main menu are in the initially loaded module with the driving and route planning sections in separate ones. This will supercharge the initial page load time and allow the SW to fetch game assets more efficiently.</li>
</ul>
</div>
<div>
<div id="_idContainer135">
</div>
</div>
</div></body></html>