<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries</h1></div></div></div><p>In this chapter, we'll take an introductory look at a mix of general-purpose and Backbone-specific third-party libraries, all of which can benefit you as a Backbone developer. In particular, we'll look at the following:</p><div><ul class="itemizedlist"><li class="listitem">Dependency management tools Require.js and Bower</li><li class="listitem">Table-generation tools Backbone Paginator and BackGrid</li><li class="listitem">HTML templating tool Handlebars</li><li class="listitem">Task automation tool Grunt</li><li class="listitem">Alternate language CoffeeScript</li><li class="listitem">General-purpose Backbone utility library BackSupport</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec89"/>The Backbone ecosystem</h1></div></div></div><p>In the five years that <a id="id311" class="indexterm"/>Backbone has existed, its popularity has resulted in the development of hundreds of related third-party libraries. In addition, numerous other general-purpose libraries have been released, which can also be of great value to a Backbone developer. While we don't have room to explore these libraries in depth, this chapter will provide you with a preview of each library so that you can identify the ones that would be most beneficial to you.</p><p>As we cover the libraries in this chapter, keep in mind that for each library that we preview, there exist several (and sometimes several dozen) competing libraries that we didn't feature. While we could try to list every available library in each category, such a list would quickly become out of date, so instead we've chosen to focus only on the most popular offerings. If any of the libraries in this chapter strike you as useful, we strongly recommend searching the Internet to see what other similar libraries are available, as you may well find one that better suits you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Dependency management with RequireJS</h1></div></div></div><p>With modern IDEs, it is possible for a<a id="id312" class="indexterm"/> developer to open a file by typing just <a id="id313" class="indexterm"/>a few characters of that file's name. This feature, along with a general desire to keep code organized, has motivated developers to separate their code into multiple files. In Backbone, this typically means creating one file for every <code class="literal">Collection</code>, <code class="literal">Model</code>, <code class="literal">View</code>, and <code class="literal">Router</code>, and even in a small project, this can add up to a lot of files.</p><p>All these files create two problems. First, each file needs to be downloaded separately, and as we learned in <a class="link" title="Chapter 8. Scaling Up – Ensuring Performance in Complex Applications" href="part0076.xhtml#aid-28FAO1">Chapter 8</a>, <em>Scaling Up: Ensuring Performance in Complex Applications</em>, browsers can only download between 2 and 8 files at once. Second, the order in which files are loaded can become increasingly hard to manage, because of the dependencies among the different files (<code class="literal">View A</code> needs <code class="literal">Collection B</code>, which needs <code class="literal">Model C</code>, which needs …). <strong>RequireJS</strong> (<a class="ulink" href="http://requirejs.org/">http://requirejs.org/</a>) solves<a id="id314" class="indexterm"/> both of these problems.</p><p>RequireJS does this by organizing your code into <code class="literal">modules</code>. Each module can optionally depend on one or more other modules, and RequireJS will take care of stitching the modules together in a way that preserves all of their dependencies. RequireJS also provides a related tool, called RequireJS Optimizer, which allows you to combine multiple modules into a single file. The optimizer can also "minify" your code, as well as "uglify" it, making it harder for others to understand (to prevent competitors from reading your source files).</p><p>Here's an example RequireJS module for a BookList <code class="literal">View</code> class:</p><div><pre class="programlisting">// All RequireJS modules start by calling a special "define" function
define([
    // The module's dependencies are the first argument
    'collections/Books', // dependency on collections/Books.js
    'models/Book'       // dependency on models/Book.js

// The function that defines the module is the second argument
], function(
    // The variable names for each dependency make up the arguments to that function    Books, // alias the "collections/Books" module as "Books"
    Book   // alias the "models/Book" module as "Book"
) {
    // The actual module itself goes here
    var BookList = Backbone.View.extend({
        // Logic for our BookList View would go here; presumably it
        // would use both Book and Books
    });
    // To tell RequireJS what variable this module should "define" simply return
    // that variable at the end
    return BookList;
    // in other words, whatever is returned will be what is passed in
    // to other modules that depend on this one
});</pre></div><p>RequireJS's style of <a id="id315" class="indexterm"/>managing dependencies is known as the<a id="id316" class="indexterm"/> <strong>AMD</strong> style. There is also a competing style, known as<a id="id317" class="indexterm"/> <strong>Common JS</strong>, which is used by other dependency <a id="id318" class="indexterm"/>management libraries such as Browserify or Hem. Common JS modules look significantly different; here's our previous example rewritten using Browserify's Common JS syntax:</p><div><pre class="programlisting">// Dependencies are brought in by using the "require" function
// The module aliases are defined on the same line using the 
// standard JavaScript syntax for declaring a variable
var books = require('collections/Books');
var book = require('models/Book');
// Just as before, the contents of the module are defined using
// standard JavaScriptBookList = Backbone.View.extend({
    // Logic for our BookList View would go here; presumably it would
    // use both Book and Books
});
// Instead of returning what the module defines, in CommonJS modules
// are "exported" by assigning them to a "module.exports"module.exports.BookList = BookList;</pre></div><p>The downside to this approach is that the actual ordering of the modules isn't handled for you, as it is in RequireJS. Instead, the order of the modules must be spelt out separately using <code class="literal">require</code> statements:</p><div><pre class="programlisting">&lt;script src="img/fileWithModuleDefinitions.js"/&gt;
&lt;script&gt;
require('collections/Books');
require('models/Book');
require('views/BookList');
&lt;/script&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec91"/>External dependency management with Bower</h1></div></div></div><p>In addition to using <a id="id319" class="indexterm"/>RequireJS or a similar library for <a id="id320" class="indexterm"/>managing your code's dependencies, many programmers also use a second tool called <a id="id321" class="indexterm"/>
<strong>Bower</strong> (<a class="ulink" href="http://bower.io/">http://bower.io/</a>) to manage their external library dependencies. Much like Python's <code class="literal">pip</code> or Node.js's NPM, Bower offers a simple command line interface for easily installing external libraries. It's worth noting that NPM itself can also be used for managing libraries on the client-side, but this tool is designed primarily for server-side developers, whereas Bower is designed primarily for use on the client-side. To install a library, such as jQuery, one would simply run the following command at the command line:</p><div><pre class="programlisting">bower install jquery</pre></div><p>Multiple Bower dependencies can be stored in a <code class="literal">bower.json</code> file, allowing you to install all of your application's dependencies with a single command. Here's an example of what such a file might look like:</p><div><pre class="programlisting">{
    "name": "your-project",
    "version": "0.0.1",
    "ignore": [
        "**/*.txt"
    ],
    "dependencies": {
        "backbone": "1.0.0",
        "jquery": "~2.0.0"
    },
     "devDependencies": {
        "mocha": "^1.17.1"
    }
}</pre></div><p>As you can see, the preceding file defines the dependencies for your project. It includes Backbone and jQuery but not Underscore; as a dependency of Backbone, Underscore will be downloaded automatically (jQuery isn't technically a dependency of Backbone, as the library will work without it, so we have to require it separately). It also lets us include Mocha as <code class="literal">devDependency</code>, which means that it will be downloaded in a development environment but not in a production one. Using a requirements file like this allows you to keep your external libraries out of your source control system and to easily update them when new versions come out. It also allows you to easily manage different builds of these libraries (for instance, the debugging version versus the minified version).</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec92"/>Paginating with Backbone Paginator</h1></div></div></div><p>One very common task many <a id="id322" class="indexterm"/>Backbone developers are faced with is rendering paginated data. For example, you might have a search page that can return hundreds of results, but you only want to show the first twenty results. To do this, you essentially need two <code class="literal">Collection</code> classes: one for all of the results and the other for the results being displayed. However, switching between the two can be tricky, and you may not actually want to fetch hundreds of results at once. Instead, you might just want to fetch the first twenty, but still be able to know how many total results are available so that you can display that information to your users.</p><p>Backbone Paginator (<a class="ulink" href="https://github.com/backbone-paginator/backbone.paginator">https://github.com/backbone-paginator/backbone.paginator</a>) is a <a id="id323" class="indexterm"/>specialized <code class="literal">Collection</code> class created expressly for <a id="id324" class="indexterm"/>this purpose. Backbone Paginator was originally two separate libraries, but these libraries have since merged making Backbone Paginator the primary tool for handling paginated data in Backbone.</p><p>Backbone Paginator can be used in one of the <a id="id325" class="indexterm"/>following three modes:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">client</code>: For when<a id="id326" class="indexterm"/> you want to fetch with your entire <code class="literal">Collection</code> at once</li><li class="listitem"><code class="literal">server</code>: For<a id="id327" class="indexterm"/> when you want to leave most of the <code class="literal">Collection</code> on the server and only fetch the relevant parts</li><li class="listitem"><code class="literal">infinite</code>: For<a id="id328" class="indexterm"/> creating a <code class="literal">Collection</code> class to power a Facebook-like infinite scroll view.</li></ul></div><p>To use Backbone Paginator, you simply extend its <code class="literal">PageableCollection</code> class to create your own pageable <code class="literal">Collection</code> class, as follows:</p><div><pre class="programlisting">var BookResults = Backbone.PageableCollection.extend({
    model: BookResult,
    queryParams: {
        currentPage: 'selected_page',
        pageSize: 'num_records'
    },
    state: {
        firstPage: 0,
        currentPage: 5,
        totalRecords: 500
		},
		url: 'www.example.com/api/book_search_results'
});</pre></div><p>As you can see a <code class="literal">PageableCollection</code> class is very similar to a normal <code class="literal">Collection</code> class: It has the <code class="literal">model</code> and <code class="literal">url</code> properties, can be extended, and so on. However, it also has two special properties.</p><p>The first of these properties is <code class="literal">queryParams</code>, which tells <code class="literal">PageableCollection</code> how to interpret the pagination information in your server's response, in much the same way that a <code class="literal">parse</code> method normally tells Backbone how to interpret your server's response. The second property is <code class="literal">state</code>, which <code class="literal">PageableCollection</code> uses to keep track of which page of results the user is currently on, how many results there are in a page, and so on.</p><p>The full Backbone <a id="id329" class="indexterm"/>Paginator library has several other options for both <code class="literal">queryParams</code> and <code class="literal">state</code>, as well as a set of pagination methods such as <code class="literal">getPage</code> (for moving to a specific page of results) or <code class="literal">setSorting</code> (for changing how the results are sorted). If you want to implement a paginated view yourself, you can find full documentation of Backbone Paginator on its GitHub page. However, as it turns out, you may not want to create your own <code class="literal">View</code> of paginated data at all, because there's already a very powerful existing one that you can leverage instead: BackGrid.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec93"/>Rendering tables with Backgrid.js</h1></div></div></div><p>There are several different <a id="id330" class="indexterm"/>table <code class="literal">View</code> libraries available specifically for <a id="id331" class="indexterm"/>rendering tables in Backbone, and there are also many popular non-Backbone specific libraries (such as <code class="literal">jqGrid</code> or <code class="literal">DataTables</code>) that you can easily adapt for use in Backbone. However, <a id="id332" class="indexterm"/>BackGrid (<a class="ulink" href="http://backgridjs.com/">http://backgridjs.com/</a>) stands out from the rest because it combines a powerful feature set, simple design, and support for Backbone Paginator <em>out of the box</em>.</p><p>Here's an example of a table generated using BackGrid:</p><div><img src="img/image00170.jpeg" alt="Rendering tables with Backgrid.js"/></div><p style="clear:both; height: 1em;"> </p><p>To use BackGrid, you simply extend it, just as you would with any other <code class="literal">View</code> and then, instantiate it with one extra <code class="literal">columns</code> option:</p><div><pre class="programlisting">var BookResultsGrid =  Backgrid.Grid.extend();
var grid = new BookResultsGrid({
    columns: [
        {name: 'bookTitle', label: 'title', cell: 'string'},
        {name: 'numPages', label: '# of Pages', cell: 'integer'},
        {name: 'authorName', label: 'Name of the Author',
         cell: 'string'}
    ],
    collection: bookResults
});
grid.render();</pre></div><p>As you can see the <a id="id333" class="indexterm"/>extra <code class="literal">columns</code> option that you provide tells <a id="id334" class="indexterm"/>BackGrid which attribute of <code class="literal">Model</code> to use for the column's data (<code class="literal">name</code>), what this column's header text should be (<code class="literal">label</code>), and how BackGrid should format cells in this column (<code class="literal">cell</code>). Once you provide BackGrid with these columns and a <code class="literal">Collection</code> class, BackGrid will generate a <code class="literal">&lt;table&gt;</code> element as its <code class="literal">el</code> by using each <code class="literal">Model</code> in the provided <code class="literal">Collection</code> to generate a <code class="literal">&lt;tr&gt;</code> element.</p><p>If you only want a table that displays information that's all you need to do, but BackGrid can also be optionally used to edit information. To use this feature, you just need to pass one other <code class="literal">editable: true</code> option in each column that you want to make editable. When BackGrid renders its table, users will be able to click on any cells in the editable columns to switch the selected cell into the <em>edit</em> mode (for instance, replacing plain text with an HTML <code class="literal">&lt;input&gt;</code> tag), and any changes that the user makes will be automatically updated in the appropriate <code class="literal">Model</code>.</p><p>BackGrid has many <a id="id335" class="indexterm"/>other features as well, such as the ability to <a id="id336" class="indexterm"/>define your own custom cell types by extending Backgrid.Cell. You can find the full list of these features on Backgrid's website, which has excellent tutorial-style documentation and API reference documentation.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec94"/>Templating with Handlebars</h1></div></div></div><p>As we discussed in <a class="link" title="Chapter 5. Adding and Modifying Elements with Views" href="part0050.xhtml#aid-1FLS42">Chapter 5</a>, <em>Adding and Modifying Elements with Views</em>, using templates to render<a id="id337" class="indexterm"/> your View's HTML offers many benefits. While you<a id="id338" class="indexterm"/> can simply use Underscore's <code class="literal">template</code> function, if you want a more powerful templating language there are many different libraries to choose from. For this chapter, we are going to use <a id="id339" class="indexterm"/>Handlebars (<a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>) as our templating engine. Other libraries you may want to consider include <a id="id340" class="indexterm"/>Mustache (<a class="ulink" href="https://github.com/janl/mustache.js">https://github.com/janl/mustache.js</a>), Embedded JS<a id="id341" class="indexterm"/> (<a class="ulink" href="http://embeddedjs.com/">http://embeddedjs.com/</a>), or<a id="id342" class="indexterm"/> Hogan.js (<a class="ulink" href="http://twitter.github.io/hogan.js/">http://twitter.github.io/hogan.js/</a>).</p><p>Handlebars, which was created from another templating library (Mustache), offers a significant amount of in-template logic in the form of "helper". For instance, here's a Handlebars template that uses an "each" helper and an "if" helper to render a list of last names prefaced with either "Mr." or "Ms.," depending on the person's gender:</p><div><pre class="programlisting">&lt;ul&gt;
    {{#each people}}
    &lt;li&gt;
        {{#if this.isMale}}Mr.{{else}}Ms.{{/if}} {{this.lastName}}
    &lt;/li&gt;
    {{/each}}
&lt;/ul&gt;</pre></div><p>Handlebars also allows you to define your own custom helpers, which makes it very extensible. These helpers are so flexible that you could create an entire sub-language within your templates if you so desire.</p><p>Once you have a template written, you can either include it directly in your JavaScript code (wrapped in quotation marks to make it a valid string), or you can store it in a separate file and use RequireJS or a similar tool to bring it in. Thereafter, it's a simple matter of compiling the template and writing a <code class="literal">View render</code> method that<a id="id343" class="indexterm"/> uses this template, as <a id="id344" class="indexterm"/>follows:</p><div><pre class="programlisting">var template = '&lt;ul&gt;' +
    '{{#each people}}' +
    '&lt;li&gt;' +
        '{{#if this.isMale}}Mr.{{else}}Ms.{{/if}} {{this.lastName}}' +
    '&lt;/li&gt;' +
    '{{/each}}' +
'&lt;/ul&gt;';
var compiledTemplate = Handlebars.compile(template);
var TemplatedView = Backbone.View.extend({
    render: function() {
        var templatedHtml = compiledTemplate(this.model.toJSON());
        this.$el.html(templatedHtml);
        return this;
    }
});
new TemplatedView({
    model: new Backbone.Model({isMale: 'true', lastName: 'Smith'})
}).render().$el.html(); // will be "Mr. Smith"</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec95"/>Automating tasks with Grunt</h1></div></div></div><p>In many software projects, there <a id="id345" class="indexterm"/>are a number of tasks that are typically automated. For <a id="id346" class="indexterm"/>instance, just as a traditional C++ or Java project would need to compile the source code into byte code, a JavaScript project might need to use RequireJS or CoffeeScript to compile its source. The project might also need to concatenate files, run linting programs to validate the source, or assemble other web components such as sprite image files or SCSS/Less-generated CSS files.</p><p>Most of these tasks aren't language-specific: you don't need to actually use JavaScript code in order to start RequireJS Optimizer; you just need a command line. Because of this, it's possible to use a tool designed for another language (such as Ant or Maven for Java, or Fabric for Python) to automate these tasks, and if your server-side team is using such a language, it might be helpful to have everyone using the same tool.</p><p>However, if you don't have a server-side team (or if that team uses <code class="literal">Node.js</code>), you may wish to have a JavaScript-specific build tool, and this is where Grunt comes in. Here's an example Grunt configuration file that can be used to run RequireJS Optimizer:</p><div><pre class="programlisting">module.exports = function(grunt) {
    grunt.initConfig({
        requirejs: {
            app: {
                options: {
                    findNestedDependencies: true,
                    mainConfigFile: 'public/js/config.js',
                    baseUrl : 'public/js',
                    name : 'app',
                    out : 'build.js',
                    optimize : 'none'
                }
            }
        }
    });
    grunt.loadNpmTasks('grunt-contrib-requirejs');
    grunt.registerTask('default', ["requirejs"]);
};</pre></div><p>While a full explanation of the preceding code is outside the scope of this book, it is sufficient to say that by using this configuration file, you can run a single command at the command line to invoke <a id="id347" class="indexterm"/>RequireJS Optimizer. More importantly, you<a id="id348" class="indexterm"/> can make RequireJS Optimizer just one step of your entire deployment process and then, invoke that entire process by using a single command. You can also use Grunt to set up different processes for different environments, such as one process for setting up a development environment and a different one for setting up a production server.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec96"/>New syntax with CoffeeScript</h1></div></div></div><p>You would think that as the creator of Backbone (and <strong>Underscore</strong> and <strong>Docco</strong>), Jeremy Ashkenas would have enough on his hands … but you'd be wrong. Somewhere in between creating these three libraries, Jeremy also found the time to create an entirely new programming language called <a id="id349" class="indexterm"/>
<strong>CoffeeScript</strong> (<a class="ulink" href="http://coffeescript.org/">http://coffeescript.org/</a>).</p><p>CoffeeScript<a id="id350" class="indexterm"/> is interesting to many web developers because of the following two key features: </p><div><ol class="orderedlist arabic"><li class="listitem">CoffeeScript compiles to JavaScript, which means that you can use it for development but then compile it into a language that your user's browsers can actually understand.</li><li class="listitem">CoffeeScript offers a syntax and feature set that have more in common with languages such as Python or Ruby than with "vanilla" JavaScript.</li></ol><div></div><p>This is best explained by example. Here's how you would create a <code class="literal">View</code> class for an <code class="literal">h1</code> element in CoffeeScript:</p><div><pre class="programlisting">class HeaderView extends Backbone.View
    tagName: 'h1'
    initialize: -&gt;
        @render
    render: -&gt;
        $(@el).text 'Hello World!'
header = new  HeaderView</pre></div><p>Here are some of the<a id="id351" class="indexterm"/> key differences that we just demonstrated:</p><div><ul class="itemizedlist"><li class="listitem">CoffeScript has its own syntax for declaring classes</li><li class="listitem">CoffeeScript uses indentation rather than curly braces ("<code class="literal">{}</code>") to mark where a function starts/stops</li><li class="listitem">CoffeeScript declares functions using <code class="literal">-&gt;</code> instead of <code class="literal">function() {} this</code> can be referenced as <code class="literal">@</code> the parentheses in function calls are optional</li></ul></div><p>Together these (and many other) features make CoffeeScript a significant improvement over JavaScript. However, there is a catch to using it. Because it compiles to JavaScript, debugging can be tricky, as the browser will use the JavaScript line numbers instead of the CoffeeScript line numbers when reporting errors. Also, when using the browser's debugger, you will walk through the JavaScript code, not the CoffeeScript code. While a new technology called "source maps" can help reduce these issues, it doesn't eliminate them entirely.</p><p>If you are willing to put up with the abovementioned inconveniences, CoffeeScript can provide you with a syntax and a feature set that JavaScript itself won't have for many years, if ever. Further, because it was created by Jeremy Ashkenas, you can be rest assured that Backbone will always be compatible with CoffeeScript. In fact, Jeremy added at least one feature to Backbone, the hidden <code class="literal">__super__</code> property, specifically to support CoffeeScript.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Making life easier with BackSupport</h1></div></div></div><p>When I first started working with <a id="id352" class="indexterm"/>Backbone a few years ago, I was inspired to write <a id="id353" class="indexterm"/>BackSupport (<a class="ulink" href="https://github.com/machineghost/BackSupport">https://github.com/machineghost/BackSupport</a>) to help eliminate a lot of boilerplate code that I found myself writing over and over again. For instance, consider this basic <code class="literal">View</code> class:</p><div><pre class="programlisting">var BookView = ParentBookView.extend({
    className: ParentBookView.prototype.className + ' book-view',
    initialize: function(options) {
        this.template = options.template ;
        if (!this.template ) {
            throw new Error('The template option is required!');
        }
        _.bindAll(this, ''render');
    },
    render: function() {
        this.$el.html(this.template(this.model.toJSON()));
   }
});</pre></div><p>Now, what if there were a way to reduce all that common code to just the parts that are specific to our class? This is where BackSupport comes in. Let's look at that same <code class="literal">View</code> class recreated using BackSupport:</p><div><pre class="programlisting">BookView = ParentBookView.extend2({
    boundMethods: ['render'],
    className: "book-view",
    propertyOptions: ['template'],
    requiredOptions: ['template'],
});</pre></div><p>As you can see, BackSupport simplified so much of our logic that we didn't even need an <code class="literal">initialize</code> method in our second version!</p><p>Here are all of the BackSupport features demonstrated:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">extend2</code>: This<a id="id354" class="indexterm"/> alternate form of Backbone's <code class="literal">extend</code> is smart enough to combine, rather than replace, properties such as <code class="literal">className</code>, <code class="literal">events</code>, or <code class="literal">defaults</code>. This allows you to more easily create subclasses that use these properties, without losing their values from the parent class.</li><li class="listitem"><code class="literal">boundMethods</code>: BackSupport will <a id="id355" class="indexterm"/>automatically call <code class="literal">_.bindAll</code> on every method included in this property, so we don't have to do it manually in an <code class="literal">initialize</code> method.</li><li class="listitem"><code class="literal">propertyOptions</code>: BackSupport will <a id="id356" class="indexterm"/>automatically transform any option included in this property into a new property of instances of this class, saving us from the tedium of doing <code class="literal">this.foo = options.foo</code> in our <code class="literal">initialize</code>.</li><li class="listitem"><code class="literal">requiredOptions</code>: BackSupport <a id="id357" class="indexterm"/>will throw an error if a class is instantiated without providing these options, giving us a simple way to ensure that they are provided without adding extra <code class="literal">initialize</code> logic.</li><li class="listitem"><code class="literal">render</code>: BackSupport<a id="id358" class="indexterm"/> provides a set of methods to make using templates easier. These methods are completely agnostic as to which templating system you use, and to choose a particular templating system, you need to only override the relevant BackSupport methods.</li></ul></div><p>While this simple example provides a taste of what BackSupport offers, it also has many other great convenience features, which you can learn about on its GitHub page.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec98"/>Summary</h1></div></div></div><p>In this chapter, we learned about the great variety of tools available to the Backbone community. In particular, we looked at RequireJS and Bower for dependency management, Backbone Paginator and BackGrid for rendering paginated tables, and Handlebars for templating. We also looked at using Grunt for build management, CoffeeScript for an alternative syntax, and this author's own tool, BackSupport, for general-purpose solutions to many of the minor inconveniences of Backbone.</p><p>In the next chapter, we'll wrap things up by reviewing a summary of everything we've covered in this book. We'll also take a brief look at how the lessons learned can be applied to a real-world use case. Finally, we'll finish up with a look into the sources for learning even more about Backbone.</p></div></body></html>