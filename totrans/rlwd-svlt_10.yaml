- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: State Management with Svelte Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Svelte存储进行状态管理
- en: Every user interface control has a state. A checkbox has a checked-unchecked
    state. A textbox’s state is its current input value. A table’s state is the data
    displayed and the columns currently being sorted. Sometimes when you have multiple
    user interface controls present across the screen at the same time, you need to
    synchronize the state across them—this is where state management comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户界面控件都有一个状态。复选框有一个选中/未选中的状态。文本框的状态是其当前的输入值。表格的状态是显示的数据和当前排序的列。有时，当屏幕上同时存在多个用户界面控件时，你需要同步它们的状态——这就是状态管理的作用所在。
- en: In this chapter, we are going to discuss managing states in Svelte using Svelte
    stores. We will start with why we should use Svelte stores, and then discuss tips
    that will help you when using Svelte stores for state management.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用Svelte存储进行状态管理。我们将从为什么应该使用Svelte存储开始，然后讨论使用Svelte存储进行状态管理时的一些技巧。
- en: Next, we will go into the topic of using state management libraries. We will
    talk about why and how to use them. With that, we will be going through a few
    examples of integrating third-party state management libraries into Svelte through
    Svelte stores.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨使用状态管理库的主题。我们将讨论为什么以及如何使用它们。在此基础上，我们将通过几个示例展示如何通过Svelte存储将第三方状态管理库集成到Svelte中。
- en: 'This chapter includes sections on the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题的章节：
- en: Managing states with Svelte stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Svelte存储管理状态
- en: Using state management libraries with Svelte
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Svelte中使用状态管理库
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10)。
- en: Managing states with Svelte stores
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Svelte存储管理状态
- en: When building an interactive user interface, the first thing we consider is
    determining the necessary states to represent the various components and interactions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建交互式用户界面时，我们首先考虑的是确定表示各种组件和交互所需的状态。
- en: 'For example, in the following snippet, I have a login form that has a few components,
    including two inputs, one checkbox, and one button:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码片段中，我有一个包含几个组件的登录表单，包括两个输入框、一个复选框和一个按钮：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each of the Svelte components has multiple states, as outlined here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Svelte组件都有多个状态，如下所述：
- en: The `<Input />` component has an input value state and an error state set during
    validation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Input />` 组件有一个输入值状态和验证期间设置的错误状态'
- en: The `<Checkbox />` component has a checked/unchecked state, checked to reveal
    the password in the input
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Checkbox />` 组件有一个选中/未选中的状态，选中时会在输入框中显示密码'
- en: The password `<Input />` component has an additional state to reveal/hide the
    password
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码 `<Input />` 组件有一个额外的状态来显示/隐藏密码
- en: The `<Button />` component has an enabled/disabled state, disabled when the
    form is incomplete
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Button />` 组件有一个启用/禁用状态，当表单不完整时禁用'
- en: Each of these states can be represented by a variable. The variables themselves
    can be interrelated.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态中的每一个都可以用一个变量来表示。这些变量本身可以是相互关联的。
- en: Let us examine how these variables can be related to each other. For example,
    when the checkbox is checked, the password input needs to reveal the password.
    When the name and password inputs are filled, the button needs to turn into an
    enabled state. When the button is pressed, validation is performed, and the inputs’
    error state is updated accordingly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些变量如何相互关联。例如，当复选框被选中时，密码输入需要显示密码。当姓名和密码输入被填写时，按钮需要变为启用状态。当按钮被按下时，执行验证，并相应地更新输入的错误状态。
- en: The art of managing multiple states across components to form a cohesive experience
    is called state management.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件之间管理多个状态以形成一个连贯体验的技艺被称为状态管理。
- en: 'It would be clearer and easier to group all these states together and manage
    them as one, rather than separate individual states. In the following snippet,
    I group all of the aforementioned variables into one variable object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些状态分组在一起并作为一个整体来管理，会比分别管理单个状态更清晰、更容易。在下面的代码片段中，我将上述所有变量组合成一个变量对象：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you can see the related states in one place, making it easier to see and
    tell if something is wrong.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到相关状态集中在一个地方，这使得更容易查看并判断是否有错误发生。
- en: 'To illustrate this, let’s say the `nameValue` and `submitDisabled` variables
    are kept as two separate variables in two separate components; in the `Input`
    component, we have the `nameValue` variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们假设`nameValue`和`submitDisabled`变量被保留为两个单独的组件中的两个单独的变量；在`Input`组件中，我们有`nameValue`变量：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And in the `Button` component, we have the `submitDisabled` variable:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Button`组件中，我们有一个`submitDisabled`变量：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the code, you can see that it is not straightforward to tell whether the
    `nameValue` and `submitDisabled` variables are related. If one of the states is
    not updated as expected, you don’t have one convenient place to inspect both states
    at once; you will have to inspect them in each separate component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中，你可以看到很难直接判断`nameValue`和`submitDisabled`变量是否相关。如果某个状态没有按预期更新，你没有一个方便的地方可以同时检查这两个状态；你将不得不在每个单独的组件中检查它们。
- en: For example, if the `submitDisabled` state in the `<Button />` component did
    not change to `false` to enable the button after typing in the name input, you
    would need to find and inspect the `nameValue` variable in a separate component
    (the `<Input />` component).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`<Button />`组件中的`submitDisabled`状态在输入名称后没有改变为`false`以启用按钮，你将需要在一个单独的组件（`<Input
    />`组件）中找到并检查`nameValue`变量。
- en: 'If, instead, the states are grouped into a `state` object, then you can inspect
    the `state` object and check the `nameValue` and the `submitDisabled` properties
    and see if they are set correctly. Have a look at the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，相反，状态被组合成一个`state`对象，那么你可以检查`state`对象并查看`nameValue`和`submitDisabled`属性是否设置正确。看看下面的例子：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we’ve established that we should group multiple related states into
    one state object, the next question is this: If we could group states using a
    simple JavaScript object, why would it be necessary to group states using a Svelte
    store?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定应该将多个相关状态组合成一个状态对象，接下来的问题是：如果我们可以使用简单的JavaScript对象来组合状态，为什么还需要使用Svelte存储来组合状态呢？
- en: Well, the truth is, it is not always necessary. In some cases, using a simple
    JavaScript object to group states can work just as effectively. However, a Svelte
    store offers additional benefits and functionality that can enhance your state
    management experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，事实是，这并不总是必要的。在某些情况下，使用简单的JavaScript对象来组合状态可以同样有效。然而，Svelte存储提供了额外的功能和好处，可以增强你的状态管理体验。
- en: As we explored in [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), a Svelte
    store is useful as it can be passed around components and have its updates propagate
    across components. Then, in [*Chapter 9*](B18887_09.xhtml#_idTextAnchor135), we
    saw how useful a Svelte store is, being able to encapsulate logic within the Svelte
    store, as well as being able to define data logic right next to the data itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第8章*](B18887_08.xhtml#_idTextAnchor121)中探讨的那样，Svelte存储非常有用，因为它可以在组件之间传递，并且其更新可以在组件之间传播。然后在[*第9章*](B18887_09.xhtml#_idTextAnchor135)中，我们看到了Svelte存储是多么有用，它能够封装逻辑在Svelte存储中，以及能够定义数据逻辑紧挨着数据本身。
- en: 'So, for the sake of the chapter, we are going to proceed with grouping multiple
    related states into a state object using a Svelte store. Here’s a short snippet
    of code of how it would look:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了本章的目的，我们将继续使用Svelte存储将多个相关状态组合成一个状态对象。以下是如何看起来的一段简短代码片段：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we use a `writable()` store for creating the state object because we will
    be modifying the state object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`writable()`存储来创建状态对象，因为我们将会修改状态对象。
- en: The state object can be defined either inside or outside a Svelte component.
    Since our state object is a Svelte store, we can import the state object into
    any component, and any updates to the state object will be propagated across all
    Svelte components that use the state object—so, it doesn’t matter in which file
    we define the state object in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 状态对象可以在Svelte组件内部或外部定义。由于我们的状态对象是一个Svelte存储，我们可以将状态对象导入到任何组件中，并且任何对状态对象的更新都将传播到所有使用状态对象的Svelte组件——所以，状态对象在哪个文件中定义并不重要。
- en: 'If we define our state object in a Svelte component, then we can pass our state
    object to the component’s child component through props. Here’s an example of
    doing so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Svelte组件中定义我们的状态对象，那么我们可以通过props将状态对象传递给组件的子组件。以下是一个这样的例子：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the other hand, if we define our state object in a JavaScript module, then
    we can import our state object into any Svelte components that will be using the
    state object. The following is a snippet of importing a Svelte store state object
    into a Svelte component:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们在一个 JavaScript 模块中定义我们的状态对象，那么我们可以将我们的状态对象导入任何将使用状态对象的 Svelte 组件。以下是将
    Svelte 存储状态对象导入 Svelte 组件的代码片段：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), we learned how to read,
    subscribe to, and update a Svelte store. Whether the data stored inside a Svelte
    store is a state object or anything else, there is no difference in terms of the
    operations to read, subscribe, and update the Svelte store state object like any
    other Svelte store.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18887_08.xhtml#_idTextAnchor121) 中，我们学习了如何读取、订阅和更新 Svelte 存储的内容。无论存储在
    Svelte 存储中的数据是状态对象还是其他任何东西，在读取、订阅和更新 Svelte 存储状态对象的操作上都没有区别，就像任何其他 Svelte 存储一样。
- en: But as the state is used more frequently in a growing project, you will have
    more state values inside a `state` store object. As the `state` store gets larger
    and more complex, your application may get slower, and you may feel the need to
    optimize/improve it. Therefore, I am dedicating the following subsections to sharing
    my tips and opinions on state management with a Svelte store.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着状态在增长的项目中使用频率越来越高，你将在 `state` 存储对象内部拥有更多的状态值。随着 `state` 存储对象变得更大和更复杂，你的应用程序可能会变慢，你可能会有优化/改进它的需求。因此，我将以下小节专门用于分享我关于使用
    Svelte 存储进行状态管理的技巧和观点。
- en: Of course, you shouldn’t apply all these methods blindly. As said by Donald
    Knuth, the famous computer scientist, “*Premature optimization is the root of
    all evil*”—you should measure and evaluate whether any of the following tips apply.
    As I go through the tips, I will explain what they are and why and when are they
    useful.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不应该盲目地应用所有这些方法。正如著名计算机科学家唐纳德·克努特所说，“*过早优化是万恶之源*”——你应该衡量和评估以下任何一条建议是否适用。随着我介绍这些技巧，我会解释它们是什么，为什么以及何时它们是有用的。
- en: Tip 1 – simplify complex state updates with unidirectional data flow
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小贴士 1 – 使用单向数据流简化复杂的状态更新
- en: When your application becomes more complex, with multiple components and multiple
    places to update your state, managing state updates becomes even more challenging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序变得更加复杂，有多个组件和多个更新状态的地方时，管理状态更新变得更加具有挑战性。
- en: 'How would you know when managing state updates becomes unmanageable? You may
    run into situations such as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道管理状态更新变得难以控制？你可能会遇到以下情况：
- en: Your application state changes, and you find it hard to track down why the state
    changed
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的状态发生变化，而你发现很难追踪状态变化的原因
- en: You change a certain state value, but unknowingly, this causes other seemingly
    unrelated state values to update as well, and you have a hard time working out
    why
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你更改了某个状态值，但无意中，这导致其他看似无关的状态值也进行了更新，而你很难找出原因
- en: These are signs that the state updates have grown complex and become difficult
    to manage. In such situations, having unidirectional data flow can help simplify
    state management.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迹象表明状态更新已经变得复杂且难以管理。在这种情况下，拥有单向数据流可以帮助简化状态管理。
- en: With unidirectional data flow, state updates are managed in a single direction,
    and the flow of data can be easily traced and debugged.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单向数据流，状态更新以单一方向进行管理，数据流可以轻松追踪和调试。
- en: There are state management libraries such as Redux, MobX, and XState that help
    to enforce a single data flow and enable you to reason with the state changes.
    You may be curious about how to use these state management libraries with a Svelte
    store; I will be covering them later in this chapter and will use one of the libraries
    as an example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些状态管理库，如 Redux、MobX 和 XState，可以帮助强制执行单一数据流并使你能够对状态变化进行推理。你可能对如何使用这些状态管理库与
    Svelte 存储感兴趣；我将在本章的后面部分介绍它们，并将使用其中一个库作为示例。
- en: Tip 2 – prefer smaller self-contained state objects over one big state object
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小贴士 2 – 相比于一个大型的状态对象，更倾向于使用较小的自包含状态对象
- en: In Svelte, when a state object changes, all components that use that state object
    are updated, even if the specific state value that a component uses did not change.
    This means that if a state object becomes larger and more complex, with many unrelated
    state values, updating that state object can trigger unnecessary updates to many
    components in the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: In Svelte, when a state object changes, all components that use that state object
    are updated, even if the specific state value that a component uses did not change.
    This means that if a state object becomes larger and more complex, with many unrelated
    state values, updating that state object can trigger unnecessary updates to many
    components in the application.
- en: Here, I am going to use a product details page of an e-commerce web application
    as an example. In a typical e-commerce web app, you have a page that shows the
    details of a product. You will see other information, such as the shopping cart
    and product reviews, on the same page as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Here, I am going to use a product details page of an e-commerce web application
    as an example. In a typical e-commerce web app, you have a page that shows the
    details of a product. You will see other information, such as the shopping cart
    and product reviews, on the same page as well.
- en: 'If I use one state object for all the information on the page, it may look
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'If I use one state object for all the information on the page, it may look
    like this:'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we use the same state object, `$state`, across three
    components: `ShoppingCart`, `ProductDetails`, and `ProductRatings`. When any part
    of the `$state` state object changes, such as changing `$state.cart`, all three
    components will be triggered to update.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'In the preceding code, we use the same state object, `$state`, across three
    components: `ShoppingCart`, `ProductDetails`, and `ProductRatings`. When any part
    of the `$state` state object changes, such as changing `$state.cart`, all three
    components will be triggered to update.'
- en: This is undesirable—multiple components updating unnecessarily could lead to
    slower performance and a less responsive user interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: This is undesirable—multiple components updating unnecessarily could lead to
    slower performance and a less responsive user interface.
- en: 'So, it is recommended to split big state objects into smaller state objects.
    Using the same example, that would mean splitting the `$state` state object into
    three smaller state objects, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'So, it is recommended to split big state objects into smaller state objects.
    Using the same example, that would mean splitting the `$state` state object into
    three smaller state objects, like so:'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: import { writable } from 'svelte/store';
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: import { writable } from 'svelte/store';
- en: const userInfo = writable({
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: const userInfo = writable({
- en: 'personalDetails: {...},'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'personalDetails: {...},'
- en: 'socials: {...},'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'socials: {...},'
- en: '});'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: import { writable } from 'svelte/store';
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: import { writable } from 'svelte/store';
- en: const userPersonalDetails = writable({...});
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: const userPersonalDetails = writable({...});
- en: const userSocials = writable({...});
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: const userSocials = writable({...});
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: // previously
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: // previously
- en: $userInfo = newUserInfo;
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: $userInfo = newUserInfo;
- en: // now
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: // now
- en: $userPersonalDetails = newUserInfo.personalDetails;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: $userPersonalDetails = newUserInfo.personalDetails;
- en: $userSocials = newUserInfo.socials;
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: $userSocials = newUserInfo.socials;
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: import { derived } from 'svelte/store';
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: import { derived } from 'svelte/store';
- en: const userSocials = derived(userInfo, $userInfo => $userInfo.socials);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: const userSocials = derived(userInfo, $userInfo => $userInfo.socials);
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: import { proxy } from 'valtio/vanilla';
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: import { proxy } from 'valtio/vanilla';
- en: 'const state = proxy({ count: 0, text: ''hello'' });'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'const state = proxy({ count: 0, text: ''hello'' });'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: setInterval(() => {
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: setInterval(() => {
- en: state.count++;
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: state.count++;
- en: '}, 1000);'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '}, 1000);'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: import { subscribe } from 'valtio';
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: import { subscribe } from 'valtio';
- en: const unsubscribe = subscribe(state, () => {
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: const unsubscribe = subscribe(state, () => {
- en: console.log('state object changed');
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('state object changed');
- en: '});'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: const unsubscribe = subscribe(state.count, () => {
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: const unsubscribe = subscribe(state.count, () => {
- en: console.log('state count changed');
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('state count changed');
- en: '});'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: import { subscribe, snapshot } from 'valtio';
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: import { subscribe, snapshot } from 'valtio';
- en: const unsubscribe = subscribe(state, () => {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: const unsubscribe = subscribe(state, () => {
- en: const obj = snapshot(state);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: const obj = snapshot(state);
- en: '});'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '// filename: data.js'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '// filename: data.js'
- en: import { proxy } from 'valtio';
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: import { proxy } from 'valtio';
- en: 'export const state = proxy({ count1: 0, count2: 0 });'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'export const state = proxy({ count1: 0, count2: 0 });'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: export function increment1() {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: export function increment1() {
- en: state.count1 ++;
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: state.count1++;
- en: '}'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: export function increment2() {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: export function increment2() {
- en: state.count2 ++;
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: state.count2++;
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <script>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: import { state, increment1, increment2 } from './data.js';
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: import { state, increment1, increment2 } from './data.js';
- en: </script>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: 'Count #1: {state.count1}'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Count #1: {state.count1}'
- en: 'Count #2: {state.count2}'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'Count #2: {state.count2}'
- en: <button on:click={increment1}>Increment 1</button>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <button on:click={increment1}>Increment 1</button>
- en: <button on:click={increment2}>Increment 2</button>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <button on:click={increment2}>Increment 2</button>
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: import { subscribe } from 'valtio';
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: import { subscribe } from 'valtio';
- en: subscribe(state, () => {
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: subscribe(state, () => {
- en: console.log(state);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(state);
- en: '});'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: function valtioStateToSvelteStore(proxyState) {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: function valtioStateToSvelteStore(proxyState) {
- en: return {};
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: return {};
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: function valtioStateToSvelteStore(proxyState) {
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: function valtioStateToSvelteStore(proxyState) {
- en: return {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: return {
- en: subscribe(fn) {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: subscribe(fn) {
- en: '},'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: function valtioStateToSvelteStore(proxyState) {
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: function valtioStateToSvelteStore(proxyState) {
- en: return {
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: return {
- en: subscribe(fn) {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: subscribe(fn) {
- en: fn(snapshot(proxyState));
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: fn(snapshot(proxyState));
- en: '},'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: function valtioStateToSvelteStore(proxyState) {
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: function valtioStateToSvelteStore(proxyState) {
- en: return {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: return {
- en: subscribe(fn) {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: subscribe(fn) {
- en: fn(snapshot(proxyState));
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: fn(snapshot(proxyState));
- en: return subscribe(proxyState, () => {
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: return subscribe(proxyState, () => {
- en: fn(snapshot(proxyState));
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: fn(snapshot(proxyState));
- en: '});'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '},'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <script>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
- en: const store = valtioStateToSvelteStore(state);
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: const store = valtioStateToSvelteStore(state);
- en: </script>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: 'Count #1: {$store.count1}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '计数 #1: {$store.count1}'
- en: 'Count #2: {$store.count2}'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '计数 #2: {$store.count2}'
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <script>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: // ...
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '$: console.log(''count1: '', $store.count1);'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '$: console.log(''count1: '', $store.count1);'
- en: '$: console.log(''count2: '', $store.count2);'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '$: console.log(''count2: '', $store.count2);'
- en: </script>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <script>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
- en: const count1 = valtioStateToSvelteStore(state.count1);
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: const count1 = valtioStateToSvelteStore(state.count1);
- en: const count2 = valtioStateToSvelteStore(state.count2);
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: const count2 = valtioStateToSvelteStore(state.count2);
- en: '$: console.log(''count1: '', $count1);'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '$: console.log(''count1: '', $count1);'
- en: '$: console.log(''count2: '', $count2);'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '$: console.log(''count2: '', $count2);'
- en: </script>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: export const state = proxy({
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: export const state = proxy({
- en: 'count1: { value: 0 },'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'count1: { value: 0 },'
- en: 'count2: { value: 0 },'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'count2: { value: 0 },'
- en: '});'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: export function increment1() {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: export function increment1() {
- en: state.count1.value ++;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: state.count1.value ++;
- en: '}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '$: console.log(''count1: '', count1. Conversely, when you click on the other
    button, labeled count2. The reactive statement will only run when the respective
    counter is incremented. That’s because our count1 and count2 stores only update
    when a specific part of the Valtio proxy state changes.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '$: console.log(''count1: '', count1. 相反，当你点击另一个按钮，标记为 count2。只有当相应的计数器增加时，响应式语句才会运行。这是因为我们的
    count1 和 count2 存储只在 Valtio 代理状态的一个特定部分发生变化时更新。'
- en: So, let’s conclude what we’ve done so far.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们总结一下到目前为止我们所做的工作。
- en: We explored the integration of Valtio in Svelte by converting the Valtio proxy
    state into a Svelte store. Step by step, we implemented the Svelte store contract
    by leveraging Valtio’s built-in methods for subscribing and unsubscribing. Toward
    the end, we explored how to subscribe to partial updates of the proxy state, minimizing
    unnecessary reactivity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 Valtio 代理状态转换为 Svelte 存储，探索了 Valtio 在 Svelte 中的集成。一步一步地，我们通过利用 Valtio
    内置的订阅和取消订阅方法，实现了 Svelte 存储合约。在最后，我们探讨了如何订阅代理状态的局部更新，以最小化不必要的响应性。
- en: I believe you are eager to try it out yourself by now, so let’s use the next
    state management library as an exercise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在一定迫不及待想要亲自尝试一下，那么我们就用下一个状态管理库来做练习。
- en: Exercise – transforming an XState state machine into a Svelte store
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 – 将 XState 状态机转换为 Svelte 存储
- en: XState ([https://xstate.js.org/](https://xstate.js.org/)) is a JavaScript library
    for managing states using state machines. In this exercise, you are going to transform
    an XState state machine into a Svelte store.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: XState ([https://xstate.js.org/](https://xstate.js.org/)) 是一个用于使用状态机管理状态的 JavaScript
    库。在这个练习中，你将把一个 XState 状态机转换成一个 Svelte 存储。
- en: XState provides a package named `@xstate/svelte` that includes utilities specifically
    designed for integrating XState in Svelte. Although this package can be a source
    of inspiration for your task, the use of `@xstate/svelte` is, however, not permitted
    for this exercise. The goal here is to challenge you to implement the function
    to transform an XState state machine into a Svelte store without the aid of pre-existing
    integration utilities.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: XState 提供了一个名为 `@xstate/svelte` 的包，其中包含专门为在 Svelte 中集成 XState 设计的实用工具。尽管这个包可以为你的任务提供灵感，但在这个练习中，使用
    `@xstate/svelte` 是不允许的。这里的目的是挑战你实现一个将 XState 状态机转换为 Svelte 存储的功能，而不使用现有的集成实用工具。
- en: 'To get started with this exercise, follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个练习，请按照以下步骤操作：
- en: '**Understand XState**: If you’re not already familiar with XState, spend some
    time reading its documentation and experimenting with its features. Understand
    how state machines work and how XState implements them.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解 XState**：如果你还不熟悉 XState，花些时间阅读其文档并尝试其功能。了解状态机的工作原理以及 XState 如何实现它们。'
- en: '**Create a state machine**: Using XState, create a state machine that you’d
    like to convert into a Svelte store. This could be a simple machine with a few
    states and transitions, or something more complex if you’re comfortable with it.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建状态机**：使用 XState 创建一个你想要转换为 Svelte 存储的状态机。这可能是一个具有几个状态和转换的简单机，或者如果你感到舒适，也可以是更复杂的机。'
- en: '**Transform the state machine into a Svelte store**: Now comes the key part
    of the exercise. You’ll need to write a function that converts your XState state
    machine into a Svelte store. This involves subscribing to state changes in the
    machine and forwarding them to the Svelte store, as well as mapping actions from
    the store back to transitions in the state machine.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将状态机转换为 Svelte 存储**：现在到了练习的关键部分。你需要编写一个函数，将你的 XState 状态机转换为 Svelte 存储。这涉及到订阅机器中的状态变化并将它们转发到
    Svelte 存储，以及将存储中的操作映射回状态机的转换。'
- en: '**Test your implementation**: After you’ve completed your conversion, ensure
    you thoroughly test it. Change states in your store and observe whether the same
    changes are reflected in your state machine and vice versa.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试你的实现**：在你完成转换后，确保你彻底测试它。更改存储中的状态，并观察是否在状态机中反映了相同的更改，反之亦然。'
- en: If you’re stuck, take a step back and refer to the documentation of XState and
    this chapter, or the source code of `@xstate/svelte`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了困难，退一步参考 XState 和本章的文档，或者 `@xstate/svelte` 的源代码。
- en: Summary
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how we can manage our application states with
    Svelte.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Svelte 管理我们的应用程序状态。
- en: At the beginning of the chapter, we discussed some of the tips for managing
    states in Svelte through a Svelte store. These tips will be useful to you as your
    Svelte application grows larger and more complex.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了一些通过 Svelte 存储管理 Svelte 中状态的技巧。随着你的 Svelte 应用程序变得更大、更复杂，这些技巧将对你非常有用。
- en: One of the tips that we discussed is using state management libraries to manage
    data changes and data flows. That’s why we spent the second half of the chapter
    exploring how we can use state management libraries in Svelte, by transforming
    the state management libraries’ state into Svelte stores.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的其中一个技巧是使用状态管理库来管理数据变化和数据流。这就是为什么我们在本章的后半部分探讨了如何在 Svelte 中使用状态管理库，通过将状态管理库的状态转换为
    Svelte 存储。
- en: In the next chapter, we are going to explore how we can use a combination of
    both a Svelte context and a Svelte store to create renderless components—logical
    components that do not render any content.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何结合使用 Svelte 上下文和 Svelte 存储来创建无渲染组件——不渲染任何内容的逻辑组件。
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
