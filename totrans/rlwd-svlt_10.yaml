- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State Management with Svelte Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every user interface control has a state. A checkbox has a checked-unchecked
    state. A textbox’s state is its current input value. A table’s state is the data
    displayed and the columns currently being sorted. Sometimes when you have multiple
    user interface controls present across the screen at the same time, you need to
    synchronize the state across them—this is where state management comes in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to discuss managing states in Svelte using Svelte
    stores. We will start with why we should use Svelte stores, and then discuss tips
    that will help you when using Svelte stores for state management.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go into the topic of using state management libraries. We will
    talk about why and how to use them. With that, we will be going through a few
    examples of integrating third-party state management libraries into Svelte through
    Svelte stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes sections on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing states with Svelte stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using state management libraries with Svelte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing states with Svelte stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building an interactive user interface, the first thing we consider is
    determining the necessary states to represent the various components and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following snippet, I have a login form that has a few components,
    including two inputs, one checkbox, and one button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the Svelte components has multiple states, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<Input />` component has an input value state and an error state set during
    validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<Checkbox />` component has a checked/unchecked state, checked to reveal
    the password in the input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password `<Input />` component has an additional state to reveal/hide the
    password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<Button />` component has an enabled/disabled state, disabled when the
    form is incomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these states can be represented by a variable. The variables themselves
    can be interrelated.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine how these variables can be related to each other. For example,
    when the checkbox is checked, the password input needs to reveal the password.
    When the name and password inputs are filled, the button needs to turn into an
    enabled state. When the button is pressed, validation is performed, and the inputs’
    error state is updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The art of managing multiple states across components to form a cohesive experience
    is called state management.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be clearer and easier to group all these states together and manage
    them as one, rather than separate individual states. In the following snippet,
    I group all of the aforementioned variables into one variable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the related states in one place, making it easier to see and
    tell if something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let’s say the `nameValue` and `submitDisabled` variables
    are kept as two separate variables in two separate components; in the `Input`
    component, we have the `nameValue` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `Button` component, we have the `submitDisabled` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the code, you can see that it is not straightforward to tell whether the
    `nameValue` and `submitDisabled` variables are related. If one of the states is
    not updated as expected, you don’t have one convenient place to inspect both states
    at once; you will have to inspect them in each separate component.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the `submitDisabled` state in the `<Button />` component did
    not change to `false` to enable the button after typing in the name input, you
    would need to find and inspect the `nameValue` variable in a separate component
    (the `<Input />` component).
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead, the states are grouped into a `state` object, then you can inspect
    the `state` object and check the `nameValue` and the `submitDisabled` properties
    and see if they are set correctly. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve established that we should group multiple related states into
    one state object, the next question is this: If we could group states using a
    simple JavaScript object, why would it be necessary to group states using a Svelte
    store?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, the truth is, it is not always necessary. In some cases, using a simple
    JavaScript object to group states can work just as effectively. However, a Svelte
    store offers additional benefits and functionality that can enhance your state
    management experience.
  prefs: []
  type: TYPE_NORMAL
- en: As we explored in [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), a Svelte
    store is useful as it can be passed around components and have its updates propagate
    across components. Then, in [*Chapter 9*](B18887_09.xhtml#_idTextAnchor135), we
    saw how useful a Svelte store is, being able to encapsulate logic within the Svelte
    store, as well as being able to define data logic right next to the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the sake of the chapter, we are going to proceed with grouping multiple
    related states into a state object using a Svelte store. Here’s a short snippet
    of code of how it would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a `writable()` store for creating the state object because we will
    be modifying the state object.
  prefs: []
  type: TYPE_NORMAL
- en: The state object can be defined either inside or outside a Svelte component.
    Since our state object is a Svelte store, we can import the state object into
    any component, and any updates to the state object will be propagated across all
    Svelte components that use the state object—so, it doesn’t matter in which file
    we define the state object in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we define our state object in a Svelte component, then we can pass our state
    object to the component’s child component through props. Here’s an example of
    doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we define our state object in a JavaScript module, then
    we can import our state object into any Svelte components that will be using the
    state object. The following is a snippet of importing a Svelte store state object
    into a Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), we learned how to read,
    subscribe to, and update a Svelte store. Whether the data stored inside a Svelte
    store is a state object or anything else, there is no difference in terms of the
    operations to read, subscribe, and update the Svelte store state object like any
    other Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: But as the state is used more frequently in a growing project, you will have
    more state values inside a `state` store object. As the `state` store gets larger
    and more complex, your application may get slower, and you may feel the need to
    optimize/improve it. Therefore, I am dedicating the following subsections to sharing
    my tips and opinions on state management with a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you shouldn’t apply all these methods blindly. As said by Donald
    Knuth, the famous computer scientist, “*Premature optimization is the root of
    all evil*”—you should measure and evaluate whether any of the following tips apply.
    As I go through the tips, I will explain what they are and why and when are they
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Tip 1 – simplify complex state updates with unidirectional data flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your application becomes more complex, with multiple components and multiple
    places to update your state, managing state updates becomes even more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would you know when managing state updates becomes unmanageable? You may
    run into situations such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application state changes, and you find it hard to track down why the state
    changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You change a certain state value, but unknowingly, this causes other seemingly
    unrelated state values to update as well, and you have a hard time working out
    why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are signs that the state updates have grown complex and become difficult
    to manage. In such situations, having unidirectional data flow can help simplify
    state management.
  prefs: []
  type: TYPE_NORMAL
- en: With unidirectional data flow, state updates are managed in a single direction,
    and the flow of data can be easily traced and debugged.
  prefs: []
  type: TYPE_NORMAL
- en: There are state management libraries such as Redux, MobX, and XState that help
    to enforce a single data flow and enable you to reason with the state changes.
    You may be curious about how to use these state management libraries with a Svelte
    store; I will be covering them later in this chapter and will use one of the libraries
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip 2 – prefer smaller self-contained state objects over one big state object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Svelte, when a state object changes, all components that use that state object
    are updated, even if the specific state value that a component uses did not change.
    This means that if a state object becomes larger and more complex, with many unrelated
    state values, updating that state object can trigger unnecessary updates to many
    components in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I am going to use a product details page of an e-commerce web application
    as an example. In a typical e-commerce web app, you have a page that shows the
    details of a product. You will see other information, such as the shopping cart
    and product reviews, on the same page as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I use one state object for all the information on the page, it may look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the same state object, `$state`, across three
    components: `ShoppingCart`, `ProductDetails`, and `ProductRatings`. When any part
    of the `$state` state object changes, such as changing `$state.cart`, all three
    components will be triggered to update.'
  prefs: []
  type: TYPE_NORMAL
- en: This is undesirable—multiple components updating unnecessarily could lead to
    slower performance and a less responsive user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it is recommended to split big state objects into smaller state objects.
    Using the same example, that would mean splitting the `$state` state object into
    three smaller state objects, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: import { writable } from 'svelte/store';
  prefs: []
  type: TYPE_NORMAL
- en: const userInfo = writable({
  prefs: []
  type: TYPE_NORMAL
- en: 'personalDetails: {...},'
  prefs: []
  type: TYPE_NORMAL
- en: 'socials: {...},'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: import { writable } from 'svelte/store';
  prefs: []
  type: TYPE_NORMAL
- en: const userPersonalDetails = writable({...});
  prefs: []
  type: TYPE_NORMAL
- en: const userSocials = writable({...});
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: // previously
  prefs: []
  type: TYPE_NORMAL
- en: $userInfo = newUserInfo;
  prefs: []
  type: TYPE_NORMAL
- en: // now
  prefs: []
  type: TYPE_NORMAL
- en: $userPersonalDetails = newUserInfo.personalDetails;
  prefs: []
  type: TYPE_NORMAL
- en: $userSocials = newUserInfo.socials;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: import { derived } from 'svelte/store';
  prefs: []
  type: TYPE_NORMAL
- en: const userSocials = derived(userInfo, $userInfo => $userInfo.socials);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: import { proxy } from 'valtio/vanilla';
  prefs: []
  type: TYPE_NORMAL
- en: 'const state = proxy({ count: 0, text: ''hello'' });'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: setInterval(() => {
  prefs: []
  type: TYPE_NORMAL
- en: state.count++;
  prefs: []
  type: TYPE_NORMAL
- en: '}, 1000);'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: import { subscribe } from 'valtio';
  prefs: []
  type: TYPE_NORMAL
- en: const unsubscribe = subscribe(state, () => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log('state object changed');
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: const unsubscribe = subscribe(state.count, () => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log('state count changed');
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: import { subscribe, snapshot } from 'valtio';
  prefs: []
  type: TYPE_NORMAL
- en: const unsubscribe = subscribe(state, () => {
  prefs: []
  type: TYPE_NORMAL
- en: const obj = snapshot(state);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '// filename: data.js'
  prefs: []
  type: TYPE_NORMAL
- en: import { proxy } from 'valtio';
  prefs: []
  type: TYPE_NORMAL
- en: 'export const state = proxy({ count1: 0, count2: 0 });'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: export function increment1() {
  prefs: []
  type: TYPE_NORMAL
- en: state.count1 ++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: export function increment2() {
  prefs: []
  type: TYPE_NORMAL
- en: state.count2 ++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import { state, increment1, increment2 } from './data.js';
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: 'Count #1: {state.count1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count #2: {state.count2}'
  prefs: []
  type: TYPE_NORMAL
- en: <button on:click={increment1}>Increment 1</button>
  prefs: []
  type: TYPE_NORMAL
- en: <button on:click={increment2}>Increment 2</button>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: import { subscribe } from 'valtio';
  prefs: []
  type: TYPE_NORMAL
- en: subscribe(state, () => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(state);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: function valtioStateToSvelteStore(proxyState) {
  prefs: []
  type: TYPE_NORMAL
- en: return {};
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: function valtioStateToSvelteStore(proxyState) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: subscribe(fn) {
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: function valtioStateToSvelteStore(proxyState) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: subscribe(fn) {
  prefs: []
  type: TYPE_NORMAL
- en: fn(snapshot(proxyState));
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: function valtioStateToSvelteStore(proxyState) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: subscribe(fn) {
  prefs: []
  type: TYPE_NORMAL
- en: fn(snapshot(proxyState));
  prefs: []
  type: TYPE_NORMAL
- en: return subscribe(proxyState, () => {
  prefs: []
  type: TYPE_NORMAL
- en: fn(snapshot(proxyState));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  prefs: []
  type: TYPE_NORMAL
- en: const store = valtioStateToSvelteStore(state);
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: 'Count #1: {$store.count1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count #2: {$store.count2}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '$: console.log(''count1: '', $store.count1);'
  prefs: []
  type: TYPE_NORMAL
- en: '$: console.log(''count2: '', $store.count2);'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  prefs: []
  type: TYPE_NORMAL
- en: const count1 = valtioStateToSvelteStore(state.count1);
  prefs: []
  type: TYPE_NORMAL
- en: const count2 = valtioStateToSvelteStore(state.count2);
  prefs: []
  type: TYPE_NORMAL
- en: '$: console.log(''count1: '', $count1);'
  prefs: []
  type: TYPE_NORMAL
- en: '$: console.log(''count2: '', $count2);'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: export const state = proxy({
  prefs: []
  type: TYPE_NORMAL
- en: 'count1: { value: 0 },'
  prefs: []
  type: TYPE_NORMAL
- en: 'count2: { value: 0 },'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: export function increment1() {
  prefs: []
  type: TYPE_NORMAL
- en: state.count1.value ++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '$: console.log(''count1: '', count1. Conversely, when you click on the other
    button, labeled count2. The reactive statement will only run when the respective
    counter is incremented. That’s because our count1 and count2 stores only update
    when a specific part of the Valtio proxy state changes.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s conclude what we’ve done so far.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the integration of Valtio in Svelte by converting the Valtio proxy
    state into a Svelte store. Step by step, we implemented the Svelte store contract
    by leveraging Valtio’s built-in methods for subscribing and unsubscribing. Toward
    the end, we explored how to subscribe to partial updates of the proxy state, minimizing
    unnecessary reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: I believe you are eager to try it out yourself by now, so let’s use the next
    state management library as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – transforming an XState state machine into a Svelte store
  prefs: []
  type: TYPE_NORMAL
- en: XState ([https://xstate.js.org/](https://xstate.js.org/)) is a JavaScript library
    for managing states using state machines. In this exercise, you are going to transform
    an XState state machine into a Svelte store.
  prefs: []
  type: TYPE_NORMAL
- en: XState provides a package named `@xstate/svelte` that includes utilities specifically
    designed for integrating XState in Svelte. Although this package can be a source
    of inspiration for your task, the use of `@xstate/svelte` is, however, not permitted
    for this exercise. The goal here is to challenge you to implement the function
    to transform an XState state machine into a Svelte store without the aid of pre-existing
    integration utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with this exercise, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand XState**: If you’re not already familiar with XState, spend some
    time reading its documentation and experimenting with its features. Understand
    how state machines work and how XState implements them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a state machine**: Using XState, create a state machine that you’d
    like to convert into a Svelte store. This could be a simple machine with a few
    states and transitions, or something more complex if you’re comfortable with it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transform the state machine into a Svelte store**: Now comes the key part
    of the exercise. You’ll need to write a function that converts your XState state
    machine into a Svelte store. This involves subscribing to state changes in the
    machine and forwarding them to the Svelte store, as well as mapping actions from
    the store back to transitions in the state machine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test your implementation**: After you’ve completed your conversion, ensure
    you thoroughly test it. Change states in your store and observe whether the same
    changes are reflected in your state machine and vice versa.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re stuck, take a step back and refer to the documentation of XState and
    this chapter, or the source code of `@xstate/svelte`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about how we can manage our application states with
    Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we discussed some of the tips for managing
    states in Svelte through a Svelte store. These tips will be useful to you as your
    Svelte application grows larger and more complex.
  prefs: []
  type: TYPE_NORMAL
- en: One of the tips that we discussed is using state management libraries to manage
    data changes and data flows. That’s why we spent the second half of the chapter
    exploring how we can use state management libraries in Svelte, by transforming
    the state management libraries’ state into Svelte stores.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore how we can use a combination of
    both a Svelte context and a Svelte store to create renderless components—logical
    components that do not render any content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
