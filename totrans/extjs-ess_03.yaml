- en: Chapter 3. Reacting to User and Application Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing effective applications with Ext JS requires a solid understanding
    of event-driven programming and how actions are performed, based on user and application
    interactions. Ext JS is an event-driven framework and uses events to control the
    flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events can be raised by user input, internally by the framework or by our own
    application code. For example, when a user clicks a button with their mouse, a
    click event will be fired by the button''s instance. We can then attach a listener
    to this event and execute our handler code when it is fired. Have a look at the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reacting to User and Application Interactions](img/6626_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter will explore in detail the events in Ext JS. The topics covered
    in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching event handlers to components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for user input via mouse, keyboard, and touch screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications built with Ext JS will make use of events at numerous points throughout
    their lifecycle. Even if you're unaware of it, in the background, the framework
    will raise events when something interesting happens. As developers, we want our
    application code to respond to these events, either to process something or to
    give the user feedback on what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS implements an `Ext.mixin.Observable` class that provides a common interface
    for publishing events. Let's look at the options we have to listen to events.
  prefs: []
  type: TYPE_NORMAL
- en: Defining event handlers in config objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common way to define listeners is to use the `listeners` config option, which
    allows us to define an object containing event handlers. This object should be
    defined in the `config` object of the Ext JS component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump straight into the `BizDash.view.main.Main` class that was created
    automatically when we generated our application in [Chapter 1](ch01.html "Chapter 1. Getting
    to Know Ext JS"), *Getting to Know Ext JS*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will bind an event listener to the `afterrender` event of the Tab Panel
    component. The function is executed when the event is fired. In this case, the
    output of the handler is a simple console message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to attach handlers to multiple events at once. This example
    has both, a `beforerender` and `afterrender` handler for events fired by the Tab
    Panel component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Button handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The framework provides a shortcut to define a handler to a button as it''s
    highly likely you''ll want your buttons to respond to a mouse click. The `handler`
    in this case is bound to the `onClickButton` method in the view''s ViewController,
    `BizDash.view.main.MainController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's considered good practice to keep your business logic out of views instead
    of putting it in global controllers or ViewControllers.
  prefs: []
  type: TYPE_NORMAL
- en: The on method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the `on` method, which is an alias of the `addListener`
    method. This method comes from the mixed in `Ext.mixin.Observable` class and enables
    us to add listeners to a class, or component after the class is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how to use an Ext JS Component Query to search for
    the button in our application and add a `mouseover` listener bound to the method
    `onMouseOver` in our ViewController. We will go into Component Queries in more
    detail in [Chapter 7](ch07.html "Chapter 7. Constructing Common UI Widgets"),
    *Constructing Common UI Widgets*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the listeners `config` object, the `on` method also accepts an alternative
    parameter set that allows multiple event handlers to be assigned at once. By providing
    a JavaScript object as the first parameter, with name/value pairs specifying the
    event name and its handling function, the listeners will all be assigned at once.
    By defining a `scope` property within this object, the handler functions will
    all be executed within the scope of the specified object (or what `this` will
    refer to within the function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Scope** defaults to the object that fires the event. In our case, that would
    be the button. You can customize this with the `scope` option if you require the
    handler function to be executed in a different scope. The preceding example demonstrates
    this using the `this` reference to alter the scope to that of the `BizDash.view.main.MainController`.'
  prefs: []
  type: TYPE_NORMAL
- en: Listener options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous listener options for you to configure as well. For example,
    you can buffer an event that fires in quick succession or target an event to a
    specific element rather than the entire component. Event delegation like this
    is useful during component construction to add DOM event listeners to elements
    of components, which will exist only after the component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the `single` option added to the click event. This option
    automatically removes the click event after the first time it's fired. We've further
    enhanced the `onClickButton` method to disable the button too.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for `Ext.mixin.Observable` contains useful examples and further
    information on configuring events. You can find it at [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable).
  prefs: []
  type: TYPE_NORMAL
- en: Firing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Ext.mixin.Observable` class also provides a way to fire events, whether
    these are framework events or custom events. The `fireEvent` method will fire
    any event we require and pass parameters for consumption by the handler function.
    The following example shows us how to fire a custom `confirmed` event, passing
    the `choice` parameter on the button, and binding it to an `onConfirmed` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Listening for events on elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As some events, for example click, aren't available on all components, it's
    possible to attach event handlers directly to any element. The `Ext.dom.Element`
    class, a framework class that wraps DOM elements, will relay all of the underlying
    DOM events, and its documentation contains a full list of these.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how to listen for a tap event on the entire `Viewport`.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event handlers, however, are a common cause of memory leaks and can cause performance
    degradation when not managed carefully. The more event handlers we create, the
    more likely we are to introduce such problems; so, we should try to avoid creating
    huge numbers of handlers when we don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegation is a technique where a single event handler is created on a
    parent element, which leverages the fact that the browser will bubble any events
    raised on one of its children to this parent element. If the target of the original
    event matches the delegate's selector, then it will execute the event handler;
    otherwise nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: This means that instead of attaching an event handler to each individual child
    element, we only have to create a single handler on the parent element, and then,
    within the handler, query which child element was actually clicked and react appropriately.
    To achieve this, we use the delegate option available to the `listeners` config.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you might use event delegation with an element
    containing multiple links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mouse events the framework can handle are `mousedown`, `mousemove`, `mouseup`,
    `mouseover`, `mouseout`, `mouseenter`, and `mouseleave`. The `Ext.event.Event`
    class handles the cross-browser and cross-device differences for us to ensure
    our application behaves the same on all supported browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Ext.event.Event` class also provides a list of key constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can, for instance, get a reference to the enter key's code using `Ext.event.Event.ENTER`.
  prefs: []
  type: TYPE_NORMAL
- en: KeyMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Ext.util.KeyMap` class is used to bind keyboard strokes to a handling
    function. Using this, you can enable the user to control the application using
    their keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only do we often have to support multiple browsers, but most of the time
    we need our applications to be device agnostic. Ext JS enables us to support users
    with other types of pointers, such as a mouse, pen, or finger.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 5 provides support for `touchstart`, `touchmove`, and `touchend` events.
  prefs: []
  type: TYPE_NORMAL
- en: Event normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To support touch-screen devices, the framework automatically translates touch-screen
    events into their equivalent mouse events for us. This is called event normalization.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we don't need to worry about the extra coding. All we have to
    do is consider the event being used by a mouse. For instance, `mousedown` will
    seamlessly be translated to `touchdown` and `pointerdown` for us.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While normalization saves us coding, we still need to understand the gesture
    the user carries out on our application. Ext JS does almost all the heavy lifting
    for us. It will interpret gestures such as tap, swipe, drag, and double tap on
    any element and raise events for us to listen for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, the framework builds upon the Sencha Touch gesture system,
    which interprets the sequence and timing of three primary events: `touchstart`,
    `touchmove`, and `touchend`. Ext JS 5 translates these to the equivalent pointer
    and mouse events (for example, `pointerdown` or `mousedown`) so that gestures
    are understood regardless of the device being used for input.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, gestures such as tap and swipe will work for both touch and mouse
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to work with events in an Ext JS application.
    You should now feel more comfortable with:'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching event handlers to components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for user input via mouse, keyboard, and touch screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter builds on your knowledge of classes and events to cover the
    entire application and its architecture. Ext JS 5 now provides support for MVVM
    as well as MVC. While the chapter's focus is these paradigms, we also explore
    other considerations it's worth making early in the development cycle.
  prefs: []
  type: TYPE_NORMAL
