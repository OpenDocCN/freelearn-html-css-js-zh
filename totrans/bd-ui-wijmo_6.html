<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Dashboard with WijmoGrid"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Dashboard with WijmoGrid</h1></div></div></div><p>Developing rich client applications with jQuery UI results in a large number of CSS query selectors and event handlers. In this chapter, you will learn about another way of developing interactive user interfaces. Wijmo facilitates the shift to this programming paradigm, supporting it with a plugin. This chapter will get you started with the concepts.</p><div class="section" title="Introduction to MVVM"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Introduction to MVVM</h1></div></div></div><p>Modern web applications are often built with the MVC pattern, for the backend. What about the frontend? Frameworks such as <code class="literal">Backbone.js</code> leave a lot of boilerplate code to be written. This becomes apparent for large projects. The library is lightweight, but lacks strong abstractions. It leaves the task of loading data from the server and DOM manipulation to the developer.</p><p>With the <span class="strong"><strong>ModelViewViewModel</strong></span> (<span class="strong"><strong>MVVM</strong></span>) pattern, the<a id="id228" class="indexterm"/> application logic is encapsulated in a set of ViewModel classes that expose an object model that is View-friendly. Views rely on bindings to observables to be notified of changes in the ViewModel. As a result, the UI refreshes automatically with the data when using the MVVM pattern. The flow of data in the MVVM pattern is illustrated in this diagram:</p><div class="mediaobject"><img src="graphics/6067OT_6_01.jpg" alt="Introduction to MVVM"/></div><p>From a software design point of view, the MVVM pattern has the benefit of testability, separation of concerns, and reusability. The ViewModel doesn't contain any user interface<a id="id229" class="indexterm"/> elements, making it easy to test. The presentation is kept in the <span class="strong"><strong>View</strong></span>
<a id="id230" class="indexterm"/> with HTML and CSS, which requires different skills than those for working with the business logic in the <span class="strong"><strong>ViewModel</strong></span>
<a id="id231" class="indexterm"/>. The ViewModel can be reused in other views, such as a mobile one or in a similar application with a different look. In my own experience, I have used subclasses of a common ViewModel <a id="id232" class="indexterm"/>to build two applications. Both of the applications use the same backend <span class="strong"><strong>Model</strong></span>.</p><p>When the MVVM pattern is used in the browser, the Model represents the backend. It is an abstraction of the normalized data store for objects and the operations (create, read, update, delete) on it. The View is the user interface that displays information to the user and fires events to the ViewModel. The ViewModel retrieves data from the Model and notifies the View of changes. Also, it receives UI events from the View and updates the data in the Model in response.</p></div></div>
<div class="section" title="Introduction to Knockout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Introduction to Knockout</h1></div></div></div><p>
<span class="strong"><strong>Knockout</strong></span> is<a id="id233" class="indexterm"/> a JavaScript library that implements the MVVM pattern. By using Knockout, you can avoid event handling and DOM manipulation with jQuery and work with declarative bindings instead. Knockout comes with a rich set of bindings for controlling the text, appearance, and flow. These include <code class="literal">foreach</code>, <code class="literal">if</code>, <code class="literal">visiblility</code>, and <code class="literal">style</code> bindings. In addition, there are specific bindings for working with form fields. They can be used to handle click events and to enable or disable UI elements. These bindings are bound to an observable or an <code class="literal">observableArray</code> object in the <a id="id234" class="indexterm"/>ViewModel. An observable issues notifications when their value changes. Knockout provides a simple syntax for reading and writing from an observable, as we will see. Equally important, Knockout keeps track of the right parts of your UI to update when the ViewModel changes. That means if you update an item of an <code class="literal">observableArray</code> object<a id="id235" class="indexterm"/> that is rendered with a <code class="literal">foreach</code> loop, the HTML element that corresponds to the item changes with it. If an observable is computed from another observable, then the dependency is tracked for you.</p><p>Let's take a look at instantiating and using an observable. To create an observable, we assign it to a property of a ViewModel.</p><div class="informalexample"><pre class="programlisting">varviewModel = {
  name: ko.observable('Bob')
};</pre></div><p>To read <a id="id236" class="indexterm"/>from the observable, just call the observable with no parameters. If we call <code class="literal">viewModel.name()</code>, "Bob" is returned. To write to the observable, pass the new value as the parameter to the observable. Calling <code class="literal">viewModel.name('Jeff')</code> writes the value <code class="literal">Jeff</code> to the value <code class="literal">name</code>.</p><p>Next, we <a id="id237" class="indexterm"/>write the View with a templating language using the <code class="literal">data-bind</code> attribute:</p><div class="informalexample"><pre class="programlisting">My name is &lt;span data-bind="text: name"&gt;&lt;/span&gt;</pre></div><p>The View has the same effect as the following when initialized:</p><div class="informalexample"><pre class="programlisting">My name is &lt;span&gt;Bob&lt;/span&gt;</pre></div><p>Finally, to activate Knockout, we bind the ViewModel layer to the View layer with JavaScript:</p><div class="informalexample"><pre class="programlisting">ko.applyBindings(myViewModel);</pre></div><p>We can place this either at the bottom of the page or a DOM-ready function.</p><div class="section" title="Building a rating system with Knockout"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec25"/>Building a rating system with Knockout</h2></div></div></div><p>In this <a id="id238" class="indexterm"/>section we build a rating system using Wijmo's <a id="id239" class="indexterm"/>rating widget. The rating system lets the user vote for the factors that affect their technology choices. They have a total of 10 points to use. The <span class="strong"><strong>Finish</strong></span> button<a id="id240" class="indexterm"/> is only enabled if the number of points left for use is valid as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6067OT_6_02.jpg" alt="Building a rating system with Knockout"/></div><p>To build<a id="id241" class="indexterm"/> this rating system, we make use of Wijmo's<a id="id242" class="indexterm"/> Knockout binding for its rating widgets. The survey is composed of a set of options where the user rates the option. For each of the options, we create an answer object with the values for the binding:</p><div class="informalexample"><pre class="programlisting">function Answer(text) {
  this.answerText = text;
  this.points = ko.observable(1);
  this.split = ko.observable(2); // each star is split into 2 sections to allow voting by .5
}</pre></div><p>The contents of <code class="literal">answerText</code> are displayed under the <span class="strong"><strong>Option</strong></span> heading. The points are the number of stars under the <span class="strong"><strong>Importance</strong></span> heading. The rating widget has many other options, but we only introduce the ones necessary for our use. These options are bound to the widget<a id="id243" class="indexterm"/> with the <code class="literal">data-bind</code> attribute:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind="wijrating: { value: points, split: split }"&gt;&lt;/div&gt;</pre></div><p>In our ViewModel, we have an array of options called <code class="literal">answers</code> and a total number of points allowed, the <code class="literal">pointsBudget</code>. The <code class="literal">pointsUsed</code> is a dependent observable and is calculated by adding up the points in all the answers:</p><div class="informalexample"><pre class="programlisting">function SurveyViewModel(pointsBudget, answers) {
  this.pointsBudget = pointsBudget;
  this.answers = $.map(answers, function (text) {
  return new Answer(text)
});
this.save = function () {
  alert('To do')
};

this.pointsUsed = ko.computed(function () {
  var total = 0;
  for (var i = 0; i &lt;this.answers.length; i++)
    total += this.answers[i].points();
  return total;
}, this);</pre></div><p>Using the jQuery <code class="literal">$.map</code> function<a id="id244" class="indexterm"/>, we can pass an array of option texts to the <code class="literal">SurveyViewModel</code>class<a id="id245" class="indexterm"/>. The first argument sets the total number of points allowed:</p><div class="informalexample"><pre class="programlisting">newSurveyViewModel(10, [
"Functionality, compatibility, pricing - all that boring stuff",
"How often it is mentioned on Hacker News",
"Number of gradients/dropshadows on project homepage",
"Totally believable testimonials on project homepage"
])</pre></div><p>Since <a id="id246" class="indexterm"/>Knockout is an MVVM framework, we<a id="id247" class="indexterm"/> need to write the View using a templating language. To display the options and the rating widget, we loop through each answer in the ViewModel and display the <code class="literal">answerText</code> string and the points for<a id="id248" class="indexterm"/> each answer, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;tbody data-bind="foreach: answers"&gt;
&lt;tr&gt;
  &lt;td data-bind="text: answerText"&gt;&lt;/td&gt;
  &lt;td&gt;&lt;div data-bind="wijrating: { value: points, split: split }"&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;</pre></div><p>The <code class="literal">text</code> binding<a id="id249" class="indexterm"/> applied to <code class="literal">answerText</code> displays its text value, while the <code class="literal">value</code> binding for <code class="literal">wijrating</code> shows up as stars. Next, we want to show the number of points the user is left with. This is also done with the help of <code class="literal">text</code> binding, which converts a numeric value to a string:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;You've got &lt;b data-bind="text: pointsBudget - pointsUsed()"&gt;&lt;/b&gt; points left to use.&lt;/p&gt;</pre></div><p>We enable the <span class="strong"><strong>Submit</strong></span> button<a id="id250" class="indexterm"/> only when the value of <code class="literal">pointsUsed</code> doesn't exceed the value we set in the SurveyViewModel. In this case, it's <code class="literal">10</code>. The <code class="literal">click</code> binding assigns the <code class="literal">save</code> action in the SurveyViewModel to the <code class="literal">click</code> event<a id="id251" class="indexterm"/> on the button:</p><div class="informalexample"><pre class="programlisting">&lt;button data-bind="enable: pointsUsed() &lt;= pointsBudget, click: save"&gt;Finished&lt;/button&gt;</pre></div><p>To initialize the UI, we bind the ViewModel to the HTML by calling <code class="literal">ko.applyBindings</code> and passing a SurveyViewModel object. Putting it all together, the rating system is only a few lines of JavaScript and has no DOM manipulation. For the complete source code for this example, refer to the code bundle available for download online<a id="id252" class="indexterm"/> on the Packt website. Note that in addition <a id="id253" class="indexterm"/>to the usual Wijmo imports, we add the Knockout library and the Wijmo bindings, which includes <code class="literal">wijrating</code>.</p><p>Now that you know how to build a user interface with the MVVM design pattern, we go on to building a more complete application with forms and grids.</p></div></div>
<div class="section" title="Building the dashboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Building the dashboard</h1></div></div></div><p>The project for the rest of the chapter is based on a mobile-paging application. The application allows<a id="id254" class="indexterm"/> messages to be sent to pagers with a dashboard showing all of the messages. The messages in the dashboard are updated in real time and are sortable by column headings. In a real-world application, the messages shown in the dashboard would be paginated and sorting each column would send an AJAX request to the server. Wijmo already has an example of how to do this with the Grid widget, which we will also use in our project. Our project introduces the basics of setting up a real-time messaging platform with the MVVM pattern. The data is not persisted to a database. However, form submissions are sent to the dashboard in real time with WebSockets. After you finish this chapter, I would encourage you to take a look at <a class="ulink" href="http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/">http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/</a>.</p><div class="section" title="Sending a message with Knockout and Socket.IO"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Sending a message with Knockout and Socket.IO</h2></div></div></div><p>The <span class="strong"><strong>Send Message</strong></span>
<a id="id255" class="indexterm"/> page is a form that lets<a id="id256" class="indexterm"/> the user submit a message with a<a id="id257" class="indexterm"/> subject, body, phone number, and message<a id="id258" class="indexterm"/> type. We build this form using a combination of the bindings that come with Knockout and those provided by Wijmo. First, let's start with a subject and a body. Since the Wijmo's textbox widget doesn't have a binding for the input value, we use Knockout's <code class="literal">value</code> binding. This binding can be used on the <code class="literal">&lt;input&gt;</code>, <code class="literal">&lt;select&gt;</code>, and <code class="literal">&lt;textarea&gt;</code> elements and links the element's value with a property in the ViewModel:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="formdecorator"&gt;
  &lt;li&gt;
    &lt;h3&gt; Subject &lt;/h3&gt;
    &lt;input id="text1" type="text" data-bind="value: subject"/&gt;
  &lt;/li&gt;
  
  &lt;li&gt;
    &lt;h3&gt; Body &lt;/h3&gt;
    &lt;textarea id="textarea1" rows="2" cols="50" data-bind="value: body"&gt;&lt;/textarea&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p>To make <a id="id259" class="indexterm"/>these elements use the same<a id="id260" class="indexterm"/> styles as the rest of the form, we decorate them <a id="id261" class="indexterm"/>with the textbox widget. This is<a id="id262" class="indexterm"/> done for styling the elements, as the View in HTML contains the bindings:</p><div class="informalexample"><pre class="programlisting">$('#text1,#textarea1').wijtextbox();</pre></div><p>In our ViewModel, we initialize the <code class="literal">subject</code> and <code class="literal">body</code> fields as observables with empty strings:</p><div class="informalexample"><pre class="programlisting">varViewModel = function () {
  this.subject = ko.observable('');
  this.body = ko.observable('');
};</pre></div><p>After seeing how the <code class="literal">subject</code> and <code class="literal">body</code> fields are implemented, you may want to use the <code class="literal">wijtextbox</code> binding directly, as shown in the following demonstration that does not work:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="formdecorator"&gt;
  &lt;li&gt;
    &lt;h3&gt; Subject &lt;/h3&gt;
    &lt;input id="text1" type="text" data-bind="wijtextbox: 
      {value: subject}"/&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3&gt; Body &lt;/h3&gt;
    &lt;textarea id="Textarea1" rows="2" cols="50" databind="wijtextbox:{value: body}"&gt;
    &lt;/textarea&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Although Knockout has a <code class="literal">value</code> binding, the <code class="literal">wijtextbox</code> binding is purely for presentation. For a list of supported options for each binding, see <a class="ulink" href="http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout">http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout</a>. Only the options listed on the page support two-way bindings while other widget options are just used <a id="id263" class="indexterm"/>for initialization. In the next step, Wijmo<a id="id264" class="indexterm"/> bindings are used for the phone<a id="id265" class="indexterm"/> number<a id="id266" class="indexterm"/> and message type form components:</p><div class="informalexample"><pre class="programlisting">&lt;li&gt;
  &lt;h3&gt; Phone Number &lt;/h3&gt;
  &lt;input data-bind="wijinputmask: 
    { text: phoneNumber, mask: '(999) 000-0000' }" /&gt;
&lt;/li&gt;

&lt;li&gt;
  &lt;h3&gt; Message Type &lt;/h3&gt;
  &lt;input data-bind="wijcombobox: 
    { text: messageType, data: messageTypes }"/&gt;
&lt;/li&gt;</pre></div><p>The <code class="literal">wijinputmask</code> binding initializes a <code class="literal">WijmoInputMask</code> widget<a id="id267" class="indexterm"/> with the pattern <code class="literal">(___) ___-____</code>. The <code class="literal">text</code> option binds it to <a id="id268" class="indexterm"/>the observable <code class="literal">phoneNumber</code> in the ViewModel. The <code class="literal">wijcombobox</code> widget acts as a dropdown for the message type. The <code class="literal">data</code> option sets the <code class="literal">messageTypes</code> as<a id="id269" class="indexterm"/> available. Since the message types are only read and not written, we scope it outside of the ViewModel. Changes to objects outside of the ViewModel layer do not affect the UI. Later on, we submit the ViewModel object to the server and having extraneous data such as message types outside of the ViewModel layer simplifies the code. Wijmo's ComboBox takes an array of objects with the label and value for the data option. The <code class="literal">label</code> property<a id="id270" class="indexterm"/> is the text displayed, while <code class="literal">value</code> would be stored in the <code class="literal">messageType</code> observable.</p><div class="informalexample"><pre class="programlisting">varmessageTypes = $.map(["Alpha", "Beta", "Gamma"], function (type) {
  return {label: type, value: type}
});</pre></div><p>To initialize the message type to <code class="literal">Gamma</code>, we set it in the observable:</p><div class="informalexample"><pre class="programlisting">varViewModel = function () {
  this.subject = ko.observable('');
  this.body = ko.observable('');
  this.messageType = ko.observable('Gamma');
  this.phoneNumber = ko.observable('');
};</pre></div><p>Finally, the last item we have left on the form is a submit button which sends the data to the server using a WebSocket object. For this part, we will use Socket.IO. To set up <code class="literal">So</code>
<code class="literal">cket.IO</code>, download and install <code class="literal">Node.JS</code>
<a id="id271" class="indexterm"/> from <a class="ulink" href="http://nodejs.org/download/">http://nodejs.org/download/</a>, then run <code class="literal">npm install socket.io</code> on the command line. This will make the path <code class="literal">/socket.io/socket.io.js</code> available in the browser when the <code class="literal">Node.JS</code> server is running. On<a id="id272" class="indexterm"/> the server, <code class="literal">Socket.IO</code> listens<a id="id273" class="indexterm"/> for message events and broadcasts<a id="id274" class="indexterm"/> it as news. The <code class="literal">emit</code> function broadcasts to<a id="id275" class="indexterm"/> all clients except the one<a id="id276" class="indexterm"/> who sent the message:</p><div class="informalexample"><pre class="programlisting">io.sockets.on('connection', function (socket) {
  socket.on('message', function (data) {
  socket.broadcast.emit('news', data);
  });
});</pre></div><p>In the browser, a WebSocket connection is created to <code class="literal">localhost</code> by calling <code class="literal">io.connect('http://localhost')</code>. The <code class="literal">submit</code> function sends a message event to the <a id="id277" class="indexterm"/>server:</p><div class="informalexample"><pre class="programlisting">varViewModel = function () {
...
  this.submit = function () {
    socket.emit('message', ko.toJSON(viewModel));
  }
};</pre></div><p>
<code class="literal">ko.toJSON</code> converts the ViewModel data to JSON. JSON includes all of the observables. The submit button is bound to the method through the click binding:</p><div class="informalexample"><pre class="programlisting">&lt;li&gt;
  &lt;button id="Button1" data-bind="click: submit"&gt;
    Submit
  &lt;/button&gt;
&lt;/li&gt;</pre></div><p>For decorating the button, call <code class="literal">$('button').button()</code>. The jQuery UI button method styles the submit button in the same way as other widgets. You may ask, why not just write the View so that the jQuery UI button is applied in the binding? The following code would work in a perfect world:</p><div class="informalexample"><pre class="programlisting">&lt;button id="Button1" data-bind="button: { click: submit }"&gt;
  Submit
&lt;/button&gt;</pre></div><p>Yet, Wijmo<a id="id278" class="indexterm"/> does not support binding to the <code class="literal">click</code> event on button widgets. So we use Knockout's native <code class="literal">click</code> binding and jQuery UI's <code class="literal">button</code> method.</p><p>To make<a id="id279" class="indexterm"/> the View and the ViewModel layers work together, we apply the bindings to the HTML:</p><div class="informalexample"><pre class="programlisting">varviewModel = new ViewModel();
ko.applyBindings(viewModel);</pre></div><p>With<a id="id280" class="indexterm"/> the Rocket theme, the <span class="strong"><strong>Send Message</strong></span> page<a id="id281" class="indexterm"/> looks<a id="id282" class="indexterm"/> like the following<a id="id283" class="indexterm"/> screenshot:</p><div class="mediaobject"><img src="graphics/6067OT_6_06.jpg" alt="Sending a message with Knockout and Socket.IO"/></div></div><div class="section" title="Displaying messages on the Dashboard"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec27"/>Displaying messages on the Dashboard</h2></div></div></div><p>Our ViewModel<a id="id284" class="indexterm"/> class for the Dashboard page is simple. It is composed of an <code class="literal">observableArray</code> of message objects. An <code class="literal">observableArray</code> is useful when you want to detect and respond to changes in a collection of JavaScript objects. Since the messages on the Dashboard are not editable, the properties of each message object do not need to be an observable. Each message has <code class="literal">subject</code>, <code class="literal">body</code>, <code class="literal">messageType</code>, and, <code class="literal">phoneNumber</code> strings:</p><div class="informalexample"><pre class="programlisting">varviewModel = {
  data: ko.observableArray([
    {"subject": "Hi", "body": "Just a message", "messageType": "Gamma", "phoneNumber": "4128675309"}
  ])
};</pre></div><p>On receiving an update from the server, the message is added to the ViewModel. The data is received<a id="id285" class="indexterm"/> as text, as in AJAX responses. So the <code class="literal">JSON.parse</code> method turns it<a id="id286" class="indexterm"/> into a <code class="literal">message</code> object:</p><div class="informalexample"><pre class="programlisting">var socket = io.connect('http://localhost');
socket.on('news', function (data) {
  viewModel.data.push(JSON.parse(data));
});</pre></div><p>In the preceding code, a WebSocket connection is made to the server, allowing bi-directional communication. However, we only listen for events from the server for the Dashboard.</p><p>Our View <a id="id287" class="indexterm"/>layer is just a table. Wijmo makes displaying tabular data so easy that all we need to make it dynamic is just the <code class="literal">wijgrid</code> binding, along with one essential option, <code class="literal">data</code>. The <code class="literal">data</code> option<a id="id288" class="indexterm"/> takes as its parameter a <code class="literal">wijdatasource</code> widget<a id="id289" class="indexterm"/>, an array, or a DOM table. A <code class="literal">wijdatasource</code> can be used to load data dynamically from a remote source with filtering and sorting. Because our application doesn't have a database in the Model, we pass an <code class="literal">observableArray</code>to<a id="id290" class="indexterm"/> the <code class="literal">data</code> option:</p><div class="informalexample"><pre class="programlisting">&lt;table id="dataGrid" data-bind="wijgrid: { data: data, allowSorting: true }"&gt;
&lt;/table&gt;</pre></div><p>To enhance the functionality, <code class="literal">allowSorting</code> is set so that clicking on a column heading sorts the table by that column. The <code class="literal">wijgrid</code> binding takes care of updating the table when the ViewModel data changes. As you are now familiar, we are missing an essential piece that links the View and the ViewModels: <code class="literal">ko.applyBindings(viewModel)</code>. That finishes the dashboard with the result as seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6067OT_6_08.jpg" alt="Displaying messages on the Dashboard"/></div><p>The dashboard initially loads with just the first message. When the <span class="strong"><strong>Send Message</strong></span> page is submitted, <a id="id291" class="indexterm"/>another message is inserted below it.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Summary</h1></div></div></div><p>Wijmo, combined with Knockout, makes programming interactive applications easy. In the rating system example, we have seen how observables that are computed from other observables work. We've used a dependent observable to calculate the total number of points used as each rating changes. In the Dashboard example, we built a dynamic table that is updated by the server with the Wijmo grid widget. Also, we coded the Send Message page to use the Wijmo widgets in combination with Knockout bindings. The next chapter introduces mobile web development with Wijmo Mobile.</p></div></body></html>