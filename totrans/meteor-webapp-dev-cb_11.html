<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Leveraging Advanced Features</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Building custom server methods</li><li class="listitem">Creating custom EJSON objects</li><li class="listitem">Handling asynchronous events</li><li class="listitem">Using asynchronous functions</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Introduction</h1></div></div></div><p>There are some unique functions Meteor offers that make our lives in a full-stack development environment even easier. This chapter will go into these lesser-advertised areas of functionality, providing you with even more under the hood knowledge to make your applications elegant and powerful.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Building custom server methods</h1></div></div></div><p>The majority of <a id="id586" class="indexterm"/>communications we perform between the client and server in Meteor is done via DDP. There are times, however, where direct server calls can come in very handy. For example, while you're testing, or as an admin, you may create some <code class="literal">'hidden'</code> helper methods to make debugging easier. In other instances, you may want to make very secure or very simple methods available to reduce the vulnerability or complexity of your code. In any case, server methods are a staple of development, and this recipe will walk you through creating and using server-side methods, using the <code class="literal">Meteor.methods()</code> function.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec279"/>Getting ready</h2></div></div></div><p>To create server methods, we first need a basic application. We'll quickly create a color swatch app. Nothing fancy, but once we're done, we will be able to create server methods with good visual feedback.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec30"/>Project setup</h3></div></div></div><p>You will need <a id="id587" class="indexterm"/>Meteor installed, and have a project created. In a terminal window, create your root project by entering the following commands:</p><div><pre class="programlisting">
<strong>$ meteor create server-calls</strong>
<strong>$ cd server-calls</strong>
<strong>$ rm server-calls.*</strong>
<strong>$ mkdir {client,server,both}</strong>
<strong>$ meteor add twbs:bootstrap</strong>
<strong>$ meteor</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec31"/>Creating a simple app</h3></div></div></div><p>Create a file <a id="id588" class="indexterm"/>named <code class="literal">[project root]/both/helpers.js</code> and add the following code:</p><div><pre class="programlisting">Swatches = new Mongo.Collection('swatches');

randomColor = function(){
  var retCol = '#';
  while (retCol.length&lt;4) {
    retCol += Random.choice('06F');
  }
  return retCol;
}</pre></div><p>Next, create a file named <code class="literal">[project root]/client/client.js</code> and add the following code:</p><div><pre class="programlisting">Template.colors.helpers({
  swatches: function(){
    return Swatches.find().fetch();
  }
})

Template.body.events({
  'click #newColor' : function(e){
    Swatches.insert({color:randomColor()});
  }
})</pre></div><p>Create some simple styling by creating a file named <code class="literal">[project root]/client/styles.css</code> with the following style declarations:</p><div><pre class="programlisting">.swatch{
  display:inline-block;
  height:8rem;
  width:8rem;
  border-radius: 0.5rem;
  margin-top: 1rem;
}

#newColor{
  display:block;
  margin-top: 0.5rem;
}</pre></div><p>Finally, create your <a id="id589" class="indexterm"/>templates by creating <code class="literal">[project root]/client/main.html</code> and adding the following templates:</p><div><pre class="programlisting">&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;div id="newColor" class="btn btn-info btn-lg"&gt;
      &lt;span class="glyphicon glyphicon-plus"&gt;&lt;/span&gt;
    &lt;/div&gt;
    {{&gt; colors}}
  &lt;/div&gt;
&lt;/body&gt;


&lt;template name="colors"&gt;
  {{#each swatches}}
  &lt;div class="swatch" style="background-color:{{color}}"&gt;&lt;/div&gt;
  {{/each}}
&lt;/template&gt;</pre></div><p>Save all your changes, navigate to <code class="literal">http://localhost:3000</code> in a browser, and click the button with the plus sign on it repeatedly to add random color swatches. You should see something similar to the following screenshot:</p><div><img src="img/image00420.jpeg" alt="Creating a simple app"/></div><p style="clear:both; height: 1em;"> </p><p>You are now ready to create some helper server methods.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec280"/>How to do it...</h2></div></div></div><p>We will create two <a id="id590" class="indexterm"/>server methods. One to clear the <code class="literal">Swatches</code> collection, and one that adds only unique colors.</p><div><ol class="orderedlist arabic"><li class="listitem">First, let's build the <code class="literal">clearSwatches()</code> function. Create a file named <code class="literal">[project root]/server/methods.js</code> and add the following <code class="literal">Meteor.methods</code> declaration:<div><pre class="programlisting">Meteor.methods({
  clearSwatches: function(){
    Swatches.remove({});
  }
});</pre></div><p>In your browser console, enter the following command:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('clearSwatches')</strong>
</pre></div><p>All your color swatches should disappear. Don't fret, friend, you can always create more swatches by clicking the button on the screen.</p></li><li class="listitem">Next, let's create the <code class="literal">addUniqueSwatches()</code> function. Open <code class="literal">methods.js</code> from the preceding step and add the following declaration just after the <code class="literal">clearSwatches</code> declaration:<div><pre class="programlisting">clearSwatches: function(){
    Swatches.remove({});
  }<strong>,</strong>
<strong>  addUniqueSwatch: function(newColor){</strong>
<strong>    if (Swatches.findOne({color:newColor})) return null;</strong>
<strong>    Swatches.insert({color:newColor});</strong>
<strong>  }</strong>
</pre></div></li><li class="listitem">Now, open <code class="literal">[project root]/client/client.js</code>, and make the following change to the <code class="literal">Template.body.events</code> declaration:<div><pre class="programlisting">Template.body.events({
  'click #newColor' : function(e){
<strong>    Meteor.call('addUniqueSwatch' , randomColor());</strong>
  }
})</pre></div><p>Now, as you click on the button to add colors, you will find that, eventually, no new swatches will be added. This is because the total number of <a id="id591" class="indexterm"/>unique colors is 27. If you start with no swatches, your screen will eventually look similar to the following screenshot:</p><div><img src="img/image00421.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><p>You won't be able to add more than the 27 colors, no matter how many times you click the button.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec281"/>How it works...</h2></div></div></div><p>We created two calls on the server by creating code inside the <code class="literal">server</code> folder. These calls are exposed to the client because we declared them using the <code class="literal">Meteor.methods()</code> function.</p><p>The <code class="literal">clearSwatches()</code> method we created in the <code class="literal">methods.js</code> file is <em>hidden</em>, in that, unless you know it's there, there's no easy way to know that it exists. The <code class="literal">addUniqueSwatch()</code> method is used inside of the <code class="literal">onclick</code> event for our button, so someone could discover it by looking at our client code.</p><p>In both cases, the methods are not called through an Ajax/traditional server call, but are instead automatically <a id="id592" class="indexterm"/>exposed by Meteor, and , very easy to invoke via the <code class="literal">Meteor.call()</code> method, which accepts the name of the method as the first parameter, and any additional parameters, as method arguments.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec282"/>There's more…</h2></div></div></div><p>If you pass a callback function as the last argument in <code class="literal">Meteor.call()</code>, the callback will be automatically invoked when the server method has completed execution. You can use this to perform actions after the call is complete. The following is an example.</p><p>Open <code class="literal">[project root]/server/methods.js</code> and make the following changes to <code class="literal">addUniqueSwatch()</code> function:</p><div><pre class="programlisting">addUniqueSwatch: function(newColor){
    if (Swatches.findOne({color:newColor})) return null;
    Swatches.insert({color:newColor});
<strong>    return Swatches.find().count();</strong>
  }</pre></div><p>Now, in your browser console, quickly reset the <code class="literal">Swatches</code> collection:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('clearSwatches')</strong>
</pre></div><p>Finally, make the following manual call to <code class="literal">addUniqueSwatch()</code> multiple times:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('addUniqueSwatch',randomColor(), function(err,data){console.log(data);})</strong>
</pre></div><p>Each time you run that command, the console will print out the total number of swatches. Meteor is auto-running the callback you passed, populating the data parameter with the results from the <code class="literal">addUniqueSwitch()</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec283"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Using the web console</em> recipe in <a class="link" title="Chapter 1. Optimizing Your Workflow" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <em>Optimizing Your Workflow</em></li><li class="listitem">The <em>Adding Meteor packages</em> recipe in <a class="link" title="Chapter 2. Customizing with Packages" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Customizing with Packages</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Creating custom EJSON objects</h1></div></div></div><p>It's pretty <a id="id593" class="indexterm"/>easy to pass simple objects between the client and the server using DDP. But did you know that you can pass custom, named objects complete with methods? The folks at Meteor have extended JSON to allow customized, complete objects to be passed over DDP, without you having to worry about serialization/deserialization. This recipe will teach you how to create and use custom EJSON objects, and pass those custom objects between the client and the server.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec284"/>Getting ready</h2></div></div></div><p>We will be using the previous recipe found in this chapter, <em>Building custom server methods</em>, as a baseline. Please complete that recipe, and then make the following modifications.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec32"/>Declaring the Swatch object</h3></div></div></div><p>Create a new <a id="id594" class="indexterm"/>file named <code class="literal">[project root]/both/swatch.js</code> <a id="id595" class="indexterm"/>and add the following code to the file:</p><div><pre class="programlisting">Swatch = function (color){
  this.color = color;
}

Swatch.prototype = {
  constructor: Swatch,
  
  switch: function(){
    this.color = randomColor();
  },
  toString: function(){
    return "My color is: " + this.color;
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec33"/>Modifying Swatches.insert()</h3></div></div></div><p>In preparation <a id="id596" class="indexterm"/>for using EJSON objects, which are not the normal, plain objects MongoDB expects, we need to layer our objects by one <a id="id597" class="indexterm"/>level when inserting. In the web console, execute the following line to clear out the <code class="literal">Swatches</code> collection:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('clearSwatches')</strong>
</pre></div><p>Now, open <code class="literal">[project root]/server/methods.js</code> and modify the <code class="literal">Swatches.insert()</code> method <a id="id598" class="indexterm"/>as follows:</p><div><pre class="programlisting">addUniqueSwatch: function(newColor){
  ...
<strong>  Swatches.insert({swatch:new Swatch(newColor)});</strong>
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec34"/>Changing Swatch colors</h3></div></div></div><p>The layering on <a id="id599" class="indexterm"/>insert will break our UI a bit, but that's okay, we can recover because we're awesome. Inside the <code class="literal">[project root]/client/client.js</code> file, in the <code class="literal">Template.colors.helpers</code> section, and just below the <code class="literal">swatches</code> helper, add the following helper:</p><div><pre class="programlisting">}<strong>,</strong>
<strong>color: function(){</strong>
<strong>    return this.swatch.color;</strong>
<strong>}</strong>
</pre></div><p>Lastly, let's add the following <code class="literal">events</code> declaration, so that we can change the color of our swatches:</p><div><pre class="programlisting">Template.colors.events({
  'click .swatch' : function(e){
    this.swatch.color = randomColor();
    Swatches.update(this._id,this);
  }
})</pre></div><p>Save your changes, and test in a browser by clicking on any of the added swatches. The corresponding swatch should change to a random color each time you click. You are now ready to proceed with creating custom EJSON objects.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec285"/>How to do it…</h2></div></div></div><p>As mentioned, Meteor <a id="id600" class="indexterm"/>takes care of the serialization and deserialization for us. We just need to declare our object as an EJSON object. Proceed with the following steps to create a custom EJSON object:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's add the <code class="literal">typeName</code> and <code class="literal">toJSONValue</code> functions. Open the <code class="literal">[project root]/both/swatch.js</code> file, and add the following two functions to the <code class="literal">Swatch.prototype</code> declaration, just below the <code class="literal">toString()</code> function:<div><pre class="programlisting">}<strong>,</strong>
<strong>typeName: function(){</strong>
<strong>  return 'Swatch';</strong>
<strong>},</strong>
<strong>toJSONValue: function(){</strong>
<strong>  return {</strong>
<strong>    color:this.color</strong>
<strong>  };</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Next we need to declare our object with <code class="literal">EJSON.addType</code>. In the same <code class="literal">swatch.js</code> file, at the very bottom, add the following function call:<div><pre class="programlisting">EJSON.addType("Swatch", function fromJSONValue(value){
  return new Swatch(value.color);
});</pre></div></li><li class="listitem">We're now ready to use our EJSON object methods. Open the <code class="literal">[project root]/client/client.js</code> file, and make the following changes to <code class="literal">Template.colors.events</code>:<div><pre class="programlisting">'click .swatch': function (e) {
<strong>    this.swatch.switch();</strong>
    Swatches.update(this._id, this);
<strong>    console.log(this.swatch.toString());</strong>
<strong>  }</strong>
</pre></div><p>In the browser, add <a id="id601" class="indexterm"/>some new swatches and click on them with your browser console window open. The swatches will change colors, and they will tell you what their new colors are in the console. Your screen should look similar to the following screenshot:</p><div><img src="img/image00422.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec286"/>How it works…</h2></div></div></div><p>When known <code class="literal">EJSON</code> objects are inserted into, or retrieved from MongoDB, Meteor automatically serializes and deserializes the objects using the <code class="literal">EJSON</code> library.</p><p>To do this properly, the objects themselves have to have at least two methods. First, the object must have the <code class="literal">typeName</code> function, which aids in mapping the object to the declared <code class="literal">EJSON</code> object. Second, the object must have the <code class="literal">toJSONValue()</code> function, so that Meteor can properly serialize the object to a string/standard JSON value. Without the <code class="literal">toJSONValue()</code> function, MongoDB would choke on the object, and refuse to insert it. Transporting the object over DDP would be equally unfeasible.</p><p>The other action needed is to declare the <code class="literal">EJSON</code> object, which we did in <code class="literal">swatch.js</code> with the <code class="literal">EJSON.addType()</code> function. This function takes a <code class="literal">fromJSONValue()</code> function as an argument, which (exactly as it sounds) takes the JSON value passed over the wire and instantiates an actual object of the appropriate type. In our case, this was a <code class="literal">Swatch</code> object, and the only property <a id="id602" class="indexterm"/>needing to be created was the <code class="literal">color</code> property, which was passed in through the constructor.</p><p>Once the previous methods are declared, and the <code class="literal">addType</code> function called, Meteor takes care of the rest for us, and stores our objects rather cleverly in MongoDB. As an example, here is what the raw JSON looks like for one of our serialized <code class="literal">Swatch</code> objects:</p><div><pre class="programlisting"> {
  "_id" : "tktEzxMGTGNZ8oB4R",
    "swatch" : {
      "EJSON$type" : "Swatch",
        "EJSON$value" : {
          "EJSONcolor" : "#66F"
        }
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec287"/>There's more…</h2></div></div></div><p>The <code class="literal">EJSON</code> object has other helper functions that you can declare in an object to aid in the development and use of <code class="literal">EJSON</code> objects.</p><p>The <code class="literal">.clone()</code> method can be implemented on an <code class="literal">EJSON</code> object to perform a deep copy with logic. If you don't declare the <code class="literal">.clone()</code> function, Meteor uses <code class="literal">toJSONValue()</code> instead.</p><p>The <code class="literal">.equals()</code> method takes another object as a parameter and performs a custom comparison of your choosing. If you don't declare the <code class="literal">.equals()</code> function, Meteor simply takes both objects, performs a <code class="literal">toJSONValue()</code> transformation on each, and compares the result.</p><div><h3 class="title"><a id="tip44"/>Tip</h3><p>Learn more <a id="id603" class="indexterm"/>about the EJSON library by viewing the Meteor documentation, found here: <a class="ulink" href="https://www.meteor.com/ejson">https://www.meteor.com/ejson</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec288"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Building </em><a id="id604" class="indexterm"/><em>custom server methods</em> recipe in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Handling asynchronous events</h1></div></div></div><p>Meteor is a <a id="id605" class="indexterm"/>reactive framework. As you've probably noticed, it's built on top of <code class="literal">Node.js</code>, but when writing or using packages, it somehow magically avoids all of the callback and event loop drama you'd normally face with <code class="literal">Node.js</code>. Meteor lets you code in a declarative, synchronous-like style. This recipe will show you one of the ways Meteor does this, and how you can handle asynchronous events coming in from a third-party package. In this case, we will read an incoming Twitter stream from the npm <code class="literal">twit</code> package.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec289"/>Getting ready</h2></div></div></div><p>We need to quickly set up a test application on Twitter and load the npm <code class="literal">twit</code> module, so we'll do that here, so <a id="id606" class="indexterm"/>as not to distract from the recipe itself. Note that you can use any asynchronous event stream you would like for this recipe, including the standard <code class="literal">setInterval()</code> method, which could be used to mimic an asynchronous event stream.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec35"/>Creating a baseline Meteor app</h3></div></div></div><p>Open a <a id="id607" class="indexterm"/>terminal window, navigate to where you would like your project to reside, and enter the following commands:</p><div><pre class="programlisting">
<strong>$ meteor create thirdpartyevents</strong>
<strong>$ cd thirdpartyevents</strong>
<strong>$ rm thirdpartyevents.*</strong>
<strong>$ mkdir {client,server,both}</strong>
<strong>$ meteor add meteorhacks:npm</strong>
<strong>$ meteor</strong>
</pre></div><p>Instead of starting Meteor like usual, this will instead create a file called <code class="literal">[project root]/packages.json</code>. Open that file in an editor and add the following declaration:</p><div><pre class="programlisting">{
<strong>  "twit" : "1.1.20"</strong>
}</pre></div><p>Save your changes, and in the terminal, run the <code class="literal">meteor</code> command again:</p><div><pre class="programlisting">
<strong>$ meteor</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec36"/>Obtaining your Twitter Access Tokens</h3></div></div></div><p>Use a <a id="id608" class="indexterm"/>browser to log in to <a class="ulink" href="http://twitter.com">http://twitter.com</a>, and then navigate to <a class="ulink" href="https://apps.twitter.com">https://apps.twitter.com</a>. Create a new app, following <a id="id609" class="indexterm"/>the instructions, and click on the <strong>Keys and Access Tokens</strong> tab to obtain your Consumer Key + Secret and a valid Access Token + Secret found on that page. <em>Keep this page open</em>, as we will need to reference it a bit later.</p><div><h3 class="title"><a id="tip45"/>Tip</h3><p>For Meteor-specific instructions on setting up a Twitter App, please see the <em>Implementing OAuth accounts packages</em> recipe, found in <a class="link" title="Chapter 10. Working with Accounts" href="part0079.xhtml#aid-2BASE1">Chapter 10</a>, <em>Working with Accounts.</em></p></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec37"/>Initializing twit</h3></div></div></div><p>Create a file <a id="id610" class="indexterm"/>named <code class="literal">[project root]/server/config-twit.js</code> and add the following code, replacing the <code class="literal">consumer_key</code>, <code class="literal">consumer_secret</code>, <code class="literal">access_token</code>, and <code class="literal">access_token_secret</code> with the information you obtained previously. When completed, your file should look similar to the following code:</p><div><pre class="programlisting">Twitter = Meteor.npmRequire('twit');

Twit = new Twitter({
  consumer_key: 'egrdttfakeconsumerkeyFMx42339eMR8',
  consumer_secret: 'fR2r02CthisnJCDtVisMij2WjNiafakeo6QPqsecretnxztb',
  access_token: 'q8thisnEkn3xMiscUhafake9I5EOAtoken3DvDZM',
  access_token_secret: '7mel7Kr8fakeaccesstokensecretdzpiDuaqtRaij914'
});

simplifyTweet = function(tweet){
  var retObj = {};
  if (!tweet) return retObj;
  retObj.created_at = tweet.created_at;
  retObj.text = tweet.text;
  retObj.user = '@' + tweet.user.screen_name;
  
  return retObj;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec38"/>Creating the Tweets collection, and building a stream reader</h3></div></div></div><p>Create a file <a id="id611" class="indexterm"/>named <code class="literal">[project root]/both/model.js</code> and <a id="id612" class="indexterm"/>add the following line:</p><div><pre class="programlisting">Tweets = new Mongo.Collection('tweets');</pre></div><p>Now, create a file named <code class="literal">[project root]/server/twitter-stream.js</code> and add the following code:</p><div><pre class="programlisting">stream = {};
Meteor.methods({
  TwitterStream: function (query) {
    if (query == 'off') {
      if (stream.stop != null) stream.stop();
      Tweets.remove({});
      return;
    }
    stream = Twit.stream('statuses/filter', {
      track: query
    });
    stream.on('tweet', function (tweet) {
      var simpleT = simplifyTweet(tweet);
      console.log(simpleT);
    });
  }
})</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec39"/>Tracking and testing changes</h3></div></div></div><p>Create a <a id="id613" class="indexterm"/>file named <code class="literal">[project root]/client/consoleTracking.js</code> and add the following code:</p><div><pre class="programlisting">Tracker.autorun(function(){
    console.table(Tweets.find().fetch());
  });</pre></div><p>Now, navigate in a <a id="id614" class="indexterm"/>browser to <code class="literal">http://localhost:3000</code>, open the console window, and enter the following command:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('TwitterStream','JavaScript')</strong>
</pre></div><p>In your terminal window where you started Meteor with the <code class="literal">meteor</code> command, you should periodically see some JSON-formatted tweets. If tweets aren't showing up, it may be that the query you used isn't popular enough (this is a live Twitter feed!), so you can select something else, like <em>lmao</em> or <em>lebron</em>, if you want to see a steady stream.</p><p>Lastly, you will want to test the <code class="literal">Tweets</code> collection tracking. In the browser console, enter the following command, and run it multiple times:</p><div><pre class="programlisting">
<strong>&gt; Tweets.insert({a:Tweets.find().count()})</strong>
</pre></div><p>If everything is set up properly, you will see a growing table of entries in your console.</p><p>To turn off the Twitter feed and to clear out the <code class="literal">Tweets</code> collection, enter the following in the browser console:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('TwitterStream','off')</strong>
</pre></div><p>With everything all cleaned up, let's proceed to the recipe.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec290"/>How to do it…</h2></div></div></div><p>This recipe <a id="id615" class="indexterm"/>concentrates on only one thing: handling asynchronous events synchronously. As such, there are one two very simple steps as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">[project root]/server/twitter-stream.js</code>, and add the following <code class="literal">insert</code> statement to the <code class="literal">stream.on</code> handler, as follows:<div><pre class="programlisting">stream.on('tweet', function (tweet) {
      var simpleT = simplifyTweet(tweet);
      console.log(simpleT);
<strong>      Tweets.insert(simpleT);</strong>
    });</pre></div><p>Because the event handler is an asynchronous event, if you try turning the stream on as-is, you will get a very nasty error stating the following:</p><div><pre class="programlisting">
<strong>Meteor code must always run within a Fiber.</strong>
</pre></div></li><li class="listitem">Modify the <code class="literal">stream.on</code> handler as follows:<div><pre class="programlisting">stream.on('tweet', <strong>Meteor.bindEnvironment(</strong>
      function (tweet) {
      var simpleT = simplifyTweet(tweet);
      console.log(simpleT);
      Tweets.insert(simpleT);
    }<strong>)</strong>);</pre></div><p>You can now turn on the stream in the browser console, as follows:</p><div><pre class="programlisting">
<strong>&gt; Meteor.call('TwitterStream','JavaScript')</strong>
</pre></div><p>As entries come in from the stream, they will populate in the Tweets collection, and you will see the results in your browser console, similar to the following:</p><div><img src="img/image00423.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec291"/>How it works…</h2></div></div></div><p>To accomplish the declarative, reactive environment we've come to know and love, the Meteor server intentionally runs on a single thread per request. Therefore, when you create some type of asynchronous action, such as listening to a <code class="literal">Node.js</code> event stream, the callback (handler) for that asynchronous action operates on a different thread. When the callback is fired, if you try to call Meteor functions (like <code class="literal">Tweets.insert()</code> for example ), Meteor will throw an error, because the callback and the main Meteor server are on different threads. In addition, if you used any global variables with values, you can't guarantee that those values have remained the same while the asynchronous call was waiting. Some other operation could have changed the environment!</p><p>Meteor has an elegant <a id="id616" class="indexterm"/>way of dealing with this situation, using <code class="literal">Meteor.bindEnvironment()</code>.</p><p>By wrapping the callback function with <code class="literal">Meteor.bindEnvironment()</code>, a <em>Fiber</em> is created. The Fiber keeps track of the variables and their values (the environment), and knows that sooner or later the callback is going to be called.</p><p>In the meantime, the Fiber removes the operation from the event loop, so that the operation isn't blocking any other operations. Once the callback is ready, the Fiber puts the operation back into the event loop, restores the environment, and the operation completes.</p><p>In this particular case, when we use <code class="literal">Meteor.call('TwitterStream',…)</code> we are sending a request to the Meteor server on a single thread. The <code class="literal">Twit.stream</code> service is started on that thread but the events (the incoming stream) are asynchronous. By wrapping the handler for <code class="literal">stream.on()</code> with <code class="literal">Meteor.bindEnvironment()</code>, we are instructing Meteor to "take a snapshot" of the current environment. Meteor then takes the current operation out of the event loop so that other things can get through. Then, we wait.</p><p>When the stream has new data, the event fires, which triggers the callback. Meteor (or more accurately, the Fiber) sees that the callback is ready, restores the environment from the snapshot created using <code class="literal">Meteor.bindEnvironment()</code>, and puts the operation back on the event loop. This process happens again and again, as many times as needed, whenever a new Tweet comes in and triggers the callback function.</p><p>At the risk of oversimplifying, <code class="literal">Meteor.bindEnvironment()</code> wraps some code into the Fiber and then waits, without blocking any other code operations. Once the wrapped code is ready/activated, the Fiber makes sure that the code is executed on the correct thread with the correct data.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec292"/>There's more…</h2></div></div></div><p>We can be very granular about what code is wrapped, and we can separate out wrapped code, to make the overall code easier to read.</p><p>Add the following function to the top of the <code class="literal">twitter-stream.js</code> file:</p><div><pre class="programlisting">wrappedInsert = Meteor.bindEnvironment(function(simpleT){
  Tweets.insert(simpleT);
});</pre></div><p>Now, revert <code class="literal">stream.on</code> <a id="id617" class="indexterm"/>by removing the <code class="literal">Meteor.bindEnvironment()</code> wrapping, and call <code class="literal">wrappedInsert()</code> instead of <code class="literal">Tweets.insert()</code>, as follows:</p><div><pre class="programlisting">stream.on('tweet', function (tweet) {
      var simpleT = simplifyTweet(tweet);
      console.log(simpleT);
<strong>      wrappedInsert(simpleT);</strong>
    });</pre></div><p>This will operate exactly the same as wrapping the entire callback function.</p><p>One last alternative, we could take the entire callback out, wrap it with a user-friendly name, and use that name in the callback section, as shown in the following example:</p><div><pre class="programlisting">wrappedCallback = Meteor.bindEnvironment(
  function (tweet) {
    var simpleT = simplifyTweet(tweet);
    console.log(simpleT);
    Tweets.insert(simpleT);
  }
);
...
stream.on('tweet', wrappedCallback);</pre></div><div><h3 class="title"><a id="tip46"/>Tip</h3><p>The most concise <a id="id618" class="indexterm"/>explanation of Fibers, Futures, and <code class="literal">Meteor.bindEnvironment()</code> can be found here: <a class="ulink" href="http://bit.ly/meteor-fibers-explained">http://bit.ly/meteor-fibers-explained</a>. Make sure to thoroughly review all the links from that page!</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec293"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Implementing OAuth accounts packages</em> recipe in <a class="link" title="Chapter 10. Working with Accounts" href="part0079.xhtml#aid-2BASE1">Chapter 10</a>, <em>Working with Accounts</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Using asynchronous functions</h1></div></div></div><p><code class="literal">Node.js</code>, for all <a id="id619" class="indexterm"/>its awesomeness, has a flaw: callbacks. Being asynchronous and non-blocking has a ton of advantages, and we can't imagine life without it. But, wouldn't it be great if there were a way to avoid the "callback hell" by writing our code in a synchronous style but still reaping the benefits of asynchronous code? As you might have guessed, Meteor has a way of doing just that. This recipe will show you how to write and handle asynchronous functions in a synchronous style using <code class="literal">Meteor.wrapAsync()</code>.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec294"/>Getting ready</h2></div></div></div><p>Because brevity breeds clarity, we will keep this recipe as simple as possible.</p><p>Open a terminal window, navigate to where you would like your project to reside, and enter the following commands:</p><div><pre class="programlisting">
<strong>$ meteor create wrap-sample</strong>
<strong>$ cd wrap-sample</strong>
<strong>$ mkdir server</strong>
<strong>$ meteor</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec295"/>How to do it…</h2></div></div></div><p>We are going to simulate a delayed call to an asynchronous method, using the standard JavaScript <code class="literal">setTimeout()</code> function.</p><div><ol class="orderedlist arabic"><li class="listitem">First, let's prep for the server call. Open <code class="literal">[project root]/wrap-sample.js</code> and modify the <code class="literal">Template.hello.events</code> function, as follows:<div><pre class="programlisting">'click button': function () {
<strong>      var x = 0;</strong>
<strong>      while (x &lt; 5) {</strong>
<strong>        x++;</strong>
<strong>        var q = "" + x + ". do work";</strong>
<strong>        Meteor.call('someCall', q, function (e, d) {</strong>
<strong>          console.log(d);</strong>
<strong>        });</strong>
<strong>      }</strong>
    }</pre></div></li><li class="listitem">Create a file <a id="id620" class="indexterm"/>named <code class="literal">[project root]/server/method.js</code> and add the following asynchronous function:<div><pre class="programlisting">asyncCall = function(query,cb){
  var ranLen = ~~(Math.random()*3000);
  setTimeout(function(){
    cb &amp;&amp; cb(null,query + " complete!");
  },ranLen);
};</pre></div></li><li class="listitem">Now, add a simple <code class="literal">Meteor.methods</code> declaration, using <code class="literal">Meteor.wrapAsync()</code> to write synchronous-style code, as follows:<div><pre class="programlisting">Meteor.methods({
  someCall: function (query) {
    console.log('performing: '+query);
    this.unblock();
    var syncCall = Meteor.wrapAsync(asyncCall);
    var result = syncCall(query);
    return result;
  }
});</pre></div></li><li class="listitem">Open a browser to <code class="literal">http://localhost:3000</code>, open the browser console, and click the button on the screen. As you look at the server terminal, you will immediately see five log entries, printed in consecutive order, similar to the following:<div><pre class="programlisting">
<strong>performing: 1. do work</strong>
<strong>performing: 2. do work</strong>
<strong>performing: 3. do work</strong>
<strong>performing: 4. do work</strong>
<strong>performing: 5. do work</strong>
</pre></div><p>In the Browser window, you will see five log entries. These entries, however, will not be immediate, and will likely be out of order, similar to the following example:</p><div><pre class="programlisting">
<strong>1. do work complete!</strong>
<strong>4. do work complete!</strong>
<strong>2. do work complete!</strong>
<strong>5. do work complete!</strong>
<strong>3. do work complete!</strong>
</pre></div></li><li class="listitem">Click the <a id="id621" class="indexterm"/>button again, and notice the random order and time of completion for each of the five server calls.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec296"/>How it works…</h2></div></div></div><p><code class="literal">Meteor.wrapAsync()</code> is a bit of syntactic sugar for running asynchronous calls as if they were synchronous. As discussed in the <em>Handling asynchronous events</em> recipe from this chapter, Fibers and Futures are the way that Meteor handles asynchronous logic. In this case, we are dealing with what would be considered a <em>standard asynchronous function</em> in <code class="literal">Node.js</code>.</p><p>Meteor defines a standard asynchronous function as a function as follows:</p><div><ul class="itemizedlist"><li class="listitem">Takes a callback as the last argument</li><li class="listitem">Is non-blocking</li><li class="listitem">Executes the callback upon completion</li></ul></div><p>The signature of the callback passed in is always the same. There are two arguments, the first of which is an <code class="literal">error</code> object. If there is an <code class="literal">error</code>, this object will have a value, otherwise, the <code class="literal">error</code> argument will be <code class="literal">null</code>.</p><p>The second argument is a <code class="literal">data</code> object. If the call does not return an <code class="literal">error</code> object as its first parameter, this data argument will have data in it that can be used by the callback function.</p><p>In our case, we declared a standard asynchronous function named <code class="literal">asyncCall()</code>. The signature of <code class="literal">asyncCall()</code> looks as shown in the following example:</p><div><pre class="programlisting">function(query,cb)...</pre></div><p>Nothing in <code class="literal">asyncCall()</code> will block the event loop, even though we're making a call to <code class="literal">setInterval()</code>. The <code class="literal">setInterval()</code> call is asynchronous, and is therefore non-blocking (very much like an ajax call, or a file i/o operation, etc). Once <code class="literal">setInterval()</code> is complete, it invokes our callback, <code class="literal">cb(null , query + '...')</code>.</p><p>In the <code class="literal">Meteor.methods</code> declaration, we created a method named <code class="literal">someCall</code>. Inside of <code class="literal">someCall</code>, we first make sure it won't clog up the event loop by calling <code class="literal">this.unblock()</code>.</p><p>We then take our standard asynchronous function (as defined previously) and we wrap it with the <code class="literal">Meteor.wrapAsync(asyncCall)</code> command.</p><p>Once wrapped, we can use <a id="id622" class="indexterm"/>the wrapped call as if it were synchronous. It's not. There will be a delay in the result, but our operation will wait until the asynchronous call is complete, which allows us to better understand what is happening. If we look at the lines of code after <code class="literal">Meteor.wrapAsync()</code>, we can easily wrap our heads around what is happening:</p><div><pre class="programlisting">var result = syncCall(query);
return result;</pre></div><p>The <code class="literal">result</code> variable is being assigned to the result of the call. We then return <code class="literal">result</code> like we would in a synchronous function. Easy peasy.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec297"/>There's more…</h2></div></div></div><p>The rule for using <code class="literal">Meteor.wrapAsync()</code> can be stated this way: any time you have a standard asynchronous function, where you would normally have to nest your logic in the callback, you can instead wrap the function and use the result as if it were a synchronous call.</p><p>Under the hood, Meteor is wrapping a Fiber/Future and automatically implementing the <code class="literal">.current</code>, <code class="literal">.yield()</code>, <code class="literal">.run()</code>, and <code class="literal">.wait()</code> pieces for you. But don't worry about that. If you just stick with the idea that <code class="literal">.wrapAsync()</code> is turning asynchronous functions with callbacks into standard functions without callbacks, you'll be well on your way to writing elegant, declarative code.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec298"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Handling </em><a id="id623" class="indexterm"/><em>asynchronous events</em> recipe in this chapter</li></ul></div></div></div></body></html>