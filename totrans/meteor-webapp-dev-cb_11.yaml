- en: Chapter 11. Leveraging Advanced Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。利用高级功能
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Building custom server methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义服务器方法
- en: Creating custom EJSON objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义EJSON对象
- en: Handling asynchronous events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步事件
- en: Using asynchronous functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步函数
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are some unique functions Meteor offers that make our lives in a full-stack
    development environment even easier. This chapter will go into these lesser-advertised
    areas of functionality, providing you with even more under the hood knowledge
    to make your applications elegant and powerful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor提供了一些独特的功能，使我们在全栈开发环境中的生活更加轻松。本章将深入探讨这些不太为人所知的功能区域，为你提供更多底层知识，使你的应用程序更加优雅和强大。
- en: Building custom server methods
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义服务器方法
- en: The majority of communications we perform between the client and server in Meteor
    is done via DDP. There are times, however, where direct server calls can come
    in very handy. For example, while you're testing, or as an admin, you may create
    some `'hidden'` helper methods to make debugging easier. In other instances, you
    may want to make very secure or very simple methods available to reduce the vulnerability
    or complexity of your code. In any case, server methods are a staple of development,
    and this recipe will walk you through creating and using server-side methods,
    using the `Meteor.methods()` function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meteor中，我们与客户端和服务器之间的大部分通信都是通过DDP完成的。然而，有时直接调用服务器会非常有用。例如，在测试时，或者作为管理员，你可能需要创建一些“隐藏”的辅助方法来简化调试。在其他情况下，你可能希望提供非常安全或非常简单的服务方法，以减少代码的脆弱性或复杂性。无论如何，服务器方法是开发的基础，本食谱将指导你使用`Meteor.methods()`函数创建和使用服务器端方法。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To create server methods, we first need a basic application. We'll quickly create
    a color swatch app. Nothing fancy, but once we're done, we will be able to create
    server methods with good visual feedback.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务器方法，我们首先需要一个基本的应用程序。我们将快速创建一个颜色样本应用程序。虽然不是什么特别复杂的应用，但一旦完成，我们就能通过良好的视觉反馈来创建服务器方法。
- en: Project setup
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'You will need Meteor installed, and have a project created. In a terminal window,
    create your root project by entering the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Meteor，并创建一个项目。在终端窗口中，通过输入以下命令创建你的根项目：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a simple app
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单应用
- en: 'Create a file named `[project root]/both/helpers.js` and add the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `[project root]/both/helpers.js` 的文件，并添加以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create a file named `[project root]/client/client.js` and add the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `[project root]/client/client.js` 的文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create some simple styling by creating a file named `[project root]/client/styles.css`
    with the following style declarations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `[project root]/client/styles.css` 的文件并添加以下样式声明来创建一些简单的样式：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create your templates by creating `[project root]/client/main.html`
    and adding the following templates:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过创建 `[project root]/client/main.html` 并添加以下模板来创建你的模板：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save all your changes, navigate to `http://localhost:3000` in a browser, and
    click the button with the plus sign on it repeatedly to add random color swatches.
    You should see something similar to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有更改，在浏览器中导航到 `http://localhost:3000`，然后反复点击带有加号按钮以添加随机颜色样本。你应该会看到以下截图类似的内容：
- en: '![Creating a simple app](img/image00420.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单应用](img/image00420.jpeg)'
- en: You are now ready to create some helper server methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以准备创建一些辅助服务器方法了。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will create two server methods. One to clear the `Swatches` collection, and
    one that adds only unique colors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个服务器方法。一个用于清除`Swatches`集合，另一个用于添加唯一的颜色。
- en: 'First, let''s build the `clearSwatches()` function. Create a file named `[project
    root]/server/methods.js` and add the following `Meteor.methods` declaration:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们构建`clearSwatches()`函数。创建一个名为 `[project root]/server/methods.js` 的文件，并添加以下`Meteor.methods`声明：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In your browser console, enter the following command:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的浏览器控制台中，输入以下命令：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All your color swatches should disappear. Don't fret, friend, you can always
    create more swatches by clicking the button on the screen.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有的颜色样本都应该消失。不要担心，朋友，你总是可以通过点击屏幕上的按钮来创建更多样本。
- en: 'Next, let''s create the `addUniqueSwatches()` function. Open `methods.js` from
    the preceding step and add the following declaration just after the `clearSwatches`
    declaration:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`addUniqueSwatches()`函数。从上一步打开`methods.js`文件，并在`clearSwatches`声明之后添加以下声明：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, open `[project root]/client/client.js`, and make the following change
    to the `Template.body.events` declaration:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `[项目根目录]/client/client.js` 文件，并对 `Template.body.events` 声明进行以下修改：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, as you click on the button to add colors, you will find that, eventually,
    no new swatches will be added. This is because the total number of unique colors
    is 27\. If you start with no swatches, your screen will eventually look similar
    to the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当你点击按钮添加颜色时，你会发现最终不会添加新的色卡。这是因为独特的颜色总数为 27。如果你一开始没有色卡，你的屏幕最终会看起来类似于以下截图：
- en: '![How to do it...](img/image00421.jpeg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00421.jpeg)'
- en: You won't be able to add more than the 27 colors, no matter how many times you
    click the button.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论你点击按钮多少次，都无法添加超过 27 种颜色。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We created two calls on the server by creating code inside the `server` folder.
    These calls are exposed to the client because we declared them using the `Meteor.methods()`
    function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `server` 文件夹内创建代码在服务器上创建了两个调用。这些调用被暴露给客户端，因为我们使用 `Meteor.methods()` 函数声明了它们。
- en: The `clearSwatches()` method we created in the `methods.js` file is *hidden*,
    in that, unless you know it's there, there's no easy way to know that it exists.
    The `addUniqueSwatch()` method is used inside of the `onclick` event for our button,
    so someone could discover it by looking at our client code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `methods.js` 文件中创建的 `clearSwatches()` 方法是 *隐藏的*，也就是说，除非你知道它的存在，否则没有简单的方法知道它存在。`addUniqueSwatch()`
    方法用于我们按钮的 `onclick` 事件中，所以有人可以通过查看我们的客户端代码来发现它。
- en: In both cases, the methods are not called through an Ajax/traditional server
    call, but are instead automatically exposed by Meteor, and , very easy to invoke
    via the `Meteor.call()` method, which accepts the name of the method as the first
    parameter, and any additional parameters, as method arguments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，方法不是通过 Ajax/传统服务器调用调用的，而是由 Meteor 自动暴露，并且通过 `Meteor.call()` 方法调用，该方法接受方法名称作为第一个参数，以及任何额外的参数作为方法参数，非常容易调用。
- en: There's more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you pass a callback function as the last argument in `Meteor.call()`, the
    callback will be automatically invoked when the server method has completed execution.
    You can use this to perform actions after the call is complete. The following
    is an example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将回调函数作为 `Meteor.call()` 的最后一个参数传递，当服务器方法执行完成后，回调函数将被自动调用。你可以使用这个功能在调用完成后执行操作。以下是一个示例。
- en: 'Open `[project root]/server/methods.js` and make the following changes to `addUniqueSwatch()`
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `[项目根目录]/server/methods.js` 文件，并对 `addUniqueSwatch()` 函数进行以下修改：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in your browser console, quickly reset the `Swatches` collection:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的浏览器控制台中，快速重置 `Swatches` 集合：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, make the following manual call to `addUniqueSwatch()` multiple times:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，多次手动调用 `addUniqueSwatch()`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each time you run that command, the console will print out the total number
    of swatches. Meteor is auto-running the callback you passed, populating the data
    parameter with the results from the `addUniqueSwitch()` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行该命令时，控制台将打印出色卡的总数。Meteor 会自动运行你传递的回调函数，将 `addUniqueSwitch()` 方法的结果填充到数据参数中。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the web console* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Optimizing
    Your Workflow"), *Optimizing Your Workflow*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。优化你的工作流程") 的 *使用网络控制台* 菜谱中，*优化你的工作流程*
- en: The *Adding Meteor packages* recipe in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Customizing with Packages"), *Customizing with Packages*
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 2 章](part0028.xhtml#aid-QMFO1 "第 2 章。使用包进行自定义") 的 *添加 Meteor 包* 菜谱中，*使用包进行自定义*
- en: Creating custom EJSON objects
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 EJSON 对象
- en: It's pretty easy to pass simple objects between the client and the server using
    DDP. But did you know that you can pass custom, named objects complete with methods?
    The folks at Meteor have extended JSON to allow customized, complete objects to
    be passed over DDP, without you having to worry about serialization/deserialization.
    This recipe will teach you how to create and use custom EJSON objects, and pass
    those custom objects between the client and the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DDP 在客户端和服务器之间传递简单对象非常简单。但你是否知道你可以传递自定义的、命名的对象，包括方法？Meteor 的人扩展了 JSON，允许通过
    DDP 传递自定义的完整对象，而不必担心序列化/反序列化。这个菜谱将教你如何创建和使用自定义 EJSON 对象，并在客户端和服务器之间传递这些自定义对象。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the previous recipe found in this chapter, *Building custom
    server methods*, as a baseline. Please complete that recipe, and then make the
    following modifications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章中找到的先前配方，即*构建自定义服务器方法*，作为基准。请完成该配方，然后进行以下修改。
- en: Declaring the Swatch object
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明Swatch对象
- en: 'Create a new file named `[project root]/both/swatch.js` and add the following
    code to the file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`[项目根目录]/both/swatch.js`的新文件，并将以下代码添加到该文件中：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Modifying Swatches.insert()
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改Swatches.insert()
- en: 'In preparation for using EJSON objects, which are not the normal, plain objects
    MongoDB expects, we need to layer our objects by one level when inserting. In
    the web console, execute the following line to clear out the `Swatches` collection:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用EJSON对象，这些对象不是MongoDB期望的正常、纯对象，我们在插入时需要将对象分层。在网页控制台中，执行以下行以清除`Swatches`集合：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, open `[project root]/server/methods.js` and modify the `Swatches.insert()`
    method as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`[项目根目录]/server/methods.js`并修改`Swatches.insert()`方法如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Changing Swatch colors
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变色板颜色
- en: 'The layering on insert will break our UI a bit, but that''s okay, we can recover
    because we''re awesome. Inside the `[project root]/client/client.js` file, in
    the `Template.colors.helpers` section, and just below the `swatches` helper, add
    the following helper:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入时分层将稍微破坏我们的UI，但没关系，我们可以恢复，因为我们很棒。在`[项目根目录]/client/client.js`文件中的`Template.colors.helpers`部分，并在`swatches`辅助函数下方添加以下辅助函数：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, let''s add the following `events` declaration, so that we can change
    the color of our swatches:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加以下`events`声明，以便我们可以改变色板的颜色：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save your changes, and test in a browser by clicking on any of the added swatches.
    The corresponding swatch should change to a random color each time you click.
    You are now ready to proceed with creating custom EJSON objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的更改，并通过点击添加的任何色板在浏览器中测试。每次点击时，相应的色板都应该改变为随机颜色。现在，您已经准备好创建自定义EJSON对象了。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As mentioned, Meteor takes care of the serialization and deserialization for
    us. We just need to declare our object as an EJSON object. Proceed with the following
    steps to create a custom EJSON object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Meteor会为我们处理序列化和反序列化。我们只需要将我们的对象声明为EJSON对象。按照以下步骤创建自定义EJSON对象：
- en: 'Let''s add the `typeName` and `toJSONValue` functions. Open the `[project root]/both/swatch.js`
    file, and add the following two functions to the `Swatch.prototype` declaration,
    just below the `toString()` function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`typeName`和`toJSONValue`函数。打开`[项目根目录]/both/swatch.js`文件，并在`toString()`函数下方添加以下两个函数到`Swatch.prototype`声明中：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next we need to declare our object with `EJSON.addType`. In the same `swatch.js`
    file, at the very bottom, add the following function call:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`EJSON.addType`声明我们的对象。在同一个`swatch.js`文件中，在最底部添加以下函数调用：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''re now ready to use our EJSON object methods. Open the `[project root]/client/client.js`
    file, and make the following changes to `Template.colors.events`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的EJSON对象方法了。打开`[项目根目录]/client/client.js`文件，并对`Template.colors.events`进行以下更改：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the browser, add some new swatches and click on them with your browser console
    window open. The swatches will change colors, and they will tell you what their
    new colors are in the console. Your screen should look similar to the following
    screenshot:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器中，添加一些新的色板，并使用打开的浏览器控制台窗口点击它们。色板会改变颜色，并在控制台中显示它们的新颜色。您的屏幕应该类似于以下截图：
- en: '![How to do it…](img/image00422.jpeg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image00422.jpeg)'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When known `EJSON` objects are inserted into, or retrieved from MongoDB, Meteor
    automatically serializes and deserializes the objects using the `EJSON` library.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当已知的`EJSON`对象被插入到或从MongoDB检索时，Meteor会自动使用`EJSON`库对对象进行序列化和反序列化。
- en: To do this properly, the objects themselves have to have at least two methods.
    First, the object must have the `typeName` function, which aids in mapping the
    object to the declared `EJSON` object. Second, the object must have the `toJSONValue()`
    function, so that Meteor can properly serialize the object to a string/standard
    JSON value. Without the `toJSONValue()` function, MongoDB would choke on the object,
    and refuse to insert it. Transporting the object over DDP would be equally unfeasible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确完成这项任务，对象本身至少需要有两个方法。首先，对象必须有一个`typeName`函数，它有助于将对象映射到声明的`EJSON`对象。其次，对象必须有一个`toJSONValue()`函数，这样Meteor才能正确地将对象序列化为字符串/标准JSON值。如果没有`toJSONValue()`函数，MongoDB会对对象产生错误，并拒绝插入它。通过DDP传输对象同样不可行。
- en: The other action needed is to declare the `EJSON` object, which we did in `swatch.js`
    with the `EJSON.addType()` function. This function takes a `fromJSONValue()` function
    as an argument, which (exactly as it sounds) takes the JSON value passed over
    the wire and instantiates an actual object of the appropriate type. In our case,
    this was a `Swatch` object, and the only property needing to be created was the
    `color` property, which was passed in through the constructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的另一个操作是声明 `EJSON` 对象，我们在 `swatch.js` 中使用 `EJSON.addType()` 函数完成了这一操作。这个函数接受一个
    `fromJSONValue()` 函数作为参数，该函数（正如其名）接收通过线路传递的 JSON 值，并实例化一个适当类型的实际对象。在我们的例子中，这是一个
    `Swatch` 对象，唯一需要创建的属性是 `color` 属性，它通过构造函数传入。
- en: 'Once the previous methods are declared, and the `addType` function called,
    Meteor takes care of the rest for us, and stores our objects rather cleverly in
    MongoDB. As an example, here is what the raw JSON looks like for one of our serialized
    `Swatch` objects:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了前面的方法并调用了 `addType` 函数，Meteor 会为我们处理其余的事情，并将我们的对象巧妙地存储在 MongoDB 中。以下是一个示例，展示了我们序列化的
    `Swatch` 对象的原始 JSON：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `EJSON` object has other helper functions that you can declare in an object
    to aid in the development and use of `EJSON` objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`EJSON` 对象还有其他辅助函数，您可以在一个对象中声明这些函数，以帮助开发和使用 `EJSON` 对象。'
- en: The `.clone()` method can be implemented on an `EJSON` object to perform a deep
    copy with logic. If you don't declare the `.clone()` function, Meteor uses `toJSONValue()`
    instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `EJSON` 对象上实现 `.clone()` 方法，以执行具有逻辑的深度复制。如果你没有声明 `.clone()` 函数，Meteor 将使用
    `toJSONValue()` 代替。
- en: The `.equals()` method takes another object as a parameter and performs a custom
    comparison of your choosing. If you don't declare the `.equals()` function, Meteor
    simply takes both objects, performs a `toJSONValue()` transformation on each,
    and compares the result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`.equals()` 方法接受另一个对象作为参数，并执行你选择的自定义比较。如果你没有声明 `.equals()` 函数，Meteor 将简单地取两个对象，对每个对象执行
    `toJSONValue()` 转换，并比较结果。'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Learn more about the EJSON library by viewing the Meteor documentation, found
    here: [https://www.meteor.com/ejson](https://www.meteor.com/ejson).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 Meteor 文档了解更多关于 EJSON 库的信息，文档地址为：[https://www.meteor.com/ejson](https://www.meteor.com/ejson)。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Building* *custom server methods* recipe in this chapter
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *构建* *自定义服务器方法* 的配方
- en: Handling asynchronous events
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步事件
- en: Meteor is a reactive framework. As you've probably noticed, it's built on top
    of `Node.js`, but when writing or using packages, it somehow magically avoids
    all of the callback and event loop drama you'd normally face with `Node.js`. Meteor
    lets you code in a declarative, synchronous-like style. This recipe will show
    you one of the ways Meteor does this, and how you can handle asynchronous events
    coming in from a third-party package. In this case, we will read an incoming Twitter
    stream from the npm `twit` package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 是一个响应式框架。正如你可能注意到的，它建立在 `Node.js` 之上，但在编写或使用包时，它神奇地避免了你通常在 `Node.js`
    中遇到的回调和事件循环的戏剧性。Meteor 允许你以声明式、类似同步的风格进行编码。这个配方将向你展示 Meteor 是如何做到这一点的，以及你如何处理来自第三方包的异步事件。在这种情况下，我们将从
    npm 的 `twit` 包中读取 Twitter 流。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to quickly set up a test application on Twitter and load the npm `twit`
    module, so we'll do that here, so as not to distract from the recipe itself. Note
    that you can use any asynchronous event stream you would like for this recipe,
    including the standard `setInterval()` method, which could be used to mimic an
    asynchronous event stream.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要快速在 Twitter 上设置一个测试应用并加载 npm 的 `twit` 模块，所以我们在这里做，以免分散对配方本身的注意力。请注意，你可以为这个配方使用任何你想要的异步事件流，包括标准的
    `setInterval()` 方法，它可以用来模拟异步事件流。
- en: Creating a baseline Meteor app
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基线 Meteor 应用
- en: 'Open a terminal window, navigate to where you would like your project to reside,
    and enter the following commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到你希望项目所在的位置，并输入以下命令：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of starting Meteor like usual, this will instead create a file called
    `[project root]/packages.json`. Open that file in an editor and add the following
    declaration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常启动 Meteor 不同，这将创建一个名为 `[项目根]/packages.json` 的文件。在编辑器中打开该文件，并添加以下声明：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save your changes, and in the terminal, run the `meteor` command again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改，然后在终端中再次运行 `meteor` 命令：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Obtaining your Twitter Access Tokens
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取你的 Twitter 访问令牌
- en: Use a browser to log in to [http://twitter.com](http://twitter.com), and then
    navigate to [https://apps.twitter.com](https://apps.twitter.com). Create a new
    app, following the instructions, and click on the **Keys and Access Tokens** tab
    to obtain your Consumer Key + Secret and a valid Access Token + Secret found on
    that page. *Keep this page open*, as we will need to reference it a bit later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器登录到[http://twitter.com](http://twitter.com)，然后导航到[https://apps.twitter.com](https://apps.twitter.com)。按照说明创建一个新的应用，点击**密钥和访问令牌**标签以获取您的消费者密钥
    + 秘密以及在该页面上找到的有效访问令牌 + 秘密。*请保持此页面打开*，因为我们稍后会需要参考它。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For Meteor-specific instructions on setting up a Twitter App, please see the
    *Implementing OAuth accounts packages* recipe, found in [Chapter 10](part0079.xhtml#aid-2BASE1
    "Chapter 10. Working with Accounts"), *Working with Accounts.*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置Twitter应用的Meteor特定说明，请参阅[第10章](part0079.xhtml#aid-2BASE1 "第10章。处理账户")中的*实现OAuth账户包*配方，*处理账户*。
- en: Initializing twit
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化twit
- en: 'Create a file named `[project root]/server/config-twit.js` and add the following
    code, replacing the `consumer_key`, `consumer_secret`, `access_token`, and `access_token_secret`
    with the information you obtained previously. When completed, your file should
    look similar to the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`[项目根]/server/config-twit.js`的文件，并添加以下代码，用之前获得的信息替换`consumer_key`、`consumer_secret`、`access_token`和`access_token_secret`。完成后，您的文件应类似于以下代码：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating the Tweets collection, and building a stream reader
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建推文集合，并构建流读取器
- en: 'Create a file named `[project root]/both/model.js` and add the following line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`[项目根]/both/model.js`的文件，并添加以下行：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, create a file named `[project root]/server/twitter-stream.js` and add
    the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`[项目根]/server/twitter-stream.js`的文件，并添加以下代码：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tracking and testing changes
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪和测试更改
- en: 'Create a file named `[project root]/client/consoleTracking.js` and add the
    following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`[项目根]/client/consoleTracking.js`的文件，并添加以下代码：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, navigate in a browser to `http://localhost:3000`, open the console window,
    and enter the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中导航到`http://localhost:3000`，打开控制台窗口，并输入以下命令：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In your terminal window where you started Meteor with the `meteor` command,
    you should periodically see some JSON-formatted tweets. If tweets aren't showing
    up, it may be that the query you used isn't popular enough (this is a live Twitter
    feed!), so you can select something else, like *lmao* or *lebron*, if you want
    to see a steady stream.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用`meteor`命令启动Meteor的终端窗口中，您应该定期看到一些JSON格式的推文。如果推文没有显示，可能是因为您使用的查询不够流行（这是一个实时Twitter流！），因此您可以选择其他内容，如*lmao*或*lebron*，如果您想看到稳定的流。
- en: 'Lastly, you will want to test the `Tweets` collection tracking. In the browser
    console, enter the following command, and run it multiple times:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将想要测试`Tweets`集合的跟踪。在浏览器控制台中输入以下命令，并多次运行它：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If everything is set up properly, you will see a growing table of entries in
    your console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您将在控制台中看到不断增长的条目表。
- en: 'To turn off the Twitter feed and to clear out the `Tweets` collection, enter
    the following in the browser console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭Twitter流并清除`Tweets`集合，请在浏览器控制台中输入以下内容：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With everything all cleaned up, let's proceed to the recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切清理完毕后，让我们继续到配方。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe concentrates on only one thing: handling asynchronous events synchronously.
    As such, there are one two very simple steps as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方专注于仅处理异步事件同步。因此，以下有两个非常简单的步骤：
- en: 'Open `[project root]/server/twitter-stream.js`, and add the following `insert`
    statement to the `stream.on` handler, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`[项目根]/server/twitter-stream.js`，并在`stream.on`处理器中添加以下`insert`语句，如下所示：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because the event handler is an asynchronous event, if you try turning the
    stream on as-is, you will get a very nasty error stating the following:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为事件处理器是异步事件，如果您直接尝试打开流，您将得到一个非常糟糕的错误，如下所示：
- en: '[PRE32]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify the `stream.on` handler as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`stream.on`处理器：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can now turn on the stream in the browser console, as follows:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在可以在浏览器控制台中打开流，如下所示：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As entries come in from the stream, they will populate in the Tweets collection,
    and you will see the results in your browser console, similar to the following:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着从流中进入的条目，它们将在推文集合中填充，您将在浏览器控制台中看到类似以下的结果：
- en: '![How to do it…](img/image00423.jpeg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00423.jpeg)'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To accomplish the declarative, reactive environment we've come to know and love,
    the Meteor server intentionally runs on a single thread per request. Therefore,
    when you create some type of asynchronous action, such as listening to a `Node.js`
    event stream, the callback (handler) for that asynchronous action operates on
    a different thread. When the callback is fired, if you try to call Meteor functions
    (like `Tweets.insert()` for example ), Meteor will throw an error, because the
    callback and the main Meteor server are on different threads. In addition, if
    you used any global variables with values, you can't guarantee that those values
    have remained the same while the asynchronous call was waiting. Some other operation
    could have changed the environment!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们熟悉并喜爱的声明式、响应式环境，Meteor 服务器故意在每个请求上运行单个线程。因此，当你创建某种异步操作，例如监听 `Node.js`
    事件流时，该异步操作的回调（处理程序）在另一个线程上操作。当回调被触发时，如果你尝试调用 Meteor 函数（例如 `Tweets.insert()`），Meteor
    将抛出错误，因为回调和主 Meteor 服务器在不同的线程上。此外，如果你使用了任何具有值的全局变量，你无法保证在异步调用等待期间这些值保持不变。其他操作可能会改变环境！
- en: Meteor has an elegant way of dealing with this situation, using `Meteor.bindEnvironment()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 有一种优雅的方式来处理这种情况，使用 `Meteor.bindEnvironment()`。
- en: By wrapping the callback function with `Meteor.bindEnvironment()`, a *Fiber*
    is created. The Fiber keeps track of the variables and their values (the environment),
    and knows that sooner or later the callback is going to be called.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Meteor.bindEnvironment()` 封装回调函数，创建了一个 *Fiber*。Fiber 跟踪变量及其值（环境），并知道迟早会调用回调。
- en: In the meantime, the Fiber removes the operation from the event loop, so that
    the operation isn't blocking any other operations. Once the callback is ready,
    the Fiber puts the operation back into the event loop, restores the environment,
    and the operation completes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Fiber 将操作从事件循环中移除，以便操作不会阻塞其他操作。一旦回调就绪，Fiber 将操作放回事件循环，恢复环境，并完成操作。
- en: In this particular case, when we use `Meteor.call('TwitterStream',…)` we are
    sending a request to the Meteor server on a single thread. The `Twit.stream` service
    is started on that thread but the events (the incoming stream) are asynchronous.
    By wrapping the handler for `stream.on()` with `Meteor.bindEnvironment()`, we
    are instructing Meteor to "take a snapshot" of the current environment. Meteor
    then takes the current operation out of the event loop so that other things can
    get through. Then, we wait.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，当我们使用 `Meteor.call('TwitterStream',…)` 时，我们是在单个线程上向 Meteor 服务器发送请求。`Twit.stream`
    服务在该线程上启动，但事件（传入的流）是异步的。通过使用 `Meteor.bindEnvironment()` 封装 `stream.on()` 的处理程序，我们指示
    Meteor “拍摄”当前环境的快照。然后，Meteor 将当前操作从事件循环中取出，以便其他事情可以通过。然后，我们等待。
- en: When the stream has new data, the event fires, which triggers the callback.
    Meteor (or more accurately, the Fiber) sees that the callback is ready, restores
    the environment from the snapshot created using `Meteor.bindEnvironment()`, and
    puts the operation back on the event loop. This process happens again and again,
    as many times as needed, whenever a new Tweet comes in and triggers the callback
    function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当流有新数据时，事件被触发，这会触发回调。Meteor（或更准确地说，Fiber）看到回调已就绪，从使用 `Meteor.bindEnvironment()`
    创建的快照中恢复环境，并将操作放回事件循环。这个过程会重复进行，直到需要多少次就重复多少次，每次有新的推文到来并触发回调函数时。
- en: At the risk of oversimplifying, `Meteor.bindEnvironment()` wraps some code into
    the Fiber and then waits, without blocking any other code operations. Once the
    wrapped code is ready/activated, the Fiber makes sure that the code is executed
    on the correct thread with the correct data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以简化的风险，`Meteor.bindEnvironment()` 将一些代码封装到 Fiber 中，然后等待，而不阻塞任何其他代码操作。一旦封装的代码准备就绪/激活，Fiber
    确保代码在正确的线程上以正确的数据执行。
- en: There's more…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: We can be very granular about what code is wrapped, and we can separate out
    wrapped code, to make the overall code easier to read.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常细致地控制要封装的代码，并且可以将封装的代码分离出来，使整体代码更容易阅读。
- en: 'Add the following function to the top of the `twitter-stream.js` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到 `twitter-stream.js` 文件的顶部：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, revert `stream.on` by removing the `Meteor.bindEnvironment()` wrapping,
    and call `wrappedInsert()` instead of `Tweets.insert()`, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过移除 `stream.on` 的 `Meteor.bindEnvironment()` 封装，并调用 `wrappedInsert()` 而不是
    `Tweets.insert()`，如下所示：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will operate exactly the same as wrapping the entire callback function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全与封装整个回调函数的方式相同。
- en: 'One last alternative, we could take the entire callback out, wrap it with a
    user-friendly name, and use that name in the callback section, as shown in the
    following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种选择，我们可以移除整个回调，用用户友好的名称包装它，并在回调部分使用该名称，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The most concise explanation of Fibers, Futures, and `Meteor.bindEnvironment()`
    can be found here: [http://bit.ly/meteor-fibers-explained](http://bit.ly/meteor-fibers-explained).
    Make sure to thoroughly review all the links from that page!'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Fibers、Futures和`Meteor.bindEnvironment()`的最简洁解释可以在以下链接找到：[http://bit.ly/meteor-fibers-explained](http://bit.ly/meteor-fibers-explained)。请务必仔细查看该页面的所有链接！
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Implementing OAuth accounts packages* recipe in [Chapter 10](part0079.xhtml#aid-2BASE1
    "Chapter 10. Working with Accounts"), *Working with Accounts*
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第10章（[part0079.xhtml#aid-2BASE1 "第10章。使用账户"】）的*实现OAuth账户包*食谱中，*使用账户*
- en: Using asynchronous functions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步函数
- en: '`Node.js`, for all its awesomeness, has a flaw: callbacks. Being asynchronous
    and non-blocking has a ton of advantages, and we can''t imagine life without it.
    But, wouldn''t it be great if there were a way to avoid the "callback hell" by
    writing our code in a synchronous style but still reaping the benefits of asynchronous
    code? As you might have guessed, Meteor has a way of doing just that. This recipe
    will show you how to write and handle asynchronous functions in a synchronous
    style using `Meteor.wrapAsync()`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.js` 尽管非常出色，但有一个缺陷：回调。异步和非阻塞有许多优点，我们无法想象没有它的生活。但是，如果有一种方法可以避免“回调地狱”，通过以同步风格编写我们的代码，但仍然获得异步代码的好处，那岂不是很好？正如您可能已经猜到的，Meteor有实现这一点的办法。这个食谱将向您展示如何使用
    `Meteor.wrapAsync()` 以同步风格编写和处理异步函数。'
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Because brevity breeds clarity, we will keep this recipe as simple as possible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简洁性可以带来清晰性，我们将尽可能简化这个食谱。
- en: 'Open a terminal window, navigate to where you would like your project to reside,
    and enter the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到您希望项目存放的位置，并输入以下命令：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We are going to simulate a delayed call to an asynchronous method, using the
    standard JavaScript `setTimeout()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准的JavaScript `setTimeout()` 函数来模拟对异步方法的延迟调用。
- en: 'First, let''s prep for the server call. Open `[project root]/wrap-sample.js`
    and modify the `Template.hello.events` function, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为服务器调用做准备。打开 `[项目根]/wrap-sample.js` 并修改 `Template.hello.events` 函数，如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a file named `[project root]/server/method.js` and add the following
    asynchronous function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `[项目根]/server/method.js` 的文件，并添加以下异步函数：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, add a simple `Meteor.methods` declaration, using `Meteor.wrapAsync()`
    to write synchronous-style code, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个简单的 `Meteor.methods` 声明，使用 `Meteor.wrapAsync()` 来编写同步风格的代码，如下所示：
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open a browser to `http://localhost:3000`, open the browser console, and click
    the button on the screen. As you look at the server terminal, you will immediately
    see five log entries, printed in consecutive order, similar to the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个浏览器到 `http://localhost:3000`，打开浏览器控制台，并点击屏幕上的按钮。当您查看服务器终端时，您将立即看到五个日志条目，按顺序打印，类似于以下内容：
- en: '[PRE42]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the Browser window, you will see five log entries. These entries, however,
    will not be immediate, and will likely be out of order, similar to the following
    example:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，您将看到五个日志条目。然而，这些条目不会立即出现，并且可能顺序混乱，类似于以下示例：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Click the button again, and notice the random order and time of completion for
    each of the five server calls.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击按钮，注意五个服务器调用的随机顺序和完成时间。
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`Meteor.wrapAsync()` is a bit of syntactic sugar for running asynchronous calls
    as if they were synchronous. As discussed in the *Handling asynchronous events*
    recipe from this chapter, Fibers and Futures are the way that Meteor handles asynchronous
    logic. In this case, we are dealing with what would be considered a *standard
    asynchronous function* in `Node.js`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meteor.wrapAsync()` 是一种语法糖，用于将异步调用运行得像同步调用一样。正如本章中讨论的*处理异步事件*食谱所示，Fibers和Futures是Meteor处理异步逻辑的方式。在这种情况下，我们正在处理在`Node.js`中会被认为是*标准异步函数*的函数。'
- en: 'Meteor defines a standard asynchronous function as a function as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor定义的标准异步函数如下：
- en: Takes a callback as the last argument
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将回调作为最后一个参数
- en: Is non-blocking
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是非阻塞的
- en: Executes the callback upon completion
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成时执行回调
- en: The signature of the callback passed in is always the same. There are two arguments,
    the first of which is an `error` object. If there is an `error`, this object will
    have a value, otherwise, the `error` argument will be `null`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传入回调函数的签名总是相同的。有两个参数，第一个是一个 `error` 对象。如果有错误，这个对象将有一个值，否则，`error` 参数将是 `null`。
- en: The second argument is a `data` object. If the call does not return an `error`
    object as its first parameter, this data argument will have data in it that can
    be used by the callback function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个 `data` 对象。如果调用不返回一个错误对象作为其第一个参数，这个数据参数将包含可以被回调函数使用的数据。
- en: 'In our case, we declared a standard asynchronous function named `asyncCall()`.
    The signature of `asyncCall()` looks as shown in the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们声明了一个名为 `asyncCall()` 的标准异步函数。`asyncCall()` 的签名如下所示：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Nothing in `asyncCall()` will block the event loop, even though we're making
    a call to `setInterval()`. The `setInterval()` call is asynchronous, and is therefore
    non-blocking (very much like an ajax call, or a file i/o operation, etc). Once
    `setInterval()` is complete, it invokes our callback, `cb(null , query + '...')`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `asyncCall()` 中没有任何操作会阻塞事件循环，尽管我们调用了 `setInterval()`。`setInterval()` 调用是异步的，因此是非阻塞的（非常类似于
    AJAX 调用或文件 I/O 操作等）。一旦 `setInterval()` 完成，它将调用我们的回调函数 `cb(null, query + '...')`。
- en: In the `Meteor.methods` declaration, we created a method named `someCall`. Inside
    of `someCall`, we first make sure it won't clog up the event loop by calling `this.unblock()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Meteor.methods` 声明中，我们创建了一个名为 `someCall` 的方法。在 `someCall` 内部，我们首先通过调用 `this.unblock()`
    确保不会阻塞事件循环。
- en: We then take our standard asynchronous function (as defined previously) and
    we wrap it with the `Meteor.wrapAsync(asyncCall)` command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `Meteor.wrapAsync(asyncCall)` 命令将我们的标准异步函数（如前所述）进行封装。
- en: 'Once wrapped, we can use the wrapped call as if it were synchronous. It''s
    not. There will be a delay in the result, but our operation will wait until the
    asynchronous call is complete, which allows us to better understand what is happening.
    If we look at the lines of code after `Meteor.wrapAsync()`, we can easily wrap
    our heads around what is happening:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦封装，我们就可以像同步调用一样使用封装后的调用。实际上它不是同步的。结果会有延迟，但我们的操作将等待异步调用完成，这使我们能够更好地理解正在发生的事情。如果我们查看
    `Meteor.wrapAsync()` 之后的代码行，我们可以轻松地理解正在发生的情况：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `result` variable is being assigned to the result of the call. We then return
    `result` like we would in a synchronous function. Easy peasy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 变量被分配给调用结果。然后我们像在同步函数中一样返回 `result`。简单易懂。'
- en: There's more…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The rule for using `Meteor.wrapAsync()` can be stated this way: any time you
    have a standard asynchronous function, where you would normally have to nest your
    logic in the callback, you can instead wrap the function and use the result as
    if it were a synchronous call.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Meteor.wrapAsync()` 的规则可以这样表述：任何你原本需要将逻辑嵌套在回调中的标准异步函数，你都可以将其封装，并像同步调用一样使用其结果。
- en: Under the hood, Meteor is wrapping a Fiber/Future and automatically implementing
    the `.current`, `.yield()`, `.run()`, and `.wait()` pieces for you. But don't
    worry about that. If you just stick with the idea that `.wrapAsync()` is turning
    asynchronous functions with callbacks into standard functions without callbacks,
    you'll be well on your way to writing elegant, declarative code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Meteor 正在封装 Fiber/Future 并自动实现 `.current`、`.yield()`、`.run()` 和 `.wait()`
    这些功能供你使用。但无需担心这一点。只要你坚持认为 `.wrapAsync()` 将带有回调的异步函数转换成不带回调的标准函数，你就能顺利地写出优雅、声明式的代码。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Handling* *asynchronous events* recipe in this chapter
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于 *处理异步事件* 的配方
