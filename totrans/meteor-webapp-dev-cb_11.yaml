- en: Chapter 11. Leveraging Advanced Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building custom server methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom EJSON objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling asynchronous events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some unique functions Meteor offers that make our lives in a full-stack
    development environment even easier. This chapter will go into these lesser-advertised
    areas of functionality, providing you with even more under the hood knowledge
    to make your applications elegant and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom server methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of communications we perform between the client and server in Meteor
    is done via DDP. There are times, however, where direct server calls can come
    in very handy. For example, while you're testing, or as an admin, you may create
    some `'hidden'` helper methods to make debugging easier. In other instances, you
    may want to make very secure or very simple methods available to reduce the vulnerability
    or complexity of your code. In any case, server methods are a staple of development,
    and this recipe will walk you through creating and using server-side methods,
    using the `Meteor.methods()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create server methods, we first need a basic application. We'll quickly create
    a color swatch app. Nothing fancy, but once we're done, we will be able to create
    server methods with good visual feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need Meteor installed, and have a project created. In a terminal window,
    create your root project by entering the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a simple app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `[project root]/both/helpers.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file named `[project root]/client/client.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create some simple styling by creating a file named `[project root]/client/styles.css`
    with the following style declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create your templates by creating `[project root]/client/main.html`
    and adding the following templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all your changes, navigate to `http://localhost:3000` in a browser, and
    click the button with the plus sign on it repeatedly to add random color swatches.
    You should see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple app](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You are now ready to create some helper server methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create two server methods. One to clear the `Swatches` collection, and
    one that adds only unique colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build the `clearSwatches()` function. Create a file named `[project
    root]/server/methods.js` and add the following `Meteor.methods` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your browser console, enter the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All your color swatches should disappear. Don't fret, friend, you can always
    create more swatches by clicking the button on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s create the `addUniqueSwatches()` function. Open `methods.js` from
    the preceding step and add the following declaration just after the `clearSwatches`
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `[project root]/client/client.js`, and make the following change
    to the `Template.body.events` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as you click on the button to add colors, you will find that, eventually,
    no new swatches will be added. This is because the total number of unique colors
    is 27\. If you start with no swatches, your screen will eventually look similar
    to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image00421.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You won't be able to add more than the 27 colors, no matter how many times you
    click the button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created two calls on the server by creating code inside the `server` folder.
    These calls are exposed to the client because we declared them using the `Meteor.methods()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `clearSwatches()` method we created in the `methods.js` file is *hidden*,
    in that, unless you know it's there, there's no easy way to know that it exists.
    The `addUniqueSwatch()` method is used inside of the `onclick` event for our button,
    so someone could discover it by looking at our client code.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the methods are not called through an Ajax/traditional server
    call, but are instead automatically exposed by Meteor, and , very easy to invoke
    via the `Meteor.call()` method, which accepts the name of the method as the first
    parameter, and any additional parameters, as method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you pass a callback function as the last argument in `Meteor.call()`, the
    callback will be automatically invoked when the server method has completed execution.
    You can use this to perform actions after the call is complete. The following
    is an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `[project root]/server/methods.js` and make the following changes to `addUniqueSwatch()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your browser console, quickly reset the `Swatches` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make the following manual call to `addUniqueSwatch()` multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each time you run that command, the console will print out the total number
    of swatches. Meteor is auto-running the callback you passed, populating the data
    parameter with the results from the `addUniqueSwitch()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the web console* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Optimizing
    Your Workflow"), *Optimizing Your Workflow*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding Meteor packages* recipe in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Customizing with Packages"), *Customizing with Packages*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom EJSON objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's pretty easy to pass simple objects between the client and the server using
    DDP. But did you know that you can pass custom, named objects complete with methods?
    The folks at Meteor have extended JSON to allow customized, complete objects to
    be passed over DDP, without you having to worry about serialization/deserialization.
    This recipe will teach you how to create and use custom EJSON objects, and pass
    those custom objects between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the previous recipe found in this chapter, *Building custom
    server methods*, as a baseline. Please complete that recipe, and then make the
    following modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Swatch object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new file named `[project root]/both/swatch.js` and add the following
    code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Modifying Swatches.insert()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In preparation for using EJSON objects, which are not the normal, plain objects
    MongoDB expects, we need to layer our objects by one level when inserting. In
    the web console, execute the following line to clear out the `Swatches` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `[project root]/server/methods.js` and modify the `Swatches.insert()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Changing Swatch colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The layering on insert will break our UI a bit, but that''s okay, we can recover
    because we''re awesome. Inside the `[project root]/client/client.js` file, in
    the `Template.colors.helpers` section, and just below the `swatches` helper, add
    the following helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s add the following `events` declaration, so that we can change
    the color of our swatches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save your changes, and test in a browser by clicking on any of the added swatches.
    The corresponding swatch should change to a random color each time you click.
    You are now ready to proceed with creating custom EJSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, Meteor takes care of the serialization and deserialization for
    us. We just need to declare our object as an EJSON object. Proceed with the following
    steps to create a custom EJSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `typeName` and `toJSONValue` functions. Open the `[project root]/both/swatch.js`
    file, and add the following two functions to the `Swatch.prototype` declaration,
    just below the `toString()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we need to declare our object with `EJSON.addType`. In the same `swatch.js`
    file, at the very bottom, add the following function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re now ready to use our EJSON object methods. Open the `[project root]/client/client.js`
    file, and make the following changes to `Template.colors.events`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the browser, add some new swatches and click on them with your browser console
    window open. The swatches will change colors, and they will tell you what their
    new colors are in the console. Your screen should look similar to the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00422.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When known `EJSON` objects are inserted into, or retrieved from MongoDB, Meteor
    automatically serializes and deserializes the objects using the `EJSON` library.
  prefs: []
  type: TYPE_NORMAL
- en: To do this properly, the objects themselves have to have at least two methods.
    First, the object must have the `typeName` function, which aids in mapping the
    object to the declared `EJSON` object. Second, the object must have the `toJSONValue()`
    function, so that Meteor can properly serialize the object to a string/standard
    JSON value. Without the `toJSONValue()` function, MongoDB would choke on the object,
    and refuse to insert it. Transporting the object over DDP would be equally unfeasible.
  prefs: []
  type: TYPE_NORMAL
- en: The other action needed is to declare the `EJSON` object, which we did in `swatch.js`
    with the `EJSON.addType()` function. This function takes a `fromJSONValue()` function
    as an argument, which (exactly as it sounds) takes the JSON value passed over
    the wire and instantiates an actual object of the appropriate type. In our case,
    this was a `Swatch` object, and the only property needing to be created was the
    `color` property, which was passed in through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the previous methods are declared, and the `addType` function called,
    Meteor takes care of the rest for us, and stores our objects rather cleverly in
    MongoDB. As an example, here is what the raw JSON looks like for one of our serialized
    `Swatch` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EJSON` object has other helper functions that you can declare in an object
    to aid in the development and use of `EJSON` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `.clone()` method can be implemented on an `EJSON` object to perform a deep
    copy with logic. If you don't declare the `.clone()` function, Meteor uses `toJSONValue()`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `.equals()` method takes another object as a parameter and performs a custom
    comparison of your choosing. If you don't declare the `.equals()` function, Meteor
    simply takes both objects, performs a `toJSONValue()` transformation on each,
    and compares the result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn more about the EJSON library by viewing the Meteor documentation, found
    here: [https://www.meteor.com/ejson](https://www.meteor.com/ejson).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building* *custom server methods* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling asynchronous events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meteor is a reactive framework. As you've probably noticed, it's built on top
    of `Node.js`, but when writing or using packages, it somehow magically avoids
    all of the callback and event loop drama you'd normally face with `Node.js`. Meteor
    lets you code in a declarative, synchronous-like style. This recipe will show
    you one of the ways Meteor does this, and how you can handle asynchronous events
    coming in from a third-party package. In this case, we will read an incoming Twitter
    stream from the npm `twit` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to quickly set up a test application on Twitter and load the npm `twit`
    module, so we'll do that here, so as not to distract from the recipe itself. Note
    that you can use any asynchronous event stream you would like for this recipe,
    including the standard `setInterval()` method, which could be used to mimic an
    asynchronous event stream.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a baseline Meteor app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open a terminal window, navigate to where you would like your project to reside,
    and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of starting Meteor like usual, this will instead create a file called
    `[project root]/packages.json`. Open that file in an editor and add the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your changes, and in the terminal, run the `meteor` command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining your Twitter Access Tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use a browser to log in to [http://twitter.com](http://twitter.com), and then
    navigate to [https://apps.twitter.com](https://apps.twitter.com). Create a new
    app, following the instructions, and click on the **Keys and Access Tokens** tab
    to obtain your Consumer Key + Secret and a valid Access Token + Secret found on
    that page. *Keep this page open*, as we will need to reference it a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Meteor-specific instructions on setting up a Twitter App, please see the
    *Implementing OAuth accounts packages* recipe, found in [Chapter 10](part0079.xhtml#aid-2BASE1
    "Chapter 10. Working with Accounts"), *Working with Accounts.*
  prefs: []
  type: TYPE_NORMAL
- en: Initializing twit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `[project root]/server/config-twit.js` and add the following
    code, replacing the `consumer_key`, `consumer_secret`, `access_token`, and `access_token_secret`
    with the information you obtained previously. When completed, your file should
    look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Tweets collection, and building a stream reader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `[project root]/both/model.js` and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a file named `[project root]/server/twitter-stream.js` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tracking and testing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `[project root]/client/consoleTracking.js` and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, navigate in a browser to `http://localhost:3000`, open the console window,
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In your terminal window where you started Meteor with the `meteor` command,
    you should periodically see some JSON-formatted tweets. If tweets aren't showing
    up, it may be that the query you used isn't popular enough (this is a live Twitter
    feed!), so you can select something else, like *lmao* or *lebron*, if you want
    to see a steady stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you will want to test the `Tweets` collection tracking. In the browser
    console, enter the following command, and run it multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If everything is set up properly, you will see a growing table of entries in
    your console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn off the Twitter feed and to clear out the `Tweets` collection, enter
    the following in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With everything all cleaned up, let's proceed to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe concentrates on only one thing: handling asynchronous events synchronously.
    As such, there are one two very simple steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `[project root]/server/twitter-stream.js`, and add the following `insert`
    statement to the `stream.on` handler, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the event handler is an asynchronous event, if you try turning the
    stream on as-is, you will get a very nasty error stating the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `stream.on` handler as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now turn on the stream in the browser console, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As entries come in from the stream, they will populate in the Tweets collection,
    and you will see the results in your browser console, similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00423.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To accomplish the declarative, reactive environment we've come to know and love,
    the Meteor server intentionally runs on a single thread per request. Therefore,
    when you create some type of asynchronous action, such as listening to a `Node.js`
    event stream, the callback (handler) for that asynchronous action operates on
    a different thread. When the callback is fired, if you try to call Meteor functions
    (like `Tweets.insert()` for example ), Meteor will throw an error, because the
    callback and the main Meteor server are on different threads. In addition, if
    you used any global variables with values, you can't guarantee that those values
    have remained the same while the asynchronous call was waiting. Some other operation
    could have changed the environment!
  prefs: []
  type: TYPE_NORMAL
- en: Meteor has an elegant way of dealing with this situation, using `Meteor.bindEnvironment()`.
  prefs: []
  type: TYPE_NORMAL
- en: By wrapping the callback function with `Meteor.bindEnvironment()`, a *Fiber*
    is created. The Fiber keeps track of the variables and their values (the environment),
    and knows that sooner or later the callback is going to be called.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, the Fiber removes the operation from the event loop, so that
    the operation isn't blocking any other operations. Once the callback is ready,
    the Fiber puts the operation back into the event loop, restores the environment,
    and the operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, when we use `Meteor.call('TwitterStream',…)` we are
    sending a request to the Meteor server on a single thread. The `Twit.stream` service
    is started on that thread but the events (the incoming stream) are asynchronous.
    By wrapping the handler for `stream.on()` with `Meteor.bindEnvironment()`, we
    are instructing Meteor to "take a snapshot" of the current environment. Meteor
    then takes the current operation out of the event loop so that other things can
    get through. Then, we wait.
  prefs: []
  type: TYPE_NORMAL
- en: When the stream has new data, the event fires, which triggers the callback.
    Meteor (or more accurately, the Fiber) sees that the callback is ready, restores
    the environment from the snapshot created using `Meteor.bindEnvironment()`, and
    puts the operation back on the event loop. This process happens again and again,
    as many times as needed, whenever a new Tweet comes in and triggers the callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: At the risk of oversimplifying, `Meteor.bindEnvironment()` wraps some code into
    the Fiber and then waits, without blocking any other code operations. Once the
    wrapped code is ready/activated, the Fiber makes sure that the code is executed
    on the correct thread with the correct data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can be very granular about what code is wrapped, and we can separate out
    wrapped code, to make the overall code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to the top of the `twitter-stream.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, revert `stream.on` by removing the `Meteor.bindEnvironment()` wrapping,
    and call `wrappedInsert()` instead of `Tweets.insert()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will operate exactly the same as wrapping the entire callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last alternative, we could take the entire callback out, wrap it with a
    user-friendly name, and use that name in the callback section, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most concise explanation of Fibers, Futures, and `Meteor.bindEnvironment()`
    can be found here: [http://bit.ly/meteor-fibers-explained](http://bit.ly/meteor-fibers-explained).
    Make sure to thoroughly review all the links from that page!'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing OAuth accounts packages* recipe in [Chapter 10](part0079.xhtml#aid-2BASE1
    "Chapter 10. Working with Accounts"), *Working with Accounts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Node.js`, for all its awesomeness, has a flaw: callbacks. Being asynchronous
    and non-blocking has a ton of advantages, and we can''t imagine life without it.
    But, wouldn''t it be great if there were a way to avoid the "callback hell" by
    writing our code in a synchronous style but still reaping the benefits of asynchronous
    code? As you might have guessed, Meteor has a way of doing just that. This recipe
    will show you how to write and handle asynchronous functions in a synchronous
    style using `Meteor.wrapAsync()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because brevity breeds clarity, we will keep this recipe as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window, navigate to where you would like your project to reside,
    and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to simulate a delayed call to an asynchronous method, using the
    standard JavaScript `setTimeout()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s prep for the server call. Open `[project root]/wrap-sample.js`
    and modify the `Template.hello.events` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `[project root]/server/method.js` and add the following
    asynchronous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a simple `Meteor.methods` declaration, using `Meteor.wrapAsync()`
    to write synchronous-style code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a browser to `http://localhost:3000`, open the browser console, and click
    the button on the screen. As you look at the server terminal, you will immediately
    see five log entries, printed in consecutive order, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the Browser window, you will see five log entries. These entries, however,
    will not be immediate, and will likely be out of order, similar to the following
    example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the button again, and notice the random order and time of completion for
    each of the five server calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Meteor.wrapAsync()` is a bit of syntactic sugar for running asynchronous calls
    as if they were synchronous. As discussed in the *Handling asynchronous events*
    recipe from this chapter, Fibers and Futures are the way that Meteor handles asynchronous
    logic. In this case, we are dealing with what would be considered a *standard
    asynchronous function* in `Node.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meteor defines a standard asynchronous function as a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a callback as the last argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is non-blocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executes the callback upon completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of the callback passed in is always the same. There are two arguments,
    the first of which is an `error` object. If there is an `error`, this object will
    have a value, otherwise, the `error` argument will be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a `data` object. If the call does not return an `error`
    object as its first parameter, this data argument will have data in it that can
    be used by the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we declared a standard asynchronous function named `asyncCall()`.
    The signature of `asyncCall()` looks as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Nothing in `asyncCall()` will block the event loop, even though we're making
    a call to `setInterval()`. The `setInterval()` call is asynchronous, and is therefore
    non-blocking (very much like an ajax call, or a file i/o operation, etc). Once
    `setInterval()` is complete, it invokes our callback, `cb(null , query + '...')`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Meteor.methods` declaration, we created a method named `someCall`. Inside
    of `someCall`, we first make sure it won't clog up the event loop by calling `this.unblock()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then take our standard asynchronous function (as defined previously) and
    we wrap it with the `Meteor.wrapAsync(asyncCall)` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once wrapped, we can use the wrapped call as if it were synchronous. It''s
    not. There will be a delay in the result, but our operation will wait until the
    asynchronous call is complete, which allows us to better understand what is happening.
    If we look at the lines of code after `Meteor.wrapAsync()`, we can easily wrap
    our heads around what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `result` variable is being assigned to the result of the call. We then return
    `result` like we would in a synchronous function. Easy peasy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rule for using `Meteor.wrapAsync()` can be stated this way: any time you
    have a standard asynchronous function, where you would normally have to nest your
    logic in the callback, you can instead wrap the function and use the result as
    if it were a synchronous call.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Meteor is wrapping a Fiber/Future and automatically implementing
    the `.current`, `.yield()`, `.run()`, and `.wait()` pieces for you. But don't
    worry about that. If you just stick with the idea that `.wrapAsync()` is turning
    asynchronous functions with callbacks into standard functions without callbacks,
    you'll be well on your way to writing elegant, declarative code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling* *asynchronous events* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
