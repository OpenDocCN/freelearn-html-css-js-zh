- en: Chapter 3. Writing a Blog Application with Node.js and AngularJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 Node.js 和 AngularJS 编写博客应用程序
- en: In this chapter, we are going to build a blog application by using Node.js and
    AngularJS. Our system will support adding, editing, and removing articles, so
    there will be a control panel. The MongoDB or MySQL database will handle the storing
    of the information and the Express framework will be used as the site base. It
    will deliver the JavaScript, CSS, and the HTML to the end user, and will provide
    an API to access the database. We will use AngularJS to build the user interface
    and control the client-side logic in the administration page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Node.js 和 AngularJS 构建一个博客应用程序。我们的系统将支持添加、编辑和删除文章，因此将有一个控制面板。MongoDB
    或 MySQL 数据库将处理信息的存储，Express 框架将用作网站的基础。它将向最终用户交付 JavaScript、CSS 和 HTML，并提供一个访问数据库的
    API。我们将使用 AngularJS 构建用户界面并控制管理页面上的客户端逻辑。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: AngularJS fundamentals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS 基础知识
- en: Choosing and initializing a database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和初始化数据库
- en: Implementing the client-side part of an application with AngularJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AngularJS 实现应用程序的客户端部分
- en: Exploring AngularJS
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 AngularJS
- en: '**AngularJS** is an open source, client-side JavaScript framework developed
    by Google. It''s full of features and is really well documented. It has almost
    become a standard framework in the development of single-page applications. The
    official site of AngularJS, [http://angularjs.org](http://angularjs.org), provides
    a well-structured documentation. As the framework is widely used, there is a lot
    of material in the form of articles and video tutorials. As a JavaScript library,
    it collaborates pretty well with Node.js. In this chapter, we will build a simple
    blog with a control panel.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**AngularJS** 是由 Google 开发的一个开源的客户端 JavaScript 框架。它功能丰富，文档齐全。它几乎已经成为单页应用程序开发的标准框架。AngularJS
    的官方网站 [http://angularjs.org](http://angularjs.org) 提供了结构良好的文档。由于该框架被广泛使用，因此有很多文章和视频教程形式的材料。作为一个
    JavaScript 库，它与 Node.js 协作得很好。在本章中，我们将构建一个带有控制面板的简单博客。'
- en: Before we start developing our application, let's first take a look at the framework.
    AngularJS gives us very good control over the data on our page. We don't have
    to think about selecting elements from the DOM and filling them with values. Thankfully,
    due to the available data-binding, we may update the data in the JavaScript part
    and see the change in the HTML part. This is also true for the reverse. Once we
    change something in the HTML part, we get the new values in the JavaScript part.
    The framework has a powerful dependency injector. There are predefined classes
    in order to perform AJAX requests and manage routes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发应用程序之前，让我们首先了解一下这个框架。AngularJS 让我们对页面上的数据有了非常好的控制。我们不必考虑从 DOM 中选择元素并填充它们的值。幸运的是，由于可用的数据绑定，我们可以在
    JavaScript 部分更新数据，并在 HTML 部分看到变化。反之亦然。一旦我们在 HTML 部分做了更改，我们就会在 JavaScript 部分得到新的值。该框架有一个强大的依赖注入器。有一些预定义的类用于执行
    AJAX 请求和管理路由。
- en: You could also read *Mastering Web Development with AngularJS* by Peter Bacon
    Darwin and Pawel Kozlowski, published by Packt Publishing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以阅读由 Peter Bacon Darwin 和 Pawel Kozlowski 编著，由 Packt Publishing 出版的《Mastering
    Web Development with AngularJS》。
- en: Bootstrapping AngularJS applications
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导 AngularJS 应用程序
- en: 'To bootstrap an AngularJS application, we need to add the `ng-app` attribute
    to some of our HTML tags. It is important that we pick the right one. Having `ng-app`
    somewhere means that all the child nodes will be processed by the framework. It''s
    common practice to put that attribute on the `<html>` tag. In the following code,
    we have a simple HTML page containing ng-app:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要引导一个 AngularJS 应用程序，我们需要将 `ng-app` 属性添加到我们的某些 HTML 标签中。选择正确的一个非常重要。如果某个地方有
    `ng-app`，这意味着所有子节点都将由框架处理。通常的做法是将该属性放在 `<html>` 标签上。在下面的代码中，我们有一个包含 ng-app 的简单
    HTML 页面：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Very often, we will apply a value to the attribute. This will be a module name.
    We will do this while developing the control panel of our blog application. Having
    the freedom to place `ng-app` wherever we want means that we can decide which
    part of our markup will be controlled by AngularJS. That's good, because if we
    have a giant HTML file, we really don't want to spend resources parsing the whole
    document. Of course, we may bootstrap our logic manually, and this is needed when
    we have more than one AngularJS application on the page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的是，我们会将一个值应用到属性上。这将是一个模块名称。我们会在开发我们的博客应用的控制面板时这样做。有自由将`ng-app`放置在我们想要的位置意味着我们可以决定我们的标记的哪一部分将由AngularJS控制。这是好的，因为如果我们有一个巨大的HTML文件，我们真的不想花费资源解析整个文档。当然，我们可能需要手动引导我们的逻辑，当我们页面上有多个AngularJS应用时，这是必要的。
- en: Using directives and controllers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指令和控制器
- en: 'In AngularJS, we can implement the Model-View-Controller pattern. The controller
    acts as glue between the data (model) and the user interface (view). In the context
    of the framework, the controller is just a simple function. For example, the following
    HTML code illustrates that a controller is just a simple function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，我们可以实现模型-视图-控制器（Model-View-Controller）模式。控制器作为数据（模型）和用户界面（视图）之间的粘合剂。在框架的上下文中，控制器只是一个简单的函数。例如，以下HTML代码说明了控制器只是一个简单的函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `<head>` of the page, we are adding the minified version of the library
    and `HeaderController.js`; a file that will host the code of our controller. We
    also set an `ng-controller` attribute in the HTML markup. The definition of the
    controller is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的`<head>`中，我们添加了库的精简版本和`HeaderController.js`；一个将包含我们控制器代码的文件。我们还在HTML标记中设置了`ng-controller`属性。控制器的定义如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every controller has its own area of influence. That area is called the scope.
    In our case, `HeaderController` defines the `{{title}}` variable. AngularJS has
    a wonderful dependency-injection system. Thankfully, due to this mechanism, the
    `$scope` argument is automatically initialized and passed to our function. The
    `ng-controller` attribute is called the directive, that is, an attribute, which
    has meaning to AngularJS. There are a lot of directives that we can use. That's
    maybe one of the strongest points of the framework. We can implement complex logic
    directly inside our templates, for example, data binding, filtering, or modularity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都有自己的影响区域。这个区域被称为作用域。在我们的例子中，`HeaderController`定义了`{{title}}`变量。AngularJS有一个出色的依赖注入系统。幸运的是，由于这个机制，`$scope`参数会自动初始化并传递给我们的函数。`ng-controller`属性被称为指令，即一个对AngularJS有意义的属性。我们可以使用很多指令。这可能是框架的强项之一。我们可以在模板中直接实现复杂逻辑，例如数据绑定、过滤或模块化。
- en: Data binding
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'Data binding is a process of automatically updating the view once the model
    is changed. As we mentioned earlier, we can change a variable in the JavaScript
    part of the application and the HTML part will be automatically updated. We don''t
    have to create a reference to a DOM element or attach event listeners. Everything
    is handled by the framework. Let''s continue and elaborate on the previous example,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是一个在模型更改后自动更新视图的过程。正如我们之前提到的，我们可以在应用程序的JavaScript部分更改一个变量，HTML部分将自动更新。我们不需要创建DOM元素的引用或附加事件监听器。一切由框架处理。让我们继续并详细说明之前的例子，如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A link is added and it contains the `ng-click` directive. The `updateTitle`
    function is a function defined in the controller, as seen in the following code
    snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个链接，并包含`ng-click`指令。`updateTitle`函数是在控制器中定义的函数，如下代码片段所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We don''t care about the DOM element and where the `{{title}}` variable is.
    We just change a property of `$scope` and everything works. There are, of course,
    situations where we will have the `<input>` fields and we want to bind their values.
    If that''s the case, then the `ng-model` directive can be used. We can see this
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不关心DOM元素和`{{title}}`变量在哪里。我们只需更改`$scope`的一个属性，一切就会正常工作。当然，当然会有这样的情况，我们会遇到`<input>`字段，并希望绑定它们的值。如果是这种情况，那么可以使用`ng-model`指令。我们可以如下看到：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The data in the input field is bound to the same `title` variable. This time,
    we don't have to edit the controller. AngularJS automatically changes the content
    of the `h1` tag.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段中的数据绑定到相同的`title`变量。这次，我们不需要编辑控制器。AngularJS自动更改`h1`标签的内容。
- en: Encapsulating logic with modules
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块封装逻辑
- en: 'It''s great that we have controllers. However, it''s not a good practice to
    place everything into globally defined functions. That''s why it is good to use
    the module system. The following code shows how a module is defined:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有控制器真是太好了。然而，将所有内容都放在全局定义的函数中并不是一个好的实践。这就是为什么使用模块系统是好的。以下代码展示了如何定义一个模块：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first parameter is the name of the module and the second one is an array
    with the module''s dependencies. By dependencies, we mean other modules, services,
    or something custom that we can use inside the module. It should also be set as
    a value of the `ng-app` directive. The code so far could be translated to the
    following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是模块的名称，第二个参数是一个包含模块依赖项的数组。依赖项指的是其他模块、服务或我们可以在模块内部使用的自定义项。它也应该设置为`ng-app`指令的值。到目前为止的代码可以转换为以下代码片段：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, the first line defines a module. We can chain the different methods of the
    module and one of them is the `controller` method. Following this approach, that
    is, putting our code inside a module, we will be encapsulating logic. This is
    a sign of good architecture. And of course, with a module, we have access to different
    features such as filters, custom directives, and custom services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一行定义了一个模块。我们可以链式调用模块的不同方法，其中之一就是`controller`方法。按照这种方法，即把我们的代码放在模块内部，我们将封装逻辑。这是一个良好架构的标志。当然，使用模块，我们可以访问不同的功能，例如过滤器、自定义指令和自定义服务。
- en: Preparing data with filters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤器准备数据
- en: 'The filters are very handy when we want to prepare our data, prior to be displayed
    to the user. Let''s say, for example, that we need to mention our title in uppercase
    once it reaches a length of more than 20 characters:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在向用户展示之前准备数据时，过滤器非常有用。比如说，如果我们需要提到标题，一旦它的长度超过20个字符，就将其转换为大写：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s the definition of the custom filter called `customuppercase`. It receives
    the input and performs a simple check. What it returns, is what the user sees
    at the end. Here is how this filter could be used in HTML:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是自定义过滤器`customuppercase`的定义。它接收输入并执行简单的检查。它返回的，就是用户最终看到的内容。以下是如何在HTML中使用这个过滤器的示例：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Of course, we may add more than one filter per variable. There are some predefined
    filters to limit the length, such as the JavaScript to JSON conversion or, for
    example, date formatting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以为每个变量添加多个过滤器。有一些预定义的过滤器可以限制长度，例如JavaScript到JSON的转换或日期格式化。
- en: Dependency injection
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Dependency management can be very tough sometimes. We may split everything
    into different modules/components. They have nicely written APIs and they are
    very well documented. However, very soon, we may realize that we need to create
    a lot of objects. Dependency injection solves this problem by providing what we
    need, on the fly. We already saw this in action. The `$scope` parameter passed
    to our controller, is actually created by the `injector` of AngularJS. To get
    something as a dependency, we need to define it somewhere and let the framework
    know about it. We do this as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理有时可能非常困难。我们可能需要将一切分成不同的模块/组件。它们有很好的API编写，并且有很好的文档。然而，很快我们可能会意识到我们需要创建很多对象。依赖注入通过提供我们需要的，即时解决问题。我们已经在实际操作中看到了这一点。传递给我们的控制器的`$scope`参数实际上是由AngularJS的`injector`创建的。要获取某个依赖项，我们需要在某个地方定义它，并让框架知道它。我们这样做如下：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Module` class has a method called `factory`. It registers a new service
    that could later be used as a dependency. The function returns an object with
    only one method, `getTitle`. Of course, the name of the service should match the
    name of the controller's parameter. Otherwise, AngularJS will not be able to find
    the dependency's source.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module`类有一个名为`factory`的方法。它注册了一个新的服务，这个服务可以稍后作为依赖项使用。该函数返回一个只有一个方法的对象，即`getTitle`。当然，服务的名称应该与控制器参数的名称匹配。否则，AngularJS将无法找到依赖项的来源。'
- en: The model in the context of AngularJS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AngularJS上下文中的模型
- en: In the well known Model-View-Controller pattern, the model is the part that
    stores the data in the application. AngularJS doesn't have a specific workflow
    to define models. The `$scope` variable could be considered a model. We keep the
    data in properties attached to the current scope. Later, we can use the `ng-model`
    directive and bind a property to the DOM element. We already saw how this works
    in the previous sections. The framework may not provide the usual form of a model,
    but it's made like that so that we can write our own implementation. The fact
    that AngularJS works with plain JavaScript objects, makes this task easily doable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在众所周知的模型-视图-控制器（Model-View-Controller）模式中，模型是存储应用程序数据的部分。AngularJS没有定义模型的特定工作流程。`$scope`变量可以被视为一个模型。我们将在当前作用域附加的属性中保存数据。稍后，我们可以使用`ng-model`指令并将属性绑定到DOM元素。我们已经在前面的章节中看到了它是如何工作的。框架可能不会提供模型的传统形式，但它是这样设计的，以便我们可以编写自己的实现。AngularJS与纯JavaScript对象一起工作的事实，使得这项任务变得容易实现。
- en: Final words on AngularJS
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于AngularJS的结语
- en: AngularJS is one of the leading frameworks, not only because it is made by Google,
    but also because it's really flexible. We could use just a small piece of it or
    build a solid architecture using the giant collection of features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是领先的框架之一，不仅因为它是由谷歌制作的，而且因为它非常灵活。我们可以只使用它的一小部分，或者使用其庞大的功能集合构建一个坚实的架构。
- en: Selecting and initializing the database
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和初始化数据库
- en: 'To build a blog application, we need a database that will store the published
    articles. In most cases, the choice of the database depends on the current project.
    There are factors such as performance and scalability and we should keep them
    in mind. In order to have a better look at the possible solutions, we will have
    a look at the two of the most popular databases: **MongoDB** and **MySQL**. The
    first one is a NoSQL type of database. According to the Wikipedia entry ([http://en.wikipedia.org/wiki/NoSQL](http://en.wikipedia.org/wiki/NoSQL))
    on NoSQL databases:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个博客应用程序，我们需要一个数据库来存储已发布的文章。在大多数情况下，数据库的选择取决于当前项目。有一些因素，如性能和可扩展性，我们应该记住。为了更好地查看可能的解决方案，我们将查看两个最受欢迎的数据库：**MongoDB**和**MySQL**。第一个是一个NoSQL类型的数据库。根据维基百科上关于NoSQL数据库的条目([http://en.wikipedia.org/wiki/NoSQL](http://en.wikipedia.org/wiki/NoSQL))：
- en: '*"A NoSQL or Not Only SQL database provides a mechanism for storage and retrieval
    of data that is modeled in means other than the tabular relations used in relational
    databases."*'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"NoSQL或非仅SQL数据库提供了一种以不同于关系数据库中使用的表格关系的方式对数据进行存储和检索的机制。"*'
- en: In other words, it's simpler than a SQL database, and very often stores information
    in the key value type. Usually, such solutions are used when handling and storing
    large amounts of data. It is also a very popular approach when we need flexible
    schema or when we want to use JSON. It really depends on what kind of system we
    are building. In some cases, MySQL could be a better choice, while in some other
    cases, MongoDB. In our example blog, we're going to use both.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它比SQL数据库更简单，并且通常以键值类型存储信息。通常，此类解决方案用于处理和存储大量数据。当需要灵活的模式或想要使用JSON时，这也是一个非常流行的方法。它实际上取决于我们正在构建的系统类型。在某些情况下，MySQL可能是一个更好的选择，而在其他情况下，MongoDB。在我们的示例博客中，我们将使用两者。
- en: In order to do this, we will need a layer that connects to the database server
    and accepts queries. To make things a bit more interesting, we will create a module
    that has only one API, but can switch between the two database models.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一个连接到数据库服务器并接受查询的层。为了使事情更有趣，我们将创建一个只有一个API的模块，但可以在两种数据库模型之间切换。
- en: Using NoSQL with MongoDB
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MongoDB的NoSQL
- en: Let's start with MongoDB. Before we start storing information, we need a MongoDB
    server running. It can be downloaded from the official page of the database [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从MongoDB开始。在我们开始存储信息之前，我们需要一个运行的MongoDB服务器。可以从数据库的官方网站下载[https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)。
- en: 'We are not going to handle the communication with the database manually. There
    is a driver specifically developed for Node.js. It''s called `mongodb` and we
    should include it in our `package.json` file. After successful installation via
    `npm install`, the driver will be available in our scripts. We can check this
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会手动处理与数据库的通信。有一个专门为Node.js开发的驱动程序。它被称为`mongodb`，我们应该将其包含在我们的`package.json`文件中。通过`npm
    install`成功安装后，驱动程序将可用于我们的脚本。我们可以如下检查：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will stick to the Model-View-Controller architecture and the database-related
    operations in a model called `Articles`. We can see this as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用Model-View-Controller架构，并在名为`Articles`的模型中进行数据库相关操作。我们可以如下查看：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It starts with defining a few dependencies and settings for the MongoDB connection.
    Line number one requires the `crypto` module. We will use it to generate unique
    IDs for every article. The `type` variable defines which database is currently
    accessed. The third line initializes the MongoDB driver. We will use it to communicate
    with the database server. After that, we set the host and port for the connection
    and at the end a global `collection` variable, which will keep a reference to
    the collection with the articles. In MongoDB, the collections are similar to the
    tables in MySQL. The next logical step is to establish a database connection and
    perform the needed operations, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它从定义一些MongoDB连接的依赖项和设置开始。第一行需要`crypto`模块。我们将使用它为每篇文章生成唯一的ID。`type`变量定义了当前访问的是哪个数据库。第三行初始化MongoDB驱动程序。我们将使用它与数据库服务器进行通信。之后，我们设置连接的主机和端口，最后是一个全局的`collection`变量，它将保持对文章集合的引用。在MongoDB中，集合类似于MySQL中的表。下一个逻辑步骤是建立数据库连接并执行所需的操作，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We pass the host and the port, and the driver is doing everything else. Of
    course, it is a good practice to handle the error (if any) and throw an exception.
    In our case, this is especially needed because without the information in the
    database, the frontend has nothing to show. The rest of the module contains methods
    to add, edit, retrieve, and delete records:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递主机和端口，驱动程序将完成其他所有工作。当然，处理错误（如果有）并抛出异常是一个好习惯。在我们的情况下，这尤其必要，因为没有数据库中的信息，前端就没有东西可以显示。该模块的其余部分包含添加、编辑、检索和删除记录的方法：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `add` and `update` methods accept the `data` parameter. That''s a simple
    JavaScript object. For example, see the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`update`方法接受`data`参数。这是一个简单的JavaScript对象。例如，请看以下代码：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The records are identified by an automatically generated unique `id`. The `update`
    method needs it in order to find out which record to edit. All the methods also
    have a callback. That's important, because the module is meant to be used as a
    black box, that is, we should be able to create an instance of it, operate with
    the data, and at the end continue with the rest of the application's logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记录通过自动生成的唯一`id`进行标识。`update`方法需要它来找出要编辑哪个记录。所有方法都有回调。这很重要，因为这个模块旨在作为一个黑盒使用，也就是说，我们应该能够创建其实例，操作数据，并在最后继续应用程序的其他逻辑。
- en: Using MySQL
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MySQL
- en: We're going to use an SQL type of database with MySQL. We will add a few more
    lines of code to the already working `Articles.js` model. The idea is to have
    a class that supports the two databases like two different options. At the end,
    we should be able to switch from one to the other, by simply changing the value
    of a variable. Similar to MongoDB, we need to first install the database to be
    able use it. The official download page is [http://www.mysql.com/downloads](http://www.mysql.com/downloads).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MySQL类型的数据库。我们将在已经工作的`Articles.js`模型中添加几行代码。想法是有一个类支持两个数据库，就像两个不同的选项。最后，我们应该能够通过简单地更改变量的值从其中一个切换到另一个。类似于MongoDB，我们需要首先安装数据库才能使用它。官方下载页面是[http://www.mysql.com/downloads](http://www.mysql.com/downloads)。
- en: 'MySQL requires another Node.js module. It should be added again to the `package.json`
    file. We can see the module as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL需要另一个Node.js模块。它应该再次添加到`package.json`文件中。我们可以如下查看该模块：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to the MongoDB solution, we need to firstly connect to the server.
    To do so, we need to know the values of the **host**, **username**, and **password**
    fields. And because the data is organized in databases, a name of the database.
    In MySQL, we put our data into different databases. So, the following code defines
    the needed variables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于MongoDB解决方案，我们首先需要连接到服务器。为此，我们需要知道**主机**、**用户名**和**密码**字段的值。并且因为数据是有组织地存储在数据库中的，所以需要一个数据库名称。在MySQL中，我们将数据放入不同的数据库中。因此，以下代码定义了所需的变量：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous example leaves the **password** field empty but we should set
    the proper value of our system. The MySQL database requires us to define a table
    and its fields before we start saving data. So, the following code is a short
    dump of the table used in this chapter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子中**密码**字段留空，但我们应该设置我们系统的正确值。MySQL数据库要求我们在开始保存数据之前定义一个表及其字段。因此，以下代码是本章中使用的表的简短转储：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we have a database and its table set, we can continue with the database
    connection, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了数据库及其表，我们就可以继续进行数据库连接，如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The driver provides a method to connect to the server and execute queries. The
    first executed query selects the database. If everything is ok, you should see
    **Successfully selected database** as an output in your console. Half of the job
    is done. What we should do now is replicate the methods returned in the first
    MongoDB implementation. We need to do this because when we switch to the MySQL
    usage, the code using the class will not work. And by replicating them we mean
    that they should have the same names and should accept the same arguments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序提供了一个连接到服务器并执行查询的方法。第一个执行的查询选择数据库。如果一切正常，你应该在你的控制台中看到**成功选择数据库**的输出。一半的工作已经完成。我们现在需要做的是复制第一个MongoDB实现中返回的方法。我们需要这样做，因为当我们切换到MySQL使用时，使用该类的代码将不会工作。而我们所说的复制是指它们应该有相同的名称，并且应该接受相同的参数。
- en: 'If we do everything correctly, at the end our application will support two
    types of databases. And all we have to do is change the value of the `type` variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一切都做得正确，最终我们的应用程序将支持两种类型的数据库。我们只需要更改`type`变量的值：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code is a little longer than the one generated in the first MongoDB variant.
    That's because we needed to construct MySQL queries from the passed data. Keep
    in mind that we have to escape the information, which comes to the module. That's
    why we use `connection.escape()`. With these lines of code, our model is completed.
    Now we can add, edit, remove, or get data. Let's continue with the part that shows
    the articles to our users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码比第一个MongoDB变体生成的代码要长一些。这是因为我们需要从传递的数据中构建MySQL查询。请记住，我们必须转义传递给模块的信息。这就是为什么我们使用`connection.escape()`。有了这些代码行，我们的模型就完成了。现在我们可以添加、编辑、删除或获取数据。让我们继续展示文章的部分给用户。
- en: Developing the client side with Angular
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 开发客户端
- en: 'Let''s assume that there is some data in the database and we are ready to present
    it to the users. So far, we have only developed the model, which is the class
    that takes care of the access to the information. In the previous chapter of this
    book, we learned about Express. To simplify the process, we will use it again
    here. We need to first update the `package.json` file and include that in the
    framework, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中已有一些数据，我们准备将其展示给用户。到目前为止，我们只开发了模型，即负责信息访问的类。在本书的上一章中，我们学习了Express。为了简化过程，我们在这里再次使用它。我们需要首先更新`package.json`文件，并将其包含在框架中，如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are also adding **Jade**, because we are going to use it as a template language.
    The writing of markup in plain HTML is not very efficient nowadays. By using the
    template engine, we can split the data and the HTML markup, which makes our application
    much better structured. Jade''s syntax is kind of similar to HTML. We can write
    tags without the need to close them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了**Jade**，因为我们打算将其用作模板语言。现在使用纯HTML编写标记并不是很高效。通过使用模板引擎，我们可以将数据和HTML标记分开，这使得我们的应用程序结构更加清晰。Jade的语法与HTML有些类似。我们可以编写不需要关闭的标签：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code snippet is transformed to the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段被转换成以下代码片段：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Jade relies on the indentation in the content to distinguish the tags.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Jade依赖于内容中的缩进来区分标签。
- en: 'Let''s start with the project structure, as seen in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下截图所示的项目结构开始：
- en: '![Developing the client side with Angular](img/00007.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Angular 开发客户端](img/00007.jpeg)'
- en: 'We placed our already written class, `Articles.js`, inside the `models` directory.
    The public directory will contain CSS styles, and all the necessary client-side
    JavaScript: the AngularJS library, the AngularJS router module, and our custom
    code.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将已经编写的类`Articles.js`放在了`models`目录中。公共目录将包含CSS样式，以及所有必要的客户端JavaScript：AngularJS库、AngularJS路由模块和我们的自定义代码。
- en: 'We will skip some of the explanations about the following code, because we
    already covered that in the previous chapter. Our `index.js` file looks as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过一些关于以下代码的解释，因为我们已经在上一章中介绍过了。我们的`index.js`文件看起来如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At the beginning, we require the Express framework and our model. Maybe it's
    better to initialize the model inside the controller, but in our case this is
    not necessary. Just after that, we set up some basic options for Express and define
    our own middleware. It has only one job to do and that is to attach the model
    to the request object. We are doing this because the request object is passed
    to all the route handlers. In our case, these handlers are actually the controllers.
    So, `Articles.js` becomes accessible everywhere via the `req.articles` property.
    At the end of the script, we placed two routes. The second one catches the usual
    requests that come from the users. The first one, `/api/get`, is a bit more interesting.
    We want to build our frontend on top of AngularJS. So, the data that is stored
    in the database should not enter the Node.js part but on the client side where
    we use Google's framework. To make this possible, we will create routes/controllers
    to get, add, edit, and delete records. Everything will be controlled by HTTP requests
    performed by AngularJS. In other words, we need an API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们引入了 Express 框架和我们的模型。也许在控制器内部初始化模型会更好，但在这个例子中并不必要。紧接着，我们为 Express 设置了一些基本选项并定义了我们自己的中间件。它只有一个任务要做，那就是将模型附加到请求对象上。我们这样做是因为请求对象会被传递给所有的路由处理器。在我们的例子中，这些处理器实际上是控制器。所以，`Articles.js`
    通过 `req.articles` 属性在所有地方都可以访问。在脚本末尾，我们放置了两个路由。第二个路由捕获来自用户的常规请求。第一个路由 `/api/get`
    则更有趣。我们想在 AngularJS 之上构建我们的前端。因此，存储在数据库中的数据不应进入 Node.js 部分，而应在客户端使用 Google 的框架。为了实现这一点，我们将创建用于获取、添加、编辑和删除记录的路由/控制器。所有这些都将由
    AngularJS 执行的 HTTP 请求来控制。换句话说，我们需要一个 API。
- en: 'Before we start using Angular, let''s take a look at the `/controllers/api/get.js`
    controller:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Angular 之前，让我们看看 `/controllers/api/get.js` 控制器：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The main job is done by our model and the response is handled by Express. It's
    nice because if we pass a JavaScript object, as we did, (`rows` is actually an
    array of objects) the framework sets the response headers automatically. To test
    the result, we could run the application with `node index.js` and open `http://localhost:3000/api/get`.
    If we don't have any records in the database, we will get an empty array. If not,
    the stored articles will be returned. So, that's the URL, which we should hit
    from within the AngularJS controller in order to get the information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作由我们的模型完成，响应由 Express 处理。这很好，因为我们传递了一个 JavaScript 对象（实际上 `rows` 是一个对象数组），框架会自动设置响应头。为了测试结果，我们可以用
    `node index.js` 运行应用程序，并打开 `http://localhost:3000/api/get`。如果没有记录在数据库中，我们将得到一个空数组。如果有，存储的文章将被返回。所以，这就是我们应该从
    AngularJS 控制器内部击中的 URL，以获取信息。
- en: 'The code of the `/controller/index.js` controller is also just a few lines.
    We can see the code as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`/controller/index.js` 控制器的代码也只有几行。我们可以看到以下代码：'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It simply renders the list view, which is stored in the `list.jade` file. That
    file should be saved in the `/views directory`. But before we see its code, we
    will check another file, which acts as a base for all the pages. Jade has a nice
    feature called*blocks*. We may define different partials and combine them into
    one template. The following is our `layout.jade` `file`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地渲染了存储在 `list.jade` 文件中的列表视图。该文件应保存在 `/views` 目录中。但在我们查看其代码之前，我们将检查另一个文件，该文件作为所有页面的基础。Jade
    有一个叫做*块*的不错特性。我们可以定义不同的部分并将它们组合成一个模板。以下是我们的 `layout.jade` 文件：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is only one variable passed to this template, which is `#{app}`. We will
    need it later to initialize the administration''s module. The `angular.min.js`
    and `angular-route.min.js` files should be downloaded from the official AngularJS
    site, and placed in the `/public` directory. The body of the page contains a block
    placeholder called `content,` which we will later fill with the list of the articles.
    The following is the `list.jade` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板只传递了一个变量，即 `#{app}`。我们稍后会需要它来初始化管理模块。`angular.min.js` 和 `angular-route.min.js`
    文件应从官方 AngularJS 网站下载，并放置在 `/public` 目录中。页面主体包含一个名为 `content` 的块占位符，稍后我们将用文章列表填充它。以下是
    `list.jade` 文件：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The two lines in the beginning combine both the templates into one page. The
    Express framework transforms the Jade template into HTML and serves it to the
    browser of the user. From there, the client-side JavaScript takes control. We
    are using the `ng-controller` directive saying that the `div` element will be
    controlled by an AngularJS controller called `BlogCtrl.` The same class should
    have variable, `articles`, filled with the information from the database`.` `ng-repeat`
    goes through the array and displays the content to the users`.` The `blog.js`
    class holds the code of the controller:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 开头两行将两个模板合并到一个页面中。Express框架将Jade模板转换为HTML，并服务于用户的浏览器。从那里，客户端JavaScript接管控制。我们使用`ng-controller`指令表示`div`元素将由名为`BlogCtrl`的AngularJS控制器控制。相同的类应该有一个变量`articles`，其中包含来自数据库的信息`.`
    `ng-repeat`遍历数组并向用户显示内容`.` `blog.js`类包含控制器的代码：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The controller has two dependencies. The first one`,` `$scope,` points to the
    current view. Whatever we assign as a property there is available as a variable
    in our HTML markup. Initially, we add only one element, which doesn''t have a
    title, but has text. It is shown to indicate that we are still loading the articles
    from the database. The second dependency, `$http`, provides an API in order to
    make HTTP requests. So, all we have to do is query `/api/get`, fetch the data,
    and pass it to the `$scope` dependency. The rest is done by AngularJS and its
    magical two-way data binding. To make the application a little more interesting,
    we will add a search field, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器有两个依赖项。第一个依赖项`,` `$scope,` 指向当前视图。我们在那里分配的任何属性都作为变量在我们的HTML标记中可用。最初，我们只添加了一个元素，它没有标题，但有文本。这显示出来是为了表明我们仍在从数据库中加载文章。第二个依赖项，`$http`，提供了一个API，用于执行HTTP请求。因此，我们只需查询`/api/get`，获取数据，并将其传递给`$scope`依赖项。其余的工作由AngularJS及其神奇的双向数据绑定来完成。为了使应用程序更有趣，我们将添加一个搜索字段，如下所示：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ng-model` directive, binds the value of the input field to a variable
    inside our `$scope` dependency. However, this time, we don''t have to edit our
    controller and can simply apply the same variable as a filter to the `ng-repeat`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-model`指令将输入字段的值绑定到我们`$scope`依赖项内的一个变量。然而，这次我们不需要编辑我们的控制器，只需将相同的变量作为过滤器应用到`ng-repeat`：'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As a result, the articles shown will be filtered based on the user's input.
    Two simple additions, but something really valuable is on the page. The filters
    of AngularJS can be very powerful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显示的文章将根据用户的输入进行筛选。这两个简单的添加，但页面上确实有一些真正有价值的东西。AngularJS的过滤器可以非常强大。
- en: Implementing a control panel
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制面板
- en: 'The control panel is the place where we will manage the articles of the blog.
    Several things should be made in the backend before continuing with the user interface.
    They are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制面板是我们管理博客文章的地方。在继续处理用户界面之前，在后台需要做一些事情。具体如下：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previous lines of code should be added to `/index.js`. Our administration
    should be protected, so the first two lines define our credentials. We are using
    Express as data storage, simply creating key-value pairs. Later, if we need the
    username we can get it with `app.get("username")`. The next two lines enable session
    support. We need that because of the login process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应将前面的代码行添加到`/index.js`中。我们的管理应该受到保护，所以前两行定义了我们的凭证。我们使用Express作为数据存储，简单地创建键值对。稍后，如果我们需要用户名，我们可以使用`app.get("username")`来获取它。接下来的两行启用了会话支持。我们需要它是因为登录过程。
- en: 'We added a middleware, which attaches the articles to the `request` object.
    We will do the same with the current user''s status, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个中间件，它将文章附加到`request`对象上。我们将对当前用户的身份状态做同样处理，如下所示：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our `if` statement is a little long, but it tells us whether the user is logged
    in or not. The first part checks whether there is a session created and the second
    one checks whether the user submitted a form with the correct username and password.
    If these expressions are `true`, then we attach a variable, `logged`, to the `request`
    object and create a session that will be valid during the following requests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`if`语句有点长，但它告诉我们用户是否已登录。第一部分检查是否创建了会话，第二部分检查用户是否提交了包含正确用户名和密码的表单。如果这些表达式为`true`，则我们将变量`logged`附加到`request`对象上，并创建一个在后续请求中有效的会话。
- en: 'There is only one thing that we need in the main application''s file. A few
    routes that will handle the control panel operations. In the following code, we
    are defining them along with the needed route handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在主应用程序的文件中，我们只需要一个东西。一些将处理控制面板操作的路由。在以下代码中，我们定义了它们以及所需的路由处理程序：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The three routes, which start with `/api`, will use the model `Articles.js`
    to add, edit, and remove articles from the database. These operations should be
    protected. We will add a middleware function that takes care of this. If the `req.logged`
    variable is not available, it simply responds with a `401 - Unauthorized` status
    code. The last route, `/admin`, is a little different because it shows a login
    form instead. The following is the controller to create new articles:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以`/api`开头的三个路由将使用`Articles.js`模型来添加、编辑和从数据库中删除文章。这些操作应该是受保护的。我们将添加一个中间件函数来处理这个问题。如果`req.logged`变量不可用，它将简单地响应一个`401
    - Unauthorized`状态码。最后一个路由`/admin`有一点不同，因为它显示了一个登录表单。以下是为创建新文章创建的控制器：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We transfer most of the logic to the frontend, so again, there are just a few
    lines. What is interesting here is that we pass `req.body` directly to the model.
    It actually contains the data submitted by the user. The following code, is how
    the `req.articles.add` method looks for the MongoDB implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大部分逻辑转移到前端，所以这里也只有几行。这里有趣的是，我们直接将`req.body`传递给模型。它实际上包含了用户提交的数据。以下代码展示了`req.articles.add`方法在MongoDB实现中的样子：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And the MySQL implementation is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL实现如下：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In both the cases, we need `title` and `text` in the passed data object. Thankfully,
    due to Express'' `bodyParser` middleware, this is what we have in the `req.body`
    object. We can directly forward it to the model. The other route handlers are
    almost the same:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都需要在传递的数据对象中包含`title`和`text`。幸运的是，由于Express的`bodyParser`中间件，这就是我们在`req.body`对象中拥有的。我们可以直接将其转发到模型。其他路由处理程序几乎相同：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What we changed is the method of the `Articles.js` class. It is not `add` but
    `update`. The same technique is applied in the route to delete an article. We
    can see it as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变的是`Articles.js`类的处理方法。它不是`add`而是`update`。同样的技术也应用于路由中删除文章的操作。我们可以这样看到：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What we need for deletion is not the whole body of the request but only the
    unique ID of the record. Every API method sends `{success: true}` as a response.
    While we are dealing with API requests, we should always return a response. Even
    if something goes wrong.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要删除的不是请求的整个主体，而是记录的唯一ID。每个API方法都会发送`{success: true}`作为响应。当我们处理API请求时，我们应该始终返回一个响应。即使出了问题。'
- en: 'The last thing in the Node.js part, which we have to cover, is the controller
    responsible for the user interface of the administration panel, that is, the.
    `/controllers/admin.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js部分，我们最后要讨论的是负责管理面板用户界面的控制器，即`.controllers/admin.js`文件：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are two templates that are rendered: `/views/admin.jade` and `/views/login.jade`.
    Based on the variable, which we set in `/index.js`, the script decides which one
    to show. If the user is not logged in, then a login form is sent to the browser,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个模板被渲染：`/views/admin.jade`和`/views/login.jade`。根据我们在`/index.js`中设置的变量，脚本决定显示哪一个。如果用户未登录，则将登录表单发送到浏览器，如下所示：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is no AngularJS code here. All we have is the good old HTML form, which
    submits its data via POST to the same URL—`/admin`. If the username and password
    are correct, the `.logged` variable is set to `true` and the controller renders
    the other template:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有AngularJS代码。我们只有那个古老的HTML表单，它通过POST将数据提交到相同的URL——`/admin`。如果用户名和密码正确，`.logged`变量将被设置为`true`，控制器将渲染其他模板：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The control panel needs several views to handle all the operations. AngularJS
    has a great router module, which works with hashtags-type URLs, that is, URLs
    such as `/admin#/add`. The same module requires a placeholder for the different
    partials. In our case, this is a `section` tag. The `ng-view` attribute tells
    the framework that this is the element prepared for that logic. At the end of
    the template, we are adding an external file, which keeps the whole client-side
    JavaScript code that is needed by the control panel.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 控制面板需要几个视图来处理所有操作。AngularJS有一个出色的路由模块，它与标签型URL一起工作，即类似于`/admin#/add`的URL。同一个模块需要一个占位符来处理不同的部分。在我们的案例中，这是一个`section`标签。`ng-view`属性告诉框架这是一个为该逻辑准备的元素。在模板的末尾，我们添加了一个外部文件，它包含了控制面板所需的全部客户端JavaScript代码。
- en: 'While the client-side part of the applications needs only loading of the articles,
    the control panel requires a lot more functionalities. It is good to use the modular
    system of AngularJS. We need the routes and views to change, so the `ngRoute`
    module is needed as a dependency. This module is not added in the main `angular.min.js`
    build. It is placed in the `angular-route.min.js` file. The following code shows
    how our module starts:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序的客户端部分只需要加载文章，但控制面板需要更多的功能。使用AngularJS的模块化系统是很好的。我们需要路由和视图发生变化，因此需要`ngRoute`模块作为依赖项。此模块未添加到主`angular.min.js`构建中。它放在`angular-route.min.js`文件中。以下代码显示了我们的模块是如何开始的：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We configured the router by mapping URLs to specific routes. At the moment,
    the routes are just empty objects, but we will fix that shortly. Every controller
    will need to make HTTP requests to the Node.js part of the application. It will
    be nice if we have such a service and use it all over our code. We can see an
    example as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将URL映射到特定路由来配置路由器。目前，路由只是空对象，但我们将很快解决这个问题。每个控制器都需要向应用程序的Node.js部分发出HTTP请求。如果我们有一个这样的服务并在整个代码中使用它，那将很好。以下是一个示例：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'One of the best things about AngularJS is that it works with plain JavaScript
    objects. There are no unnecessary abstractions and no extending or inheriting
    special classes. We are using the `.factory` method to create a simple JavaScript
    object. It has four methods that can be called: `get`, `add`, `edit`, and `remove`.
    Each one of them calls a function, which is defined in the helper method `request`.
    The service has only one dependency, `$http`. We already know this module; it
    handles HTTP requests nicely. The URLs that we are going to query are the same
    ones that we defined in the Node.js part.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS最好的事情之一是它与纯JavaScript对象一起工作。没有不必要的抽象，也没有扩展或继承特殊类。我们正在使用`.factory`方法创建一个简单的JavaScript对象。它有四个可以调用的方法：`get`、`add`、`edit`和`remove`。每个方法都调用在辅助方法`request`中定义的函数。该服务只有一个依赖项，即`$http`。我们已经知道这个模块；它很好地处理HTTP请求。我们将查询的URL与我们在Node.js部分定义的相同。
- en: 'Now, let''s create a controller that will show the articles currently stored
    in the database. First, we should replace the empty route object `.when(''/'',
    {})` with the following object:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个控制器，该控制器将显示数据库中当前存储的文章。首先，我们应该用以下对象替换空的路由对象`.when('/', {})`：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The object has to contain a controller and a template. The template is nothing
    more than a few lines of HTML markup. It looks a bit like the template used to
    show the articles on the client side. The difference is the links used to edit
    and delete. JavaScript doesn''t allow new lines in the string definitions. The
    backward slashes at the end of the lines prevent syntax errors, which will eventually
    be thrown by the browser. The following is the code for the controller. It is
    defined, again, in the module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须包含一个控制器和一个模板。模板不过是几行HTML标记。它看起来有点像客户端用来显示文章的模板。区别在于用于编辑和删除的链接。JavaScript不允许在字符串定义中使用换行符。行尾的反斜杠可以防止语法错误，这些错误最终会被浏览器抛出。以下是为控制器编写的代码。它再次在模块中定义：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And here is the beauty of the AngularJS dependency injection. Our custom-defined
    service `API` is automatically initialized and passed to the controller. The `.get`
    method fetches the articles from the database. Later, we send the information
    to the current `$scope` dependency and the two-way data binding does the rest.
    The articles are shown on the page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是AngularJS依赖注入的美丽之处。我们自定义的服务`API`会自动初始化并传递给控制器。`.get`方法从数据库中获取文章。稍后，我们将信息发送到当前的`$scope`依赖项，双向数据绑定完成剩余的工作。文章显示在页面上。
- en: 'The work with AngularJS is so easy that we could combine the controller to
    add and edit in one place. Let''s store the route object in an external variable,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AngularJS的工作非常简单，以至于我们可以将控制器组合在一起，在同一个地方添加和编辑。让我们将路由对象存储在一个外部变量中，如下所示：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And later, assign it to the both the routes, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其分配给两个路由，如下所示：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The template is just a form with the necessary fields and a button, which calls
    the `save` method in the controller. Notice that we bound the input field and
    the text area to variables inside the `$scope` dependency. This comes in handy
    because we don''t need to access the DOM to get the values. We can see this as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 模板只是一个带有必要字段和按钮的表单，该按钮调用控制器中的`save`方法。注意，我们将输入字段和文本区域绑定到了`$scope`依赖项内部的变量上。这很有用，因为我们不需要访问DOM来获取值。我们可以这样看到：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The controller receives four dependencies. We already know about `$scope` and
    `API`. The `$location` dependency is used when we want to change the current route,
    or, in other words, to forward the user to another view. The `$routeParams` dependency
    is needed to fetch parameters from the URL. In our case, `/edit/:id` is a route
    with a variable inside. Inside the code, the `id` is available in `$routeParams.id`.
    The adding and editing of articles uses the same form. So, with a simple check,
    we know what the user is currently doing. If the user is in the edit mode, then
    we fetch the article based on the provided `id` and fill the form. Otherwise,
    the fields are empty and new records will be created.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器接收四个依赖项。我们已经了解了`$scope`和`API`。当我们要更改当前路由，或者说，将用户重定向到另一个视图时，使用`$location`依赖项。`$routeParams`依赖项用于从URL中获取参数。在我们的例子中，`/edit/:id`是一个包含变量的路由。在代码内部，`id`在`$routeParams.id`中可用。文章的添加和编辑使用相同的表单。因此，通过简单的检查，我们知道用户当前正在做什么。如果用户处于编辑模式，那么我们将根据提供的`id`获取文章并填写表单。否则，字段为空，将创建新的记录。
- en: 'The deletion of an article can be done by using a similar approach, which is
    adding a route object and defining a new controller. We can see the deletion as
    follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文章可以通过类似的方法完成，即添加一个路由对象并定义一个新的控制器。我们可以这样看待删除操作：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We don''t need a template in this case. Once the article is deleted from the
    database, we will forward the user to the list page. We have to call the `remove`
    method of the API. Here is how the `RemoveCtrl` controller looks like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要模板。一旦文章从数据库中删除，我们将用户重定向到列表页面。我们必须调用API的`remove`方法。以下是`RemoveCtrl`控制器的外观：
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code depicts same dependencies like in the previous controller.
    This time, we simply forward the `$routeParams` dependency to the API. And because
    it is a plain JavaScript object, everything works as expected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码描述了与上一个控制器相同的依赖项。这次，我们只是简单地将`$routeParams`依赖项转发给API。因为它是一个纯JavaScript对象，所以一切按预期工作。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a simple blog by writing the backend of the application
    in Node.js. The module for database communication, which we wrote, can work with
    the MongoDB or MySQL database and store articles. The client-side part and the
    control panel of the blog were developed with AngularJS. We then defined a custom
    service using the built-in HTTP and routing mechanisms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用Node.js编写应用程序的后端，构建了一个简单的博客。我们编写的数据库通信模块可以与MongoDB或MySQL数据库协同工作，并存储文章。博客的客户端部分和控制面板是用AngularJS开发的。然后，我们使用内置的HTTP和路由机制定义了一个自定义服务。
- en: Node.js works well with AngularJS, mainly because both are written in JavaScript.
    We found out that AngularJS is built to support the developer. It removes all
    those boring tasks such as DOM element referencing, attaching event listeners,
    and so on. It's a great choice for the modern client-side coding stack.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js与AngularJS配合得很好，主要是因为两者都是用JavaScript编写的。我们发现AngularJS是为了支持开发者而构建的。它消除了所有那些无聊的任务，例如DOM元素引用、附加事件监听器等。它是现代客户端编码堆栈的一个很好的选择。
- en: In the next chapter, we will see how to program a real-time chat with Socket.IO,
    one of the popular solutions covering the WebSockets communication.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用Socket.IO编程实时聊天，它是涵盖WebSockets通信的流行解决方案之一。
