<html><head></head><body>
		<div><h1 id="_idParaDest-55" class="chapter-number"><a id="_idTextAnchor056"/>3</h1>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor057"/> JavaScript Fundamentals</h1>
			<p>In this chapter, we will review all the aspects of JavaScript that are relevant to this book. While this topic could be a book in itself, this chapter synthesizes the most basic parts (arrays, objects, strings, and data types) in order to do a deeper analysis of the most complex parts, such as functions and closures.</p>
			<p>Even if you are already familiar with JavaScript, this chapter will help you to refresh your knowledge of certain areas. Also, you will learn about the latest changes in JavaScript introduced by the latest specification.</p>
			<p>We will also learn how JavaScript has become a standard on how decisions are made when a request change is made for the language.</p>
			<p>Additionally, we will review some tools that will help us to write better JavaScript by using linters, debugging tools, and proper documentation for our code.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>Refresh or acquire JavaScript knowledge, including about many of its features</li>
				<li>Understand JavaScript versioning and the TC39 committee</li>
				<li>Get familiar with the JavaScript documentation and linting</li>
				<li>Understand the most commonly used parts of JavaScript (comments, data types, operators, conditionals, loops, functions, objects, arrays, classes, and so on)</li>
				<li>Understand advanced JavaScript concepts such as closures and prototypes</li>
			</ul>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/BxM8XZzINmg">https://youtu.be/BxM8XZzINmg</a></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>JavaScript is a powerful language</h1>
			<p>JavaScript is a very powerful language. It is used in the frontend, backend, mobile, desktop, IoT, and so on. It is very flexible, and it is very easy to get started, but it is also very hard to master in depth.</p>
			<p>There is a very famous quote (<a href="https://www.crockford.com/javascript/javascript.html">https://www.crockford.com/javascript/javascript.html</a>) by Douglas Crockford that says:</p>
			<p class="author-quote">JavaScript is the world’s most misunderstood programming language.</p>
			<p>JavaScript is a multi-paradigm<a id="_idIndexMarker070"/> language, which means that you can use different programming styles, such as object-oriented programming, functional programming, or declarative programming. This is very useful because you can use the programming style that best fits your needs. But on the other hand, it can be very confusing for beginners, and not all the programming styles are equally supported by the language.</p>
			<p>JavaScript is a very dynamic language, which means that you can change the behavior of the language at runtime. Thanks to JavaScript, you can learn complex concepts, such as closures and prototypes, and use them to create very powerful and complex applications. But you can also use them to create very confusing and hard-to-maintain applications.</p>
			<p>In the next chapters, we will learn how to use JavaScript to create powerful applications, but we will also learn how to use it in a way that is easy to understand and maintain.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Don’t worry if you’re not deeply familiar with any of the mentioned paradigms. Throughout this book, we’ll gradually incorporate elements from each paradigm, introducing them as needed.</p>
			<p>In the next section, we will explore the role of the TC39 in JavaScript and how the specification works.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor060"/>Understanding versioning – TC39</h1>
			<p>JavaScript is getting old; it was created in 1995 by Brendan Eich at Netscape Communications Corporation. It was<a id="_idIndexMarker071"/> originally called Mocha, but it <a id="_idIndexMarker072"/>was renamed LiveScript and finally JavaScript.</p>
			<p>The first version <a id="_idIndexMarker073"/>of JavaScript<a id="_idIndexMarker074"/> was released in 1996. It was called <strong class="bold">ECMAScript 1</strong> (<strong class="bold">ES1</strong>) and was<a id="_idIndexMarker075"/> standardized by the <strong class="bold">European Computer Manufacturers Association</strong> (<strong class="bold">ECMA</strong>) in 1997.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Understanding versioning – ECMAScript</h2>
			<p>Over the years, many new features were added to the language, such as classes, modules, and arrow functions. The <a id="_idIndexMarker076"/>new features were added to the language through a submission proposal process called ECMAScript proposals (<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>) that are managed directly by the TC39 (<a href="https://tc39.es/process-document/">https://tc39.es/process-document/</a>), which refers to a committee of ECMA that is responsible for the evolution of the language.</p>
			<p>From 1997 until 2015, new features were added to the language every few years, but in 2015, the TC39 decided to release a new version of the language every year, which means that the language is evolving faster than ever. This also helps us with the adoption of the new features because we don’t need to wait many years to use them in production environments.</p>
			<p>Currently, the latest version of the language is ECMA-262 2023 (<a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>), which was released in June 2023.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>What is included in the next version of JavaScript?</h2>
			<p>In order to add new features to <a id="_idIndexMarker077"/>the language, the TC39 committee has a process that is divided into stages. Anybody can submit a proposal to the TC39 committee, but it is not an easy task, because the proposal needs to be approved by the committee before it is implemented.</p>
			<p>You can find all the proposals in the TC39 GitHub repository (<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>). You can participate in the discussions and get involved in the community.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>What is not included in the JavaScript specification?</h2>
			<p>The JavaScript specification is very big, but it <a id="_idIndexMarker078"/>does not include many APIs that are commonly used in JavaScript applications, such as browser APIs and Node.js APIs.</p>
			<p>If you are using JavaScript in the browser, you can use browser APIs, such as the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). If you <a id="_idIndexMarker079"/>are using JavaScript in Node.js, you can use Node.js APIs, such as the filesystem or HTTP.</p>
			<p>At the end of the day, JavaScript is just a programming language. If you are used to building JavaScript applications in the browser, you might be familiar with many APIs that are not included in the JavaScript specification and are not available in Node.js. For example, the window object (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">https://developer.mozilla.org/en-US/docs/Web/API/Window</a>) is available in the browser, but it is not available in Node.js.</p>
			<p>Now that we know how the specification works, it is time to explore the JavaScript documentation in the next section.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Exploring JavaScript documentation</h1>
			<p>While ECMA-262 (<a href="https://262.ecma-international.org/14.0/">https://262.ecma-international.org/14.0/</a>) is a great source of information, it is not very <a id="_idIndexMarker080"/>beginner-friendly.</p>
			<p>The most complete source of information is the MDN Web Docs (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>), which is a community-driven documentation. It is very comprehensive, and it is updated regularly and even translated into other languages.</p>
			<p>If you are familiar with frontend development, you might have used the MDN Web Docs before, because it is the main source of information for browser APIs, such as the DOM (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction</a>) and the Fetch API (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>).</p>
			<p>If are looking for more concise documentation, you can use W3Schools (<a href="https://www.w3schools.com/js/default.asp">https://www.w3schools.com/js/default.asp</a>), which is a great source of information for beginners, with a lot of examples.</p>
			<p>Finally, if you are <a id="_idIndexMarker081"/>looking for a specific answer to a question, you can use Stack Overflow (<a href="https://stackoverflow.com/questions/tagged/javascript">https://stackoverflow.com/questions/tagged/javascript</a>), which is a community-driven Q&amp;A website.</p>
			<p>In the next section, we will learn how we can use linting tools to improve our JavaScript code easily.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/>Linting JavaScript code</h1>
			<p>Linting is the process of<a id="_idIndexMarker082"/> running a program that will analyze your code for potential errors. It is very useful in catching errors before running your code, so you can fix them before they cause any issues.</p>
			<p>JavaScript is a very flexible language, which means that it is very easy to make mistakes. As you get more used to it, you will make fewer mistakes, but it is always good to have a linter to help you.</p>
			<p>In the next chapters, we will use ESLint (<a href="https://eslint.org/">https://eslint.org/</a>) to lint our code, but there are other options available, such as JSLint (<a href="https://www.jslint.com/">https://www.jslint.com/</a>) and JSHint (<a href="https://jshint.com/">https://jshint.com/</a>).</p>
			<p>Configuring a linter is not a trivial task, but it is worth the effort. There are many rules available, and it is not easy to know which ones to use. I highly recommend that you use the standard rules (<a href="https://standardjs.com/">https://standardjs.com/</a>), which are one of the most popular and used by many open source projects (including Node.js, Express, and MongoDB) and companies. You can find all the rules available on the JavaScript Standard Style page (<a href="https://standardjs.com/rules.html">https://standardjs.com/rules.html</a>).</p>
			<p>In <em class="italic">Figure 3</em><em class="italic">.1</em>, you can see how the standard is used to review the source code of the project. It will recommend what to do in order to follow the configured rules.</p>
			<div><div><img src="img/B21678_03_01.jpg" alt="Figure 3.1 – Screenshot from GitHub Codespaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Screenshot from GitHub Codespaces</p>
			<p>In the next section, we will learn <a id="_idIndexMarker083"/>how to document our own code, so it becomes easier to maintain.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>Commenting JavaScript code</h1>
			<p>You have multiple options <a id="_idIndexMarker084"/>to include comments in your code:</p>
			<pre class="source-code">
// Single line comment
/*
Multiline
comment
*/</pre>			<p>If you are new to JavaScript, I recommend you use a lot of comments to help you understand what is going on in your code. As you become more experienced, you will need fewer comments. Comments also help other developers to read and understa<a id="_idTextAnchor067"/>nd your code.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor068"/>Using JSDoc</h2>
			<p>If you need guidance on how to write good comments, you can use the JSDoc (<a href="https://jsdoc.app/">https://jsdoc.app/</a>) syntax. Another <a id="_idIndexMarker085"/>additional benefit of<a id="_idIndexMarker086"/> using JSDoc is that you can use it to autogenerate documentation for your code.</p>
			<p>This is quite a popular solution. For example, Lodash uses this approach.  Use the following links to check out how the <code>_.chunk</code> method is documented:</p>
			<ul>
				<li>JSDoc in practice: <a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818">https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818</a></li>
				<li>Documentation automatically generated by JSDocs: <a href="https://lodash.com/docs/4.17.15#chunk">https://lodash.com/docs/4.17.15#chunk</a></li>
			</ul>
			<p>In the next section, we will learn how to use <code>console</code> to speed up our debugging process.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Printing values and debugging</h1>
			<p>The <code>console</code> object is non-standard; it is not part of the JavaScript language, but it is provided by the browser and Node.js. You can use it to print messages to the console, which is very <a id="_idIndexMarker087"/>useful for debugging purposes and for the purposes of this book, to follow along with the examples. It is quite common to use it to print the value of a variable. Take the following example:</p>
			<pre class="source-code">
const name = "Ulises";
console.log(name); // Ulises</pre>			<p>Yes, you can use <code>console.log</code> to print multiple values at the same time, separated by commas, and even include additional information to explain what you are printing. You don’t have to worry about the type of the variable as in other languages; <code>console.log</code> will do it for you.</p>
			<p>In some cases, you will need to help <code>console.log</code> print the value of a variable; for example, if you want to print an object, sometimes you end up getting <code>[object, object]</code> or similar as the output message. In this case, you will need to use <code>console.log(JSON.stringify(object))</code> to print the object as a string:</p>
			<pre class="source-code">
const data = {
  nestedData: {
    moreNestedData: {
      value: 1
    }
  }
};
console.log(data); // [object, object]
console.log(JSON.stringify(data)); // {"nestedData":{"moreNestedData":{"value":1}}}</pre>			<p>Over time, the JavaScript engines improve the <code>console</code> output, so this simple example might be printed as <a id="_idIndexMarker088"/>expected in your browser; but certain complex objects might still need to be stringified, for example, the response from a long HTTP request.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <code>console</code> object offers many methods to print the information in different formats, which will improve your developer experience a lot. Documentation is available for web browsers (<a href="https://developer.mozilla.org/en-US/docs/Web/API/console">https://developer.mozilla.org/en-US/docs/Web/API/console</a>) and for Node.js (<a href="https://nodejs.org/api/console.html">https://nodejs.org/api/console.html</a>).</p>
			<p>In the next section, we will learn how JavaScript uses constants and variables to store the information that we need when building applications.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Variables and constants</h1>
			<p>We use variables to store<a id="_idIndexMarker089"/> values, and we use constants to store values that will not change. In JavaScript, we can use the <code>let</code> keyword to declare a variable <a id="_idIndexMarker090"/>and the <code>const</code> keyword to declare a constant. Before ES6, we could only use the <code>var</code> keyword to declare variables, but it is not recommended to use it anymore.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Naming conventions</h2>
			<p>In JavaScript, it is very common<a id="_idIndexMarker091"/> to use <em class="italic">camelCase</em> to name variables and constants, but other conventions are supported too, such as <em class="italic">snake_case</em> and <em class="italic">PascalCase</em>. It is also possible to start variables with symbols, but it is<a id="_idIndexMarker092"/> not recommended.</p>
			<p>There are a few limitations that we need to consider when naming variables and constants:</p>
			<ul>
				<li>Avoid starting with a symbol, such as <code>$resource</code></li>
				<li>Don’t start with a number, such as <code>1variable</code></li>
				<li>Don’t use spaces, such as <code>const my variable = 1</code></li>
				<li>Don’t use reserved words, such as <code>const const = "</code><code>constant"</code></li>
			</ul>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>let versus const</h2>
			<p>We use <code>let</code> to declare variables and <code>const</code> to declare constants. The main difference is that we can<a id="_idIndexMarker093"/> reassign a value to a variable, but we cannot <a id="_idIndexMarker094"/>reassign a value to a constant. Here is an example <a id="_idIndexMarker095"/>of reassigning a value to a<a id="_idIndexMarker096"/> variable:</p>
			<pre class="source-code">
let userName = "Joe Doe";
console.log(userName); // Joe Doe
userName = "Jane Doe";
console.log(userName); // Jane Doe</pre>			<p>As we can see here, we cannot reassign a value to a constant:</p>
			<pre class="source-code">
const userName = "Joe Doe";
console.log(userName); // Joe Doe
userName = "mary"; // TypeError: Assignment to constant variable.</pre>			<p>It is important to notice that we can <a id="_idIndexMarker097"/>change the value of a constant if the value<a id="_idIndexMarker098"/> is an object, but we cannot reassign<a id="_idIndexMarker099"/> a new value to the constant:</p>
			<pre class="source-code">
const user = {
  name: "Joe Doe"
}
console.log(user.name); // Joe Doe
user.name = "Jane Doe";
console.log(user.name); // Jane Doe
user = "Mr. Joe"; // TypeError: Assignment to constant variable.</pre>			<p>Later in this chapter, we will <a id="_idIndexMarker100"/>explore objects in more detail, and we will understand these mutations deeper.</p>
			<p>In JavaScript, there is another mechanism that you need to understand. Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase. This is done to optimize the code, but it can have some side effects. You can find a great guide at <a href="https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3">https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3</a>.</p>
			<p>Now that we are clear on how variables and constants work, it is time to explore the different data types available in JavaScript in the next section.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor073"/>Understanding data types</h1>
			<p>In JavaScript, there are<a id="_idIndexMarker101"/> several primitive types. We can group them into two groups: before ES6 (<code>undefined</code>, <code>object</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, and <code>function</code>) and after ES6 (<code>bigint</code> and <code>symbol</code>). In order to check the type of a variable, we can use the <code>typeof</code> operator.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>undefined</h2>
			<p>Not all languages have an <code>undefined</code> type, but JavaScript does. It is used to represent the absence<a id="_idIndexMarker102"/> of a value. It is also used as the default <a id="_idIndexMarker103"/>value for uninitialized variables.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>object</h2>
			<p>The <code>object</code> type is used to<a id="_idIndexMarker104"/> represent a collection of data. It is a very generic type, and<a id="_idIndexMarker105"/> it is used to represent many different things, such as arrays (lists), objects (dictionaries), class instances, and <code>null</code>.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>boolean</h2>
			<p>The <code>boolean</code> type is used to<a id="_idIndexMarker106"/> represent a logical value. It can be either <code>true</code> or <code>false</code>. This type can be <a id="_idIndexMarker107"/>generated by using the <code>Boolean</code>  function too, as everything in JavaScript can be converted to a <code>boolean</code> value.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>number</h2>
			<p>The <code>number</code> type is used to<a id="_idIndexMarker108"/> represent a numeric value. It can be either an<a id="_idIndexMarker109"/> integer or a floating-point number. It is also used to represent special numeric values such as <code>Infinity</code>, <code>-Infinity</code>, and <code>NaN</code> (which stands for Not a Number).</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>string</h2>
			<p>The <code>string</code> type is used to<a id="_idIndexMarker110"/> represent a sequence of characters. It can be created explicitly <a id="_idIndexMarker111"/>by using single quotes (<code>'</code>), double quotes (<code>"</code>), or backticks (<code>`</code>) or implicitly by using the <code>String</code> function or expressions.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>function</h2>
			<p>The <code>function</code> type is used to represent a function. Functions in JavaScript are very powerful. We will explore<a id="_idIndexMarker112"/> them in detail in this chapter. There are two ways to<a id="_idIndexMarker113"/> create a function, by using the <code>function</code> keyword or by using the arrow function syntax.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>bigint</h2>
			<p><code>bigint</code> was introduced<a id="_idIndexMarker114"/> in ES6 in order to work with large numbers. <code>number</code> is limited to <a id="_idIndexMarker115"/>values between -(253 – 1) and 253 – 1</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>symbol</h2>
			<p>The <code>symbol</code> type is used to<a id="_idIndexMarker116"/> represent a unique identifier. It is a new type that was introduced in ES6; you won’t really need to be familiar with it to follow along <a id="_idIndexMarker117"/>with this book.</p>
			<p>In the next section, we will explore numbers in depth, including the Math built-in library, common operators used for comparison, and useful methods for converting numbers and strings.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Exploring numbers</h1>
			<p>JavaScript has good support for mathematical operations and dates, but sometimes it can be tricker and <a id="_idIndexMarker118"/>more limited than other programming languages, so many developers use specialized libraries when the application requires advanced math. For example, if you need to work with vectors, matrices, or complex numbers, you should use a library such as Math.js (<a href="https://mathjs.org/">https://mathjs.org/</a>).</p>
			<p>Here is a typical example of the floating-point precision problem:</p>
			<pre class="source-code">
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false</pre>			<p>As you can see, the result of <code>0.1 + 0.2</code> is not <code>0.3</code>, but <code>0.30000000000000004</code>. This is because JavaScript uses the IEEE 754 standard (<a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a>) to represent numbers, and it is not possible to represent all decimal numbers in binary. This is a common problem in many programming languages; it is not an exclusively JavaScript problem. But you can solve it by using the <code>Number</code> and <code>toPrecision</code> functions as you will implicitly convert from <a id="_idIndexMarker119"/>number to string and then back to number:</p>
			<pre class="source-code">
let impreciseOperation = 0.1 + 0.2;
Number(impreciseOperation.toPrecision(1)) === 0.3; // true</pre>			<p>As you can see, there are some edge cases that are not easy to understand or solve intuitively. Most of the time, you will not need to worry about this, but it is important to know that this problem exists and you can use libraries if you are not experienced enough with numbers in JavaScript.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Arithmetic operators</h2>
			<p>JavaScript has the expected <a id="_idIndexMarker120"/>arithmetic operators, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, and <code>**</code>, and indicates <a id="_idIndexMarker121"/>priority with brackets as in any modern language.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Assignment operators</h2>
			<p>JavaScript has the expected <a id="_idIndexMarker122"/>assignment operators, <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, and <code>**=</code>, as in other languages.</p>
			<p>Also, you can use <code>++</code> and <code>--</code> to increment and <a id="_idIndexMarker123"/>decrement a variable. This operator can be added before or after the variable, and it will change the value of the variable before or after the operation:</p>
			<pre class="source-code">
let a = 5;
console.log(a++); // 5
console.log(a);   // 6
console.log(++a); // 7
console.log(a);   // 7</pre>			<p class="callout-heading">Additional info</p>
			<p class="callout">JavaScript also supports bitwise operations, so you can work with a set of 32 bits (zeros and ones), rather <a id="_idIndexMarker124"/>than decimal, hexadecimal, or octal numbers. You can check out the full documentation here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators</a>.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Useful methods</h2>
			<p>There are methods that are key to <a id="_idIndexMarker125"/>performing mathematical operations or transformations in daily work:</p>
			<ul>
				<li><code>Number.prototype.toFixed()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed</a></li>
				<li><code>Number.prototype.toPrecision()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision</a></li>
				<li><code>Number.parseInt()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt</a></li>
				<li><code>Number.parseFloat()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat</a></li>
			</ul>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>The Math object</h2>
			<p>JavaScript has a built-in <code>Math</code> object <a id="_idIndexMarker126"/>that provides a lot of useful methods to perform mathematical operations. I will list some of them here, but you can find the full list in the MDN documentation (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math</a>).</p>
			<h3>Useful methods</h3>
			<p>There are methods that are key to performing mathematical operations or transformations in daily work:</p>
			<ul>
				<li><code>Math.random()</code>: Returns<a id="_idIndexMarker127"/> a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive) <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random</a></li>
				<li><code>Math.max()</code>: Returns the maximum numeric value among the arguments passed to it  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max</a></li>
				<li><code>Math.min()</code>: Returns the minimum numeric value among the arguments passed to it  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min</a></li>
				<li><code>Math.floor()</code>: Returns the resulting number from rounding a number down to the nearest integer that is less than or equal to the given number <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor</a></li>
			</ul>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Other numbers</h2>
			<p>In JavaScript, there are some special values that are numbers, but they are not real numbers. These values are <code>NaN</code> and <code>Infinity</code>.</p>
			<h3>Not a Number (NaN)</h3>
			<p><code>NaN</code> is a special value that represents Not<a id="_idIndexMarker128"/> a Number. It is the result of an<a id="_idIndexMarker129"/> invalid or undefined mathematical operation, for example, dividing 0 by 0, or multiplying Infinity by 0. You can use <code>isNaN()</code> to check whether a value is <code>NaN</code> (<a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN</a>).</p>
			<h3>Infinity</h3>
			<p><code>Infinity</code> is a special value that represents infinity. It is the result of a mathematical operation that exceeds<a id="_idIndexMarker130"/> the largest possible number. You can use <code>isFinite()</code> to<a id="_idIndexMarker131"/> check whether a value is finite (<a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite</a>).</p>
			<p>In the next section, we will explore dates in depth.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor088"/>Exploring Dates object</h1>
			<p>Dates are a complex topic for any programming language or system as you need to take into account many things, such <a id="_idIndexMarker132"/>as time zones. If you need to work with dates intensively, consider using a library such as Lunox (<a href="https://github.com/moment/luxon/">https://github.com/moment/luxon/</a>) or date-fns (<a href="https://date-fns.org/">https://date-fns.org/</a>).</p>
			<p>For more simple scenarios, you can use the built-in <code>Date</code> object and the Intl API (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl</a>) to format dates.</p>
			<p>The API offers several ways to generate the Date object by using numbers, strings, or several arguments. Also, you have getters and setters to read and modify specific parts, such as the year or milliseconds. It is also possible to perform operations such as comparing or adding time.</p>
			<p>For many years, the only way to format dates in JavaScript was using the <code>toLocaleString()</code> method. This method is still valid, but it has a lot of limitations, specifically, when you want to compare dates in a human-readable way (e.g., <em class="italic">3 days ago</em> or <em class="italic">2 </em><em class="italic">weeks ago</em>).</p>
			<p>In the past, we needed to use external libraries to achieve this, but now we can use the Intl API (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl</a>) to format dates.</p>
			<p>In the following code, you can see how to generate, manipulate, and format dates:</p>
			<pre class="source-code">
const jsDateAnnouncement = new Date(818031600000);
const currentDate = new Date();
const diff = jsDateAnnouncement - currentDate;
const formatter = new Intl.RelativeTimeFormat('en', {
    numeric: 'auto'
});
const diffInDays = Math.round(diff / 86400000);
const diffInYears = Math.round(diffInDays / 365);
const diffInText = formatter.format(diffInDays, 'day');
console.log(`JavaScript was presented to the world ${formatter.format(diffInDays, 'day')}`);
// JavaScript was presented to the world 10,094 days ago
console.log(`JavaScript was presented to the world ${formatter.format(diffInYears, 'year')}`);
// JavaScript was presented to the world 28 years ago.</pre>			<p>The result may vary on your machine as it will have been some time since I wrote this code. Therefore, keep in <a id="_idIndexMarker133"/>mind that the output you observe may differ from mine.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The TC39 is doing a great job at consolidating this API, which includes a lot of features to format dates, numbers, currencies, and more. I recommend you follow the proposal’s progress and implementation in the JavaScript engines.</p>
			<p>In the next section, we will learn how to use conditionals in JavaScript by using several tools that JavaScript provides.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Conditional statements</h1>
			<p>There are many ways to write<a id="_idIndexMarker134"/> conditional statements in JavaScript, but the most common are <code>if</code>, <code>switch</code>, and the ternary operator (<code>?:</code>).</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Math comparison operators</h2>
			<p>For mathematical operations, we have the following operators: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>. They are used to compare<a id="_idIndexMarker135"/> two values and return a <a id="_idIndexMarker136"/>Boolean value. Their use is the same as in most modern programming languages.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Equality operators</h2>
			<p>Equality operators are used to compare <a id="_idIndexMarker137"/>two values and return a Boolean <a id="_idIndexMarker138"/>value. There are two types of equality operators: strict (<code>===</code> and <code>!==</code>) and non-strict (<code>==</code> and <code>!=</code>).</p>
			<p>The strict equality operator cannot be used to compare non-primitive types (such as <code>object</code>, <code>array</code>, and <code>function</code>) and certain values such as <code>NaN</code>, as it will always return <code>false</code>:</p>
			<pre class="source-code">
console.log([1,2] === [1,2]) // false
console.log({ name: 'John' } === { name: 'John' }); // false
console.log(NaN === NaN); // false</pre>			<p>It is not recommended to use non-strict equality operators, as they can lead to unexpected results, because this operator does not check the type of the values:</p>
			<pre class="source-code">
console.log(1 == '1'); // true
console.log(1 != '1'); // false</pre>			<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Logical operators</h2>
			<p>It is possible to combine multiple conditions using logical operators. There are three logical operators, <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>, and some<a id="_idIndexMarker139"/> variations of them, <code>&amp;&amp;=</code> and <code>||=</code>, that are used to reduce the amount of code for certain<a id="_idIndexMarker140"/> operations. We won’t cover them all in this book.</p>
			<p>You can combine operators to build more complex validations:</p>
			<pre class="source-code">
const num = 2
console.log((num == 2) &amp;&amp; (3 &gt;= 6)); // false
console.log((num &gt; 3) || (17 &lt;= 40)); // true</pre>			<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>The NOT operator (!)</h2>
			<p>The NOT operator is used to invert the <a id="_idIndexMarker141"/>value of a Boolean. It will<a id="_idIndexMarker142"/> return <code>true</code> if the value is false, and <code>false</code> if the value is true:</p>
			<pre class="source-code">
console.log(!true); // false
console.log(!false); // true</pre>			<p>This example is not clear about all the possibilities that are offered, so let’s try to build an analogy with a more verbose structure, <code>Boolean(value) === false</code>. Basically, the <code>!</code> operator converts the value to a Boolean and then compares it with a <code>false</code> value.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>Equality in JavaScript</h2>
			<p>Due to the nature of JavaScript, it is <a id="_idIndexMarker143"/>possible to use any value as a condition. The condition will be evaluated as a Boolean, and if the value is truthy, the condition will be <code>true</code>. If the value is falsy, the condition will be <code>false</code>. This can be a bit confusing, so let’s explore the <code>Boolean</code> method to understand how different data values are transformed:</p>
			<pre class="source-code">
// The truthy values:
console.log("String:", Boolean("Ulises")  );
console.log("1235:", Boolean(1235));
console.log("-1235:", Boolean(-1235));
console.log("Object:", Boolean({text: "hi"}));
console.log("Array:", Boolean(["apple", -1, false]));
console.log("Function:", Boolean(function(){}));
console.log("Arrow function:", Boolean(() =&gt; {}));
// The falsy values:
console.log("Empty string:", Boolean("")  );
console.log("0:", Boolean(0));
console.log("-0:", Boolean(-0));
console.log("null:", Boolean(null));
console.log("undefined:", Boolean(undefined));
console.log("NaN:", Boolean(NaN));</pre>			<p>We can conclude easily that empty values (such as <code>null</code>, <code>undefined</code>, an empty string, or <code>NaN</code>) and <code>0</code> are falsy, and values with complex data types (such as objects and functions) or non<a id="_idIndexMarker144"/> empty strings and non-zero numbers are truthy.</p>
			<p>This is quite convenient when we want to check whether a value is empty or not, as in the following example:</p>
			<pre class="source-code">
function checkValue (value) {
    if(!value) {
        throw new Error ("The value is invalid! Try again.")
    }
}</pre>			<p>This Boolean transformation and comparison can turn into a very complex situation if you want to compare different data types and values, for example, <code>Boolean([]) === Boolean({})</code>. You can explore this topic in detail in the MDN documentation (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness</a>). But in general, you don’t need to be an expert in<a id="_idIndexMarker145"/> this area to follow along with this book.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can get a better understanding of this topic by exploring JavaScript Equality Table by Dorey at <a href="https://github.com/dorey/Javascript-Equality-Table/">https://github.com/dorey/Javascript-Equality-Table/</a>.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>The nullish coalescing operator (??)</h2>
			<p>The nullish coalescing operator is a <a id="_idIndexMarker146"/>new operator that<a id="_idIndexMarker147"/> was introduced in ES2020. It is used to check whether a value is <code>null</code> or <code>undefined</code>; if it is, it will return a default value:</p>
			<pre class="source-code">
const name = null ?? "John Joe";
console.log(name); // John Joe</pre>			<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>The if statement</h2>
			<p>The <code>if</code> statement is the most common way <a id="_idIndexMarker148"/>to write a conditional statement. It will<a id="_idIndexMarker149"/> execute the code inside the block if the condition is true. The <code>else</code> statement allows us to follow up when the condition is not met by executing the code that is in the <code>else</code> statement. The <code>else if</code> statement is a variation of the <code>if</code> statement. It will execute the code inside the block if the condition is true. If the condition is false, it will execute the code inside the <code>else</code> block. You can add as many <code>else if</code> statements as you need:</p>
			<pre class="source-code">
const condition = true
const condition2 = true
if(condition) {
    console.log("The condition is true")
} else if (condition2) {
    console.log("The condition2 is true")
} else {
    console.log("The condition and condition2 are false")
}</pre>			<p>You can change the values in <code>condition</code> and <code>condition2</code> in order to get more familiar with the <a id="_idIndexMarker150"/>behavior of the conditional structures.</p>
			<h3>return usage</h3>
			<p>The <code>return</code> statement is widely <a id="_idIndexMarker151"/>used to avoid using <code>else</code> statements and allows for cleaner code. Here is an example:</p>
			<pre class="source-code">
const condition = true;
if(condition) {
    return console.log("The condition is true");
}
console.log("The condition is false");</pre>			<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>The switch statement</h2>
			<p>The <code>switch</code> statement is a good option<a id="_idIndexMarker152"/> when you want to compare a variable against multiple values. It is good when you want to assign a value to a variable depending on a condition.</p>
			<p>The <code>switch</code> structure is composed <a id="_idIndexMarker153"/>of the <code>switch</code> keyword, followed by the variable that you want to compare, and then a block of <code>case</code> statements. Each <code>case</code> statement is composed of the <code>case</code> keyword, followed by the value that you want to compare, "and then a double colon (:). After the double colon," you can write the code that you want to execute if the condition is true. The <code>default</code> statement is optional, and it will be executed if none of the <code>case</code> statements are true, like <code>else</code> when using <code>if</code> statements.</p>
			<p>The <code>break</code> statement is used to stop the execution of the <code>switch</code> statement. If you don’t add the <code>break</code> statement, the code will continue executing the next <code>case</code> statement. Here we have a <a id="_idIndexMarker154"/>combined example:</p>
			<pre class="source-code">
const extension = ".md";
switch (extension) {
  case ".doc":
    console.log("This extension .doc will be deprecated soon")
  case ".pdf":
  case ".md":
  case ".svg":
    console.log("Congratulations! You can open this file");
    break;
  default:
    console.log(`${extension} is not supported`);
}</pre>			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Ternary operator</h2>
			<p>The ternary operator is shorthand for the <code>if</code> and <code>else</code> statements. It is a good option when you want to assign a value to a variable depending on a condition.</p>
			<p>The structure is composed of the condition, followed by a question mark, <code>?</code>, then the value that you want to assign if the <a id="_idIndexMarker155"/>condition is true, followed <a id="_idIndexMarker156"/>by a double colon (:), and then the value that you want to assign if the condition is false: <code>condition ? valueIfTrue : </code><code>valueIfFalse</code>.</p>
			<p>Let’s see an example with the <code>if</code> and <code>else</code> statements:</p>
			<pre class="source-code">
const isMember = true;
console.log(`The payment is ${isMember ? "20.00€" : "50.00€"}`);
// The payment is 20.00€</pre>			<p>The ternary operator can nest multiple ternary operators, but it is not recommended because it can be extremely difficult to read. Also, it is possible to use the ternary operator to do multiple <a id="_idIndexMarker157"/>operations, but it is not recommended because it can be extremely <a id="_idIndexMarker158"/>difficult to read even if you use parentheses.</p>
			<p>Now that we are clear on how conditional structures work in JavaScript, it is time to explore loops in the next section.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor099"/>Understanding loops</h1>
			<p>There are many ways to create loops in JavaScript, but the most common are the <code>for</code> and <code>while</code> statements and variations of them that are specific to arrays and objects. Also, functions in JavaScript can be used to create loops when using recursion. In this section, we will look at only the <code>for</code>, <code>while</code>, and <code>do...while</code> statements.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>while</h2>
			<p>The <code>while</code> statement creates a loop<a id="_idIndexMarker159"/> that executes a block of code as long as the <a id="_idIndexMarker160"/>condition is true. The condition is evaluated before executing the block of code:</p>
			<pre class="source-code">
let i = 1;
while (i &lt;= 10) {
    console.log(i);
    i++;
};</pre>			<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>do...while</h2>
			<p>The <code>do...while</code> statement creates a<a id="_idIndexMarker161"/> loop that executes a block of code at least once<a id="_idIndexMarker162"/> even if the condition is not met, and then repeats the loop as long as the condition is true. The condition is evaluated after executing the block of code:</p>
			<pre class="source-code">
let i = 0;
do {
    console.log(`i value: ${i}`);
    i++;
} while (false);
// i value: 0</pre>			<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>for</h2>
			<p>The <code>for</code> statement creates a loop that consists <a id="_idIndexMarker163"/>of three optional expressions, enclosed in parentheses and<a id="_idIndexMarker164"/> separated by semicolons, followed by a statement executed in the loop:</p>
			<pre class="source-code">
for (let i = 0; i &lt; 10; i++) {
    console.log(i);
}</pre>			<p>The first expression is executed before the loop starts. Usually, it is used to initialize the variable that will act as counter.</p>
			<p>The second expression is the condition that is evaluated before executing the block of code. If the condition is true, the block of code is executed. If the condition is false, the loop stops.</p>
			<p>The third expression is executed after the block of code is executed. Usually, it is used to increment or decrement the counter variable.</p>
			<p>This structure is quite flexible, and some developers tend to abuse it. Let’s see an example with bad readability:</p>
			<pre class="source-code">
for (let i = 0, x = 1, z = 2, limit = 10; i &lt;= limit; x *= z, i++ ) {
    console.log(`i: ${i}. x: ${x}. z: ${z}`);
}
// i: 0. x: 1. z: 2
// ...
// i: 10. x: 1024. z: 2</pre>			<p>The readability issues are due to the large number of variables defined and updated in the <code>for</code> loop. It is important to<a id="_idIndexMarker165"/> remember that we write code that other <a id="_idIndexMarker166"/>programmers can understand in the future. Let’s see the same code<a id="_idIndexMarker167"/> with a more readable approach:</p>
			<pre class="source-code">
let x = 1;
const z = 2, limit = 10;
for (let i = 0; i &lt;= limit; i++ ) {
    console.log(`i: ${i}. x: ${x}. z: ${z}`);
    x *= z
}</pre>			<p>You can already notice the difference; it takes less time and effort to understand it. In the next section, we will learn how to use strings.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Using strings in JavaScript</h1>
			<p>Strings are primitive values. They are <a id="_idIndexMarker168"/>a sequence of characters. There are three ways to create strings in JavaScript: using single quotes, <code>'</code>, double quotes, <code>"</code>, or backticks, <code>`</code>.</p>
			<pre class="source-code">
console.log('Hello World');
console.log("Hello World");
console.log(`Hello World`);</pre>			<p>Strings are immutable, which means <a id="_idIndexMarker169"/>that once they are created, they cannot be modified, but you can overwrite the variables or references depending on the data structure. So, all the methods that you use to modify a string will return a new string (or array):</p>
			<p>Template strings allow you to use placeholders, <code>${}</code>, to insert variables or expressions inside a str<a id="_idTextAnchor104"/>ing. There is also added support for multiple lines:</p>
			<pre class="source-code">
const name = "John";
console.log(`Hello ${name}!`) //Hello John!</pre>			<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Important methods</h2>
			<p>There are many ways to perform operations with strings, but in this section, we will see only the most important <a id="_idIndexMarker170"/>methods that you will use in your day-to-day work:</p>
			<ul>
				<li><code>String.prototype.indexOf()</code>: Finds the index of the first occurrence of a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf</a></li>
				<li><code>String.prototype.lastIndexOf()</code>: Finds the index of the last occurrence of a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf</a></li>
				<li><code>String.prototype.search()</code>: Searches for a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search</a></li>
				<li><code>String.prototype.includes()</code>: Determines whether one string contains another string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes</a></li>
				<li><code>String.prototype.match()</code>: Extracts matches of a regular expression pattern from a string <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match</a></li>
				<li><code>String.prototype.matchAll()</code>: Returns an iterator that yields all matches of a regular expression against a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll</a></li>
				<li><code>String.prototype.split()</code>: Splits a string into an array of substrings based on a specified separator  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split</a></li>
				<li><code>String.prototype.slice()</code>: Extracts a<a id="_idIndexMarker171"/> section of a string and returns it as a new string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice</a></li>
				<li><code>String.prototype.trim()</code>: Removes whitespace characters from both ends of a string <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim</a></li>
				<li><code>String.prototype.replace()</code>: Finds and replaces substrings within a string <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace</a></li>
			</ul>
			<p>In the next section, we will learn how to use arrays, one of the most versatile data structures in JavaScript.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor106"/>Exploring arrays</h1>
			<p>Arrays are non-primitive values; they are a collection of values. The values can be any type of value, including other arrays. Arrays<a id="_idIndexMarker172"/> are mutable, which means that you can modify them and the changes will be reflected in the original array.</p>
			<p>Arrays are zero-indexed, which means that the first element is at index 0, the second element is at index 1, and so on.</p>
			<p>The <code>Array.isArray()</code> method determines whether the passed value is an array:</p>
			<pre class="source-code">
const array = [1, 2, 3];
console.log(Array.isArray(array)); // true
const object = { name: "Ulises" };
console.log(Array.isArray(object)); // false
console.log(typeof array); // object
console.log(typeof object); // object
console.log("are object and array the same type?", typeof(array) === typeof(object)); // true</pre>			<p>As arrays are objects, you <a id="_idIndexMarker173"/>need to be careful because they can’t be compared with the <code>===</code> or <code>==</code> operator, because it will compare the references, not the values:</p>
			<pre class="source-code">
const array1 = [1, 2, 3];
const array2 = [1, 2, 3];
console.log(array1 === array2); // false</pre>			<p>Arrays have a <code>length</code> property that returns the number of elements in the array and provides an easy way to iterate over the array.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Basic operations</h2>
			<p>In this section, we will look at the <a id="_idIndexMarker174"/>most common operations that you will perform with arrays.</p>
			<h3>Creating an array</h3>
			<p>There are many ways<a id="_idIndexMarker175"/> to create an array in JavaScript. The most common is using the array literal notation, <code>[]</code>, but you can also create an array from other data types, such as when you split a string, or using the <code>string.prototype.split()</code> method. The following is an example of creating an array using the array literal notation:</p>
			<pre class="source-code">
const emptyArray = [];
const numbers = [1, 2, 3];
const strings = ["Hello", "World"];
const mixed = [1, "Hello", true];</pre>			<p>The <code>Array.of()</code> method creates a new array instance from a variable number of arguments, regardless of the number or type of the arguments:</p>
			<pre class="source-code">
<code>const array = Array.of( 1, 2, 3 );</code></pre>			<p>The <code>Array.from()</code> method <a id="_idIndexMarker176"/>creates a new array instance from an array-like or iterable object:</p>
			<pre class="source-code">
console.log(Array.from('packt'));   // ['p', 'a', 'c', 'k', 't']</pre>			<p>The spread operator, <code>...</code>, can be used to create a new array from an existing array or from a string:</p>
			<pre class="source-code">
console.log([...[1, 2, 3]]);    // [1, 2, 3]
console.log([...'packt']);      // ['p', 'a', 'c', 'k', 't']</pre>			<p>Also, you can pass a map function as a second parameter so you can perform transformations when the array is created:</p>
			<pre class="source-code">
console.log(Array.from([1, 2, 3], x =&gt; x + x)); // [2, 4, 6]</pre>			<h3>Accessing items</h3>
			<p>You can access an item in an<a id="_idIndexMarker177"/> array using the index of the item:</p>
			<pre class="source-code">
const fruits = ['banana', 'apple', 'orange'];
console.log(fruits[0]); // banana
console.log(fruits[1]); // apple
console.log(fruits[2]); // orange</pre>			<h3>Replacing items</h3>
			<p>You can replace an item in an <a id="_idIndexMarker178"/>array using the index of the item:</p>
			<pre class="source-code">
const fruits = ['banana', 'apple', 'orange'];
fruits[0] = 'pear';
console.log(fruits); // ['pear', 'apple', 'orange']</pre>			<h3>Adding items</h3>
			<p>You can add items to an <a id="_idIndexMarker179"/>array using two main methods:</p>
			<ul>
				<li><code>Array.prototype.push()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push</a></li>
				<li><code>Array.prototype.unshift()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift</a></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">It is always preferable to add new items to the end of the array, because adding items to the beginning of the array is an expensive operation. This is because it requires re-indexing all the items in the array.</p>
			<h3>Removing items</h3>
			<p>There are several methods that <a id="_idIndexMarker180"/>allow you to remove items from the array:</p>
			<ul>
				<li><code>Array.prototype.pop()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop</a></li>
				<li><code>Array.prototype.shift()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift</a></li>
				<li><code>Array.prototype.splice()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice</a></li>
			</ul>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor108"/>Iterating over an array</h2>
			<p>As we saw at the beginning of<a id="_idIndexMarker181"/> this chapter, it is possible to iterate over an array using a <code>for</code> loop, but there are also other ways to iterate over an array.</p>
			<p>JavaScript provides great support for declarative programming, which is especially useful when you need to iterate over arrays. So, let’s summarize the most common ways to iterate over an array.</p>
			<p>Most of these methods receive a function as a parameter, and it is executed for each item in the array. Depending on the method used and  the data returned from the function  will get one result or another.</p>
			<p>Another important thing to remember is that these methods can be chained together, so you can use one method after another and compose more complex operations.</p>
			<h3>Iteration</h3>
			<p>As arrays can store a lot of elements, it is <a id="_idIndexMarker182"/>important to get familiar with the methods that are provided by the array in order to properly iterate over them. The most common are <code>Array.prototype.map()</code> and <code>Array.prototype.forEach()</code>. In both cases, we will iterate over the array, but <code>Array.prototype.map()</code> will directly return a new array with the applied transformation. Let’s see an example comparing both methods:</p>
			<pre class="source-code">
const numbers = [1, 2, 3, 4, 5]
const mapTransformation = numbers.map(el =&gt; el * 10)
const forEachTransformation = []
numbers.forEach(el =&gt; {
    forEachTransformation.push(el * 10)
})
console.log(mapTransformation) // 10,20,30,40,50
console.log(forEachTransformation) // 10,20,30,40,50</pre>			<h3>Validation</h3>
			<p>As arrays can contain any type of data, it is<a id="_idIndexMarker183"/> common to need to validate whether an array contains a specific item or whether all the items in the array match a condition. There are several methods, but the most common are as follows:</p>
			<ul>
				<li><code>Array.prototype.every()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every</a></li>
				<li><code>Array.prototype.some()</code>:<a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some"> https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some</a></li>
				<li><code>Array.prototype.includes()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes</a></li>
			</ul>
			<h3>Filtering</h3>
			<p>Arrays can store a<a id="_idIndexMarker184"/> lot of information, and it is quite common to store nested structures such as big objects. There are many ways to do filtering in JavaScript. The most important difference between them is what your expected output is as sometimes we will be interested in a new array with the filtered values, but other times we might want the position (index) of certain elements in the array. The most used method is <code>Array.prototype.filter()</code>, which is used to generate a new array with the elements that pass certain criteria. Let’s see an example:</p>
			<pre class="source-code">
const numbers = [1, 2, 3, 4, 5]
const filteredNums = numbers.filter(el =&gt; el &lt;= 3)
console.log(filteredNums) // [1, 2, 3]</pre>			<p>There are several methods that you will find relevant in this category:</p>
			<ul>
				<li><code>Array.prototype.slice()</code>: Returns the copy of a portion of the array <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a></li>
				<li><code>Array.prototype.find()</code>: Returns the value of the first item in the array that satisfies the <a id="_idIndexMarker185"/>provided criteria <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find</a></li>
				<li><code>Array.prototype.findIndex()</code>: Returns the index of the first item in the array that satisfies the criteria <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex</a></li>
			</ul>
			<h3>Utilities</h3>
			<p>Sometimes you need to flatten<a id="_idIndexMarker186"/> an array of arrays. You can use the <code>array.flat()</code> method to do that:</p>
			<pre class="source-code">
const data = [1, [2, 3], [4, 5]];
const flatData = data.flat();
console.log(flatData); // [1, 2, 3, 4, 5]</pre>			<p>Another common method is the <code>array.join()</code> method, which is used to join all the items in an array into a string:</p>
			<pre class="source-code">
const people = ['Joe', 'Jane', 'John', 'Jack'];
console.log(people.join()); // Joe,Jane,John,Jack
console.log(people.join(' + ')); // Joe + Jane + John + Jack</pre>			<p>This is very useful when you need to create a string with a list of items, for example, when you need to create a list of items in HTML, XML, Markdown, and so on:</p>
			<pre class="source-code">
const people = ['Joe', 'Jane', 'John', 'Jack'];
const structuredPeople = people.map(person =&gt; `&lt;li&gt;${person}&lt;/li&gt;\n`);
console.log(`
    &lt;ul&gt;
        ${structuredPeople.join('')}
    &lt;/ul&gt;
`)
// &lt;ul&gt;
//     &lt;li&gt;Joe&lt;/li&gt;
//      ...
// &lt;/ul&gt;</pre>			<p>While working with data, it is very<a id="_idIndexMarker187"/> common that we need to sort the items in the array. This can be done with <code>array.sort()</code>. In general, it is better if we provide a function that specifies how to properly sort the items just to avoid unexpected results. Let’s see an example:</p>
			<pre class="source-code">
const numbers = [7, 1,10, 3,15,20]
console.log(numbers.sort())
// [1, 10, 15, 20, 3, 7]
console.log(numbers.sort((a, b) =&gt; a - b))
// [1, 3, 7, 10, 15, 20]</pre>			<p>There are several methods that are quite useful and you will find yourself using very frequently:</p>
			<ul>
				<li><code>Array.prototype.reverse()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse</a></li>
				<li><code>Array.prototype.concat()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat</a></li>
				<li><code>Array.prototype.fill()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill</a></li>
				<li><code>Array.prototype.reduce()</code>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce</a></li>
			</ul>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Destructuring</h2>
			<p>ES6 introduced a new syntax for destructuring arrays and objects. The left-hand side of an assignment is now a<a id="_idIndexMarker188"/> pattern for extracting values from arrays and objects. This pattern can be used in variable declarations, assignments, function parameters, and function return values. Also, you can use default values (fail-soft) in case the value is not present in the array.</p>
			<p>In the following code sample, we can see the classic way to do a fail-soft:</p>
			<pre class="source-code">
const list = [1, 2];
const a = list[0] || 0; // 1
const b = list[1] // 2
const c = list[2] || 4; // 4</pre>			<p>The following snippet contains the same code but using ECMAScript 6 destructuring:</p>
			<pre class="source-code">
const list = [1, 2];
const [ a = 0, b, c = 4 ] =<a id="_idTextAnchor110"/> list;</pre>			<p>As you can see, this version is more compact. Currently, this is the more popular way to assign default values when it is possible to combine it with destructuring.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor111"/>Sets</h2>
			<p>ES6 introduces a new data structure called <code>Set</code>. A Set is a collection of values, where each value may occur only once. It can be <a id="_idIndexMarker189"/>used to store a collection of values, but it is not an array as it doesn’t have indexes. It is quite a common solution to remove duplicate values from an array, as we can see in the following code:</p>
			<pre class="source-code">
let arr = [1,2,2,3,1,4,5,4,5]
let set = new Set(arr)
let uniques = Array.from(set)
console.log(uniques) // [1,2,3,4,5]</pre>			<p>You can find more information about set-specific methods at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a>.</p>
			<p>In the next section, we will learn how to use objects, one of the most powerful data structures in JavaScript.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor112"/>Using objects in JavaScript</h1>
			<p>Objects are non-primitive values; they are <a id="_idIndexMarker190"/>a collection of properties. A property is a key-value pair. The key is always a string, and the value can be any type of value, including other objects.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Basic operations</h2>
			<p>Objects are the most versatile<a id="_idIndexMarker191"/> structure in JavaScript. In this section, we will learn how to create objects, how to access and modify their properties, and how to iterate over the properties of an object.</p>
			<h3>Creating an object</h3>
			<p>You can create an object using <a id="_idIndexMarker192"/>the object literal syntax, that is, using curly braces:</p>
			<pre class="source-code">
const person = {}</pre>			<p>You can also create an object and directly add properties:</p>
			<pre class="source-code">
const person = {
    name: 'Jane',
}</pre>			<p>You can store any type of value in an object, including other objects or functions (methods):</p>
			<pre class="source-code">
const person = {
    name: 'Jane',
    id: 1,
    favoriteColors: ['blue', 'green'],
    address: {
        street: 'Main St',
        number: 1,
    },
    fullName: function() {
        return `${this.name} Doe`
    },
    sayHi: function() {
        console.log('Hello!')
    }
}
console.log(person.fullName()) // Jane Doe
person.sayHi() // Hello!
console.log(person.address.street) // Main St
console.log(person.id) // 1
console.log(person.favoriteColors[0]) // blue</pre>			<h3>Creating and accessing properties</h3>
			<p>You can create a new <a id="_idIndexMarker193"/>property or overwrite existing ones in an object by assigning a<a id="_idIndexMarker194"/> value:</p>
			<pre class="source-code">
const person = {
    id: 12
}
person.name = 'Jane'
console.log(person.name) // Jane
person.id = 1
console.log(person.id) // 1</pre>			<p>You can also access the properties of an object using the bracket notation, which is useful when using programmatic access or when using keys with special characters or whitespaces:</p>
			<pre class="source-code">
const person = {
    id: 12
}
console.log(person['id']) // 12
const specialKey = 'first name with spaces'
person[specialKey] = 'Jane'
console.log(person[specialKey]) // Jane</pre>			<h3>Deleting properties</h3>
			<p>You can delete a property <a id="_idIndexMarker195"/>from an object using the <code>delete</code> operator or overwrite it to <code>undefined</code>:</p>
			<pre class="source-code">
const person = {
    id: 12,
    name: 'Jane'
}
delete person.id
person.name = undefined
console.log(person.id) // undefined
console.log(person.name) // undefined</pre>			<h2 id="_idParaDest-110"><a id="_idTextAnchor114"/>Iteration</h2>
			<p>Let’s see how to iterate over<a id="_idIndexMarker196"/> the properties of an object, and how to get an array with the keys and values of an object.</p>
			<p>This is our base object:</p>
			<pre class="source-code">
const users = {
    admin: 'Jane',
    moderator: 'Joe',
    user: 'Billy',
}</pre>			<p>You can iterate over the properties of an object using the <code>for...in</code> loop:</p>
			<pre class="source-code">
for (let role in users) {
    console.log(`${users[role]} is the ${role}`)}
// Jane is the admin
// Joe is the moderator
// Billy is the user</pre>			<p>You can also use the <code>Object.keys()</code> method to get an array with the keys of an object, so you can use array-specific methods<a id="_idIndexMarker197"/> to manage the iteration, such as <code>array.prototype.forEach()</code>:</p>
			<pre class="source-code">
const roles = Object.keys(users)
console.log(roles) // ['admin', 'moderator', 'user']
roles.forEach(role =&gt; {
    console.log(role) // admin
    console.log(users[role]) // Jane
})</pre>			<p>You can also use additional methods introduced recently in the language:</p>
			<ul>
				<li><code>Object.values()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values</a></li>
				<li><code>Object.entries()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries</a></li>
			</ul>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor115"/>Shallow copy versus deep copy</h2>
			<p>The way JavaScript works means<a id="_idIndexMarker198"/> that sometimes we don’t get the expected copy of a variable. Let’s see a simple example:</p>
			<pre class="source-code">
const name = "Jane"
const number = 1
const array = [1, 2, 3]
const object = { id: 1, name: 'Jane' }
// Copy
let nameCopy = name
let numberCopy = number
const arrayCopy = array
const objectCopy = object
// Modify the copy
nameCopy = 'Joe'
numberCopy = 2
arrayCopy.push("additional item")
objectCopy.name = 'Joe'
// Check the original
console.log(name) // Jane
console.log(nameCopy) // Joe
console.log(number) // 1
console.log(numberCopy) // 2
console.log(array) // [1, 2, 3, "additional item"]
console.log(arrayCopy) // [1, 2, 3, "additional item"]
console.log(object) // { id: 1, name: 'Joe' }
console.log(objectCopy) // { id: 1, name: 'Joe' }</pre>			<p>This is quite a specific behavior of JavaScript that frustrates many developers. How is it possible that the original variable is modified when we modify the copy? The answer is that <a id="_idIndexMarker199"/>we are not copying the variable (<em class="italic">deep copy</em>) in all the scenarios; we are copying the reference to the variable (<em class="italic">shallow copy</em>).</p>
			<p>Only the primitive types (<em class="italic">string, number, Boolean, null, undefined, </em>and <em class="italic">symbol</em>) are copied by value; the rest are copied by reference, so you actually get a reference to the original variable, like a shortcut.</p>
			<p>This allows you to do some interesting things, such as  create shortcut references for very nested objects:</p>
			<pre class="source-code">
const data = {item: {detail: { reference: {id: '123'} }}}
// make a shortcut reference
const ref = data.item.detail.reference
ref.name = 'Jane'
// check the original
console.log(data.item.detail.reference) // {id: '123', name: 'Jane'}</pre>			<p>But, as you can see, this can lead to changes in the original object. This can be an unexpected behavior if <a id="_idIndexMarker200"/>we are not clear how the original structure was copied. It can be trickier to detect if you are using nested structures.</p>
			<p>If you want to get a deep copy of a simple object, you can use <code>Object.assign()</code> or the spread operator, <code>...</code>:</p>
			<pre class="source-code">
const array = [1, 2, 3]
const object = { id: 1, name: 'Jane' }
// Copy
const arrayCopy = [...array]
const objectCopy = Object.assign({}, object)
// Modify the copy
arrayCopy.push("additional item")
objectCopy.name = 'Joe'
// Check the original
console.log(array) // [1, 2, 3]
console.log(arrayCopy) // [1, 2, 3, "additional item"]
console.log(object) // { id: 1, name: 'Jane' }
console.log(objectCopy) // { id: 1, name: 'Joe' }</pre>			<p>But the nested objects<a id="_idIndexMarker201"/> will be copied by reference, so you will get the same behavior as before:</p>
			<pre class="source-code">
const data = [{ 'a': 1 }, { 'b': 2 }];
const shallowCopy = [...data];
shallowCopy[0].a = 3;
console.log(data[0].a); // 3
console.log(shallowCopy[0].a); // 3</pre>			<p>An alternative is to use a specialized library such as Lodash (<a href="https://lodash.com/docs/4.17.15#cloneDeep">https://lodash.com/docs/4.17.15#cloneDeep</a>) or transform it into JSON and digest the structure, but this has some limitations, such as not being able to copy functions or items that are not defined in the JSON specs (<a href="https://datatracker.ietf.org/doc/html/rfc7159">https://datatracker.ietf.org/doc/html/rfc7159</a>).</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Merging objects</h2>
			<p>Merging two objects can be done with <code>Object.assign</code>, but you need to understand two things:</p>
			<ul>
				<li>The order is important, so<a id="_idIndexMarker202"/> the first item will be overwritten by the next item when they share common properties</li>
				<li>If the objects are complex data structures such as nested objects or arrays, then the final object will copy the references (shallow copy)</li>
			</ul>
			<p>Let’s see an example:</p>
			<pre class="source-code">
const dst  = { quux: 0 }
const src1 = { foo: 1, bar: 2 }
const src2 = { foo: 3, baz: 4 }
Object.assign(dst, src1, src2)
console.log(dst) // {quux: 0, foo: 3, bar: 2, baz: 4}</pre>			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Destructuring</h2>
			<p>Since ES6, JavaScript has provided<a id="_idIndexMarker203"/> destructuring assignment for objects, which is very handy for extracting and including values in objects. Let’s see an example with a simple object:</p>
			<pre class="source-code">
const name = "Jane";
const age = 25;
const data = { item: "Lorem Ipsum", status: "OK" };</pre>			<p>If we didn’t use destructuring, we would have to do something like this:</p>
			<pre class="source-code">
const user = {
  name: name,
  age: age,
  data: data,
};
const item = data.item;
const status = data.status;</pre>			<p>But with destructuring, we can do it in a more concise way:</p>
			<pre class="source-code">
const user = { name, age, data };
const { item, status } = data;</pre>			<h2 id="_idParaDest-114"><a id="_idTextAnchor118"/>Optional chaining (?.)</h2>
			<p>The optional chaining operator is a new operator introduced in ES2020. It allows you to access deeply nested properties <a id="_idIndexMarker204"/>of an object without worrying about whether the <a id="_idIndexMarker205"/>property exists or not. Before the optional chaining operator, you had to check whether the property exists before accessing it. This was quite tedious for very nested structures. Let’s see a practical example:</p>
			<pre class="source-code">
const user = {
  name: "John",
  address: {
    street: "Main Street",
  },
};
const otherUser = {
  name: "Jane",
};
console.log(user.address?.street); // Main Street
console.log(otherUser.address?.street); // undefined
// without optional chaining:
console.log(user.address.street); // Main Street
console.log(otherUser.address.street); // TypeError: Cannot read properties of undefined (reading 'street')</pre>			<p>Now that we are familiar <a id="_idIndexMarker206"/>with most of the data structures, it is time to explore functions in the next section.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor119"/>Exploring functions</h1>
			<p>Functions are one of the more meaningful structures in JavaScript. There are certain characteristics that make them different from other programming languages; for example, they are<a id="_idIndexMarker207"/> first-class citizens, which means that they can be assigned to a variable, passed as an argument to another function, or returned from another function.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>The basics</h2>
			<p>There are many advanced <a id="_idIndexMarker208"/>concepts related to functions, but in this section, we will just look at the basics of functions in JavaScript. We will start with the declaration, execution, and arguments using the <code>function</code> keyword. Then, we will focus on<a id="_idIndexMarker209"/> arrow functions and closures.</p>
			<h3>Declaration</h3>
			<p>In essence, a function is a<a id="_idIndexMarker210"/> block of code that can be executed when it is called. In JavaScript, we can declare a function using the <code>function</code> keyword. The syntax is the following:</p>
			<pre class="source-code">
function myFunction() {
  console.log("This is a function body")
  // code to be executed
}</pre>			<h3>Execution</h3>
			<p>The function is not executed when it is declared; it is executed when it is called. To call a function, we just need to<a id="_idIndexMarker211"/> write the name of the function followed by parentheses. Take the following example:</p>
			<pre class="source-code">
const myFunction = function() {
  console.log("This is a function body")
  // code to be executed
}
myFunction() // This is a function body</pre>			<h3>Anonymous functions</h3>
			<p>Functions can also be declared as a function<a id="_idIndexMarker212"/> expression. This is known as anonymous functions. A simple example is when we pass the function as an argument to another function, like when we use timers – <code>setTimeout</code>, in this case:</p>
			<pre class="source-code">
setTimeout(function() {
    console.log('1 second later')
}, 1000);</pre>			<h3>Return values</h3>
			<p>A function can return a value using the <code>return</code> keyword. This value can be assigned to a variable or used in <a id="_idIndexMarker213"/>another function. Take the following example:</p>
			<pre class="source-code">
function isEven(number) {
  return number % 2 === 0
}
const result = isEven(2)
const otherResult = isEven(3)
console.log(result) // true
console.log(otherResult) // false</pre>			<h3>Arguments</h3>
			<p>Functions can receive<a id="_idIndexMarker214"/> arguments; these arguments are passed to the function when it is called. Take the following example:</p>
			<pre class="source-code">
function sayHi (name) {
  console.log(`Hi ${name}!`);
};
sayHi('John'); // Hi John!</pre>			<p>You don’t need to specify the arguments; you can use the rest operator (<code>...</code>) to access the arguments. In this example, we will sum all the numbers passed to the function:</p>
			<pre class="source-code">
function sum (...numbers) {
  console.log("First Number:", numbers[0])
  console.log("Last Number:", numbers[numbers.length - 1])
  let total = 0
  for (let number of numbers) {
    total += number
  }
  console.log("Total (SUM):", total)
}
const result = sum(1, 2, 3, 4, 5)
// First Number: 1
// Last Number: 5
// Total (SUM): 15</pre>			<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Arrow functions</h2>
			<p>One of the most important<a id="_idIndexMarker215"/> features introduced in ES6 is arrow functions. They are a new syntax for writing JavaScript functions, but they also introduce certain changes that <a id="_idIndexMarker216"/>are important to be aware of:</p>
			<ul>
				<li>Arrow functions introduce a new syntax for writing functions</li>
				<li>Arrow functions are always anonymous</li>
			</ul>
			<h3>Syntax</h3>
			<p>Since the beginning of JavaScript, we <a id="_idIndexMarker217"/>declared functions using the <code>function</code> keyword, as in the following example:</p>
			<pre class="source-code">
const sampleFunction = function () { }
const sayHelloNow = function (name) {
  const now = new Date()
  console.log(`Hello ${name}, at ${now}!`)
}</pre>			<p>The new syntax for writing arrow functions uses <code>=&gt;</code> and does not use the <code>function</code> keyword. The following<a id="_idIndexMarker218"/> example is the same as the previous one but with the new syntax:</p>
			<pre class="source-code">
const sampleFunction = () =&gt; {}
const sayHelloNow = name =&gt; {
  const now = new Date()
  console.log(`Hello ${name}, at ${now}!`)
}</pre>			<p>The new syntax has an implicit return, so if you want to return a value, you can do it without using the <code>return</code> keyword:</p>
			<pre class="source-code">
const alwaysTrue = () =&gt; true
const getData = (name, age) =&gt; ({ name: "John", age: 25 })</pre>			<p>The previous example can be translated to the previous syntax as follows:</p>
			<pre class="source-code">
const alwaysTrue = function () { return true }
const getData = function (name, age) {
  return { name: "John", age: 25 }
}</pre>			<p>Arrow functions can receive arguments, but if you want to receive more than one argument, you need to use parentheses:</p>
			<pre class="source-code">
const sum = function (a, b) { return a + b }
// Arrow function translation
const sum = (a, b) =&gt; a + b</pre>			<h3>Behavior changes</h3>
			<p>Due to the fact that JavaScript has retro compatibility with older versions, arrow functions introduce certain changes in the behavior of the functions. The most important one is related to the <code>this</code> keyword.</p>
			<p>Also, arrow functions do not <a id="_idIndexMarker219"/>have a <code>prototype</code> property, which means that they cannot be used as constructors or method handlers.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The management of <code>this</code> in JavaScript can be a bit confusing and is quite advanced for the objectives of this book. If you want to learn more about it, you can read the MDN documentation: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</a>.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Closures</h2>
			<p>This is one of the most popular and<a id="_idIndexMarker220"/> important concepts in JavaScript, but it is a bit advanced, and it is not easy to understand.</p>
			<h3>So, what is a closure?</h3>
			<p>Basically, a closure is a function<a id="_idIndexMarker221"/> returned by another function. Here, we have an example:</p>
			<pre class="source-code">
const outerFunction = function () {
  console.log("This is the outer function")
  const innerFunction = function () {
    console.log("This is the inner function")
  }
  return innerFunction
}</pre>			<p>In this example, <code>outerFunction</code> returns <code>innerFunction</code>, so we can call <code>innerFunction</code> after calling <code>outerFunction</code>:</p>
			<pre class="source-code">
const innerFunction = outerFunction() // This is the outer function
innerFunction() // This is the inner function</pre>			<p>Now, let’s achieve the same<a id="_idIndexMarker222"/> result using less code by doing both executions in the same statement:</p>
			<pre class="source-code">
// Execution in single line
outerFunction()()</pre>			<h3>But how is this useful?</h3>
			<p>The most important thing about<a id="_idIndexMarker223"/> closures is that they can access and even modify the scope of the parent function (code block and arguments), even after the parent function has returned. Let’s see a practical example:</p>
			<pre class="source-code">
const createCounter = (initialValue = 0) =&gt; {
  let counter = initialValue
  return (incrementalValue) =&gt; {
    counter += incrementalValue
    console.log(counter)
  }
}</pre>			<p>In this example, we added the <code>initialValue</code> and <code>incrementalValue</code> arguments to the functions, and also, we defined the <code>counter</code> variable to store the counter’s current value. In practice, we can use this function to create a counter that starts from a specific value, and then we can increment it by a specific value. We can’t access the <code>counter</code> variable directly because it lives only in the scope within the function and not outside, but we can use the closure to access it and even manipulate<a id="_idIndexMarker224"/> the value:</p>
			<pre class="source-code">
const addToCounter = createCounter(10)
addToCounter(12) // 22
addToCounter(1)  // 23</pre>			<p>In this example, we saw the basic usage of closures, but they can be used for many other things. One of the most common usages is to create abstractions to manage third-party services such as databases and APIs.</p>
			<p>We will use this structure in the following chapters when using MongoDB and Express.</p>
			<p>In the next section, we will learn how to create and manage classes, as well as how prototypical inherence works in JavaScript.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor123"/>Creating and managing classes</h1>
			<p>Classes were introduced in ES6. They <a id="_idIndexMarker225"/>are syntactic sugar over the prototype-based inheritance. Historically, JavaScript did not have formal classes as we can expect from the typical Object Oriented Programing (OOP) languages.</p>
			<p>In this section, we will learn how to create classes and how to use them with ES6. Also, we will explore how the prototypical inheritance is a key feature in maintaining retro compatibility and extends JavaScript’s core features.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Creating a class</h2>
			<p>To create a class, we<a id="_idIndexMarker226"/> need to use the <code>class</code> keyword, and then we can define the default properties of the class using the <code>constructor</code> method:</p>
			<pre class="source-code">
class Human{
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const jane = new Human ("Jane", 30);
console.log(jane.name); // Jane
console.log(jane.age); // 30</pre>			<p>In this example, we created a class called <code>Human</code> and then we created an instance of the class<a id="_idIndexMarker227"/> called <code>jane</code>. We can access the properties of the class using dot notation.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Class methods</h2>
			<p>To define a method in a <a id="_idIndexMarker228"/>class, we need to use a similar syntax as we use for defining methods in objects:</p>
			<pre class="source-code">
class Human {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHello() {
    console.log(`Hello, my name is ${this.name}!`);
  }
}
const jane = new Human ("Jane", 30);
jane.sayHello(); // Hello, my name is Jane!</pre>			<p>In this example, we defined a method called <code>sayHello</code> in the <code>Human</code> class, then we created an instance of the class, and we called the method.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>Extending classes</h2>
			<p>We can extend <a id="_idIndexMarker229"/>classes using the <code>extends</code> keyword. This will allow us to inherit the properties and methods of the parent class:</p>
			<pre class="source-code">
class Colleague extends Human {
  constructor(name, age, stack) {
    super(name, age);
    this.stack = stack;
    this.canCode = true;
  }
  code() {
    console.log(`I can code in ${this.stack}!`);
  }
}
const jane = new Colleague ("Jane", 30, ['JavaScript', 'React', 'MongoDB']);
console.log(jane.name); // Jane
console.log(jane.canCode); // true
jane.sayHello(); // Hello, my name is Jane!
jane.code(); // I can code in JavaScript, React and MongoDB!</pre>			<p>In this example, we created a class called <code>Colleague</code> that extends the <code>Human</code> class, then we created an instance of the class, and we called the methods and properties inherited from both classes.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor127"/>Static methods</h2>
			<p>Static methods are methods <a id="_idIndexMarker230"/>that can be called without instantiating the class. They are defined using the <code>static</code> keyword:</p>
			<pre class="source-code">
class Car {
  constructor(brand) {
    this.brand = brand;
  }
  move() {
    console.log(`The ${this.brand} is moving!`);
  }
  static speedLimits() {
    console.log("The speed limit is 120 km/h for new cars");
  }
}</pre>			<p>Now, we can call the <code>speedLimits</code> method without instantiating the class:</p>
			<pre class="source-code">
Car.speedLimits(); // The speed limit is 120 km/h for new cars</pre>			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Getters and setters</h2>
			<p>As in other languages that support object-oriented <a id="_idIndexMarker231"/>programming, you can define getters <a id="_idIndexMarker232"/>and setters using the <code>get</code> and <code>set</code> keywords, respectively. This will allow you to access and modify the properties of<a id="_idTextAnchor129"/> the instance in a more classic way:</p>
			<pre class="source-code">
class Rectangle {
    constructor (width, height) {
        this._width  = width
        this._height = height
    }
    set width  (width)  { this._width = width               }
    get width  ()       { return this._width                }
    set height (height) { this._height = height             }
    get height ()       { return this._height               }
    get area   ()       { return this._width * this._height }
}
const shape = new Rectangle(5, 2)
console.log(shape.area) // 10
console.log(shape.height) // 2
console.log(shape.width) // 5
shape.height = 10
shape.width = 10
console.log(shape.area) // 100
console.log(shape.height) // 10
console.log(shape.width) // 10</pre>			<h1 id="_idParaDest-125"><a id="_idTextAnchor130"/>Summary</h1>
			<p>In this chapter, we explored JavaScript’s history and current state. We learned about the different versions of the language and how the language has evolved over time. We also learned about how the new features are added to the language.</p>
			<p>Also, we learned how to find the best documentation about the language and how to use it to learn about the language in more depth.</p>
			<p>Additionally, we explored how to use numbers, dates, conditional statements, loops, strings, arrays, objects, and functions, among others, in detail.</p>
			<p>Furthermore, we learned about classes and prototype-based inheritance and how it is a key feature to maintain retro compatibility and extends JavaScript’s core features.</p>
			<p>In the next chapter, we will learn about asynchronous programming with JavaScript. You will apply all the knowledge learned in this chapter to manage asynchronous code using different approaches, such as callbacks, promises, and async/await.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor131"/>Further reading</h1>
			<ul>
				<li>The Weird History of JavaScript: <a href="https://www.youtube.com/watch?v=Sh6lK57Cuk4">https://www.youtube.com/watch?v=Sh6lK57Cuk4</a></li>
				<li>A Brief History of JavaScript, talk by Brendan Eich (creator of JavaScript): <a href="https://www.youtube.com/watch?v=qKJP93dWn40">https://www.youtube.com/watch?v=qKJP93dWn40</a></li>
				<li>TC39 Demystified, by Ujjwal Sharma: <a href="https://www.youtube.com/watch?v=YLHhRpaPly8">https://www.youtube.com/watch?v=YLHhRpaPly8</a></li>
				<li>Documenting the Web Platform, by Florian Scholz: <a href="https://www.youtube.com/watch?v=f_M0vQcKiW4">https://www.youtube.com/watch?v=f_M0vQcKiW4</a></li>
				<li>TC39: From the Proposal to ECMAScript, Step by Step, by Romulo Cintra: <a href="https://www.youtube.com/watch?v=h5pUuz2qqVQ">https://www.youtube.com/watch?v=h5pUuz2qqVQ</a></li>
			</ul>
		</div>
	</body></html>