<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-55" class="chapter-number"><a id="_idTextAnchor056"/>3</h1>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor057"/> JavaScript Fundamentals</h1>
			<p>In this chapter, we will review all the aspects of JavaScript that are relevant to this book. While this topic could be a book in itself, this chapter synthesizes the most basic parts (arrays, objects, strings, and data types) in order to do a deeper analysis of the most complex parts, such as functions <span class="No-Break">and closures.</span></p>
			<p>Even if you are already familiar with JavaScript, this chapter will help you to refresh your knowledge of certain areas. Also, you will learn about the latest changes in JavaScript introduced by the <span class="No-Break">latest specification.</span></p>
			<p>We will also learn how JavaScript has become a standard on how decisions are made when a request change is made for <span class="No-Break">the language.</span></p>
			<p>Additionally, we will review some tools that will help us to write better JavaScript by using linters, debugging tools, and proper documentation for <span class="No-Break">our code.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Refresh or acquire JavaScript knowledge, including about many of <span class="No-Break">its features</span></li>
				<li>Understand JavaScript versioning and the <span class="No-Break">TC39 committee</span></li>
				<li>Get familiar with the JavaScript documentation <span class="No-Break">and linting</span></li>
				<li>Understand the most commonly used parts of JavaScript (comments, data types, operators, conditionals, loops, functions, objects, arrays, classes, and <span class="No-Break">so on)</span></li>
				<li>Understand advanced JavaScript concepts such as closures <span class="No-Break">and prototypes</span></li>
			</ul>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/BxM8XZzINmg"><span class="No-Break">https://youtu.be/BxM8XZzINmg</span></a></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>JavaScript is a powerful language</h1>
			<p>JavaScript is a very powerful language. It is used in the frontend, backend, mobile, desktop, IoT, and so on. It is very flexible, and it is very easy to get started, but it is also very hard to master <span class="No-Break">in depth.</span></p>
			<p>There is a very famous quote (<a href="https://www.crockford.com/javascript/javascript.html">https://www.crockford.com/javascript/javascript.html</a>) by Douglas Crockford <span class="No-Break">that says:</span></p>
			<p class="author-quote">JavaScript is the world’s most misunderstood programming language.</p>
			<p>JavaScript is a multi-paradigm<a id="_idIndexMarker070"/> language, which means that you can use different programming styles, such as object-oriented programming, functional programming, or declarative programming. This is very useful because you can use the programming style that best fits your needs. But on the other hand, it can be very confusing for beginners, and not all the programming styles are equally supported by <span class="No-Break">the language.</span></p>
			<p>JavaScript is a very dynamic language, which means that you can change the behavior of the language at runtime. Thanks to JavaScript, you can learn complex concepts, such as closures and prototypes, and use them to create very powerful and complex applications. But you can also use them to create very confusing and <span class="No-Break">hard-to-maintain applications.</span></p>
			<p>In the next chapters, we will learn how to use JavaScript to create powerful applications, but we will also learn how to use it in a way that is easy to understand <span class="No-Break">and maintain.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Don’t worry if you’re not deeply familiar with any of the mentioned paradigms. Throughout this book, we’ll gradually incorporate elements from each paradigm, introducing them <span class="No-Break">as needed.</span></p>
			<p>In the next section, we will explore the role of the TC39 in JavaScript and how the <span class="No-Break">specification works.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor060"/>Understanding versioning – TC39</h1>
			<p>JavaScript is getting old; it was created in 1995 by Brendan Eich at Netscape Communications Corporation. It was<a id="_idIndexMarker071"/> originally called Mocha, but it <a id="_idIndexMarker072"/>was renamed LiveScript and <span class="No-Break">finally JavaScript.</span></p>
			<p>The first version <a id="_idIndexMarker073"/>of JavaScript<a id="_idIndexMarker074"/> was released in 1996. It was called <strong class="bold">ECMAScript 1</strong> (<strong class="bold">ES1</strong>) and was<a id="_idIndexMarker075"/> standardized by the <strong class="bold">European Computer Manufacturers Association</strong> (<strong class="bold">ECMA</strong>) <span class="No-Break">in 1997.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Understanding versioning – ECMAScript</h2>
			<p>Over the years, many new features were added to the language, such as classes, modules, and arrow functions. The <a id="_idIndexMarker076"/>new features were added to the language through a submission proposal process called ECMAScript proposals (<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>) that are managed directly by the TC39 (<a href="https://tc39.es/process-document/">https://tc39.es/process-document/</a>), which refers to a committee of ECMA that is responsible for the evolution of <span class="No-Break">the language.</span></p>
			<p>From 1997 until 2015, new features were added to the language every few years, but in 2015, the TC39 decided to release a new version of the language every year, which means that the language is evolving faster than ever. This also helps us with the adoption of the new features because we don’t need to wait many years to use them in <span class="No-Break">production environments.</span></p>
			<p>Currently, the latest version of the language is ECMA-262 2023 (<a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>), which was released in <span class="No-Break">June 2023.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>What is included in the next version of JavaScript?</h2>
			<p>In order to add new features to <a id="_idIndexMarker077"/>the language, the TC39 committee has a process that is divided into stages. Anybody can submit a proposal to the TC39 committee, but it is not an easy task, because the proposal needs to be approved by the committee before it <span class="No-Break">is implemented.</span></p>
			<p>You can find all the proposals in the TC39 GitHub repository (<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>). You can participate in the discussions and get involved in <span class="No-Break">the community.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>What is not included in the JavaScript specification?</h2>
			<p>The JavaScript specification is very big, but it <a id="_idIndexMarker078"/>does not include many APIs that are commonly used in JavaScript applications, such as browser APIs and <span class="No-Break">Node.js APIs.</span></p>
			<p>If you are using JavaScript in the browser, you can use browser APIs, such as the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). If you <a id="_idIndexMarker079"/>are using JavaScript in Node.js, you can use Node.js APIs, such as the filesystem <span class="No-Break">or HTTP.</span></p>
			<p>At the end of the day, JavaScript is just a programming language. If you are used to building JavaScript applications in the browser, you might be familiar with many APIs that are not included in the JavaScript specification and are not available in Node.js. For example, the window object (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">https://developer.mozilla.org/en-US/docs/Web/API/Window</a>) is available in the browser, but it is not available <span class="No-Break">in Node.js.</span></p>
			<p>Now that we know how the specification works, it is time to explore the JavaScript documentation in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Exploring JavaScript documentation</h1>
			<p>While ECMA-262 (<a href="https://262.ecma-international.org/14.0/">https://262.ecma-international.org/14.0/</a>) is a great source of information, it is not <span class="No-Break">very </span><span class="No-Break"><a id="_idIndexMarker080"/></span><span class="No-Break">beginner-friendly.</span></p>
			<p>The most complete source of information is the MDN Web Docs (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>), which is a community-driven documentation. It is very comprehensive, and it is updated regularly and even translated into <span class="No-Break">other languages.</span></p>
			<p>If you are familiar with frontend development, you might have used the MDN Web Docs before, because it is the main source of information for browser APIs, such as the DOM<span class="hidden"> </span>(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction</a>) and the Fetch <span class="No-Break">API (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</span></a><span class="No-Break">).</span></p>
			<p>If are looking for more concise documentation, you can use W3Schools (<a href="https://www.w3schools.com/js/default.asp">https://www.w3schools.com/js/default.asp</a>), which is a great source of information for beginners, with a lot <span class="No-Break">of examples.</span></p>
			<p>Finally, if you are <a id="_idIndexMarker081"/>looking for a specific answer to a question, you can use Stack Overflow (<a href="https://stackoverflow.com/questions/tagged/javascript">https://stackoverflow.com/questions/tagged/javascript</a>), which is a community-driven <span class="No-Break">Q&amp;A website.</span></p>
			<p>In the next section, we will learn how we can use linting tools to improve our JavaScript <span class="No-Break">code easily.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/>Linting JavaScript code</h1>
			<p>Linting is the process of<a id="_idIndexMarker082"/> running a program that will analyze your code for potential errors. It is very useful in catching errors before running your code, so you can fix them before they cause <span class="No-Break">any issues.</span></p>
			<p>JavaScript is a very flexible language, which means that it is very easy to make mistakes. As you get more used to it, you will make fewer mistakes, but it is always good to have a linter to <span class="No-Break">help you.</span></p>
			<p>In the next chapters, we will use ESLint (<a href="https://eslint.org/">https://eslint.org/</a>) to lint our code, but there are other options available, such as JSLint (<a href="https://www.jslint.com/">https://www.jslint.com/</a>) and <span class="No-Break">JSHint (</span><a href="https://jshint.com/"><span class="No-Break">https://jshint.com/</span></a><span class="No-Break">).</span></p>
			<p>Configuring a linter is not a trivial task, but it is worth the effort. There are many rules available, and it is not easy to know which ones to use. I highly recommend that you use the standard rules (<a href="https://standardjs.com/">https://standardjs.com/</a>), which are one of the most popular and used by many open source projects (including Node.js, Express, and MongoDB) and companies. You can find all the rules available on the JavaScript Standard Style <span class="No-Break">page (</span><a href="https://standardjs.com/rules.html"><span class="No-Break">https://standardjs.com/rules.html</span></a><span class="No-Break">).</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, you can see how the standard is used to review the source code of the project. It will recommend what to do in order to follow the <span class="No-Break">configured rules.</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B21678_03_01.jpg" alt="Figure 3.1 – Screenshot from GitHub Codespaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Screenshot from GitHub Codespaces</p>
			<p>In the next section, we will learn <a id="_idIndexMarker083"/>how to document our own code, so it becomes easier <span class="No-Break">to maintain.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>Commenting JavaScript code</h1>
			<p>You have multiple options <a id="_idIndexMarker084"/>to include comments in <span class="No-Break">your code:</span></p>
			<pre class="source-code">
// Single line comment
/*
Multiline
comment
*/</pre>			<p>If you are new to JavaScript, I recommend you use a lot of comments to help you understand what is going on in your code. As you become more experienced, you will need fewer comments. Comments also help other developers to read and understa<a id="_idTextAnchor067"/>nd <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor068"/>Using JSDoc</h2>
			<p>If you need guidance on how to write good comments, you can use the JSDoc (<a href="https://jsdoc.app/">https://jsdoc.app/</a>) syntax. Another <a id="_idIndexMarker085"/>additional benefit of<a id="_idIndexMarker086"/> using JSDoc is that you can use it to autogenerate documentation for <span class="No-Break">your code.</span></p>
			<p>This is quite a popular solution. For example, Lodash uses this approach.  Use the following links to check out how the <strong class="source-inline">_.chunk</strong> method <span class="No-Break">is documented:</span></p>
			<ul>
				<li>JSDoc in <span class="No-Break">practice: </span><a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818"><span class="No-Break">https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818</span></a></li>
				<li>Documentation automatically generated by <span class="No-Break">JSDocs: </span><a href="https://lodash.com/docs/4.17.15#chunk"><span class="No-Break">https://lodash.com/docs/4.17.15#chunk</span></a></li>
			</ul>
			<p>In the next section, we will learn how to use <strong class="source-inline">console</strong> to speed up our <span class="No-Break">debugging process.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Printing values and debugging</h1>
			<p>The <strong class="source-inline">console</strong> object is non-standard; it is not part of the JavaScript language, but it is provided by the browser and Node.js. You can use it to print messages to the console, which is very <a id="_idIndexMarker087"/>useful for debugging purposes and for the purposes of this book, to follow along with the examples. It is quite common to use it to print the value of a variable. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
const name = "Ulises";
console.log(name); // Ulises</pre>			<p>Yes, you can use <strong class="source-inline">console.log</strong> to print multiple values at the same time, separated by commas, and even include additional information to explain what you are printing. You don’t have to worry about the type of the variable as in other languages; <strong class="source-inline">console.log</strong> will do it <span class="No-Break">for you.</span></p>
			<p>In some cases, you will need to help <strong class="source-inline">console.log</strong> print the value of a variable; for example, if you want to print an object, sometimes you end up getting <strong class="source-inline">[object, object]</strong> or similar as the output message. In this case, you will need to use <strong class="source-inline">console.log(JSON.stringify(object))</strong> to print the object as <span class="No-Break">a string:</span></p>
			<pre class="source-code">
const data = {
  nestedData: {
    moreNestedData: {
      value: 1
    }
  }
};
console.log(data); // [object, object]
console.log(JSON.stringify(data)); // {"nestedData":{"moreNestedData":{"value":1}}}</pre>			<p>Over time, the JavaScript engines improve the <strong class="source-inline">console</strong> output, so this simple example might be printed as <a id="_idIndexMarker088"/>expected in your browser; but certain complex objects might still need to be stringified, for example, the response from a long <span class="No-Break">HTTP request.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">console</strong> object offers many methods to print the information in different formats, which will improve your developer experience a lot. Documentation is available for web browsers (<a href="https://developer.mozilla.org/en-US/docs/Web/API/console">https://developer.mozilla.org/en-US/docs/Web/API/console</a>) and for <span class="No-Break">Node.js (</span><a href="https://nodejs.org/api/console.html"><span class="No-Break">https://nodejs.org/api/console.html</span></a><span class="No-Break">).</span></p>
			<p>In the next section, we will learn how JavaScript uses constants and variables to store the information that we need when <span class="No-Break">building applications.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Variables and constants</h1>
			<p>We use variables to store<a id="_idIndexMarker089"/> values, and we use constants to store values that will not change. In JavaScript, we can use the <strong class="source-inline">let</strong> keyword to declare a variable <a id="_idIndexMarker090"/>and the <strong class="source-inline">const</strong> keyword to declare a constant. Before ES6, we could only use the <strong class="source-inline">var</strong> keyword to declare variables, but it is not recommended to use <span class="No-Break">it anymore.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Naming conventions</h2>
			<p>In JavaScript, it is very common<a id="_idIndexMarker091"/> to use <em class="italic">camelCase</em> to name variables and constants, but other conventions are supported too, such as <em class="italic">snake_case</em> and <em class="italic">PascalCase</em>. It is also possible to start variables with symbols, but it is<a id="_idIndexMarker092"/> <span class="No-Break">not recommended.</span></p>
			<p>There are a few limitations that we need to consider when naming variables <span class="No-Break">and constants:</span></p>
			<ul>
				<li>Avoid starting with a symbol, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">$resource</strong></span></li>
				<li>Don’t start with a number, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">1variable</strong></span></li>
				<li>Don’t use spaces, such as <strong class="source-inline">const my variable = 1</strong></li>
				<li>Don’t use reserved words, such as <strong class="source-inline">const const = "</strong><span class="No-Break"><strong class="source-inline">constant"</strong></span></li>
			</ul>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>let versus const</h2>
			<p>We use <strong class="source-inline">let</strong> to declare variables and <strong class="source-inline">const</strong> to declare constants. The main difference is that we can<a id="_idIndexMarker093"/> reassign a value to a variable, but we cannot <a id="_idIndexMarker094"/>reassign a value to a constant. Here is an example <a id="_idIndexMarker095"/>of reassigning a value to <span class="No-Break">a</span><span class="No-Break"><a id="_idIndexMarker096"/></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
let userName = "Joe Doe";
console.log(userName); // Joe Doe
userName = "Jane Doe";
console.log(userName); // Jane Doe</pre>			<p>As we can see here, we cannot reassign a value to <span class="No-Break">a constant:</span></p>
			<pre class="source-code">
const userName = "Joe Doe";
console.log(userName); // Joe Doe
userName = "mary"; // TypeError: Assignment to constant variable.</pre>			<p>It is important to notice that we can <a id="_idIndexMarker097"/>change the value of a constant if the value<a id="_idIndexMarker098"/> is an object, but we cannot reassign<a id="_idIndexMarker099"/> a new value to <span class="No-Break">the constant:</span></p>
			<pre class="source-code">
const user = {
  name: "Joe Doe"
}
console.log(user.name); // Joe Doe
user.name = "Jane Doe";
console.log(user.name); // Jane Doe
user = "Mr. Joe"; // TypeError: Assignment to constant variable.</pre>			<p>Later in this chapter, we will <a id="_idIndexMarker100"/>explore objects in more detail, and we will understand these <span class="No-Break">mutations deeper.</span></p>
			<p>In JavaScript, there is another mechanism that you need to understand. Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase. This is done to optimize the code, but it can have some side effects. You can find a great guide <span class="No-Break">at </span><a href="https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3"><span class="No-Break">https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3</span></a><span class="No-Break">.</span></p>
			<p>Now that we are clear on how variables and constants work, it is time to explore the different data types available in JavaScript in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor073"/>Understanding data types</h1>
			<p>In JavaScript, there are<a id="_idIndexMarker101"/> several primitive types. We can group them into two groups: before ES6 (<strong class="source-inline">undefined</strong>, <strong class="source-inline">object</strong>, <strong class="source-inline">boolean</strong>, <strong class="source-inline">number</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">function</strong>) and after ES6 (<strong class="source-inline">bigint</strong> and <strong class="source-inline">symbol</strong>). In order to check the type of a variable, we can use the <span class="No-Break"><strong class="source-inline">typeof</strong></span><span class="No-Break"> operator.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>undefined</h2>
			<p>Not all languages have an <strong class="source-inline">undefined</strong> type, but JavaScript does. It is used to represent the absence<a id="_idIndexMarker102"/> of a value. It is also used as the default <a id="_idIndexMarker103"/>value for <span class="No-Break">uninitialized variables.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>object</h2>
			<p>The <strong class="source-inline">object</strong> type is used to<a id="_idIndexMarker104"/> represent a collection of data. It is a very generic type, and<a id="_idIndexMarker105"/> it is used to represent many different things, such as arrays (lists), objects (dictionaries), class instances, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>boolean</h2>
			<p>The <strong class="source-inline">boolean</strong> type is used to<a id="_idIndexMarker106"/> represent a logical value. It can be either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. This type can be <a id="_idIndexMarker107"/>generated by using the <strong class="source-inline">Boolean</strong>  function too, as everything in JavaScript can be converted to a <span class="No-Break"><strong class="source-inline">boolean</strong></span><span class="No-Break"> value.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>number</h2>
			<p>The <strong class="source-inline">number</strong> type is used to<a id="_idIndexMarker108"/> represent a numeric value. It can be either an<a id="_idIndexMarker109"/> integer or a floating-point number. It is also used to represent special numeric values such as <strong class="source-inline">Infinity</strong>, <strong class="source-inline">-Infinity</strong>, and <strong class="source-inline">NaN</strong> (which stands for Not <span class="No-Break">a Number).</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>string</h2>
			<p>The <strong class="source-inline">string</strong> type is used to<a id="_idIndexMarker110"/> represent a sequence of characters. It can be created explicitly <a id="_idIndexMarker111"/>by using single quotes (<strong class="source-inline">'</strong>), double quotes (<strong class="source-inline">"</strong>), or backticks (<strong class="source-inline">`</strong>) or implicitly by using the <strong class="source-inline">String</strong> function <span class="No-Break">or expressions.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>function</h2>
			<p>The <strong class="source-inline">function</strong> type is used to represent a function. Functions in JavaScript are very powerful. We will explore<a id="_idIndexMarker112"/> them in detail in this chapter. There are two ways to<a id="_idIndexMarker113"/> create a function, by using the <strong class="source-inline">function</strong> keyword or by using the arrow <span class="No-Break">function syntax.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>bigint</h2>
			<p><strong class="source-inline">bigint</strong> was introduced<a id="_idIndexMarker114"/> in ES6 in order to work with large numbers. <strong class="source-inline">number</strong> is limited to <a id="_idIndexMarker115"/>values between -(2<span class="superscript">53</span> – 1) and 2<span class="superscript">53</span> – 1</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>symbol</h2>
			<p>The <strong class="source-inline">symbol</strong> type is used to<a id="_idIndexMarker116"/> represent a unique identifier. It is a new type that was introduced in ES6; you won’t really need to be familiar with it to follow along <a id="_idIndexMarker117"/>with <span class="No-Break">this book.</span></p>
			<p>In the next section, we will explore numbers in depth, including the Math built-in library, common operators used for comparison, and useful methods for converting numbers <span class="No-Break">and strings.</span></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Exploring numbers</h1>
			<p>JavaScript has good support for mathematical operations and dates, but sometimes it can be tricker and <a id="_idIndexMarker118"/>more limited than other programming languages, so many developers use specialized libraries when the application requires advanced math. For example, if you need to work with vectors, matrices, or complex numbers, you should use a library such as <span class="No-Break">Math.js (</span><a href="https://mathjs.org/"><span class="No-Break">https://mathjs.org/</span></a><span class="No-Break">).</span></p>
			<p>Here is a typical example of the floating-point <span class="No-Break">precision problem:</span></p>
			<pre class="source-code">
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false</pre>			<p>As you can see, the result of <strong class="source-inline">0.1 + 0.2</strong> is not <strong class="source-inline">0.3</strong>, but <strong class="source-inline">0.30000000000000004</strong>. This is because JavaScript uses the IEEE 754 standard (<a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a>) to represent numbers, and it is not possible to represent all decimal numbers in binary. This is a common problem in many programming languages; it is not an exclusively JavaScript problem. But you can solve it by using the <strong class="source-inline">Number</strong> and <strong class="source-inline">toPrecision</strong> functions as you will implicitly convert from <a id="_idIndexMarker119"/>number to string and then back <span class="No-Break">to number:</span></p>
			<pre class="source-code">
let impreciseOperation = 0.1 + 0.2;
Number(impreciseOperation.toPrecision(1)) === 0.3; // true</pre>			<p>As you can see, there are some edge cases that are not easy to understand or solve intuitively. Most of the time, you will not need to worry about this, but it is important to know that this problem exists and you can use libraries if you are not experienced enough with numbers <span class="No-Break">in JavaScript.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Arithmetic operators</h2>
			<p>JavaScript has the expected <a id="_idIndexMarker120"/>arithmetic operators, <strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, <strong class="source-inline">%</strong>, and <strong class="source-inline">**</strong>, and indicates <a id="_idIndexMarker121"/>priority with brackets as in any <span class="No-Break">modern language.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Assignment operators</h2>
			<p>JavaScript has the expected <a id="_idIndexMarker122"/>assignment operators, <strong class="source-inline">=</strong>, <strong class="source-inline">+=</strong>, <strong class="source-inline">-=</strong>, <strong class="source-inline">*=</strong>, <strong class="source-inline">/=</strong>, <strong class="source-inline">%=</strong>, and <strong class="source-inline">**=</strong>, as in <span class="No-Break">other languages.</span></p>
			<p>Also, you can use <strong class="source-inline">++</strong> and <strong class="source-inline">--</strong> to increment and <a id="_idIndexMarker123"/>decrement a variable. This operator can be added before or after the variable, and it will change the value of the variable before or after <span class="No-Break">the operation:</span></p>
			<pre class="source-code">
let a = 5;
console.log(a++); // 5
console.log(a);   // 6
console.log(++a); // 7
console.log(a);   // 7</pre>			<p class="callout-heading">Additional info</p>
			<p class="callout">JavaScript also supports bitwise operations, so you can work with a set of 32 bits (zeros and ones), rather <a id="_idIndexMarker124"/>than decimal, hexadecimal, or octal numbers. You can check out the full documentation <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Useful methods</h2>
			<p>There are methods that are key to <a id="_idIndexMarker125"/>performing mathematical operations or transformations in <span class="No-Break">daily work:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Number.prototype.toFixed()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Number.prototype.toPrecision()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Number.parseInt()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Number.parseFloat()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat</span></a></li>
			</ul>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>The Math object</h2>
			<p>JavaScript has a built-in <strong class="source-inline">Math</strong> object <a id="_idIndexMarker126"/>that provides a lot of useful methods to perform mathematical operations. I will list some of them here, but you can find the full list in the MDN <span class="No-Break">documentation (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math</span></a><span class="No-Break">).</span></p>
			<h3>Useful methods</h3>
			<p>There are methods that are key to performing mathematical operations or transformations in <span class="No-Break">daily work:</span></p>
			<ul>
				<li><strong class="source-inline">Math.random()</strong>: Returns<a id="_idIndexMarker127"/> a pseudo-random floating-point number between 0 (inclusive) and 1 (<span class="No-Break">exclusive) </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random</span></a></li>
				<li><strong class="source-inline">Math.max()</strong>: Returns the maximum numeric value among the arguments passed to it  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max</span></a></li>
				<li><strong class="source-inline">Math.min()</strong>: Returns the minimum numeric value among the arguments passed to it  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min</span></a></li>
				<li><strong class="source-inline">Math.floor()</strong>: Returns the resulting number from rounding a number down to the nearest integer that is less than or equal to the given <span class="No-Break">number </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor</span></a></li>
			</ul>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Other numbers</h2>
			<p>In JavaScript, there are some special values that are numbers, but they are not real numbers. These values are <strong class="source-inline">NaN</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Infinity</strong></span><span class="No-Break">.</span></p>
			<h3>Not a Number (NaN)</h3>
			<p><strong class="source-inline">NaN</strong> is a special value that represents Not<a id="_idIndexMarker128"/> a Number. It is the result of an<a id="_idIndexMarker129"/> invalid or undefined mathematical operation, for example, dividing 0 by 0, or multiplying Infinity by 0. You can use <strong class="source-inline">isNaN()</strong> to check whether a value is <span class="No-Break"><strong class="source-inline">NaN</strong></span><span class="No-Break"> (</span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN</span></a><span class="No-Break">).</span></p>
			<h3>Infinity</h3>
			<p><strong class="source-inline">Infinity</strong> is a special value that represents infinity. It is the result of a mathematical operation that exceeds<a id="_idIndexMarker130"/> the largest possible number. You can use <strong class="source-inline">isFinite()</strong> to<a id="_idIndexMarker131"/> check whether a value is <span class="No-Break">finite (</span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite</span></a><span class="No-Break">).</span></p>
			<p>In the next section, we will explore dates <span class="No-Break">in depth.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor088"/>Exploring Dates object</h1>
			<p>Dates are a complex topic for any programming language or system as you need to take into account many things, such <a id="_idIndexMarker132"/>as time zones. If you need to work with dates intensively, consider using a library such as Lunox (<a href="https://github.com/moment/luxon/">https://github.com/moment/luxon/</a>) or <span class="No-Break">date-fns (</span><a href="https://date-fns.org/"><span class="No-Break">https://date-fns.org/</span></a><span class="No-Break">).</span></p>
			<p>For more simple scenarios, you can use the built-in <strong class="source-inline">Date</strong> object and the Intl API (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl</a>) to <span class="No-Break">format dates.</span></p>
			<p>The API offers several ways to generate the Date object by using numbers, strings, or several arguments. Also, you have getters and setters to read and modify specific parts, such as the year or milliseconds. It is also possible to perform operations such as comparing or <span class="No-Break">adding time.</span></p>
			<p>For many years, the only way to format dates in JavaScript was using the <strong class="source-inline">toLocaleString()</strong> method. This method is still valid, but it has a lot of limitations, specifically, when you want to compare dates in a human-readable way (e.g., <em class="italic">3 days ago</em> or <em class="italic">2 </em><span class="No-Break"><em class="italic">weeks ago</em></span><span class="No-Break">).</span></p>
			<p>In the past, we needed to use external libraries to achieve this, but now we can use the Intl API (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl</a>) to <span class="No-Break">format dates.</span></p>
			<p>In the following code, you can see how to generate, manipulate, and <span class="No-Break">format dates:</span></p>
			<pre class="source-code">
const jsDateAnnouncement = new Date(818031600000);
const currentDate = new Date();
const diff = jsDateAnnouncement - currentDate;
const formatter = new Intl.RelativeTimeFormat('en', {
    numeric: 'auto'
});
const diffInDays = Math.round(diff / 86400000);
const diffInYears = Math.round(diffInDays / 365);
const diffInText = formatter.format(diffInDays, 'day');
console.log(`JavaScript was presented to the world ${formatter.format(diffInDays, 'day')}`);
// JavaScript was presented to the world 10,094 days ago
console.log(`JavaScript was presented to the world ${formatter.format(diffInYears, 'year')}`);
// JavaScript was presented to the world 28 years ago.</pre>			<p>The result may vary on your machine as it will have been some time since I wrote this code. Therefore, keep in <a id="_idIndexMarker133"/>mind that the output you observe may differ <span class="No-Break">from mine.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The TC39 is doing a great job at consolidating this API, which includes a lot of features to format dates, numbers, currencies, and more. I recommend you follow the proposal’s progress and implementation in the <span class="No-Break">JavaScript engines.</span></p>
			<p>In the next section, we will learn how to use conditionals in JavaScript by using several tools that <span class="No-Break">JavaScript provides.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Conditional statements</h1>
			<p>There are many ways to write<a id="_idIndexMarker134"/> conditional statements in JavaScript, but the most common are <strong class="source-inline">if</strong>, <strong class="source-inline">switch</strong>, and the ternary <span class="No-Break">operator (</span><span class="No-Break"><strong class="source-inline">?:</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Math comparison operators</h2>
			<p>For mathematical operations, we have the following operators: <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;=</strong>, and <strong class="source-inline">&lt;=</strong>. They are used to compare<a id="_idIndexMarker135"/> two values and return a <a id="_idIndexMarker136"/>Boolean value. Their use is the same as in most modern <span class="No-Break">programming languages.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Equality operators</h2>
			<p>Equality operators are used to compare <a id="_idIndexMarker137"/>two values and return a Boolean <a id="_idIndexMarker138"/>value. There are two types of equality operators: strict (<strong class="source-inline">===</strong> and <strong class="source-inline">!==</strong>) and non-strict (<strong class="source-inline">==</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">!=</strong></span><span class="No-Break">).</span></p>
			<p>The strict equality operator cannot be used to compare non-primitive types (such as <strong class="source-inline">object</strong>, <strong class="source-inline">array</strong>, and <strong class="source-inline">function</strong>) and certain values such as <strong class="source-inline">NaN</strong>, as it will always <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
console.log([1,2] === [1,2]) // false
console.log({ name: 'John' } === { name: 'John' }); // false
console.log(NaN === NaN); // false</pre>			<p>It is not recommended to use non-strict equality operators, as they can lead to unexpected results, because this operator does not check the type of <span class="No-Break">the values:</span></p>
			<pre class="source-code">
console.log(1 == '1'); // true
console.log(1 != '1'); // false</pre>			<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Logical operators</h2>
			<p>It is possible to combine multiple conditions using logical operators. There are three logical operators, <strong class="source-inline">&amp;&amp;</strong>, <strong class="source-inline">||</strong>, and <strong class="source-inline">!</strong>, and some<a id="_idIndexMarker139"/> variations of them, <strong class="source-inline">&amp;&amp;=</strong> and <strong class="source-inline">||=</strong>, that are used to reduce the amount of code for certain<a id="_idIndexMarker140"/> operations. We won’t cover them all in <span class="No-Break">this book.</span></p>
			<p>You can combine operators to build more <span class="No-Break">complex validations:</span></p>
			<pre class="source-code">
const num = 2
console.log((num == 2) &amp;&amp; (3 &gt;= 6)); // false
console.log((num &gt; 3) || (17 &lt;= 40)); // true</pre>			<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>The NOT operator (!)</h2>
			<p>The NOT operator is used to invert the <a id="_idIndexMarker141"/>value of a Boolean. It will<a id="_idIndexMarker142"/> return <strong class="source-inline">true</strong> if the value is false, and <strong class="source-inline">false</strong> if the value <span class="No-Break">is true:</span></p>
			<pre class="source-code">
console.log(!true); // false
console.log(!false); // true</pre>			<p>This example is not clear about all the possibilities that are offered, so let’s try to build an analogy with a more verbose structure, <strong class="source-inline">Boolean(value) === false</strong>. Basically, the <strong class="source-inline">!</strong> operator converts the value to a Boolean and then compares it with a <span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break"> value.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>Equality in JavaScript</h2>
			<p>Due to the nature of JavaScript, it is <a id="_idIndexMarker143"/>possible to use any value as a condition. The condition will be evaluated as a Boolean, and if the value is truthy, the condition will be <strong class="source-inline">true</strong>. If the value is falsy, the condition will be <strong class="source-inline">false</strong>. This can be a bit confusing, so let’s explore the <strong class="source-inline">Boolean</strong> method to understand how different data values <span class="No-Break">are transformed:</span></p>
			<pre class="source-code">
// The truthy values:
console.log("String:", Boolean("Ulises")  );
console.log("1235:", Boolean(1235));
console.log("-1235:", Boolean(-1235));
console.log("Object:", Boolean({text: "hi"}));
console.log("Array:", Boolean(["apple", -1, false]));
console.log("Function:", Boolean(function(){}));
console.log("Arrow function:", Boolean(() =&gt; {}));
// The falsy values:
console.log("Empty string:", Boolean("")  );
console.log("0:", Boolean(0));
console.log("-0:", Boolean(-0));
console.log("null:", Boolean(null));
console.log("undefined:", Boolean(undefined));
console.log("NaN:", Boolean(NaN));</pre>			<p>We can conclude easily that empty values (such as <strong class="source-inline">null</strong>, <strong class="source-inline">undefined</strong>, an empty string, or <strong class="source-inline">NaN</strong>) and <strong class="source-inline">0</strong> are falsy, and values with complex data types (such as objects and functions) or non<a id="_idIndexMarker144"/> empty strings and non-zero numbers <span class="No-Break">are truthy.</span></p>
			<p>This is quite convenient when we want to check whether a value is empty or not, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
function checkValue (value) {
    if(!value) {
        throw new Error ("The value is invalid! Try again.")
    }
}</pre>			<p>This Boolean transformation and comparison can turn into a very complex situation if you want to compare different data types and values, for example, <strong class="source-inline">Boolean([]) === Boolean({})</strong>. You can explore this topic in detail in the MDN documentation (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness</a>). But in general, you don’t need to be an expert in<a id="_idIndexMarker145"/> this area to follow along with <span class="No-Break">this book.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can get a better understanding of this topic by exploring JavaScript Equality Table by Dorey <span class="No-Break">at </span><a href="https://github.com/dorey/Javascript-Equality-Table/"><span class="No-Break">https://github.com/dorey/Javascript-Equality-Table/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>The nullish coalescing operator (??)</h2>
			<p>The nullish coalescing operator is a <a id="_idIndexMarker146"/>new operator that<a id="_idIndexMarker147"/> was introduced in ES2020. It is used to check whether a value is <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong>; if it is, it will return a <span class="No-Break">default value:</span></p>
			<pre class="source-code">
const name = null ?? "John Joe";
console.log(name); // John Joe</pre>			<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>The if statement</h2>
			<p>The <strong class="source-inline">if</strong> statement is the most common way <a id="_idIndexMarker148"/>to write a conditional statement. It will<a id="_idIndexMarker149"/> execute the code inside the block if the condition is true. The <strong class="source-inline">else</strong> statement allows us to follow up when the condition is not met by executing the code that is in the <strong class="source-inline">else</strong> statement. The <strong class="source-inline">else if</strong> statement is a variation of the <strong class="source-inline">if</strong> statement. It will execute the code inside the block if the condition is true. If the condition is false, it will execute the code inside the <strong class="source-inline">else</strong> block. You can add as many <strong class="source-inline">else if</strong> statements as <span class="No-Break">you need:</span></p>
			<pre class="source-code">
const condition = true
const condition2 = true
if(condition) {
    console.log("The condition is true")
} else if (condition2) {
    console.log("The condition2 is true")
} else {
    console.log("The condition and condition2 are false")
}</pre>			<p>You can change the values in <strong class="source-inline">condition</strong> and <strong class="source-inline">condition2</strong> in order to get more familiar with the <a id="_idIndexMarker150"/>behavior of the <span class="No-Break">conditional structures.</span></p>
			<h3>return usage</h3>
			<p>The <strong class="source-inline">return</strong> statement is widely <a id="_idIndexMarker151"/>used to avoid using <strong class="source-inline">else</strong> statements and allows for cleaner code. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const condition = true;
if(condition) {
    return console.log("The condition is true");
}
console.log("The condition is false");</pre>			<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>The switch statement</h2>
			<p>The <strong class="source-inline">switch</strong> statement is a good option<a id="_idIndexMarker152"/> when you want to compare a variable against multiple values. It is good when you want to assign a value to a variable depending on <span class="No-Break">a condition.</span></p>
			<p>The <strong class="source-inline">switch</strong> structure is composed <a id="_idIndexMarker153"/>of the <strong class="source-inline">switch</strong> keyword, followed by the variable that you want to compare, and then a block of <strong class="source-inline">case</strong> statements. Each <strong class="source-inline">case</strong> statement is composed of the <strong class="source-inline">case</strong> keyword, followed by the value that you want to compare, "and then a double colon (:). After the double colon," you can write the code that you want to execute if the condition is true. The <strong class="source-inline">default</strong> statement is optional, and it will be executed if none of the <strong class="source-inline">case</strong> statements are true, like <strong class="source-inline">else</strong> when using <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statements.</span></p>
			<p>The <strong class="source-inline">break</strong> statement is used to stop the execution of the <strong class="source-inline">switch</strong> statement. If you don’t add the <strong class="source-inline">break</strong> statement, the code will continue executing the next <strong class="source-inline">case</strong> statement. Here we have a <a id="_idIndexMarker154"/><span class="No-Break">combined example:</span></p>
			<pre class="source-code">
const extension = ".md";
switch (extension) {
  case ".doc":
    console.log("This extension .doc will be deprecated soon")
  case ".pdf":
  case ".md":
  case ".svg":
    console.log("Congratulations! You can open this file");
    break;
  default:
    console.log(`${extension} is not supported`);
}</pre>			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Ternary operator</h2>
			<p>The ternary operator is shorthand for the <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> statements. It is a good option when you want to assign a value to a variable depending on <span class="No-Break">a condition.</span></p>
			<p>The structure is composed of the condition, followed by a question mark, <strong class="source-inline">?</strong>, then the value that you want to assign if the <a id="_idIndexMarker155"/>condition is true, followed <a id="_idIndexMarker156"/>by a double colon (:), and then the value that you want to assign if the condition is false: <strong class="source-inline">condition ? valueIfTrue : </strong><span class="No-Break"><strong class="source-inline">valueIfFalse</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see an example with the <strong class="source-inline">if</strong> and <span class="No-Break"><strong class="source-inline">else</strong></span><span class="No-Break"> statements:</span></p>
			<pre class="source-code">
const isMember = true;
console.log(`The payment is ${isMember ? "20.00€" : "50.00€"}`);
// The payment is 20.00€</pre>			<p>The ternary operator can nest multiple ternary operators, but it is not recommended because it can be extremely difficult to read. Also, it is possible to use the ternary operator to do multiple <a id="_idIndexMarker157"/>operations, but it is not recommended because it can be extremely <a id="_idIndexMarker158"/>difficult to read even if you <span class="No-Break">use parentheses.</span></p>
			<p>Now that we are clear on how conditional structures work in JavaScript, it is time to explore loops in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor099"/>Understanding loops</h1>
			<p>There are many ways to create loops in JavaScript, but the most common are the <strong class="source-inline">for</strong> and <strong class="source-inline">while</strong> statements and variations of them that are specific to arrays and objects. Also, functions in JavaScript can be used to create loops when using recursion. In this section, we will look at only the <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, and <span class="No-Break"><strong class="source-inline">do...while</strong></span><span class="No-Break"> statements.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>while</h2>
			<p>The <strong class="source-inline">while</strong> statement creates a loop<a id="_idIndexMarker159"/> that executes a block of code as long as the <a id="_idIndexMarker160"/>condition is true. The condition is evaluated before executing the block <span class="No-Break">of code:</span></p>
			<pre class="source-code">
let i = 1;
while (i &lt;= 10) {
    console.log(i);
    i++;
};</pre>			<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>do...while</h2>
			<p>The <strong class="source-inline">do...while</strong> statement creates a<a id="_idIndexMarker161"/> loop that executes a block of code at least once<a id="_idIndexMarker162"/> even if the condition is not met, and then repeats the loop as long as the condition is true. The condition is evaluated after executing the block <span class="No-Break">of code:</span></p>
			<pre class="source-code">
let i = 0;
do {
    console.log(`i value: ${i}`);
    i++;
} while (false);
// i value: 0</pre>			<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>for</h2>
			<p>The <strong class="source-inline">for</strong> statement creates a loop that consists <a id="_idIndexMarker163"/>of three optional expressions, enclosed in parentheses and<a id="_idIndexMarker164"/> separated by semicolons, followed by a statement executed in <span class="No-Break">the loop:</span></p>
			<pre class="source-code">
for (let i = 0; i &lt; 10; i++) {
    console.log(i);
}</pre>			<p>The first expression is executed before the loop starts. Usually, it is used to initialize the variable that will act <span class="No-Break">as counter.</span></p>
			<p>The second expression is the condition that is evaluated before executing the block of code. If the condition is true, the block of code is executed. If the condition is false, the <span class="No-Break">loop stops.</span></p>
			<p>The third expression is executed after the block of code is executed. Usually, it is used to increment or decrement the <span class="No-Break">counter variable.</span></p>
			<p>This structure is quite flexible, and some developers tend to abuse it. Let’s see an example with <span class="No-Break">bad readability:</span></p>
			<pre class="source-code">
for (let i = 0, x = 1, z = 2, limit = 10; i &lt;= limit; x *= z, i++ ) {
    console.log(`i: ${i}. x: ${x}. z: ${z}`);
}
// i: 0. x: 1. z: 2
// ...
// i: 10. x: 1024. z: 2</pre>			<p>The readability issues are due to the large number of variables defined and updated in the <strong class="source-inline">for</strong> loop. It is important to<a id="_idIndexMarker165"/> remember that we write code that other <a id="_idIndexMarker166"/>programmers can understand in the future. Let’s see the same code<a id="_idIndexMarker167"/> with a more <span class="No-Break">readable approach:</span></p>
			<pre class="source-code">
let x = 1;
const z = 2, limit = 10;
for (let i = 0; i &lt;= limit; i++ ) {
    console.log(`i: ${i}. x: ${x}. z: ${z}`);
    x *= z
}</pre>			<p>You can already notice the difference; it takes less time and effort to understand it. In the next section, we will learn how to <span class="No-Break">use strings.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Using strings in JavaScript</h1>
			<p>Strings are primitive values. They are <a id="_idIndexMarker168"/>a sequence of characters. There are three ways to create strings in JavaScript: using single quotes, <strong class="source-inline">'</strong>, double quotes, <strong class="source-inline">"</strong>, or <span class="No-Break">backticks, </span><span class="No-Break"><strong class="source-inline">`</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
console.log('Hello World');
console.log("Hello World");
console.log(`Hello World`);</pre>			<p>Strings are immutable, which means <a id="_idIndexMarker169"/>that once they are created, they cannot be modified, but you can overwrite the variables or references depending on the data structure. So, all the methods that you use to modify a string will return a new string (<span class="No-Break">or array):</span></p>
			<p>Template strings allow you to use placeholders, <strong class="source-inline">${}</strong>, to insert variables or expressions inside a str<a id="_idTextAnchor104"/>ing. There is also added support for <span class="No-Break">multiple lines:</span></p>
			<pre class="source-code">
const name = "John";
console.log(`Hello ${name}!`) //Hello John!</pre>			<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Important methods</h2>
			<p>There are many ways to perform operations with strings, but in this section, we will see only the most important <a id="_idIndexMarker170"/>methods that you will use in your <span class="No-Break">day-to-day work:</span></p>
			<ul>
				<li><strong class="source-inline">String.prototype.indexOf()</strong>: Finds the index of the first occurrence of a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf</span></a></li>
				<li><strong class="source-inline">String.prototype.lastIndexOf()</strong>: Finds the index of the last occurrence of a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf</span></a></li>
				<li><strong class="source-inline">String.prototype.search()</strong>: Searches for a specified substring within a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search</span></a></li>
				<li><strong class="source-inline">String.prototype.includes()</strong>: Determines whether one string contains another string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes</span></a></li>
				<li><strong class="source-inline">String.prototype.match()</strong>: Extracts matches of a regular expression pattern from a <span class="No-Break">string </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match</span></a></li>
				<li><strong class="source-inline">String.prototype.matchAll()</strong>: Returns an iterator that yields all matches of a regular expression against a string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll</span></a></li>
				<li><strong class="source-inline">String.prototype.split()</strong>: Splits a string into an array of substrings based on a specified separator  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split</span></a></li>
				<li><strong class="source-inline">String.prototype.slice()</strong>: Extracts a<a id="_idIndexMarker171"/> section of a string and returns it as a new string  <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice</span></a></li>
				<li><strong class="source-inline">String.prototype.trim()</strong>: Removes whitespace characters from both ends of a <span class="No-Break">string </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim</span></a></li>
				<li><strong class="source-inline">String.prototype.replace()</strong>: Finds and replaces substrings within a <span class="No-Break">string </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace</span></a></li>
			</ul>
			<p>In the next section, we will learn how to use arrays, one of the most versatile data structures <span class="No-Break">in JavaScript.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor106"/>Exploring arrays</h1>
			<p>Arrays are non-primitive values; they are a collection of values. The values can be any type of value, including other arrays. Arrays<a id="_idIndexMarker172"/> are mutable, which means that you can modify them and the changes will be reflected in the <span class="No-Break">original array.</span></p>
			<p>Arrays are zero-indexed, which means that the first element is at index 0, the second element is at index 1, and <span class="No-Break">so on.</span></p>
			<p>The <strong class="source-inline">Array.isArray()</strong> method determines whether the passed value is <span class="No-Break">an array:</span></p>
			<pre class="source-code">
const array = [1, 2, 3];
console.log(Array.isArray(array)); // true
const object = { name: "Ulises" };
console.log(Array.isArray(object)); // false
console.log(typeof array); // object
console.log(typeof object); // object
console.log("are object and array the same type?", typeof(array) === typeof(object)); // true</pre>			<p>As arrays are objects, you <a id="_idIndexMarker173"/>need to be careful because they can’t be compared with the <strong class="source-inline">===</strong> or <strong class="source-inline">==</strong> operator, because it will compare the references, not <span class="No-Break">the values:</span></p>
			<pre class="source-code">
const array1 = [1, 2, 3];
const array2 = [1, 2, 3];
console.log(array1 === array2); // false</pre>			<p>Arrays have a <strong class="source-inline">length</strong> property that returns the number of elements in the array and provides an easy way to iterate over <span class="No-Break">the array.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Basic operations</h2>
			<p>In this section, we will look at the <a id="_idIndexMarker174"/>most common operations that you will perform <span class="No-Break">with arrays.</span></p>
			<h3>Creating an array</h3>
			<p>There are many ways<a id="_idIndexMarker175"/> to create an array in JavaScript. The most common is using the array literal notation, <strong class="source-inline">[]</strong>, but you can also create an array from other data types, such as when you split a string, or using the <strong class="source-inline">string.prototype.split()</strong> method. The following is an example of creating an array using the array <span class="No-Break">literal notation:</span></p>
			<pre class="source-code">
const emptyArray = [];
const numbers = [1, 2, 3];
const strings = ["Hello", "World"];
const mixed = [1, "Hello", true];</pre>			<p>The <strong class="source-inline">Array.of()</strong> method creates a new array instance from a variable number of arguments, regardless of the number or type of <span class="No-Break">the arguments:</span></p>
			<pre class="source-code">
<strong class="source-inline">const array = Array.of( 1, 2, 3 );</strong></pre>			<p>The <strong class="source-inline">Array.from()</strong> method <a id="_idIndexMarker176"/>creates a new array instance from an array-like or <span class="No-Break">iterable object:</span></p>
			<pre class="source-code">
console.log(Array.from('packt'));   // ['p', 'a', 'c', 'k', 't']</pre>			<p>The spread operator, <strong class="source-inline">...</strong>, can be used to create a new array from an existing array or from <span class="No-Break">a string:</span></p>
			<pre class="source-code">
console.log([...[1, 2, 3]]);    // [1, 2, 3]
console.log([...'packt']);      // ['p', 'a', 'c', 'k', 't']</pre>			<p>Also, you can pass a map function as a second parameter so you can perform transformations when the array <span class="No-Break">is created:</span></p>
			<pre class="source-code">
console.log(Array.from([1, 2, 3], x =&gt; x + x)); // [2, 4, 6]</pre>			<h3>Accessing items</h3>
			<p>You can access an item in an<a id="_idIndexMarker177"/> array using the index of <span class="No-Break">the item:</span></p>
			<pre class="source-code">
const fruits = ['banana', 'apple', 'orange'];
console.log(fruits[0]); // banana
console.log(fruits[1]); // apple
console.log(fruits[2]); // orange</pre>			<h3>Replacing items</h3>
			<p>You can replace an item in an <a id="_idIndexMarker178"/>array using the index of <span class="No-Break">the item:</span></p>
			<pre class="source-code">
const fruits = ['banana', 'apple', 'orange'];
fruits[0] = 'pear';
console.log(fruits); // ['pear', 'apple', 'orange']</pre>			<h3>Adding items</h3>
			<p>You can add items to an <a id="_idIndexMarker179"/>array using two <span class="No-Break">main methods:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.push()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.unshift()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift</span></a></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">It is always preferable to add new items to the end of the array, because adding items to the beginning of the array is an expensive operation. This is because it requires re-indexing all the items in <span class="No-Break">the array.</span></p>
			<h3>Removing items</h3>
			<p>There are several methods that <a id="_idIndexMarker180"/>allow you to remove items from <span class="No-Break">the array:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.pop()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.shift()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.splice()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice</span></a></li>
			</ul>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor108"/>Iterating over an array</h2>
			<p>As we saw at the beginning of<a id="_idIndexMarker181"/> this chapter, it is possible to iterate over an array using a <strong class="source-inline">for</strong> loop, but there are also other ways to iterate over <span class="No-Break">an array.</span></p>
			<p>JavaScript provides great support for declarative programming, which is especially useful when you need to iterate over arrays. So, let’s summarize the most common ways to iterate over <span class="No-Break">an array.</span></p>
			<p>Most of these methods receive a function as a parameter, and it is executed for each item in the array. Depending on the method used and  the data returned from the function  will get one result <span class="No-Break">or another.</span></p>
			<p>Another important thing to remember is that these methods can be chained together, so you can use one method after another and compose more <span class="No-Break">complex operations.</span></p>
			<h3>Iteration</h3>
			<p>As arrays can store a lot of elements, it is <a id="_idIndexMarker182"/>important to get familiar with the methods that are provided by the array in order to properly iterate over them. The most common are <strong class="source-inline">Array.prototype.map()</strong> and <strong class="source-inline">Array.prototype.forEach()</strong>. In both cases, we will iterate over the array, but <strong class="source-inline">Array.prototype.map()</strong> will directly return a new array with the applied transformation. Let’s see an example comparing <span class="No-Break">both methods:</span></p>
			<pre class="source-code">
const numbers = [1, 2, 3, 4, 5]
const mapTransformation = numbers.map(el =&gt; el * 10)
const forEachTransformation = []
numbers.forEach(el =&gt; {
    forEachTransformation.push(el * 10)
})
console.log(mapTransformation) // 10,20,30,40,50
console.log(forEachTransformation) // 10,20,30,40,50</pre>			<h3>Validation</h3>
			<p>As arrays can contain any type of data, it is<a id="_idIndexMarker183"/> common to need to validate whether an array contains a specific item or whether all the items in the array match a condition. There are several methods, but the most common are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.every()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.some()</strong></span><span class="No-Break">:</span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some"><span class="No-Break"> https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.includes()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes</span></a></li>
			</ul>
			<h3>Filtering</h3>
			<p>Arrays can store a<a id="_idIndexMarker184"/> lot of information, and it is quite common to store nested structures such as big objects. There are many ways to do filtering in JavaScript. The most important difference between them is what your expected output is as sometimes we will be interested in a new array with the filtered values, but other times we might want the position (index) of certain elements in the array. The most used method is <strong class="source-inline">Array.prototype.filter()</strong>, which is used to generate a new array with the elements that pass certain criteria. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const numbers = [1, 2, 3, 4, 5]
const filteredNums = numbers.filter(el =&gt; el &lt;= 3)
console.log(filteredNums) // [1, 2, 3]</pre>			<p>There are several methods that you will find relevant in <span class="No-Break">this category:</span></p>
			<ul>
				<li><strong class="source-inline">Array.prototype.slice()</strong>: Returns the copy of a portion of the <span class="No-Break">array </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</span></a></li>
				<li><strong class="source-inline">Array.prototype.find()</strong>: Returns the value of the first item in the array that satisfies the <a id="_idIndexMarker185"/>provided <span class="No-Break">criteria </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find</span></a></li>
				<li><strong class="source-inline">Array.prototype.findIndex()</strong>: Returns the index of the first item in the array that satisfies the <span class="No-Break">criteria </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex</span></a></li>
			</ul>
			<h3>Utilities</h3>
			<p>Sometimes you need to flatten<a id="_idIndexMarker186"/> an array of arrays. You can use the <strong class="source-inline">array.flat()</strong> method to <span class="No-Break">do that:</span></p>
			<pre class="source-code">
const data = [1, [2, 3], [4, 5]];
const flatData = data.flat();
console.log(flatData); // [1, 2, 3, 4, 5]</pre>			<p>Another common method is the <strong class="source-inline">array.join()</strong> method, which is used to join all the items in an array into <span class="No-Break">a string:</span></p>
			<pre class="source-code">
const people = ['Joe', 'Jane', 'John', 'Jack'];
console.log(people.join()); // Joe,Jane,John,Jack
console.log(people.join(' + ')); // Joe + Jane + John + Jack</pre>			<p>This is very useful when you need to create a string with a list of items, for example, when you need to create a list of items in HTML, XML, Markdown, and <span class="No-Break">so on:</span></p>
			<pre class="source-code">
const people = ['Joe', 'Jane', 'John', 'Jack'];
const structuredPeople = people.map(person =&gt; `&lt;li&gt;${person}&lt;/li&gt;\n`);
console.log(`
    &lt;ul&gt;
        ${structuredPeople.join('')}
    &lt;/ul&gt;
`)
// &lt;ul&gt;
//     &lt;li&gt;Joe&lt;/li&gt;
//      ...
// &lt;/ul&gt;</pre>			<p>While working with data, it is very<a id="_idIndexMarker187"/> common that we need to sort the items in the array. This can be done with <strong class="source-inline">array.sort()</strong>. In general, it is better if we provide a function that specifies how to properly sort the items just to avoid unexpected results. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const numbers = [7, 1,10, 3,15,20]
console.log(numbers.sort())
// [1, 10, 15, 20, 3, 7]
console.log(numbers.sort((a, b) =&gt; a - b))
// [1, 3, 7, 10, 15, 20]</pre>			<p>There are several methods that are quite useful and you will find yourself using <span class="No-Break">very frequently:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.reverse()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.concat()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.fill()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Array.prototype.reduce()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><span class="No-Break">https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce</span></a></li>
			</ul>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Destructuring</h2>
			<p>ES6 introduced a new syntax for destructuring arrays and objects. The left-hand side of an assignment is now a<a id="_idIndexMarker188"/> pattern for extracting values from arrays and objects. This pattern can be used in variable declarations, assignments, function parameters, and function return values. Also, you can use default values (fail-soft) in case the value is not present in <span class="No-Break">the array.</span></p>
			<p>In the following code sample, we can see the classic way to do <span class="No-Break">a fail-soft:</span></p>
			<pre class="source-code">
const list = [1, 2];
const a = list[0] || 0; // 1
const b = list[1] // 2
const c = list[2] || 4; // 4</pre>			<p>The following snippet contains the same code but using ECMAScript <span class="No-Break">6 destructuring:</span></p>
			<pre class="source-code">
const list = [1, 2];
const [ a = 0, b, c = 4 ] =<a id="_idTextAnchor110"/> list;</pre>			<p>As you can see, this version is more compact. Currently, this is the more popular way to assign default values when it is possible to combine it <span class="No-Break">with destructuring.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor111"/>Sets</h2>
			<p>ES6 introduces a new data structure called <strong class="source-inline">Set</strong>. A Set is a collection of values, where each value may occur only once. It can be <a id="_idIndexMarker189"/>used to store a collection of values, but it is not an array as it doesn’t have indexes. It is quite a common solution to remove duplicate values from an array, as we can see in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let arr = [1,2,2,3,1,4,5,4,5]
let set = new Set(arr)
let uniques = Array.from(set)
console.log(uniques) // [1,2,3,4,5]</pre>			<p>You can find more information about set-specific methods <span class="No-Break">at </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</span></a><span class="No-Break">.</span></p>
			<p>In the next section, we will learn how to use objects, one of the most powerful data structures <span class="No-Break">in JavaScript.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor112"/>Using objects in JavaScript</h1>
			<p>Objects are non-primitive values; they are <a id="_idIndexMarker190"/>a collection of properties. A property is a key-value pair. The key is always a string, and the value can be any type of value, including <span class="No-Break">other objects.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Basic operations</h2>
			<p>Objects are the most versatile<a id="_idIndexMarker191"/> structure in JavaScript. In this section, we will learn how to create objects, how to access and modify their properties, and how to iterate over the properties of <span class="No-Break">an object.</span></p>
			<h3>Creating an object</h3>
			<p>You can create an object using <a id="_idIndexMarker192"/>the object literal syntax, that is, using <span class="No-Break">curly braces:</span></p>
			<pre class="source-code">
const person = {}</pre>			<p>You can also create an object and directly <span class="No-Break">add properties:</span></p>
			<pre class="source-code">
const person = {
    name: 'Jane',
}</pre>			<p>You can store any type of value in an object, including other objects or <span class="No-Break">functions (methods):</span></p>
			<pre class="source-code">
const person = {
    name: 'Jane',
    id: 1,
    favoriteColors: ['blue', 'green'],
    address: {
        street: 'Main St',
        number: 1,
    },
    fullName: function() {
        return `${this.name} Doe`
    },
    sayHi: function() {
        console.log('Hello!')
    }
}
console.log(person.fullName()) // Jane Doe
person.sayHi() // Hello!
console.log(person.address.street) // Main St
console.log(person.id) // 1
console.log(person.favoriteColors[0]) // blue</pre>			<h3>Creating and accessing properties</h3>
			<p>You can create a new <a id="_idIndexMarker193"/>property or overwrite existing ones in an object by assigning <span class="No-Break">a</span><span class="No-Break"><a id="_idIndexMarker194"/></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
const person = {
    id: 12
}
person.name = 'Jane'
console.log(person.name) // Jane
person.id = 1
console.log(person.id) // 1</pre>			<p>You can also access the properties of an object using the bracket notation, which is useful when using programmatic access or when using keys with special characters <span class="No-Break">or whitespaces:</span></p>
			<pre class="source-code">
const person = {
    id: 12
}
console.log(person['id']) // 12
const specialKey = 'first name with spaces'
person[specialKey] = 'Jane'
console.log(person[specialKey]) // Jane</pre>			<h3>Deleting properties</h3>
			<p>You can delete a property <a id="_idIndexMarker195"/>from an object using the <strong class="source-inline">delete</strong> operator or overwrite it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const person = {
    id: 12,
    name: 'Jane'
}
delete person.id
person.name = undefined
console.log(person.id) // undefined
console.log(person.name) // undefined</pre>			<h2 id="_idParaDest-110"><a id="_idTextAnchor114"/>Iteration</h2>
			<p>Let’s see how to iterate over<a id="_idIndexMarker196"/> the properties of an object, and how to get an array with the keys and values of <span class="No-Break">an object.</span></p>
			<p>This is our <span class="No-Break">base object:</span></p>
			<pre class="source-code">
const users = {
    admin: 'Jane',
    moderator: 'Joe',
    user: 'Billy',
}</pre>			<p>You can iterate over the properties of an object using the <span class="No-Break"><strong class="source-inline">for...in</strong></span><span class="No-Break"> loop:</span></p>
			<pre class="source-code">
for (let role in users) {
    console.log(`${users[role]} is the ${role}`)}
// Jane is the admin
// Joe is the moderator
// Billy is the user</pre>			<p>You can also use the <strong class="source-inline">Object.keys()</strong> method to get an array with the keys of an object, so you can use array-specific methods<a id="_idIndexMarker197"/> to manage the iteration, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">array.prototype.forEach()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const roles = Object.keys(users)
console.log(roles) // ['admin', 'moderator', 'user']
roles.forEach(role =&gt; {
    console.log(role) // admin
    console.log(users[role]) // Jane
})</pre>			<p>You can also use additional methods introduced recently in <span class="No-Break">the language:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Object.values()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Object.entries()</strong></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries</span></a></li>
			</ul>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor115"/>Shallow copy versus deep copy</h2>
			<p>The way JavaScript works means<a id="_idIndexMarker198"/> that sometimes we don’t get the expected copy of a variable. Let’s see a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const name = "Jane"
const number = 1
const array = [1, 2, 3]
const object = { id: 1, name: 'Jane' }
// Copy
let nameCopy = name
let numberCopy = number
const arrayCopy = array
const objectCopy = object
// Modify the copy
nameCopy = 'Joe'
numberCopy = 2
arrayCopy.push("additional item")
objectCopy.name = 'Joe'
// Check the original
console.log(name) // Jane
console.log(nameCopy) // Joe
console.log(number) // 1
console.log(numberCopy) // 2
console.log(array) // [1, 2, 3, "additional item"]
console.log(arrayCopy) // [1, 2, 3, "additional item"]
console.log(object) // { id: 1, name: 'Joe' }
console.log(objectCopy) // { id: 1, name: 'Joe' }</pre>			<p>This is quite a specific behavior of JavaScript that frustrates many developers. How is it possible that the original variable is modified when we modify the copy? The answer is that <a id="_idIndexMarker199"/>we are not copying the variable (<em class="italic">deep copy</em>) in all the scenarios; we are copying the reference to the variable (<span class="No-Break"><em class="italic">shallow copy</em></span><span class="No-Break">).</span></p>
			<p>Only the primitive types (<em class="italic">string, number, Boolean, null, undefined, </em>and <em class="italic">symbol</em>) are copied by value; the rest are copied by reference, so you actually get a reference to the original variable, like <span class="No-Break">a shortcut.</span></p>
			<p>This allows you to do some interesting things, such as  create shortcut references for very <span class="No-Break">nested objects:</span></p>
			<pre class="source-code">
const data = {item: {detail: { reference: {id: '123'} }}}
// make a shortcut reference
const ref = data.item.detail.reference
ref.name = 'Jane'
// check the original
console.log(data.item.detail.reference) // {id: '123', name: 'Jane'}</pre>			<p>But, as you can see, this can lead to changes in the original object. This can be an unexpected behavior if <a id="_idIndexMarker200"/>we are not clear how the original structure was copied. It can be trickier to detect if you are using <span class="No-Break">nested structures.</span></p>
			<p>If you want to get a deep copy of a simple object, you can use <strong class="source-inline">Object.assign()</strong> or the spread <span class="No-Break">operator, </span><span class="No-Break"><strong class="source-inline">...</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const array = [1, 2, 3]
const object = { id: 1, name: 'Jane' }
// Copy
const arrayCopy = [...array]
const objectCopy = Object.assign({}, object)
// Modify the copy
arrayCopy.push("additional item")
objectCopy.name = 'Joe'
// Check the original
console.log(array) // [1, 2, 3]
console.log(arrayCopy) // [1, 2, 3, "additional item"]
console.log(object) // { id: 1, name: 'Jane' }
console.log(objectCopy) // { id: 1, name: 'Joe' }</pre>			<p>But the nested objects<a id="_idIndexMarker201"/> will be copied by reference, so you will get the same behavior <span class="No-Break">as before:</span></p>
			<pre class="source-code">
const data = [{ 'a': 1 }, { 'b': 2 }];
const shallowCopy = [...data];
shallowCopy[0].a = 3;
console.log(data[0].a); // 3
console.log(shallowCopy[0].a); // 3</pre>			<p>An alternative is to use a specialized library such as Lodash (<a href="https://lodash.com/docs/4.17.15#cloneDeep">https://lodash.com/docs/4.17.15#cloneDeep</a>) or transform it into JSON and digest the structure, but this has some limitations, such as not being able to copy functions or items that are not defined in the JSON <span class="No-Break">specs (</span><a href="https://datatracker.ietf.org/doc/html/rfc7159"><span class="No-Break">https://datatracker.ietf.org/doc/html/rfc7159</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Merging objects</h2>
			<p>Merging two objects can be done with <strong class="source-inline">Object.assign</strong>, but you need to understand <span class="No-Break">two things:</span></p>
			<ul>
				<li>The order is important, so<a id="_idIndexMarker202"/> the first item will be overwritten by the next item when they share <span class="No-Break">common properties</span></li>
				<li>If the objects are complex data structures such as nested objects or arrays, then the final object will copy the references (<span class="No-Break">shallow copy)</span></li>
			</ul>
			<p>Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const dst  = { quux: 0 }
const src1 = { foo: 1, bar: 2 }
const src2 = { foo: 3, baz: 4 }
Object.assign(dst, src1, src2)
console.log(dst) // {quux: 0, foo: 3, bar: 2, baz: 4}</pre>			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Destructuring</h2>
			<p>Since ES6, JavaScript has provided<a id="_idIndexMarker203"/> destructuring assignment for objects, which is very handy for extracting and including values in objects. Let’s see an example with a <span class="No-Break">simple object:</span></p>
			<pre class="source-code">
const name = "Jane";
const age = 25;
const data = { item: "Lorem Ipsum", status: "OK" };</pre>			<p>If we didn’t use destructuring, we would have to do something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const user = {
  name: name,
  age: age,
  data: data,
};
const item = data.item;
const status = data.status;</pre>			<p>But with destructuring, we can do it in a more <span class="No-Break">concise way:</span></p>
			<pre class="source-code">
const user = { name, age, data };
const { item, status } = data;</pre>			<h2 id="_idParaDest-114"><a id="_idTextAnchor118"/>Optional chaining (?.)</h2>
			<p>The optional chaining operator is a new operator introduced in ES2020. It allows you to access deeply nested properties <a id="_idIndexMarker204"/>of an object without worrying about whether the <a id="_idIndexMarker205"/>property exists or not. Before the optional chaining operator, you had to check whether the property exists before accessing it. This was quite tedious for very nested structures. Let’s see a <span class="No-Break">practical example:</span></p>
			<pre class="source-code">
const user = {
  name: "John",
  address: {
    street: "Main Street",
  },
};
const otherUser = {
  name: "Jane",
};
console.log(user.address?.street); // Main Street
console.log(otherUser.address?.street); // undefined
// without optional chaining:
console.log(user.address.street); // Main Street
console.log(otherUser.address.street); // TypeError: Cannot read properties of undefined (reading 'street')</pre>			<p>Now that we are familiar <a id="_idIndexMarker206"/>with most of the data structures, it is time to explore functions in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor119"/>Exploring functions</h1>
			<p>Functions are one of the more meaningful structures in JavaScript. There are certain characteristics that make them different from other programming languages; for example, they are<a id="_idIndexMarker207"/> first-class citizens, which means that they can be assigned to a variable, passed as an argument to another function, or returned from <span class="No-Break">another function.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>The basics</h2>
			<p>There are many advanced <a id="_idIndexMarker208"/>concepts related to functions, but in this section, we will just look at the basics of functions in JavaScript. We will start with the declaration, execution, and arguments using the <strong class="source-inline">function</strong> keyword. Then, we will focus on<a id="_idIndexMarker209"/> arrow functions <span class="No-Break">and closures.</span></p>
			<h3>Declaration</h3>
			<p>In essence, a function is a<a id="_idIndexMarker210"/> block of code that can be executed when it is called. In JavaScript, we can declare a function using the <strong class="source-inline">function</strong> keyword. The syntax is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
function myFunction() {
  console.log("This is a function body")
  // code to be executed
}</pre>			<h3>Execution</h3>
			<p>The function is not executed when it is declared; it is executed when it is called. To call a function, we just need to<a id="_idIndexMarker211"/> write the name of the function followed by parentheses. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
const myFunction = function() {
  console.log("This is a function body")
  // code to be executed
}
myFunction() // This is a function body</pre>			<h3>Anonymous functions</h3>
			<p>Functions can also be declared as a function<a id="_idIndexMarker212"/> expression. This is known as anonymous functions. A simple example is when we pass the function as an argument to another function, like when we use timers – <strong class="source-inline">setTimeout</strong>, in <span class="No-Break">this case:</span></p>
			<pre class="source-code">
setTimeout(function() {
    console.log('1 second later')
}, 1000);</pre>			<h3>Return values</h3>
			<p>A function can return a value using the <strong class="source-inline">return</strong> keyword. This value can be assigned to a variable or used in <a id="_idIndexMarker213"/>another function. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
function isEven(number) {
  return number % 2 === 0
}
const result = isEven(2)
const otherResult = isEven(3)
console.log(result) // true
console.log(otherResult) // false</pre>			<h3>Arguments</h3>
			<p>Functions can receive<a id="_idIndexMarker214"/> arguments; these arguments are passed to the function when it is called. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
function sayHi (name) {
  console.log(`Hi ${name}!`);
};
sayHi('John'); // Hi John!</pre>			<p>You don’t need to specify the arguments; you can use the rest operator (<strong class="source-inline">...</strong>) to access the arguments. In this example, we will sum all the numbers passed to <span class="No-Break">the function:</span></p>
			<pre class="source-code">
function sum (...numbers) {
  console.log("First Number:", numbers[0])
  console.log("Last Number:", numbers[numbers.length - 1])
  let total = 0
  for (let number of numbers) {
    total += number
  }
  console.log("Total (SUM):", total)
}
const result = sum(1, 2, 3, 4, 5)
// First Number: 1
// Last Number: 5
// Total (SUM): 15</pre>			<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Arrow functions</h2>
			<p>One of the most important<a id="_idIndexMarker215"/> features introduced in ES6 is arrow functions. They are a new syntax for writing JavaScript functions, but they also introduce certain changes that <a id="_idIndexMarker216"/>are important to be <span class="No-Break">aware of:</span></p>
			<ul>
				<li>Arrow functions introduce a new syntax for <span class="No-Break">writing functions</span></li>
				<li>Arrow functions are <span class="No-Break">always anonymous</span></li>
			</ul>
			<h3>Syntax</h3>
			<p>Since the beginning of JavaScript, we <a id="_idIndexMarker217"/>declared functions using the <strong class="source-inline">function</strong> keyword, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
const sampleFunction = function () { }
const sayHelloNow = function (name) {
  const now = new Date()
  console.log(`Hello ${name}, at ${now}!`)
}</pre>			<p>The new syntax for writing arrow functions uses <strong class="source-inline">=&gt;</strong> and does not use the <strong class="source-inline">function</strong> keyword. The following<a id="_idIndexMarker218"/> example is the same as the previous one but with the <span class="No-Break">new syntax:</span></p>
			<pre class="source-code">
const sampleFunction = () =&gt; {}
const sayHelloNow = name =&gt; {
  const now = new Date()
  console.log(`Hello ${name}, at ${now}!`)
}</pre>			<p>The new syntax has an implicit return, so if you want to return a value, you can do it without using the <span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source-code">
const alwaysTrue = () =&gt; true
const getData = (name, age) =&gt; ({ name: "John", age: 25 })</pre>			<p>The previous example can be translated to the previous syntax <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const alwaysTrue = function () { return true }
const getData = function (name, age) {
  return { name: "John", age: 25 }
}</pre>			<p>Arrow functions can receive arguments, but if you want to receive more than one argument, you need to <span class="No-Break">use parentheses:</span></p>
			<pre class="source-code">
const sum = function (a, b) { return a + b }
// Arrow function translation
const sum = (a, b) =&gt; a + b</pre>			<h3>Behavior changes</h3>
			<p>Due to the fact that JavaScript has retro compatibility with older versions, arrow functions introduce certain changes in the behavior of the functions. The most important one is related to the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> keyword.</span></p>
			<p>Also, arrow functions do not <a id="_idIndexMarker219"/>have a <strong class="source-inline">prototype</strong> property, which means that they cannot be used as constructors or <span class="No-Break">method handlers.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The management of <strong class="source-inline">this</strong> in JavaScript can be a bit confusing and is quite advanced for the objectives of this book. If you want to learn more about it, you can read the MDN <span class="No-Break">documentation: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Closures</h2>
			<p>This is one of the most popular and<a id="_idIndexMarker220"/> important concepts in JavaScript, but it is a bit advanced, and it is not easy <span class="No-Break">to understand.</span></p>
			<h3>So, what is a closure?</h3>
			<p>Basically, a closure is a function<a id="_idIndexMarker221"/> returned by another function. Here, we have <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const outerFunction = function () {
  console.log("This is the outer function")
  const innerFunction = function () {
    console.log("This is the inner function")
  }
  return innerFunction
}</pre>			<p>In this example, <strong class="source-inline">outerFunction</strong> returns <strong class="source-inline">innerFunction</strong>, so we can call <strong class="source-inline">innerFunction</strong> after <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">outerFunction</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const innerFunction = outerFunction() // This is the outer function
innerFunction() // This is the inner function</pre>			<p>Now, let’s achieve the same<a id="_idIndexMarker222"/> result using less code by doing both executions in the <span class="No-Break">same statement:</span></p>
			<pre class="source-code">
// Execution in single line
outerFunction()()</pre>			<h3>But how is this useful?</h3>
			<p>The most important thing about<a id="_idIndexMarker223"/> closures is that they can access and even modify the scope of the parent function (code block and arguments), even after the parent function has returned. Let’s see a <span class="No-Break">practical example:</span></p>
			<pre class="source-code">
const createCounter = (initialValue = 0) =&gt; {
  let counter = initialValue
  return (incrementalValue) =&gt; {
    counter += incrementalValue
    console.log(counter)
  }
}</pre>			<p>In this example, we added the <strong class="source-inline">initialValue</strong> and <strong class="source-inline">incrementalValue</strong> arguments to the functions, and also, we defined the <strong class="source-inline">counter</strong> variable to store the counter’s current value. In practice, we can use this function to create a counter that starts from a specific value, and then we can increment it by a specific value. We can’t access the <strong class="source-inline">counter</strong> variable directly because it lives only in the scope within the function and not outside, but we can use the closure to access it and even manipulate<a id="_idIndexMarker224"/> <span class="No-Break">the value:</span></p>
			<pre class="source-code">
const addToCounter = createCounter(10)
addToCounter(12) // 22
addToCounter(1)  // 23</pre>			<p>In this example, we saw the basic usage of closures, but they can be used for many other things. One of the most common usages is to create abstractions to manage third-party services such as databases <span class="No-Break">and APIs.</span></p>
			<p>We will use this structure in the following chapters when using MongoDB <span class="No-Break">and Express.</span></p>
			<p>In the next section, we will learn how to create and manage classes, as well as how prototypical inherence works <span class="No-Break">in JavaScript.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor123"/>Creating and managing classes</h1>
			<p>Classes were introduced in ES6. They <a id="_idIndexMarker225"/>are syntactic sugar over the prototype-based inheritance. Historically, JavaScript did not have formal classes as we can expect from the typical Object Oriented Programing (<span class="No-Break">OOP) languages.</span></p>
			<p>In this section, we will learn how to create classes and how to use them with ES6. Also, we will explore how the prototypical inheritance is a key feature in maintaining retro compatibility and extends JavaScript’s <span class="No-Break">core features.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Creating a class</h2>
			<p>To create a class, we<a id="_idIndexMarker226"/> need to use the <strong class="source-inline">class</strong> keyword, and then we can define the default properties of the class using the <span class="No-Break"><strong class="source-inline">constructor</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
class Human{
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const jane = new Human ("Jane", 30);
console.log(jane.name); // Jane
console.log(jane.age); // 30</pre>			<p>In this example, we created a class called <strong class="source-inline">Human</strong> and then we created an instance of the class<a id="_idIndexMarker227"/> called <strong class="source-inline">jane</strong>. We can access the properties of the class using <span class="No-Break">dot notation.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Class methods</h2>
			<p>To define a method in a <a id="_idIndexMarker228"/>class, we need to use a similar syntax as we use for defining methods <span class="No-Break">in objects:</span></p>
			<pre class="source-code">
class Human {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHello() {
    console.log(`Hello, my name is ${this.name}!`);
  }
}
const jane = new Human ("Jane", 30);
jane.sayHello(); // Hello, my name is Jane!</pre>			<p>In this example, we defined a method called <strong class="source-inline">sayHello</strong> in the <strong class="source-inline">Human</strong> class, then we created an instance of the class, and we called <span class="No-Break">the method.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>Extending classes</h2>
			<p>We can extend <a id="_idIndexMarker229"/>classes using the <strong class="source-inline">extends</strong> keyword. This will allow us to inherit the properties and methods of the <span class="No-Break">parent class:</span></p>
			<pre class="source-code">
class Colleague extends Human {
  constructor(name, age, stack) {
    super(name, age);
    this.stack = stack;
    this.canCode = true;
  }
  code() {
    console.log(`I can code in ${this.stack}!`);
  }
}
const jane = new Colleague ("Jane", 30, ['JavaScript', 'React', 'MongoDB']);
console.log(jane.name); // Jane
console.log(jane.canCode); // true
jane.sayHello(); // Hello, my name is Jane!
jane.code(); // I can code in JavaScript, React and MongoDB!</pre>			<p>In this example, we created a class called <strong class="source-inline">Colleague</strong> that extends the <strong class="source-inline">Human</strong> class, then we created an instance of the class, and we called the methods and properties inherited from <span class="No-Break">both classes.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor127"/>Static methods</h2>
			<p>Static methods are methods <a id="_idIndexMarker230"/>that can be called without instantiating the class. They are defined using the <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source-code">
class Car {
  constructor(brand) {
    this.brand = brand;
  }
  move() {
    console.log(`The ${this.brand} is moving!`);
  }
  static speedLimits() {
    console.log("The speed limit is 120 km/h for new cars");
  }
}</pre>			<p>Now, we can call the <strong class="source-inline">speedLimits</strong> method without instantiating <span class="No-Break">the class:</span></p>
			<pre class="source-code">
Car.speedLimits(); // The speed limit is 120 km/h for new cars</pre>			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Getters and setters</h2>
			<p>As in other languages that support object-oriented <a id="_idIndexMarker231"/>programming, you can define getters <a id="_idIndexMarker232"/>and setters using the <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> keywords, respectively. This will allow you to access and modify the properties of<a id="_idTextAnchor129"/> the instance in a more <span class="No-Break">classic way:</span></p>
			<pre class="source-code">
class Rectangle {
    constructor (width, height) {
        this._width  = width
        this._height = height
    }
    set width  (width)  { this._width = width               }
    get width  ()       { return this._width                }
    set height (height) { this._height = height             }
    get height ()       { return this._height               }
    get area   ()       { return this._width * this._height }
}
const shape = new Rectangle(5, 2)
console.log(shape.area) // 10
console.log(shape.height) // 2
console.log(shape.width) // 5
shape.height = 10
shape.width = 10
console.log(shape.area) // 100
console.log(shape.height) // 10
console.log(shape.width) // 10</pre>			<h1 id="_idParaDest-125"><a id="_idTextAnchor130"/>Summary</h1>
			<p>In this chapter, we explored JavaScript’s history and current state. We learned about the different versions of the language and how the language has evolved over time. We also learned about how the new features are added to <span class="No-Break">the language.</span></p>
			<p>Also, we learned how to find the best documentation about the language and how to use it to learn about the language in <span class="No-Break">more depth.</span></p>
			<p>Additionally, we explored how to use numbers, dates, conditional statements, loops, strings, arrays, objects, and functions, among others, <span class="No-Break">in detail.</span></p>
			<p>Furthermore, we learned about classes and prototype-based inheritance and how it is a key feature to maintain retro compatibility and extends JavaScript’s <span class="No-Break">core features.</span></p>
			<p>In the next chapter, we will learn about asynchronous programming with JavaScript. You will apply all the knowledge learned in this chapter to manage asynchronous code using different approaches, such as callbacks, promises, <span class="No-Break">and async/await.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor131"/>Further reading</h1>
			<ul>
				<li>The Weird History of <span class="No-Break">JavaScript: </span><a href="https://www.youtube.com/watch?v=Sh6lK57Cuk4"><span class="No-Break">https://www.youtube.com/watch?v=Sh6lK57Cuk4</span></a></li>
				<li>A Brief History of JavaScript, talk by Brendan Eich (creator of <span class="No-Break">JavaScript): </span><a href="https://www.youtube.com/watch?v=qKJP93dWn40"><span class="No-Break">https://www.youtube.com/watch?v=qKJP93dWn40</span></a></li>
				<li>TC39 Demystified, by Ujjwal <span class="No-Break">Sharma: </span><a href="https://www.youtube.com/watch?v=YLHhRpaPly8"><span class="No-Break">https://www.youtube.com/watch?v=YLHhRpaPly8</span></a></li>
				<li>Documenting the Web Platform, by Florian <span class="No-Break">Scholz: </span><a href="https://www.youtube.com/watch?v=f_M0vQcKiW4"><span class="No-Break">https://www.youtube.com/watch?v=f_M0vQcKiW4</span></a></li>
				<li>TC39: From the Proposal to ECMAScript, Step by Step, by Romulo <span class="No-Break">Cintra: </span><a href="https://www.youtube.com/watch?v=h5pUuz2qqVQ"><span class="No-Break">https://www.youtube.com/watch?v=h5pUuz2qqVQ</span></a></li>
			</ul>
		</div>
	</body></html>