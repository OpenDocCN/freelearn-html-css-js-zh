- en: '[CHAPTER 2](toc.xhtml#c02)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第二章](toc.xhtml#c02)'
- en: '[Introduction to TypeScript](toc.xhtml#c02)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[TypeScript介绍](toc.xhtml#c02)'
- en: '[Introduction](toc.xhtml#s32a)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[介绍](toc.xhtml#s32a)'
- en: Millions of applications are developed in JavaScript, but developers face many
    issues while developing it. JavaScript runs directly without compiling the code
    first. Due to dynamic typing and lack of compile-time checks, issues like runtime
    errors, code complexity, and maintenance of large codebase are common. TypeScript
    was introduced as a superset of JavaScript to address all such issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中开发的应用程序数以百万计，但开发者在开发过程中面临许多问题。JavaScript直接运行而不先编译代码。由于动态类型和缺少编译时检查，运行时错误、代码复杂性和大型代码库的维护等问题很常见。TypeScript作为JavaScript的超集被引入，以解决所有这些问题。
- en: In this chapter, we will discuss the basic concepts of TypeScript and how to
    use it instead of JavaScript in your application while developing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论TypeScript的基本概念以及如何在开发应用程序时使用TypeScript代替JavaScript。
- en: '[Structure](toc.xhtml#s33a)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s33a)'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Overview of TypeScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript概述
- en: Advantages of TypeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的优势
- en: Pitfalls of TypeScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的陷阱
- en: Installing TypeScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装TypeScript
- en: Building a Basic Application with TypeScript
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TypeScript构建基本应用程序
- en: OOP (Object-Oriented Programming) Concepts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）概念
- en: Features of ECMAScript
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript特性
- en: EsLint
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EsLint
- en: '[Overview of TypeScript](toc.xhtml#s34a)'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[TypeScript概述](toc.xhtml#s34a)'
- en: TypeScript is a superset of JavaScript, meaning all JavaScript features are
    present and other extra features are bundled in it. JavaScript is an object-based
    language but does not provide all the concepts of object-oriented programming,
    so the missing part is achieved through TypeScript. TypeScript is an open-source
    programming language that is developed and maintained by Microsoft. It was released
    in 2012 and is often abbreviated as TS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的超集，这意味着所有JavaScript特性都存在，并且还包含其他额外特性。JavaScript是一种基于对象的语言，但它不提供面向对象编程的所有概念，所以缺失的部分通过TypeScript来实现。TypeScript是由微软开发和维护的开源编程语言。它于2012年发布，通常缩写为TS。
- en: Displayed in the image (see *[Figure 2.1](#fig2_1)*) is the representation of
    TypeScript, which functions as a superset of JavaScript, compiled by the TypeScript
    compiler (TSC) and subsequently transformed into JavaScript code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中显示的是TypeScript的表示，它作为JavaScript的超集，由TypeScript编译器（TSC）编译，然后转换为JavaScript代码。
- en: '![](img/2.1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2.1.jpg)'
- en: '**Figure 2.1:** TypeScript as a Superset of JavaScript'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.1**：TypeScript作为JavaScript的超集'
- en: JavaScript is an interpreted language which runs directly without the code being
    compiled. So if any error occurs, it will be detected at run time. TypeScript
    can easily deal with that problem, because it is strict in checking the type of
    data. If it is followed properly, there are fewer chances of error at run time.
    TypeScript first compiles the code and then transpiles the code. Basically here
    transpiles means converting TypeScript code to JavaScript code. The default compiler
    for it is known as `**tsc**`. TypeScript supports all ES6 (ECMAScript6) features
    and oops concepts. TypeScript is **static checking** which states that it detects
    errors without executing code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种解释型语言，它直接运行而不需要先编译代码。因此，如果发生任何错误，它将在运行时被检测到。TypeScript可以轻松处理这个问题，因为它在检查数据类型时非常严格。如果使用得当，运行时出现错误的几率会减少。TypeScript首先编译代码，然后转换代码。基本上，这里的转换意味着将TypeScript代码转换为JavaScript代码。它的默认编译器被称为`**tsc**`。TypeScript支持所有ES6（ECMAScript6）特性和面向对象的概念。TypeScript是**静态检查**，这意味着它在执行代码之前检测错误。
- en: 'Let us consider an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子：
- en: '**JS code**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**JS代码**'
- en: '`let name = "Jack";`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`let name = "Jack";`'
- en: '`name = 12;`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`name = 12;`'
- en: '`No error`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`无错误`'
- en: '**TS Code**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**TS代码**'
- en: '`let name: string = "Jack";`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`let name: string = "Jack";`'
- en: '`name = 12;`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`name = 12;`'
- en: '`Error: Type ''number'' is not assignable to type ''string''`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：类型''number''不能分配给类型''string''`'
- en: This is a very basic example of both JS and TS codes. The difference is that
    JS automatically considers the string type and once a number value is assigned,
    it converts number to string, and hence, it will not give any error. However,
    this can lead to runtime issues when used in subsequent code sections involving
    number-related operations. In contrast, TypeScript identifies such issues during
    the build process, generating errors at that stage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JS和TS代码的非常基础的例子。区别在于JS会自动考虑字符串类型，一旦分配了数字值，它就会将数字转换为字符串，因此不会产生任何错误。然而，当在涉及数字相关操作的后续代码部分中使用时，这可能会导致运行时问题。相比之下，TypeScript在构建过程中识别此类问题，在该阶段生成错误。
- en: '[Advantages of TypeScript](toc.xhtml#s35a)'
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[TypeScript的优点](toc.xhtml#s35a)'
- en: 'There are many benefits of using TypeScript. Some key advantages are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript有许多好处。以下是一些关键优点：
- en: '**Open source:** TypeScript is free and open source, strongly type checking
    programming language. It can be easily installed and used free of cost.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源：** TypeScript是免费且开源的强类型检查编程语言。它可以免费轻松安装和使用。'
- en: '**Cross platform:** TypeScript supports cross platform and has cross browser
    compatibility. After all, it is run as JavaScript code once the compilation is
    finished.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台：** TypeScript支持跨平台和跨浏览器兼容性。毕竟，一旦编译完成，它作为JavaScript代码运行。'
- en: '**Supports OOP and ES6:** TypeScript has the capability to use the most powerful
    object oriented programming concept, the same as other high level oops languages
    such as JAVA which is not enabled for Js. It supports classes, interfaces, access
    modifiers, abstraction, inheritance, and so on. It also has the ability to use
    ES6 features for better coding standards and readability.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持OOP和ES6：** TypeScript具有使用最强大的面向对象编程概念的能力，就像其他高级OOP语言（如JAVA）一样，它为Js启用了这些功能。它支持类、接口、访问修饰符、抽象、继承等。它还具有使用ES6功能的能力，以实现更好的编码标准和可读性。'
- en: '**Bug detector:** TypeScript provides a bug detection facility while developing
    applications that give errors with description before running it; so developers
    can assuredly save time for debugging and develop it with robust code.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测器：** TypeScript在开发应用程序时提供错误检测功能，在运行之前提供错误描述；因此，开发者可以确保节省调试时间，并使用健壮的代码进行开发。'
- en: '**Optional type checking:** TypeScript is basically for strong type checking
    but it can be optional because it allows static as well as dynamic checking. For
    dynamic checking, it needs to be optional.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选类型检查：** TypeScript基本上是用于强类型检查的，但它可以是可选的，因为它允许静态以及动态检查。对于动态检查，它需要是可选的。'
- en: '**Flexible and maintainable:** TypeScript has huge flexibility to be used with
    different JavaScript frameworks such as React.js, Angular, Nest.js, Express.js,
    loopback, and so on. It can be used as JavaScript on both client as well as server
    sides. Moreover, code can be easily maintained even though different developers
    collaborate and work together by following standard coding practices.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和可维护性：** TypeScript具有巨大的灵活性，可以与不同的JavaScript框架（如React.js、Angular、Nest.js、Express.js、loopback等）一起使用。它可以在客户端和服务器端都作为JavaScript使用。此外，即使不同的开发者遵循标准编码实践协作并共同工作，代码也易于维护。'
- en: '**Better IDE support:** TypeScript provides much better IDE support than JavaScript.
    All popular IDEs provide features such as code completion, parameter hints, type
    checking, and so on, which makes development faster and more efficient.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的IDE支持：** TypeScript比JavaScript提供了更好的IDE支持。所有流行的IDE都提供了代码补全、参数提示、类型检查等功能，这使得开发更快、更高效。'
- en: '[Pitfalls of TypeScript](toc.xhtml#s36a)'
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[TypeScript的陷阱](toc.xhtml#s36a)'
- en: 'While TypeScript has several advantages, there are some disadvantages as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TypeScript有多个优点，但也存在一些缺点：
- en: '**Unsuitable for small applications:** TypeScript is not fit for all applications,
    mostly for small-scale applications because it becomes complicated to implement
    minor features where type checking is not needed whereas in JS it can be easily
    done.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适合小型应用：** TypeScript并不适合所有应用，尤其是小型应用，因为它在不需要类型检查的简单功能实现上变得复杂，而在JS中则可以轻松完成。'
- en: '**Compilation time:** TypeScript code is first compiled, so it takes time in
    the overall process of transpiling which must need a compiler for compilation
    whereas JavaScript does not require it.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时间：** TypeScript代码首先进行编译，因此在整个转换过程中需要时间，这需要编译器进行编译，而JavaScript不需要。'
- en: '**Learning curve:** Being a bit more complex than JavaScript, developers need
    to invest some time to learn and adapt the syntax. However, it is usually only
    for the first time. Once a developer is familiar and comfortable with TypeScript,
    because of TypeScript’s advantages, a lot of time is saved.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：由于比 JavaScript 复杂一些，开发者需要投入一些时间来学习和适应语法。然而，这通常只发生在第一次。一旦开发者熟悉并适应了
    TypeScript，由于 TypeScript 的优势，可以节省大量时间。'
- en: '[Installing TypeScript](toc.xhtml#s37a)'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[安装 TypeScript](toc.xhtml#s37a)'
- en: TypeScript can be installed and set up in your system in two ways. First one
    is installing it globally and another one is installing it locally as a dev dependency.
    We can install it through the npm module which must be installed before in your
    system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以通过两种方式在您的系统中安装和设置。第一种是全局安装，另一种是将它作为开发依赖项本地安装。我们可以通过在系统中预先安装的 npm
    模块来安装它。
- en: '[Global Installation](toc.xhtml#s38a)'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[全局安装](toc.xhtml#s38a)'
- en: Global installation approach proves beneficial when handling multiple projects,
    eliminating the need for project-specific installations. However, it assumes that
    the same version is employed across various projects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个项目时，全局安装方法证明是有益的，因为它消除了对特定项目安装的需求。然而，它假设在各个项目中使用的是相同的版本。
- en: Open the terminal and paste the following command. It will install the latest
    version in your system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并粘贴以下命令。它将在您的系统中安装最新版本。
- en: '`$ npm install typescript -g`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ npm install typescript -g`'
- en: 'Once installation is done, if you want to verify the version of installed TypeScript,
    paste the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，如果您想验证已安装 TypeScript 的版本，请粘贴以下代码：
- en: '`$ tsc -v`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ tsc -v`'
- en: Output of the preceding command will gives like `"**Version 5.3.3**"`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出将类似于 `"**版本 5.3.3**"`
- en: '![](img/2.2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2.2.jpg)'
- en: '**Figure 2.2:** Typescript Installation'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.2**：TypeScript 安装'
- en: '[Project-wise Installation](toc.xhtml#s39a)'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[按项目安装](toc.xhtml#s39a)'
- en: In many of the cases there is a need to use different versions of TypeScript
    with different projects, that time locally installation is necessary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，需要使用不同版本的 TypeScript 来处理不同的项目，这时本地安装是必要的。
- en: 'Create one folder for the project and install it locally as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目创建一个文件夹，并按照以下方式本地安装：
- en: '`$ mkdir basic-typescript-project`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ mkdir basic-typescript-project`'
- en: '`$ cd  basic-typescript-project`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cd  basic-typescript-project`'
- en: '`$ npm install typescript  --save-dev`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ npm install typescript  --save-dev`'
- en: This will install TypeScript on that project locally. We can now jump into developing
    basic applications with TS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在该项目中本地安装 TypeScript。现在我们可以开始使用 TypeScript 开发基本应用程序了。
- en: '[Building a Basic Application with TypeScript](toc.xhtml#s40a)'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[使用 TypeScript 构建基本应用程序](toc.xhtml#s40a)'
- en: 'Once installation is done, go to the root directory of the created project
    and follow the given steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，转到创建的项目根目录，并按照以下步骤操作：
- en: '**Initialize the project**: Enter the following command that will create a
    `**package.json**` file for initializing the node project, and it will prompt
    some questions for information about the project such as project name, version,
    description, entry point (main file), and so on. So enter those details as shown
    in *[Figure 2.2](#fig2_2)*.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化项目**：输入以下命令将创建一个 `**package.json**` 文件以初始化 Node.js 项目，并会提示一些关于项目的信息，如项目名称、版本、描述、入口点（主文件）等。因此，按照如图
    *[图 2.2](#fig2_2)* 所示输入这些详细信息。'
- en: '`$ npm init`'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ npm init`'
- en: '![](img/2.3.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/2.3.jpg)'
- en: '**Figure 2.3:** Project Initialization Step'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 2.3**：项目初始化步骤'
- en: '**Install TypeScript as dev dependency**: Now run the following command which
    will add TypeScript as dev dependency (development dependency) purpose:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 TypeScript 作为开发依赖项安装**：现在运行以下命令，这将添加 TypeScript 作为开发依赖项（开发依赖）：'
- en: '`$ npm install typescript --save-dev`'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ npm install typescript --save-dev`'
- en: '**Install node as dev dependency with TypeScript**: While working with Node.js
    projects, it is better to install it with types. This will allow all default modules
    of Node.js to be used with TypeScript such as http, https, fs, and so on.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 node 作为 TypeScript 的开发依赖项安装**：在处理 Node.js 项目时，最好使用类型安装它。这将允许使用 TypeScript
    使用 Node.js 的所有默认模块，例如 http、https、fs 等。'
- en: '`$ npm install @types/node --save-dev`'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ npm install @types/node --save-dev`'
- en: Any extra package can be installed with `**@types/pkg_name --save-dev**` while
    developing so that the type definitions can be made available in the IDE.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开发过程中，可以使用 `**@types/pkg_name --save-dev**` 安装任何额外的包，以便在 IDE 中提供类型定义。
- en: '**Create a** `**tsconfig.json**` **file and define compiler options**: Create
    a `**tsconfig.json**` file in the root directory and then configure the compiler
    options as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个** `**tsconfig.json**` **文件并定义编译器选项**：在根目录中创建一个 `**tsconfig.json**` 文件，然后按如下方式配置编译器选项：'
- en: '`{`'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`"compilerOptions": {`'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"compilerOptions": {`'
- en: '`"target": "es2019",`'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"target": "es2019",`'
- en: '`"module": "commonjs",`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"module": "commonjs",`'
- en: '`"moduleResolution": "node",`'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"moduleResolution": "node",`'
- en: '`"pretty": true,`'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"pretty": true,`'
- en: '`"sourceMap": true,`'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"sourceMap": true,`'
- en: '`"outDir": "./dist",`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"outDir": "./dist",`'
- en: '`"baseUrl": "./lib",`'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"baseUrl": "./lib",`'
- en: '`"noImplicitAny": false,`'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"noImplicitAny": false,`'
- en: '`"esModuleInterop": true,`'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"esModuleInterop": true,`'
- en: '`"removeComments": true,`'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"removeComments": true,`'
- en: '`"preserveConstEnums": true,`'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"preserveConstEnums": true,`'
- en: '`"experimentalDecorators": true,`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"experimentalDecorators": true,`'
- en: '`"alwaysStrict": true,`'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"alwaysStrict": true,`'
- en: '`"forceConsistentCasingInFileNames": true,`'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"forceConsistentCasingInFileNames": true,`'
- en: '`"emitDecoratorMetadata": true,`'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"emitDecoratorMetadata": true,`'
- en: '`"resolveJsonModule": true,`'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"resolveJsonModule": true,`'
- en: '`"skipLibCheck": true`'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"skipLibCheck": true`'
- en: '`},`'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`},`'
- en: '`"include": [`'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"include": [`'
- en: '`"lib/**/*.ts"`'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"lib/**/*.ts"`'
- en: '`],`'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`],`'
- en: '`"exclude": [`'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"exclude": [`'
- en: '`"node_modules"`'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"node_modules"`'
- en: '`],`'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`],`'
- en: '`"files": [`'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"files": [`'
- en: '`"node_modules/@types/node/index.d.ts"`'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"node_modules/@types/node/index.d.ts"`'
- en: '`]`'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`]`'
- en: '`}`'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'Let us understand these compiler options one by one and then exclude and include
    options in the `**tsconfig.json**` file:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们逐个了解这些编译器选项，然后排除和包含 `**tsconfig.json**` 文件中的选项：
- en: '`**target**`**:** Specifies the ECMAScript Target Version. By default it is
    `**''ES3''**` and can be set to `**''ES5''**`, `**''ES6**`, `**''ES2015''**`,
    `**''ES2016''**`, `**''ES2017''**`, `**''ES2018''**`, `**''ES2019''**`, or `**''ESNEXT''**`.
    It sets the JavaScript language version for emitted JavaScript and include compatible
    library declarations.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**target**`**:** 指定 ECMAScript 目标版本。默认为 `**''ES3''**`，可以设置为 `**''ES5''**`、`**''ES6''**`、`**''ES2015''**`、`**''ES2016''**`、`**''ES2017''**`、`**''ES2018''**`、`**''ES2019''**`
    或 `**''ESNEXT''**`。它设置输出 JavaScript 的 JavaScript 语言版本，并包含兼容的库声明。'
- en: '`**module**`**:** Specifies what module code is generated. If the target attribute
    is `**ES5**` or `**ES3**`, then the default value is `**''commonjs''**` else `**''ES6''**`,
    `**''AMD''**`, `**''System''**`, `**''ES2015''**`, or `**''ESNEXT''**`.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**module**`**:** 指定生成的模块代码。如果目标属性是 `**ES5**` 或 `**ES3**`，则默认值为 `**''commonjs''**`，否则为
    `**''ES6''**`、`**''AMD''**`、`**''System''**`、`**''ES2015''**` 或 `**''ESNEXT''**`。'
- en: '`**moduleResolution**`**:** Specifies module resolution strategy as `**''node''**`
    (Node.js) or `**''classic''**` (TypeScript). It is always set as a node for modern
    JS, otherwise classic. It specifies how TypeScript looks up a file from a given
    module specifier.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**moduleResolution**`**:** 指定模块解析策略为 `**''node''**`（Node.js）或 `**''classic''**`（TypeScript）。对于现代
    JS，它始终设置为 `node`，否则为 `classic`。它指定 TypeScript 如何根据给定的模块指定符查找文件。'
- en: '`**pretty**`**:** Enables color and formatting in output to make compiler errors
    easier to read. This can be set as either true or false.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**pretty**`**:** 启用输出中的颜色和格式化，以便更容易阅读编译器错误。这可以设置为 `true` 或 `false`。'
- en: '`**sourceMap**`**:** This enables generating source map files for emitted JavaScript
    or not, it helps in debugging and reporting errors.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**sourceMap**`**:** 这可以启用为发出的 JavaScript 生成源映射文件，也可以不生成，它有助于调试和错误报告。'
- en: '`**outDir**`: Specify an output folder for storing all transpiled files.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**outDir**`: 指定一个输出文件夹以存储所有转换后的文件。'
- en: '`**baseUrl**`**:** Specify the base directory to resolve non-relative module
    names where all TypeScript files are located.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**baseUrl**`**:** 指定基本目录以解析非相对模块名称，其中所有 TypeScript 文件都位于该目录。'
- en: '`**noImplicitAny**`: Enable error reporting for expressions and declarations
    with an implied any type.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**noImplicitAny**`: 启用对具有隐含 `any` 类型的表达式和声明的错误报告。'
- en: '`**esModuleInterop**`**:** Emit additional JavaScript to ease support for importing
    CommonJS modules. This enables `**allowSyntheticDefaultImports**` for type compatibility.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**esModuleInterop**`**:** 发出额外的 JavaScript 以简化对 CommonJS 模块的导入支持。这启用了 `**allowSyntheticDefaultImports**`
    以实现类型兼容性。'
- en: '`**removeComments**`**:** Disable emitting comments, which means do not emit
    comments to output.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**removeComments**`**:** 禁用输出注释，这意味着不会向输出中发出注释。'
- en: '`**preserveConstEnums**`**:** Disable erasing const `**enum**` declarations
    in generated code. When set as true, the `**enum**` exists at runtime and provides
    a way to reduce the overall memory footprint of your application at runtime by
    emitting the enum value instead of a reference.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**preserveConstEnums**`**:** 禁用生成代码中删除 `**enum**` 声明。当设置为 `true` 时，`**enum**`
    在运行时存在，并提供了一种通过发出枚举值而不是引用来减少应用程序运行时整体内存占用空间的方法。'
- en: '`**experimentalDecorators**`**:** This option enables using decorators in TS
    projects. ES has not yet introduced decorators, so they are disabled by default.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**experimentalDecorators**`**:** 此选项启用在TS项目中使用装饰器。ES尚未引入装饰器，因此默认情况下是禁用的。'
- en: '`**alwaysStrict**`**:** Ensures that your files are parsed in the `**ECMAScript**`
    strict mode, and emit `"**use strict**"` for each source file. Default value is
    false.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**alwaysStrict**`**:** 确保您的文件以`**ECMAScript**`严格模式解析，并为每个源文件发出`"**use strict**"`。默认值是false。'
- en: '`**forceConsistentCasingInFileNames**`**:** Ensure that casing is correct in
    imports which disallow inconsistently cased references to the same file.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**forceConsistentCasingInFileNames**`**:** 确保导入中的大小写正确，不允许对同一文件的不一致大小写引用。'
- en: '`**emitDecoratorMetadata**`**:** Enables experimental support for emitting
    type metadata for decorators.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**emitDecoratorMetadata**`**:** 启用对发射装饰器类型元数据的实验性支持。'
- en: '`**resolveJsonModule**`**:** Enable importing `**.json**` files.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**resolveJsonModule**`**:** 启用导入`**.json**`文件。'
- en: '`**skipLibCheck**`**:** Skip type checking all `**.d.ts**` files.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**skipLibCheck**`**:** 跳过所有`**.d.ts**`文件的类型检查。'
- en: '`**include**`**:** Specifies a list of glob patterns that match files to be
    included in compilation. If no ‘files’ or ‘include’ property is present in `**tsconfig.json**`,
    the compiler defaults to including all files in the containing directory and subdirectories
    except those specified by ‘exclude’.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**include**`**:** 指定匹配要包含在编译中的文件的glob模式列表。如果`**tsconfig.json**`中没有`‘files’**`或`‘include’**`属性，编译器默认包含包含目录及其子目录中的所有文件，但排除由`‘exclude’**`指定的文件。'
- en: '`**exclude**`**:** Specifies a list of files to be excluded from compilation.
    The `**''exclude''**` property only affects the files included via the ‘include’
    property and not the `**''files''**` property.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**exclude**`**:** 指定要排除的文件列表。`**''exclude''**`属性仅影响通过`‘include’**`属性包含的文件，不影响`**''files''**`属性。'
- en: '`**files**`**:** If no `**''files''**` or `**''include''**` property is present
    in **tsconfig.json**, the compiler defaults to including all files in the containing
    directory and subdirectories except those specified by `**''exclude''**`. When
    a `**''files''**` property is specified, only those files and those specified
    by ‘include’ are included.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**files**`**:** 如果**tsconfig.json**中没有`**''files''**`或`**''include''**`属性，编译器默认包含包含目录及其子目录中的所有文件，但排除由`**''exclude''**`指定的文件。当指定了`**''files''**`属性时，只包含那些文件和由`‘include’**`指定的文件。'
- en: '**Create a basic application with TypeScript**: Create a `**lib**` folder and
    create the `**main.ts**` file in that as defined in `**tsconfig.json**` include
    `**lib**` folder which compiles all .ts files.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用TypeScript创建基本应用程序**：创建一个`**lib**`文件夹，并在其中创建`**main.ts**`文件，如`**tsconfig.json**`中定义的，包含`**lib**`文件夹，它编译所有.ts文件。'
- en: '`$ mkdir lib`'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ mkdir lib`'
- en: '`$ cd lib`'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ cd lib`'
- en: '`$ touch main.ts`'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ touch main.ts`'
- en: 'Now write the following code in the main.ts file and save it:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在在`main.ts`文件中写下以下代码并保存：
- en: '`import * as http from ''http'';`'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import * as http from ''http'';`'
- en: '`const hostname = ''127.0.0.1'';`'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`const hostname = ''127.0.0.1'';`'
- en: '`const port = 3000;`'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`const port = 3000;`'
- en: '`const server = http.createServer((req, res) => {`'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`const server = http.createServer((req, res) => {`'
- en: '`res.statusCode = 200;`'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`res.statusCode = 200;`'
- en: '`res.setHeader(''Content-Type'', ''text/plain'');`'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`res.setHeader(''Content-Type'', ''text/plain'');`'
- en: '`res.end(''Hello World'');`'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`res.end(''Hello World'');`'
- en: '`});`'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`server.listen(port, hostname, () => {`'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`server.listen(port, hostname, () => {`'
- en: '``console.log(`Server running with TypeScript project at``'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '``console.log(`Server running with TypeScript project at`'
- en: '``http://${hostname}:${port}/`);``'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '``http://${hostname}:${port}/`);``'
- en: '`});`'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`});`'
- en: '**Run TypeScript Code**: Install the `**ts-node**` package for compilation
    and `**nodemon**` so that every time the changes in files can be auto reload or
    rerun. This way we do not need to run the server again after some changes. Go
    to the root directory and enter the following commands:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行TypeScript代码**：安装`**ts-node**`包进行编译和`**nodemon**`，以便每次文件更改时都可以自动重新加载或重新运行。这样我们就不需要在某些更改后再次运行服务器。转到根目录并输入以下命令：'
- en: '`$ npm install ts-node nodemon  --save-dev`'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ npm install ts-node nodemon  --save-dev`'
- en: '`$ tsc`'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ tsc`'
- en: As soon as the `**tsc**` command runs, a new directory is created named `**dist**`
    (we specified it in `**tsconfig.json**` as outDir). All TS files are compiled
    as JS and placed in this directory. Now we can run the application on the specified
    port, which is usually 3000 by default. If the port is 3000, then the application
    would be available at http://127.0.0.1:3000.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行了`**tsc**`命令，就会创建一个名为`**dist**`的新目录（我们在`**tsconfig.json**`中将其指定为outDir）。所有TS文件都会编译成JS并放置在这个目录中。现在我们可以在指定的端口上运行应用程序，默认通常是3000。如果端口是3000，那么应用程序将可通过http://127.0.0.1:3000访问。
- en: '`**nodemon**` can detect new changes in the `**dist**` directory and restart
    the server as soon as there is a change. We just need to run the server using
    `**nodemon**` instead of node:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**nodemon**` 可以检测 `**dist**` 目录中的新更改，并在有更改时立即重启服务器。我们只需使用 `**nodemon**` 而不是
    node 来运行服务器：'
- en: '`$ nodemon dist/main.js`'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nodemon dist/main.js`'
- en: '![](img/2.4.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片2.4](img/2.4.jpg)'
- en: '**Figure 2.4:** Compile Typescript Application'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图2.4**：编译TypeScript应用程序'
- en: '`**nodemon**` can detect the changes from the `**dist**` directory and run
    `**main.js**` again, but since we are coding in TS, the files need to be recompiled
    after each change. Manual recompilation using `**tsc**` is also a tedious task.
    To solve this, we can use the watch option so that every time a TS file is changed,
    it will be compiled automatically. To run the `**tsc**` in watch mode, we can
    use `**-w**` flag as follows:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**nodemon**` 可以检测 `**dist**` 目录中的更改并重新运行 `**main.js**`，但由于我们正在用 TS 编码，每次更改后都需要重新编译文件。使用
    `**tsc**` 进行手动重新编译也是一个繁琐的任务。为了解决这个问题，我们可以使用监视选项，这样每次 TS 文件更改时，它都会自动编译。要使用监视模式运行
    `**tsc**`，我们可以使用 `**-w**` 标志，如下所示：'
- en: '`$ tsc -w`'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ tsc -w`'
- en: This way we can build a basic TypeScript application. In case, if you want to
    explore more about `**tsconfig.js**` compiler options, you can visit [https://www.TypeScriptlang.org/tsconfig](https://www.TypeScriptlang.org/tsconfig)
    for reference.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以构建一个基本的 TypeScript 应用程序。如果你想要了解更多关于 `**tsconfig.js**` 编译器选项的信息，可以访问 [https://www.TypeScriptlang.org/tsconfig](https://www.TypeScriptlang.org/tsconfig)
    以获取参考。
- en: We have seen building basic TypeScript application, now we will look into OOP
    concepts which are not supported in JavaScript.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了构建基本的 TypeScript 应用程序，现在我们将探讨 JavaScript 中不支持的对象导向概念。
- en: '[OOP Concepts in TS](toc.xhtml#s41a)'
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[TypeScript中的面向对象概念](toc.xhtml#s41a)'
- en: TypeScript supports object-oriented programming, where we will learn about class,
    interface, abstraction, inheritance, encapsulation, and polymorphism. However,
    before that we need to know about data types in TypeScript. So let us take a look
    at the supported data types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持面向对象编程，我们将学习关于类、接口、抽象、继承、封装和多态。然而，在那之前，我们需要了解 TypeScript 中的数据类型。因此，让我们看看支持的数据类型。
- en: '[Data Types](toc.xhtml#s42a)'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[数据类型](toc.xhtml#s42a)'
- en: TypeScript has primitive and non-primitive data types. Primitive data types
    means value is assigned directly, which are also known as basic data types, whereas
    non primitive can be reference or subtype of primitive type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有原始数据类型和非原始数据类型。原始数据类型意味着值直接赋值，也称为基本数据类型，而非原始数据类型可以是原始数据类型的引用或子类型。
- en: '[Primitive Types](toc.xhtml#s43a)'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[原始数据类型](toc.xhtml#s43a)'
- en: 'For Primitive data types, the values are assigned directly. These are also
    known as basic data types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始数据类型，值是直接赋值的。这些也称为基本数据类型：
- en: '`**String**`: It is used for textual data that is enclosed with “(double quote)
    or ‘ (single quote). Example:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**String**`: 它用于文本数据，这些数据被双引号或单引号包围。例如：'
- en: '`let name:string = "Tom";`'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let name:string = "Tom";`'
- en: '`name = "Jerry";`'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`name = "Jerry";`'
- en: '`**Number**`: It is used for numeric data. It also supports decimal, binary,
    hexadecimal, and octal data as well. Example:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Number**`: 它用于数值数据。它还支持十进制、二进制、十六进制和八进制数据。例如：'
- en: '`let total :number = 100;`'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let total :number = 100;`'
- en: '`let binaryNumber :number = 0b0101;`'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let binaryNumber :number = 0b0101;`'
- en: '`let hexaNumber :number = 0xf00d;`'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let hexaNumber :number = 0xf00d;`'
- en: '`let octalNumber :number = 0o555;`'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let octalNumber :number = 0o555;`'
- en: '`**Bigint**`: It is used for Numeric data. It also supports big integers. Example:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Bigint**`: 它用于数值数据。它还支持大整数。例如：'
- en: '`let bigNumber :bigint = 200n;`'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let bigNumber :bigint = 200n;`'
- en: '`let anotherBigNumber :bigint = BigInt(200);`'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let anotherBigNumber :bigint = BigInt(200);`'
- en: '`**Boolean**`: It is used when you need either a `**true**` or `**false**`
    case. Example:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Boolean**`: 当你需要 `**true**` 或 `**false**` 的情况时使用。例如：'
- en: '`let mute :boolean = true;`'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let mute :boolean = true;`'
- en: '`mute = false;`'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mute = false;`'
- en: '`**Null**` and `**Undefined**`: It is the same as JavaScript: **null** represents
    an object having nothing, while **undefined** means type is not initialized. Both
    are subtypes of other types.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Null**` 和 `**Undefined**`: 它与 JavaScript 相同：**null** 表示一个没有任何对象的引用，而 **undefined**
    表示类型尚未初始化。两者都是其他类型的子类型。'
- en: '`let name:undefined = undefined;`'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let name:undefined = undefined;`'
- en: '`let num:null = null;`'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let num:null = null;`'
- en: '`**Symbol**`: It is a new data type introduced in `**ES6**`. This creates a
    unique symbol from the `**Symbol**` function.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Symbol**`: 它是`**ES6**`中引入的一种新数据类型。它通过`**Symbol**`函数创建一个唯一的符号。'
- en: '`let symbolTest  = Symbol();`'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let symbolTest  = Symbol();`'
- en: '[Non-Primitive Types](toc.xhtml#s44a)'
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[非原始数据类型](toc.xhtml#s44a)'
- en: '`**Object**`: It represents a key-value pair in which key as property and value
    can be any primitive type. For example:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**对象**`: 它表示一个键值对，其中键是属性，值可以是任何原始类型。例如：'
- en: '`let student :Object = {id: 1, name :"Jack"}; //declare and assign`'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let student :Object = {id: 1, name :"Jack"}; //声明和赋值`'
- en: '`let employee :{emp_id:number, name:string};  //declare`'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let employee :{emp_id:number, name:string};  //声明`'
- en: '`employee = {emp_id: 2, name :"Jack"};  //assign value`'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`employee = {emp_id: 2, name :"Jack"};  //赋值`'
- en: '`**Array**`: It is similar to JavaScript arrays where you can store multiple
    elements in a single variable. It can be written in two ways:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**数组**`: 它类似于JavaScript数组，可以在单个变量中存储多个元素。它可以有两种写法：'
- en: '`let colors: string[ ] = ["Black","white","Red"];`'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let colors: string[ ] = ["Black","white","Red"];`'
- en: '`let colors: Array<string>  =  ["Black","white","Red"];`'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let colors: Array<string>  =  ["Black","white","Red"];`'
- en: First way to define is using the type of elements followed by [ ] (Square bracket).
    Second way is to use Array followed by `**<typeof elements in Array>**`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一种定义方式是使用元素类型后跟 [ ]（方括号）。第二种方式是使用 Array 后跟 `**<数组中元素的类型>**`。
- en: '`**Enums**`: Enumeration is used when possible values are from a set of few
    fixed constant values. It can be number `**enums**`, string `**enums**`, heterogeneous
    `**enums**`, or any primitive type `**enums**`. An example of the `**enums**`
    can be for status of a task:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**枚举**`: 当可能的值来自一组少数固定常量值时使用枚举。它可以是有数字 `**枚举**`，字符串 `**枚举**`，异构 `**枚举**`，或任何原始类型
    `**枚举**`。`**枚举**`的一个例子可以是任务的状况：'
- en: '`enum Status {`'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`enum Status {`'
- en: '`"pending",`'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"pending",`'
- en: '`"in_progress",`'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"in_progress",`'
- en: '`"completed"`'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"completed"`'
- en: '`}`'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`**Tuple**`: It represents an array in fixed size with known data types of
    each element in the array. For example,'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**元组**`: 它表示一个具有已知数据类型的固定大小数组。例如，'
- en: '`//correct value need to match`'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`//正确值需要匹配`'
- en: '`let tupleExample : [string,number] = ["Jack",1]`'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let tupleExample : [string,number] = ["Jack",1]`'
- en: '`//gives error`'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`//gives error`'
- en: '`let tupleExampleIncorrect : [string,number] =[1,"Jack"];`'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let tupleExampleIncorrect : [string,number] =[1,"Jack"];`'
- en: In this example, the first element should be a string and the second would be
    a number. Providing them in incorrect order would throw an error.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个元素应该是一个字符串，第二个应该是一个数字。如果提供错误的顺序，将会抛出错误。
- en: '`**Any**`: It is a special type when the value type is not known. In simple
    words, after specifying any data type, checks are not done and it does not give
    any error. It is not recommended to use it except in the cases when there is no
    choice left.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**任意类型**`: 当值类型未知时使用特殊类型。简单来说，指定任何数据类型后，不会进行检查，也不会给出任何错误。除非没有其他选择，否则不建议使用它。'
- en: '`let data: **any** = {};`'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`let data: **any** = {};`'
- en: '`data.geometry={`'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`data.geometry={`'
- en: '`"type": "Polygon",`'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"type": "Polygon",`'
- en: '`"coordinates": [`'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"coordinates": [`'
- en: '`[`'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[`'
- en: '`[123.61, -22.14], [122.38, -21.73], [121.06, -21.69]`'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[123.61, -22.14], [122.38, -21.73], [121.06, -21.69]`'
- en: '`` `]`    `]`    `}`    `data.latitude = 90;`    `data.longitude = 90;` ``'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`` `]`    `]`    `}`    `data.latitude = 90;`    `data.longitude = 90;` ``'
- en: '`` *   `**Custom**`: It allows you to define your own custom type using primitive
    and non- primitive types. For example a type project is created as follows:          `type
    project = {`                    `name: string;`                    `description:
    string;`                    `start_time: number;`                    `owner_name:
    string[];`                    `};`                    `const projectData: project
    = {`                    `name: ''Project Management'',`                    `description:
    ''It is about to manage any project from on board to deployment process'',`                    `start_time:
    1682516674343,`                    `owner_name: ["Jack", "John"]`                    `};`
    ``'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`` *   `**自定义类型**`: 它允许你使用原始类型和非原始类型来定义自己的自定义类型。例如，一个类型project可以这样创建：          `type
    project = {`                    `name: string;`                    `description:
    string;`                    `start_time: number;`                    `owner_name:
    string[];`                    `};`                    `const projectData: project
    = {`                    `name: ''Project Management'',`                    `description:
    ''It is about to manage any project from on board to deployment process'',`                    `start_time:
    1682516674343,`                    `owner_name: ["Jack", "John"]`                    `};`
    ``'
- en: '[PRE0] `Output:`    `VM37:2 Uncaught TypeError: Task is not a constructor at
    <anonymous>:2:13`    `(anonymous) @ VM37:2`    # [Blocking Scopes](toc.xhtml#s56a)    In
    JavaScript, variables can be declared with the "`**var**"` keyword which can be
    redeclared and reassigned that has functional scope, whereas in Es6, `**let**`
    and `**const**` are introduced with different usage of scope.    # [The let Keyword](toc.xhtml#s57a)    The
    variables declared using the let keyword have a blocking scope and these are accessible
    only in the block where they are declared. These variables can be reassigned new
    values but not redeclared.    Let us consider the following example:    `let name
    = "Project";`    `let nameIsDeclared = true;`    `if(nameIsDeclared) {`    `let
    name = "PMS";`    `console.log(name);`    `}`    `console.log(name);`    `// Output`    `PMS`    `Project`    As
    per the preceding example, the name variable is declared and assigned with `"**Project**"`
    value which has global scope. After that, the same name variable is declared and
    assigned with PMS in the block function. In this case, it is redeclared and does
    not give an error due to changing its scope from global to block.    However,
    if it is redeclared in the same global scope, then it gives an error as `**caught
    SyntaxError: Identifier ''name'' has already been declared**`**.**    # [The const
    Keyword](toc.xhtml#s58a)    The `**const**` keyword has also a blocking scope,
    same as `**let**`, but it cannot be reassigned to a new value. Its value remains
    constant as the name suggests.    In the following example, we are trying to re-assign
    a value to the `**const**` `**name**` and that is not allowed, hence we get a
    compile time error:    `const name = "PMS";`    `name = "Project Management system";`    `Output:`    `VM1717:2
    Uncaught TypeError: Assignment to constant variable.`    `at <anonymous>:2:6`    In
    case of variables holding objects, the behavior is a bit different. We know that
    Object is one kind of reference. If a const is created to hold the object, its
    properties can be changed, but the whole object cannot be replaced with another.    Let
    us consider the following example:    `const Task = {`    `name: "Insert Data
    to database",`    `efforts_hrs: 10`    `};`    `Task.name = " Fetch Data from
    database";`    `console.log(Task.name);`    Output:    `Fetch Data from database`    In
    this case, the name property of Task could be changed.    # [Template Literals](toc.xhtml#s59a)    ECMAScript
    supports template string which has syntax backticks ( ``**` `**`` ) enclosed with
    string. Inside the string we can use the dollar (`**$**`) sign to put a variable
    or an expression, which will be evaluated and its value will be printed.    `let
    name = "PMS";`    `let task = "Insert data to database";`    `console.log("Task
    => " + task + " and name => " + name); // without template`    ``console.log(`Task
    => ${task} and name => ${name}`);  // with template``    This avoids the use of
    + (plus) sign to concatenate multiple strings or variables.    # [Classes](toc.xhtml#s60a)    ES6
    allows the use of object-oriented concepts and classes are one of them. A class
    consists of objects, methods, and constructor. Classes can be declared with the
    class keyword.    Syntax :    `class class_name { }`    Example:    `class Project
    {`    `constructor() { }`    `}`    We already have seen details of class in OOPs
    concept earlier in this chapter.    # [Promises](toc.xhtml#s61a)    Before the
    introduction of `**ES6**`, callbacks were used to perform or handle asynchronous
    tasks. `**Callback**` is a type of function that gets called after the execution
    of the actual function is done. When there are multiple nested callbacks, it creates
    a situation called callback hell. To solve this problem, `**Promises**` were introduced.    The
    syntax of a promise is:    `new Promise((resolve,reject) => {….});`    A promise
    has following three states:    *   `**pending**`: It is the initial state that
    is before the reject or resolve state. *   `**reject**`: It is the state when
    failure happens. *   `**resolve**`: It is the state when execution completes successfully.    Let
    us consider the following example:    `const example = new Promise((resolve, reject)
    => {`    `try {`    `const options = {`    `body: JSON.stringify({test:"test"}),`    `headers:
    { ''Content-Type'': ''application/json'' },`    `method: ''POST'',`    `};`    ``const
    url = `https://www.google.com`;``    `fetch(url, options)`    `.then(async (response)
    => {`    ``console.log(`Got response - ${await response.text()}`);``    `resolve(response);`    `})`    `.catch((err)
    => {`    `console.log(''Catch => '', err);`    `reject(err);`    `}).finally(()
    => {`    `console.log("Finally");`    `});`    `} catch (error) {`    `console.log(''Catch
    2 => '', error);`    `reject(error);`    `}`    `});`    In the preceding example,
    when the result of fetch is returned, based on the good or bad result, we can
    call either `**resolve()**` or `**reject()**`. As we can see that on successful
    results, we are making a call to `**resolve()**`, and in case there is an error
    caught, we are calling `**reject()**`.    Using the syntax of promise is also
    now outdated. Instead of promises, async await is used for handling asynchronous
    requests. The same function can be rewritten using `**async await**` as:    `async
    function example() { // line 1`    `try {`    `const options = {`    `body: JSON.stringify({test:
    "test"}),`    `headers: {''Content-Type'': ''application/json''},`    `method:
    ''POST''`    `};`    `const url = ''https://www.google.com'';`    `const response
    = await fetch(url, options);`    ``console.log(`Got response - ${await response.text()}`);``    `return
    response;`    `} catch (error) {`    `console.log(''Catch => '', error);`    `throw
    error;`    `} finally {`    `console.log(''Finally'');`    `}`    `}`    To make
    a function use async-await, we need to declare the function as async similar to
    what we have done in line 1\. Now, we can use await for the calls for which we
    want to wait. In the preceding example, we have used `**await**` before `**fetch()**`.
    The execution is going to wait for the fetch to complete and return with some
    result.    # [Destructuring](toc.xhtml#s62a)    Destructuring allows us to make
    properties of objects and values of arrays into identical variables.    # [Object
    Destructuring](toc.xhtml#s63a)    Let us consider the following example:    `const
    obj = { a: 1, b: 2 };`    `const { a, b } = obj;`    `console.log(a);`    `console.log(b);`    `Output:`    `1`    `2`    In
    this example, we could declare two variables `**a**` and `**b**` directly from
    the object’s properties.    # [Array Destructuring](toc.xhtml#s64a)    Let us
    consider the following example to understand how it works:    `const numbers =
    ["1", "2", "3"];`    `const [red, yellow, green] = numbers;`    `console.log(red);
    // "1"`    `console.log(yellow); // "2"`    `console.log(green); // "3"`    `Output:`    `1`    `2`    `3`    In
    the case of an array, the values can be assigned to the variables in the same
    order as the values appear in the array.    # [Default Parameters](toc.xhtml#s65a)    In
    ES6, it is possible to set the default value to any variable through the parameter
    of function.    The syntax for setting the default value is following:    `function
    fnName(param1 = defaultValue1, /* …,*/ paramN = defaultValueN) {`    `// …`    `}`    Let
    us define a function to add two values:    `function sum(num1, num2=5) {`    `let
    sum = num1 + num2;`    `return sum;`    `}`    The preceding function can be called
    as:    `sum(1, 3)  // returns 4`    `sum(3)  // returns 8`    The function can
    be called without specifying a value to the default parameters.    # [Modules](toc.xhtml#s66a)    ES6
    provides export and import facilities. In this any written JavaScript code can
    be transferred from one file to another file as a module for reuse as export from
    one file to import in another file.    Let us create a file named project.js as:    `export
    class Project {`    `//objects`    `//constructor`    `//methods`    `}`    The
    class Project is exported using the export keyword. Let us create another file
    main.js in which we can import the class Project as:    `import {Person} from
    ''./project.js''`    Now, all properties and functions can be used in the main.js
    file. This way export-import is possible in JavaScript after ES6 was introduced.    #
    [Enhanced Object Literals](toc.xhtml#s67a)    In ES6, it is possible to make dynamic
    properties for objects effectively. It also enables shorthand syntax for initializing
    objects.    Let us consider the example of a function `**getTask()**` in regular
    JavaScript:    `// regular JavaScript`    `function getTask(name, hrs) {`    `return
    {`    `name: name,`    `hrs: hrs`    `}`    `}`    `getTask("Task 1", 10);`    `Output
    :`    `{name: ''Task 1'', hrs: 10}`    We can rewrite the same function in `**ES6**`
    as follows:    `//ES6`    `function getTask(name, hrs) {`    `return { name, hrs
    };`    `}`    `getTask("Task 1", 10);`    `Output:`    `{name: ''Task 1'', hrs:
    10}`    Now let us add some dynamic properties:    `let name = "t";`    `let i
    = 0;`    `const task = {`    `[name + ++i]: "Add",`    `[name + ++i]: "Update",`    `[name
    + ++i]: "Delete"`    `};`    We added three more properties to the task object
    as `**t1**`, `**t2**`, and `**t3**`:    `console.log(task.t1);`    `console.log(task.t2);`    `console.log(task.t3);`    `Output:`    `Add`    `Update`    `Delete`    These
    were the most used features of `**ES6**`. There are some other features which
    can be explored and be used with the help of various examples through reference
    from the official website of `**ECMAScript**`: [https://262.ecma-international.org](https://262.ecma-international.org).    #
    [EsLint](toc.xhtml#s68a)    EsLint is one of the best tools that checks JavaScript
    and ECMAScript code based on a set of rules defined and highlights what is not
    done correctly as per the rules. All major IDEs support `**eslint**`, and if that
    rule is violated, the developer is notified immediately. This helps to save a
    lot of development efforts.    # [Installing Eslint](toc.xhtml#s69a)    To install
    `**Eslint**` in your project, simply install the following packages:    `npm install
    eslint @typescript-eslint/parser`    `@typescript-eslint/eslint-plugin --save-dev`    #
    [Configuring Eslint](toc.xhtml#s70a)    Let us create a file named `**.eslintrc**`
    in the root directory of the project. Now save the following code in the `**.eslintrc**`
    file with defined rules and parser options:    `{`    `"env": {`    `"browser":
    true,`    `"es2021": true,`    `"node": true`    `},`    `"parser": "@typescript-eslint/parser",`    `"parserOptions":
    {`    `"ecmaVersion": 12,`    `"sourceType": "module"`    `},`    `"plugins":
    [`    `"@typescript-eslint"`    `],`    `"extends": [`    `"eslint:recommended",`    `"plugin:@typescript-eslint/recommended"`    `],`    `"rules":
    {`    `"@typescript-eslint/explicit-module-boundary-types": "off",`    `"@typescript-eslint/no-unused-vars":
    "error",`    `"no-console": "warn",`    `"indent": ["error", 2],`    `"quotes":
    ["error", "single"],`    `"semi": ["error", "always"]`    `}`    `}`    # [Running
    Eslint](toc.xhtml#s71a)    Although all IDEs will immediately start evaluating
    the code based on the provided `**.eslintrc**` file, we can run `**eslint**` manually
    in the terminal as well.    Open the `**package.json**` file of the project and
    save the following lint script:    `"scripts": {`    `**…**`    `"**lint**"**:**
    "**eslint . --ext .ts**"`    `}`    Now we can run `**lint**` script:    `$ npm
    run lint`  ![](img/2.5.jpg)  **Figure 2.5:** Run Eslint    Some of the `**Eslint**`
    issues are auto-fixable and we can fix those by using `**-- fix**` option in script:    `"scripts":
    {`    `**…**`    `"**lint**"**:** "**eslint . --ext .ts --fix**"`    `}`  ![](img/2.6.jpg)  **Figure
    2.6:** Fix Eslint Issue    This is helpful when there are small errors like missing
    semicolon, extra whitespace, and so on.    As shown above, some fixes need to
    be done manually here. For demonstration purpose, we did not remove the console
    statements, which need to be manually removed or an eslint rule should be added.    That
    is overview of how `**Eslint**` is used in project for better development; if
    you need to explore more about it, follow the reference EsLint Documentation ([https://eslint.org/docs/latest/](https://eslint.org/docs/latest/))    Earlier,
    there was a typescript linting tool named `**tslint**`, which is now deprecated.
    The plan is to use `**Eslint**` for typescript projects as well. The roadmap can
    be tracked at [https://github.com/palantir/tslint/issues/4534](https://github.com/palantir/tslint/issues/4534).    #
    [Conclusion](toc.xhtml#s72a)    In this chapter, we learned about basic TypeScript
    with examples, its installation, and configuration. We learned about the OOP concepts
    along with what is offered by ECMAScript.    In the next chapter, we will learn
    Express.js, the most used framework of Node.js. Express.js will help us to build
    the APIs we need in the chapters ahead in the book.    # [Multiple Choice Questions](toc.xhtml#s73a)    1.  What
    is TypeScript?     1.  A JavaScript library for creating user interfaces     2.  A
    statically typed superset of JavaScript     3.  A database management system     4.  A
    programming language for server-side development 2.  Which of the following is
    a benefit of using TypeScript?     1.  It runs in a web browser without any compilation     2.  It
    enforces strict typing rules to catch errors early     3.  It provides built-in
    support for database connections     4.  It can be used for mobile app development
    3.  How is TypeScript code compiled into JavaScript?     1.  It is interpreted
    by the browser     2.  It is manually transcribed by developers     3.  It is
    compiled using the TypeScript compiler (tsc)     4.  It is converted by a built-in
    JavaScript converter 4.  Which command is used to compile a TypeScript file (for
    example, `**app.ts**`) into JavaScript?     1.  ts compile app.ts     2.  tsc
    app.ts     3.  typescript app.ts     4.  transpile app.ts 5.  Which TypeScript
    feature allows you to define reusable types for complex data structures?     1.  Type
    annotations     2.  Type inference     3.  Interfaces and custom types     4.  Polymorphism
    6.  Which OOP concept promotes the idea of bundling data and methods that operate
    on that data into a single unit called an object?     1.  Inheritance     2.  Encapsulation     3.  Polymorphism     4.  Abstraction
    7.  Which OOP principle states that objects of a derived class should be able
    to replace objects of the base class without affecting the correctness of the
    program?     1.  Encapsulation     2.  Abstraction     3.  Inheritance     4.  Polymorphism
    8.  Which ES6 feature allows you to unpack elements from arrays or properties
    from objects into distinct variables?     1.  Destructuring Assignment     2.  Object
    Literals     3.  Spread Operator     4.  Template Literals 9.  Which ES6 feature
    allows you to create multi-line strings with embedded expressions?     1.  Template
    Strings     2.  String Templates     3.  Multi-line Strings     4.  String Literals
    10.  Given an array of numbers, how do you create a new array with all the elements
    of numbers followed by 5 using the spread operator?     1.  […numbers + 5]     2.  […numbers,
    5]     3.  [numbers + …5]     4.  [5 …numbers]    # [Answers](toc.xhtml#s74a)    1.  b
    2.  b 3.  c 4.  b 5.  c 6.  b 7.  d 8.  a 9.  a 10.  b    # [Further Reading](toc.xhtml#s75a)    [https://www.typescriptlang.org](https://www.typescriptlang.org)
    [PRE1]`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
