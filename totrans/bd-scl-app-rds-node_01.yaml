- en: '[CHAPTER 2](toc.xhtml#c02)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction to TypeScript](toc.xhtml#c02)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s32a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Millions of applications are developed in JavaScript, but developers face many
    issues while developing it. JavaScript runs directly without compiling the code
    first. Due to dynamic typing and lack of compile-time checks, issues like runtime
    errors, code complexity, and maintenance of large codebase are common. TypeScript
    was introduced as a superset of JavaScript to address all such issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the basic concepts of TypeScript and how to
    use it instead of JavaScript in your application while developing.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s33a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pitfalls of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Basic Application with TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP (Object-Oriented Programming) Concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of ECMAScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EsLint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overview of TypeScript](toc.xhtml#s34a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript, meaning all JavaScript features are
    present and other extra features are bundled in it. JavaScript is an object-based
    language but does not provide all the concepts of object-oriented programming,
    so the missing part is achieved through TypeScript. TypeScript is an open-source
    programming language that is developed and maintained by Microsoft. It was released
    in 2012 and is often abbreviated as TS.
  prefs: []
  type: TYPE_NORMAL
- en: Displayed in the image (see *[Figure 2.1](#fig2_1)*) is the representation of
    TypeScript, which functions as a superset of JavaScript, compiled by the TypeScript
    compiler (TSC) and subsequently transformed into JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.1:** TypeScript as a Superset of JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is an interpreted language which runs directly without the code being
    compiled. So if any error occurs, it will be detected at run time. TypeScript
    can easily deal with that problem, because it is strict in checking the type of
    data. If it is followed properly, there are fewer chances of error at run time.
    TypeScript first compiles the code and then transpiles the code. Basically here
    transpiles means converting TypeScript code to JavaScript code. The default compiler
    for it is known as `**tsc**`. TypeScript supports all ES6 (ECMAScript6) features
    and oops concepts. TypeScript is **static checking** which states that it detects
    errors without executing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JS code**'
  prefs: []
  type: TYPE_NORMAL
- en: '`let name = "Jack";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`name = 12;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`No error`'
  prefs: []
  type: TYPE_NORMAL
- en: '**TS Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '`let name: string = "Jack";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`name = 12;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: Type ''number'' is not assignable to type ''string''`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic example of both JS and TS codes. The difference is that
    JS automatically considers the string type and once a number value is assigned,
    it converts number to string, and hence, it will not give any error. However,
    this can lead to runtime issues when used in subsequent code sections involving
    number-related operations. In contrast, TypeScript identifies such issues during
    the build process, generating errors at that stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[Advantages of TypeScript](toc.xhtml#s35a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many benefits of using TypeScript. Some key advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open source:** TypeScript is free and open source, strongly type checking
    programming language. It can be easily installed and used free of cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross platform:** TypeScript supports cross platform and has cross browser
    compatibility. After all, it is run as JavaScript code once the compilation is
    finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports OOP and ES6:** TypeScript has the capability to use the most powerful
    object oriented programming concept, the same as other high level oops languages
    such as JAVA which is not enabled for Js. It supports classes, interfaces, access
    modifiers, abstraction, inheritance, and so on. It also has the ability to use
    ES6 features for better coding standards and readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bug detector:** TypeScript provides a bug detection facility while developing
    applications that give errors with description before running it; so developers
    can assuredly save time for debugging and develop it with robust code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional type checking:** TypeScript is basically for strong type checking
    but it can be optional because it allows static as well as dynamic checking. For
    dynamic checking, it needs to be optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible and maintainable:** TypeScript has huge flexibility to be used with
    different JavaScript frameworks such as React.js, Angular, Nest.js, Express.js,
    loopback, and so on. It can be used as JavaScript on both client as well as server
    sides. Moreover, code can be easily maintained even though different developers
    collaborate and work together by following standard coding practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better IDE support:** TypeScript provides much better IDE support than JavaScript.
    All popular IDEs provide features such as code completion, parameter hints, type
    checking, and so on, which makes development faster and more efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pitfalls of TypeScript](toc.xhtml#s36a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While TypeScript has several advantages, there are some disadvantages as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsuitable for small applications:** TypeScript is not fit for all applications,
    mostly for small-scale applications because it becomes complicated to implement
    minor features where type checking is not needed whereas in JS it can be easily
    done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compilation time:** TypeScript code is first compiled, so it takes time in
    the overall process of transpiling which must need a compiler for compilation
    whereas JavaScript does not require it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve:** Being a bit more complex than JavaScript, developers need
    to invest some time to learn and adapt the syntax. However, it is usually only
    for the first time. Once a developer is familiar and comfortable with TypeScript,
    because of TypeScript’s advantages, a lot of time is saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing TypeScript](toc.xhtml#s37a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript can be installed and set up in your system in two ways. First one
    is installing it globally and another one is installing it locally as a dev dependency.
    We can install it through the npm module which must be installed before in your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Global Installation](toc.xhtml#s38a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global installation approach proves beneficial when handling multiple projects,
    eliminating the need for project-specific installations. However, it assumes that
    the same version is employed across various projects.
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and paste the following command. It will install the latest
    version in your system.
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install typescript -g`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installation is done, if you want to verify the version of installed TypeScript,
    paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ tsc -v`'
  prefs: []
  type: TYPE_NORMAL
- en: Output of the preceding command will gives like `"**Version 5.3.3**"`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.2:** Typescript Installation'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project-wise Installation](toc.xhtml#s39a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many of the cases there is a need to use different versions of TypeScript
    with different projects, that time locally installation is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create one folder for the project and install it locally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ mkdir basic-typescript-project`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ cd  basic-typescript-project`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install typescript  --save-dev`'
  prefs: []
  type: TYPE_NORMAL
- en: This will install TypeScript on that project locally. We can now jump into developing
    basic applications with TS.
  prefs: []
  type: TYPE_NORMAL
- en: '[Building a Basic Application with TypeScript](toc.xhtml#s40a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once installation is done, go to the root directory of the created project
    and follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialize the project**: Enter the following command that will create a
    `**package.json**` file for initializing the node project, and it will prompt
    some questions for information about the project such as project name, version,
    description, entry point (main file), and so on. So enter those details as shown
    in *[Figure 2.2](#fig2_2)*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm init`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/2.3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 2.3:** Project Initialization Step'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install TypeScript as dev dependency**: Now run the following command which
    will add TypeScript as dev dependency (development dependency) purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm install typescript --save-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install node as dev dependency with TypeScript**: While working with Node.js
    projects, it is better to install it with types. This will allow all default modules
    of Node.js to be used with TypeScript such as http, https, fs, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm install @types/node --save-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any extra package can be installed with `**@types/pkg_name --save-dev**` while
    developing so that the type definitions can be made available in the IDE.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create a** `**tsconfig.json**` **file and define compiler options**: Create
    a `**tsconfig.json**` file in the root directory and then configure the compiler
    options as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"compilerOptions": {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"target": "es2019",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"module": "commonjs",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"moduleResolution": "node",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"pretty": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"sourceMap": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"outDir": "./dist",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"baseUrl": "./lib",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"noImplicitAny": false,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"esModuleInterop": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"removeComments": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"preserveConstEnums": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"experimentalDecorators": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"alwaysStrict": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"forceConsistentCasingInFileNames": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"emitDecoratorMetadata": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"resolveJsonModule": true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"skipLibCheck": true`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`},`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"include": [`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"lib/**/*.ts"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`],`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"exclude": [`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"node_modules"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`],`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"files": [`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"node_modules/@types/node/index.d.ts"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us understand these compiler options one by one and then exclude and include
    options in the `**tsconfig.json**` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**target**`**:** Specifies the ECMAScript Target Version. By default it is
    `**''ES3''**` and can be set to `**''ES5''**`, `**''ES6**`, `**''ES2015''**`,
    `**''ES2016''**`, `**''ES2017''**`, `**''ES2018''**`, `**''ES2019''**`, or `**''ESNEXT''**`.
    It sets the JavaScript language version for emitted JavaScript and include compatible
    library declarations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**module**`**:** Specifies what module code is generated. If the target attribute
    is `**ES5**` or `**ES3**`, then the default value is `**''commonjs''**` else `**''ES6''**`,
    `**''AMD''**`, `**''System''**`, `**''ES2015''**`, or `**''ESNEXT''**`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**moduleResolution**`**:** Specifies module resolution strategy as `**''node''**`
    (Node.js) or `**''classic''**` (TypeScript). It is always set as a node for modern
    JS, otherwise classic. It specifies how TypeScript looks up a file from a given
    module specifier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**pretty**`**:** Enables color and formatting in output to make compiler errors
    easier to read. This can be set as either true or false.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**sourceMap**`**:** This enables generating source map files for emitted JavaScript
    or not, it helps in debugging and reporting errors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**outDir**`: Specify an output folder for storing all transpiled files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**baseUrl**`**:** Specify the base directory to resolve non-relative module
    names where all TypeScript files are located.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**noImplicitAny**`: Enable error reporting for expressions and declarations
    with an implied any type.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**esModuleInterop**`**:** Emit additional JavaScript to ease support for importing
    CommonJS modules. This enables `**allowSyntheticDefaultImports**` for type compatibility.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**removeComments**`**:** Disable emitting comments, which means do not emit
    comments to output.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**preserveConstEnums**`**:** Disable erasing const `**enum**` declarations
    in generated code. When set as true, the `**enum**` exists at runtime and provides
    a way to reduce the overall memory footprint of your application at runtime by
    emitting the enum value instead of a reference.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**experimentalDecorators**`**:** This option enables using decorators in TS
    projects. ES has not yet introduced decorators, so they are disabled by default.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**alwaysStrict**`**:** Ensures that your files are parsed in the `**ECMAScript**`
    strict mode, and emit `"**use strict**"` for each source file. Default value is
    false.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**forceConsistentCasingInFileNames**`**:** Ensure that casing is correct in
    imports which disallow inconsistently cased references to the same file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**emitDecoratorMetadata**`**:** Enables experimental support for emitting
    type metadata for decorators.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**resolveJsonModule**`**:** Enable importing `**.json**` files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**skipLibCheck**`**:** Skip type checking all `**.d.ts**` files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**include**`**:** Specifies a list of glob patterns that match files to be
    included in compilation. If no ‘files’ or ‘include’ property is present in `**tsconfig.json**`,
    the compiler defaults to including all files in the containing directory and subdirectories
    except those specified by ‘exclude’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**exclude**`**:** Specifies a list of files to be excluded from compilation.
    The `**''exclude''**` property only affects the files included via the ‘include’
    property and not the `**''files''**` property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**files**`**:** If no `**''files''**` or `**''include''**` property is present
    in **tsconfig.json**, the compiler defaults to including all files in the containing
    directory and subdirectories except those specified by `**''exclude''**`. When
    a `**''files''**` property is specified, only those files and those specified
    by ‘include’ are included.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create a basic application with TypeScript**: Create a `**lib**` folder and
    create the `**main.ts**` file in that as defined in `**tsconfig.json**` include
    `**lib**` folder which compiles all .ts files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ mkdir lib`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ cd lib`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ touch main.ts`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now write the following code in the main.ts file and save it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import * as http from ''http'';`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const hostname = ''127.0.0.1'';`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const port = 3000;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const server = http.createServer((req, res) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.statusCode = 200;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.setHeader(''Content-Type'', ''text/plain'');`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.end(''Hello World'');`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`server.listen(port, hostname, () => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '``console.log(`Server running with TypeScript project at``'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '``http://${hostname}:${port}/`);``'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Run TypeScript Code**: Install the `**ts-node**` package for compilation
    and `**nodemon**` so that every time the changes in files can be auto reload or
    rerun. This way we do not need to run the server again after some changes. Go
    to the root directory and enter the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm install ts-node nodemon  --save-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ tsc`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As soon as the `**tsc**` command runs, a new directory is created named `**dist**`
    (we specified it in `**tsconfig.json**` as outDir). All TS files are compiled
    as JS and placed in this directory. Now we can run the application on the specified
    port, which is usually 3000 by default. If the port is 3000, then the application
    would be available at http://127.0.0.1:3000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**nodemon**` can detect new changes in the `**dist**` directory and restart
    the server as soon as there is a change. We just need to run the server using
    `**nodemon**` instead of node:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ nodemon dist/main.js`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/2.4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 2.4:** Compile Typescript Application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**nodemon**` can detect the changes from the `**dist**` directory and run
    `**main.js**` again, but since we are coding in TS, the files need to be recompiled
    after each change. Manual recompilation using `**tsc**` is also a tedious task.
    To solve this, we can use the watch option so that every time a TS file is changed,
    it will be compiled automatically. To run the `**tsc**` in watch mode, we can
    use `**-w**` flag as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ tsc -w`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This way we can build a basic TypeScript application. In case, if you want to
    explore more about `**tsconfig.js**` compiler options, you can visit [https://www.TypeScriptlang.org/tsconfig](https://www.TypeScriptlang.org/tsconfig)
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen building basic TypeScript application, now we will look into OOP
    concepts which are not supported in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[OOP Concepts in TS](toc.xhtml#s41a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript supports object-oriented programming, where we will learn about class,
    interface, abstraction, inheritance, encapsulation, and polymorphism. However,
    before that we need to know about data types in TypeScript. So let us take a look
    at the supported data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Types](toc.xhtml#s42a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript has primitive and non-primitive data types. Primitive data types
    means value is assigned directly, which are also known as basic data types, whereas
    non primitive can be reference or subtype of primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: '[Primitive Types](toc.xhtml#s43a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Primitive data types, the values are assigned directly. These are also
    known as basic data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**String**`: It is used for textual data that is enclosed with “(double quote)
    or ‘ (single quote). Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let name:string = "Tom";`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name = "Jerry";`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Number**`: It is used for numeric data. It also supports decimal, binary,
    hexadecimal, and octal data as well. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let total :number = 100;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let binaryNumber :number = 0b0101;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let hexaNumber :number = 0xf00d;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let octalNumber :number = 0o555;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Bigint**`: It is used for Numeric data. It also supports big integers. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let bigNumber :bigint = 200n;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let anotherBigNumber :bigint = BigInt(200);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Boolean**`: It is used when you need either a `**true**` or `**false**`
    case. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let mute :boolean = true;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mute = false;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Null**` and `**Undefined**`: It is the same as JavaScript: **null** represents
    an object having nothing, while **undefined** means type is not initialized. Both
    are subtypes of other types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let name:undefined = undefined;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let num:null = null;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Symbol**`: It is a new data type introduced in `**ES6**`. This creates a
    unique symbol from the `**Symbol**` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let symbolTest  = Symbol();`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Non-Primitive Types](toc.xhtml#s44a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`**Object**`: It represents a key-value pair in which key as property and value
    can be any primitive type. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let student :Object = {id: 1, name :"Jack"}; //declare and assign`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let employee :{emp_id:number, name:string};  //declare`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`employee = {emp_id: 2, name :"Jack"};  //assign value`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Array**`: It is similar to JavaScript arrays where you can store multiple
    elements in a single variable. It can be written in two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let colors: string[ ] = ["Black","white","Red"];`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let colors: Array<string>  =  ["Black","white","Red"];`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First way to define is using the type of elements followed by [ ] (Square bracket).
    Second way is to use Array followed by `**<typeof elements in Array>**`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Enums**`: Enumeration is used when possible values are from a set of few
    fixed constant values. It can be number `**enums**`, string `**enums**`, heterogeneous
    `**enums**`, or any primitive type `**enums**`. An example of the `**enums**`
    can be for status of a task:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum Status {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"pending",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"in_progress",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"completed"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Tuple**`: It represents an array in fixed size with known data types of
    each element in the array. For example,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//correct value need to match`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let tupleExample : [string,number] = ["Jack",1]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`//gives error`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`let tupleExampleIncorrect : [string,number] =[1,"Jack"];`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, the first element should be a string and the second would be
    a number. Providing them in incorrect order would throw an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**Any**`: It is a special type when the value type is not known. In simple
    words, after specifying any data type, checks are not done and it does not give
    any error. It is not recommended to use it except in the cases when there is no
    choice left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let data: **any** = {};`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`data.geometry={`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"type": "Polygon",`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"coordinates": [`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[123.61, -22.14], [122.38, -21.73], [121.06, -21.69]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`` `]`    `]`    `}`    `data.latitude = 90;`    `data.longitude = 90;` ``'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`` *   `**Custom**`: It allows you to define your own custom type using primitive
    and non- primitive types. For example a type project is created as follows:          `type
    project = {`                    `name: string;`                    `description:
    string;`                    `start_time: number;`                    `owner_name:
    string[];`                    `};`                    `const projectData: project
    = {`                    `name: ''Project Management'',`                    `description:
    ''It is about to manage any project from on board to deployment process'',`                    `start_time:
    1682516674343,`                    `owner_name: ["Jack", "John"]`                    `};`
    ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0] `Output:`    `VM37:2 Uncaught TypeError: Task is not a constructor at
    <anonymous>:2:13`    `(anonymous) @ VM37:2`    # [Blocking Scopes](toc.xhtml#s56a)    In
    JavaScript, variables can be declared with the "`**var**"` keyword which can be
    redeclared and reassigned that has functional scope, whereas in Es6, `**let**`
    and `**const**` are introduced with different usage of scope.    # [The let Keyword](toc.xhtml#s57a)    The
    variables declared using the let keyword have a blocking scope and these are accessible
    only in the block where they are declared. These variables can be reassigned new
    values but not redeclared.    Let us consider the following example:    `let name
    = "Project";`    `let nameIsDeclared = true;`    `if(nameIsDeclared) {`    `let
    name = "PMS";`    `console.log(name);`    `}`    `console.log(name);`    `// Output`    `PMS`    `Project`    As
    per the preceding example, the name variable is declared and assigned with `"**Project**"`
    value which has global scope. After that, the same name variable is declared and
    assigned with PMS in the block function. In this case, it is redeclared and does
    not give an error due to changing its scope from global to block.    However,
    if it is redeclared in the same global scope, then it gives an error as `**caught
    SyntaxError: Identifier ''name'' has already been declared**`**.**    # [The const
    Keyword](toc.xhtml#s58a)    The `**const**` keyword has also a blocking scope,
    same as `**let**`, but it cannot be reassigned to a new value. Its value remains
    constant as the name suggests.    In the following example, we are trying to re-assign
    a value to the `**const**` `**name**` and that is not allowed, hence we get a
    compile time error:    `const name = "PMS";`    `name = "Project Management system";`    `Output:`    `VM1717:2
    Uncaught TypeError: Assignment to constant variable.`    `at <anonymous>:2:6`    In
    case of variables holding objects, the behavior is a bit different. We know that
    Object is one kind of reference. If a const is created to hold the object, its
    properties can be changed, but the whole object cannot be replaced with another.    Let
    us consider the following example:    `const Task = {`    `name: "Insert Data
    to database",`    `efforts_hrs: 10`    `};`    `Task.name = " Fetch Data from
    database";`    `console.log(Task.name);`    Output:    `Fetch Data from database`    In
    this case, the name property of Task could be changed.    # [Template Literals](toc.xhtml#s59a)    ECMAScript
    supports template string which has syntax backticks ( ``**` `**`` ) enclosed with
    string. Inside the string we can use the dollar (`**$**`) sign to put a variable
    or an expression, which will be evaluated and its value will be printed.    `let
    name = "PMS";`    `let task = "Insert data to database";`    `console.log("Task
    => " + task + " and name => " + name); // without template`    ``console.log(`Task
    => ${task} and name => ${name}`);  // with template``    This avoids the use of
    + (plus) sign to concatenate multiple strings or variables.    # [Classes](toc.xhtml#s60a)    ES6
    allows the use of object-oriented concepts and classes are one of them. A class
    consists of objects, methods, and constructor. Classes can be declared with the
    class keyword.    Syntax :    `class class_name { }`    Example:    `class Project
    {`    `constructor() { }`    `}`    We already have seen details of class in OOPs
    concept earlier in this chapter.    # [Promises](toc.xhtml#s61a)    Before the
    introduction of `**ES6**`, callbacks were used to perform or handle asynchronous
    tasks. `**Callback**` is a type of function that gets called after the execution
    of the actual function is done. When there are multiple nested callbacks, it creates
    a situation called callback hell. To solve this problem, `**Promises**` were introduced.    The
    syntax of a promise is:    `new Promise((resolve,reject) => {….});`    A promise
    has following three states:    *   `**pending**`: It is the initial state that
    is before the reject or resolve state. *   `**reject**`: It is the state when
    failure happens. *   `**resolve**`: It is the state when execution completes successfully.    Let
    us consider the following example:    `const example = new Promise((resolve, reject)
    => {`    `try {`    `const options = {`    `body: JSON.stringify({test:"test"}),`    `headers:
    { ''Content-Type'': ''application/json'' },`    `method: ''POST'',`    `};`    ``const
    url = `https://www.google.com`;``    `fetch(url, options)`    `.then(async (response)
    => {`    ``console.log(`Got response - ${await response.text()}`);``    `resolve(response);`    `})`    `.catch((err)
    => {`    `console.log(''Catch => '', err);`    `reject(err);`    `}).finally(()
    => {`    `console.log("Finally");`    `});`    `} catch (error) {`    `console.log(''Catch
    2 => '', error);`    `reject(error);`    `}`    `});`    In the preceding example,
    when the result of fetch is returned, based on the good or bad result, we can
    call either `**resolve()**` or `**reject()**`. As we can see that on successful
    results, we are making a call to `**resolve()**`, and in case there is an error
    caught, we are calling `**reject()**`.    Using the syntax of promise is also
    now outdated. Instead of promises, async await is used for handling asynchronous
    requests. The same function can be rewritten using `**async await**` as:    `async
    function example() { // line 1`    `try {`    `const options = {`    `body: JSON.stringify({test:
    "test"}),`    `headers: {''Content-Type'': ''application/json''},`    `method:
    ''POST''`    `};`    `const url = ''https://www.google.com'';`    `const response
    = await fetch(url, options);`    ``console.log(`Got response - ${await response.text()}`);``    `return
    response;`    `} catch (error) {`    `console.log(''Catch => '', error);`    `throw
    error;`    `} finally {`    `console.log(''Finally'');`    `}`    `}`    To make
    a function use async-await, we need to declare the function as async similar to
    what we have done in line 1\. Now, we can use await for the calls for which we
    want to wait. In the preceding example, we have used `**await**` before `**fetch()**`.
    The execution is going to wait for the fetch to complete and return with some
    result.    # [Destructuring](toc.xhtml#s62a)    Destructuring allows us to make
    properties of objects and values of arrays into identical variables.    # [Object
    Destructuring](toc.xhtml#s63a)    Let us consider the following example:    `const
    obj = { a: 1, b: 2 };`    `const { a, b } = obj;`    `console.log(a);`    `console.log(b);`    `Output:`    `1`    `2`    In
    this example, we could declare two variables `**a**` and `**b**` directly from
    the object’s properties.    # [Array Destructuring](toc.xhtml#s64a)    Let us
    consider the following example to understand how it works:    `const numbers =
    ["1", "2", "3"];`    `const [red, yellow, green] = numbers;`    `console.log(red);
    // "1"`    `console.log(yellow); // "2"`    `console.log(green); // "3"`    `Output:`    `1`    `2`    `3`    In
    the case of an array, the values can be assigned to the variables in the same
    order as the values appear in the array.    # [Default Parameters](toc.xhtml#s65a)    In
    ES6, it is possible to set the default value to any variable through the parameter
    of function.    The syntax for setting the default value is following:    `function
    fnName(param1 = defaultValue1, /* …,*/ paramN = defaultValueN) {`    `// …`    `}`    Let
    us define a function to add two values:    `function sum(num1, num2=5) {`    `let
    sum = num1 + num2;`    `return sum;`    `}`    The preceding function can be called
    as:    `sum(1, 3)  // returns 4`    `sum(3)  // returns 8`    The function can
    be called without specifying a value to the default parameters.    # [Modules](toc.xhtml#s66a)    ES6
    provides export and import facilities. In this any written JavaScript code can
    be transferred from one file to another file as a module for reuse as export from
    one file to import in another file.    Let us create a file named project.js as:    `export
    class Project {`    `//objects`    `//constructor`    `//methods`    `}`    The
    class Project is exported using the export keyword. Let us create another file
    main.js in which we can import the class Project as:    `import {Person} from
    ''./project.js''`    Now, all properties and functions can be used in the main.js
    file. This way export-import is possible in JavaScript after ES6 was introduced.    #
    [Enhanced Object Literals](toc.xhtml#s67a)    In ES6, it is possible to make dynamic
    properties for objects effectively. It also enables shorthand syntax for initializing
    objects.    Let us consider the example of a function `**getTask()**` in regular
    JavaScript:    `// regular JavaScript`    `function getTask(name, hrs) {`    `return
    {`    `name: name,`    `hrs: hrs`    `}`    `}`    `getTask("Task 1", 10);`    `Output
    :`    `{name: ''Task 1'', hrs: 10}`    We can rewrite the same function in `**ES6**`
    as follows:    `//ES6`    `function getTask(name, hrs) {`    `return { name, hrs
    };`    `}`    `getTask("Task 1", 10);`    `Output:`    `{name: ''Task 1'', hrs:
    10}`    Now let us add some dynamic properties:    `let name = "t";`    `let i
    = 0;`    `const task = {`    `[name + ++i]: "Add",`    `[name + ++i]: "Update",`    `[name
    + ++i]: "Delete"`    `};`    We added three more properties to the task object
    as `**t1**`, `**t2**`, and `**t3**`:    `console.log(task.t1);`    `console.log(task.t2);`    `console.log(task.t3);`    `Output:`    `Add`    `Update`    `Delete`    These
    were the most used features of `**ES6**`. There are some other features which
    can be explored and be used with the help of various examples through reference
    from the official website of `**ECMAScript**`: [https://262.ecma-international.org](https://262.ecma-international.org).    #
    [EsLint](toc.xhtml#s68a)    EsLint is one of the best tools that checks JavaScript
    and ECMAScript code based on a set of rules defined and highlights what is not
    done correctly as per the rules. All major IDEs support `**eslint**`, and if that
    rule is violated, the developer is notified immediately. This helps to save a
    lot of development efforts.    # [Installing Eslint](toc.xhtml#s69a)    To install
    `**Eslint**` in your project, simply install the following packages:    `npm install
    eslint @typescript-eslint/parser`    `@typescript-eslint/eslint-plugin --save-dev`    #
    [Configuring Eslint](toc.xhtml#s70a)    Let us create a file named `**.eslintrc**`
    in the root directory of the project. Now save the following code in the `**.eslintrc**`
    file with defined rules and parser options:    `{`    `"env": {`    `"browser":
    true,`    `"es2021": true,`    `"node": true`    `},`    `"parser": "@typescript-eslint/parser",`    `"parserOptions":
    {`    `"ecmaVersion": 12,`    `"sourceType": "module"`    `},`    `"plugins":
    [`    `"@typescript-eslint"`    `],`    `"extends": [`    `"eslint:recommended",`    `"plugin:@typescript-eslint/recommended"`    `],`    `"rules":
    {`    `"@typescript-eslint/explicit-module-boundary-types": "off",`    `"@typescript-eslint/no-unused-vars":
    "error",`    `"no-console": "warn",`    `"indent": ["error", 2],`    `"quotes":
    ["error", "single"],`    `"semi": ["error", "always"]`    `}`    `}`    # [Running
    Eslint](toc.xhtml#s71a)    Although all IDEs will immediately start evaluating
    the code based on the provided `**.eslintrc**` file, we can run `**eslint**` manually
    in the terminal as well.    Open the `**package.json**` file of the project and
    save the following lint script:    `"scripts": {`    `**…**`    `"**lint**"**:**
    "**eslint . --ext .ts**"`    `}`    Now we can run `**lint**` script:    `$ npm
    run lint`  ![](img/2.5.jpg)  **Figure 2.5:** Run Eslint    Some of the `**Eslint**`
    issues are auto-fixable and we can fix those by using `**-- fix**` option in script:    `"scripts":
    {`    `**…**`    `"**lint**"**:** "**eslint . --ext .ts --fix**"`    `}`  ![](img/2.6.jpg)  **Figure
    2.6:** Fix Eslint Issue    This is helpful when there are small errors like missing
    semicolon, extra whitespace, and so on.    As shown above, some fixes need to
    be done manually here. For demonstration purpose, we did not remove the console
    statements, which need to be manually removed or an eslint rule should be added.    That
    is overview of how `**Eslint**` is used in project for better development; if
    you need to explore more about it, follow the reference EsLint Documentation ([https://eslint.org/docs/latest/](https://eslint.org/docs/latest/))    Earlier,
    there was a typescript linting tool named `**tslint**`, which is now deprecated.
    The plan is to use `**Eslint**` for typescript projects as well. The roadmap can
    be tracked at [https://github.com/palantir/tslint/issues/4534](https://github.com/palantir/tslint/issues/4534).    #
    [Conclusion](toc.xhtml#s72a)    In this chapter, we learned about basic TypeScript
    with examples, its installation, and configuration. We learned about the OOP concepts
    along with what is offered by ECMAScript.    In the next chapter, we will learn
    Express.js, the most used framework of Node.js. Express.js will help us to build
    the APIs we need in the chapters ahead in the book.    # [Multiple Choice Questions](toc.xhtml#s73a)    1.  What
    is TypeScript?     1.  A JavaScript library for creating user interfaces     2.  A
    statically typed superset of JavaScript     3.  A database management system     4.  A
    programming language for server-side development 2.  Which of the following is
    a benefit of using TypeScript?     1.  It runs in a web browser without any compilation     2.  It
    enforces strict typing rules to catch errors early     3.  It provides built-in
    support for database connections     4.  It can be used for mobile app development
    3.  How is TypeScript code compiled into JavaScript?     1.  It is interpreted
    by the browser     2.  It is manually transcribed by developers     3.  It is
    compiled using the TypeScript compiler (tsc)     4.  It is converted by a built-in
    JavaScript converter 4.  Which command is used to compile a TypeScript file (for
    example, `**app.ts**`) into JavaScript?     1.  ts compile app.ts     2.  tsc
    app.ts     3.  typescript app.ts     4.  transpile app.ts 5.  Which TypeScript
    feature allows you to define reusable types for complex data structures?     1.  Type
    annotations     2.  Type inference     3.  Interfaces and custom types     4.  Polymorphism
    6.  Which OOP concept promotes the idea of bundling data and methods that operate
    on that data into a single unit called an object?     1.  Inheritance     2.  Encapsulation     3.  Polymorphism     4.  Abstraction
    7.  Which OOP principle states that objects of a derived class should be able
    to replace objects of the base class without affecting the correctness of the
    program?     1.  Encapsulation     2.  Abstraction     3.  Inheritance     4.  Polymorphism
    8.  Which ES6 feature allows you to unpack elements from arrays or properties
    from objects into distinct variables?     1.  Destructuring Assignment     2.  Object
    Literals     3.  Spread Operator     4.  Template Literals 9.  Which ES6 feature
    allows you to create multi-line strings with embedded expressions?     1.  Template
    Strings     2.  String Templates     3.  Multi-line Strings     4.  String Literals
    10.  Given an array of numbers, how do you create a new array with all the elements
    of numbers followed by 5 using the spread operator?     1.  […numbers + 5]     2.  […numbers,
    5]     3.  [numbers + …5]     4.  [5 …numbers]    # [Answers](toc.xhtml#s74a)    1.  b
    2.  b 3.  c 4.  b 5.  c 6.  b 7.  d 8.  a 9.  a 10.  b    # [Further Reading](toc.xhtml#s75a)    [https://www.typescriptlang.org](https://www.typescriptlang.org)
    [PRE1]`'
  prefs: []
  type: TYPE_NORMAL
