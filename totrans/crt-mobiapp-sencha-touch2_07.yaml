- en: 'Chapter 7. The Decider: External APIs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 决策者：外部API
- en: 'One of the key aspects of mobile technology is the ability to tie different
    systems together into a meaningful application. More and more companies are allowing
    access to their programs and data through an **Application Programming Interface**
    or **API**. These APIs include things such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动技术的一个关键方面是将不同的系统结合起来形成一个有意义的应用程序。越来越多的公司允许通过**应用程序编程接口**或**API**访问他们的程序和数据。这些API包括如下内容：
- en: Maps via Google, Yahoo, and other providers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Google、Yahoo和其他提供商的地图
- en: Music applications such as Rdio and Spotify
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Rdio和Spotify之类的音乐应用程序
- en: Location aware data providers such as Foursquare
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Foursquare之类的位置感知数据提供商
- en: Social networks such as Facebook and Google Plus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Facebook和Google Plus之类的社交网络
- en: Photo services such as Flickr and Picassa
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Flickr和Picasa之类的照片服务
- en: Note
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get a rough idea of what is available, at [http://www.programmableweb.com/apis](http://www.programmableweb.com/apis).
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[http://www.programmableweb.com/apis](http://www.programmableweb.com/apis)上大致了解可用的内容。
- en: 'This is just a small sampling of the data available to make your application
    more useful. The trick is how to get the data and how to use it. In this chapter
    we will be using the Foursquare API to explore the use of these types of APIs
    and how to get started. We will talk about:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是可用数据的小样本，使你的应用程序更有用。关键是获取数据和使用数据的方法。在本章中，我们将使用Foursquare API来探索这些类型API的使用以及如何开始。我们将讨论：
- en: An overview of external APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部API概述
- en: Getting started with the Foursquare API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Foursquare API
- en: Building the basic application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本应用程序
- en: Loading a data store with information from Foursquare
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Foursquare的信息加载数据存储
- en: Displaying the data to the user
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示数据
- en: We will start with a general look at how external APIs generally work and what
    you need to get started with one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从外部API通常是如何工作以及你需要开始使用它的概述开始。
- en: Using an external API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部API
- en: APIs are provided as a service from many different companies. This is not an
    entirely altruistic move on the part of the company. The expectation is that by
    providing the information and access to the company's data, the company gets more
    usage for their service and more customers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同的公司提供API作为一项服务。这不是公司完全无私的行为。预期是通过提供信息和访问公司数据，公司可以使他们的服务得到更多使用，并吸引更多客户。
- en: With this in mind, most (if not all) companies will require you to have an account
    on their system in order to access their API. This allows you to access their
    systems and information from within your application, but more importantly from
    the company's perspective, it allows them to maintain control over how their data
    can be used. If you violate the company's usage policies, they can shut off your
    application's access to the data, so play nice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，大多数（如果不是所有）公司都会要求你在他们的系统中拥有一个账户，以便访问他们的API。这允许你从你的应用程序内部访问他们的系统和信息，但更重要的是，从公司的角度来看，它允许他们保持对其数据如何使用的控制。如果你违反了公司的使用政策，他们可以切断你的应用程序对数据的访问，所以请保持友好。
- en: The API key
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API密钥
- en: Most APIs require a key in order to use them. An API key is a long string of
    text that gets sent as an extra parameter on any request you send to the API.
    The key is often composed of two separate pieces and it uniquely identifies your
    application to the system much like a username and a password would for a regular
    user account. As such it's also a good idea to keep this key hidden in your application
    so that your users can't easily get it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数API在使用时都需要一个密钥。API密钥是一长串文本，它作为任何你发送到API的请求的额外参数发送。密钥通常由两个独立的部分组成，它像用户名和密码对普通用户账户那样唯一地识别你的应用程序。因此，最好也将此密钥隐藏在你的应用程序中，这样你的用户就不能轻易地获取它。
- en: While each company is different, an API key is typically a matter of filling
    out a web form and getting the key. Most companies do not charge for this service.
    However, some do limit the usage available to outside applications, so it's a
    good idea to look at any restrictions the company sets on their service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个公司都不同，但API密钥通常只是填写一个网页表单并获取密钥的事情。大多数公司不为此服务收费。然而，一些公司确实限制了外部应用程序可用的使用量，因此查看公司对其服务设定的任何限制是个好主意。
- en: Once you have an API key you should take a look at the available functions for
    the API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了API密钥，你应该查看API提供的可用功能。
- en: API functions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API函数
- en: 'API functions typically come in two types – public and protected:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: API函数通常有两种类型——公开的和受保护的：
- en: The public functions can simply be requested with the API key
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共功能可以通过API密钥简单请求
- en: The protected functions will also require that a user be logged into the system
    in order to make the request
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的函数还要求用户登录到系统中才能发出请求
- en: If the API function is protected, your application will also need to know how
    to log in correctly with the remote system. The login functions will usually be
    a part of the API or a web standard such as Facebook and Google's OAuth.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API功能受保护，您的应用程序还需要知道如何正确地与远程系统登录。登录功能通常会是API的一部分或是一个网络标准，例如Facebook和Google的OAuth。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that while OAuth is a standard, its implementation will vary
    depending on the service. You will need to consult the documentation for the service
    you are using to make sure that the features and functions you need are supported.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，虽然OAuth是一个标准，但其实现将根据服务而有所不同。您需要查阅您所使用服务的文档，以确保您需要的特性和功能得到支持。
- en: Be sure to read through the service's API documentation to understand which
    functions you will need and if they require a login.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要阅读服务的API文档，以了解您需要哪些功能以及它们是否需要登录。
- en: Another thing to understand about APIs is that they don't always do exactly
    what you need them to do. You may find that you need to do a little more work
    than you expect to get the data you need. In this case, it's always good to do
    a little bit of testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于API的另一件事是要理解，它们并不总是完全按照您需要的去做。您可能会发现，您需要做比预期更多的工作才能获取所需的数据。在这种情况下，进行一些测试总是好的。
- en: 'Many APIs offer a console interface where you can type commands directly into
    the system and examine the results:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API提供控制台接口，您可以直接在系统中输入命令并检查结果：
- en: '![API functions](img/8901OS_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![API函数](img/8901OS_07_01.jpg)'
- en: This can be really helpful for digging into the data, but consoles are not always
    available for every API service. Another option is to send the commands in your
    application (along with your API credentials) and examine the data returned in
    the Safari console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于深入挖掘数据非常有帮助，但控制台并不总是适用于每个API服务。另一种选择是将命令发送到您的应用程序中（包括您的API凭据）并在Safari控制台中检查返回的数据。
- en: 'The drawback of this method is that the data is often returned as a single-line
    string that is very difficult to read as shown in the screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是数据通常以单行字符串的形式返回，如截图所示，非常难以阅读：
- en: '![API functions](img/8901OS_07_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![API函数](img/8901OS_07_02.jpg)'
- en: 'This is where a tool like JSONLint comes in handy. You can copy and paste the
    single-line string from your Safari console into the page at [http://jsonlint.com](http://jsonlint.com)
    and have the string formatted so that it is much easier to read and validate the
    string as JSON at the same time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，一个像JSONLint这样的工具就派上用场了。您可以将从Safari控制台复制的单行字符串粘贴到[http://jsonlint.com](http://jsonlint.com)页面中，这样字符串就会被格式化，使其更容易阅读，并且同时验证字符串作为JSON的有效性：
- en: '![API functions](img/8901OS_07_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![API函数](img/8901OS_07_03.jpg)'
- en: Once you get a hold of what data is being sent and received, you will need to
    set it all up in Sencha Touch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了发送和接收的数据，您就需要在Sencha Touch中设置所有这些。
- en: External APIs and Sencha Touch
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部API和Sencha Touch
- en: As we have talked about earlier in the book, you cannot use a standard AJAX
    request to get data from another domain. You will need to use a JSONP proxy and
    store to request data from an external API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中之前讨论过的，您不能使用标准的AJAX请求从另一个域获取数据。您需要使用JSONP代理和存储来请求外部API的数据。
- en: Using the API or the Safari console, you can get a good idea of the data that
    is coming back to you and use it to set up your model. For this example, let's
    use a simple model called `Category`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API或Safari控制台，您可以很好地了解返回给您的数据，并使用它来设置您的模型。对于这个例子，让我们使用一个简单的模型叫做`Category`。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then set up a store to load data from the API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以设置一个存储来从API加载数据：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will set up a store with our `Category` model and call the `url` property
    for our external API. Remember that we have to send our credentials along with
    the request so we set these as `extraParams` on the `proxy` section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个使用我们的`Category`模型的数据存储，并调用我们外部API的`url`属性。请记住，我们必须在请求中发送我们的凭据，因此我们在`proxy`部分将这些设置为`extraParams`。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `apiKey` and `appSecret` properties shown here are examples. You will need
    your own API key information to use an API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`apiKey`和`appSecret`属性是示例。您需要自己的API密钥信息才能使用API。
- en: We also need to set a property called `rootProperty` in the `reader` section.
    Most API's send back a ton of detailed information along with the request and
    the store needs some idea of where to start loading in the category records.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`reader`部分设置一个名为`rootProperty`的属性。大多数API都会在请求中发送大量的详细信息，并且存储需要一些关于从何处开始加载类别记录的想法。
- en: We can also add additional parameters later by calling the `setExtraParam()`
    function on our store proxy. This will let us add additional parameters to be
    sent to our external API URL.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在存储代理上调用`setExtraParam()`函数来稍后添加额外的参数。这将使我们能够添加要发送到外部API URL的额外参数。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that `setExtraParam()` will add an additional parameter but `setExtraParams()`
    will replace all of our `extraParams` with the new values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`setExtraParam()`将添加一个额外的参数，但`setExtraParams()`将用新值替换我们所有的`extraParams`。
- en: Let's take a look at our application for this chapter to see how this all fits
    together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章的应用程序，看看这一切是如何结合在一起的。
- en: The basic application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本应用
- en: The Decider application is designed to use a combination of local storage, Google's
    Map API, and the Foursquare API. The application will take a list of people and
    their food preferences, and then use Foursquare and Google Maps to find nearby
    places to eat that will match everyone's food preferences.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Decider应用程序旨在结合使用本地存储、Google的Map API和Foursquare API。应用程序将获取人员列表及其食品偏好，然后使用Foursquare和Google
    Maps找到符合每个人食品偏好的附近餐饮场所。
- en: 'This screenshot provides a pictorial representation of the preceding explanation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图提供了先前解释的图示表示：
- en: '![The basic application](img/8901OS_07_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![基本应用](img/8901OS_07_04.jpg)'
- en: Our contacts and categories will be stored using local storage. External APIs
    from Google and Foursquare will generate our maps and restaurant listings respectively.
    We will start with a quick overview of the basic application structure and forms,
    before diving into the store setup and API integration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本地存储来存储我们的联系人和类别。来自Google和Foursquare的外部API将分别生成我们的地图和餐厅列表。我们将在深入研究存储设置和API集成之前，快速概述基本应用程序结构和表单。
- en: 'Our main container is a simple card layout:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要容器是一个简单的卡片布局：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this viewport we will add two cards: a navigation view and a form panel.
    Our `navigationvew` will serve as our main window for display. We will add additional
    containers to it via our controller:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，我们将添加两个卡片：一个导航视图和一个表单面板。我们的`navigationvew`将作为我们的主显示窗口。我们将通过我们的控制器向其中添加额外的容器：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `mainView` contains our `navigationBar` and our `homeScreen` container
    with the big `Get Started` button. This button will add new containers to the
    navigation view (we will look at this later in the controller).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此`mainView`包含我们的`navigationBar`和包含大号`Get Started`按钮的`homeScreen`容器。此按钮将向导航视图添加新容器（我们将在控制器中稍后查看）。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that Sencha Touch automatically creates a back button for each container
    that is added to the navigation view. This means that we don't have to write an
    extra code for it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Sencha Touch会自动为添加到导航视图中的每个容器创建一个返回按钮。这意味着我们不需要为它编写额外的代码。
- en: 'The second item that is added to our viewport is our form panel. This will
    contain text fields for first and last name, as well as a selectable list for
    our different food categories:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到我们的视口中的第二个项目是我们的表单面板。它将包含用于姓氏和名字的文本字段，以及用于我们不同食品类别的可选择列表：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We close out the form with a `segmentedbutton` property, which has options for
    `Save` and `Cancel`. We will add the handler functions for these buttons later
    on in our controller.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个`segmentedbutton`属性关闭表单，该属性具有`Save`和`Cancel`选项。我们将在控制器中稍后添加这些按钮的处理函数。
- en: We also include a title bar at the top of the form to give the user some idea
    of what they are doing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在表单的顶部包括一个标题栏，以使用户了解他们正在做什么。
- en: One of the key pieces of this form is the categories list, so let's take a closer
    look at how it works.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单的关键部分之一是类别列表，因此让我们更详细地看看它是如何工作的。
- en: Creating the categories list
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类别列表
- en: Since we will be getting our list of potential restaurants from the Foursquare
    API, we need to use their categories as well so that we can match things up with
    some degree of accuracy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从Foursquare API获取潜在餐厅的列表，因此我们需要使用他们的类别，以便我们可以以某种程度的准确性匹配事物。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Foursquare API can be found at [https://developer.foursquare.com/](https://developer.foursquare.com/).
    As mentioned before, you will need a Foursquare account to access the API. You
    will also need an API key in order to integrate Foursquare with your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Foursquare API 可以在 [https://developer.foursquare.com/](https://developer.foursquare.com/)
    找到。如前所述，你需要一个 Foursquare 账户来访问 API。你还需要一个 API 密钥，以便将 Foursquare 集成到你的应用程序中。
- en: We can use the Foursquare's API to get a list of categories, however the API
    returns a list of a few hundred categories including Airports, Trains, Taxis,
    Museums, and Restaurants. Additionally, each of these has its own subcategories.
    All we really want is the subcategories for Restaurants.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Foursquare 的 API 获取类别列表，然而 API 返回的列表包括机场、火车、出租车、博物馆和餐厅等几百个类别。此外，每个类别都有自己的子类别。我们真正想要的只是餐厅的子类别。
- en: 'To make things more complicated, Foursquare''s API also returns the data like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使事情更加复杂，Foursquare 的 API 还会以这种方式返回数据：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means we can only get at a specific category by its order in the array
    of categories. For example, if Restaurants is the twenty-third category in the
    array, we can get to it as: `categories[23]`, but we cannot get to it by calling
    `categories[''Restaurants'']`. Unfortunately, if we use `categories[23]` and Foursquare
    adds a new category or changes the order, our application will break.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只能通过类别数组中的顺序来获取特定的类别。例如，如果餐厅是数组中的第二十三类别，我们可以通过 `categories[23]` 来访问它，但不能通过调用
    `categories['Restaurants']` 来访问。不幸的是，如果我们使用 `categories[23]`，而 Foursquare 添加了一个新类别或改变了顺序，我们的应用程序将会崩溃。
- en: 'This is a situation where it pays to be adaptable. Foursquare''s API includes
    a console where we can try out our API requests. We can use this console to request
    the data for all of our categories and then pull the data we need into a flat
    file for our application. Check this URL to see the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要灵活应对的情况。Foursquare 的 API 包含一个控制台，我们可以在这里尝试我们的 API 请求。我们可以使用这个控制台来请求我们所有类别的数据，然后将所需的数据拉入我们应用程序的平面文件中。查看此
    URL 以查看输出：
- en: '[https://developer.foursquare.com/docs/explore#req=venues/categories](https://developer.foursquare.com/docs/explore#req=venues/categories)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.foursquare.com/docs/explore#req=venues/categories](https://developer.foursquare.com/docs/explore#req=venues/categories)'
- en: We can copy just the Restaurant information that we need from categories and
    save this as a file called `categories.json` and call it from our store.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从类别中复制所需的餐厅信息，并将其保存为名为 `categories.json` 的文件，然后从我们的存储中调用它。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A better solution to this conundrum would be to write some server code that
    would request the full category list from Foursquare and then pull out just the
    information we are interested in. But for the sake of brevity, we will just use
    a flat `json` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个难题的更好方法可能是编写一些服务器代码，从 Foursquare 请求完整的类别列表，然后提取我们感兴趣的信息。但为了简洁起见，我们只会使用平面
    `json` 文件。
- en: 'Each of our categories are laid out like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个类别都像这样排列：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The main pieces we care about are the `id`, `name`, `shortname` and `icon`
    values. This gives us a data model that looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的要点是 `id`、`name`、`shortname` 和 `icon` 值。这给我们一个看起来像这样的数据模型：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that we also add a function to create an image URL for the icons we
    need. We do this with the `convert` configuration, which lets us assemble the
    data for image URL based on the other data in the record:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们还在其中添加了一个函数来创建所需图标的图像 URL。我们通过 `convert` 配置来完成此操作，它允许我们根据记录中的其他数据组装图像 URL
    的数据：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `convert` function is automatically passed both the data value (`v`), which
    we ignore in this case, and the record (`rec`), which lets us create a valid Foursquare
    URL by combining the `icon.prefix` value, a number, and the `icon.suffix` value
    in our record. If you take a look at our previous category data example, this
    would yield a URL of:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert` 函数会自动传入数据值（`v`），在这个例子中我们忽略了它，以及记录（`rec`），这允许我们通过将记录中的 `icon.prefix`
    值、一个数字和 `icon.suffix` 值组合起来，创建一个有效的 Foursquare URL。如果你查看我们之前的类别数据示例，这将产生以下 URL：'
- en: '[https://foursquare.com/img/categories_v2/food/argentinian_32.png](https://foursquare.com/img/categories_v2/food/argentinian_32.png)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://foursquare.com/img/categories_v2/food/argentinian_32.png](https://foursquare.com/img/categories_v2/food/argentinian_32.png)'
- en: By changing the number we can control the size of the icon (this is part of
    the Foursquare API as well).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改数字，我们可以控制图标的大小（这也是 Foursquare API 的一部分）。
- en: 'We combine this with our XTemplate:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个与我们的 XTemplate 结合起来：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This gives us a very attractive list for choosing our categories:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个非常吸引人的类别选择列表：
- en: '![Creating the categories list](img/8901OS_07_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![创建类别列表](img/8901OS_07_05.jpg)'
- en: Next we need to take a look at the controller for the contact form.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要查看联系表单的控制器。
- en: Creating the contact controller
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联系人控制器
- en: 'The contact controller handles saving the contact and canceling the action.
    We start out the controller by declaring our references and controls:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 联系控制器处理保存联系人和取消操作。我们通过声明我们的引用和控制开始控制器：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember that our `refs` (references) provide a handy shortcut we can use anywhere
    in the controller to get to the pieces we need. Our `control` section attaches
    `tap` listeners to our cancel and save buttons.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们的`refs`（引用）为我们提供了一个方便的快捷方式，我们可以在控制器中的任何地方使用它来获取我们需要的部分。我们的`control`部分将`tap`监听器附加到取消和保存按钮上。
- en: 'Next we need to add our two functions after the controls section. The `doCancel`
    function is really simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要在控制部分之后添加我们的两个函数。`doCancel`函数非常简单：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We just use our references to clear the contact editor, deselect all the items
    in our category list, and switch back to our main view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用我们的引用来清除联系人编辑器，取消选择我们类别列表中的所有项目，并切换回我们的主视图。
- en: 'The `save` function is a little more complex, but similar to the functions
    we have covered elsewhere in this book:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`函数比我们在这本书的其他地方覆盖的函数复杂一些，但类似：'
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with our previous save functions, we create a new `MyApp.model.Contact` and
    add the values from our form. However, since our list isn't really a standard
    form component we need to grab its selections separately and add them to the contact
    data as a comma-separated list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的保存函数一样，我们创建一个新的`MyApp.model.Contact`并添加表单中的值。然而，由于我们的列表并不是一个标准的表单组件，我们需要单独获取其选择并将其作为以逗号分隔的列表添加到联系人数据中。
- en: We do this by creating an empty array and using `Ext.each()` to loop through
    and run a function on all our categories. We then use `join` to implode the array
    into a comma-separated list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个空数组并使用`Ext.each()`来遍历并运行一个函数在我们所有的类别上。然后我们使用`join`将数组压缩成以逗号分隔的列表。
- en: Finally, we save the contact and run our `doCancel` function to clean up and
    return to our main view.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们保存联系人并运行我们的`doCancel`函数来清理并返回到我们的主视图。
- en: Now that we can add contacts we need to create a controller to handle our requests
    to the Foursquare and Google APIs, and get the data back to our users.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够添加联系人，我们需要创建一个控制器来处理我们对Foursquare和Google API的请求，并将数据返回给我们的用户。
- en: Integrating with Google Maps and Foursquare
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Google Maps和Foursquare集成
- en: 'Our application still has a couple of tasks to accomplish. It needs to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序仍有一些任务要完成。它需要：
- en: Handle the click of the **Get Started** button
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理**开始**按钮的点击
- en: Add our maps panel and offer to adjust the current location via Google Maps
    API
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加我们的地图面板，并通过Google Maps API提供调整当前位置的选项
- en: Display a list of friends to include in our search
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示要包含在搜索中的朋友列表
- en: Display the search results in a list
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中显示搜索结果
- en: Display the details for a selected result
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所选结果的详细信息
- en: We will start out with the basic skeleton of the controller, create the views
    and stores, and then finish up the controller to complete the application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从控制器的基本骨架开始，创建视图和存储，然后完成控制器以完成应用程序。
- en: Starting the mainView.js controller
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动mainView.js控制器
- en: We will start the `mainView.js` controller file with some placeholders for the
    stores. We will add views later on and some references for those components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一些存储的占位符开始`mainView.js`控制器文件。我们将在稍后添加视图和这些组件的一些引用。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that when working with placeholders in this fashion the application
    will not be testable until all the files are actually in place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以这种方式使用占位符时，应用程序将无法测试，直到所有文件实际上都已就位。
- en: 'We create the `mainView.js` file in our `controllers` folder:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`controllers`文件夹中创建`mainView.js`文件：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the top of this configuration we require `Ext.DateExtras`. This file provides
    us with formatting options for date objects. If this file is not included, only
    the `now()` method for date objects will be available in your application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置的顶部，我们引入了`Ext.DateExtras`。此文件为我们提供了日期对象的格式化选项。如果此文件未包含，则日期对象中只有`now()`方法将可用在你的应用程序中。
- en: In our `views` section we have added placeholders for `confirmLocation`, `restaurantList`,
    `friendChooser`,and `restaurantDetails`. We will add these files later on, along
    with the `RestaurantStore` file listed in our `stores` section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`views`部分，我们为`confirmLocation`、`restaurantList`、`friendChooser`和`restaurantDetails`添加了占位符。我们将在稍后添加这些文件，以及`stores`部分中列出的`RestaurantStore`文件。
- en: We also have a number of references for these views, stores, and some of their
    sub-components. We will need to create these views before getting to the rest
    of our controller. We will take these views in the order the user will see them,
    starting with the `confirmLocation` view.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也为这些视图、存储以及它们的一些子组件提供了一些参考。在我们继续控制器其他部分之前，我们需要创建这些视图。我们将按照用户看到的顺序来处理这些视图，首先是`confirmLocation`视图。
- en: Creating the confirmLocation view
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 confirmLocation 视图
- en: The `confirmLocation` view first appears when the user clicks on the **Get Started**
    button. This view will present the user with a map showing their current location
    and offer an option to switch to a different location if the user desires.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**开始**按钮时，`confirmLocation`视图首先出现。这个视图将向用户展示一个显示他们当前位置的地图，并提供一个选项，如果用户希望，可以切换到不同的位置。
- en: 'The following screenshot gives a pictorial representation of the preceding
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图给出了前面代码的图形表示：
- en: '![Creating the confirmLocation view](img/8901OS_07_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![创建 confirmLocation 视图](img/8901OS_07_06.jpg)'
- en: 'In order to give ourselves a bit more flexibility, we will be using the Google
    Maps Tracker plugin as part of this view. You can find this plugin in your Sencha
    Touch 2 folder in `examples/map/lib/plugin/google/Tracker.js`. Copy the file into
    a `lib/google` folder in your main application folder and be sure to add it into
    the `requires` section of your `app.js` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们自己更多的灵活性，我们将在这个视图中使用Google Maps Tracker插件。你可以在你的Sencha Touch 2文件夹中的`examples/map/lib/plugin/google/Tracker.js`找到这个插件。将文件复制到你的主应用程序文件夹中的`lib/google`文件夹，并确保将其添加到`app.js`文件的`requires`部分：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should also set the path that corresponds to the `Ext.plugin` namespace,
    just above where you enable `Ext.Loader` in `app.js` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在`app.js`文件中启用`Ext.Loader`的上方设置与`Ext.plugin`命名空间对应的路径：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This plugin will let us easily drop markers on the map.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件将使我们能够轻松地在地图上放置标记。
- en: 'Once the Google Tracker plugin file is included in the application, we can
    set up our `confirmLocation.js` view like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将Google Tracker插件文件包含到应用程序中，我们就可以像这样设置我们的`confirmLocation.js`视图：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The view itself is a simple container with some HTML at the top asking the user
    to confirm their location. Next we have a map container that uses our Google Tracker
    plugin to configure the map and animate the location marker to drop from the top
    of the screen to the current location of the user. The `position` configuration
    is a default location, which is used when the user denies the application access
    to their current location. This one is set to the Sencha Headquarters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 视图本身是一个简单的容器，顶部有一些HTML代码，提示用户确认他们的位置。接下来是一个地图容器，它使用我们的Google Tracker插件来配置地图并使位置标记从屏幕顶部动画到用户的当前位置。`position`配置是一个默认位置，当用户拒绝应用程序访问其当前位置时使用。这个位置设置为Sencha总部。
- en: 'Next we need a few options for the user to choose from: **Cancel**, **New Location**,
    and **Next**. We will add these as a segmented button under our map container.
    We add the code to the end of our `items` container (after the `map` container):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为用户提供一些选项来选择：**取消**、**新位置**和**下一步**。我们将把这些选项作为一个分段按钮添加到地图容器下。我们在`items`容器的末尾添加代码（在`map`容器之后）：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each of our buttons has an associated action. This allows us to assign functions
    to each button within the `mainView.js` controller. By creating buttons in this
    fashion, we maintain separation between the display of the application and the
    functionality of the application. This is really helpful when you want to re-use
    a view component.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每个按钮都关联了一个动作。这允许我们在`mainView.js`控制器中为每个按钮分配函数。通过以这种方式创建按钮，我们保持了应用程序显示和功能之间的分离。当你想要重用视图组件时，这非常有帮助。
- en: The next view the user encounters is the Friends Chooser.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用户遇到的下一个视图是“朋友选择器”。
- en: Creating the Friends Chooser view
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Friends Chooser 视图
- en: 'The `friendsChooser.js` file uses a similar list to our previous category chooser.
    This lets our users select multiple people to include in the restaurant search:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`friendsChooser.js`文件使用了一个与之前类别选择器相似的列表。这允许我们的用户选择多个要包含在餐厅搜索中的人：'
- en: '![Creating the Friends Chooser view](img/8901OS_07_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Friends Chooser 视图](img/8901OS_07_07.jpg)'
- en: 'Our `friendChooser` extends the `Ext.Container` component and allows the user
    to select from a list of friends:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`friendChooser`扩展了`Ext.Container`组件，并允许用户从朋友列表中选择：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As with our previous panel, we have a container with HTML at the top to provide
    some instructions to the user. Below that is our `list` container, which, like
    our category list, allows for selection of multiple items via the `mode: ''MULTI''`
    configuration. We also set `grouped` to `true`. This allows our store to group
    the contacts together by last name.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '就像我们之前的面板一样，我们有一个包含 HTML 的容器在顶部，为用户提供一些说明。下面是我们的 `list` 容器，它，就像我们的类别列表一样，允许通过
    `mode: ''MULTI''` 配置选择多个项目。我们还设置了 `grouped` 为 `true`。这允许我们的商店通过姓氏将联系人分组在一起。'
- en: 'If you take a look at the `ContactStore.js` file, you can see where we do:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `ContactStore.js` 文件，您可以看到我们做了什么：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This configuration returns the first letter of the last name for grouping.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置返回姓氏的首字母进行分组。
- en: 'The last thing we need to do with our `friendChooser.js` file is add the buttons
    at the bottom to **Cancel** or **Finish** the search. The buttons go out in the
    `items` section, just below the list:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用 `friendChooser.js` 文件做的最后一件事是在底部添加按钮来 **取消** 或 **完成** 搜索。按钮位于列表下方，`items`
    部分中：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As in our previous view, we use a `segmentedbutton` property with actions assigned
    to each of our individual buttons.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的视图一样，我们使用一个 `segmentedbutton` 属性，并为每个单独的按钮分配了动作。
- en: Once the user clicks on **Finish**, we will need to return a list of restaurants
    they can select from.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击 **完成**，我们需要返回一个他们可以从中选择的餐厅列表。
- en: Creating the restaurant list, store, and details
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建餐厅列表、商店和详细信息
- en: Our restaurant list will use a store and the Foursquare API to return a list
    of restaurants based on the shared preferences of everyone the user selected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的餐厅列表将使用商店和 Foursquare API 根据用户选择的每个人的共享偏好返回餐厅列表。
- en: 'The following screenshot exemplifies the preceding explanation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面的解释：
- en: '![Creating the restaurant list, store, and details](img/8901OS_07_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![创建餐厅列表、商店和详细信息](img/8901OS_07_08.jpg)'
- en: 'This component is pretty basic:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件相当基础：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This component uses a simple list with a configuration option for `onItemDisclosure:
    true`. This places an arrow next to the restaurant name in the list. The user
    will be able to click on the arrow and see the details for that restaurant (which
    we will create after the store).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '此组件使用一个简单的列表，并具有 `onItemDisclosure: true` 的配置选项。这将在列表中的餐厅名称旁边放置一个箭头。用户将能够点击箭头并查看该餐厅的详细信息（我们将在创建商店后创建）。'
- en: We also set `grouped` to `true`, only this time our store will use a function
    to calculate and sort by distance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了 `grouped` 为 `true`，但这次我们的商店将使用一个函数来计算和按距离排序。
- en: Creating the restaurant store and model
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建餐厅商店和模型
- en: 'The restaurant store is where we set up our request to the Foursquare API:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 餐厅商店是我们设置向 Foursquare API 发送请求的地方：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `RestaurantStore.js` file sets a `model` and `storeId` field for our store
    and then defines our proxy. The `proxy` section is where we set up our request
    to Foursquare.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantStore.js` 文件为我们的商店设置了一个 `model` 和 `storeId` 字段，然后定义了我们的代理。`proxy`
    部分是我们设置向 Foursquare 发送请求的地方。'
- en: As we mentioned at the start of the chapter, this needs to be a `jsonp` request
    since it is going to another domain. We make our request to [https://api.foursquare.com/v2/venues/search](https://api.foursquare.com/v2/venues/search)
    and we are looking for the `responses.venues` section of the `JSON` array that
    gets returned.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，这需要是一个 `jsonp` 请求，因为它将访问另一个域名。我们向 [https://api.foursquare.com/v2/venues/search](https://api.foursquare.com/v2/venues/search)
    发送请求，并寻找返回的 `JSON` 数组中的 `responses.venues` 部分。
- en: You will note that this store currently has no other parameters to send to Foursquare.
    We will add these later on in the controller before we load the store.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这个商店目前没有其他参数要发送给 Foursquare。我们将在控制器中加载商店之前稍后添加这些参数。
- en: For the model, we can consult the Foursquare API documentation to see the information
    that is returned for a restaurant (called a venue in Foursquare terms) at [https://developer.foursquare.com/docs/responses/venue](https://developer.foursquare.com/docs/responses/venue)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型，我们可以查阅 Foursquare API 文档，以查看返回的餐厅信息（在 Foursquare 术语中称为 venue）[https://developer.foursquare.com/docs/responses/venue](https://developer.foursquare.com/docs/responses/venue)
- en: 'You can include any of the fields listed on the page. For this app, we have
    chosen to include the following code in our model:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以包括页面上的任何字段。对于这个应用程序，我们选择在我们的模型中包含以下代码：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can add more fields if you want to display more information in the details
    view.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在详细视图中显示更多信息，可以添加更多字段。
- en: Creating the details view
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建详细视图
- en: 'The details view is a simple panel and XTemplate combination. Using our controller,
    the panel will receive the data record when a user clicks on a restaurant in the
    list:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息视图是一个简单的面板和 XTemplate 组合。使用我们的控制器，当用户在列表中点击餐厅时，面板将接收到数据记录：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `tpl` tag is basically HTML, you can use any CSS styling you like
    here. Keep in mind that certain fields such as `contact`, `location`, and `categories`
    can have more than one entry. You will need to use `<tpl for="fieldname">` to
    loop through these values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `tpl` 标签基本上是 HTML，你可以在这里使用任何你喜欢的 CSS 样式。请注意，某些字段如 `contact`、`location` 和
    `categories` 可以有多个条目。你需要使用 `<tpl for="fieldname">` 来遍历这些值。
- en: Now that the views are complete, we need to head back to our controller and
    add the functions to put everything together.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视图已经完成，我们需要回到我们的控制器并添加将一切组合起来的函数。
- en: Finishing the main view controller
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成主视图控制器
- en: 'When we started out with our main controller, we added all of our views, stores,
    and references. Now it''s time to add the functionality for the application. We
    start by adding a `control` section to the end of our `config`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用主控制器时，我们添加了所有的视图、存储和引用。现在是我们添加应用程序功能的时候了。我们首先在 `config` 的末尾添加一个 `control`
    部分：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The controls are based on the references in the controller and they add functions
    to specific listeners on the component. These are each in the format of:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 控件基于控制器中的引用，并为组件的特定监听器添加函数。这些函数的格式如下：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once these controls are in place, we can add our functions after the `config`
    section of our controller.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些控件就位，我们可以在控制器的 `config` 部分之后添加我们的函数。
- en: 'Our first function is `doStart`. This function loads our `Contacts` store and
    checks to see if we have any existing contacts. If not, we alert the user and
    offer to let them add some. If they have contacts we create a new instance of
    our `confirmLocation` container and `push` it onto the main navigation view:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数是 `doStart`。这个函数加载我们的 `Contacts` 存储并检查我们是否有任何现有联系人。如果没有，我们提醒用户并建议他们添加一些。如果他们有联系人，我们创建一个新的
    `confirmLocation` 容器实例并将其 `push` 到主导航视图中：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that since the `mainView` is a navigation view, a **Back** button will
    automatically be created in the top toolbar. This function will show the user
    our initial map panel with the users current location.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于 `mainView` 是一个导航视图，**后退** 按钮将自动在顶部工具栏中创建。这个函数将显示用户当前的初始地图面板。
- en: 'This panel needs four functions: one to cancel the request, one to pop up a
    new location window, one to set the new location, and one to move on to the next
    step:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板需要四个函数：一个用于取消请求，一个用于弹出新的位置窗口，一个用于设置新位置，以及一个用于进入下一步：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We actually want to be able to use the `doCancel` function from anywhere in
    the process. As we add new panels to our `mainView` navigation, these panels simply
    pile up in a stack. This means we need to get the number of panels currently on
    the `mainView` stack. We use `length-1` to always leave the initial panel (the
    one with our big **Get Started** button) on the stack. We use `pop` to remove
    all but the first panel from the stack. This way the **Cancel** button will take
    us all the way back to the beginning of our stack, while the **Back** button will
    take us back just to the previous step.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上希望能够在处理过程中的任何地方使用 `doCancel` 函数。当我们向 `mainView` 导航添加新的面板时，这些面板只是简单地堆叠起来。这意味着我们需要获取当前在
    `mainView` 堆栈上的面板数量。我们使用 `length-1` 以确保初始面板（带有我们的大 **Get Started** 按钮的那个）仍然在堆栈上。我们使用
    `pop` 来从堆栈中移除除了第一个面板之外的所有面板。这样，**取消** 按钮将带我们回到堆栈的起点，而 **后退** 按钮将带我们回到上一步。
- en: 'The next function is `doNewLocation()`, which uses `Ext.Msg.prompt` to ask
    the user to enter a new location:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是 `doNewLocation()`，它使用 `Ext.Msg.prompt` 来提示用户输入新位置：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the user enters a new location, we call `setNewLocation` to process the
    text the user entered in the prompt textbox:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了新位置，我们调用 `setNewLocation` 来处理用户在提示文本框中输入的文本：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code gets our map and encodes the text the user passed us as a geocode
    location. If Google returns a valid address, we center the map on the location
    and drop a marker to show the exact location. We also set the latitude and longitude
    so that we can reference them later.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取我们的地图并将用户传递给我们的文本编码为地理编码位置。如果谷歌返回一个有效的地址，我们将地图中心定位在该位置并放置一个标记以显示确切位置。我们还设置了纬度和经度，以便我们以后可以引用它们。
- en: If we fail to get a valid address, we alert the user so they can fix it and
    try again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法获取有效的地址，我们将提醒用户以便他们可以修复并再次尝试。
- en: 'Once the user is happy with the location they can click on the **Next** button,
    which fires our `doChooseFriends` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户对位置满意，他们可以点击 **下一步** 按钮，这将触发我们的 `doChooseFriends` 函数：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function pushes our `friendchooser` view onto the stack for display. The
    `friendchooser` view allows the user to select multiple friends and click on **Cancel**
    or **Finish**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将我们的 `friendchooser` 视图推入堆栈以进行显示。`friendchooser` 视图允许用户选择多个朋友并点击 **取消** 或
    **完成**。
- en: Since we have already taken care of our **Cancel** button with our `doCancel`
    function, we just need to write the `doShowRestaurants` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经用 `doCancel` 函数处理了我们的 **取消** 按钮，我们只需要编写 `doShowRestaurants` 函数。
- en: This function starts by looping through the selected friends. For the first
    one in the list, we grab the restaurant categories we have stored for the friend
    and convert it from a comma-separated list (which is how we stored it) into an
    array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先遍历选定的朋友。对于列表中的第一个，我们获取朋友存储的餐厅类别，并将其从逗号分隔列表（这是我们存储的方式）转换为数组。
- en: 'This lets us grab every subsequent selection and run `Ext.Array.intersect()`
    to find the common categories between all of the selected friends:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够获取每个后续选择，并运行 `Ext.Array.intersect()` 来找到所有选中朋友之间的共同类别：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we load the store based on the common categories by `categoryID`, the
    location data we have stored in our map, `client_id`, and `client_secret` that
    comprise our API key for Foursquare and a `radius` value (in meters).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据 `categoryID` 加载存储，这是我们在地图中存储的位置数据，`client_id` 和 `client_secret`，它们构成了我们的
    Foursquare API 密钥以及一个 `radius` 值（以米为单位）。
- en: We also send a required field called `v` that is set to the current date.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发送一个名为 `v` 的必填字段，其设置为当前日期。
- en: Finally, we push our restaurant list component onto the stack of containers.
    This will display our list of results and allow the user to click on for details.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的餐厅列表组件推入容器堆栈。这将显示我们的结果列表，并允许用户点击查看详情。
- en: 'This brings us to our `doShowRestaurantDetails` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到 `doShowRestaurantDetails` 函数：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the user taps one of the disclosure icons in our list of restaurants, we
    push a `restaurantdetails` view onto the stack of containers and set its data
    to the record that was tapped. This displays the details for the restaurant in
    our details XTemplate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在我们的餐厅列表中点击其中一个展开图标时，我们将 `restaurantdetails` 视图推入容器堆栈，并将其数据设置为被点击的记录。这将在我们的详情
    XTemplate 中显示餐厅的详细信息。
- en: Homework
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'There are a number of additional features that can be added to this type of
    application, including:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向此类应用程序添加许多其他功能，包括：
- en: Editing for contacts (or automatically pulling friends from Facebook)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑联系人（或从 Facebook 自动拉取朋友）
- en: Setting up a live feed for the categories menu
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置类别菜单的实时流
- en: Adding additional venues other than restaurants
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加除餐厅以外的其他场所
- en: Combining the application with additional APIs such as Yelp for reviews
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序与额外的 API（如 Yelp）结合以获取评论
- en: 'Just remember the key requirements of using additional APIs: the API key(s),
    studying the API documentation, and using the JSONP store for grabbing the data.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住使用额外 API 的关键要求：API 密钥、研究 API 文档以及使用 JSONP 存储来获取数据。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we talked about using external APIs to enhance your Sencha
    Touch applications. This included:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用外部 API 来增强您的 Sencha Touch 应用程序。这包括：
- en: An overview of API basics
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 基础概述
- en: Putting together the basic application
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装基本应用程序
- en: Interaction with Google Maps and Foursquare
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Google Maps 和 Foursquare 的交互
- en: Building the views, models, and stores
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建视图、模型和存储
- en: Building the application controller
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序控制器
- en: In the next chapter we will talk about the use of progressive enhancement to
    target sites to a specific device or screen size.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用渐进增强来针对特定设备或屏幕尺寸的网站。
