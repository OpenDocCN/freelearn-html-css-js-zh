- en: '*Chapter 2*: Automated Testing and Test runners'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting
    started with Puppeteer*, we covered the first fundamental pillar of this book:
    browser automation and headless browsers. In this chapter, we are going to cover
    the second pillar: UI testing. We learned that Puppeteer is not just about testing,
    but that doesn''t mean that it''s not an excellent tool for the job.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn the fundamentals of Testing Automation.
    We are going to see the differences between UI Testing and End-to-End testing.
    If you have tried to write tests in Node.js before, you might have come across
    some weird names: Mocha, Jest, Jasmine, AVA, or Chai. That feels quite overwhelming
    if you are not used to these tools. We are going to see which are the right tools
    for us.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Automated Testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test runner main features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available Test runners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first test project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we understand these foundational concepts and we learn how test runners
    work, we will be able to dive deep into the Puppeteer API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter2` directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Automated Testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a fundamental task in software development. Even if you consider
    yourself a bad tester, or even a bad developer, you do some testing when you code
    your app. At the very least, you open the app to see whether it works as expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe you are a little bit more methodical and you have a test plan, at least
    in your mind. You know that when you code a form, you have to validate some common
    scenarios:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Try to save a form with empty fields.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to save with good data.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to enter bad data. You might enter text in numeric fields, invalid dates,
    and so on.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More experienced developers will cover all the possible scenarios. They will
    write code based on those scenarios and then test accordingly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we get to the word that''s driving this book: we **automate** stuff. We
    want to automate our tests. We don''t want to forget any scenarios or have to
    test the same thing over and over.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will notice, I haven''t mentioned **Quality Assurance** (**QA**) analysts
    yet, because I want to highlight that testing is not something relegated to the
    QA team. Those who are involved in the testing process include the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Backend developers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend developers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QA analysts
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managers (product or project managers)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to know that there are different types of tests. Some types of tests
    will be performed by developers and QA analysts. Other tests will be specific
    to either developers or QA analysts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Mike Cohn, in his book *Succeeding with Agile* (Addison-Wesley Professional),
    introduced his very popular Testing Pyramid:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Mike Cohn’s Testing Pyramid'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B16113.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Mike Cohn's Testing Pyramid
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Although Mike's book is more than 10 years old, this pyramid is still valid.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'This pyramid is based on three characteristics:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Number of tests
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have only one thing against this pyramid: the word **UI**. Modern apps rely
    more and more on client code, "UI" code. Frameworks such as React, Angular, and
    Vue.js allow developers to write reusable components. Many apps now have most
    of their business rules running on the client.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Frontend developers should not be limited to the top of this pyramid. They
    should be able to write unit tests and service tests for their UI code. This might
    look like a small change, but I think it''s important. With this change in the
    paradigm, we get a pyramid that looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![New Pyramid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B16113.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: New Pyramid
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding, let's talk about the different levels
    of this pyramid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are the base of the pyramid. The more business logic you cover in
    unit tests, the less ground you will need to cover in service or UI tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the pyramid, unit tests need to be **fast and isolated**. That
    means that a good unit test shouldn't depend on the environment or any other function.
    Sometimes this is easier said than done. For instance, if you want to test that
    the total amount of an invoice is equal to the sum of its items, you should be
    able to test that specific functionality in the code, without launching a web
    server or getting data from a database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: What roles use Unit tests?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Backend developers**: For sure, Unit tests are for them. They follow the
    **Test-Driven Development** (**TDD**) process if possible. TDD is a technique
    in software development where tests are written even before any source code has
    been written. Once the tests have been written, the developer will program the
    source code to make them pass.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend developers**: Writing unit tests was almost impossible in the past.
    If you didn''t have the right tools, you couldn''t do your job correctly. But
    now, many modern libraries support unit testing. If you use React and Redux, you
    will find that Redux has a way to write unit tests for your components (https://www.hardkoded.com/ui-testing-with-puppeteer/redux-unit-tests).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: That's not all. In the same way that backend developers need to think about
    how to make their code testable, if frontend developers, using modern frameworks,
    start creating small and testable components, **they should be able to use Puppeteer
    to write UI unit tests**. And here is where the "UI" at the top of the testing
    pyramid stops making any sense. Now we can write **UI unit tests**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We can run a small test, rendering a component and testing, for instance, that
    it "*renders a textbox and when I enter a value, the label below changes*," or
    "*if I pass a list of 10 items, 10 elements are rendered*."
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*We moved UI testing to the bottom of the testing pyramid.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**QA Analysts** are not involved yet. Unit tests are about testing the internal
    code.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量分析师**目前还没有参与。单元测试是关于测试内部代码的。'
- en: How about **Managers**? If you are a developer, I believe you are going to show
    this paragraph to your boss. Managers won't write unit tests, but they need to
    know the importance of writing unit tests and investing time in them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于**经理**呢？如果你是开发者，我相信你会把这段话展示给你的老板。经理不会编写单元测试，但他们需要知道编写单元测试和投入时间的重要性。
- en: These are the four benefits you (or your boss) need to know about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你（或你的老板）需要了解的四个好处。
- en: Unit tests show how the code works
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试展示了代码的工作方式
- en: Unit tests explain how the code works. When I review code, I start by reviewing
    unit tests. If I find unit tests saying, for instance, "*Create order should send
    email*". I could read that test first, and then, check how that rule was implemented.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试解释了代码的工作方式。当我审查代码时，我首先审查单元测试。如果我发现单元测试写着，例如，“*创建订单应该发送电子邮件*”。我可以先阅读这个测试，然后检查这个规则是如何实现的。
- en: Business Analysts or project managers could read these tests and see whether
    there are any scenarios that haven't been covered or some missing validation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 业务分析师或项目经理可以阅读这些测试，看看是否有任何未覆盖的场景或缺失的验证。
- en: Unit tests make refactoring possible
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试使重构成为可能
- en: I took a risk using the word possible. But I believe that's true. You can't
    refactor your code if you don't have unit tests backing your changes. Remember,
    refactoring is changing the implementation of your code without changing the result
    given specific inputs. Unit tests guarantee that premise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用“可能”这个词是冒了点风险。但我相信这是真的。如果你没有单元测试来支持你的更改，你就不能重构你的代码。记住，重构是在不改变特定输入结果的情况下改变代码的实现。单元测试保证了这一点。
- en: Unit tests prevent regressions
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试防止回归
- en: '**Regression is an involuntary change in the expected behavior of an app**.
    If we have a good set of tests, they will prevent us from breaking any behavior
    of the app while we implement new features or while fixing bugs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**回归是应用程序预期行为的不自觉变化**。如果我们有一套好的测试，它们将防止我们在实现新功能或修复错误时破坏应用程序的任何行为。'
- en: How can I make sure that some other developers won't come and break the precious
    function I just wrote? By writing unit tests. A unit test is a version of you
    in the future enforcing how a piece of code should work. "*Create an order should
    send an email*" – no one will be able to break that rule.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何确保其他开发者不会来破坏我刚刚编写的宝贵功能？通过编写单元测试。单元测试是你未来版本的自己，强制执行代码应该如何工作。“*创建订单应该发送电子邮件*”——没有人能够打破这个规则。
- en: When I review code, changes in unit tests are a red flag to me. I'm not saying
    that unit tests shouldn't change. But if a test changes, there must be an explanation.
    Now, the "*Create and order should send an email*" shows that the sent email count
    is 2\. Is that right? Are we sending another email? Or do we have a regression?
    Pay attention to changes in unit tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我审查代码时，单元测试的变化对我来说是一个红旗。我并不是说单元测试不应该改变。但如果一个测试改变了，必须有解释。现在，“*创建和排序应该发送电子邮件*”显示发送的电子邮件计数为2。这是正确的吗？我们还要发送另一封电子邮件吗？或者我们遇到了回归？请注意单元测试的变化。
- en: Time to go up in the test pyramid.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔上升的时间。
- en: Service tests
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务测试
- en: 'Service tests are also known as **Integration Tests**. These tests will check
    how your code interacts with other components. When we talk about components,
    we are talking about the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 服务测试也被称为**集成测试**。这些测试将检查你的代码如何与其他组件交互。当我们谈论组件时，我们指的是以下内容：
- en: Databases
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Other components in the app
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的其他组件
- en: External services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务
- en: 'Frontend developers would also need to integrate their code with the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者还需要将他们的代码与以下内容集成：
- en: Other UI components
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他UI组件
- en: CSS files
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS文件
- en: REST APIs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API
- en: As we mentioned before, when we go up in the testing pyramid, tests become **slower
    and less stable**. And it's supposed to be like that. You will be connecting to
    a real database or interacting with a real REST API that would use real network
    calls. That would also mean that your tests would expect the environment to respond
    in a certain way. For instance, you would expect the database to have some set
    of data ready to be used, or a REST API to be available.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们上升测试金字塔时，测试会变得**更慢且更不稳定**。这是应该的。你将连接到真实的数据库或与真实的REST API交互，这将使用真实的网络调用。这也意味着你的测试将期望环境以某种方式响应。例如，你期望数据库有一些数据集准备好使用，或者REST
    API可用。
- en: That's why the more tests you have in the unit test layer, the fewer integration
    tests you will need to code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Let's take, for instance, the class that sends an email, could you code an integration
    test for that? Sure. You set up a local email server that would write emails in
    a temp folder, so after creating an order, you could check that folder and see
    whether the email server processed the email your app should have sent. But, as
    you can see, these kinds of orchestrations are harder to code than small unit
    tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need integration tests? Why don't we code unit tests only?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Well, you need to tests your integrations. Your code won't run in isolation.
    If you are testing the backend, you need to see how the database reacts to the
    data you are inserting, or whether a SQL query returns the data you expect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If you are a frontend developer, this is where you would invest most of your
    time, checking how your component interacts on a page or how the HTML being generated
    affects other elements in the DOM. You would need to test how your component is
    being rendered with a real REST endpoint, instead of using a dummy JSON file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: What roles use Integration tests?
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CreateOrder`, I get a new `Order` object. But now, I need to test that when
    I make a `POST` request to `/orders`, an order is created in the database.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend developers** will create tests to check how all the different components
    interact with each other on a page. Again, it''s UI testing down in the testing
    pyramid.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**QA Analysts** will create tests similar to the tests backend and frontend
    developers create but with a different perspective.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*Developers and QA Analysts create the same kinds of tests but with a different
    perspective.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Developers will create tests to back their job, so they can check whether they
    broke anything. And, as we mentioned before, they need tests to be able to refactor
    their code in the future.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '*QA Analysts will create tests to guarantee the application quality to the
    stakeholders.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one interesting type of test that QA Analysts can implement in this
    layer: the **Visual Regression Test**. These tests are used when we want to check
    whether there was any visual change regarding the style of the app. We don''t
    want to check whether there is a button, or whether that button works. We want
    to check whether the button looks like how it was before. How can we achieve that?
    By comparing images. This technique is based on four steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We take a screenshot as a baseline:![Baseline image
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B16113.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Baseline image
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We make a change in the code.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We take another screenshot:![Image after making a change
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B16113.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Image after making a change
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We compare both images:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Differences](img/Figure_2.05_B16113.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Differences
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This type of test can be quite unstable. I bet you have seen that pages sometimes
    "move" when they are loading, so you have to be very sure when the page is ready
    for a screenshot. But it is doable. Another downside is that for every error you
    get, you have to analyze whether the change was a regression (a change made by
    mistake) or we are in the presence of a **new baseline**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The role of **managers** is still important. They need to provide the tools
    and the time for developers to implement the required integration tests. They
    will also help QA Analysts to determine what the integrations to test are.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: And so we come to the top of the pyramid, the **end-to-end** tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might also find these tests referred to as **E2E** tests. The goal of E2E
    tests is to guarantee that an application works as expected through the entire
    workflow. Most applications will have more than one workflow. That would mean
    that it will require a number of E2E tests to cover all the possible workflows
    or scenarios.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a cart app as an example. These could be our tests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Passing a cart object, the `AddToCart` component renders an `AddToCart` component
    renders a "View cart" link if the product is in the array.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Integration tests:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Go to a product page and click "Add to cart." The link changes to "View cart."
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Go to the checkout page. After clicking on the **Checkout** button, it gets
    disabled.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One E2E test testing the cart flow:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Go to a product page, click **Add to cart**, then click on **View cart**.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) You should have got to the checkout page. Click **Checkout**.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) You should have been redirected to the receipt page.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) The receipt should show the product added to the cart.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e) The price should be the product price.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are at the top of the pyramid. That means that these will be the **slowest
    and least stable** tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Why least stable? Check the workflow. Many bad things can happen there. The
    add to cart endpoint might take a little bit more than expected. The scroll to
    the **Checkout** button could have failed for just a few pixels. Your database
    might be in an unexpected state. Maybe your user already purchased that product,
    so the **Add to cart** button is not enabled.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How about roles?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: This is the **QA Analyst's** land. This is where they need to take advantage
    of all the features Puppeteer provides to make reliable tests. But **Developers**
    play an important role, helping the QA team to do their job efficiently. As we
    are going to see in the next chapters, a developer can leave hints so that the
    QA team can find the components they need.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: I hope the picture of the pyramid makes more sense now. We need lots of small
    and isolated unit tests, many integration tests testing our pages, and finally,
    a good set of E2E tests, checking the workflow's health.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: This is the famous testing pyramid, but how do we write a test? Where do we
    write them? How do we run a test?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to know what we need from a test runner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Test runner features
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行器功能
- en: 'What would the world be like without a test runner? Let''s say you don''t know
    what a test runner is, and you want to code a unit test. Would that be possible?
    I think it would. For instance, say we have this small `Cart` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试运行器，世界会是什么样子？假设你不知道什么是测试运行器，而你想编写一个单元测试。这可能吗？我认为是可能的。例如，假设我们有一个小的`Cart`类：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we want to test it, we could run some code like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想测试它，我们可以运行一些像这样的代码：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A test is basically a piece of code testing our code. Will this work? Yes. Is
    this a unit test? Yes. Will this scale? Definitely not. This file will become
    massive and hard to maintain. Keeping track of what has failed would be an impossible
    task. We need a tool to help us scale and to help us keep our tests maintainable.
    We need a test runner.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基本上是一段测试我们代码的代码。这会工作吗？是的。这是一个单元测试吗？是的。它会扩展吗？绝对不会。这个文件将变得巨大且难以维护。跟踪失败的任务将是不可能的。我们需要一个工具来帮助我们扩展，并帮助我们保持测试的可维护性。我们需要一个测试运行器。
- en: Before exploring possible test runners, I would like to review what we would
    expect from a test runner. What are the features we would need in a test runner?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索可能的测试运行器之前，我想回顾一下我们对测试运行器的期望。我们需要在测试运行器中具备哪些功能？
- en: Easy to learn and run
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 易于学习和运行
- en: We have a lot of things to learn. We need to learn Node and React; we even have
    to buy a book about Puppeteer. We want a test runner that is simple and easy to
    use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多东西要学习。我们需要学习Node和React；我们甚至不得不买一本关于Puppeteer的书。我们希望有一个简单易用的测试运行器。
- en: Group tests by functionality
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按功能分组测试
- en: We want to have our tests separated by functionality, component, or workflow.
    Most test runners have a `describe` function that helps us to group tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将测试按功能、组件或工作流程分开。大多数测试运行器都有一个`describe`函数，帮助我们分组测试。
- en: Ignore tests if needed
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如有必要，忽略测试
- en: We want to skip a test if it becomes noisy, but we don't want to remove it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试变得嘈杂，我们希望跳过测试，但我们不想删除它。
- en: Run only one test
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只运行一个测试
- en: Being able to run only one test is extremely important while debugging. Imagine
    you have over 1,000 tests (yes, you are going to have over 1,000 tests). If you
    want to fix only one test, you wouldn't want to run all of them. You would like
    to run only the one you are working on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，能够只运行一个测试非常重要。想象一下，你有超过1,000个测试（是的，你将会有超过1,000个测试）。如果你想修复仅一个测试，你不想运行所有这些测试。你只想运行你正在工作的那个。
- en: Assertions
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言
- en: 'Assertions are essential. An assertion is an expression to check whether the
    program we are testing worked as expected. Do you remember my `console.log` and
    `console.error` to check whether the cart worked as expected? Well, Assertions
    are way better than that. What do we want to check with Assertions? This is a
    possible list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是必不可少的。断言是一个表达式，用于检查我们正在测试的程序是否按预期工作。你还记得我用来检查购物车是否按预期工作的`console.log`和`console.error`吗？嗯，断言比那要好得多。我们想用断言检查什么？这是一个可能的列表：
- en: Whether a value is equal to a test value.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值是否等于测试值。
- en: Whether a value is null or not null.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值是否为null或非null。
- en: Whether a string or a list contains a value. We might have a huge block of text,
    and we only want to check whether it has some string in it, or an item in an array.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串或列表是否包含一个值。我们可能有一个巨大的文本块，我们只想检查它是否包含某些字符串，或者数组中的某个项。
- en: Whether we expected something to fail, because sometimes, we would expect some
    piece of code to fail.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否预期某些东西会失败，因为有时，我们可能会预期某些代码会失败。
- en: Tools to set up and clean up the environment
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置和清理环境的工具
- en: Before starting the tests, we need our application to be in a certain state.
    For instance, in the cart test, we would like to make sure that the customer has
    not already purchased the product before starting the test.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始测试之前，我们需要确保我们的应用程序处于某种状态。例如，在购物车测试中，我们希望在开始测试之前确保客户尚未购买该产品。
- en: There are also technical setups that might need to be performed. In our case,
    we would need to have Puppeteer and a browser ready to be used before each test.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可能需要执行的技术设置。在我们的案例中，我们需要在每个测试之前准备好Puppeteer和浏览器。
- en: Another important concept is that tests should be independent and detached from
    each other. This means that the result of one test must not affect other tests.
    This is why, very often, it is required to clean up after each or all tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是，测试应该是独立的，并且彼此分离。这意味着一个测试的结果不能影响其他测试。这就是为什么，在大多数情况下，需要在每个或所有测试之后进行清理。
- en: Reports
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告
- en: We want to see which tests passed and which tests failed. We would expect a
    test runner to at least show a good report in the terminal. It could be even better
    if we can get results in other formats, such as JSON, XML, or HTML.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: There are many other features we could mention, but these are the most important
    features we need to know about before getting started.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see what the test runners available on the market that can cover the
    features we are requesting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Available test runners
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of tennis racquets. Some racquets give you more control.
    Others give you more power. If you have just started learning how to play tennis,
    you won't feel any difference. You would if you compared a cheap racquet with
    a professional one. But you wouldn't be able to say why one is better than the
    other. You would say that it just *feels better*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: It's the same with test runners. There are test runners that offer some features.
    Other runners offer other features. But what's important for us now is to get
    a test runner that provides us with all the required features to write our automated
    tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to mention is that this book is not about "using Puppeteer
    with X." We are going to pick a test runner after this chapter, but it doesn't
    need to be the test runner for you. The idea is that you can choose what's best
    for you, or what your team is using right now. It is also probable that by the
    time you read this book, a better test runner will have become popular. You should
    be able to apply the concepts you learned from this book to that test runner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: These are the most common test runners in the market today.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the Jest site ([https://jestjs.io/](https://jestjs.io/)), "*Jest
    is a delightful JavaScript Testing Framework with a focus on simplicity*." Pretty
    nice introduction. Facebook maintains this project, and it currently has over
    32,000 stars on GitHub. I'm not saying this is what makes a project a good project,
    but knowing who is behind a project and its level of community support are some
    of the things to take into consideration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Jest has all the features we mentioned before, such as group tests with `describe`,
    and each test is an `it` or `test` function. You can skip tests with `describe.skip`,
    `it.skip`, or `test.skip`. You can run only one test with `describe.only`, `it.only`,
    or `test.only`. You also have `beforeEach`, `afterEach`, `beforeAll`, and `afterAll`,
    to run setup and cleanup code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: It also has some features that differentiate it from other runners. It has a
    **Snapshot** tool. The snapshot tool would process a React component and return
    some kind of DOM representation as JSON, which will allow us to test whether the
    DOM created by the component has changed. Is this a kind of UI test? Sure it is!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider when evaluating a test runner is available plugins.
    For instance, there is a package called **jest-puppeteer**, which helps us integrate
    our tests with Puppeteer. You don't need to use **jest-puppeteer**. It's just
    a helper.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: There is also a package called **jest-image-snapshot**, maintained by American
    Express, which provides a set of tools to perform visual regression tests. In
    this case, if you want to code visual regression tests, I recommend you to use
    one of these packages. Managing all the screenshot baselines can be quite tedious.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocha is another popular framework. It is a community project with over 19,000
    stars. Something worth mentioning is that the Puppeteer team uses Mocha.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Mocha also has functions like Jest. It has a `describe` function to group tests.
    Tests are `it` functions. You can skip functions using `describe.skip` or `it.skip`,
    and use `describe.only` or `it.only` to run only one test. You also have `beforeEach`,
    `afterEach`, `beforeAll`, and `afterAll`, to run setup and cleanup code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: You will also find many plugins for Mocha. You will find **mocha-puppeteer**
    and **mocha-snapshots**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'A recipe you are going to see a lot on the web is Mocha + Chai. **Chai** is
    an assertion library that extends the assertions a test runner provides. It lets
    you express assertions in a pretty specific way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are many other test runners, such as Jasmine by Pivotal Labs with over
    15,000 stars, Karma by the AngularJS team with over 11,000 stars, AVA, a community
    project with over 18,000 stars, and the list goes on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned at the beginning of this section, we just need a good tennis
    racquet, that is, a good test runner. When you become an expert, you will be able
    to move from one test runner to another that fits your needs. For the purpose
    of this book, we are going to use **Mocha + Chai**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first test project
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a Node application in the same way we created our first app
    in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting started
    with Puppeteer*. We are going to create a folder called `OurFirstTestProject`
    (you will find this directory inside the `Chapter2` directory mentioned in the
    *Technical requirements* section) and then execute `npm init -y` inside that folder:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The response should be something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it''s time to install the packages we are going to use:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer 7
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocha (any version)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai (any version)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run the following commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For this first demo, we are going to use the site [https://www.packtpub.com/](https://www.packtpub.com/)
    as a test case. Let's keep our test simple. We want to test that the page title
    says *Packt | Programming Books, eBooks & Videos for Developers.*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The site we are using for this test might have changed over time. Before testing
    this code, go to [https://www.packtpub.com/](https://www.packtpub.com/) and check
    whether the title is still the same. That's why, in the following chapters, we
    will be downloading sites locally, so we avoid these possible issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that we would use `describe` to group our tests. But separating
    tests into different files will also help us to get our code organized. You can
    choose between having one or many `describe` functions per file. Let's create
    a file called `home.tests.js`. We are going to put all tests related to the home
    page there.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Although you can create the files anywhere you want, Mocha grabs all the tests
    in the `test` folder by default, so we will to create the `test` folder and then
    create the `home.test.js` file inside that folder.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to have the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`home.tests.js` with the home tests'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `describe` function with the header tests
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `it` function testing *"Title should have Packt name"*
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another `it` function testing *"Title mention the word Books"*
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure should look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s unpack this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We are importing Puppeteer in line 1.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lines 2 are 3 are about importing the different types of assertion styles `expect`
    is not being called with parentheses whereas `should` is. We don't need to know
    why now. But, just to be clear, that's not a mistake.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How about Mocha? Are we missing Mocha? Well, Mocha is the test runner. It will
    be the executable we will call later in `package.json`. We don't need it in our
    code.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s interesting to see that both `describe` and `it` are just simple functions
    that take two arguments: a string and a function. Can you pass a function as an
    argument? Yes, you can!'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The functions we are passing to the `it` functions are `async`. We can't use
    the `await` keyword in functions that are not marked as `async`. Remember that
    Puppeteer relies a lot on async programming.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to launch a browser and set up everything these tests need to work.
    We could do something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Don't try to learn the Puppeteer API now. We are going to explain how all of
    these commands work in [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will run perfectly. However, there are two things that could do with
    optimization:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: We would be repeating the same code over and over.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If something fails in the middle of the test, the browser won't get closed,
    leaving lots of open browsers.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid these problems, we can use `before`, `after`, `beforeEach`, and `afterEach`.
    If we add these functions to our tests, this would be the execution order:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`before`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it(''Title should have Packt name'')`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it(''Title should mention Books'')`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s not a rule of thumb, but we can do something like this in our case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`before`: Launch the browser.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`beforeEach`: Open a page and navigate to the URL.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`afterEach`: Close the page.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`after`: Close the browser.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These **hooks**, which is what Mocha calls these functions, would look like
    this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One thing to mention here is that we could do what''s called `await` the result
    of `page.close()` or `browser.close()`. So, we could do this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's not something I love doing because if something fails, you would like
    to know where and why. But as this is just cleanup code for a test, it's not production
    code, we can afford that risk.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our test has a browser opened, a page with the URL we want to test read.
    We just need to test the title:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I used two different styles here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, I'm assigning the result of the `title` async function to
    a variable, and then using `should.contain` to check whether the title contains
    the word *"Packt"*. In the second case, I just evaluated `((await page.title())`.
    I added some extra parentheses there for clarification. You won't see them in
    the final example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that in the first case, I''m using the **should**
    style, whereas in the second case, I''m using the **expect** style. The result
    will be the same. It''s just about which style you feel more comfortable with
    or feels more natural to you. There is even a third style: **assert**.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We have everything we need to run our tests. Remember how `npm init` created
    a `package.json` file for us? It''s time to use it. Let''s set the `test` command.
    You should have something like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to tell `npm` to run `npm test`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Time to run our tests! Let''s run `npm test` in the terminal:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we should have our first error:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s bad, but not that bad. Mocha validates by default that our tests should
    take less than 2,000 ms. That sounds OK for an isolated unit test. But UI tests
    might take longer than 2 seconds. That doesn''t mean that UI tests shouldn''t
    have a timeout. `--timeout` command-line argument to the launch setting we set
    up in the `package.config` file. I think 30 seconds could be a reasonable timeout.
    As it expects the value in milliseconds, it should be `30000`. Let''s make that
    change in our `package.config` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The command-line argument is not the only way to set up the timeout. You can
    call `this.Timeout (30000)` inside the `describe` function or configure the timeout
    using a config file ([https://mochajs.org/#configuring-mocha-nodejs](https://mochajs.org/#configuring-mocha-nodejs)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we set up the timeout, we can try our tests again by running `npm test`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Test Result'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B16113.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Test Result
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha not only ran our tests but also printed a pretty decent report. We have
    there all the tests Mocha ran, the final result, and the elapsed time. Here is
    where many test runners offer different options. For instance, Mocha has a `--reporter`
    flag. If you go to https://mochajs.org/, you will see all the available reporters.
    We could use the `list` reporter, which shows the elapsed time of each test. We
    can add it to our `package.config` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this change, we can get a better report:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Test Result using the list reporter'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B16113.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Test Result using the list reporter
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: This project looks fine. If you had only a few tests, this would be enough.
    But if we are going to have lots of tests using many pages, this code won't scale.
    We need to organize our code so that we can be more productive and reuse more
    code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our code
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first test was quite simple: we were just checking the page title. But
    let''s take a look at the home page:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Packtpub home page'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B16113.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Packtpub home page
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many actions we would like to test there:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Search for an existing book.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for a non-existing book.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the cart when it is empty.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the cart when we add a product.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take, for example, *Search tests*. We would be doing the same steps
    every time:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Click on the search box.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the text.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the search button.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We would be doing the same thing over and over in all our search tests. Sometimes
    there is a misconception that, as the test code is not production code, the code
    can be a mess. So, people go and copy/paste their tests over and over, duplicating
    code and hardcoding values. That ends up with hard-to-maintain tests. When tests
    are hard to maintain, they tend to be pushed down the priority list. Developers
    lose, QA analysts lose, and in the end, clients lose.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to see two techniques to improve our test code: the **Page Object
    Model** (**POM**) and the test data config.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Page Object Model
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The POM is a design pattern that will help us separate our test code from the
    implementation of the interaction our tests will perform.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let's build our `HomePageModel` together. What are the possible interactions
    on that page?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Go** (to the page)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get page title**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign In**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Cart**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go to Checkout**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribe**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well done! We just created our first Page Model. This is how it will look:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s focus on the two first functions: the `go` function, which will navigate
    to the home page, and the `title` function, which will return the page title.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse a lot of code here. If we want to start using this model, we
    would need to do two things: implement the title fetching here and pass a Puppeteer
    page to this model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now it''s a matter of importing this class into our tests using `require`.
    I will put this class into a **POM** (**Page Object Model**) folder inside the
    test folder. Once we create the file, we import it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We declare a variable inside the describe:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We create an instance of this class in the `beforeEach` hook:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And now, we simply replace the `page.title` we are using with `homePageModel.title`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As I mentioned earlier in the chapter, UI tests help us see whether our refactoring
    broke our code. Let''s run `npm test` again to confirm that we didn''t break anything:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Test result after the first refactor'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B16113.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Test result after the first refactor
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only one thing left to do so that we can be proud of our first project.
    We need to get rid of our hardcoded values. We only wrote two tests, and we have
    three hardcoded values: the site URL and the `Packt` and the `Books` words.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: For these tests, we can leave these hardcoded values. But what if you have different
    environments? You would need to make the URL dynamic. What if your site were a
    generic e-commerce site? The brand name would depend on the test you are navigating.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other use cases:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Test users and passwords
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product to test
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords to use
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a `config.js` file with all the environment settings and return
    only the one we get on an environment variable. If not set, we return the local
    version:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this looks a little bit scary, don''t worry, it''s not that complex:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns an object with three properties: `local`, `test`, and `prod`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In JavaScript, you can access a property by using `object.property` or by treating
    the object as a dictionary: `object[''local'']`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.env` allows us to read environment variables. We won''t be using environment
    variables in this book, but I wanted to show you the final solution.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we are going to return only the `local`, `test`, or `prod` property
    based on the `TESTENV` variable or `'local'` if the environment variable was not
    set.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I bet that by now, you will know that we will be able to access this object
    using a `require` call:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And from there, start using the `config` variable instead of hardcoded values.
    We would also need to pass this config to the page model because we have a hardcoded
    URL there.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'After making all these changes, this is what our tests should look like:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we remove all the unused functions, our final page model would look like
    this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we didn't need to implement complex design patterns to make
    our tests reusable and easy to maintain. I think it's time to get started with
    our tests, which we will do in [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the foundations of automated testing. Mike
    Cohn's pyramid helped us to understand the different types of tests. We also gave
    this pyramid a new look, showing how it should be used from a Frontend developer
    perspective. We also made it clear that both developers and QA analysts are part
    of this pyramid, but with different perspectives.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we got more practical, and we looked into
    test runners. A learning point here is that we used Mocha as a test runner, but
    everything you learned in this chapter should be possible with any test runner;
    that is, we used Mocha, but we could have used any other test runner.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We use many Puppeteer APIs in our tests. In the next chapter, we are going to
    dive deep into these APIs and see how we can use Puppeteer in different scenarios.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
