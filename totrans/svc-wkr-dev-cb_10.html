<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Improving Performance</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Performing network requests from a cache</li><li class="listitem" style="list-style-type: disc">Performing network requests from a network</li><li class="listitem" style="list-style-type: disc">Testing <code class="literal">waitUntil</code></li><li class="listitem" style="list-style-type: disc">Implementing background sync</li><li class="listitem" style="list-style-type: disc">Sending forward requests</li><li class="listitem" style="list-style-type: disc">Avoiding model fetching and render times</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Introduction</h1></div></div></div><p>In this last chapter, we will explore improving performance with the help of the service worker. Now, we are going to look into the areas around improving network requests from a cache and network, implementing background sync, sending forward requests, and avoiding model fetching and render times.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Performing network requests from a cache</h1></div></div></div><p>If you are a regular visitor to a certain website, chances are that you may be loading most of the resources such as CSS and JavaScript files from your cache rather than the server itself. This saves us necessary bandwidth for the server as well as requests over the network. Having control over which content we deliver from the cache and server is a great advantage. The server worker provides us this powerful feature by giving us programmatic control over the content. In this recipe, we are going to look at the methods that enable us to do so by creating a performance art event viewer web app.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec196"/>Getting ready</h2></div></div></div><p>To get<a id="id440" class="indexterm"/> started with service workers, you will<a id="id441" class="indexterm"/> need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <em>Setting up service workers</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec197"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure.</p><div><ol class="orderedlist arabic"><li class="listitem">Download files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/01/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/01/</a>
</p></li><li class="listitem">Open a browser and go to <code class="literal">index.html</code>.<div><img src="img/B05381_10_01.jpg" alt="How to do it..."/></div></li><li class="listitem">First we will request data from the network with the cache enabled. Click on the <strong>FETCH</strong> button.<div><img src="img/B05381_10_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Now we<a id="id442" class="indexterm"/> are going to select the <a id="id443" class="indexterm"/><strong>Disabled</strong> checkbox under the <strong>SOURCE</strong> label and click on the <strong>FETCH</strong> button again in order to fetch data only from the cache. An error will be shown on the page. Since the cache is disabled, data cannot be fetched.<div><img src="img/B05381_10_03.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec198"/>How it works...</h2></div></div></div><p>In <a id="id444" class="indexterm"/>the <code class="literal">index.js</code> file, we will set a page-specific<a id="id445" class="indexterm"/> name for the cache as the caches are per origin-based and no other page should use the same cache name.</p><div><pre class="programlisting">var CACHE_NAME = cache-only';</pre></div><p>If you inspect the <strong>Resources</strong> tab of the development tools, you can find the cache inside <strong>Cache Storage</strong>.</p><div><img src="img/B05381_10_04.jpg" alt="How it works..."/></div><p>We will store the elapsed time for the cache in variables.</p><div><pre class="programlisting">var cacheFetchStartTime;</pre></div><p>The source URL, for example, points to a file location in GitHub via RawGit.</p><div><pre class="programlisting">var SOURCE_URL = 'https://cdn.rawgit.com/szaranger/szaranger.github.io/master/service-workers/10/01/events';</pre></div><p>If you <a id="id446" class="indexterm"/>want to set up your own source URL, you can<a id="id447" class="indexterm"/> easily do so by creating a gist or a repository in GitHub and creating a file with your data in the JSON format (you don't need the <code class="literal">.json</code> extension). Once you've done that, copy the URL of the file and head over to <a class="ulink" href="https://rawgit.com">https://rawgit.com</a>. </p><p>Paste the link there to obtain another link with a content type header as shown in the following screenshot:</p><div><img src="img/B05381_10_05.jpg" alt="How it works..."/></div><p>Between the time we click on the fetch button and all the data being received, we have to make sure that the user doesn't either change the criteria for searching or click on the fetch button again. To handle this situation, we will disable the controls.</p><div><pre class="programlisting">function clear() {
  outlet.textContent = '';
  cacheStatus.textContent = '';
}

function disableEdit(enable) {
  fetchButton.disabled = enable;
  cacheDelayText.disabled = enable;
  cacheDisabledCheckbox.disabled = enable;

  if(!enable) {
    clear();
  }
}</pre></div><p>The<a id="id448" class="indexterm"/> returned data <a id="id449" class="indexterm"/>will be rendered to the screen in rows.</p><div><pre class="programlisting">function displayEvents(events) {

  events.forEach(function(event) {
    var tickets = event.ticket ?
      '&lt;a href="' + event.ticket + '" class="tickets"&gt;Tickets&lt;/a&gt;' : '';

    outlet.innerHTML = outlet.innerHTML +
      '&lt;article&gt;' +
      '&lt;span class="date"&gt;' + formatDate(event.date) + '&lt;/span&gt;' +
      ' &lt;span class="title"&gt;' + event.title + '&lt;/span&gt;' +
      ' &lt;span class="venue"&gt; - ' + event.venue + '&lt;/span&gt; ' +
      tickets +
      '&lt;/article&gt;';
  });

}</pre></div><p>Each item of the <code class="literal">events</code> array will be printed to the screen as rows.</p><div><img src="img/B05381_10_06.jpg" alt="How it works..."/></div><p>The <code class="literal">handleFetchComplete</code> function is the callback for the cache.</p><p>Because request bodies can only be read once, we have to clone the response.</p><div><pre class="programlisting">cloned = response.clone();</pre></div><p>We will place the cloned response in the cache using <code class="literal">cache.put</code> as a key value pair. This helps subsequent cache fetches to find this updated data.</p><div><pre class="programlisting">caches.open(CACHE_NAME).then(function(cache) {
   cache.put(SOURCE_URL, cloned); // cache.put(URL, response)
});</pre></div><p>Now we will read the response in the JSON format.</p><div><pre class="programlisting">response.json().then(function(data) {
    displayEvents(data);
});</pre></div><p>When the user clicks on the fetch button, we will make nearly simultaneous requests from the cache for data. This would happen on a page load in a real-world application instead of as a result of a user action.</p><div><pre class="programlisting">fetchButton.addEventListener('click', function handleClick() {
...
}</pre></div><p>To<a id="id450" class="indexterm"/> simulate cache delays, we wait before calling the<a id="id451" class="indexterm"/> cache fetch callback. In case the callback errors out, we will make sure that we reject <code class="literal">Promise</code> we got from the original call to match.</p><div><pre class="programlisting">return new Promise(function(resolve, reject) {
        setTimeout(function() {
          try {
            handleCacheFetchComplete(response);
            resolve();
          } catch (err) {
            reject(err);
          }
        }, cacheDelay);
});</pre></div><p>The <code class="literal">formatDate</code> function is a helper function for us to convert the date format we receive in the response into a much more readable format on the screen.</p><div><pre class="programlisting">function formatDate(date) {
  var d = new Date(date),
      month = (d.getMonth() + 1).toString(),
      day = d.getDate().toString(),
      year = d.getFullYear();
  if (month.length &lt; 2) month = '0' + month;
  if (day.length &lt; 2) day = '0' + day;

  return [month, day, year].join('-');
}</pre></div><p>If you <a id="id452" class="indexterm"/>prefer a different date format, you can shuffle the <a id="id453" class="indexterm"/>position of the array in the return statement to your preferred format.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec199"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Showing cached content first </em>recipe in <a class="link" href="ch03.html" title="Chapter 3. Accessing Offline Content">Chapter 3</a>, <em>Accessing Offline Content</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Performing network requests from a network</h1></div></div></div><p>In the previous recipe, we<a id="id454" class="indexterm"/> looked at how we can fetch requests from the cache. In this recipe, we are going to demonstrate how we can fetch requests from the server/network using the service worker. To demonstrate network fetch, we are going to build an interface similar to the previous recipe, but catered to show network interactions.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec200"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>, <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec201"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">Download files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/02/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/02/</a>
</p></li><li class="listitem">Open a browser and go to <code class="literal">index.html</code>.<div><img src="img/B05381_10_07.jpg" alt="How to do it..."/></div></li><li class="listitem">First, we will <a id="id455" class="indexterm"/>request data from the network with the cache enabled. Click on the <strong>FETCH</strong> button.<div><img src="img/B05381_10_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Now we are<a id="id456" class="indexterm"/> going to select the <strong>Disabled</strong> checkbox under the <strong>SOURCE</strong> label and click on the <strong>FETCH</strong> button again in order to fetch data only from the cache. An error will be shown on the page. Since the cache is disabled, data cannot be fetched.<div><img src="img/B05381_10_09.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec202"/>How it works...</h2></div></div></div><p>In the <code class="literal">index.js</code> file, we<a id="id457" class="indexterm"/> will set a page-specific name for the cache as the caches are per origin-based and no other page should use the same cache name.</p><div><pre class="programlisting">var CACHE_NAME = 'network-only';</pre></div><p>If you inspect the <strong>Resources</strong> tab of the development tools, you can find the cache inside <strong>Cache Storage</strong>.</p><p>We will store the elapsed time for both networks in variables.</p><div><pre class="programlisting">var networkFetchStartTime;</pre></div><p>The source URL, for example, points to a file location in GitHub via RawGit.</p><div><pre class="programlisting">var SOURCE_URL = 'https://cdn.rawgit.com/szaranger/szaranger.github.io/master/service-workers/10/02/events';</pre></div><p>If you want to set up your own source URL, you can easily do so by creating a gist or a repository in GitHub and creating a file with your data in the JSON format (you don't need the <code class="literal">.json</code> extension). Once you've done that, copy the URL of the file and head over to <a class="ulink" href="https://rawgit.com">https://rawgit.com</a>. Paste the link there to obtain a another link with a content type header as shown in the following screenshot:</p><div><img src="img/B05381_10_10.jpg" alt="How it works..."/></div><p>Between the time<a id="id458" class="indexterm"/> we click on the fetch button and all the data being received, we have to make sure that the user doesn't either change the criteria for searching or click on the fetch button again. To handle this situation, we will disable the controls.</p><div><pre class="programlisting">function clear() {
  outlet.textContent = '';
  networkStatus.textContent = '';
  networkDataReceived = false;
}

function disableEdit(enable) {
  fetchButton.disabled = enable;
  networkDelayText.disabled = enable;
  networkDisabledCheckbox.disabled = enable;

  if(!enable) {
    clear();
  }
}</pre></div><p>The returned data will be rendered to the screen in rows.</p><div><pre class="programlisting">function displayEvents(events) {

  events.forEach(function(event) {
    var tickets = event.ticket ?
      '&lt;a href="' + event.ticket + '" class="tickets"&gt;Tickets&lt;/a&gt;' : '';

    outlet.innerHTML = outlet.innerHTML +
      '&lt;article&gt;' +
      '&lt;span class="date"&gt;' + formatDate(event.date) + '&lt;/span&gt;' +
      ' &lt;span class="title"&gt;' + event.title + '&lt;/span&gt;' +
      ' &lt;span class="venue"&gt; - ' + event.venue + '&lt;/span&gt; ' +
      tickets +
      '&lt;/article&gt;';
  });

}</pre></div><p>Each item of the <code class="literal">events</code> array will be printed to the screen as rows.</p><div><img src="img/B05381_10_11.jpg" alt="How it works..."/></div><p>The <code class="literal">handleFetchComplete</code> function is the callback for both the cache and network.</p><p>If the <strong>Disabled</strong> <a id="id459" class="indexterm"/>checkbox is checked we will simulate a network error by throwing an error.</p><div><pre class="programlisting">var shouldNetworkError = networkDisabledCheckbox.checked,
    cloned;

  if (shouldNetworkError) {
    throw new Error('Network error');
  }</pre></div><p>Because request bodies can only be read once, we have to clone the response.</p><div><pre class="programlisting">cloned = response.clone();</pre></div><p>Now we will read the response in the JSON format.</p><div><pre class="programlisting">response.json().then(function(data) {
    displayEvents(data);
    networkDataReceived = true;
});</pre></div><p>When the user clicks on the fetch button, we will make nearly simultaneous requests from the network and the cache for data. This would happen on a page load in a real-world application instead of as the result of a user action.</p><div><pre class="programlisting">fetchButton.addEventListener('click', function handleClick() {
...
}</pre></div><p>We will start with disabling any user input while the network fetch requests are initiated.</p><div><pre class="programlisting">disableEdit(true);

networkStatus.textContent = 'Fetching events...';
networkFetchStartTime = Date.now();</pre></div><p>We will request data with the fetch API with a cache-busting URL as well as a no-cache option in order to support Firefox, which hasn't implemented the caching options yet.</p><div><pre class="programlisting">networkFetch = fetch(SOURCE_URL + '?cacheBuster=' + now, {
   mode: 'cors',
   cache: 'no-cache',
   headers: headers
})</pre></div><p>In order to <a id="id460" class="indexterm"/>simulate network delays, we wait before calling the network fetch callback. In situations where the callback errors out, we have to make sure that we reject <code class="literal">Promise</code> we received from the original fetch.</p><div><pre class="programlisting">return new Promise(function(resolve, reject) {
      setTimeout(function() {
        try {
          handleFetchComplete(response);
          resolve();
        } catch (err) {
          reject(err);
        }
      }, networkDelay);
});</pre></div><p>The <code class="literal">formatDate</code> function is a helper function for us to convert the date format we receive in the response into a much more readable format on the screen.</p><div><pre class="programlisting">function formatDate(date) {
  var d = new Date(date),
      month = (d.getMonth() + 1).toString(),
      day = d.getDate().toString(),
      year = d.getFullYear();

  if (month.length &lt; 2) month = '0' + month;
  if (day.length &lt; 2) day = '0' + day;

  return [month, day, year].join('-');
}</pre></div><p>If you prefer a <a id="id461" class="indexterm"/>different date format, you can shuffle the position of the array in the return statement to your preferred format.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec203"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Showing cached content first </em>recipe in <a class="link" href="ch03.html" title="Chapter 3. Accessing Offline Content">Chapter 3</a>, <em>Accessing Offline Content</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Testing waitUntil</h1></div></div></div><p>In this recipe, we are going to use the service worker to test the <code class="literal">waitUntil</code> method, which will delay the install method of the service worker life cycle until the process of opening caches and saving a page to the cache.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec204"/>Getting ready</h2></div></div></div><p>To get started with service <a id="id462" class="indexterm"/>workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <em>Setting up service workers</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec205"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">Download files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/03/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/03/</a>
</p></li><li class="listitem">Open a browser and go to <code class="literal">index.html</code>. You will see the <strong>Registration status: successful</strong> message.<div><img src="img/B05381_10_12.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open <a id="id463" class="indexterm"/>DevTools (<em>Cmd</em> + <em>Alt</em> + <em>I</em> or <em>F12</em>), go to the <strong>Network</strong> tab, click on the dropdown displaying <strong>No Throttling</strong>, and select <strong>Offline</strong>.<div><img src="img/B05381_10_13.jpg" alt="How to do it..."/></div></li><li class="listitem">Now refresh your bowser, and you will see the offline message and the image.<div><img src="img/B05381_10_14.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec206"/>How it works...</h2></div></div></div><p>The <code class="literal">waitUntil</code> event <a id="id464" class="indexterm"/>extends the lifetime of the install event until all the caches are populated. In other words, it delays treating the installing worker as installed until all the resources we specify are cached and the passed promise resolves successfully.</p><p>We saw an HTML and an image file getting cached and then retrieved when our website was offline. We can cache other resources as well, including CSS and JavaScript files.</p><div><pre class="programlisting">caches.open(currentCache.offline)
.then(function(cache) {
        return cache.addAll([
              'offline.html',
              '/assets/css/style.css',
              '/assets/js/index.js'
            ]);
        })
);</pre></div><p>When the registration is successful, we will instruct the service worker to intercept a request and provide resources from the cached content using the fetch event.</p><p>Inside the <code class="literal">index.html</code> file, when the registration is successful, we will inspect the state of the registration and print it to the browser. Otherwise, we will print the error message returned by the service worker.</p><div><pre class="programlisting">navigator.serviceWorker.register(
      'service-worker.js',
      { scope: './' }
   ).then(function(serviceWorker) {
      document.getElementById('status').innerHTML = 
          'successful';
   }).catch(function(error) {
      document.getElementById('status').innerHTML = error;
});</pre></div><p>The service worker script file will intercept network requests, check for connectivity, and provide the content for the user.</p><p>We will add an<a id="id465" class="indexterm"/> event listener to the install event, and inside the callback we will fire a request to get this offline page with its resources, which gets added to the cache when the result is successful.</p><div><pre class="programlisting">self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(currentCache.offline)
    .then(function(cache) {
         return cache.addAll([
        offlineUrl
          ]);
          })
    );
});</pre></div><p>Now we can retrieve this page whenever we need to, because the offline page is stored in the cache. We need to add the logic to return the offline page if we don't have connectivity in the same service worker.</p><div><pre class="programlisting">self.addEventListener('fetch', function(event) {
  var request = event.request,
    isRequestMethodGET = request.method === 'GET';

  if (request.mode === 'navigate' || isRequestMethodGET) {
    event.respondWith(
      fetch(createRequestWithCacheBusting(request.url)).catch(function(error) {
        console.log('OFFLINE: Returning offline page.', error);
        return caches.match(offlineUrl);
      })
    );
  } else {
    event.respondWith(caches.match(request)
        .then(function (response) {
        return response || fetch(request);
      })
    );
  }
});</pre></div><p>We are listening <a id="id466" class="indexterm"/>out for the fetch event in the preceding source code, and we simply return the offline page from the cache if we detect that the user is trying to navigate to another page, resulting in an error. Now we have our offline page working.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Implementing background sync</h1></div></div></div><p>The background<a id="id467" class="indexterm"/> synchronization feature of the service worker is responsible for managing background synchronization processes. This feature, as of writing this book, is still nonstandard and you should avoid using it in the production.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec207"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <em>Setting up service workers</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the <em>Setting up GitHub pages for SSL</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec208"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/04/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/04/</a>
</p></li><li class="listitem">Open a browser and go to <code class="literal">index.html</code>.<div><img src="img/B05381_10_15.jpg" alt="How to do it..."/></div></li><li class="listitem">Click on the <a id="id468" class="indexterm"/><strong>Register Background Sync</strong> button. A message will appear at the bottom displaying <strong>Sync registered</strong>.<div><img src="img/B05381_10_16.jpg" alt="How to do it..."/></div></li><li class="listitem">A notification message will also appear on the screen.<div><img src="img/B05381_10_17.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec209"/>How it works...</h2></div></div></div><p>In our <code class="literal">index.html</code> file, we <a id="id469" class="indexterm"/>will add a section for the button and the message.</p><div><pre class="programlisting">  &lt;section&gt;
    &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;button id="register"&gt;Register Background Sync&lt;/button&gt;
    &lt;div id="console"&gt;&lt;/div&gt;
  &lt;/section&gt;</pre></div><p>We will handle the button click in the <code class="literal">index.js</code> file. Notifications need permissions, so we will handle that here as well.</p><div><pre class="programlisting">document.getElementById('register').addEventListener('click', function(event) {
      event.preventDefault();

      new Promise(function(resolve, reject) {
        Notification.requestPermission(function(result) {
          if (result !== 'granted') {
            return reject(Error('Notification permission denied'));
          }
          resolve();
        })
      }).then(function() {
        return navigator.serviceWorker.ready;
      }).then(function(reg) {
        return reg.sync.register('syncTest');
      }).then(function() {
        print('Sync registered');
      }).catch(function(err) {
        print('It broke');
        print(err.message);
      });
});</pre></div><p>Our <code class="literal">service-worker.js</code> file is <a id="id470" class="indexterm"/>fairly simple. We show the notification when the sync event handler is called.</p><div><pre class="programlisting">self.addEventListener('sync', function(event) {
  self.registration.showNotification('Sync\'d');
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Sending forward requests</h1></div></div></div><p>In this recipe, we are <a id="id471" class="indexterm"/>going to implement a service worker that sends forward requests. Request forwarding is helpful when you want to temporarily forward a request to a different resource.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec210"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>, <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec211"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">Download all the files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/05/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/05/</a>
</p></li><li class="listitem">Open a browser and go to <code class="literal">index.html</code>.<div><img src="img/B05381_10_18.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open <a id="id472" class="indexterm"/>DevTools (<em>Cmd</em> + <em>Alt</em> + <em>I</em> or <em>F12</em>) to see the log messages on the <strong>Console</strong> tab. A forward message will appear in a second.<div><img src="img/B05381_10_19.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec212"/>How it works...</h2></div></div></div><p>We will add a <code class="literal">div</code> element<a id="id473" class="indexterm"/> to the <code class="literal">index.html</code> file where we are planning to log a message.</p><div><pre class="programlisting">&lt;section&gt;
     &lt;div id="console"&gt;&lt;/div&gt;
&lt;/section&gt;</pre></div><p>We will handle the <code class="literal">active</code> and <code class="literal">fetch</code> events inside the <code class="literal">service-worker.js</code> file.</p><div><pre class="programlisting">self.addEventListener('activate', _ =&gt; {
  clients.claim();
});

self.addEventListener('fetch', event =&gt; {
  console.log(event.request);
  event.respondWith(fetch(event.request));
});</pre></div><p>The helper function <a id="id474" class="indexterm"/>for logging messages to the screen is in the <code class="literal">index.js</code> file.</p><div><pre class="programlisting">var consoleEl = document.getElementById('console');

function print(message) {
  var p = document.createElement('p');

  p.textContent = message;
  consoleEl.appendChild(p);
  console.log(message);
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec79"/>Avoiding model fetching and render times</h1></div></div></div><p>In order to avoid model <a id="id475" class="indexterm"/>fetching and render times upon successive requests, a <a id="id476" class="indexterm"/>cache containing the interpolated templates in order is saved, which we call as a render <strong>store</strong>.</p><p>According to Mozilla, the render store is intended to save/restore a serialized version of a particular view, mostly for the purpose of performance.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec213"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <em>Setting up service workers</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the <em>Setting up GitHub pages for SSL</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <em>Learning Service Worker Basics</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec214"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">Download files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/06/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/10/06/</a>
</p></li><li class="listitem">Open a <a id="id477" class="indexterm"/>browser and go to <code class="literal">index.html</code>.<div><img src="img/B05381_10_20.jpg" alt="How to do it..."/></div></li><li class="listitem">Click on any<a id="id478" class="indexterm"/> link in the list to go to the store.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec215"/>How it works...</h2></div></div></div><p>At the beginning of<a id="id479" class="indexterm"/> the <code class="literal">index.js</code> file, we specify the Pokemon API endpoint<a id="id480" class="indexterm"/> as well as a secure origin.</p><div><pre class="programlisting">var proxy = 'https://crossorigin.me/';
var pokedex = proxy + 'http://pokeapi.co/api/v1/pokedex/1/';
…</pre></div><p>Next, fetch the Pokemon list from <code class="literal">pokedex</code> and create a list of links.</p><div><pre class="programlisting">function fetchPokemonList() {
  fetch(pokedex)
    .then(function(response) {
      return response.json();
    })
    .then(function(info) {
      populatePokemonList(info.pokemon);

      if (window.parent !== window) {
        window.parent.document.body
          .dispatchEvent(new CustomEvent('iframeresize'));
      }
    });
}</pre></div><p>Subsequently, populate the list and create the links for the Pokemon list. These links will be intercepted by the service worker.</p><div><pre class="programlisting">function populatePokemonList(pokemonList) {
  var el = document.querySelector('#pokemon');
  var buffer = pokemonList.map(function(pokemon) {
    var tokens = pokemon.resource_uri.split('/');
    var id = tokens[tokens.length - 2];
    return '&lt;li&gt;&lt;a href="pokemon.html?id=' + id + '"&gt;' + pokemon.name +
           '&lt;/a&gt;&lt;/li&gt;';
  });
  el.innerHTML = buffer.join('\n');
} </pre></div><p>Next, let's look at<a id="id481" class="indexterm"/> the <code class="literal">service-worker.js</code> file. It tries to recover a cached<a id="id482" class="indexterm"/> copy of the document. If not found, it responds from the network.</p><div><pre class="programlisting">function getResponse(request) {
  return self.caches.open('render-store').then(function(cache) {
    return cache.match(request).then(function(match) {
      return match || fetch(request);
    });
  });
}</pre></div><p>The <code class="literal">cacheResponseInRenderStore</code> function gets the interpolated HTML contents of a <code class="literal">PUT</code> request from <code class="literal">pokemon.js</code> and creates an HTML response for the interpolated result.</p><div><pre class="programlisting">function cacheResponseInRenderStore(request) {
  return request.text().then(function(contents) {
    var headers = { 'Content-Type': 'text/html' };
    var response = new Response(contents, { headers: headers });

    return self.caches.open('render-store').then(function(cache) {
      return cache.put(request.referrer, response);
    });
  });
}</pre></div><p>In the <code class="literal">pokemon.js</code> file, we initialize timers to start with.</p><div><pre class="programlisting">var startTime = performance.now();
var interpolationTime = 0;
var fetchingModelTime = 0;</pre></div><p>We are going to create a <a id="id483" class="indexterm"/>template for a Pokemon, which is responsible for<a id="id484" class="indexterm"/> rendering by obtaining data requested from the URL's query string. This template will fetch the given Pokemon and fill the template. Once the template has been filled, we will mark the document as cached and then we will send it to the render store by sending the contents to the service worker.</p><div><pre class="programlisting">if (document.documentElement.dataset.cached) {
  logTime();
} else {
  var pokemonId = window.location.search.split('=')[1];
  
  getPokemon(pokemonId).then(fillCharSheet).then(logTime).then(cache);
}

function getPokemon(id) {
  var fetchingModelStart = getStartTime();

  return fetch(getURL(id)).then(function(response) {
    fetchingModelTime = getStartTime() - fetchingModelStart;
    return response.json();
  });
}</pre></div><p>Next, we mark the documents as cached, get all the HTML content, and send it to the service worker using a <code class="literal">PUT</code> request into the <code class="literal">./render-store/</code> URL.</p><div><pre class="programlisting">function interpolateTemplate(template, pokemon) {
  var interpolationStart = performance.now();
  var result = template.replace(/{{(\w+)}}/g, function(match, field) {
    return pokemon[field];
  });
  interpolationTime = performance.now() - interpolationStart;
  return result;
}</pre></div></div></div></body></html>