<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Routing and State Management"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Routing and State Management</h1></div></div></div><p class="calibre7">In this chapter, we will learn URL-based state management in Ember.js, which constitutes <span class="strong"><strong class="calibre8">routing</strong></span>. Routing<a id="id74" class="calibre1"/> enables us to translate different states in our applications into URLs and vice-versa. It is a key concept in Ember.js that enables developers to easily separate application logic. It also enables users to link back to content in the application via the usual HTTP URLs. That being said, by the end of this chapter, we should be able to accomplish the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create a router</li><li class="listitem">Define resources and routes</li><li class="listitem">Define a route's model</li><li class="listitem">Perform a redirect</li><li class="listitem">Accomplish asynchronous routing</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Routing and State Management">
<div class="book" title="Creating the application's router"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec23" class="calibre1"/>Creating the application's router</h1></div></div></div><p class="calibre7">We all know <a id="id75" class="calibre1"/>that in traditional web development, every request is linked by a URL that enables the server make a decision on the incoming request. Typical actions include sending back a resource file or JSON payload, redirecting the request to a different resource, or sending back an error response such as in the case of unauthorized access.</p><p class="calibre7">Ember.js strives to preserve these ideas in the browser environment by enabling association between these URLs and state of the application. The main component that manages these states is the application router. As mentioned in the introductory section, it is responsible for restoring an application to a state matching the given URL. It also enables the user to navigate between the application's history as expected. The router is automatically created on application initialization and can be referenced as <code class="email">MyApplicationNamespace.Router</code>. Before we proceed, we will be using the bundled chapter sample to better understand this extremely convenient component. The sample is a simple implementation of the Contacts OS X application as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Creating the application's router" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">It enables<a id="id76" class="calibre1"/> users to add new contacts as well as edit and delete existing ones. For simplicity, we won't support avatars, but that could be an implementation exercise for the reader at the end of the chapter.</p><p class="calibre7">We already mentioned some of the states in which this application can transition into. These states have to be registered in the same way server-side frameworks have URL dispatchers that backend programmers use to map URL patters to views. The chapter sample already illustrates how these possible states are defined:</p><div class="informalexample"><pre class="programlisting">// app.js

var App = Ember.Application.create();

App.Router.map(function() {
  this.resource('contacts', function(){
    this.route('new');
    this.resource('contact', {path: '/:contact_id'}, function(){
      this.route('edit');
    });
  });
  this.route('about');
});</pre></div><p class="calibre7">Notice that the<a id="id77" class="calibre1"/> already instantiated router was referenced as <code class="email">App.Router</code>. Calling its <code class="email">map</code> method gives the application an opportunity to register its possible states. In addition, two other methods are used to classify these states into <span class="strong"><em class="calibre9">routes</em></span> and <span class="strong"><em class="calibre9">resources</em></span>.</p></div></div>
<div class="book" title="Mapping URLs to routes"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Mapping URLs to routes</h1></div></div></div><p class="calibre7">When<a id="id78" class="calibre1"/> defining routes and resources, we are essentially mapping URLs to <a id="id79" class="calibre1"/>possible states in our application. As shown in the first code snippet, the router's <code class="email">map</code> function takes a function as its only argument. Inside this function, we may define a resource using the corresponding method, which takes the following signature:</p><div class="informalexample"><pre class="programlisting">this.resource(resourceName, options, function);</pre></div><p class="calibre7">The first argument specifies the name of the resource and coincidentally, the path to match the request URL. The next argument is optional and holds configurations that we may need to specify, as we shall see later. The last one is a function that is used to define the routes of that particular resource. For example, the first defined resource in the samples says, let the <code class="email">contacts</code> resource handle any requests whose URL starts with <code class="email">/contacts</code>. It also specifies one route, <code class="email">new</code>, that is used to handle the creation of new contacts. Routes on the other hand, accept the same arguments for the function argument.</p><p class="calibre7">You must be asking yourself, "So how are routes different from resources?" The two are essentially the same, other than the former offers a way to categorize states (routes) that perform actions on a specific entity. We can think of an Ember.js application as a tree, composed of a trunk (the router), branches (resources), and leaves (routes). For example, the <code class="email">contact</code> state (a resource) caters for a specific contact. This resource can be displayed in two modes: read and write; hence, the <code class="email">index</code> and <code class="email">edit</code> routes respectively, as shown:</p><div class="informalexample"><pre class="programlisting">this.resource('contact', {path: '/:contact_id'}, function(){
   this.route('index'); // auto defined
   this.route('edit');
});</pre></div><p class="calibre7">Because Ember.js encourages convention, there are two components of routes and resources that are always autodefined:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A default application resource: This is the master resource into which all other resources are defined. We therefore do not need to define it in the router. It's not <a id="id80" class="calibre1"/>mandatory to define resources on <a id="id81" class="calibre1"/>every state. For example, our <code class="email">about</code> state is a route because it only needs to display static content to the user. It can however be thought to be a route of the already autodefined application resource.</li><li class="listitem">A default <code class="email">index</code> route on every resource: Again, every resource has a default index route. It's autodefined because an application cannot settle on a resource state. The application therefore uses this route if no other route within this same resource was intended to be used.</li></ul></div></div>
<div class="book" title="Nesting resources"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Nesting resources</h1></div></div></div><p class="calibre7">Resources<a id="id82" class="calibre1"/> can be nested depending on the architecture of the application. In our case, we need to load contacts in the sidebar before displaying any of them to the user. Therefore, we need to define the contact resource inside the contacts. On the other hand, in an application such as Twitter, it won't make sense to define a <code class="email">tweet</code> resource embedded inside a <code class="email">tweets</code> resource because an extra overhead will be incurred when a user just wants to view a single tweet linked from an external application.</p></div>
<div class="book" title="Understanding the state transition cycle"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Understanding the state transition cycle</h1></div></div></div><p class="calibre7">A request <a id="id83" class="calibre1"/>is handled in the same way water travels from the roots (the application), up the trunk, and is eventually lost off leaves. This request we are referring to is a change in the browser location that can be triggered in a number of ways, as we shall discover more in the next chapter.</p><p class="calibre7">Before we proceed into finer details about routes, let's discuss what happened when the application was first loaded. On boot, a few things happened as outlined:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The application first transitioned into the application state, then the index state.</li><li class="listitem">Next, the application index route redirected the request to the contacts resource.</li><li class="listitem">Our application uses the browser's local storage to store the contacts and so for demoing purposes, the contacts resource populated this store with fixtures (located at <code class="email">fixtures.js</code>).</li><li class="listitem">The application then transitioned into the corresponding contacts resource index route, <code class="email">contacts.index</code>.</li><li class="listitem">Again, here <a id="id84" class="calibre1"/>we made a few decisions based on whether our store contained any data. Since we indeed have data, we redirected the application into the contact resource, passing the ID of the first contact along.</li><li class="listitem">Just as in the two preceding resources, the application transitioned from this last resource into the corresponding index route, <code class="email">contact.index</code>.</li></ul></div><p class="calibre7">The following figure gives a good view of the preceding state change:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Understanding the state transition cycle" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="Configuring the router"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Configuring the router</h1></div></div></div><p class="calibre7">The router <a id="id85" class="calibre1"/>can be customized in the following ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Logging state transitions</li><li class="listitem">Specifying the root app URL</li><li class="listitem">Changing browser location lookup method</li></ul></div><p class="calibre7">During development, it may be necessary to track the states into which the application transitions. Enabling these logs is as simple as:</p><div class="informalexample"><pre class="programlisting">var App = Ember.Application.create({
 LOG_TRANSITIONS: true
});</pre></div><p class="calibre7">As illustrated, we enable the <code class="email">LOG_TRANSITIONS</code> flag when creating the application. If an application is <a id="id86" class="calibre1"/>not served at the root of the website domain, then it may be necessary to specify the path name used, as in the following example:</p><div class="informalexample"><pre class="programlisting">App.Router.reopen({
  rootURL: '/contacts/'
});</pre></div><p class="calibre7">One other modification we may need to make revolves around the techniques Ember.js uses to subscribe to the browser's location changes. This makes it possible for the router to do its job of transitioning the app into the matched URL state. Two of these methods are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Subscribing to the <code class="email">hashchange</code> event</li><li class="listitem">Using the <code class="email">history.pushState</code> API</li></ul></div><p class="calibre7">The default technique used is provided by the<a id="id87" class="calibre1"/> <code class="email">HashLocation</code> class documented at <a class="calibre1" href="http://emberjs.com/api/classes/Ember.HashLocation.html">http://emberjs.com/api/classes/Ember.HashLocation.html</a>. This means that URL paths are usually prefixed with the hash symbol, for example, <code class="email">/#/contacts/1/edit</code>. The other one is provided by the <code class="email">HistoryLocation</code> class<a id="id88" class="calibre1"/> located at <a class="calibre1" href="http://emberjs.com/api/classes/Ember.HistoryLocation.html">http://emberjs.com/api/classes/Ember.HistoryLocation.html</a>. This does not distinguish URLs from the traditional ones and can be enabled as:</p><div class="informalexample"><pre class="programlisting">App.Router.reopen({
  location: 'history'
});</pre></div><p class="calibre7">We can also opt to let Ember.js pick which method is best suited for our app with the following code:</p><div class="informalexample"><pre class="programlisting">App.Router.reopen({
  location: 'auto'
});</pre></div><p class="calibre7">If we don't need any of these techniques, we could opt to do so especially when performing tests:</p><div class="informalexample"><pre class="programlisting">App.Router.reopen({
  location: none
});</pre></div></div>
<div class="book" title="Specifying a route's path"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Specifying a route's path</h1></div></div></div><p class="calibre7">We now <a id="id89" class="calibre1"/>know that when defining a route or resource, the resource name used also serves as the path the router uses to match request URLs. Sometimes, it may be necessary to specify a different path to use to match states. There are two common reasons that may lead us to do this, the first of which is good for delegating route handling to another route. Although, we have not yet covered route handlers, we <a id="id90" class="calibre1"/>already mentioned that our application transitions from the application <code class="email">index</code> route into the <code class="email">contacts.index</code> state. We may however specify that the contacts route handler should manage this path as:</p><div class="informalexample"><pre class="programlisting">this.resource('contacts', {path: '/'}, function(){
});</pre></div><p class="calibre7">Therefore, to specify an alternative path for a route, simply pass the desired route in a hash as the second argument during resource definition. This also applies when defining routes.</p><p class="calibre7">The second reason would be when a resource contains dynamic segments. For example, our contact resource handles contacts who should obviously have different URLs linking back to them. Ember.js uses URL pattern matching techniques used by other open source projects such as Ruby on Rails, Sinatra, and Express.js. Therefore, our contact resource should be defined as:</p><div class="informalexample"><pre class="programlisting">this.resource('contact', {path: '/:contact_id'}, function(){
});</pre></div><p class="calibre7">In the preceding snippet, <code class="email">/:contact_id</code> is the dynamic segment that will be replaced by the actual contact's ID. One thing to note is that nested resources prefix their paths with those of parent resources. Therefore, the contact resource's full path would be <code class="email">/contacts/:contact_id</code>. It's also worth noting that the name of the dynamic segment  is not mandated and so we could have named the dynamic segment as <code class="email">/:id</code>.</p></div>
<div class="book" title="Defining route and resource handlers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Defining route and resource handlers</h1></div></div></div><p class="calibre7">Now that <a id="id91" class="calibre1"/>we have defined all the possible states that our application can transition into, we need to define handlers to these states. From this point onwards, we <a id="id92" class="calibre1"/>will use the terms <span class="strong"><em class="calibre9">route</em></span> and <span class="strong"><em class="calibre9">resource handlers</em></span> interchangeably. A route handler performs the following major functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Providing data (model) to be used by the current state</li><li class="listitem">Specifying the view and/or template to use to render the provided data to the user</li><li class="listitem">Redirecting an application away into another state</li></ul></div><p class="calibre7">Before we move into discussing these roles, we need to know that a route handler is defined from the <code class="email">Ember.Route</code> class as:</p><div class="informalexample"><pre class="programlisting">App.RouteHandlerNameRoute = Ember.Route.extend();</pre></div><p class="calibre7">This class is used to define handlers for both resources and routes and therefore, the naming should not be a concern. Just as routes and resources are associated with paths and handlers, they are also associated with controllers, views, and templates using the Ember.js naming conventions. For example, when the application initializes, it enters into the <code class="email">application</code> state and therefore, the following objects are sought:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The application route</li><li class="listitem">The application controller</li><li class="listitem">The application view</li><li class="listitem">The application template</li></ul></div><p class="calibre7">In the <a id="id93" class="calibre1"/>spirit of <span class="strong"><em class="calibre9">do more with reduced boilerplate</em></span> code, Ember.js autogenerates <a id="id94" class="calibre1"/>these objects unless explicitly defined in order to override the default implementations. As another example, if we examine our application, we notice that the <code class="email">contact.edit</code> route has a corresponding <code class="email">App.ContactEditController</code> controller and <code class="email">contact/edit</code> template. </p><p class="calibre7">We do not need to define its route handler or view. Having seen this example, when referring to routes, we normally separate the resource name from the route name by a period as in the following:</p><div class="informalexample"><pre class="programlisting">resourceName.routeName</pre></div><p class="calibre7">In the case of templates, we may use a period or a forward slash:</p><div class="informalexample"><pre class="programlisting">resourceName/routeName</pre></div><p class="calibre7">The other objects are usually camelized and suffixed by the class name:</p><div class="informalexample"><pre class="programlisting">ResourcenameRoutenameClassname</pre></div><p class="calibre7">For example, the following table shows all the objects used in our chapter sample. As mentioned earlier, some are autogenerated.</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Route Name</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Controller</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Route Handler</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">View</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Template</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">applicationApplicationControllerApplicationRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ApplicationViewapplication</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">indexIndexControllerIndexRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">IndexViewindex</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">about</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">AboutController</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">AboutRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">AboutView</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">about</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contactsContactsControllerContactsRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactsView</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contacts.indexContactsIndexControllerContactsIndexRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactsIndexViewcontacts/index</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contacts.newContactsNewController</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactsNewRoute</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactController</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactView</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact.index</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactIndexController</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactIndexRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactIndexView</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact/index</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact.edit</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactEditController</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactEditRoute</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">ContactEditView</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contact/edit</code>
</p>
</td></tr></tbody></table></div><p class="calibre7">One thing to note <a id="id95" class="calibre1"/>is that objects associated with the intermediary <a id="id96" class="calibre1"/>application state do not need to carry the suffix; hence, just <code class="email">index</code> or <code class="email">about</code>.</p></div>
<div class="book" title="Specifying a route's model"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>Specifying a route's model</h1></div></div></div><p class="calibre7">In the<a id="id97" class="calibre1"/> first chapter, we mentioned that route handlers provide controllers, the data needed to be displayed by templates. These handlers have a <code class="email">model</code> hook that can be used to provide this data in the following format:</p><div class="informalexample"><pre class="programlisting">AppNamespace.RouteHandlerName = Ember.Route.extend({
  model: function(){
  }
});</pre></div><p class="calibre7">For instance, the route <code class="email">contacts</code> handler in the chapter sample loads any saved contacts from local storage as:</p><div class="informalexample"><pre class="programlisting">  model: function(){
    return App.Contact.find();
  }</pre></div><p class="calibre7">We have abstracted this logic into our <code class="email">App.Contact</code> model. Notice how we reopen the class in order to define this static method. As a recap of this lesson in <a class="calibre1" title="Chapter 2. Understanding Ember.js Objects and Mixins" href="part0019_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre9">Understanding Ember.js Objects and Mixins</em></span>, a static method can only be called by the class of that method and not its instances:</p><div class="informalexample"><pre class="programlisting">App.Contact.reopenClass({
  find: function(id){
    return (!!id)
      ? App.Contact.findOne(id)
      : App.Contact.findAll();
  },
  …
});</pre></div><p class="calibre7">If no arguments <a id="id98" class="calibre1"/>are passed to the method, it goes ahead and calls the <code class="email">findAll</code> method, which uses the local storage helper to retrieve the contacts:</p><div class="informalexample"><pre class="programlisting">  findAll: function(){
    var contacts = store('contacts') || [];
    return contacts.map(function(contact){
      return App.Contact.create(contact);
    });
  }</pre></div><p class="calibre7">Because we want to deal with contact objects, we iteratively convert the contents of the loaded contact list. If we examine the corresponding template, <code class="email">contacts</code>, we notice that we are able to populate the sidebar as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="nav nav-pills nav-stacked"&gt;
{{#each model}}
  &lt;li&gt;
    {{#link-to "contact.index" this}}{{name}}{{/link-to}}
  &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">Do not worry about the template syntax at this point if you're new to Ember.js. The important thing to note is that the model was accessed via the <code class="email">model</code> variable. Of course, before that, we check to see if the model has any content in:</p><div class="informalexample"><pre class="programlisting">{{#if model.length}}
   ...    
{{else}}
    &lt;h1&gt;Create contact&lt;/h1&gt;
{{/if}}</pre></div><p class="calibre7">As we shall see later, if the list was empty, the application would be forced to transition into the <code class="email">contacts.new</code> state, in order for the user to add the first contact as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Specifying a route's model" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">contact</code> handler <a id="id99" class="calibre1"/>is a different case. Remember we mentioned that its path has a dynamic segment that would be passed to the handler. This information is passed to the model hook in an options hash as:</p><div class="informalexample"><pre class="programlisting">App.ContactRoute = Ember.Route.extend({
  model: function(params){
    return App.Contact.find(params.contact_id);
  },
  ...
});</pre></div><p class="calibre7">Notice that we are able to access the contact's ID via the <code class="email">contact_id</code> attribute of the hash. This time, the <code class="email">find</code> method calls the <code class="email">findOne</code> static method of the contact's class, which performs a search for the contact matching the provided ID, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  findOne: function(id){
    var contacts = store('contacts') || [];
    var contact = contacts.find(function(contact){
      return contact.id == id;
    });
    if (!contact) return;
    return App.Contact.create(contact);
  }</pre></div></div>
<div class="book" title="Serializing resources"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec31" class="calibre1"/>Serializing resources</h1></div></div></div><p class="calibre7">We've <a id="id100" class="calibre1"/>mentioned that Ember.js supports content to be linked back externally. Internally, Ember.js simplifies creating these links in templates. In our sample application, when the user selects a contact, the application transitions into the <code class="email">contact.index</code> state, passing his/her ID along. This is possible through the use of the <code class="email">link-to</code> handlebars expression:</p><div class="informalexample"><pre class="programlisting">{{#link-to "contact.index" this}}{{name}}{{/link-to}}</pre></div><p class="calibre7">Again, we will revisit this later, in detail, in <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre9">Writing Application Templates</em></span>, but for now, the important thing to note is that this expression enables us to construct a link that points to the said resource by passing the resource name and the affected model. The destination resource or route handler is responsible for yielding this path <a id="id101" class="calibre1"/>constituting <span class="strong"><strong class="calibre8">serialization</strong></span>. To serialize a resource, we need to override the matching <code class="email">serialize</code> hook as in the contact handler case shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.ContactRoute = Ember.Route.extend({
  ...
  serialize: function(model, params){
    var data = {}
    data[params[0]] = Ember.get(model, 'id');
    return data;
  }
});</pre></div><p class="calibre7">Serialization means that the hook is supposed to return the values of all the specified segments. It receives two arguments, the first of which is the affected resource and the second is an array of all the specified segments during the resource definition. In our case, we only had one and so we returned the required hash that resembled the following code:</p><div class="informalexample"><pre class="programlisting">{contact_id: 1}</pre></div><p class="calibre7">If we, for example, defined a resource with multiple segments like the following code:</p><div class="informalexample"><pre class="programlisting">this.resource(
  'book',
  {path: '/name/:name/:publish_year'},
  function(){
  }
);</pre></div><p class="calibre7">The serialization hook would need to return something close to:</p><div class="informalexample"><pre class="programlisting">{
  name: 'jon+doe',
  publish_year: '1990'
}</pre></div></div>
<div class="book" title="Asynchronous routing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec32" class="calibre1"/>Asynchronous routing</h1></div></div></div><p class="calibre7">In actual apps, we <a id="id102" class="calibre1"/>would often need to load the model data in an asynchronous fashion. There are various approaches that can be used to deliver this kind of data. The most robust way to load asynchronous data is <a id="id103" class="calibre1"/>through use of <span class="strong"><strong class="calibre8">promises</strong></span>. Promises are objects whose unknown value can be set at a later point in time. It is very easy to create promises in Ember.js. For example, if our contacts were located in a remote resource, we could use jQuery to load them as:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  model: function(params){
    return Ember.$.getJSON('/contacts');
  }
});</pre></div><p class="calibre7">jQuery's HTTP utilities also return promises that Ember.js can consume. As a by-the-way, jQuery can also be referenced as <code class="email">Ember.$</code> in an Ember.js application. In the preceding snippet, once data is loaded, Ember.js would set it as the model of the resource. However, one thing is missing. We require that the loaded data be converted to the defined contact model, as shown in the following little modification:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  model: function(params){
  var promise = Ember
    .Object
    .createWithMixins(Ember.DeferredMixin);

    Ember
      .$
      .getJSON('/contacts')
      .then(reject, resolve);
    
    function resolve(contacts){
      contacts = contacts.map(function(contact){
        return App.Contact.create(contact);
      });
      promise.resolve(contacts)
    }

    function reject(res){
      var err = new Error(res.responseText);
      promise.reject(err);
    }

    return promise;
  }
});</pre></div><p class="calibre7">We first create the <a id="id104" class="calibre1"/>promise, kick off the XHR request, and then return the promise while the request is still being processed. Ember.js will resume routing once this promise is rejected or resolved. The XHR call also creates a promise, so we need to attach to it the <code class="email">then</code> method which essentially says, <span class="strong"><em class="calibre9">invoke the passed resolve or reject function on successful or failed load respectively</em></span>. The <code class="email">resolve</code> function converts the loaded data and resolves the promise; passing the data along thereby resumes routing. If the promise was rejected, the transition fails with an error. We will see how to handle this error in a moment.</p><p class="calibre7">Note that there are two other flavors we can use to create promises in Ember.js, as shown in the following examples:</p><div class="informalexample"><pre class="programlisting">var promise = Ember.Deferred.create();

Ember
  .$
  .getJSON('/contacts')
  .then(success, fail);

function success(){
  contacts = contacts.map(function(contact){
    return App.Contact.create(contact);
  });
  promise.resolve(contacts)
}

function fail(res){
  var err = new Error(res.responseText);
  promise.reject(err);
}

return promise;</pre></div><p class="calibre7">The second example is as follows:</p><div class="informalexample"><pre class="programlisting">return new Ember.RSVP.Promise(function(resolve, reject){

  Ember
    .$
    .getJSON('/contacts')
    .then(success, fail);

  function success(){
    contacts = contacts.map(function(contact){
      return App.Contact.create(contact);
    });
    resolve(contacts)
  }

  function fail(res){
    var err = new Error(res.responseText);
    reject(err);
  }

});</pre></div></div>
<div class="book" title="Configuring a route's controller"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec33" class="calibre1"/>Configuring a route's controller</h1></div></div></div><p class="calibre7">We just <a id="id105" class="calibre1"/>learned that routes provide their corresponding controllers, data that they proxy to templates and views. This usually happens in the <code class="email">setupController</code> hook of the route. For example:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  setupController: function(controller, model){
    controller.set('model', model);
  }
});</pre></div><p class="calibre7">Although we'll rarely need to use it, this hook provides a good opportunity to modify other controllers. For example, we could set a property on the <code class="email">application</code> controller as:</p><div class="informalexample"><pre class="programlisting">App.ContactsIndexRoute = Ember.Route.extend({
  setupController: function(controller, model){
   this._super(controller, model);
   this
        .controllerFor('application')
        .set('contacts', this.modelFor('contacts'));
  }
});</pre></div><p class="calibre7">We'd never actually write such code in an actual app but this snippet introduces two convenience methods, <code class="email">modelFor</code> and <code class="email">controllerFor</code>, that can be used to access the models and controllers of other handlers respectively. Note that the argument passed is the route's or resource's name. Here are more examples:</p><div class="informalexample"><pre class="programlisting">this.modelFor('contacts.index');
this.controllerFor('contact.edit');</pre></div><p class="calibre7">Sometimes, we <a id="id106" class="calibre1"/>may want to specify a different controller that a handler should use. For example, the <code class="email">contact.edit</code> route is used to edit the <code class="email">contact</code> resource model. In this case, we needed to specify that the former depended on the latter via the <code class="email">needs</code> property. That way, as we'll learn in <a class="calibre1" title="Chapter 5. Controllers" href="part0061_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre9">Controllers</em></span>, the <code class="email">contact.edit</code> route's template was able to access the model that was set on the controller as:</p><div class="informalexample"><pre class="programlisting">{{#with controller.controllers.contact}}
...
{{/with}}</pre></div><p class="calibre7">An alternative approach would be to use this controller directly by specifying it in the handler as:</p><div class="informalexample"><pre class="programlisting">App.ContactEditRoute = Ember.Route.extend({
  controllerName: 'contact'
});</pre></div><p class="calibre7">The result would be that the <code class="email">contact.edit</code> template would be similar to that of the <code class="email">contacts.new</code> template and, therefore both can be removed as explained in the next section.</p></div>
<div class="book" title="Rendering the route's template"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec34" class="calibre1"/>Rendering the route's template</h1></div></div></div><p class="calibre7">Before <a id="id107" class="calibre1"/>we discuss more on route handler template rendering, it's worth discussing what happens when the application transitions between states in the context of templates. This section will be revisited in detail in the next chapter. In our chapter example, the application eventually knows the transition, as outlined in order:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">application state</code></li><li class="listitem"><code class="email">contacts state</code></li><li class="listitem"><code class="email">contact state</code></li><li class="listitem"><code class="email">contact.index state</code></li></ul></div><p class="calibre7">Therefore, the <code class="email">application</code> template<a id="id108" class="calibre1"/> is first rendered on the screen. The next template, <code class="email">contacts</code>, is then rendered into the application template to constitute the sidebar. Next, the <code class="email">contact</code> template<a id="id109" class="calibre1"/> is inserted into the <code class="email">contacts</code> template. Lastly, the <code class="email">contact.index</code> template was inserted into the <code class="email">contact</code> template to complete the transition. Each template specifies an <code class="email">outlet</code> portion into which child route handlers can render their templates. For example, note the outlet expression in the following application template:</p><div class="informalexample"><pre class="programlisting">  &lt;script type="text/x-handlebars"&gt;
    &lt;div class="container"&gt;
      {{outlet}}
    &lt;/div&gt;
  &lt;/script&gt;</pre></div><p class="calibre7">A route <a id="id110" class="calibre1"/>handler can specify the template to use in the same way as controllers. Again, revisiting the <a id="id111" class="calibre1"/>
<code class="email">contact.edit</code> route template, it uses a partial, which we shall discuss in the next chapter, and includes the shared <code class="email">contacts.form</code> template into the host template. </p><p class="calibre7">The <code class="email">renderTemplate</code> hook<a id="id112" class="calibre1"/> is the last chance for the handler to specify a custom template to use by invoking the <code class="email">render</code> method and passing in the template to use along, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.ContactEditRoute = Ember.Route.extend({
  renderTemplate: function() {
    this.render('contacts/form');
  }
});</pre></div><p class="calibre7">In this case, we can therefore get rid of the defined controllers and routes of the <code class="email">contacts.new</code> and <code class="email">contact.edit</code> routes. Lastly, templates are not limited to a single outlet. This means that you can render different templates with different controller contexts in the current state template. For example, in a game application, we could define two outlets to host two different templates serving different purposes as:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" data-template-name="game"&gt;
  &lt;div id="leaderboard"&gt;{{outlet leaderboard}}&lt;/div&gt;
  &lt;div id="mainboard"&gt;{{outlet mainboard}}&lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">And then, render them via the handler as:</p><div class="informalexample"><pre class="programlisting">App.GameRoute = Ember.Route.extend({
  renderTemplate: function() {
    this.render('mainboard', {
      into: 'game',
      outlet: 'mainboard',
      controller: 'mainboard'
    });
    this.render('leaderboard', {
      into: 'game',
      outlet: 'leaderboard',
      controller: 'leaderboard'
    });
  }
});</pre></div></div>
<div class="book" title="Redirecting state"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec35" class="calibre1"/>Redirecting state</h1></div></div></div><p class="calibre7">A common <a id="id113" class="calibre1"/>use of a handler is to redirect the application into another state in the same way we may be redirected to a <code class="email">404</code> page if the requested resource was not found by the underlying server. In our sample app, the index controller overrides the route handler's <code class="email">redirect</code> hook in order to redirect the application into the <code class="email">contacts</code> state using the <code class="email">transitionTo</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.IndexRoute = Ember.Route.extend({
  redirect: function(){
    this.transitionTo('contacts');
  }});</pre></div><p class="calibre7">There are two cases where we may need to perform this redirection. The first is when we don't need to know the model of the route handler. We used one of these hooks, <code class="email">beforeModel</code>, to populate the contact list local store with fixtures just before the same handler went ahead to load them, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  beforeModel: function(){
    var contacts = store('contacts') || CONTACTS;
    store('contacts', contacts);
  }
});</pre></div><p class="calibre7">On the other hand, we can either use the <a id="id114" class="calibre1"/>
<code class="email">redirect</code> and <code class="email">afterModel</code> hooks if we needed to wait for the handler's model to load. In fact, the latter actually just calls the former. For example, we used the <code class="email">afterModel</code> hook<a id="id115" class="calibre1"/> in the <code class="email">contacts</code> route handler in the chapter sample to determine whether we needed to force the user to add a new contact or redirect them to view the first contact, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.ContactsIndexRoute = Ember.Route.extend({
  afterModel: function(){
    var model = this.modelFor('contacts') || [];
    var contact = model.get('firstObject');
    if (!contact) return this.transitionTo('contacts.new');
    return this.transitionTo('contact.index', contact);
  },
});</pre></div></div>
<div class="book" title="Catching routing errors"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec36" class="calibre1"/>Catching routing errors</h1></div></div></div><p class="calibre7">If a<a id="id116" class="calibre1"/> transition into a route fails, for example, failure to load the model, Ember.js emits the error action in that handler. Although we have not covered actions, think of them as events that can be delegated to a handler from templates or other route handlers and controllers. The following example catches such errors by redirecting the application to an appropriate error handling route:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  action: {
    error: function(error){
      this.controllerFor('error').set('error', error);
      this.transitionTo('error');
    } 
  }
});</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec37" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter has detailed how states are managed in Ember.js. We have particularly discussed how an Ember.js application boots from an application state into other nested states. A few concepts were introduced in the chapter sample and will be discussed in detail in the next chapter. That being said, in the next chapter, we will discuss templates, especially how they render the data proxied by controllers and how they delegate user generated actions back to routes. Therefore, you should have a solid understanding of the following topics covered in this chapter since they'll be frequently revisited:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Defining application routes</li><li class="listitem">Defining an application route</li><li class="listitem">Implementing a route's model</li><li class="listitem">Setting up a route's controllers</li><li class="listitem">Specifying a route's template</li><li class="listitem">Performing asynchronous routing</li></ul></div><p class="calibre7">The next chapter will describe how to include templates using script tags or compiling and bundling/shipping templates from the server.</p></div></body></html>