<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Programming with Types and Values</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we looked at type-driven development using ReasonML, but what are types exactly? And how do they interact with other parts of your program? How do they help you on a regular basis, and what does it look like to use a strong static type system with type inference?</p>
<p>In this chapter, we will cover the following topics:<br/></p>
<ul>
<li>Setting up an editor workflow</li>
<li>Types and values</li>
<li>Immutable values and memory</li>
<li>Static versus dynamic typing</li>
<li>Type erasure</li>
<li>Syntax errors</li>
<li>Type errors and inference</li>
<li>Unification</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Workflow</h1>
                </header>
            
            <article>
                
<p>To get the most from this chapter, we will set up a comfortable edit-compile workflow. We recommend placing two windows side-by-side in your editor. VSCode supports this functionality with the <span class="packt_screen">View | Split Editor</span> command. On one side, load a Reason source file; on the other side, load the JavaScript output file (once it is initially compiled). Then in a terminal, run the following command:</p>
<pre><strong>bsb -w</strong></pre>
<p>The preceding command starts a build in <em>watch mode,</em> which automatically recompiles any parts of a project that are affected whenever you change any source code. In fact, watch mode is smart enough to also remove an outdated JavaScript output file whenever its corresponding Reason source file is deleted. The editor will also auto-reload the compiled JavaScript file whenever you save a Reason source file.</p>
<p>In VSCode, you can also open a terminal session directly below the files using the <span class="packt_screen">View | Integrated Terminal</span> command and run <kbd>bsb -w</kbd> to get a single integrated view of your entire workflow. This way, when there are compile errors, you won't have to switch windows to see them. Of course, you may prefer to work with two monitors and keep the terminal and compiler running on another screen so you don't have to switch windows—that's feasible, too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types and values</h1>
                </header>
            
            <article>
                
<p>Let's set the stage for the rest of the book with a discussion of types and values. At its core, a type is a set of values. Think of the type <kbd>bool</kbd>, which is what Reason calls the normal Boolean type. A <kbd>bool</kbd> value can be one of two different things: <kbd>true</kbd> or <kbd>false</kbd>. We say that these values <em>inhabit</em> (live in) the type. Anything else is an error.</p>
<p>This raises an interesting question: <em>what does it mean to say? Anything else is an error' in this context? In fact, why should we care about types at all?</em></p>
<p>To answer these questions, let's think about what should happen if we try to do the operation <kbd>"Bob" / 5</kbd>. What does it mean to divide the string <kbd>Bob</kbd> by the number <kbd>5</kbd>?</p>
<p>If you can't think of a good answer, well neither can anyone else. It's kind of a meaningless question. It's like asking, <em>how does the color green taste?</em> (Although this may be a meaningful question for synesthetic people.)</p>
<p>Anyway, this is the simplest answer to why we care about types – to avoid having to deal with meaningless questions. To rule out meaningless operations, we simply make them type errors in the programs that execute the code. In other words, we get our compilers and interpreters to slot all our values into distinct types, or errors if any operations can't be meaningfully performed for the given types of values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static types</h1>
                </header>
            
            <article>
                
<p>There are two possible times when type errors can happen: at compile time and at runtime. This is the crucial difference between static and dynamic type systems: static type systems are so called because they <em>statically analyze</em> programs and try to find type errors, while dynamic type systems are so called because they throw type errors dynamically, while they run the program.</p>
<div class="packt_infobox">A dynamic type system will definitely find all the type errors in your program, provided it actually runs all the execution paths in it. Any paths that remain unexecuted may contain hidden type errors.</div>
<p>A static type system will try to find as many errors as possible without running your program. Normally, this is not a guarantee that you will catch all type errors before runtime. Some errors may slip through the <strong>typechecker</strong> and still hit you at runtime. Plus, a type system may make it difficult to express a program that you know is correct because it thinks it's not. You will want to pay close attention when this happens, though, as either the typechecker is correct, or your design will benefit from expressing the program in a different, accepted, way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What do you gain?</h1>
                </header>
            
            <article>
                
<p><span>With regard to the caveats mentioned earlier</span>, what do static type systems actually give you?</p>
<ul>
<li>A good type system catches almost all type errors for you before runtime</li>
<li>It accepts all or almost all programs that do not contain type errors</li>
</ul>
<p>Being able to catch type errors before runtime is a very nice ability to have. It will help you to avoid possible downtime, expenses, lost business, and so on. Note that we mentioned a <em>good</em> type system. We should try to aim for the best type system we can get at our disposal. Since, Reason is OCaml, it automatically gets OCaml's powerful, safe, and expressive type system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static and dynamic environments</h1>
                </header>
            
            <article>
                
<p>Let's develop a mental model for what happens in a program with types and values. At its core, a program is made up of a series of type and value definitions. For example:</p>
<pre>/* src/Ch02/Ch02_Demo.re */<br/><span class="underline">type</span> <strong>person</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/><span class="underline">type</span> <strong>company</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>, <em>employees</em>: <strong>list</strong>(<strong>person</strong>)};<br/><br/><span class="underline">let</span> <em>bob</em> = {<em>id</em>: 1, <em>name</em>: "Bob"};<br/><span class="underline">let</span> <em>acmeCo</em> = {<em>id</em>: 1, <em>name</em>: "Acme Co.", <em>employees</em>: [<em>bob</em>]};</pre>
<p>Here, we're defining <kbd>person</kbd> and <kbd>company</kbd> <kbd>types</kbd>, and then allocating a person (<kbd>bob</kbd>) and a company he works for (<kbd>acmeCo</kbd>).</p>
<p>Without worrying too much about the syntax (we will introduce this in <a href="ba37505a-f222-4238-a13c-259160ca582d.xhtml">Chapter 4</a>, <em>Group Values Together in Types</em>), let's think about how the programming environment sees this program.</p>
<p>In a statically typed programming language, the typechecker and runtime environment together make up the <em>static</em> and <em>dynamic environments.</em> These are areas where type definitions are stored while typechecking takes place, and where value definitions are stored during program execution (runtime). We can think of these as two distinct areas that are only relevant during the distinct phases of compilation and runtime. After compilation, all type information is wiped out (<em>type erasure</em>), but during runtime the dynamic environment becomes active in memory (that is, the stack and the heap).</p>
<p>Here is how the static and dynamic environments look for the preceding code:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Static Environment</strong></td>
<td><strong>Dynamic Environment</strong></td>
</tr>
<tr>
<td><kbd>type person;</kbd></td>
<td/>
</tr>
<tr>
<td>
<p><kbd>type company;</kbd> <span>(refers to </span> <strong><kbd>person</kbd></strong><span>)</span></p>
</td>
<td/>
</tr>
<tr>
<td/>
<td>
<p><kbd>let bob;</kbd></p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>let acmeCo;</kbd><span> (refers to </span><kbd>bob</kbd><span>)</span></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Example of static and dynamic environments (evaluated top to bottom)</div>
<p>In each of the static and dynamic environments, each definition is allowed to refer to definitions that came before it. This is a crucial abstraction technique – it's how we build larger programs out of smaller ones at both the type and value levels.</p>
<div class="packt_tip">There are no references between the static and dynamic environments – values don't exist at compile time and types don't exist at runtime. This may come a surprise as we do mix them in one place: the source code.</div>
<p>Among other things, this strict separation balances the needs of safety and efficiency. Note that this is in sharp contrast to dynamic typing, where types exist at runtime as well, and must be checked before every operation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Values</h1>
                </header>
            
            <article>
                
<p>It's important to understand how values work in Reason. We've seen that they come into play at runtime and live in memory but it's also important to know that, by default, all values are immutable –effectively, constants. There are a couple of exceptions, which we will cover, but generally we will work in a style where we don't try to change values, and instead just create new values out of old ones. This is a style that is well-supported by Reason and is a foundation of functional programming.</p>
<p>There is a syntax for binding values to names, which is as follows:</p>
<pre><span class="underline">let</span> <em>PATTERN</em> = <em>VALUE</em>;</pre>
<p>The preceding syntax slots the value on the right-hand side into the shape described in the left-hand side, as long as their shapes match. The general name for this concept is <em>pattern matching</em>, and we will see it a lot in this book.</p>
<p>So far, the patterns (to the left of <kbd>=</kbd>) we've seen have been just simple names, such as:</p>
<pre><span class="underline">let</span> <em>x</em> = 1;</pre>
<p>The preceding pattern has allowed us to capture the entire value in the name and reuse it later. The way it works is that Reason checks that the value (<kbd>1</kbd>) can fit inside the pattern (<kbd>x</kbd>). In this simple case, there is nothing about the pattern that prevents the value from fitting inside. We call this an <em>irrefutable pattern.</em> In further chapters, we will see examples of <em>refutable</em> patterns and how they behave.</p>
<p>Wherever you see the keyword <kbd>let</kbd>, you should understand that it may be allocating memory, if:</p>
<ul>
<li>The bound value is a literal (for example, <kbd>"Bob"</kbd>), or</li>
<li>The bound value is the result of a function or operator call, and the function or operator call allocates a new value in memory</li>
</ul>
<p>The other cases are mainly of bindings to existing values or bindings to function calls that don't allocate.</p>
<p>In this book, we won't be worrying too much about allocation and memory use, but we will look at a couple of techniques of how to reduce them when necessary, which can come in handy when trying to boost performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scoping and shadowing</h1>
                </header>
            
            <article>
                
<p>Whenever we define values, they exist (in the dynamic environment) in a scope, in which all previously defined names are available but only until the end of the scope. Scopes are nested inside each other, starting with the <em>top level</em> scope (the definitions at the file level), and nested scopes inside braces (<kbd>{...}</kbd>). For example:</p>
<pre>/* src/Ch02/Ch02_Scope.re */<br/><span class="underline">let</span> <em>x</em> = 1;<br/><br/><span class="underline">let</span> <em>y</em> = <em>x</em> + 1;<br/><span class="underline"><br/>let</span> z = {<br/>  <span class="underline">let</span> <em>result</em> = 0;<br/>  <em>result</em> + <em>x</em> + <em>y</em><br/>};</pre>
<p>Here, <kbd>x</kbd> and <kbd>y</kbd> are in the top level scope, where <kbd>y</kbd> can access <kbd>x</kbd> by name because <kbd>x</kbd> is defined before <kbd>y</kbd>; <kbd>z</kbd> can access both for the same reason. However, note the definition of <kbd>result</kbd> in the nested scope introduced by the braces. The name <kbd>result</kbd> is only available from the point it is defined up until the closing brace; outside of that scope, referring to <kbd>result</kbd> will result in a compile error (specifically, a <em>name error,</em> which we will talk about later in the chapter).</p>
<p>Because Reason puts all definitions in certain scopes, we can define the same name more than once in the same scope or in a nested scope. This is called <strong>shadowing</strong> because the new definition hides the old one until the new one goes out of scope. Of course, if the old and new names go out of scope together (that is, they're in the same scope), the old name is effectively hidden forever. The following codeblock is an example of this:</p>
<pre>/* src/Ch02/Ch02_Shadowing.re */<br/><span class="underline">let</span> <em>name</em> = "Bob";<br/><span class="underline">let</span> <em>age</em> = "33";<br/><br/><span class="underline">let</span> <em>greeting</em> = {<br/>  <span class="underline">let</span> <em>age</em> = "34";<br/>  "Hello, " ++ <em>name</em> ++ " aged " ++ <em>age</em>;<br/>};<br/><br/><span class="underline">let</span> <em>name</em> = "Jim";<br/><span class="underline">let</span> <em>greeting2</em> = "Hello, " ++ <em>name</em> ++ " aged " ++ <em>age</em>;</pre>
<p class="mce-root">Let's now take a look at the output JavaScript as follows:</p>
<pre>// src/Ch02/Ch02_Shadowing.bs.js<br/><span class="underline">var</span> <em>age</em> = "33";<br/><span class="underline">var</span> <em>greeting</em> = "Hello, Bob aged 34";<br/><span class="underline">var</span> <em>name</em> = "Jim";<br/><span class="underline">var</span> <em>greeting2</em> = "Hello, Jim aged 33";</pre>
<p class="mce-root">Notice how Bob's age is <kbd>34</kbd> in his <kbd>greeting </kbd>– the <kbd>age</kbd> in the <kbd>greeting</kbd> scope shadows <kbd>age</kbd> in the top level scope. However, as soon as that scope ends (with the closing brace), the original <kbd>age</kbd> becomes visible again and is used in Jim's <kbd>greeting2</kbd>.</p>
<p>However, the second <kbd>name</kbd> binding (<kbd>"Jim"</kbd>) permanently shadows the first one because they are both in the top level scope. In fact, since the first <kbd>name</kbd> and the inner <kbd>age</kbd> will never be visible again, the BuckleScript compiler doesn't even bother to output them, instead directly inlining their values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding type erasure</h1>
                </header>
            
            <article>
                
<p>To concretely grasp the effect of static/dynamic separation, let's look at type erasure, which is something that happens when we compile the preceding code to JavaScript. The following is the output with all redundant comments removed:</p>
<pre>// src/Ch02/Ch02_Demo.bs.js<br/><span class="underline">var</span> <em>bob</em> = [1, "Bob"];<br/><span class="underline">var</span> <em>acmeCo_002</em> = [<em>bob</em>, 0];<br/><span class="underline">var</span> <em>acmeCo</em> = [1, "Acme Co.", <em>acmeCo_002</em>];</pre>
<p>As we mentioned earlier, BuckleScript compiles Reason record types into JavaScript arrays with the corresponding number of elements. BuckleScript, in fact, performs quite a number of optimizations for you. Some of these come from its underlying OCaml compiler technology, which has been developed since the 1990s, but other things are quite unique in the world of language-to-JavaScript compilers.</p>
<p>Notice that BuckleScript has wiped out both the type definitions and has output only the minimum number of values it actually needs for runtime. The important thing to understand here is that all the output values follow the laws introduced by their corresponding types; for example, the <kbd>Bob</kbd> value, of type <kbd>person</kbd>, can only be an array with two elements (a number and a string, corresponding to the two fields in the person record), and the <kbd>acmeCo</kbd> value can only be an array with three elements of the correct types. Anything else is impossible – with a mathematical degree of certainty – even in output JavaScript code, because code that doesn't pass the typing rules (that is, doesn't typecheck) would not even compile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Errors</h1>
                </header>
            
            <article>
                
<p>We mentioned earlier that the compiler will raise errors if it cannot make sense of a piece of code it comes across. There are a few different kinds of compiler errors, and they are as follows</p>
<ul>
<li>Syntax errors</li>
<li>Type errors</li>
<li>Name errors</li>
<li>Stale interface errors (which we'll cover in the next chapter)</li>
<li>Compiler bugs (these are rare but shouldn't be discounted)</li>
</ul>
<p>The two most common types of error that we will deal with are syntax errors and type errors. Name errors are fairly simple to avoid: always start type names with a lowercase letter and ensure that the names you refer to in your code were defined before you refer to them. (Reason supports <em>cyclic references</em> but not <em>forward references</em>;<em> </em>we'll cover cyclic references later on.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Syntax errors</h1>
                </header>
            
            <article>
                
<p>Syntax errors are a basic kind of error and happen when the compiler literally can't make sense of the source code, for example:</p>
<pre><span class="underline">type</span> <strong>person</strong> = {<em>id</em>: <strong>int</strong>; <em>name</em>: <strong>string</strong>};</pre>
<p>Can you spot the error in the preceding code? If you compare it with the <kbd>person</kbd> definition in <kbd>src/Ch02/Ch02_Demo.re</kbd>, you should be able to. In any case, the compiler will tell you (usually fairly accurately) where to look. The only problem is you'll have to learn to sift through the compiler output to find the exact error, as follows:</p>
<pre><strong>(Output from bsb -w)</strong><br/>&gt;&gt;&gt;&gt; Start compiling<br/>Rebuilding since [ [ 'change', 'Ch02_Demo.re' ] ]<br/>ninja: Entering directory `lib/bs'<br/>[1/2] Building src/Ch02/Ch02_Demo.mlast<br/>FAILED: src/Ch02/Ch02_Demo.mlast<br/>/usr/local/lib/node_modules/bs-platform/lib/bsc.exe -pp "/usr/local/lib/node_modules/bs-platform/lib/refmt3.exe –print binary"    -w -30-40+6+7+27+32..39+44+45+101 -warn-error +3 -bs-suffix -nostdlib -I '/Users/yawar/src/learning-tydd-reason/node_modules/bs-platform/lib/ocaml' -no-alias-deps -color always -c -o src/Ch02/Ch02_Demo.mlast -bs-syntax-only -bs-binary-ast -impl /Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re<br/><strong>File "/Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re", line 2, characters 23-24:</strong><br/><strong>Error: 438: &lt;UNKNOWN SYNTAX ERROR&gt;</strong><br/>File "/Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re", line 1, characters 0-0:<br/>Error: Error while running external preprocessor<br/>Command line: /usr/local/lib/node_modules/bs-platform/lib/refmt3.exe –print binary '/Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re' &gt; /var/folders/xg/6jbw_1bj5h35b4lt7rygs12w0000gn/T/ocamlppf72c18<br/><br/>ninja: error: rebuilding 'build.ninja': subcommand failed<br/>&gt;&gt;&gt;&gt; Finish compiling(exit: 1)</pre>
<p>Syntax errors start with the text <kbd>File "/path/to/file", line L, characters C1-C2:</kbd> (where <kbd>L</kbd>, <kbd>C1</kbd>, and <kbd>C2</kbd> are the actual line and character numbers). The error message, <kbd>&lt;UNKNOWN SYNTAX ERROR&gt;</kbd>, is not too helpful, but the line and character positions pinpoint the location pretty well. Confusingly, there is also another error message starting in the same way, but this time with <kbd>line 1 and characters 0-0: Error while running external preprocessor</kbd>. This is Reason's way of redundantly saying it couldn't understand the code, and is hopefully going away soon!</p>
<p>In our example, the error points at the 23rd and 24th characters, where you see a semicolon and space; if you compare that with the correct version of the code, you see that it should be a comma and space.</p>
<p>When you're starting out with Reason, you should expect to see more of these syntax errors, and to spend some time working through exactly why they're happening. As you learn the syntax, you can expect to be able to tell just by looking at it that a piece of code doesn't contain the correct syntax. The correct syntax is available in Reason's excellent reference documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type errors and inference</h1>
                </header>
            
            <article>
                
<p>The other main kind of compiler error you will see is a <strong>type error</strong><em>.</em> A type error is an error that arises when a type (or a value of a type) is used in a way that's not allowed by the type definition.</p>
<p>These are more interesting errors because you're likely to come across them for the rest of your programming career, during which you should expect to continue seeing large productivity and code quality benefits from type errors forcing better design thinking and bug reduction.</p>
<p>Type errors are also heavily tied into Reason's type inference engine, which through a process of elimination works out exactly what the types should be for every piece of the code. Let's look at a few simple type errors and the code that will trigger them. We will also explain the type inference rules that led to the error.</p>
<p>First, let's try the division problem we posted earlier (the bold parts are colored red in Reason's error message):</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re 8:14-18<br/><br/>  6 │ /* ... elided ... */<br/>  7 │<br/>  <strong>8</strong> │ let result = <strong>"Bob"</strong> / 5;<br/><br/>  This has type:<br/>    <strong>string</strong><br/>  But somewhere wanted:<br/>    int</pre>
<p>Let's look at the process of elimination by which Reason arrives at type errors:</p>
<ul>
<li>Assigns types to the smallest possible parts of the expression, one by one</li>
<li>Tries to fit all the types together like puzzle pieces
<ul>
<li>If they fit, pass typechecker</li>
<li>If they don't fit, raise a type error</li>
</ul>
</li>
</ul>
<p class="mce-root">The following diagram shows the type inference and checking process (read from left to right):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c41a6ac-1481-438b-a8d9-99c671a73adf.png" style="width:34.58em;height:7.00em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The type error arises from the fact that <kbd>"Bob"</kbd> is a string (anything inside double-quotes is inferred to be a string), whereas the division operator <kbd>(/)</kbd> by definition requires two <kbd>int</kbd> variables as input. However, Reason can still infer <kbd>result</kbd> to be an <kbd>int</kbd> because it knows the division operator outputs an <kbd>int</kbd>.</p>
<p>Now, let's try a slightly more interesting type error, from not creating a record correctly, shown as follows:</p>
<pre><strong>(Output from bsb -w)</strong><br/> We've found a bug for you!<br/> /Users/yawar/src/learning-tydd-reason/src/Ch02/Ch02_Demo.re 6:51-53<br/><br/> 4 │<br/> 5 │ let bob = {id: 1, name: "Bob"};<br/> <strong>6</strong> │ let acmeCo = {id: 1, name: "Acme Co.", employees: <strong>bob</strong>};<br/><br/>  This has type:<br/> <strong>person</strong><br/> But somewhere wanted:<br/> list(person)</pre>
<p>The following diagram shows the typechecking process for a record:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42cc87e5-0431-42a1-ab82-e368904ca238.png"/></p>
<p>Here, the type error arises because one of the components of the record does not have the correct type. You can compare the code in the error message with the source code to exact</p>
<p>You may be curious to know why the division type error was reported the way it was, when it may have been more natural to work from left to right and produce an error like <span class="packt_screen">string does not support division by ints</span>. This is because the typechecker works on the <em>abstract syntax tree</em> of the program – that is, an internal representation of the program itself after it has been parsed (and verified as free of syntax errors). The AST is structured, as you might have guessed, as a tree, and in the tree, operations and function calls are the parent nodes of their arguments. So, the operations are assigned types first and then their arguments. Hence you see <kbd>"Bob"</kbd> as the thing that caused the type mismatch, instead of <kbd>(/)</kbd>.</p>
<p>Theoretically, though, typechecking could go in either direction – from the root of the AST to its leaf nodes or the other way round as normal. You may often hear the process of fitting the types together referred to as <strong>unification</strong>, which means the same thing. If instead of <kbd>"Bob"</kbd> , the first operand had been, for example, <kbd>10</kbd> (of type <kbd>int</kbd>), Reason would have been able to unify their types (<kbd>int</kbd> and <kbd>int</kbd>) and thus pass typechecking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a lot of ground, including setting up an editorial workflow, learning about types and values, static and dynamic typing, Reason's separation between compile time and runtime and its type erasure, syntax, and type errors, as well as inference and unification.</p>
<p>In future chapters, we will build on this chapter and introduce many more static typing techniques and the potential type errors that we may see from using them.</p>


            </article>

            
        </section>
    </body></html>