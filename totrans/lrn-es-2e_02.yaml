- en: Knowing Your Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6/ES7/ES8 has added lots of new properties and methods to built-in JavaScript
    objects. These new functionalities aim to help developers avoid using hacks and
    error-prone techniques to do various operations related to numbers, strings, and
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: From the last chapter, you now know a decent amount of background details about
    JavaScript, how it works, its fundamentals, and basic stuff such as hoisting,
    scoping variables, and immutability. Now let's move on and take a look at some
    topics which you'll end up using practically all the time in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The new properties and methods of the `Number`, `Object`, `Math`, and `Array`
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing numeric constants as binary or octal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiline strings and the new methods of the `String` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps and sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array buffers and typed arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to iterate properly over arrays using some built-in methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String padding, and more!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6, ES2016 (ES7), and ES2017 (ES8) bring new ways of creating numbers and new
    properties to the `Number` object to make working with numbers easier. The `Number`
    object was enhanced greatly in ES6 to make it easier to create mathematically
    rich applications and prevent the common misconceptions that caused the errors.
  prefs: []
  type: TYPE_NORMAL
- en: The binary notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, there was no native way to represent numeric constants as binary. But
    now, you can prefix numeric constants using the `0b` token to make JavaScript
    interpret them as binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `0b00001111` is a binary representation of `15`, base 10 decimal.
  prefs: []
  type: TYPE_NORMAL
- en: The octal notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The octal notation is a number system where we use only eight digits, that is,
    from 0 to 7\. You can represent a number in octal format with JavaScript if you
    like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, to represent a numeric constant as octal, we needed to prefix the
    numeric constant using `0`. For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But often, programmers new to JavaScript, get confused with octal representations
    and decimal numbers with `0` at the front. For example, they think `017` is the
    same as `17`. Therefore, to remove this confusion, JavaScript now allows us to
    prefix numeric constants using `00` to make JavaScript interpret them as octal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isInteger(number) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript numbers are stored as 64-bit, floating-point numbers. So integers
    in JavaScript are floating-point numbers without a decimal fraction or a decimal
    fraction with all 0's.
  prefs: []
  type: TYPE_NORMAL
- en: In ES5, there was no built-in way to check whether a number is an integer or
    not. There exists a new method to the `Number` object called `isInteger()`, which
    takes a number and returns `true` or `false`, depending on whether the number
    is an integer or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isNaN(value) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`The Number.isNaN` function returns `true` *if and only if*the value equals
    `NaN`. Otherwise, in every other case, it returns `false`. That means it will
    *not* try to typecast something which is not a number, to a number (which usually
    results in `NaN` being returned).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that the `Number.isNaN()` method returns `true` only if the
    passed value is exactly `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: You might ask, why not use `==` or the `===` operator instead of the `Number.isNaN(value)`
    method? The `NaN` value is the only value that is not equal to itself, that is,
    the expression `NaN==NaN` or `NaN===NaN` will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If you declare `x = NaN`, then `x` is not equal to itself!
  prefs: []
  type: TYPE_NORMAL
- en: isNaN versus Number.isNaN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To me, a method called `isNaN` should intuitively return `false` only on numbers
    and `true` on everything else. That is exactly what the `isNaN()` global method
    does. However, if you're looking to compare a value to `NaN` (which you cannot
    do with `===` or `==`), then `Number.isNaN` is your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In short, `isNaN` also tries to perform type conversion. That is why some developers
    consider it broken.
  prefs: []
  type: TYPE_NORMAL
- en: The Number.isFinite(number) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The global `isFinite()` function takes a value and checks whether it's a finite
    number or not. But unfortunately, it also returns `true` for values that convert
    to a `Number` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Number.isFinite()` method resolves the issue of the `window.isFinite()`
    function. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isSafeInteger(number) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript numbers are stored as 64-bit floating-point numbers, following the
    international IEEE 754 standard. This format stores numbers in 64 bits, where
    the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62
    bits, and the sign in the last bit.
  prefs: []
  type: TYPE_NORMAL
- en: So in JavaScript, safe integers are those numbers that do not need to be rounded
    to some other integer to fit in with the IEEE 754 representation. Mathematically,
    numbers from -(2^(53)-1) to (2^(53)-1) are considered as safe integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` are constant values,
    introduced in ES6, representing (253-1) and -(253-1) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Number.EPSILON property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript uses binary floating-point representation with the result that computers
    fail to accurately represent numbers such as 0.1, 0.2, 0.3, and so on. When your
    code is executed, numbers such as 0.1 are rounded to the nearest number in that
    format, which results in a small rounding error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Number.EPSILON` property was introduced in ES6, and has a value of approximately
    2^(-52). This value represents a reasonable margin of error when comparing floating-point
    numbers. Using this number, we can create a custom function to compare floating-point
    numbers by ignoring the minimal rounding errors. The following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `epsilonEqual()` is the custom function that we build to compare whether
    the two values are equal or not. Now, the output is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Doing math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 and above add a lot of new methods to the `Math` object, related to trigonometry,
    arithmetic, and miscellaneous. This lets developers use native methods instead
    of external math libraries. Native methods are optimized for performance and have
    better decimal precision.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry-related operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often there is a need to use mathematical functions related to trigonometry,
    exponential, logarithmic, and so on. JavaScript provides native methods for that
    to make our work easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code, which shows all trigonometry-related methods that
    are added to the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic-related operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we discussed earlier, JavaScript also exposes some functions to perform
    logarithmic and exponential calculations, which are quite handy in a lot of situations
    (especially when you're creating games).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code, which shows all arithmetic-related methods added
    to the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Exponential operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES7 introduced a new way to perform an exponential calculation with JavaScript,
    that is, with a new `**` operator. If you''re coming from a Python background,
    you should immediately be able to relate to this. A single asterisk denotes multiplication;
    however, two together denote an exponential. `a**b` means `a` raised to the power
    `b`. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.pow` was earlier used to perform an exponential calculation. Now, `a**b`
    means multiply `a` `b` times with itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous math methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the day-to-day math methods and operators we looked at earlier, there
    are some *boring* methods as well, which are not really used all the time. However,
    if you're trying to build the next online scientific calculator, here is a list
    of functions you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.imul(number1, number2) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Math.imul()` function takes two numbers as 32-bit integers and multiplies
    them. It returns the lower 32 bits of the result. This is the only native way
    to do 32-bit integer multiplication in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, when multiplication was done, it produced a number so large it couldn't
    be stored in 32 bits; therefore, the lower bits were lost.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.clz32(number) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Math.clz32()` function returns the number of leading zero bits in the 32-bit
    representation of a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Math.clz32()` function is usually used in DSP algorithms to normalize samples
    in sound and video processing.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.sign(number) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Math.sign()` function returns the sign of a number, indicating whether
    the number is negative, positive, or zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that the `Math.sign()` function returns
    `1` if the number is positive, `-1` if the number is negative, and `0` if the
    number is zero.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.trunc(number) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Math.trunc()` function returns the integer part of a number by removing
    any fractional digit. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The Math.fround(number) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Math.fround()` function rounds a number to a 32-bit floating point value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6/ES7/ES8 provides new ways of creating strings and adds new properties to
    the global `String` object and to its instances to make working with strings easier.
    **Strings** in JavaScript lacked features and capabilities when compared with
    programming languages such as Python and Ruby; therefore, ES6 enhanced strings
    to change that.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into new string features, let's revise JavaScript's internal character
    encoding and escape sequences. In the Unicode character set, every character is
    represented by a base 10 decimal number called a code point. A code unit is a
    fixed number of bits in memory to store a code point. An encoding schema determines
    the length of code unit. A code unit is 8 bits if the UTF-8 encoding schema is
    used or 16 bits if the UTF-16 encoding schema is used. If a code point doesn't
    fit in a code unit, it is split into multiple code units, that is, multiple characters
    in a sequence representing a single character.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interpreters by default interpret JavaScript source code as a sequence
    of UTF-16 code units. If the source code is written in the UTF-8 encoding schema
    then there are various ways to tell the JavaScript interpreter to interpret it
    as a sequence of UTF-8 code units. JavaScript strings are always a sequence of
    UTF-16 code points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any Unicode character with a code point less than 65,536 can be escaped in
    a JavaScript string or source code using the hexadecimal value of its code point,
    prefixed with `\u`. Escapes are six characters long. They require exactly four
    characters following `\u`. If the hexadecimal character code is only one, two,
    or three characters long, you''ll need to pad it with leading zeroes. Here is
    an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The repeat(count) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `repeat()` method of a string constructs and returns a new string which
    contains the specified number of copies on which it was called, concatenated together.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The includes(string, index) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `includes()` method is used to find whether one string may be found in
    another string, returning `true` or `false` as appropriate. Here is an example
    to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The startsWith(string, index) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `startsWith()` method is used to find whether a string begins with the
    characters of another string, returning `true` or `false` as appropriate. Here
    is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The endsWith(string, index) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `endsWith()` method is used to find whether a string ends with the characters
    of another string, returning `true` or `false` as appropriate. It also takes an
    optional second parameter representing the position in the string that is assumed
    as the end of the string. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The indexOf(string) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Personally, 99% of the time, I use `indexOf` instead of `startsWith` or `endsWith`,
    `includes` , mainly because I''m very used to it and it''s very intuitive. This
    method will return you the position of your *first occurrence of*a substring passed,
    in the given string. If not present, it''ll return `-1`. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is because the substring is found at the 0^(th) position of the bigger
    string. If the substring is not present in the string, `indexOf` returns `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Can you come up with a replacement for the `startsWith` method in terms of `indexOf`?
    The following is the answer!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The lastIndexOf(string)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lastIndexOf` method does pretty much what `indexOf` does, but it will
    start your search for the substring from the last. So, `indexOf` returns the position
    of the first occurrence of the substring and `lastIndexOf` returns the last occurrence
    of the substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it might be a bit cumbersome to replace the `endsWith` string method
    with `lastIndexOf`, I still highly recommend you to give it a try and attempt
    to code it yourself. Once you''re ready with your solution, check the following
    answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The padStart(length [, padString])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES2017 (ES8) provides the `padStart()` method, which pads the given string with
    another given string to make the original string of the required length. The padding
    is done from the start of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no `padString` is passed, spaces are assumed by default. Take a look at
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs of each line will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that the length supplied in the `padStart` function will be the maximum
    length of the whole string. If the original string is already larger than the `padStart`
    supplied length, then no padding is applied at all.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as in the last example, if `padString` is longer than the required
    padding, `padString` is trimmed down, starting from leftmost portion, to the required
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible use case for this could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess the output for the following? Here''s the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This solution is tricky to achieve without the `padStart` function. You'll have
    to manually keep track of numbers somehow and realize when to append however many
    numbers of zero. Try to brainstorm an alternate solution without `padStart`.
  prefs: []
  type: TYPE_NORMAL
- en: The padEnd(length [, padString])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`padEnd` is similar to `padStart`. The difference, as the function name says,
    is that it''ll append the supplied padding string to the end of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following examples again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `padStart` and `padEnd` together, like:`"1".padStart(5, "*").padEnd(10,
    "*")` , to produce `****1****`.
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Template strings** are just a new literal for creating strings, which makes
    various things easier. They provide features such as embedded expressions, multiline
    strings, string interpolation, string formatting, string tagging, and so on. They
    are always processed and converted to a normal JavaScript string on runtime; therefore,
    they can be used wherever we use normal strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings are written using backticks instead of single or double quotes.
    Here is an example of a simple template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template strings also bring something called "expressions" to JavaScript. Earlier,
    there was no other choice than merely concatenating strings together. For example,
    to embed expressions within normal strings, you would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: However, now template strings make it much easier to embed expressions in strings.
    Template strings can contain expressions in them. The expressions are placed in
    placeholders indicated by a dollar sign and curly brackets, that is, `${expressions}`.
    The resolved value of expressions in the placeholders and the text between them
    is passed to a function to resolve the template string to a normal string. The
    default function just concatenates the parts into a single string. If we use a
    custom function to process the string parts, then the template string is called
    a **tagged template string** and the custom function is called a **tag function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to embed expressions in a template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Tagged template literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a tagged template string, that is, process the template string
    literal using a function. Let''s implement the tag function to do the same thing
    as the default function. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What just happened? Using a tag function, whatever you return is the final value
    assigned to the variable. The first argument, strings, contains all the *static*
    strings in your template literal, as an array. The elements are separated whenever
    an expression is found. Further arguments are the dynamic values you receive after
    resolving the expressions inside the template literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you modify the `aPLUSb` variable inside the `tag` function, then in
    the final result the value will be updated. Here''s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Multiline strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template strings provide a new way to create strings that contain multiple lines
    of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, we need to use the `\n` newline character to add new line breaks. Here
    is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, using a multiline string, we can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply included new lines where we needed to place
    `\n`. While converting the template string to the normal string, the new lines
    are converted to `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: Raw strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **raw string** is a normal string in which escaped characters aren''t interpreted.
    We can create a raw string using a template string. We can get a raw version of
    a template string using the `String.raw` tag function. Here is an example to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here `\n` is not interpreted as a newline character. Instead, it is a raw string
    consisting of two characters, that is, `\` and `n`. The length of variable `s`
    would be `6`. If you create a tagged function and you want to return the raw string,
    then use the raw property of the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw property is an array that holds raw versions of the strings of the
    first argument. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Escape sequence problem with template literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tagged templates are awesome! However, there are certain rules for escape sequences
    (if used) inside a template literal:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything starting with `\u` will be regarded as a Unicode escape sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything starting with `\x` will be regarded as a hexadecimal escape sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything starting with `\` and then a digit will be regarded as an octal escape
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, as of now, even with tagged templates, you cannot make use of languages
    such as LaTeX with template strings because of the syntax of these languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'LaTeX is a document preparation system usually used to write complicated equations,
    math formulas, and so on. Using an escape sequence such as *`E &= \frac{mc^2}{\sqrt{1-\frac{v^2}{c^2}}}`*
    would result in a fancy formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3cc77b2-f6be-40e0-b50d-49bcf2a6aea1.png).'
  prefs: []
  type: TYPE_NORMAL
- en: ES2018 that is the ES9 spec aims to resolve this.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some new properties added to the global `Array` object and to its
    instances to make working with arrays easier. Arrays in JavaScript lacked features
    and capabilities when compared with programming languages such as Python and Ruby.
    Let's take a look at some popular methods associated with arrays and their use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Array.from(iterable, mapFunc, this) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Array.from()` method creates a new array instance from an iterable object.
    The first argument is a reference to the iterable object. The second argument
    is optional and is a callback (known as the **Map function**) that is called for
    every element of the iterable object. The third argument is also optional and
    is the value of this inside the Map function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.from` would be extremely useful in converting an "array-like" structure
    to the actual array. For example, when working with the **Document Object Model** (**DOM**)
    (discussed in [Chapter 10](e281222c-b2ee-434a-a2ca-fc2648d01e3f.xhtml), *Storage
    APIs in JavaScript*), quite often, when you get hold of a lot of elements in the
    DOM tree, you''d like to use methods such as `forEach` on them. However, since
    methods such as`forEach` only exist for actual arrays, you cannot use them. But,
    once you convert that to an actual array with the `Array.from` method, you''re
    good to go. A dummy example would be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`arr.forEach` is wrong, as `arr` is not actually an array. It is "array-like"
    in structure (more on this later).'
  prefs: []
  type: TYPE_NORMAL
- en: The Array.of(values…) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Array.of()` method is an alternative to the `Array` constructor for creating
    arrays. When using the `Array` constructor, if we pass only one argument, that
    too a number, then the `Array` constructor constructs an empty array with the
    array length property equal to the passed number instead of creating an array
    of one element with that number in it. Therefore the `Array.of()` method was introduced
    to resolve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You should use `Array.of()` instead of an `Array` constructor when you are constructing
    a new array instance dynamically, that is when you don't know the type of values
    and the number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of browser showing [undefined, undefined], your browser might show [undefined
    x 2] or [empty x 2] as the output.
  prefs: []
  type: TYPE_NORMAL
- en: The fill(value, startIndex, endIndex) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fill()` method of an array fills all the elements of the array from `startIndex`
    to `endIndex` (not including `endIndex`) with a given value. Remember that the `startIndex`
    and `endIndex` arguments are optional; therefore, if they are not provided then
    the whole array is filled with the given value.
  prefs: []
  type: TYPE_NORMAL
- en: If only `startIndex` is provided then `endIndex` defaults to the length of the
    array minus 1\. If `startIndex` is negative then it's treated as the length of
    the array plus `startIndex`. If `endIndex` is negative, it is treated as the length
    of the array plus `endIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The includes() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `includes()` method returns `true` if a certain supplied element exists
    in an array, and returns `false` if it doesn't exist in that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simple enough to understand with just an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The includes() versus the indexOf() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like for strings, `indexOf` exists for arrays as well and as you expect,
    it''ll return the position of the element in the array. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'So what''s the difference? There''s not really a difference unless we talk
    about `NaN` and all that weird stuff. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This is because, under the hood, `indexOf` uses the equality check (`===`),
    which obviously fails on `NaN` , as discussed earlier. Therefore, `includes` is
    a better choice in the case of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The find(testingFunc) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `+` method of an array returns an array element if it satisfies the provided
    testing function. Otherwise, it returns undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` method takes two arguments; that is, the first argument is the
    testing function and the second argument is the value of this in the testing function.
    The second argument is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing function has three parameters: the first parameter is the array
    element being processed, the second parameter is the index of the current element
    being processed, and the third parameter is the array on which `find()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: The testing function needs to return `true` to satisfy a value. The `find()`
    method returns the first element which satisfies the provided testing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate the `find()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The findIndex(testingFunc) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `findIndex()` method is similar to the `find()` method. The `findIndex()`
    method returns the index of the satisfied array element instead of the element
    itself. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The output is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The copyWithin(targetIndex, startIndex, endIndex) function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `copyWithin()` method of an array is used to copy the sequence of values
    of the array to a different position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copyWithin()` method takes three arguments: the first argument represents
    the target index to which copy elements the second argument represents the index
    position from which start copying and the third argument represents the index,
    that is, where copying elements  should end.'
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is optional and if not provided then it defaults to *length-1,*
    where length is the length of the array. If `startIndex` is negative then it's
    calculated as *length+startIndex*. Similarly, if `endIndex` is negative then it's
    calculated as *length+endIndex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The entries(), keys(), and values() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `entries()` method of an array returns an iterable object that contains
    the key/value pairs for each index of the array. Similarly, the `keys()` method
    of an array returns an iterable object that contains keys for each of the indexes
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `values()` method of an array returns an iterable object that
    contains values of the array. The iterable object returned by the `entries()`
    method stores the key/value pairs in the form of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The iterable object returned by these functions is not an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`arr.values()` is still very experimental and not implemented in most browsers
    at the time of writing (November 2017).'
  prefs: []
  type: TYPE_NORMAL
- en: Array iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll find yourself iterating over arrays most of the time during development:
    arrays from REST APIs, arrays from user input, arrays from here, arrays from there.
    Therefore, it is essential to get hands-on with some important tools you can use
    to iterate over arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: The map() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `map()` method creates and returns a new array and passes every element
    of that array to the supplied function. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, when you run `map` on `arr`, every value is passed
    one by one into the supplied function. The value is contained as `num`. Since
    we're using the ES6 arrow function notation, everything looks extremely concise
    and neat.
  prefs: []
  type: TYPE_NORMAL
- en: The filter() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filter()` method creates a new array containing only the elements of a
    given array which pass a test defined by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the filter our supplied function always returns a Boolean.
    Whenever the inside function returns `true`, that particular element is included
    in `namesWithOnly4Letters`. Whenever it returns `false`, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: forEach() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `forEach()` method calls the given function for every element in the array.
    It is different from the `map` function because `map` creates a copy of the original
    array on the basis of what you return from the `map` function. But `foreach` simply
    runs a function on every element. It doesn't care about what you return from the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, when you want to just do a bunch of operations with the elements of
    an array, use `forEach`.
  prefs: []
  type: TYPE_NORMAL
- en: some() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `some()` method will check if any element in a given array passes a supplied
    test (with a function). If it finds an element which passes the test, it'll stop
    there and will not run further (and will return `true`). Otherwise, it'll return
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it stops at `10` once the test is passed.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **collection** is an object that stores multiple elements as a single unit.
    ES6 introduced various new collection objects to provide better ways of storing
    and organizing data.
  prefs: []
  type: TYPE_NORMAL
- en: The array was the only collection object available in ES5\. Now we have ArrayBuffers,
    SharedArrayBuffers, Typed Arrays, Sets, and Maps, which are built in collection
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the different collection objects provided in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elements of arrays can be of any type, such as strings, numbers, objects, and
    so on. Arrays can grow dynamically. The problem with arrays is that they are slow
    in terms of execution time and occupy more memory. This causes issues while developing
    applications that require too much computation and deal with plenty of numbers.
    Therefore array buffers were introduced to tackle this issue.
  prefs: []
  type: TYPE_NORMAL
- en: An **array buffer** is a collection of 8-bit blocks in memory. Every block is
    an array buffer element. The size of an array buffer needs to be decided while
    creating it; therefore, it cannot grow dynamically. Array buffers can only store
    numbers. All blocks are initialized to the number 0 on the creation of an array
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array buffer object is created using the `ArrayBuffer` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from and writing values into an `ArrayBuffer` object can be done using
    a `DateView` object. It''s not compulsory that only 8 bits are used to represent
    a number. We can use 8, 16, 32, and 64 bits to represent a number. Here is an
    example, which shows how to create a `DateView` object and read/write to an `ArrayBuffer`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a `DataView` object using the `DataView` constructor. A `DataView`
    object provides several methods to read and write numbers into an `ArrayBuffer`
    object. Here we used the `setInt32()` method, which uses 32 bits to store a provided
    number. All the methods of a `DataView` object that are used to write data to
    an `ArrayBuffer` object take three arguments. The first argument represents the
    offset, that is, the byte we want to write the number to. The second argument
    is the number to be stored. And the third argument is a Boolean type that represents
    the endian of the number like `false` represents a big-endian.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, all the methods of a `DataView` object that are used to read data
    from an `ArrayBuffer` object take two arguments. The first argument is the offset
    and the second argument represents the endian used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other functions for storing numbers provided by a `DataView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setInt8`: Uses 8 bits to store a number. It takes a signed integer (-ve or
    +ve).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUint8`: Uses 8 bits to store a number. It takes an unsigned integer (+ve).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setInt16`: Uses 16 bits to store a number. It takes a signed integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUint16`: Uses 16 bits to store a number. It takes an unsigned integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setInt32`: Uses 32 bits to store a number. It takes a signed integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUint32`: Uses 32 bits to store a number. It takes an unsigned integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFloat32`: Uses 32 bits to store a number. It takes a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFloat64`: Uses 64 bits to store a number. It takes a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are other functions for retrieving stored numbers by a `DataView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getInt8`: Reads 8 bits. Returns a signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUint8`: Reads 8 bits. Returns an unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInt16`: Reads 16 bits. Returns a signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUint16`: Reads 16 bits. Returns an unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInt32`: Reads 32 bits. Returns a signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUint32`: Reads 32 bits. Returns an unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFloat32`: Reads 32 bits. Returns a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFloat64`: Reads 64 bits. Returns a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to read and write numbers in array buffers. But the method was very
    cumbersome because we had to call a function every time. Typed arrays let us read
    and write to an `ArrayBuffer` object just like we do for normal arrays.
  prefs: []
  type: TYPE_NORMAL
- en: A **typed array** acts as a wrapper for an `ArrayBuffer` object and treats data
    from an `ArrayBuffer` object as a sequence of n-bit numbers. The `n` value depends
    on how we created the typed array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is a code example that demonstrates how to create an `ArrayBuffer` object
    and read/write to it using a typed array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a typed array using the `Float64Array` constructor. It, therefore,
    treats data in `ArrayBuffer` as a sequence of 64-bit signed decimal numbers. Here
    the `ArrayBuffer` object size was 640 bits; therefore, only 10 64-bit numbers
    can be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are other typed array constructors to represent data in `ArrayBuffer`
    as a sequence of different bit numbers. Here is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int8Array`: Represents 8-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`: Represents 8-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16Array`: Represents 16-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint16Array`: Represents 16-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int32Array`: Represents 32-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint32Array`: Represents 32-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float32Array`: Represents 32-bit signed decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float64Array`: Represents 64-bit signed decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays provide all the methods that are also provided by normal JavaScript
    arrays. They also implement the iterable protocol; therefore, they can be used
    as an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to use typed arrays in Chapter 12 - Shared memory and Atomics
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Set **is a collection of unique values of any data type. The values in
    a Set are arranged in insertion order. A Set is created using the `Set` constructor.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `set1` is an empty Set, whereas `set2` was created using values of an
    iterable object, that is, the characters of a string and the string, was not empty;
    therefore, `set2` is non-empty. The following example code demonstrates various
    operations that can be done on a Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Here we added nine items to the `Set` object but the size was only six because
    the Set automatically deletes duplicate values. The characters `l` and `!` were
    repeated multiple times. The `Set` object also implements the iterable protocol
    so they can be used as an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are used when you want to maintain a collection of values and check if
    a value exists instead of retrieving a value. For example, Sets can be used as
    an alternative to an array if you only use the `indexOf()` method of the array
    in your code to check if a value exists.
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the differences between `Set` and `WeakSet` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Set` can store primitive types and object references whereas a `WeakSet`
    object can only store object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important features `WeakSet` objects is that if there is no other reference
    to an object stored in a `WeakSet` object then they are garbage-collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, a `WeakSet` object is not enumerable: that is, you cannot find its
    size; it also doesn''t implement the iterable protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these three differences, `WeakSet` behaves exactly the same way as
    `Set`. Everything else apart from these three differences is same between a `Set`
    and `WeakSet` object.
  prefs: []
  type: TYPE_NORMAL
- en: A `WeakSet` object is created using the `WeakSet` constructor. You cannot pass
    an iterable object as an argument to a `WeakSet` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `WeakSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Map** is a collection of key/value pairs. Keys and values of a Map can be
    of any data type. Key/value pairs are arranged in insertion order. A `Map` object
    is created using the `Map` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, which demonstrates how to create a `Map` object and do
    various operations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: While creating a `Map` object from an iterable object, we need to make sure
    that the values returned by the iterable object are arrays, each of length `2`;
    that is, index `0` is the key and index `1` is the value.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to add a key that already exists then it's overwritten. `Map` objects
    also implement the iterable protocol and can therefore also be used as an iterable
    object. While iterating Maps using the iterable protocol, they return arrays with
    key/value pairs as you can see in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WeakMap`, as the name suggests, is an object in which keys are weakly referenced
    to the key/value pairs. That means that values can be anything. The keys are weakly
    referenced as keys are objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the differences between `Map` and `WeakMap` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Keys of a `Map` object can be of primitive types or object references but keys
    in a `WeakMap` object can only be object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of a  `WeakMap` object is that if there is no
    other reference to an object that is referenced by a key then the key is garbage-collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, a  `WeakMap` object is not enumerable, that is, you cannot find its
    size and it doesn't implement the iterable protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In every other particular, apart from these three differences `Map` and `WeakMap`
    objects are similar.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakMap` is created using a `WeakMap` constructor. Here is an example that
    demonstrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Objects** have existed in JavaScript for a long time. They form the backbone
    of JavaScript, as almost every data type can be associated with *objects.* (`new
    String()`, `new Number()`, `new Boolean()`, and so on). You''ll often find yourself
    working and manipulating objects all the time when working with web applications
    or JavaScript in general.'
  prefs: []
  type: TYPE_NORMAL
- en: ES6, ES2016 (ES7), and ES2017 (ES8) introduce a lot of new properties and methods
    associated with objects. Let us take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Object.values()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES8 introduced the `Object.values()` method so that a programmer can retrieve
    all the values of an object as an array. This was earlier possible by manually
    iterating over every property of the object and storing its value in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Object.entries()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Object.entries()` can be used to convert an object into a key/value pair in
    the form of an array. That means your object will be converted into a 2D array
    (at the simplest level), with each element being another array containing a key
    and value. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The __proto__ property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript objects have an internal `[[prototype]]` property that references
    the object''s prototype, that is, the object it inherits: the **prototypal inheritance
    model**, which JavaScript uses. To read the property, we had to use `Object.getPrototypeof()`
    and to create a new object with a given prototype, we had to use the `Object.create()`
    method. A `[[prototype]]` property cannot be directly read or be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting was cumbersome due to the nature of the `[[prototype]]` property;
    therefore, some browsers added a special `__proto__` property in objects, which
    is an accessor property that exposes the internal `[[prototype]]` property and
    makes working with prototypes easier. The `__proto__` property was not standardized
    in ES5, but due to its popularity, it was standardized in later versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Carefully observe:'
  prefs: []
  type: TYPE_NORMAL
- en: In the ES5 example, object `y` *inherits* from object `x`; therefore, when you
    simply use `console.log` on the object `y`, the properties it inherits from object
    `x` are not visible directly (or rather they are hidden). However, when you try
    to access `y.prop2`, JavaScript doesn't find it on object `y`, so it looks on
    the `__proto__` chain (which is how JavaScript is built to work) and finds that
    there is, in fact, a reference available for `prop2` on the proto chain. However,
    it was not possible to edit that directly in ES5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ES6/ES7/ES8/ES.next and onwards, you can directly add values to the prototype
    chain of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Object.is(value1, value2) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Object.is()` method determines whether two values are equal or not. It
    is similar to the `===` operator but there are some special cases for the `Object.is()`
    method. Here is an example that demonstrates special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here's a handy table you might want to look at for the differences between 0, ==,
    ===,and Object.is**:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c77be8d-f28d-4aa9-ab30-825303628f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While it might seem intuitive that `Object.is` can compare if two given objects
    are same, that is not the case. `x = {foo: 1}` and `y = {foo: 1}` are *not* same
    for all three operators (`==`, `===`, and `Object.is`).'
  prefs: []
  type: TYPE_NORMAL
- en: The Object.setPrototypeOf(object, prototype) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Object.setPrototypeOf()` method is just another way to assign the `[[prototype]]`
    property of an object, which we have just discussed. You can either use this method
    or directly work with the `__proto__` property. However, working with a method
    is a cleaner and easier-to-read approach. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The Object.assign(targetObj, sourceObjs…) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Object.assign()` method is used is used to copy the values of all enumerable
    own properties from one or more source objects to a target object. This method
    will return `targetObj`. Here is an example which demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of important things to keep in mind while using the `Object.assign()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: It invokes getters on the sources and setters on the target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It just assigns values of the properties of the source to the new or existing
    properties of the target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't copy the `[[prototype]]` property of sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript property names can be strings or symbols. `Object.assign()` copies
    both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property definitions are not copied from sources; therefore, you need to use
    `Object.getOwnPropertyDescriptor()` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ignores copying keys with null and undefined values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object.getOwnPropertyDescriptors()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduced in ES8, the `Object.getOwnPropertyDescriptors()` method will return
    all the property descriptors for a given object. What does that mean exactly?
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The output produced is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` function fires when you try to access the property (but when you
    also want to do a bunch of stuff first). So, when you do `details.food1`, `tasty` is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical usage of this is mostly in **Decorators** (which is a whole new
    topic) and creating a shallow clone, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about new features added in ES8, ES7, and ES6 for
    working with numbers, strings, arrays, and objects. We saw how arrays impact performance
    in math-rich applications and how array buffers can be used instead. We also walked
    through the new collection objects provided by ES8.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the Symbols and Iteration protocol,
    and we will also explore the `yield` keyword and generators. A lot of exciting
    and cutting-edge stuff is coming your way! Hold tight!
  prefs: []
  type: TYPE_NORMAL
