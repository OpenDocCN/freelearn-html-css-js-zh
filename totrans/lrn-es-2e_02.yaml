- en: Knowing Your Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解你的库
- en: ES6/ES7/ES8 has added lots of new properties and methods to built-in JavaScript
    objects. These new functionalities aim to help developers avoid using hacks and
    error-prone techniques to do various operations related to numbers, strings, and
    arrays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ES6/ES7/ES8向内置JavaScript对象添加了许多新的属性和方法。这些新功能旨在帮助开发者避免使用黑客和易出错的技巧来完成与数字、字符串和数组相关的各种操作。
- en: From the last chapter, you now know a decent amount of background details about
    JavaScript, how it works, its fundamentals, and basic stuff such as hoisting,
    scoping variables, and immutability. Now let's move on and take a look at some
    topics which you'll end up using practically all the time in your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，你现在对JavaScript有了相当多的背景知识，包括它是如何工作的、其基础以及诸如提升、变量作用域和不可变性等基本内容。现在让我们继续前进，看看一些你将在代码中实际使用的话题。
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The new properties and methods of the `Number`, `Object`, `Math`, and `Array`
    objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`、`Object`、`Math`和`Array`对象的新属性和方法'
- en: Representing numeric constants as binary or octal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字常量表示为二进制或八进制
- en: Creating multiline strings and the new methods of the `String` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多行字符串和`String`对象的新方法
- en: Maps and sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射和集合
- en: Using array buffers and typed arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组缓冲区和类型化数组
- en: How to iterate properly over arrays using some built-in methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用一些内置方法正确地遍历数组
- en: String padding, and more!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串填充，等等！
- en: Working with numbers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字
- en: ES6, ES2016 (ES7), and ES2017 (ES8) bring new ways of creating numbers and new
    properties to the `Number` object to make working with numbers easier. The `Number`
    object was enhanced greatly in ES6 to make it easier to create mathematically
    rich applications and prevent the common misconceptions that caused the errors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ES6、ES2016（ES7）和ES2017（ES8）带来了创建数字的新方法以及`Number`对象的新属性，使得处理数字更加容易。`Number`对象在ES6中得到了极大的增强，使其更容易创建数学丰富的应用程序并防止导致错误的常见误解。
- en: The binary notation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制表示法
- en: Earlier, there was no native way to represent numeric constants as binary. But
    now, you can prefix numeric constants using the `0b` token to make JavaScript
    interpret them as binary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，没有原生的方法来表示数字常量作为二进制。但现在，你可以使用`0b`前缀来前缀数字常量，使JavaScript将它们解释为二进制。
- en: 'Here is an example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `0b00001111` is a binary representation of `15`, base 10 decimal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`0b00001111`是十进制15的二进制表示。
- en: The octal notation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 八进制表示法
- en: The octal notation is a number system where we use only eight digits, that is,
    from 0 to 7\. You can represent a number in octal format with JavaScript if you
    like.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制表示法是一种仅使用八个数字的数制，即从0到7。如果你喜欢，你可以使用JavaScript以八进制格式表示一个数字。
- en: 'Earlier, to represent a numeric constant as octal, we needed to prefix the
    numeric constant using `0`. For example, take a look at the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，要表示数字常量作为八进制，我们需要使用`0`前缀。例如，看看以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But often, programmers new to JavaScript, get confused with octal representations
    and decimal numbers with `0` at the front. For example, they think `017` is the
    same as `17`. Therefore, to remove this confusion, JavaScript now allows us to
    prefix numeric constants using `00` to make JavaScript interpret them as octal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于JavaScript的新程序员来说，八进制表示法和以`0`开头的十进制数字常常会让他们感到困惑。例如，他们认为`017`和`17`是相同的。因此，为了消除这种困惑，JavaScript现在允许我们使用`00`前缀来前缀数字常量，使JavaScript将它们解释为八进制。
- en: 'Here is an example to demonstrate this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Number.isInteger(number) method
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Number.isInteger(number)`方法'
- en: JavaScript numbers are stored as 64-bit, floating-point numbers. So integers
    in JavaScript are floating-point numbers without a decimal fraction or a decimal
    fraction with all 0's.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的数字以64位浮点数的形式存储。因此，JavaScript中的整数是没有小数部分的浮点数，或者小数部分全是0的浮点数。
- en: In ES5, there was no built-in way to check whether a number is an integer or
    not. There exists a new method to the `Number` object called `isInteger()`, which
    takes a number and returns `true` or `false`, depending on whether the number
    is an integer or not.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，没有内置的方法来检查一个数字是否为整数。`Number`对象中存在一个新的方法`isInteger()`，它接受一个数字并返回`true`或`false`，这取决于该数字是否为整数。
- en: 'Here is an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Number.isNaN(value) method
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Number.isNaN(value)`方法'
- en: '`The Number.isNaN` function returns `true` *if and only if*the value equals
    `NaN`. Otherwise, in every other case, it returns `false`. That means it will
    *not* try to typecast something which is not a number, to a number (which usually
    results in `NaN` being returned).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.isNaN` 函数仅在值等于 `NaN` 时返回 `true`。在其他所有情况下，它都返回 `false`。这意味着它不会尝试将不是数字的东西类型转换为数字（这通常会导致返回
    `NaN`）。'
- en: 'Check the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下示例：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here you can see that the `Number.isNaN()` method returns `true` only if the
    passed value is exactly `NaN`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`Number.isNaN()` 方法仅在传入的值正好是 `NaN` 时返回 `true`。
- en: You might ask, why not use `==` or the `===` operator instead of the `Number.isNaN(value)`
    method? The `NaN` value is the only value that is not equal to itself, that is,
    the expression `NaN==NaN` or `NaN===NaN` will return `false`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么不使用 `==` 或 `===` 运算符而不是 `Number.isNaN(value)` 方法？`NaN` 值是唯一一个不等于自身的值，即表达式
    `NaN==NaN` 或 `NaN===NaN` 将返回 `false`。
- en: If you declare `x = NaN`, then `x` is not equal to itself!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明 `x = NaN`，那么 `x` 就不等于自身！
- en: isNaN versus Number.isNaN
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: isNaN 与 Number.isNaN
- en: To me, a method called `isNaN` should intuitively return `false` only on numbers
    and `true` on everything else. That is exactly what the `isNaN()` global method
    does. However, if you're looking to compare a value to `NaN` (which you cannot
    do with `===` or `==`), then `Number.isNaN` is your choice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，一个名为 `isNaN` 的方法应该直观地只在数字上返回 `false`，在其他所有情况下返回 `true`。这正是 `isNaN()` 全局方法所做的事情。然而，如果你想要将一个值与
    `NaN`（你不能使用 `===` 或 `==`）进行比较，那么 `Number.isNaN` 就是你的选择。
- en: 'For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In short, `isNaN` also tries to perform type conversion. That is why some developers
    consider it broken.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`isNaN` 也试图执行类型转换。这就是为什么一些开发者认为它是损坏的。
- en: The Number.isFinite(number) method
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Number.isFinite(number) 方法
- en: The global `isFinite()` function takes a value and checks whether it's a finite
    number or not. But unfortunately, it also returns `true` for values that convert
    to a `Number` type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `isFinite()` 函数接受一个值并检查它是否是有限数。但不幸的是，它也会对转换为 `Number` 类型的值返回 `true`。
- en: 'The `Number.isFinite()` method resolves the issue of the `window.isFinite()`
    function. Here is an example to demonstrate this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.isFinite()` 方法解决了 `window.isFinite()` 函数的问题。以下是一个示例来演示这一点：'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Number.isSafeInteger(number) method
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Number.isSafeInteger(number) 方法
- en: JavaScript numbers are stored as 64-bit floating-point numbers, following the
    international IEEE 754 standard. This format stores numbers in 64 bits, where
    the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62
    bits, and the sign in the last bit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的数字以 64 位浮点数的形式存储，遵循国际 IEEE 754 标准。这种格式使用 64 位存储数字，其中数字（分数）存储在 0
    到 51 位，指数在 52 到 62 位，符号在最后一位。
- en: So in JavaScript, safe integers are those numbers that do not need to be rounded
    to some other integer to fit in with the IEEE 754 representation. Mathematically,
    numbers from -(2^(53)-1) to (2^(53)-1) are considered as safe integers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 JavaScript 中，安全的整数是指那些不需要四舍五入到其他整数以适应 IEEE 754 表示的数字。从数学上讲，从 -(2^(53)-1)
    到 (2^(53)-1) 的数字被认为是安全的整数。
- en: 'Here is an example to demonstrate this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来演示这一点：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` are constant values,
    introduced in ES6, representing (253-1) and -(253-1) respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Number.MAX_SAFE_INTEGER` 和 `Number.MIN_SAFE_INTEGER` 是在 ES6 中引入的常量值，分别代表
    (2^53-1) 和 -(2^53-1)。
- en: The Number.EPSILON property
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Number.EPSILON 属性
- en: JavaScript uses binary floating-point representation with the result that computers
    fail to accurately represent numbers such as 0.1, 0.2, 0.3, and so on. When your
    code is executed, numbers such as 0.1 are rounded to the nearest number in that
    format, which results in a small rounding error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用二进制浮点数表示，结果导致计算机无法准确表示像 0.1、0.2、0.3 等这样的数字。当你的代码执行时，像 0.1 这样的数字会被四舍五入到该格式中最接近的数字，这会导致小的舍入误差。
- en: 'Consider this example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Number.EPSILON` property was introduced in ES6, and has a value of approximately
    2^(-52). This value represents a reasonable margin of error when comparing floating-point
    numbers. Using this number, we can create a custom function to compare floating-point
    numbers by ignoring the minimal rounding errors. The following example code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.EPSILON` 属性是在 ES6 中引入的，其值约为 2^(-52)。这个值表示在比较浮点数时合理的误差范围。使用这个数字，我们可以创建一个自定义函数来比较浮点数，同时忽略最小的舍入误差。以下示例代码：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `epsilonEqual()` is the custom function that we build to compare whether
    the two values are equal or not. Now, the output is as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`epsilonEqual()` 是我们构建的用于比较两个值是否相等的自定义函数。现在，输出符合预期。
- en: Doing math
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行数学运算
- en: ES6 and above add a lot of new methods to the `Math` object, related to trigonometry,
    arithmetic, and miscellaneous. This lets developers use native methods instead
    of external math libraries. Native methods are optimized for performance and have
    better decimal precision.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 及以上版本向 `Math` 对象添加了许多新方法，涉及三角学、算术和杂项。这使得开发者可以使用原生方法而不是外部数学库。原生方法针对性能进行了优化，并且具有更好的十进制精度。
- en: Trigonometry-related operations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与三角学相关的操作
- en: Often there is a need to use mathematical functions related to trigonometry,
    exponential, logarithmic, and so on. JavaScript provides native methods for that
    to make our work easy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要使用与三角学、指数、对数等相关联的数学函数。JavaScript 提供了原生方法来简化我们的工作。
- en: 'The following example code, which shows all trigonometry-related methods that
    are added to the `Math` object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码，展示了添加到 `Math` 对象的所有与三角学相关的方法：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Arithmetic-related operations
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与算术相关的操作
- en: Just as we discussed earlier, JavaScript also exposes some functions to perform
    logarithmic and exponential calculations, which are quite handy in a lot of situations
    (especially when you're creating games).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，JavaScript 也公开了一些用于执行对数和指数计算的函数，这在很多情况下都非常有用（尤其是在你创建游戏时）。
- en: 'The following example code, which shows all arithmetic-related methods added
    to the `Math` object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码，展示了添加到 `Math` 对象的所有与算术相关的方法：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Exponential operator
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数操作符
- en: 'ES7 introduced a new way to perform an exponential calculation with JavaScript,
    that is, with a new `**` operator. If you''re coming from a Python background,
    you should immediately be able to relate to this. A single asterisk denotes multiplication;
    however, two together denote an exponential. `a**b` means `a` raised to the power
    `b`. Take a look at the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ES7 引入了一种使用 JavaScript 执行指数计算的新方法，即使用新的 `**` 操作符。如果你来自 Python 背景，你应该能够立即联想到这一点。单个星号表示乘法；然而，两个一起表示指数。`a**b`
    表示 `a` 的 `b` 次幂。看看以下例子：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Math.pow` was earlier used to perform an exponential calculation. Now, `a**b`
    means multiply `a` `b` times with itself.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.pow` 之前用于执行指数计算。现在，`a**b` 表示将 `a` 乘以自身 `b` 次。'
- en: Miscellaneous math methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项数学方法
- en: Apart from the day-to-day math methods and operators we looked at earlier, there
    are some *boring* methods as well, which are not really used all the time. However,
    if you're trying to build the next online scientific calculator, here is a list
    of functions you should be aware of.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前讨论的日常数学方法和运算符之外，还有一些 *无聊* 的方法，并不总是被使用。然而，如果你正在尝试构建下一个在线科学计算器，这里有一份你应该了解的函数列表。
- en: The Math.imul(number1, number2) function
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Math.imul(number1, number2)` 函数'
- en: The `Math.imul()` function takes two numbers as 32-bit integers and multiplies
    them. It returns the lower 32 bits of the result. This is the only native way
    to do 32-bit integer multiplication in JavaScript.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.imul()` 函数将两个数字作为 32 位整数相乘，并返回结果的下 32 位。这是 JavaScript 中执行 32 位整数乘法的唯一原生方法。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, when multiplication was done, it produced a number so large it couldn't
    be stored in 32 bits; therefore, the lower bits were lost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当进行乘法运算时，产生了一个太大以至于无法存储在 32 位中的数字；因此，低位的数字丢失了。
- en: The Math.clz32(number) function
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Math.clz32(number)` 函数'
- en: The `Math.clz32()` function returns the number of leading zero bits in the 32-bit
    representation of a number.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.clz32()` 函数返回一个数字在 32 位表示中的前导零位数。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Math.clz32()` function is usually used in DSP algorithms to normalize samples
    in sound and video processing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.clz32()` 函数通常用于 DSP 算法中，用于在声音和视频处理中归一化样本。'
- en: The Math.sign(number) function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Math.sign(number)` 函数'
- en: The `Math.sign()` function returns the sign of a number, indicating whether
    the number is negative, positive, or zero.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.sign()` 函数返回一个数字的符号，指示数字是负数、正数还是零。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the preceding code, we can see that the `Math.sign()` function returns
    `1` if the number is positive, `-1` if the number is negative, and `0` if the
    number is zero.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到 `Math.sign()` 函数在数字为正时返回 `1`，在数字为负时返回 `-1`，在数字为零时返回 `0`。
- en: The Math.trunc(number) function
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math.trunc(number) 函数
- en: 'The `Math.trunc()` function returns the integer part of a number by removing
    any fractional digit. Here is an example to demonstrate this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.trunc()` 函数通过删除任何小数位来返回数字的整数部分。以下是一个示例来演示这一点：'
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Math.fround(number) function
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math.fround(number) 函数
- en: The `Math.fround()` function rounds a number to a 32-bit floating point value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.fround()` 函数将一个数字四舍五入到32位浮点值。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来演示这一点：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Working with strings
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: ES6/ES7/ES8 provides new ways of creating strings and adds new properties to
    the global `String` object and to its instances to make working with strings easier.
    **Strings** in JavaScript lacked features and capabilities when compared with
    programming languages such as Python and Ruby; therefore, ES6 enhanced strings
    to change that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ES6/ES7/ES8提供了创建字符串的新方法，并为全局 `String` 对象及其实例添加了新属性，以使处理字符串更容易。与Python和Ruby等编程语言相比，JavaScript中的**字符串**缺乏功能和能力；因此，ES6增强了字符串以改变这一点。
- en: Before we get into new string features, let's revise JavaScript's internal character
    encoding and escape sequences. In the Unicode character set, every character is
    represented by a base 10 decimal number called a code point. A code unit is a
    fixed number of bits in memory to store a code point. An encoding schema determines
    the length of code unit. A code unit is 8 bits if the UTF-8 encoding schema is
    used or 16 bits if the UTF-16 encoding schema is used. If a code point doesn't
    fit in a code unit, it is split into multiple code units, that is, multiple characters
    in a sequence representing a single character.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究新的字符串功能之前，让我们复习一下JavaScript的内部字符编码和转义序列。在Unicode字符集中，每个字符都由一个称为代码点的十进制基数表示。代码单元是内存中存储代码点的固定位数。编码方案决定了代码单元的长度。如果使用UTF-8编码方案，则代码单元是8位，如果使用UTF-16编码方案，则代码单元是16位。如果一个代码点不适合代码单元，它将被分成多个代码单元，即表示单个字符的序列中的多个字符。
- en: JavaScript interpreters by default interpret JavaScript source code as a sequence
    of UTF-16 code units. If the source code is written in the UTF-8 encoding schema
    then there are various ways to tell the JavaScript interpreter to interpret it
    as a sequence of UTF-8 code units. JavaScript strings are always a sequence of
    UTF-16 code points.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript解释器将JavaScript源代码解释为UTF-16代码单元的序列。如果源代码是用UTF-8编码方案编写的，那么有各种方法可以告诉JavaScript解释器将其解释为UTF-8代码单元的序列。JavaScript字符串始终是UTF-16代码点的序列。
- en: 'Any Unicode character with a code point less than 65,536 can be escaped in
    a JavaScript string or source code using the hexadecimal value of its code point,
    prefixed with `\u`. Escapes are six characters long. They require exactly four
    characters following `\u`. If the hexadecimal character code is only one, two,
    or three characters long, you''ll need to pad it with leading zeroes. Here is
    an example to demonstrate this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有小于65,536的代码点的Unicode字符都可以使用其代码点的十六进制值在JavaScript字符串或源代码中进行转义，前面加上 `\u`。转义序列是六个字符长。它们需要紧跟
    `\u` 的正好四个字符。如果十六进制字符代码只有一位、两位或三位，则需要用前导零填充它。以下是一个示例来演示这一点：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The repeat(count) method
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: repeat(count) 方法
- en: 'The `repeat()` method of a string constructs and returns a new string which
    contains the specified number of copies on which it was called, concatenated together.
    Here is an example to demonstrate this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的 `repeat()` 方法构建并返回一个新的字符串，该字符串包含在它被调用的指定数量的副本，并将它们连接在一起。以下是一个示例来演示这一点：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The includes(string, index) method
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: includes(string, index) 方法
- en: 'The `includes()` method is used to find whether one string may be found in
    another string, returning `true` or `false` as appropriate. Here is an example
    to demonstrate this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()` 方法用于检查一个字符串是否可以在另一个字符串中找到，根据适当的情况返回 `true` 或 `false`。以下是一个示例来演示这一点：'
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个可选的第二个参数，表示在字符串中开始搜索的位置。以下是一个示例来演示这一点：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The startsWith(string, index) method
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: startsWith(string, index) 方法
- en: 'The `startsWith()` method is used to find whether a string begins with the
    characters of another string, returning `true` or `false` as appropriate. Here
    is an example to demonstrate this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith()` 方法用于检查一个字符串是否以另一个字符串的字符开头，根据情况返回 `true` 或 `false`。以下是一个示例来演示这一点：'
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个可选的第二个参数，表示在字符串中开始搜索的位置。以下是一个示例来演示这一点：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The endsWith(string, index) function
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`endsWith(string, index)` 函数'
- en: 'The `endsWith()` method is used to find whether a string ends with the characters
    of another string, returning `true` or `false` as appropriate. It also takes an
    optional second parameter representing the position in the string that is assumed
    as the end of the string. Here is an example to demonstrate this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`endsWith()` 方法用于检查一个字符串是否以另一个字符串的字符结尾，根据情况返回 `true` 或 `false`。它还接受一个可选的第二个参数，表示假设为字符串末尾的位置。以下是一个示例来演示这一点：'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The indexOf(string) function
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`indexOf(string)` 函数'
- en: 'Personally, 99% of the time, I use `indexOf` instead of `startsWith` or `endsWith`,
    `includes` , mainly because I''m very used to it and it''s very intuitive. This
    method will return you the position of your *first occurrence of*a substring passed,
    in the given string. If not present, it''ll return `-1`. For instance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，99% 的时间，我使用 `indexOf` 而不是 `startsWith` 或 `endsWith`、`includes`，主要是因为我非常习惯于它，而且它非常直观。此方法将返回您在给定字符串中传递的子字符串的第一次出现的位置。如果不存在，则返回
    `-1`。例如：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is because the substring is found at the 0^(th) position of the bigger
    string. If the substring is not present in the string, `indexOf` returns `-1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为子字符串在较大字符串的 0^(th) 位置找到。如果子字符串不在字符串中，`indexOf` 返回 `-1`。
- en: Can you come up with a replacement for the `startsWith` method in terms of `indexOf`?
    The following is the answer!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否想出一个用 `indexOf` 替换 `startsWith` 方法的方案？以下就是答案！
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The lastIndexOf(string)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`lastIndexOf(string)`'
- en: 'The `lastIndexOf` method does pretty much what `indexOf` does, but it will
    start your search for the substring from the last. So, `indexOf` returns the position
    of the first occurrence of the substring and `lastIndexOf` returns the last occurrence
    of the substring:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndexOf` 方法基本上与 `indexOf` 做的事情相同，但它将从字符串的末尾开始搜索子字符串。因此，`indexOf` 返回子字符串第一次出现的位置，而
    `lastIndexOf` 返回子字符串最后一次出现的位置：'
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output from this is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出结果是：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Although it might be a bit cumbersome to replace the `endsWith` string method
    with `lastIndexOf`, I still highly recommend you to give it a try and attempt
    to code it yourself. Once you''re ready with your solution, check the following
    answer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用 `lastIndexOf` 替换 `endsWith` 字符串方法可能有点麻烦，但我仍然强烈建议你尝试自己实现它。一旦你准备好了你的解决方案，请检查以下答案：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The padStart(length [, padString])
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`padStart(length [, padString])`'
- en: ES2017 (ES8) provides the `padStart()` method, which pads the given string with
    another given string to make the original string of the required length. The padding
    is done from the start of the string.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017 (ES8) 提供了 `padStart()` 方法，该方法使用另一个给定的字符串填充给定的字符串，以使原始字符串达到所需的长度。填充是从字符串的开始进行的。
- en: 'If no `padString` is passed, spaces are assumed by default. Take a look at
    the following examples:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递 `padString`，则默认使用空格。请看以下示例：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The outputs of each line will be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的输出结果将是：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the length supplied in the `padStart` function will be the maximum
    length of the whole string. If the original string is already larger than the `padStart`
    supplied length, then no padding is applied at all.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`padStart` 函数中提供的长度将是整个字符串的最大长度。如果原始字符串已经大于 `padStart` 提供的长度，则根本不应用填充。
- en: Similarly, as in the last example, if `padString` is longer than the required
    padding, `padString` is trimmed down, starting from leftmost portion, to the required
    length.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上一个示例，如果 `padString` 的长度超过了所需的填充长度，`padString` 将从最左侧部分开始被截断，直到达到所需的长度。
- en: 'A possible use case for this could be:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的一个可能案例是：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Can you guess the output for the following? Here''s the answer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出以下输出的结果吗？这里是答案：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This solution is tricky to achieve without the `padStart` function. You'll have
    to manually keep track of numbers somehow and realize when to append however many
    numbers of zero. Try to brainstorm an alternate solution without `padStart`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `padStart` 函数，要实现这个解决方案是相当棘手的。您必须以某种方式手动跟踪数字，并意识到何时需要附加多少个零。尝试在没有 `padStart`
    的情况下想出一个替代方案。
- en: The padEnd(length [, padString])
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`padEnd(length [, padString])`'
- en: '`padEnd` is similar to `padStart`. The difference, as the function name says,
    is that it''ll append the supplied padding string to the end of the string.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`padEnd`与`padStart`类似。区别，正如函数名所说，是它会在字符串的末尾附加提供的填充字符串。'
- en: 'Consider the following examples again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑以下示例：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output for this is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果是：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can also use `padStart` and `padEnd` together, like:`"1".padStart(5, "*").padEnd(10,
    "*")` , to produce `****1****`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以一起使用`padStart`和`padEnd`，例如：`"1".padStart(5, "*").padEnd(10, "*")`，以生成`****1****`。
- en: Template strings
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字符串
- en: '**Template strings** are just a new literal for creating strings, which makes
    various things easier. They provide features such as embedded expressions, multiline
    strings, string interpolation, string formatting, string tagging, and so on. They
    are always processed and converted to a normal JavaScript string on runtime; therefore,
    they can be used wherever we use normal strings.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板字符串**只是创建字符串的新字面量，这使得许多事情变得容易。它们提供了嵌入表达式、多行字符串、字符串插值、字符串格式化、字符串标记等功能。它们总是在运行时被处理和转换为普通JavaScript字符串；因此，它们可以在我们使用普通字符串的任何地方使用。'
- en: 'Template strings are written using backticks instead of single or double quotes.
    Here is an example of a simple template string:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串使用反引号而不是单引号或双引号来编写。以下是一个简单模板字符串的示例：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Expressions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Template strings also bring something called "expressions" to JavaScript. Earlier,
    there was no other choice than merely concatenating strings together. For example,
    to embed expressions within normal strings, you would do something like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串还把所谓的“表达式”带到了JavaScript中。之前，除了简单地连接字符串外别无选择。例如，要在普通字符串中嵌入表达式，你会这样做：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: However, now template strings make it much easier to embed expressions in strings.
    Template strings can contain expressions in them. The expressions are placed in
    placeholders indicated by a dollar sign and curly brackets, that is, `${expressions}`.
    The resolved value of expressions in the placeholders and the text between them
    is passed to a function to resolve the template string to a normal string. The
    default function just concatenates the parts into a single string. If we use a
    custom function to process the string parts, then the template string is called
    a **tagged template string** and the custom function is called a **tag function**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在模板字符串使得在字符串中嵌入表达式变得容易得多。模板字符串可以包含表达式。这些表达式放置在由美元符号和大括号指示的占位符中，即`${expressions}`。占位符中表达式的解析值以及它们之间的文本被传递给一个函数，以解析模板字符串为普通字符串。默认函数只是将部分连接成一个单一的字符串。如果我们使用自定义函数来处理字符串部分，那么模板字符串被称为**标记模板字符串**，而自定义函数被称为**标记函数**。
- en: 'Here is an example that shows how to embed expressions in a template string:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何在模板字符串中嵌入表达式：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tagged template literals
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记模板字面量
- en: 'Let''s create a tagged template string, that is, process the template string
    literal using a function. Let''s implement the tag function to do the same thing
    as the default function. Here is an example to demonstrate this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个标记模板字符串，即使用一个函数来处理模板字符串字面量。让我们实现标记函数来执行与默认函数相同的事情。以下是一个演示此功能的示例：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What just happened? Using a tag function, whatever you return is the final value
    assigned to the variable. The first argument, strings, contains all the *static*
    strings in your template literal, as an array. The elements are separated whenever
    an expression is found. Further arguments are the dynamic values you receive after
    resolving the expressions inside the template literal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？使用标记函数，你返回的任何内容都是分配给变量的最终值。第一个参数，strings，包含你模板字面量中的所有**静态**字符串，作为一个数组。元素在找到表达式时被分隔。后续参数是在解析模板字面量中的表达式后收到的动态值。
- en: 'So, if you modify the `aPLUSb` variable inside the `tag` function, then in
    the final result the value will be updated. Here''s what I mean:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你在`tag`函数中修改`aPLUSb`变量，那么在最终结果中值将被更新。我的意思是：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now the output is:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出是：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Multiline strings
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多行字符串
- en: Template strings provide a new way to create strings that contain multiple lines
    of text.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串提供了一种创建包含多行文本的字符串的新方法。
- en: 'In ES5, we need to use the `\n` newline character to add new line breaks. Here
    is an example to demonstrate this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，我们需要使用`\n`换行符来添加新行。以下是一个演示此功能的示例：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In ES6, using a multiline string, we can simply write:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，使用多行字符串，我们可以简单地写：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, we simply included new lines where we needed to place
    `\n`. While converting the template string to the normal string, the new lines
    are converted to `\n`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是在需要放置 `\n` 的地方添加了新行。在将模板字符串转换为普通字符串时，新行会被转换为 `\n`。
- en: Raw strings
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始字符串
- en: 'A **raw string** is a normal string in which escaped characters aren''t interpreted.
    We can create a raw string using a template string. We can get a raw version of
    a template string using the `String.raw` tag function. Here is an example to demonstrate
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始字符串** 是一种普通字符串，其中转义字符不会被解释。我们可以使用模板字符串创建原始字符串。我们可以使用 `String.raw` 标签函数获取模板字符串的原始版本。以下是一个示例来演示这一点：'
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here `\n` is not interpreted as a newline character. Instead, it is a raw string
    consisting of two characters, that is, `\` and `n`. The length of variable `s`
    would be `6`. If you create a tagged function and you want to return the raw string,
    then use the raw property of the first argument.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `\n` 不会被解释为换行符。相反，它是一个由两个字符组成的原始字符串，即 `\` 和 `n`。变量 `s` 的长度将是 `6`。如果你创建了一个标签函数并希望返回原始字符串，那么请使用第一个参数的原始属性。
- en: 'The raw property is an array that holds raw versions of the strings of the
    first argument. Here is an example to demonstrate this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 原始属性是一个数组，它包含第一个参数的字符串的原始版本。以下是一个示例来演示这一点：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Escape sequence problem with template literals
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字面量中的转义序列问题
- en: 'Tagged templates are awesome! However, there are certain rules for escape sequences
    (if used) inside a template literal:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 标签模板很棒！然而，在模板字面量内部（如果使用）的转义序列有一些规则：
- en: Anything starting with `\u` will be regarded as a Unicode escape sequence
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `\u` 开头的任何内容都将被视为 Unicode 转义序列
- en: Anything starting with `\x` will be regarded as a hexadecimal escape sequence
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `\x` 开头的任何内容都将被视为十六进制转义序列
- en: Anything starting with `\` and then a digit will be regarded as an octal escape
    sequence
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `\` 开头然后跟一个数字的任何内容都将被视为八进制转义序列
- en: Therefore, as of now, even with tagged templates, you cannot make use of languages
    such as LaTeX with template strings because of the syntax of these languages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，截至目前，即使有标签模板，由于这些语言的语法，也无法在模板字符串中使用如 LaTeX 这样的语言。
- en: 'LaTeX is a document preparation system usually used to write complicated equations,
    math formulas, and so on. Using an escape sequence such as *`E &= \frac{mc^2}{\sqrt{1-\frac{v^2}{c^2}}}`*
    would result in a fancy formula:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: LaTeX 是一种文档准备系统，通常用于编写复杂的方程、数学公式等。使用如 *`E &= \frac{mc^2}{\sqrt{1-\frac{v^2}{c^2}}}`*
    这样的转义序列将生成一个花哨的公式：
- en: '![](img/a3cc77b2-f6be-40e0-b50d-49bcf2a6aea1.png).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/a3cc77b2-f6be-40e0-b50d-49bcf2a6aea1.png).'
- en: ES2018 that is the ES9 spec aims to resolve this.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ES2018（即 ES9 规范）旨在解决这个问题。
- en: Arrays
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: There are some new properties added to the global `Array` object and to its
    instances to make working with arrays easier. Arrays in JavaScript lacked features
    and capabilities when compared with programming languages such as Python and Ruby.
    Let's take a look at some popular methods associated with arrays and their use
    cases.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 向全局 `Array` 对象及其实例添加了一些新属性，以便更容易地处理数组。与 Python 和 Ruby 等编程语言相比，JavaScript 中的数组在功能和能力方面缺乏。让我们看看一些与数组相关且用途广泛的流行方法。
- en: The Array.from(iterable, mapFunc, this) method
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Array.from(iterable, mapFunc, this) 方法
- en: The `Array.from()` method creates a new array instance from an iterable object.
    The first argument is a reference to the iterable object. The second argument
    is optional and is a callback (known as the **Map function**) that is called for
    every element of the iterable object. The third argument is also optional and
    is the value of this inside the Map function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()` 方法从一个可迭代对象创建一个新的数组实例。第一个参数是可迭代对象的引用。第二个参数是可选的，是一个回调函数（称为 **Map
    函数**），它会对可迭代对象的每个元素进行调用。第三个参数也是可选的，是 Map 函数内部的值。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来演示这一点：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output is:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`Array.from` would be extremely useful in converting an "array-like" structure
    to the actual array. For example, when working with the **Document Object Model** (**DOM**)
    (discussed in [Chapter 10](e281222c-b2ee-434a-a2ca-fc2648d01e3f.xhtml), *Storage
    APIs in JavaScript*), quite often, when you get hold of a lot of elements in the
    DOM tree, you''d like to use methods such as `forEach` on them. However, since
    methods such as`forEach` only exist for actual arrays, you cannot use them. But,
    once you convert that to an actual array with the `Array.from` method, you''re
    good to go. A dummy example would be like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from` 在将“类似数组”结构转换为实际数组时非常有用。例如，当处理**文档对象模型**（**DOM**）时（如第10章所述，*JavaScript中的存储API*），当你从DOM树中获取大量元素时，你可能会希望使用诸如`forEach`之类的函数。然而，由于`forEach`之类的函数仅存在于实际数组中，因此你不能使用它们。但是，一旦你使用`Array.from`方法将其转换为实际数组，你就可以顺利使用了。一个简单的例子如下：'
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`arr.forEach` is wrong, as `arr` is not actually an array. It is "array-like"
    in structure (more on this later).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.forEach`是错误的，因为`arr`实际上不是一个数组。它在结构上是“类似数组”的（关于这一点稍后还会讨论）。'
- en: The Array.of(values…) method
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Array.of(values…)`方法'
- en: The `Array.of()` method is an alternative to the `Array` constructor for creating
    arrays. When using the `Array` constructor, if we pass only one argument, that
    too a number, then the `Array` constructor constructs an empty array with the
    array length property equal to the passed number instead of creating an array
    of one element with that number in it. Therefore the `Array.of()` method was introduced
    to resolve this issue.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.of()`方法是为创建数组而提供的`Array`构造函数的替代方案。当使用`Array`构造函数时，如果我们只传递一个参数，而且这个参数也是一个数字，那么`Array`构造函数将创建一个空数组，其数组长度属性等于传递的数字，而不是创建一个包含该数字的单元素数组。因此，引入了`Array.of()`方法来解决这个问题。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You should use `Array.of()` instead of an `Array` constructor when you are constructing
    a new array instance dynamically, that is when you don't know the type of values
    and the number of elements.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你动态构建一个新的数组实例时，应该使用`Array.of()`而不是`Array`构造函数，即当你不知道值的类型和元素数量时。
- en: Instead of browser showing [undefined, undefined], your browser might show [undefined
    x 2] or [empty x 2] as the output.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是浏览器显示[undefined, undefined]，你的浏览器可能会显示[undefined x 2]或[empty x 2]作为输出。
- en: The fill(value, startIndex, endIndex) method
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`fill(value, startIndex, endIndex)`方法'
- en: The `fill()` method of an array fills all the elements of the array from `startIndex`
    to `endIndex` (not including `endIndex`) with a given value. Remember that the `startIndex`
    and `endIndex` arguments are optional; therefore, if they are not provided then
    the whole array is filled with the given value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`fill()`方法从`startIndex`到`endIndex`（不包括`endIndex`）用给定的值填充数组中的所有元素。请记住，`startIndex`和`endIndex`参数是可选的；因此，如果它们没有提供，则整个数组将用给定的值填充。
- en: If only `startIndex` is provided then `endIndex` defaults to the length of the
    array minus 1\. If `startIndex` is negative then it's treated as the length of
    the array plus `startIndex`. If `endIndex` is negative, it is treated as the length
    of the array plus `endIndex`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只提供了`startIndex`，则`endIndex`默认为数组长度减1。如果`startIndex`为负数，则视为数组长度加上`startIndex`。如果`endIndex`为负数，则视为数组长度加上`endIndex`。
- en: 'Here is an example to demonstrate this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The includes() method
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`includes()`方法'
- en: The `includes()` method returns `true` if a certain supplied element exists
    in an array, and returns `false` if it doesn't exist in that array.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()`方法如果某个指定的元素存在于数组中，则返回`true`；如果不存在，则返回`false`。'
- en: 'This is simple enough to understand with just an example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点仅用一个例子就足够简单易懂了：
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The includes() versus the indexOf() method
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`includes()`与`indexOf()`方法的比较'
- en: 'Just like for strings, `indexOf` exists for arrays as well and as you expect,
    it''ll return the position of the element in the array. Take a look:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串一样，`indexOf`也存在于数组中，正如你所期望的，它将返回元素在数组中的位置。看看这个例子：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So what''s the difference? There''s not really a difference unless we talk
    about `NaN` and all that weird stuff. For instance:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它们之间有什么区别呢？除非我们谈论`NaN`和所有那些奇怪的东西，否则实际上并没有区别。例如：
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is because, under the hood, `indexOf` uses the equality check (`===`),
    which obviously fails on `NaN` , as discussed earlier. Therefore, `includes` is
    a better choice in the case of arrays.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在底层，`indexOf`使用的是等价检查（`===`），正如之前讨论的那样，这显然在`NaN`上失败。因此，在数组的情况下，`includes`是一个更好的选择。
- en: The find(testingFunc) method
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`find(testingFunc)`方法'
- en: The `+` method of an array returns an array element if it satisfies the provided
    testing function. Otherwise, it returns undefined.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`+`方法如果满足提供的测试函数，则返回一个数组元素。否则，返回`undefined`。
- en: The `find()` method takes two arguments; that is, the first argument is the
    testing function and the second argument is the value of this in the testing function.
    The second argument is optional.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`方法接受两个参数；也就是说，第一个参数是测试函数，第二个参数是测试函数中的这个值的值。第二个参数是可选的。'
- en: 'The testing function has three parameters: the first parameter is the array
    element being processed, the second parameter is the index of the current element
    being processed, and the third parameter is the array on which `find()` is called.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数有三个参数：第一个参数是正在处理的数组元素，第二个参数是正在处理的当前元素的索引，第三个参数是调用`find()`的数组。
- en: The testing function needs to return `true` to satisfy a value. The `find()`
    method returns the first element which satisfies the provided testing function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数需要返回`true`以满足一个值。`find()`方法返回满足提供的测试函数的第一个元素。
- en: 'Here is an example to demonstrate the `find()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示`find()`方法：
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The findIndex(testingFunc) method
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findIndex(testingFunc)`方法'
- en: 'The `findIndex()` method is similar to the `find()` method. The `findIndex()`
    method returns the index of the satisfied array element instead of the element
    itself. Take a look at this example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIndex()`方法与`find()`方法类似。`findIndex()`方法返回满足条件的数组元素的索引，而不是元素本身。看看这个例子：'
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The output is `1`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`1`。
- en: The copyWithin(targetIndex, startIndex, endIndex) function
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`copyWithin(targetIndex, startIndex, endIndex)`函数'
- en: The `copyWithin()` method of an array is used to copy the sequence of values
    of the array to a different position in the array.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`copyWithin()`方法用于将数组的值序列复制到数组中的不同位置。
- en: 'The `copyWithin()` method takes three arguments: the first argument represents
    the target index to which copy elements the second argument represents the index
    position from which start copying and the third argument represents the index,
    that is, where copying elements  should end.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithin()`方法接受三个参数：第一个参数表示要复制元素的目标索引，第二个参数表示开始复制的索引位置，第三个参数表示索引，即复制元素应该结束的位置。'
- en: The third argument is optional and if not provided then it defaults to *length-1,*
    where length is the length of the array. If `startIndex` is negative then it's
    calculated as *length+startIndex*. Similarly, if `endIndex` is negative then it's
    calculated as *length+endIndex*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是可选的，如果没有提供，则默认为`length-1`，其中`length`是数组的长度。如果`startIndex`是负数，则计算为`length+startIndex`。同样，如果`endIndex`是负数，则计算为`length+endIndex`。
- en: 'Here is an example to demonstrate this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The entries(), keys(), and values() methods
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`entries()`、`keys()`和`values()`方法'
- en: The `entries()` method of an array returns an iterable object that contains
    the key/value pairs for each index of the array. Similarly, the `keys()` method
    of an array returns an iterable object that contains keys for each of the indexes
    in the array.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`entries()`方法返回一个可迭代对象，它包含数组的每个索引的键/值对。同样，数组的`keys()`方法返回一个可迭代对象，它包含数组中每个索引的键。
- en: Similarly, the `values()` method of an array returns an iterable object that
    contains values of the array. The iterable object returned by the `entries()`
    method stores the key/value pairs in the form of arrays.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，数组的`values()`方法返回一个可迭代对象，它包含数组的值。`entries()`方法返回的可迭代对象以数组的形式存储键/值对。
- en: The iterable object returned by these functions is not an array.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回的可迭代对象不是一个数组。
- en: 'Here is an example to demonstrate this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`arr.values()` is still very experimental and not implemented in most browsers
    at the time of writing (November 2017).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.values()`在写作时（2017年11月）仍然非常实验性，并且大多数浏览器中尚未实现。'
- en: Array iteration
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组迭代
- en: 'You''ll find yourself iterating over arrays most of the time during development:
    arrays from REST APIs, arrays from user input, arrays from here, arrays from there.
    Therefore, it is essential to get hands-on with some important tools you can use
    to iterate over arrays.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你大部分时间都会在迭代数组：来自REST API的数组、来自用户输入的数组、来自这里的数组、来自那里的数组。因此，掌握一些你可以用来迭代数组的重要工具是至关重要的。
- en: The map() method
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map()`方法'
- en: 'The `map()` method creates and returns a new array and passes every element
    of that array to the supplied function. Take a look at this example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`方法创建并返回一个新数组，并将该数组的每个元素传递给提供的函数。看看这个例子：'
- en: '[PRE84]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the preceding function, when you run `map` on `arr`, every value is passed
    one by one into the supplied function. The value is contained as `num`. Since
    we're using the ES6 arrow function notation, everything looks extremely concise
    and neat.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，当你对`arr`运行`map`时，每个值都会逐个传递给提供的函数。值包含为`num`。由于我们使用ES6箭头函数表示法，一切看起来都非常简洁和整洁。
- en: The filter() method
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: filter()方法
- en: The `filter()` method creates a new array containing only the elements of a
    given array which pass a test defined by the programmer.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`方法创建一个新数组，只包含通过程序员定义的测试的给定数组中的元素。'
- en: 'For example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, in the filter our supplied function always returns a Boolean.
    Whenever the inside function returns `true`, that particular element is included
    in `namesWithOnly4Letters`. Whenever it returns `false`, it is not.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在`filter`中，我们提供的函数始终返回一个布尔值。每当内部函数返回`true`时，该特定元素就会包含在`namesWithOnly4Letters`中。每当它返回`false`时，它就不会包含。
- en: forEach() method
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: forEach()方法
- en: The `forEach()` method calls the given function for every element in the array.
    It is different from the `map` function because `map` creates a copy of the original
    array on the basis of what you return from the `map` function. But `foreach` simply
    runs a function on every element. It doesn't care about what you return from the
    function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`方法会对数组中的每个元素调用给定的函数。它与`map`函数不同，因为`map`函数基于从`map`函数返回的内容创建原始数组的副本。但`forEach`只是对每个元素运行一个函数。它不关心你从函数返回什么。'
- en: 'Take a look at this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个：
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE89]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Clearly, when you want to just do a bunch of operations with the elements of
    an array, use `forEach`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你只想对数组的元素执行一系列操作时，使用`forEach`。
- en: some() method
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: some()方法
- en: The `some()` method will check if any element in a given array passes a supplied
    test (with a function). If it finds an element which passes the test, it'll stop
    there and will not run further (and will return `true`). Otherwise, it'll return
    `false`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`some()`方法将检查给定数组中的任何元素是否通过提供的测试（使用函数）。如果它找到一个通过测试的元素，它就会停止，不会运行进一步（并返回`true`）。否则，它将返回`false`。'
- en: 'Here''s an example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Notice that it stops at `10` once the test is passed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦测试通过，它就会停止在`10`。
- en: Collections
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A **collection** is an object that stores multiple elements as a single unit.
    ES6 introduced various new collection objects to provide better ways of storing
    and organizing data.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是一个将多个元素存储为单一单元的对象。ES6引入了各种新的集合对象，以提供更好的存储和组织数据的方法。'
- en: The array was the only collection object available in ES5\. Now we have ArrayBuffers,
    SharedArrayBuffers, Typed Arrays, Sets, and Maps, which are built in collection
    objects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，数组是唯一的集合对象。现在我们有ArrayBuffers、SharedArrayBuffers、Typed Arrays、Sets和Maps，这些都是内置的集合对象。
- en: Let's explore the different collection objects provided in JavaScript.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索JavaScript中提供的不同集合对象。
- en: ArrayBuffer
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayBuffer
- en: Elements of arrays can be of any type, such as strings, numbers, objects, and
    so on. Arrays can grow dynamically. The problem with arrays is that they are slow
    in terms of execution time and occupy more memory. This causes issues while developing
    applications that require too much computation and deal with plenty of numbers.
    Therefore array buffers were introduced to tackle this issue.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的元素可以是任何类型，例如字符串、数字、对象等。数组可以动态增长。数组的问题在于它们在执行时间上较慢，并且占用更多内存。这导致在开发需要大量计算和处理大量数字的应用程序时出现问题。因此，引入了数组缓冲区来解决这个问题。
- en: An **array buffer** is a collection of 8-bit blocks in memory. Every block is
    an array buffer element. The size of an array buffer needs to be decided while
    creating it; therefore, it cannot grow dynamically. Array buffers can only store
    numbers. All blocks are initialized to the number 0 on the creation of an array
    buffer.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组缓冲区**是内存中8位块的集合。每个块都是一个数组缓冲区元素。数组缓冲区的大小在创建时需要确定；因此，它不能动态增长。数组缓冲区只能存储数字。所有块在创建数组缓冲区时都初始化为数字0。'
- en: 'An array buffer object is created using the `ArrayBuffer` constructor:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ArrayBuffer`构造函数创建数组缓冲区对象：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Reading from and writing values into an `ArrayBuffer` object can be done using
    a `DateView` object. It''s not compulsory that only 8 bits are used to represent
    a number. We can use 8, 16, 32, and 64 bits to represent a number. Here is an
    example, which shows how to create a `DateView` object and read/write to an `ArrayBuffer`
    object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DateView`对象可以从`ArrayBuffer`对象中读取值并写入值。不强制使用8位来表示一个数字。我们可以使用8位、16位、32位和64位来表示一个数字。以下是一个示例，展示了如何创建`DateView`对象并读取/写入`ArrayBuffer`对象：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here we created a `DataView` object using the `DataView` constructor. A `DataView`
    object provides several methods to read and write numbers into an `ArrayBuffer`
    object. Here we used the `setInt32()` method, which uses 32 bits to store a provided
    number. All the methods of a `DataView` object that are used to write data to
    an `ArrayBuffer` object take three arguments. The first argument represents the
    offset, that is, the byte we want to write the number to. The second argument
    is the number to be stored. And the third argument is a Boolean type that represents
    the endian of the number like `false` represents a big-endian.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`DataView`构造函数创建了一个`DataView`对象。`DataView`对象提供了几种方法来将数字读入和写入`ArrayBuffer`对象。这里我们使用了`setInt32()`方法，它使用32位来存储提供的数字。所有用于将数据写入`ArrayBuffer`对象的`DataView`对象的方法都接受三个参数。第一个参数表示偏移量，即我们想要写入数字的字节。第二个参数是要存储的数字。第三个参数是一个布尔类型，表示数字的端序，例如`false`表示大端序。
- en: Similarly, all the methods of a `DataView` object that are used to read data
    from an `ArrayBuffer` object take two arguments. The first argument is the offset
    and the second argument represents the endian used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，所有用于从`ArrayBuffer`对象读取数据的`DataView`对象的方法都接受两个参数。第一个参数是偏移量，第二个参数表示使用的端序。
- en: 'Here are other functions for storing numbers provided by a `DataView` object:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`DataView`对象提供的其他存储数字的函数：
- en: '`setInt8`: Uses 8 bits to store a number. It takes a signed integer (-ve or
    +ve).'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInt8`: 使用8位来存储一个数字。它接受一个有符号整数（负数或正数）。'
- en: '`setUint8`: Uses 8 bits to store a number. It takes an unsigned integer (+ve).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUint8`: 使用8位来存储一个数字。它接受一个无符号整数（正数）。'
- en: '`setInt16`: Uses 16 bits to store a number. It takes a signed integer.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInt16`: 使用16位来存储一个数字。它接受一个有符号整数。'
- en: '`setUint16`: Uses 16 bits to store a number. It takes an unsigned integer.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUint16`: 使用16位来存储一个数字。它接受一个无符号整数。'
- en: '`setInt32`: Uses 32 bits to store a number. It takes a signed integer.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInt32`: 使用32位来存储一个数字。它接受一个有符号整数。'
- en: '`setUint32`: Uses 32 bits to store a number. It takes an unsigned integer.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUint32`: 使用32位来存储一个数字。它接受一个无符号整数。'
- en: '`setFloat32`: Uses 32 bits to store a number. It takes a signed decimal number.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFloat32`: 使用32位来存储一个数字。它接受一个有符号的十进制数。'
- en: '`setFloat64`: Uses 64 bits to store a number. It takes a signed decimal number.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFloat64`: 使用64位来存储一个数字。它接受一个有符号的十进制数。'
- en: 'Here are other functions for retrieving stored numbers by a `DataView` object:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其他通过`DataView`对象检索存储数字的函数：
- en: '`getInt8`: Reads 8 bits. Returns a signed integer number.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInt8`: 读取8位。返回一个有符号整数。'
- en: '`getUint8`: Reads 8 bits. Returns an unsigned integer number.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUint8`: 读取8位。返回一个无符号整数。'
- en: '`getInt16`: Reads 16 bits. Returns a signed integer number.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInt16`: 读取16位。返回一个有符号整数。'
- en: '`getUint16`: Reads 16 bits. Returns an unsigned integer number.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUint16`: 读取16位。返回一个无符号整数。'
- en: '`getInt32`: Reads 32 bits. Returns a signed integer number.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInt32`: 读取32位。返回一个有符号整数。'
- en: '`getUint32`: Reads 32 bits. Returns an unsigned integer number.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUint32`: 读取32位。返回一个无符号整数。'
- en: '`getFloat32`: Reads 32 bits. Returns a signed decimal number.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFloat32`: 读取32位。返回一个有符号的十进制数。'
- en: '`getFloat64`: Reads 64 bits. Returns a signed decimal number.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFloat64`: 读取64位。返回一个有符号的十进制数。'
- en: Typed arrays
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化数组
- en: We saw how to read and write numbers in array buffers. But the method was very
    cumbersome because we had to call a function every time. Typed arrays let us read
    and write to an `ArrayBuffer` object just like we do for normal arrays.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何在数组缓冲区中读取和写入数字。但是方法非常繁琐，因为我们必须每次都调用一个函数。类型化数组允许我们像对普通数组那样读取和写入`ArrayBuffer`对象。
- en: A **typed array** acts as a wrapper for an `ArrayBuffer` object and treats data
    from an `ArrayBuffer` object as a sequence of n-bit numbers. The `n` value depends
    on how we created the typed array.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型化数组**作为`ArrayBuffer`对象的包装器，并将`ArrayBuffer`对象中的数据视为n位数字的序列。`n`值取决于我们如何创建类型化数组。'
- en: 'Next is a code example that demonstrates how to create an `ArrayBuffer` object
    and read/write to it using a typed array:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个代码示例，演示了如何创建`ArrayBuffer`对象并使用类型数组对其进行读写：
- en: '[PRE94]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output is:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE95]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here we created a typed array using the `Float64Array` constructor. It, therefore,
    treats data in `ArrayBuffer` as a sequence of 64-bit signed decimal numbers. Here
    the `ArrayBuffer` object size was 640 bits; therefore, only 10 64-bit numbers
    can be stored.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Float64Array`构造函数创建了一个类型数组。因此，它将`ArrayBuffer`中的数据视为64位有符号十进制数的序列。这里`ArrayBuffer`对象的大小为640位；因此，只能存储10个64位数字。
- en: 'Similarly, there are other typed array constructors to represent data in `ArrayBuffer`
    as a sequence of different bit numbers. Here is the list:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有其他类型数组构造函数，用于将`ArrayBuffer`中的数据表示为不同位数的序列。以下是列表：
- en: '`Int8Array`: Represents 8-bit signed integers'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int8Array`：表示8位有符号整数'
- en: '`Uint8Array`: Represents 8-bit unsigned integers'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uint8Array`：表示8位无符号整数'
- en: '`Int16Array`: Represents 16-bit signed integers'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int16Array`：表示16位有符号整数'
- en: '`Uint16Array`: Represents 16-bit unsigned integers'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uint16Array`：表示16位无符号整数'
- en: '`Int32Array`: Represents 32-bit signed integers'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int32Array`：表示32位有符号整数'
- en: '`Uint32Array`: Represents 32-bit unsigned integers'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uint32Array`：表示32位无符号整数'
- en: '`Float32Array`: Represents 32-bit signed decimal number'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float32Array`：表示32位有符号十进制数'
- en: '`Float64Array`: Represents 64-bit signed decimal number'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float64Array`：表示64位有符号十进制数'
- en: Typed arrays provide all the methods that are also provided by normal JavaScript
    arrays. They also implement the iterable protocol; therefore, they can be used
    as an iterable object.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 类型数组提供了正常JavaScript数组提供的所有方法。它们还实现了可迭代协议；因此，它们可以用作可迭代对象。
- en: We'll need to use typed arrays in Chapter 12 - Shared memory and Atomics
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章“共享内存和原子操作”中使用类型数组
- en: Set
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Set
- en: 'A **Set **is a collection of unique values of any data type. The values in
    a Set are arranged in insertion order. A Set is created using the `Set` constructor.
    Here is an example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set**是一个包含任何数据类型唯一值的集合。Set中的值按插入顺序排列。Set是通过`Set`构造函数创建的。以下是一个示例：'
- en: '[PRE96]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here `set1` is an empty Set, whereas `set2` was created using values of an
    iterable object, that is, the characters of a string and the string, was not empty;
    therefore, `set2` is non-empty. The following example code demonstrates various
    operations that can be done on a Set:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`set1`是一个空集，而`set2`是使用可迭代对象（即字符串的字符和字符串）创建的，因此不为空；因此，`set2`不为空。以下示例代码演示了可以在Set上执行的各种操作：
- en: '[PRE97]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here we added nine items to the `Set` object but the size was only six because
    the Set automatically deletes duplicate values. The characters `l` and `!` were
    repeated multiple times. The `Set` object also implements the iterable protocol
    so they can be used as an iterable object.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`Set`对象中添加了九个项目，但大小仅为六个，因为Set会自动删除重复的值。字符`l`和`!`被重复多次。`Set`对象还实现了可迭代协议，因此可以用作可迭代对象。
- en: Sets are used when you want to maintain a collection of values and check if
    a value exists instead of retrieving a value. For example, Sets can be used as
    an alternative to an array if you only use the `indexOf()` method of the array
    in your code to check if a value exists.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想维护一组值并检查值是否存在而不是检索值时，使用集合。例如，如果你在代码中只使用数组的`indexOf()`方法来检查值是否存在，则可以将集合用作数组的替代品。
- en: WeakSet
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WeakSet
- en: 'Here are the differences between `Set` and `WeakSet` objects:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Set`和`WeakSet`对象之间的区别：
- en: A `Set` can store primitive types and object references whereas a `WeakSet`
    object can only store object references
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`可以存储原始类型和对象引用，而`WeakSet`对象只能存储对象引用'
- en: One important features `WeakSet` objects is that if there is no other reference
    to an object stored in a `WeakSet` object then they are garbage-collected
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet`对象的一个重要特性是，如果没有其他引用指向存储在`WeakSet`对象中的对象，则它们会被垃圾回收'
- en: 'Lastly, a `WeakSet` object is not enumerable: that is, you cannot find its
    size; it also doesn''t implement the iterable protocol'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`WeakSet`对象是不可枚举的：也就是说，你不能找到它的大小；它也没有实现可迭代协议
- en: Apart from these three differences, `WeakSet` behaves exactly the same way as
    `Set`. Everything else apart from these three differences is same between a `Set`
    and `WeakSet` object.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个区别之外，`WeakSet`的行为与`Set`完全相同。除了这三个区别之外，`Set`和`WeakSet`对象之间的一切都是相同的。
- en: A `WeakSet` object is created using the `WeakSet` constructor. You cannot pass
    an iterable object as an argument to a `WeakSet` object.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `WeakSet` 对象是通过 `WeakSet` 构造函数创建的。你不能将可迭代对象作为参数传递给 `WeakSet` 对象。
- en: 'Here is an example to demonstrate `WeakSet`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示 `WeakSet`：
- en: '[PRE99]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Map
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: A **Map** is a collection of key/value pairs. Keys and values of a Map can be
    of any data type. Key/value pairs are arranged in insertion order. A `Map` object
    is created using the `Map` constructor.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **Map** 是键/值对的集合。Map 的键和值可以是任何数据类型。键/值对按插入顺序排列。`Map` 对象是通过 `Map` 构造函数创建的。
- en: 'Here is an example, which demonstrates how to create a `Map` object and do
    various operations on it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何创建一个 `Map` 对象并在其上执行各种操作：
- en: '[PRE100]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output is as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE101]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: While creating a `Map` object from an iterable object, we need to make sure
    that the values returned by the iterable object are arrays, each of length `2`;
    that is, index `0` is the key and index `1` is the value.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当从一个可迭代对象创建 `Map` 对象时，我们需要确保可迭代对象返回的值是长度为 `2` 的数组；也就是说，索引 `0` 是键，索引 `1` 是值。
- en: If we try to add a key that already exists then it's overwritten. `Map` objects
    also implement the iterable protocol and can therefore also be used as an iterable
    object. While iterating Maps using the iterable protocol, they return arrays with
    key/value pairs as you can see in the preceding example.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试添加一个已经存在的键，那么它会被覆盖。`Map` 对象也实现了可迭代协议，因此也可以用作可迭代对象。在通过可迭代协议迭代 `Map` 时，它们返回键/值对数组，正如前一个示例所示。
- en: WeakMap
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WeakMap
- en: '`WeakMap`, as the name suggests, is an object in which keys are weakly referenced
    to the key/value pairs. That means that values can be anything. The keys are weakly
    referenced as keys are objects.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap`，正如其名所示，是一个对象，其中的键是弱引用到键/值对的。这意味着值可以是任何东西。键是弱引用的，因为键是对象。'
- en: 'Here are the differences between `Map` and `WeakMap` objects:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 和 `WeakMap` 对象之间的区别如下：'
- en: Keys of a `Map` object can be of primitive types or object references but keys
    in a `WeakMap` object can only be object references
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 对象的键可以是原始类型或对象引用，但 `WeakMap` 对象中的键只能是对象引用。'
- en: One of the important features of a  `WeakMap` object is that if there is no
    other reference to an object that is referenced by a key then the key is garbage-collected
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap` 对象的一个重要特性是，如果一个对象没有其他引用，那么该对象被键引用时，该键会被垃圾回收。'
- en: Lastly, a  `WeakMap` object is not enumerable, that is, you cannot find its
    size and it doesn't implement the iterable protocol
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个 `WeakMap` 对象是不可枚举的，也就是说，你不能找到它的大小，它也没有实现可迭代协议。
- en: In every other particular, apart from these three differences `Map` and `WeakMap`
    objects are similar.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他所有方面，除了这三个区别之外，`Map` 和 `WeakMap` 对象是相似的。
- en: '`WeakMap` is created using a `WeakMap` constructor. Here is an example that
    demonstrates its usage:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap` 是通过 `WeakMap` 构造函数创建的。以下是一个演示其用法的示例：'
- en: '[PRE102]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Objects
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objects
- en: '**Objects** have existed in JavaScript for a long time. They form the backbone
    of JavaScript, as almost every data type can be associated with *objects.* (`new
    String()`, `new Number()`, `new Boolean()`, and so on). You''ll often find yourself
    working and manipulating objects all the time when working with web applications
    or JavaScript in general.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**在 JavaScript 中已经存在很长时间了。它们是 JavaScript 的骨架，因为几乎每种数据类型都可以与 *对象* 关联（`new
    String()`、`new Number()`、`new Boolean()` 等等）。当你在处理网络应用程序或 JavaScript 时，你经常会发现自己一直在处理和操作对象。'
- en: ES6, ES2016 (ES7), and ES2017 (ES8) introduce a lot of new properties and methods
    associated with objects. Let us take a look at them.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ES6、ES2016（ES7）和ES2017（ES8）引入了许多与对象相关的新属性和方法。让我们来看看它们。
- en: Object.values()
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object.values()
- en: ES8 introduced the `Object.values()` method so that a programmer can retrieve
    all the values of an object as an array. This was earlier possible by manually
    iterating over every property of the object and storing its value in the array.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ES8 引入了 `Object.values()` 方法，以便程序员可以以数组的形式检索对象的所有值。这之前可以通过手动遍历对象的每个属性并将它的值存储在数组中来实现。
- en: 'Here''s an example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE103]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output will be:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE104]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Object.entries()
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object.entries()
- en: '`Object.entries()` can be used to convert an object into a key/value pair in
    the form of an array. That means your object will be converted into a 2D array
    (at the simplest level), with each element being another array containing a key
    and value. Take a look at this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.entries()` 可以用来将一个对象转换成数组形式的键/值对。这意味着你的对象将被转换成一个二维数组（在最简单的情况下），每个元素都是一个包含键和值的数组。看看这个例子：'
- en: '[PRE105]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The output will be:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE106]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The __proto__ property
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`__proto__` 属性'
- en: 'JavaScript objects have an internal `[[prototype]]` property that references
    the object''s prototype, that is, the object it inherits: the **prototypal inheritance
    model**, which JavaScript uses. To read the property, we had to use `Object.getPrototypeof()`
    and to create a new object with a given prototype, we had to use the `Object.create()`
    method. A `[[prototype]]` property cannot be directly read or be modified.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象有一个内部 `[[prototype]]` 属性，它引用对象的原型，即它继承的对象：这是 JavaScript 使用的 **原型继承模型**。为了读取属性，我们必须使用
    `Object.getPrototypeOf()`，为了创建具有给定原型的新的对象，我们必须使用 `Object.create()` 方法。`[[prototype]]`
    属性不能直接读取或修改。
- en: Inheriting was cumbersome due to the nature of the `[[prototype]]` property;
    therefore, some browsers added a special `__proto__` property in objects, which
    is an accessor property that exposes the internal `[[prototype]]` property and
    makes working with prototypes easier. The `__proto__` property was not standardized
    in ES5, but due to its popularity, it was standardized in later versions.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `[[prototype]]` 属性的性质，继承变得很繁琐；因此，一些浏览器在对象中添加了一个特殊的 `__proto__` 属性，它是一个访问器属性，暴露了内部的
    `[[prototype]]` 属性，使得与原型的工作更加容易。`__proto__` 属性在 ES5 中没有标准化，但由于其流行，它在后续版本中得到了标准化。
- en: 'Here is an example to demonstrate this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示这个的示例：
- en: '[PRE107]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Carefully observe:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察：
- en: In the ES5 example, object `y` *inherits* from object `x`; therefore, when you
    simply use `console.log` on the object `y`, the properties it inherits from object
    `x` are not visible directly (or rather they are hidden). However, when you try
    to access `y.prop2`, JavaScript doesn't find it on object `y`, so it looks on
    the `__proto__` chain (which is how JavaScript is built to work) and finds that
    there is, in fact, a reference available for `prop2` on the proto chain. However,
    it was not possible to edit that directly in ES5.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ES5 的例子中，对象 `y` 从对象 `x` 继承；因此，当你简单地对对象 `y` 使用 `console.log` 时，它从对象 `x` 继承的属性不会直接可见（或者更确切地说，它们是隐藏的）。然而，当你尝试访问
    `y.prop2` 时，JavaScript 不会在对象 `y` 上找到它，所以它会查看 `__proto__` 链（这是 JavaScript 的工作方式），并发现实际上在原型链上有一个对
    `prop2` 的引用。然而，在 ES5 中无法直接编辑它。
- en: With ES6/ES7/ES8/ES.next and onwards, you can directly add values to the prototype
    chain of the object.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ES6/ES7/ES8/ES.next 及以后的版本中，你可以直接向对象的原型链中添加值。
- en: The Object.is(value1, value2) method
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Object.is(value1, value2)` 方法'
- en: 'The `Object.is()` method determines whether two values are equal or not. It
    is similar to the `===` operator but there are some special cases for the `Object.is()`
    method. Here is an example that demonstrates special cases:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.is()` 方法确定两个值是否相等。它与 `===` 运算符类似，但 `Object.is()` 方法有一些特殊情况。以下是一个演示这些特殊情况的示例：'
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output is as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE109]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here's a handy table you might want to look at for the differences between 0, ==,
    ===,and Object.is**:**
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可能想要查看的方便的表格，用于比较 0、==、=== 和 Object.is 之间的区别：**
- en: '![](img/7c77be8d-f28d-4aa9-ab30-825303628f2b.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c77be8d-f28d-4aa9-ab30-825303628f2b.png)'
- en: 'While it might seem intuitive that `Object.is` can compare if two given objects
    are same, that is not the case. `x = {foo: 1}` and `y = {foo: 1}` are *not* same
    for all three operators (`==`, `===`, and `Object.is`).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然看起来直观，`Object.is` 可以比较两个给定的对象是否相同，但这并不是事实。`x = {foo: 1}` 和 `y = {foo: 1}`
    在所有三个运算符（`==`、`===` 和 `Object.is`）中都不是相同的。'
- en: The Object.setPrototypeOf(object, prototype) method
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf(object, prototype)` 方法'
- en: 'The `Object.setPrototypeOf()` method is just another way to assign the `[[prototype]]`
    property of an object, which we have just discussed. You can either use this method
    or directly work with the `__proto__` property. However, working with a method
    is a cleaner and easier-to-read approach. Here is an example to demonstrate this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf()` 方法只是另一种方式来分配对象的 `[[prototype]]` 属性，这是我们刚刚讨论过的。你可以使用这个方法或者直接操作
    `__proto__` 属性。然而，使用方法是一种更干净、更容易阅读的方法。以下是一个示例来演示这一点：'
- en: '[PRE110]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The Object.assign(targetObj, sourceObjs…) method
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Object.assign(targetObj, sourceObjs...)` 方法'
- en: 'The `Object.assign()` method is used is used to copy the values of all enumerable
    own properties from one or more source objects to a target object. This method
    will return `targetObj`. Here is an example which demonstrates this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 方法用于从一个或多个源对象复制所有可枚举的自有属性到目标对象。此方法将返回 `targetObj`。以下是一个演示此功能的示例：'
- en: '[PRE111]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output is as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE112]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Here is a list of important things to keep in mind while using the `Object.assign()`
    method:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Object.assign()` 方法时，以下是一些重要事项需要记住：
- en: It invokes getters on the sources and setters on the target.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在源上调用 getter，在目标上调用 setter。
- en: It just assigns values of the properties of the source to the new or existing
    properties of the target.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只是将源属性的值赋给目标的新或现有属性。
- en: It doesn't copy the `[[prototype]]` property of sources.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会复制源的 `[[prototype]]` 属性。
- en: JavaScript property names can be strings or symbols. `Object.assign()` copies
    both.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 属性名可以是字符串或符号。`Object.assign()` 会复制两者。
- en: Property definitions are not copied from sources; therefore, you need to use
    `Object.getOwnPropertyDescriptor()` instead.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性定义不是从源中复制的；因此，你需要使用 `Object.getOwnPropertyDescriptor()`。
- en: It ignores copying keys with null and undefined values.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会忽略带有 null 和 undefined 值的键的复制。
- en: Object.getOwnPropertyDescriptors()
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object.getOwnPropertyDescriptors()
- en: 'Introduced in ES8, the `Object.getOwnPropertyDescriptors()` method will return
    all the property descriptors for a given object. What does that mean exactly?
    Let''s take a look:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES8 中引入的 `Object.getOwnPropertyDescriptors()` 方法将返回给定对象的全部属性描述符。这究竟意味着什么呢？让我们来看一看：
- en: '[PRE113]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output produced is:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出是：
- en: '[PRE114]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `get()` function fires when you try to access the property (but when you
    also want to do a bunch of stuff first). So, when you do `details.food1`, `tasty` is
    returned.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问属性时（但同时也想先做一堆事情），`get()` 函数会被触发。所以，当你执行 `details.food1` 时，会返回 `tasty`。
- en: 'The practical usage of this is mostly in **Decorators** (which is a whole new
    topic) and creating a shallow clone, as shown here:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实际用法主要应用于 **装饰器**（这是一个全新的主题）以及创建浅拷贝，如下所示：
- en: '[PRE115]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about new features added in ES8, ES7, and ES6 for
    working with numbers, strings, arrays, and objects. We saw how arrays impact performance
    in math-rich applications and how array buffers can be used instead. We also walked
    through the new collection objects provided by ES8.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 ES8、ES7 和 ES6 中新增的用于处理数字、字符串、数组和对象的特性。我们看到了数组在数学密集型应用中的影响以及如何使用数组缓冲区来替代。我们还探讨了
    ES8 提供的新集合对象。
- en: In the next chapter, we will take a look at the Symbols and Iteration protocol,
    and we will also explore the `yield` keyword and generators. A lot of exciting
    and cutting-edge stuff is coming your way! Hold tight!
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨符号和迭代协议，同时也会探索 `yield` 关键字和生成器。许多激动人心和前沿的内容即将呈现在你面前！请保持耐心！
