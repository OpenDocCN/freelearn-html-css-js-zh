- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation and Moving the Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw some simple animations, but nothing too complex.
    In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene
    with Three.js*, we introduced the basic rendering loop, and in the chapters following
    that, we used that to rotate some simple objects and show a couple of other basic
    animation concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to look in more detail at how animation is supported
    by Three.js. We will look at the following four subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphing and skeleton animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations using external modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by covering the basic concepts behind animations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at the examples, let’s do a quick recap of what was shown in
    [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), on the render loop. To support
    animations, we need to tell Three.js to render the scene every so often. For this,
    we use the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we only need to call the `render()` function once we’ve initialized
    the scene. In the `render()` function itself, we use `requestAnimationFrame` to
    schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times or 120 times
    a second). Before `requestAnimationFrame` was added to browsers, `setInterval(function,
    interval)` or `setTimeout(function, interval)` was used. These would call the
    specified function once every set interval.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it doesn’t take into account what else
    is going on. Even if your animation isn’t shown or is in a hidden tab, it is still
    called and is still using resources. Another issue is that these functions update
    the screen whenever they are called, and not when it is the best time for the
    browser, which results in higher CPU usage. With `requestAnimationFrame`, we don’t
    tell the browser when it needs to update the screen; we ask the browser to run
    the supplied function when it’s most opportune. Usually, this results in a frame
    rate of about 60 or 120 FPS (depending on your hardware). With `requestAnimationFrame`,
    your animations will run more smoothly and will be more CPU- and GPU-friendly,
    and you don’t have to worry about timing issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll start with creating a simple animation.
  prefs: []
  type: TYPE_NORMAL
- en: Simple animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this approach, we can very easily animate objects by changing their `rotation`,
    `scale`, `position`, `material`, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    *Points and Sprites*, is available in `01-basic-animations.html`. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Animation after changing its properties](img/Figure_9.1_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Animation after changing its properties
  prefs: []
  type: TYPE_NORMAL
- en: 'The render loop for this is very simple. First, we initialize the various properties
    on the `userData` object, which is a place for custom data stored in the `THREE.Mesh`
    itself, and then update these properties on the mesh, using the data we defined
    on the `userData` object. In the animation loop, just change the rotation, position,
    and the scale based on these properties, and Three.js handles the rest. Here’s
    how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing spectacular here, but it nicely shows the concept behind the
    basic animations we will discuss in this book. We just change the `scale`, `rotation`,
    and `position` properties and Three.js does the rest.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll take a quick sidestep. Besides animations, an important
    aspect that you’ll quickly run into when working with Three.js in more complex
    scenes is the ability to select objects on the screen using the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and moving objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though not directly related to animations, since we’ll be looking at cameras
    and animations in this chapter, knowing how to select and move objects is a nice
    addition to the subjects explained in this chapter. Here, we will show you how
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an object from a scene using the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag an object around the scene with the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by looking at the steps you need to take to select an object.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, open the `selecting-objects.html` example, where you’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Randomly placed cubes that can be selected with the mouse](img/Figure_9.2_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Randomly placed cubes that can be selected with the mouse
  prefs: []
  type: TYPE_NORMAL
- en: 'When you move the mouse around the scene, you’ll see that whenever your mouse
    hits an object, that object is highlighted. You can easily create this by using
    a `THREE.Raycaster`. A raycaster will look at your current camera and cast a ray
    from the camera to your mouse’s position. Based on that, it can calculate which
    object is hit based on the position of the mouse. To accomplish this, we need
    to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object that keeps track of where the mouse is pointing at
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever we move the mouse, update that object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the render loop, use this updated information to see which Three.js object
    we’re pointing at
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using `THREE.Raycaster` to determine which objects intersect the
    position of the mouse, from the point of the camera. The result (`intersects`,
    in the preceding example) contains all the cubes that intersected our mouse because
    the ray is cast from the camera’s position through to the end of the camera’s
    range. The first one in this array is the one that we’re hovering over, and the
    other values in this array (if any) point to objects behind the first mesh. `THREE.Raycaster`
    also provides other information about exactly where you hit the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Additional information from the raycaster](img/Figure_9.3_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Additional information from the raycaster
  prefs: []
  type: TYPE_NORMAL
- en: Here, we clicked on the `face` object. `faceIndex` points to the face of the
    mesh that was selected. The `distance` value is measured from the camera to the
    clicked object, and `point` is the exact position on the mesh where it was clicked.
    Finally, we have the `uv` value, which determines, when using textures, where
    the point that was clicked appears on the 2D texture (ranging from 0 to 1; more
    information on `uv` can be found in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working* *With Textures*).
  prefs: []
  type: TYPE_NORMAL
- en: Dragging objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides selecting an object, a common requirement is being able to drag and
    move objects around. Three.js also provides default support for this. If you open
    the `dragging-objects.html` example in your browser, you’ll see a similar scene
    to the one shown in *Figure 9**.2*. This time, when you click on an object, you
    can drag it around the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Dragging an object around the scene using the mouse](img/Figure_9.4_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Dragging an object around the scene using the mouse
  prefs: []
  type: TYPE_NORMAL
- en: 'To support dragging objects, Three.js uses something called `DragControls`.
    This handles everything and provides convenient callbacks whenever the dragging
    starts and stops. The code to accomplish this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as that. Here, we added `DragControls` and passed in the elements
    that can be dragged (in our case, all of the randomly placed cubes). Then, we
    added two event listeners. The first one, `dragstart`, is called when we start
    dragging a cube, whereas `dragend` is called when we stop dragging an object.
    In this example, when we start dragging, we disable `OrbitControls` (which allows
    us to use the mouse to look around the scene) and change the color of the selected
    object. Once we stop dragging, we change the color of the object back and enable
    `OrbitControls` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a somewhat more advanced version of `DragControls` available
    called `TransformControls`. We won’t go into the details of this control, but
    it allows you to use a simple UI to transform the properties of a mesh. You can
    find an example of this control when you open `transform-controls-html` in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Transform controls allow you to change the properties of a mesh](img/Figure_9.5_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Transform controls allow you to change the properties of a mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the various parts of this control, you can easily change the
    shape of the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Shape modified using transform controls](img/Figure_9.6_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Shape modified using transform controls
  prefs: []
  type: TYPE_NORMAL
- en: For the final example in this chapter, we’ll show you how you can use an alternative
    way of modifying the properties of an object (as we saw in the first example of
    this chapter) by using a tweening library.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with Tween.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called `x` position of a mesh from 10 to 3 in 10 seconds,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can create a separate object and pass that into the mesh
    you want to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve created `TWEEN.Tween`. This tween will make sure that
    the `x` property is changed from 10 to 3 over 10,000 milliseconds. Tween.js also
    allows you to define how this property is changed over time. This can be done
    using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The value is changed over time by a process called `easing()`
    function. This library also provides additional ways to control how this easing
    is done. For instance, we can set how often the easing should be repeated (`repeat(10)`)
    and whether we want a yoyo effect (this means we go from 10 to 3 and back to 10
    in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this library together with Three.js is very simple. If you open the `tween-animations.html`
    example, you will see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Tweening a point system halfway through the action](img/Figure_9.7_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Tweening a point system halfway through the action
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the Tween.js library to move this to a single point using a specific
    `easing()`, which at a certain point looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Tweening a point when everything is merged into a single point](img/Figure_9.8_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Tweening a point when everything is merged into a single point
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve taken a point cloud from [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    and created an animation where all the points slowly move down to the center.
    The position of these particles is set by using a tween created with the Tween.js
    library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this piece of code, we created a tween that transitions a value from `1`
    to `0` and back again. To use the value from the tween, we have two different
    options: we can use the `onUpdate` function provided by this library to call a
    function with the updated values, whenever the tween is updated (which is done
    by calling `TWEEN.update()`), or we can directly access the updated values. In
    this example, we used the latter approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the changes we need to make in the `render` function, we
    must perform one additional step after we load the model. We want to tween between
    the original values to zero and back again. For this, we need to store the original
    positions of the vertices somewhere. We can do this by copying the starting positions
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we want to access the original position, we can look at the `originalPos`
    attribute on the geometry. Now, we can just use the value from the tween to calculate
    the new positions of each of the vertices. We can do this like so in the render
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With these steps in place, the tween library will take care of positioning the
    various points on the screen. As you can see, using this library is much easier
    than having to manage the transitions yourself. Besides animating and changing
    objects, we can also animate a scene by moving the camera around. In the previous
    chapters, we did this a couple of times by manually updating the position of the
    camera. Three.js also provides several additional ways of updating the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js has several camera controls you can use to control the camera throughout
    a scene. These controls are located in the Three.js distribution and can be found
    in the `examples/js/controls` directory. In this section, we’ll look at the following
    controls in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArcballControls`: An extensive control that provides a transparent overlay
    that you can use to easily move the camera around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstPersonControls`: These are controls that behave like those in first-person
    shooters. You can move around with the keyboard and look around with the mouse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlyControls`: These are flight simulator-like controls. You can move and steer
    with the keyboard and the mouse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrbitControls`: This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PointerLockControls`: These are similar to the first-person controls but they
    also lock the mouse pointer to the screen, making it a great choice for simple
    games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TrackBallControls`: These are the most-used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides using these camera controls, you can also move the camera yourself by
    setting its position and changing where it is pointed using the `lookAt()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The first control we’ll look at is `ArcballControls`.
  prefs: []
  type: TYPE_NORMAL
- en: ArcballControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to explain how `ArcballControls` works is by looking at an
    example. If you open up the `arcball-controls.html` example, you’ll see a simple
    scene, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Using ArcballControls to explore a scene](img/Figure_9.9_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Using ArcballControls to explore a scene
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely at this screenshot, you will see two translucent lines crossing
    the scene. These are lines provided by `ArcballControls`, which you can use to
    rotate and pan around the scene. These lines are called **gizmos**. The left mouse
    button is used to rotate the scene, the right mouse button can be used to pan
    around, and you can zoom in with the scroll wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this standard functionally, this control also allows you to focus on
    specific parts of the mesh that is shown. If you double-click on the scene, the
    camera will focus on that part of the scene. To use this control, all we need
    to do is instantiate it and pass in the `camera` property, the `domElement` property
    used by the renderer, and the `scene` property we’re looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This control is a very versatile one, which can be configured through a set
    of properties. Most of these properties can be explored in this example by using
    the menu on the right of this example. For this specific control, we’ll dive a
    bit deeper into the properties and methods provided by this object since it is
    a versatile control and a good choice when you want to provide a good way for
    your users to explore your scenes. Let’s provide an overview of the properties
    and the methods provided by this control. First, let’s look at the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adjustNearFar`: If this is set to `true`, this control will change the camera’s
    `near` and `far` properties when zooming in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camera`: The camera that’s used when creating this control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cursorZoom`: If set to `true`, when zooming in, the zoom will be focused on
    the position of the cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dampingFactor`: If `enableAnimations` is set to `true`, this value will determine
    how quickly an animation stops after an action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domElement`: This element is used to list mouse events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: Determines whether this control is enabled or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enableRotate`, `enableZoom`, `enablePan`, `enableGrid`, `enableAnimations`:
    These properties enable and disable functionality provided by this control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`focusAnimationTime`: When we double-click and focus on part of the scene,
    this property determines the duration of the focusing animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDistance`/`minDistance`: How far we can zoom out and in for `PerspectiveCamera`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxZoom`/`minZoom`: How far we can zoom out and in for `OrthographicCamera`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scaleFactor`: How fast we zoom in and out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scene`: The scene passed in the constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radiusFactor`: The size of the “gizmo” relative to the screen’s width and
    height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wMax`: How fast we’re allowed to rotate the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This control also provides several methods to interact or configure it further:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activateGizmos(bool)`: If `true`, it highlights the gizmos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copyState()`, `pasteState()`: Allows you to copy and paste the state of the
    controls to the clipboard in JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveState()`, `reset()`: Internally saves the current state and uses `reset()`
    to apply the saved state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispose()`: Removes all parts of this control from the scene, and cleans up
    any listeners and animations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setGizomsVisible(bool)`: Specifies whether to show or hide the gizmos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTbRadius(radiusFactor)`: Updates the `radiusFactor` property and redraws
    the gizmos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMouseAction(operation, mouse, key)`: Determines which mouse key provides
    which action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsetMouseAction(mouse, key)`: Clears an assigned mouse action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`: Whenever the camera properties change, call this to apply these
    new settings to this control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRayCaster()`: Provides access to `rayCaster`, which is used internally
    by these controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArcballControls` is a really useful and relatively new addition to Three.js
    that provides advanced control of the scene using the mouse. If you’re looking
    for a simpler approach, you can use `TrackBallControls`.'
  prefs: []
  type: TYPE_NORMAL
- en: TrackBallControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `TrackBallControls` follows the same approach as we saw for `ArcballControls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we just need to pass in the `camera` and `domeElement` properties
    from the renderer. For the trackball controls to work, we also need to add a `THREE.Clock`
    and update the render loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we can see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to calculate the elapsed time that a specific
    invocation or rendering loop takes to complete. You can do this by calling the
    `clock.getDelta()` function. This function will return the elapsed time between
    this call and the previous call to `getDelta()`. To update the position of the
    camera, we can call the `TrackBallControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we can use the `getDelta()` function from the `THREE.Clock`
    object. You might be wondering why we don’t just pass in the frame rate (1/60
    seconds) to the update function. The reason is that with `requestAnimationFrame`,
    we can expect 60 FPS, but this isn’t guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A working example of this can be found in `trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Using TrackBallControls to control a scene](img/Figure_9.10_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Using TrackBallControls to control a scene
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the camera in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left mouse button and move**: Rotate and roll the camera around the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scroll wheel**: Zoom in and zoom out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle mouse button and move**: Zoom in and zoom out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right mouse button and move**: Pan around the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won’t go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackBallControls.js` file, where these properties are listed.
  prefs: []
  type: TYPE_NORMAL
- en: FlyControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next control we’ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `fly-controls-camera.html`. The following screenshot shows a still
    image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Using FlyControls to fly around a scene](img/Figure_9.11_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Using FlyControls to fly around a scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling `FlyControls` works in the same manner as the other controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`FlyControls` takes the camera and the renderer’s `domElement` as arguments
    and requires that you call the `update()` function with the elapsed time in the
    render loop. You can control the camera with `THREE.FlyControls` in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left and middle mouse buttons**: Start moving forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right mouse button**: Move backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mouse movement**: Look around'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*W*: Start moving forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*: Move backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A*: Move left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Move right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*: Move up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Move down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left, right, up, and down arrows**: Look left, right, up, and down, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: Roll left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Roll right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next control we’ll look at is `THREE.FirstPersonControls`.
  prefs: []
  type: TYPE_NORMAL
- en: FirstPersonControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around, and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Exploring a scene using the first-person controls](img/Figure_9.12_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Exploring a scene using the first-person controls
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating these controls follows the same principles as the ones followed for
    the other controls we’ve seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The functionality provided by this control is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mouse movement**: Look around'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left, right, up, and down arrows**: Move left, right, forward, and backward,
    respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*W*: Move forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A*: Move left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*: Move backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Move right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*: Move up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Move down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Q*: Stop all movement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the final control, we’ll move on from this first-person perspective to the
    perspective from space.
  prefs: []
  type: TYPE_NORMAL
- en: OrbitControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OrbitControls` control is a great way to rotate and pan around an object
    in the center of the scene. This is also the control we used in the other chapters
    to provide you with a simple way to explore the models in the examples provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `orbit-controls-orbit-camera.html`, we’ve included an example that shows
    how this control works. The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – OrbitControls properties](img/Figure_9.13_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – OrbitControls properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `OrbitControls` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The controls for `OrbitControls` are focused on using the mouse, as shown in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left mouse click and move**: Rotate the camera around the center of the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scroll wheel or middle mouse click and move**: Zoom in and zoom out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right mouse click and move**: Pan around the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s it for the camera and moving it around. In this section, we saw a lot
    of controls that allow you to easily interact with and move through a scene by
    changing the camera properties. In the next section, we’ll look at more advanced
    methods of animation: morphing and skinning.'
  prefs: []
  type: TYPE_NORMAL
- en: Morphing and skeleton animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Morph targets**: With morph targets, you define a deformed version – that
    is, a key position – of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (this screenshot has
    been provided by the Blender foundation):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Setting up animations using morph targets](img/Figure_9.14_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Setting up animations using morph targets
  prefs: []
  type: TYPE_NORMAL
- en: '**Skeleton animation**: An alternative is using skeleton animation. With skeletal
    animation, you define the skeleton – that is, the bones – of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Setting up animations using bones](img/Figure_9.15_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Setting up animations using bones
  prefs: []
  type: TYPE_NORMAL
- en: Three.js supports both modes, but there can be an issue getting a good export
    when you want to work with skeleton/bones-based animations. For the best results,
    you should export or convert your model into glTF format, which is becoming the
    default for exchanging models, animations, and scenes, and has great support from
    Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at both options and also look at a couple of external
    formats supported by Three.js in which animations can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with morph targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called keyframes) and
    tell Three.js to move the vertices from one position to the other.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to work with morph targets using two examples. In the first
    example, we’ll let Three.js handle the transition between the various keyframes
    (or morph targets, as we’ll call them from now on), and in the second one, we’ll
    do this manually. Keep in mind that we are only scratching the surface of what
    is possible with animations in Three.js. As you’ll see in this section, Three.js
    has excellent support for controlling animations, supports syncing of animations,
    and provides ways to smoothly transition from one animation to another, warranting
    a book just on this subject. So, in the next couple of sections, we’ll provide
    you with the basics of animations in Three.js, which should provide you with enough
    information to get started and explore the more complex subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with a mixer and morph targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the examples, first, we’ll look at the three core classes
    that you can use to animate with Three.js. Later in this chapter, we’ll show you
    all the functions and properties provided by these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.AnimationClip`: When you load a model that contains animations, you
    can look in the `response` object for a field usually called `animations`. This
    field will contain a list of `THREE.AnimationClip` objects. Note that depending
    on the loader, an animation might be defined on a `Mesh`, a `Scene`, or be provided
    completely separately. A `THREE.AnimationClip` most often holds the data for a
    certain animation the model you loaded can perform. For instance, if you loaded
    a model of a bird, one `THREE.AnimationClip` would contain the information needed
    to flap the wings, and another one might be opening and closing its beak.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.AnimationMixer`: `THREE.AnimationMixer` is used to control several `THREE.AnimationClip`
    objects. It makes sure the timing of the animation is correct and makes it possible
    to sync animations together, or cleanly move from one animation to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.AnimationAction`: `THREE.AnimationMixer` itself doesn’t expose a large
    number of functions to control the animation, though. This is done through `THREE.AnimationAction`
    objects, which are returned when you add a `THREE.AnimationClip` to a `THREE.AnimationMixer`
    (though you can get them at a later time by using functions provided by `THREE.AnimationMixer`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an `AnimationObjectGroup`, which you can use to provide the animation
    state not just to a single `Mesh` but to a group of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you can control a `THREE.AnimationMixer` and a `THREE.AnimationAction`,
    which were created using a `THREE.AnimationClip` from the model. The `THREE.AnimationClip`
    objects used in this example morph a model into a cube and then into a cylinder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this first morphing example, the easiest way to understand how a morph
    targets-based animation works is by opening up the `morph-targets.html` example.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Animation using morph targets](img/Figure_9.16_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Animation using morph targets
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve got a simple model (a monkey’s head), which can be transformed
    into either a cube or a cylinder using morph targets. You can easily test this
    yourself by moving the `cubeTarget` or `coneTarget` sliders, and you’ll see the
    head being morphed into a different shape. For instance, with `cubeTarget` at
    `0.5`, you will see that we’re halfway through morphing the monkey’s initial head
    into a cube. Once it is at `1`, the initial geometry is morphed completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Same model, but now with cubeTarget set to 1](img/Figure_9.17_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Same model, but now with cubeTarget set to 1
  prefs: []
  type: TYPE_NORMAL
- en: And that’s the basics of how morph animations work. You’ve got several `morphTargets`
    (influences) you can control, and based on their value (from 0 to 1), the vertices
    move into the desired position. An animation that uses morph targets uses this
    approach. It just defines at which time certain vertex positions should occur.
    When running the animation, Three.js will make sure the right values are passed
    to the `morphTargets` property of the `Mesh` instance.
  prefs: []
  type: TYPE_NORMAL
- en: To run the predefined animation, you can open the `AnimationMixer` menu for
    this example, and click **Play**. You’ll see that the head will first transform
    into a cube and then into a cylinder, before moving back into the shape of a head.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the required components to accomplish this in Three.js can be done
    using the following pieces of code. First, we have to load the model. In this
    example, we exported this example from Blender into glTF, so our `animations`
    are at the top level. We simply add these to a variable that we can access in
    the other parts of the code. We could also set this as a property on the mesh
    or add it to the `userdata` property of `Mesh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve got an animation from the loaded model, we can set up the specific
    Three.js components so that we can play them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one final step we need to take so that the correct shape of the mesh
    is shown whenever we render something, and that is adding a single line to the
    render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `THREE.Clock` again to determine the time that’s passed between
    now and the previous render loop, and called `mixer.update()`. This information
    is used by the mixer to determine how far it should morph the vertices to the
    next morph target (keyframe).
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.AnimationMixer` and `THREE.AnimationClip` provide several other functions
    that you can use to control the animation or create new `THREE.AnimationClip`
    objects. You can experiment with them by using the menu on the right in the examples
    for this section. We will start with `THREE.AnimationClip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`duration`: The duration of this track (in seconds).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of this clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracks`: The internal property used to keep track of how certain properties
    of the model are animated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: The unique ID of this clip. This is assigned automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: Makes a copy of this clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimize()`: This optimizes `THREE.AnimationClip`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetDuration()`: This determines the correct duration of this clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJson()`: Converts this clip into a JSON object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim()`: This trims all the internal tracks to the duration set on this clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate()`: Does some minimal validation to see if this is a valid clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)`:
    This creates a list of `THREE.AnimationClip` instances based on a set of morph
    target sequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)`: This
    creates a single `THREE.AnimationClip` from a sequence of morph targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findByName(objectOrClipArray, name)`: Searches for a `THREE.AnimationClip`
    by name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse` and `toJson`: Allow you to restore and save a `Three.AnimationClip`
    as JSON, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseAnimation(animation, bones)`: Converts an `THREE.AnimationClip` into
    JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve got a `THREE.AnimationClip`, you can pass it into the `THREE.AnimationMixer`
    object, which provides the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnimationMixer(rootObject)`: The constructor for this object. This constructor
    takes a `THREE.Object3D` as an argument (for example, a `THREE.Mesh` of a `THREE.Group`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The global time for this mixer. This starts at 0, at the time when
    this mixer is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeScale`: This can be used to speed up or slow down all the animations managed
    by this mixer. If the value of this property is set to 0, all the animations are
    effectively paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clipAction(animationClip, optionalRoot)`: This creates a `THREE.AnimationAction`
    that can be used to control the passed-in `THREE.AnimationClip`. If the animation
    clip is for a different object than what was provided in the constructor of `AnimationMixer`,
    you can pass that in as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`existingAction(animationClip, optionalRoot)`: This returns the `THREE.AnimationAction`
    property, which can be used to control the passed-in `THREE.AnimationClip`. Once
    again, if `THREE.AnimationClip` is for a different `rootObject`, you can also
    pass that in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you get `THREE.AnimationClip` back, you can use it to control the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clampWhenFinished`: When set to `true`, this will cause the animation to be
    paused when it reaches its last frame. The default is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: When set to `false`, this will disable the current action so that
    it does not affect the model. When the action is re-enabled, the animation will
    continue where it left off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: This is the looping mode of this action (which can be set using the
    `setLoop` function). This can be set to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopOnce`: Plays the clip only one time'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopRepeat`: Repeats the clip based on the number of repetitions that
    have been set'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopPingPong`: Plays the clip based on the number of repetitions, but
    alternates between playing the clip forward and backward'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: Setting this property to `true` will pause the execution of this
    clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repetitions`: The number of times the animation will be repeated. This is
    used by the `loop` property. The default is `Infinity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The time this action has been running. This is wrapped from 0 to the
    duration of the clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeScale`: This can be used to speed up or slow down this animation. If the
    value of this property is set to `0`, this animation is effectively paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weight`: This specifies the effect this animation has on the model from a
    scale of `0` to `1`. When set to `0`, you won’t see any transformation of the
    model from this animation, and when set to `1`, you will see the full effect of
    this animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroSlopeAtEnd`: When set to true (which is the default), this will make sure
    there is a smooth transition between separate clips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroSlopeAtStart`: When set to true (which is the default), this will make
    sure there is a smooth transition between separate clips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)`: This causes
    this action to fade in, while `fadeOutAction` is faded out. The total fade takes
    `durationInSeconds`. This allows for smooth transitions between animations. When
    `warpBoolean` is set to `true`, it will apply additional smoothing of timescales.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)`: Same as `crossFadeFrom`,
    but this time, it fades in the provided action, and fades out this action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeIn(durationInSeconds)`: Increases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeOut(durationInSeconds)`: Decreases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEffectiveTimeScale()`: Returns the effective timescale based on the currently
    running warp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEffectiveWeight()`: Returns the effective weight based on the currently
    running fade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getClip()`: Returns the `THREE.AnimationClip` property this action is managing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMixer()`: Returns the mixer that is playing this action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRoot()`: Gets the root object that is controlled by this action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`halt(durationInSeconds)`: Gradually decreases `timeScale` to `0` within `durationInSeconds`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRunning()`: Checks whether the animation is currently running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isScheduled()`: Checks whether this action is currently active in the mixer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: Starts running this action (starting the animation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()`: Resets this action. This will result in setting `paused` to `false`,
    `enabled` to `true`, and `time` to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDuration(durationInSeconds)`: Sets the duration of a single loop. This
    will change `timeScale` so that the complete animation can play within `durationInSeconds`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEffectiveTimeScale(timeScale)`: Sets `timeScale` to the provided value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEffectiveWeight()`: Sets `weight` to the provided value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLoop(loopMode, repetitions)`: Sets `loopMode` and the number of `repetitions`.
    See the `loop` property for the options and their effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startAt(startTimeInSeconds)`: Delays starting the animation for `startTimeInSeconds`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: Stops this action, and `reset` is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopFading()`: Stops any scheduled fading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopWarping()`: Stops any schedule warping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syncWith(otherAction)`: Syncs this action with the passed-in action. This
    will set this action’s `time` and `timeScale` value to the passed-in action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warp(startTimeScale, endTimeScale, durationInSeconds)`: Changes the `timeScale`
    property from `startTimeScale` to `endTimeScale` within the specified `durationInSeconds`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides all the functions and properties that you can use to control the animation,
    `THREE.AnimationMixer` also provides two events you can listen to by calling `addEventListener`
    on the mixer. The `"loop"` event is sent when a single loop is finished, and the
    `"finished"` event is sent when the complete action has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Animation using bones and skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the *Animation with a mixer and morph targets* section, morph
    animations are very straightforward. Three.js knows all the target vertex positions
    and only needs to transition each vertex from one position to the next. For bones
    and skinning, it becomes a bit more complex. When you use bones for animation,
    you move the bone, and Three.js has to determine how to translate the attached
    skin (a set of vertices) accordingly. For this example, we will use a model that
    was exported from Blender into Three.js format (`lpp-rigging.gltf` in the `models/blender-skeleton`
    folder). This is a model of a person, complete with a set of bones. By moving
    the bones around, we can animate the complete model. First, let’s look at how
    we loaded the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ve exported the model in glTF format since the support for glTF in Three.js
    is good. Loading a model for bone animation isn’t that different than any of the
    other models. We just specify the model file and load it like any other glTF file.
    For glTF, the animations are in a separate property of the object that is loaded,
    so we simply assign it to the `animations` variable for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve added a console log, which shows what `THREE.Mesh` looks
    like once we’ve loaded it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects](img/Figure_9.18_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the mesh consists of a tree of bones and meshes. This
    also means that if you move a bone, the relevant meshes will be moved alongside
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Manually changing the rotation of the arm and leg bones](img/Figure_9.19_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Manually changing the rotation of the arm and leg bones
  prefs: []
  type: TYPE_NORMAL
- en: 'This scene also contains an animation, which you can trigger by checking the
    **animationIsPlaying** checkbox. This will override the manually set bones’ positions
    and rotations, and has the skeleton kind of jumping up and down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Playing a skeleton animation](img/Figure_9.20_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Playing a skeleton animation
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up this animation, we must follow the same steps we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with bones is just as easy as working with fixed morph
    targets. In this example, we’ve only adjusted the rotation of the bones; you can
    also move the position or change the scale. In the next section, we will look
    at loading animations from external models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations using external models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and Loading Advanced
    Meshes and Geometries*, we looked at several 3D formats that are supported by
    Three.js. A couple of those formats also support animations. In this chapter,
    we’ll look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLADA model**: The COLLADA format has support for animations. For this
    example, we’ll load an animation from a COLLADA file and render it with Three.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**glTF models**: **GL transmission format** (**glTF**) is a format specifically
    designed for storing 3D scenes and models. It focuses on minimizing the size of
    the assets and tries to be as efficient as possible in unpacking the models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FBX model**: FBX is a format produced by the Mixamo tooling available at
    [https://www.mixamo.com](https://www.mixamo.com). With Mixamo, you can easily
    rig and animate models, without needing lots of modeling experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BVH model**: The **Biovision** (**BVH**) format is a slightly different one
    compared to the other loaders. With this loader, you don’t load a geometry with
    a skeleton or a set of animations. With this format, which is used by Autodesk
    MotionBuilder, you just load a skeleton, which you can visualize or even attach
    to your geometry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with a glTF model since this format is becoming the standard for
    exchanging models between different tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using gltfLoader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A format that is getting more and more attention lately is the glTF format.
    This format, for which you can find a very extensive explanation at [https://github.com/KhronosGroup/glTF](https://github.com/KhronosGroup/glTF),
    focuses on optimizing size and resource usage. Using `glTFLoader` is similar to
    using the other loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This loader also loads a complete scene, so you can either add everything to
    the group or select child elements. For this example, you can view the results
    by opening `load-gltf.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Animation loaded using glTF](img/Figure_9.21_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Animation loaded using glTF
  prefs: []
  type: TYPE_NORMAL
- en: For the next example, we’ll use the FBX model.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing motions captured models using fbxLoader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Autodesk FBX format has been around for a while and is very easy to use.
    There is a great resource online where you can find many animations that you can
    download in this format: [https://www.mixamo.com/](https://www.mixamo.com/). This
    site provides 2,500 animations that you can use and customize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Loading animations from mixamo](img/Figure_9.22_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Loading animations from mixamo
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading an animation, using it from Three.js is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting animation, as you can see in `load-fbx.html`, looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Animation loaded using fbx](img/Figure_9.23_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Animation loaded using fbx
  prefs: []
  type: TYPE_NORMAL
- en: 'FBX and glTF are modern formats that are used a lot and are a good way to exchange
    models and animations. There are a couple of older formats around as well. An
    interesting one is a format used by the old FPS Quake: MD2.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading an animation from a Quake model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. Using an MD2 file is a bit different
    than using the others we’ve seen so far. When you load an MD2 model, you get a
    geometry, so you have to make sure that you create a material as well and assign
    a skin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have this `Mesh`, setting up the animation works in the same way.
    The result of this animation can be seen here (`load-md2.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Loaded Quake monster](img/Figure_9.24_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Loaded Quake monster
  prefs: []
  type: TYPE_NORMAL
- en: Next up is COLLADA.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an animation from a COLLADA model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the normal COLLADA models aren’t compressed (and they can get quite large),
    there is also a `KMZLoader` available in Three.js. This is a compressed COLLADA
    model, so if you run into `KMZLoader` instead of `ColladaLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Loaded COLLADA model](img/Figure_9.25_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Loaded COLLADA model
  prefs: []
  type: TYPE_NORMAL
- en: For the final loader, we’ll look at `BVHLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing a skeleton with BVHLoader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BVHLoader` is a slightly different loader than the ones we’ve seen so far.
    This loader doesn’t return meshes or geometries with animations; instead, it returns
    a skeleton and an animation. An example of this is shown in `load-bvh.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Loaded BVH skeleton](img/Figure_9.26_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Loaded BVH skeleton
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize this, we can use a `THREE.SkeletonHelper`, as seen here. With
    a `THREE.SkeletonHelper`, we can visualize the skeleton of a mesh. BVH models
    just contain skeleton information, which we can visualize like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In older versions of Three.js, there was support for other kinds of animation
    file formats. Most of those are obsolete and have subsequently been removed from
    the Three.js distribution. If you do stumble upon a different format in which
    you want to show the animations, you can look at the older Three.js releases and
    possibly reuse the loaders from there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different ways you can animate your scene. We
    started with some basic animation tricks, moved on to camera movement and control,
    and ended by looking at animating models using morph targets and skeleton/bones
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: When you have the render loop in place, adding simple animations is very easy.
    Just change a property of the mesh; in the next rendering step, Three.js will
    render the updated mesh. For more complex animations, you would usually model
    them in external programs and load them through one of the loaders provided by
    Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at the various materials we can use to skin
    our objects. For instance, we saw how we can change the color, shininess, and
    opacity of these materials. What we haven’t discussed in detail yet, however,
    is how we can use external images (also called textures) together with these materials.
    With textures, we can easily create objects that look as if they are made out
    of wood, metal, stone, and much more. In [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    we’ll explore all the different aspects of textures and how they are used in Three.js.
  prefs: []
  type: TYPE_NORMAL
