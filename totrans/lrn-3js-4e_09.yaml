- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation and Moving the Camera
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw some simple animations, but nothing too complex.
    In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene
    with Three.js*, we introduced the basic rendering loop, and in the chapters following
    that, we used that to rotate some simple objects and show a couple of other basic
    animation concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to look in more detail at how animation is supported
    by Three.js. We will look at the following four subjects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphing and skeleton animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations using external modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by covering the basic concepts behind animations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at the examples, let’s do a quick recap of what was shown in
    [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), on the render loop. To support
    animations, we need to tell Three.js to render the scene every so often. For this,
    we use the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this code, we only need to call the `render()` function once we’ve initialized
    the scene. In the `render()` function itself, we use `requestAnimationFrame` to
    schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times or 120 times
    a second). Before `requestAnimationFrame` was added to browsers, `setInterval(function,
    interval)` or `setTimeout(function, interval)` was used. These would call the
    specified function once every set interval.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it doesn’t take into account what else
    is going on. Even if your animation isn’t shown or is in a hidden tab, it is still
    called and is still using resources. Another issue is that these functions update
    the screen whenever they are called, and not when it is the best time for the
    browser, which results in higher CPU usage. With `requestAnimationFrame`, we don’t
    tell the browser when it needs to update the screen; we ask the browser to run
    the supplied function when it’s most opportune. Usually, this results in a frame
    rate of about 60 or 120 FPS (depending on your hardware). With `requestAnimationFrame`,
    your animations will run more smoothly and will be more CPU- and GPU-friendly,
    and you don’t have to worry about timing issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll start with creating a simple animation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Simple animations
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this approach, we can very easily animate objects by changing their `rotation`,
    `scale`, `position`, `material`, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    *Points and Sprites*, is available in `01-basic-animations.html`. The following
    screenshot shows this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Animation after changing its properties](img/Figure_9.1_B18726.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Animation after changing its properties
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 更改属性后的动画
- en: 'The render loop for this is very simple. First, we initialize the various properties
    on the `userData` object, which is a place for custom data stored in the `THREE.Mesh`
    itself, and then update these properties on the mesh, using the data we defined
    on the `userData` object. In the animation loop, just change the rotation, position,
    and the scale based on these properties, and Three.js handles the rest. Here’s
    how we do this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染循环非常简单。首先，我们在`userData`对象上初始化各种属性，这是一个存储在`THREE.Mesh`本身中的自定义数据位置，然后使用我们在`userData`对象上定义的数据更新这些属性。在动画循环中，只需根据这些属性更改旋转、位置和缩放，Three.js会处理其余部分。以下是我们的操作方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There’s nothing spectacular here, but it nicely shows the concept behind the
    basic animations we will discuss in this book. We just change the `scale`, `rotation`,
    and `position` properties and Three.js does the rest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处，但它很好地展示了我们将在这本书中讨论的基本动画背后的概念。我们只是更改`scale`、`rotation`和`position`属性，Three.js会处理其余部分。
- en: In the next section, we’ll take a quick sidestep. Besides animations, an important
    aspect that you’ll quickly run into when working with Three.js in more complex
    scenes is the ability to select objects on the screen using the mouse.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速跳转一下。除了动画之外，当你使用Three.js在更复杂的场景中工作时，你很快就会遇到的一个重要方面是使用鼠标在屏幕上选择对象的能力。
- en: Selecting and moving objects
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和移动对象
- en: 'Even though not directly related to animations, since we’ll be looking at cameras
    and animations in this chapter, knowing how to select and move objects is a nice
    addition to the subjects explained in this chapter. Here, we will show you how
    to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与动画没有直接关系，但由于我们将在本章中查看相机和动画，了解如何选择和移动对象是本章所解释主题的一个很好的补充。在这里，我们将向您展示如何完成以下操作：
- en: Select an object from a scene using the mouse
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标从场景中选择一个对象
- en: Drag an object around the scene with the mouse
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标在场景中拖动一个对象
- en: We’ll start by looking at the steps you need to take to select an object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看选择对象所需的步骤。
- en: Selecting objects
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择对象
- en: 'First, open the `selecting-objects.html` example, where you’ll see the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`selecting-objects.html`示例，你会看到以下内容：
- en: '![Figure 9.2 – Randomly placed cubes that can be selected with the mouse](img/Figure_9.2_B18726.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 可以用鼠标选择的随机放置的立方体](img/Figure_9.2_B18726.jpg)'
- en: Figure 9.2 – Randomly placed cubes that can be selected with the mouse
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 可以用鼠标选择的随机放置的立方体
- en: 'When you move the mouse around the scene, you’ll see that whenever your mouse
    hits an object, that object is highlighted. You can easily create this by using
    a `THREE.Raycaster`. A raycaster will look at your current camera and cast a ray
    from the camera to your mouse’s position. Based on that, it can calculate which
    object is hit based on the position of the mouse. To accomplish this, we need
    to take the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景中移动鼠标时，你会看到每当你的鼠标击中一个对象时，该对象就会被突出显示。你可以通过使用`THREE.Raycaster`轻松创建这个效果。Raycaster会查看你的当前相机，并从相机位置向鼠标位置发射一条射线。基于此，它可以根据鼠标的位置计算出被击中的对象。为了完成这个任务，我们需要采取以下步骤：
- en: Create an object that keeps track of where the mouse is pointing at
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个跟踪鼠标指向位置的对象
- en: Whenever we move the mouse, update that object
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们移动鼠标时，更新那个对象
- en: In the render loop, use this updated information to see which Three.js object
    we’re pointing at
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染循环中，使用这些更新信息来查看我们指向的Three.js对象
- en: 'This is shown in the following code fragment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的代码片段中显示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are using `THREE.Raycaster` to determine which objects intersect the
    position of the mouse, from the point of the camera. The result (`intersects`,
    in the preceding example) contains all the cubes that intersected our mouse because
    the ray is cast from the camera’s position through to the end of the camera’s
    range. The first one in this array is the one that we’re hovering over, and the
    other values in this array (if any) point to objects behind the first mesh. `THREE.Raycaster`
    also provides other information about exactly where you hit the object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`THREE.Raycaster`来确定哪些对象与相机点的鼠标位置相交。结果（在先前的示例中为`intersects`）包含所有与我们的鼠标相交的立方体，因为射线是从相机的位置发射到相机范围的末尾。在这个数组中的第一个是我们在悬停的对象，这个数组中的其他值（如果有）指向第一个网格后面的对象。`THREE.Raycaster`还提供了关于你击中对象的确切位置的其他信息：
- en: '![Figure 9.3 – Additional information from the raycaster](img/Figure_9.3_B18726.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Raycaster提供的信息](img/Figure_9.3_B18726.jpg)'
- en: Figure 9.3 – Additional information from the raycaster
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 来自射线投射器的附加信息
- en: Here, we clicked on the `face` object. `faceIndex` points to the face of the
    mesh that was selected. The `distance` value is measured from the camera to the
    clicked object, and `point` is the exact position on the mesh where it was clicked.
    Finally, we have the `uv` value, which determines, when using textures, where
    the point that was clicked appears on the 2D texture (ranging from 0 to 1; more
    information on `uv` can be found in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working* *With Textures*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们点击了`face`对象。`faceIndex`指向所选网格的表面。`distance`值是从相机到点击对象的距离，而`point`是点击在网格上的确切位置。最后，我们有`uv`值，当使用纹理时，它决定了点击的点在2D纹理上的位置（范围从0到1；有关`uv`的更多信息，请参阅[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和操作*
    *纹理*)。
- en: Dragging objects
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动对象
- en: 'Besides selecting an object, a common requirement is being able to drag and
    move objects around. Three.js also provides default support for this. If you open
    the `dragging-objects.html` example in your browser, you’ll see a similar scene
    to the one shown in *Figure 9**.2*. This time, when you click on an object, you
    can drag it around the scene:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择对象外，一个常见的需求是能够拖动和移动对象。Three.js也为此提供了默认支持。如果你在浏览器中打开`dragging-objects.html`示例，你会看到一个类似于*图9.2*所示的场景。这次，当你点击一个对象时，你可以将其拖动到场景中：
- en: '![Figure 9.4 – Dragging an object around the scene using the mouse](img/Figure_9.4_B18726.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用鼠标在场景中拖动对象](img/Figure_9.4_B18726.jpg)'
- en: Figure 9.4 – Dragging an object around the scene using the mouse
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用鼠标在场景中拖动对象
- en: 'To support dragging objects, Three.js uses something called `DragControls`.
    This handles everything and provides convenient callbacks whenever the dragging
    starts and stops. The code to accomplish this is shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持拖动对象，Three.js使用一种称为`DragControls`的东西。它处理所有事情，并在拖动开始和停止时提供方便的回调。完成此操作的代码如下：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is as simple as that. Here, we added `DragControls` and passed in the elements
    that can be dragged (in our case, all of the randomly placed cubes). Then, we
    added two event listeners. The first one, `dragstart`, is called when we start
    dragging a cube, whereas `dragend` is called when we stop dragging an object.
    In this example, when we start dragging, we disable `OrbitControls` (which allows
    us to use the mouse to look around the scene) and change the color of the selected
    object. Once we stop dragging, we change the color of the object back and enable
    `OrbitControls` again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单。在这里，我们添加了`DragControls`并传递了可以拖动的元素（在我们的例子中，是所有随机放置的立方体）。然后，我们添加了两个事件监听器。第一个，`dragstart`，在我们开始拖动立方体时被调用，而`dragend`在我们停止拖动对象时被调用。在这个例子中，当我们开始拖动时，我们禁用了`OrbitControls`（它允许我们使用鼠标在场景周围查看）并更改了所选对象的颜色。一旦我们停止拖动，我们将对象的颜色改回并再次启用`OrbitControls`。
- en: 'There is also a somewhat more advanced version of `DragControls` available
    called `TransformControls`. We won’t go into the details of this control, but
    it allows you to use a simple UI to transform the properties of a mesh. You can
    find an example of this control when you open `transform-controls-html` in your
    browser:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更高级的`DragControls`版本，称为`TransformControls`。我们不会深入探讨这个控制器的细节，但它允许你使用简单的UI来变换网格的属性。当你打开浏览器中的`transform-controls-html`时，你可以找到一个此控制器的示例：
- en: '![Figure 9.5 – Transform controls allow you to change the properties of a mesh](img/Figure_9.5_B18726.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 变换控制器允许你改变网格的属性](img/Figure_9.5_B18726.jpg)'
- en: Figure 9.5 – Transform controls allow you to change the properties of a mesh
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 变换控制器允许你改变网格的属性
- en: 'If you click on the various parts of this control, you can easily change the
    shape of the cube:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个控制器的各个部分，你可以轻松地改变立方体的形状：
- en: '![Figure 9.6 – Shape modified using transform controls](img/Figure_9.6_B18726.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 使用变换控制器修改的形状](img/Figure_9.6_B18726.jpg)'
- en: Figure 9.6 – Shape modified using transform controls
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 使用变换控制器修改的形状
- en: For the final example in this chapter, we’ll show you how you can use an alternative
    way of modifying the properties of an object (as we saw in the first example of
    this chapter) by using a tweening library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个例子中，我们将向你展示如何使用一个替代方法来修改对象的属性（正如我们在本章的第一个例子中所见），即使用缓动库。
- en: Animating with Tween.js
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tween.js进行动画
- en: 'Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called `x` position of a mesh from 10 to 3 in 10 seconds,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can create a separate object and pass that into the mesh
    you want to work with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we’ve created `TWEEN.Tween`. This tween will make sure that
    the `x` property is changed from 10 to 3 over 10,000 milliseconds. Tween.js also
    allows you to define how this property is changed over time. This can be done
    using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The value is changed over time by a process called `easing()`
    function. This library also provides additional ways to control how this easing
    is done. For instance, we can set how often the easing should be repeated (`repeat(10)`)
    and whether we want a yoyo effect (this means we go from 10 to 3 and back to 10
    in this example).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this library together with Three.js is very simple. If you open the `tween-animations.html`
    example, you will see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Tweening a point system halfway through the action](img/Figure_9.7_B18726.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Tweening a point system halfway through the action
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the Tween.js library to move this to a single point using a specific
    `easing()`, which at a certain point looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Tweening a point when everything is merged into a single point](img/Figure_9.8_B18726.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Tweening a point when everything is merged into a single point
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve taken a point cloud from [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    and created an animation where all the points slowly move down to the center.
    The position of these particles is set by using a tween created with the Tween.js
    library, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this piece of code, we created a tween that transitions a value from `1`
    to `0` and back again. To use the value from the tween, we have two different
    options: we can use the `onUpdate` function provided by this library to call a
    function with the updated values, whenever the tween is updated (which is done
    by calling `TWEEN.update()`), or we can directly access the updated values. In
    this example, we used the latter approach.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the changes we need to make in the `render` function, we
    must perform one additional step after we load the model. We want to tween between
    the original values to zero and back again. For this, we need to store the original
    positions of the vertices somewhere. We can do this by copying the starting positions
    array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, whenever we want to access the original position, we can look at the `originalPos`
    attribute on the geometry. Now, we can just use the value from the tween to calculate
    the new positions of each of the vertices. We can do this like so in the render
    loop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时我们想要访问原始位置，我们都可以查看几何体的 `originalPos` 属性。现在，我们可以直接使用 tween 的值来计算每个顶点的新位置。我们可以在渲染循环中这样做：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With these steps in place, the tween library will take care of positioning the
    various points on the screen. As you can see, using this library is much easier
    than having to manage the transitions yourself. Besides animating and changing
    objects, we can also animate a scene by moving the camera around. In the previous
    chapters, we did this a couple of times by manually updating the position of the
    camera. Three.js also provides several additional ways of updating the camera.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤到位后， tween 库将负责处理屏幕上各个点的位置。正如你所见，使用这个库比手动管理过渡要容易得多。除了动画和改变对象，我们还可以通过移动相机来动画化场景。在前面的章节中，我们通过手动更新相机位置做了几次这样的操作。Three.js
    也提供了几种更新相机位置的方法。
- en: Working with the camera
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: 'Three.js has several camera controls you can use to control the camera throughout
    a scene. These controls are located in the Three.js distribution and can be found
    in the `examples/js/controls` directory. In this section, we’ll look at the following
    controls in more detail:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了几个相机控制，你可以使用它们在场景中控制相机。这些控制位于 Three.js 分发中，可以在 `examples/js/controls`
    目录中找到。在本节中，我们将更详细地查看以下控制：
- en: '`ArcballControls`: An extensive control that provides a transparent overlay
    that you can use to easily move the camera around.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArcballControls`：一个提供透明覆盖层的扩展控制，你可以用它轻松地移动相机。'
- en: '`FirstPersonControls`: These are controls that behave like those in first-person
    shooters. You can move around with the keyboard and look around with the mouse.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstPersonControls`：这些是像第一人称射击游戏中的控制方式。你可以用键盘移动，用鼠标环顾四周。'
- en: '`FlyControls`: These are flight simulator-like controls. You can move and steer
    with the keyboard and the mouse.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyControls`：这些是类似飞行模拟器的控制。你可以用键盘和鼠标移动和操控。'
- en: '`OrbitControls`: This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrbitControls`：这模拟了一个围绕特定场景运行的卫星。这允许你使用鼠标和键盘移动。'
- en: '`PointerLockControls`: These are similar to the first-person controls but they
    also lock the mouse pointer to the screen, making it a great choice for simple
    games.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerLockControls`：这些与第一人称控制类似，但它们还会锁定鼠标指针到屏幕上，这使得它们成为简单游戏的一个很好的选择。'
- en: '`TrackBallControls`: These are the most-used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrackBallControls`：这些是最常用的控制，允许你使用鼠标（或轨迹球）轻松地移动、平移和缩放场景。'
- en: Besides using these camera controls, you can also move the camera yourself by
    setting its position and changing where it is pointed using the `lookAt()` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些相机控制，你也可以通过设置其位置并使用 `lookAt()` 函数改变其指向来自行移动相机。
- en: The first control we’ll look at is `ArcballControls`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下 `ArcballControls`。
- en: ArcballControls
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArcballControls
- en: 'The easiest way to explain how `ArcballControls` works is by looking at an
    example. If you open up the `arcball-controls.html` example, you’ll see a simple
    scene, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 `ArcballControls` 的工作方式最简单的方法是查看一个示例。如果你打开 `arcball-controls.html` 示例，你会看到一个简单的场景，就像这样：
- en: '![Figure 9.9 – Using ArcballControls to explore a scene](img/Figure_9.9_B18726.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 使用 ArcballControls 探索场景](img/Figure_9.9_B18726.jpg)'
- en: Figure 9.9 – Using ArcballControls to explore a scene
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 使用 ArcballControls 探索场景
- en: If you look closely at this screenshot, you will see two translucent lines crossing
    the scene. These are lines provided by `ArcballControls`, which you can use to
    rotate and pan around the scene. These lines are called **gizmos**. The left mouse
    button is used to rotate the scene, the right mouse button can be used to pan
    around, and you can zoom in with the scroll wheel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察这张截图，你会看到两条透明的线条穿过场景。这些是由 `ArcballControls` 提供的线条，你可以使用它们来旋转和平移场景。这些线条被称为
    **gizmos**。左键用于旋转场景，右键可以用来平移，滚动鼠标滚轮可以放大。
- en: 'Besides this standard functionally, this control also allows you to focus on
    specific parts of the mesh that is shown. If you double-click on the scene, the
    camera will focus on that part of the scene. To use this control, all we need
    to do is instantiate it and pass in the `camera` property, the `domElement` property
    used by the renderer, and the `scene` property we’re looking at:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This control is a very versatile one, which can be configured through a set
    of properties. Most of these properties can be explored in this example by using
    the menu on the right of this example. For this specific control, we’ll dive a
    bit deeper into the properties and methods provided by this object since it is
    a versatile control and a good choice when you want to provide a good way for
    your users to explore your scenes. Let’s provide an overview of the properties
    and the methods provided by this control. First, let’s look at the properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`adjustNearFar`: If this is set to `true`, this control will change the camera’s
    `near` and `far` properties when zooming in'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camera`: The camera that’s used when creating this control'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cursorZoom`: If set to `true`, when zooming in, the zoom will be focused on
    the position of the cursor'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dampingFactor`: If `enableAnimations` is set to `true`, this value will determine
    how quickly an animation stops after an action'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domElement`: This element is used to list mouse events'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: Determines whether this control is enabled or not'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enableRotate`, `enableZoom`, `enablePan`, `enableGrid`, `enableAnimations`:
    These properties enable and disable functionality provided by this control'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`focusAnimationTime`: When we double-click and focus on part of the scene,
    this property determines the duration of the focusing animation'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDistance`/`minDistance`: How far we can zoom out and in for `PerspectiveCamera`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxZoom`/`minZoom`: How far we can zoom out and in for `OrthographicCamera`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scaleFactor`: How fast we zoom in and out'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scene`: The scene passed in the constructor'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radiusFactor`: The size of the “gizmo” relative to the screen’s width and
    height'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wMax`: How fast we’re allowed to rotate the scene'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This control also provides several methods to interact or configure it further:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`activateGizmos(bool)`: If `true`, it highlights the gizmos'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copyState()`, `pasteState()`: Allows you to copy and paste the state of the
    controls to the clipboard in JSON'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveState()`, `reset()`: Internally saves the current state and uses `reset()`
    to apply the saved state'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispose()`: Removes all parts of this control from the scene, and cleans up
    any listeners and animations'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setGizomsVisible(bool)`: Specifies whether to show or hide the gizmos'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTbRadius(radiusFactor)`: Updates the `radiusFactor` property and redraws
    the gizmos'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMouseAction(operation, mouse, key)`: Determines which mouse key provides
    which action'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsetMouseAction(mouse, key)`: Clears an assigned mouse action'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`: Whenever the camera properties change, call this to apply these
    new settings to this control'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRayCaster()`: Provides access to `rayCaster`, which is used internally
    by these controls'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArcballControls` is a really useful and relatively new addition to Three.js
    that provides advanced control of the scene using the mouse. If you’re looking
    for a simpler approach, you can use `TrackBallControls`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: TrackBallControls
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `TrackBallControls` follows the same approach as we saw for `ArcballControls`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This time, we just need to pass in the `camera` and `domeElement` properties
    from the renderer. For the trackball controls to work, we also need to add a `THREE.Clock`
    and update the render loop, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we can see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to calculate the elapsed time that a specific
    invocation or rendering loop takes to complete. You can do this by calling the
    `clock.getDelta()` function. This function will return the elapsed time between
    this call and the previous call to `getDelta()`. To update the position of the
    camera, we can call the `TrackBallControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we can use the `getDelta()` function from the `THREE.Clock`
    object. You might be wondering why we don’t just pass in the frame rate (1/60
    seconds) to the update function. The reason is that with `requestAnimationFrame`,
    we can expect 60 FPS, but this isn’t guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'A working example of this can be found in `trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Using TrackBallControls to control a scene](img/Figure_9.10_B18726.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Using TrackBallControls to control a scene
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the camera in the following manner:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Left mouse button and move**: Rotate and roll the camera around the scene'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scroll wheel**: Zoom in and zoom out'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle mouse button and move**: Zoom in and zoom out'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right mouse button and move**: Pan around the scene'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won’t go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackBallControls.js` file, where these properties are listed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: FlyControls
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next control we’ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `fly-controls-camera.html`. The following screenshot shows a still
    image of this example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Using FlyControls to fly around a scene](img/Figure_9.11_B18726.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Using FlyControls to fly around a scene
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling `FlyControls` works in the same manner as the other controls:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FlyControls` takes the camera and the renderer’s `domElement` as arguments
    and requires that you call the `update()` function with the elapsed time in the
    render loop. You can control the camera with `THREE.FlyControls` in the following
    manner:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Left and middle mouse buttons**: Start moving forward'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right mouse button**: Move backward'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mouse movement**: Look around'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*W*: Start moving forward'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*: Move backward'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A*: Move left'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Move right'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*: Move up'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Move down'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left, right, up, and down arrows**: Look left, right, up, and down, respectively'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: Roll left'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Roll right'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next control we’ll look at is `THREE.FirstPersonControls`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: FirstPersonControls
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around, and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Exploring a scene using the first-person controls](img/Figure_9.12_B18726.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Exploring a scene using the first-person controls
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating these controls follows the same principles as the ones followed for
    the other controls we’ve seen so far:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The functionality provided by this control is pretty straightforward:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Mouse movement**: Look around'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left, right, up, and down arrows**: Move left, right, forward, and backward,
    respectively'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*W*: Move forward'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A*: Move left'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*: Move backward'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Move right'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*: Move up'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Move down'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Q*: Stop all movement'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the final control, we’ll move on from this first-person perspective to the
    perspective from space.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: OrbitControls
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OrbitControls` control is a great way to rotate and pan around an object
    in the center of the scene. This is also the control we used in the other chapters
    to provide you with a simple way to explore the models in the examples provided.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'With `orbit-controls-orbit-camera.html`, we’ve included an example that shows
    how this control works. The following screenshot shows a still image of this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – OrbitControls properties](img/Figure_9.13_B18726.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – OrbitControls properties
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `OrbitControls` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The controls for `OrbitControls` are focused on using the mouse, as shown in
    the following list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Left mouse click and move**: Rotate the camera around the center of the scene'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左键点击并移动**：围绕场景中心旋转相机'
- en: '**Scroll wheel or middle mouse click and move**: Zoom in and zoom out'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚轮或中间鼠标点击并移动**：放大和缩小'
- en: '**Right mouse click and move**: Pan around the scene'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右键点击并移动**：在场景中平移'
- en: 'That’s it for the camera and moving it around. In this section, we saw a lot
    of controls that allow you to easily interact with and move through a scene by
    changing the camera properties. In the next section, we’ll look at more advanced
    methods of animation: morphing and skinning.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于相机及其移动就到这里。在本节中，我们看到了许多允许你通过改变相机属性轻松交互和移动场景的控制。在下一节中，我们将探讨更高级的动画方法：形变和蒙皮。
- en: Morphing and skeleton animation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形变和骨骼动画
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在外部程序（例如 Blender）中创建动画时，通常有两个主要选项来定义动画：
- en: '**Morph targets**: With morph targets, you define a deformed version – that
    is, a key position – of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (this screenshot has
    been provided by the Blender foundation):'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形变目标**：使用形变目标，你定义网格的变形版本——即关键位置。对于这个变形目标，存储了所有顶点的位置。要动画化形状，你只需将所有顶点从一个位置移动到另一个关键位置，并重复此过程。以下截图显示了用于展示面部表情的各种形变目标（此截图由
    Blender 基金会提供）：'
- en: '![Figure 9.14 – Setting up animations using morph targets](img/Figure_9.14_B18726.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 使用形变目标设置动画](img/Figure_9.14_B18726.jpg)'
- en: Figure 9.14 – Setting up animations using morph targets
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 使用形变目标设置动画
- en: '**Skeleton animation**: An alternative is using skeleton animation. With skeletal
    animation, you define the skeleton – that is, the bones – of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼动画**：另一种选择是使用骨骼动画。在骨骼动画中，你定义网格的骨骼（即骨骼），并将顶点附着到特定的骨骼上。现在，当你移动一个骨骼时，任何连接的骨骼也会相应地移动，并且附着的顶点会根据骨骼的位置、运动和缩放进行移动和变形。以下截图，再次由
    Blender 基金会提供，展示了如何使用骨骼来移动和变形对象：'
- en: '![Figure 9.15 – Setting up animations using bones](img/Figure_9.15_B18726.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 使用骨骼设置动画](img/Figure_9.15_B18726.jpg)'
- en: Figure 9.15 – Setting up animations using bones
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 使用骨骼设置动画
- en: Three.js supports both modes, but there can be an issue getting a good export
    when you want to work with skeleton/bones-based animations. For the best results,
    you should export or convert your model into glTF format, which is becoming the
    default for exchanging models, animations, and scenes, and has great support from
    Three.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 支持这两种模式，但在处理基于骨骼/骨骼的动画时，可能会遇到导出良好的问题。为了获得最佳结果，你应该将你的模型导出或转换为 glTF 格式，该格式正成为交换模型、动画和场景的默认格式，并且得到了
    Three.js 的良好支持。
- en: In this section, we’ll look at both options and also look at a couple of external
    formats supported by Three.js in which animations can be defined.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这两种选项，并查看 Three.js 支持的几种外部格式，在这些格式中可以定义动画。
- en: Animation with morph targets
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于形变目标的动画
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called keyframes) and
    tell Three.js to move the vertices from one position to the other.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 形变目标是定义动画最直接的方式。你为每个重要位置（也称为关键帧）定义所有顶点，并告诉 Three.js 将顶点从一个位置移动到另一个位置。
- en: We’ll show you how to work with morph targets using two examples. In the first
    example, we’ll let Three.js handle the transition between the various keyframes
    (or morph targets, as we’ll call them from now on), and in the second one, we’ll
    do this manually. Keep in mind that we are only scratching the surface of what
    is possible with animations in Three.js. As you’ll see in this section, Three.js
    has excellent support for controlling animations, supports syncing of animations,
    and provides ways to smoothly transition from one animation to another, warranting
    a book just on this subject. So, in the next couple of sections, we’ll provide
    you with the basics of animations in Three.js, which should provide you with enough
    information to get started and explore the more complex subjects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Animation with a mixer and morph targets
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the examples, first, we’ll look at the three core classes
    that you can use to animate with Three.js. Later in this chapter, we’ll show you
    all the functions and properties provided by these objects:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.AnimationClip`: When you load a model that contains animations, you
    can look in the `response` object for a field usually called `animations`. This
    field will contain a list of `THREE.AnimationClip` objects. Note that depending
    on the loader, an animation might be defined on a `Mesh`, a `Scene`, or be provided
    completely separately. A `THREE.AnimationClip` most often holds the data for a
    certain animation the model you loaded can perform. For instance, if you loaded
    a model of a bird, one `THREE.AnimationClip` would contain the information needed
    to flap the wings, and another one might be opening and closing its beak.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.AnimationMixer`: `THREE.AnimationMixer` is used to control several `THREE.AnimationClip`
    objects. It makes sure the timing of the animation is correct and makes it possible
    to sync animations together, or cleanly move from one animation to another.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.AnimationAction`: `THREE.AnimationMixer` itself doesn’t expose a large
    number of functions to control the animation, though. This is done through `THREE.AnimationAction`
    objects, which are returned when you add a `THREE.AnimationClip` to a `THREE.AnimationMixer`
    (though you can get them at a later time by using functions provided by `THREE.AnimationMixer`).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an `AnimationObjectGroup`, which you can use to provide the animation
    state not just to a single `Mesh` but to a group of objects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you can control a `THREE.AnimationMixer` and a `THREE.AnimationAction`,
    which were created using a `THREE.AnimationClip` from the model. The `THREE.AnimationClip`
    objects used in this example morph a model into a cube and then into a cylinder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'For this first morphing example, the easiest way to understand how a morph
    targets-based animation works is by opening up the `morph-targets.html` example.
    The following screenshot shows a still image of this example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Animation using morph targets](img/Figure_9.16_B18726.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Animation using morph targets
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve got a simple model (a monkey’s head), which can be transformed
    into either a cube or a cylinder using morph targets. You can easily test this
    yourself by moving the `cubeTarget` or `coneTarget` sliders, and you’ll see the
    head being morphed into a different shape. For instance, with `cubeTarget` at
    `0.5`, you will see that we’re halfway through morphing the monkey’s initial head
    into a cube. Once it is at `1`, the initial geometry is morphed completely:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Same model, but now with cubeTarget set to 1](img/Figure_9.17_B18726.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Same model, but now with cubeTarget set to 1
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: And that’s the basics of how morph animations work. You’ve got several `morphTargets`
    (influences) you can control, and based on their value (from 0 to 1), the vertices
    move into the desired position. An animation that uses morph targets uses this
    approach. It just defines at which time certain vertex positions should occur.
    When running the animation, Three.js will make sure the right values are passed
    to the `morphTargets` property of the `Mesh` instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: To run the predefined animation, you can open the `AnimationMixer` menu for
    this example, and click **Play**. You’ll see that the head will first transform
    into a cube and then into a cylinder, before moving back into the shape of a head.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the required components to accomplish this in Three.js can be done
    using the following pieces of code. First, we have to load the model. In this
    example, we exported this example from Blender into glTF, so our `animations`
    are at the top level. We simply add these to a variable that we can access in
    the other parts of the code. We could also set this as a property on the mesh
    or add it to the `userdata` property of `Mesh`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we’ve got an animation from the loaded model, we can set up the specific
    Three.js components so that we can play them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is one final step we need to take so that the correct shape of the mesh
    is shown whenever we render something, and that is adding a single line to the
    render loop:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we used `THREE.Clock` again to determine the time that’s passed between
    now and the previous render loop, and called `mixer.update()`. This information
    is used by the mixer to determine how far it should morph the vertices to the
    next morph target (keyframe).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.AnimationMixer` and `THREE.AnimationClip` provide several other functions
    that you can use to control the animation or create new `THREE.AnimationClip`
    objects. You can experiment with them by using the menu on the right in the examples
    for this section. We will start with `THREE.AnimationClip`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`duration`: The duration of this track (in seconds).'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of this clip.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracks`: The internal property used to keep track of how certain properties
    of the model are animated.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: The unique ID of this clip. This is assigned automatically.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: Makes a copy of this clip.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimize()`: This optimizes `THREE.AnimationClip`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetDuration()`: This determines the correct duration of this clip.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJson()`: Converts this clip into a JSON object.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim()`: This trims all the internal tracks to the duration set on this clip.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate()`: Does some minimal validation to see if this is a valid clip.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)`:
    This creates a list of `THREE.AnimationClip` instances based on a set of morph
    target sequences.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)`: This
    creates a single `THREE.AnimationClip` from a sequence of morph targets.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findByName(objectOrClipArray, name)`: Searches for a `THREE.AnimationClip`
    by name.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse` and `toJson`: Allow you to restore and save a `Three.AnimationClip`
    as JSON, respectively.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseAnimation(animation, bones)`: Converts an `THREE.AnimationClip` into
    JSON.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve got a `THREE.AnimationClip`, you can pass it into the `THREE.AnimationMixer`
    object, which provides the following functionality:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`AnimationMixer(rootObject)`: The constructor for this object. This constructor
    takes a `THREE.Object3D` as an argument (for example, a `THREE.Mesh` of a `THREE.Group`).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The global time for this mixer. This starts at 0, at the time when
    this mixer is created.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeScale`: This can be used to speed up or slow down all the animations managed
    by this mixer. If the value of this property is set to 0, all the animations are
    effectively paused.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clipAction(animationClip, optionalRoot)`: This creates a `THREE.AnimationAction`
    that can be used to control the passed-in `THREE.AnimationClip`. If the animation
    clip is for a different object than what was provided in the constructor of `AnimationMixer`,
    you can pass that in as well.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`existingAction(animationClip, optionalRoot)`: This returns the `THREE.AnimationAction`
    property, which can be used to control the passed-in `THREE.AnimationClip`. Once
    again, if `THREE.AnimationClip` is for a different `rootObject`, you can also
    pass that in.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you get `THREE.AnimationClip` back, you can use it to control the animation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`clampWhenFinished`: When set to `true`, this will cause the animation to be
    paused when it reaches its last frame. The default is `false`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: When set to `false`, this will disable the current action so that
    it does not affect the model. When the action is re-enabled, the animation will
    continue where it left off.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: This is the looping mode of this action (which can be set using the
    `setLoop` function). This can be set to the following:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopOnce`: Plays the clip only one time'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopRepeat`: Repeats the clip based on the number of repetitions that
    have been set'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LoopPingPong`: Plays the clip based on the number of repetitions, but
    alternates between playing the clip forward and backward'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: Setting this property to `true` will pause the execution of this
    clip.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repetitions`: The number of times the animation will be repeated. This is
    used by the `loop` property. The default is `Infinity`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The time this action has been running. This is wrapped from 0 to the
    duration of the clip.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeScale`: This can be used to speed up or slow down this animation. If the
    value of this property is set to `0`, this animation is effectively paused.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weight`: This specifies the effect this animation has on the model from a
    scale of `0` to `1`. When set to `0`, you won’t see any transformation of the
    model from this animation, and when set to `1`, you will see the full effect of
    this animation.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroSlopeAtEnd`: When set to true (which is the default), this will make sure
    there is a smooth transition between separate clips.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroSlopeAtStart`: When set to true (which is the default), this will make
    sure there is a smooth transition between separate clips.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)`: This causes
    this action to fade in, while `fadeOutAction` is faded out. The total fade takes
    `durationInSeconds`. This allows for smooth transitions between animations. When
    `warpBoolean` is set to `true`, it will apply additional smoothing of timescales.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)`: Same as `crossFadeFrom`,
    but this time, it fades in the provided action, and fades out this action.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeIn(durationInSeconds)`: Increases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeOut(durationInSeconds)`: Decreases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEffectiveTimeScale()`: Returns the effective timescale based on the currently
    running warp.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEffectiveWeight()`: Returns the effective weight based on the currently
    running fade.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getClip()`: Returns the `THREE.AnimationClip` property this action is managing.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMixer()`: Returns the mixer that is playing this action.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRoot()`: Gets the root object that is controlled by this action.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`halt(durationInSeconds)`: Gradually decreases `timeScale` to `0` within `durationInSeconds`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRunning()`: Checks whether the animation is currently running.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isScheduled()`: Checks whether this action is currently active in the mixer.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play()`: Starts running this action (starting the animation).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()`: Resets this action. This will result in setting `paused` to `false`,
    `enabled` to `true`, and `time` to `0`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDuration(durationInSeconds)`: Sets the duration of a single loop. This
    will change `timeScale` so that the complete animation can play within `durationInSeconds`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEffectiveTimeScale(timeScale)`: Sets `timeScale` to the provided value.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEffectiveWeight()`: Sets `weight` to the provided value.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLoop(loopMode, repetitions)`: Sets `loopMode` and the number of `repetitions`.
    See the `loop` property for the options and their effect.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startAt(startTimeInSeconds)`: Delays starting the animation for `startTimeInSeconds`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: Stops this action, and `reset` is applied.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopFading()`: Stops any scheduled fading.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopWarping()`: Stops any schedule warping.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syncWith(otherAction)`: Syncs this action with the passed-in action. This
    will set this action’s `time` and `timeScale` value to the passed-in action.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warp(startTimeScale, endTimeScale, durationInSeconds)`: Changes the `timeScale`
    property from `startTimeScale` to `endTimeScale` within the specified `durationInSeconds`.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides all the functions and properties that you can use to control the animation,
    `THREE.AnimationMixer` also provides two events you can listen to by calling `addEventListener`
    on the mixer. The `"loop"` event is sent when a single loop is finished, and the
    `"finished"` event is sent when the complete action has finished.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Animation using bones and skinning
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the *Animation with a mixer and morph targets* section, morph
    animations are very straightforward. Three.js knows all the target vertex positions
    and only needs to transition each vertex from one position to the next. For bones
    and skinning, it becomes a bit more complex. When you use bones for animation,
    you move the bone, and Three.js has to determine how to translate the attached
    skin (a set of vertices) accordingly. For this example, we will use a model that
    was exported from Blender into Three.js format (`lpp-rigging.gltf` in the `models/blender-skeleton`
    folder). This is a model of a person, complete with a set of bones. By moving
    the bones around, we can animate the complete model. First, let’s look at how
    we loaded the model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve exported the model in glTF format since the support for glTF in Three.js
    is good. Loading a model for bone animation isn’t that different than any of the
    other models. We just specify the model file and load it like any other glTF file.
    For glTF, the animations are in a separate property of the object that is loaded,
    so we simply assign it to the `animations` variable for easy access.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve added a console log, which shows what `THREE.Mesh` looks
    like once we’ve loaded it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects](img/Figure_9.18_B18726.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the mesh consists of a tree of bones and meshes. This
    also means that if you move a bone, the relevant meshes will be moved alongside
    it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a still image of this example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Manually changing the rotation of the arm and leg bones](img/Figure_9.19_B18726.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Manually changing the rotation of the arm and leg bones
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'This scene also contains an animation, which you can trigger by checking the
    **animationIsPlaying** checkbox. This will override the manually set bones’ positions
    and rotations, and has the skeleton kind of jumping up and down:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Playing a skeleton animation](img/Figure_9.20_B18726.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Playing a skeleton animation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up this animation, we must follow the same steps we saw earlier:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, working with bones is just as easy as working with fixed morph
    targets. In this example, we’ve only adjusted the rotation of the bones; you can
    also move the position or change the scale. In the next section, we will look
    at loading animations from external models.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations using external models
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and Loading Advanced
    Meshes and Geometries*, we looked at several 3D formats that are supported by
    Three.js. A couple of those formats also support animations. In this chapter,
    we’ll look at the following examples:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**COLLADA model**: The COLLADA format has support for animations. For this
    example, we’ll load an animation from a COLLADA file and render it with Three.js.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**glTF models**: **GL transmission format** (**glTF**) is a format specifically
    designed for storing 3D scenes and models. It focuses on minimizing the size of
    the assets and tries to be as efficient as possible in unpacking the models.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FBX model**: FBX is a format produced by the Mixamo tooling available at
    [https://www.mixamo.com](https://www.mixamo.com). With Mixamo, you can easily
    rig and animate models, without needing lots of modeling experience.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BVH model**: The **Biovision** (**BVH**) format is a slightly different one
    compared to the other loaders. With this loader, you don’t load a geometry with
    a skeleton or a set of animations. With this format, which is used by Autodesk
    MotionBuilder, you just load a skeleton, which you can visualize or even attach
    to your geometry.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with a glTF model since this format is becoming the standard for
    exchanging models between different tools and libraries.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Using gltfLoader
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A format that is getting more and more attention lately is the glTF format.
    This format, for which you can find a very extensive explanation at [https://github.com/KhronosGroup/glTF](https://github.com/KhronosGroup/glTF),
    focuses on optimizing size and resource usage. Using `glTFLoader` is similar to
    using the other loaders:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This loader also loads a complete scene, so you can either add everything to
    the group or select child elements. For this example, you can view the results
    by opening `load-gltf.js`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Animation loaded using glTF](img/Figure_9.21_B18726.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Animation loaded using glTF
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: For the next example, we’ll use the FBX model.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing motions captured models using fbxLoader
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Autodesk FBX format has been around for a while and is very easy to use.
    There is a great resource online where you can find many animations that you can
    download in this format: [https://www.mixamo.com/](https://www.mixamo.com/). This
    site provides 2,500 animations that you can use and customize:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Loading animations from mixamo](img/Figure_9.22_B18726.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Loading animations from mixamo
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading an animation, using it from Three.js is easy:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting animation, as you can see in `load-fbx.html`, looks great:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Animation loaded using fbx](img/Figure_9.23_B18726.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Animation loaded using fbx
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'FBX and glTF are modern formats that are used a lot and are a good way to exchange
    models and animations. There are a couple of older formats around as well. An
    interesting one is a format used by the old FPS Quake: MD2.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Loading an animation from a Quake model
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. Using an MD2 file is a bit different
    than using the others we’ve seen so far. When you load an MD2 model, you get a
    geometry, so you have to make sure that you create a material as well and assign
    a skin:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have this `Mesh`, setting up the animation works in the same way.
    The result of this animation can be seen here (`load-md2.html`):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Loaded Quake monster](img/Figure_9.24_B18726.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Loaded Quake monster
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Next up is COLLADA.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Loading an animation from a COLLADA model
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the normal COLLADA models aren’t compressed (and they can get quite large),
    there is also a `KMZLoader` available in Three.js. This is a compressed COLLADA
    model, so if you run into `KMZLoader` instead of `ColladaLoader`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Loaded COLLADA model](img/Figure_9.25_B18726.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Loaded COLLADA model
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: For the final loader, we’ll look at `BVHLoader`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing a skeleton with BVHLoader
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BVHLoader` is a slightly different loader than the ones we’ve seen so far.
    This loader doesn’t return meshes or geometries with animations; instead, it returns
    a skeleton and an animation. An example of this is shown in `load-bvh.html`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Loaded BVH skeleton](img/Figure_9.26_B18726.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Loaded BVH skeleton
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize this, we can use a `THREE.SkeletonHelper`, as seen here. With
    a `THREE.SkeletonHelper`, we can visualize the skeleton of a mesh. BVH models
    just contain skeleton information, which we can visualize like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In older versions of Three.js, there was support for other kinds of animation
    file formats. Most of those are obsolete and have subsequently been removed from
    the Three.js distribution. If you do stumble upon a different format in which
    you want to show the animations, you can look at the older Three.js releases and
    possibly reuse the loaders from there.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different ways you can animate your scene. We
    started with some basic animation tricks, moved on to camera movement and control,
    and ended by looking at animating models using morph targets and skeleton/bones
    animations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了您可以为场景添加动画的不同方法。我们首先介绍了一些基本的动画技巧，然后转向摄像机运动和控制，最后通过使用形态目标以及骨骼/骨骼动画来查看如何对模型进行动画处理。
- en: When you have the render loop in place, adding simple animations is very easy.
    Just change a property of the mesh; in the next rendering step, Three.js will
    render the updated mesh. For more complex animations, you would usually model
    them in external programs and load them through one of the loaders provided by
    Three.js.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已经设置了渲染循环后，添加简单的动画变得非常容易。只需更改网格的一个属性；在下一个渲染步骤中，Three.js 将渲染更新后的网格。对于更复杂的动画，您通常会使用外部程序进行建模，并通过
    Three.js 提供的加载器之一加载它们。
- en: In the previous chapters, we looked at the various materials we can use to skin
    our objects. For instance, we saw how we can change the color, shininess, and
    opacity of these materials. What we haven’t discussed in detail yet, however,
    is how we can use external images (also called textures) together with these materials.
    With textures, we can easily create objects that look as if they are made out
    of wood, metal, stone, and much more. In [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    we’ll explore all the different aspects of textures and how they are used in Three.js.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了我们可以用来为对象着色的各种材质。例如，我们看到了如何更改这些材质的颜色、光泽度和透明度。然而，我们尚未详细讨论如何使用外部图像（也称为纹理）与这些材质结合使用。通过纹理，我们可以轻松创建看起来像是用木材、金属、石头等材料制成的对象。在[*第
    10 章*](B18726_10.xhtml#_idTextAnchor171)中，我们将探讨纹理的所有不同方面以及它们在 Three.js 中的使用方式。
