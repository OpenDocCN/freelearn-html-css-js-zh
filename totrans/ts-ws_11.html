<html><head></head><body>
		<div>
			<div id="_idContainer127" class="Content">
			</div>
		</div>
		<div id="_idContainer128" class="Content">
			<h1 id="_idParaDest-196"><a id="_idTextAnchor236"/>10. Event Loop and Asynchronous Behavior</h1>
		</div>
		<div id="_idContainer133" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor237"/>Overview</p>
			<p class="callout">In this chapter, you'll investigate how a web page actually works within the browser, with a special focus on how, when, and why the browser executes the JavaScript code we provide. You'll dive deep into the intricacies of the event loop and see how we can manage it. Lastly, you'll learn about the tools that TypeScript offers you. By the end of this chapter, you will be able to better manage the asynchronous nature of the execution.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor238"/>Introduction</h1>
			<p>In the previous chapter, you learned the fundamentals of generics and conditional types. This chapter introduces you to event loops and asynchronous behavior. However, before you proceed with learning these topics, let's have a look at a hypothetical scenario to really understand how synchronous and asynchronous executions work. </p>
			<p><a id="_idTextAnchor239"/>Imagine a small bank that has a single teller. His name is Tom, and he's serving clients all day. Since it's a small bank and there are few clients, there's no queue. So, when a client comes in, they get Tom's undivided attention. The client provides all the necessary paperwork, and Tom processes it. If the process needs some kind of outside input, such as from a credit bureau or the bank's back-office department, Tom submits the request, and he and the client wait for the response together. They might chat a bit, and when the response comes, Tom resumes his work. If a document needs to be printed, Tom sends it to the printer that's right on his desk, and they wait and chat. When the printing is done, Tom resumes his work. Once the work is completed, the bank has another satisfied client, and Tom continues with his day. If somebody comes while Tom is serving a client (which happens seldom), they wait until Tom is completely done with the previous client, and only then do they begin their process. Even if Tom is waiting on an external response, the other client will have to wait their turn, while Tom idly chats with the current client.</p>
			<p>Tom effectively works synchronously and sequentially. There are lots of benefits of this approach to working, namely, Tom (and his bosses) can always tell whether he is serving a client or not, he always knows who his current client is, and he can completely forget all the data about the client as soon as the client leaves, knowing that they have been serviced completely. There are no issues with mixing up documents from different clients. Any problems are easy to diagnose and easy to fix. And since the queue never gets crowded, this setup works to everyone's satisfaction.</p>
			<p>So far, so good. But what happens when the bank suddenly gets more clients? As more and more clients arrive, we get a long queue, and everyone is waiting, while Tom chats with the current client, waiting on a response from the credit bureau. Tom's boss is, understandably, not happy with the situation. The current system does not scale – at all. So, he wants to change the system somehow, to be able to serve more clients. How can he do that? You will look at a couple of solutions in the following section.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor240"/>The Multi-Threaded Approach</h1>
			<p>Basically, there are two different approaches. One is to have multiple Toms. So, every single teller will still work in the exact same simple and synchronous way as before – we just have lots of them. Of course, the boss will need to have some kind of organization to know which teller is available and which is working, whether there are separate queues for each teller, or a single large queue, along with some kind of distribution mechanism (that is, a system where a number is assigned to each customer). The boss might also get one of those big office printers, instead of having one printer per teller, and have some kind of rule in order to not mix up the print jobs. The organization will be complex, but the task of every single teller will be straightforward.</p>
			<p>By now, you know we're not really discussing banks. This is the usual approach for server-side processing. Grossly simplified, the server process will have multiple sub-processes (called threads) that will work in parallel, and the main process will orchestrate everything. Each thread will execute synchronously, with a well-defined beginning, middle, and end. Since servers are usually machines with lots of resources, with heavy loads, this approach makes sense. It can accommodate low or high loads nicely, and the code that processes each request can be relatively simple and easy to debug. It even makes sense to have the thread wait for some external resource (a file from the file system, or data from the network or database), since we can always spin up new threads if we have more requests. This is not the case with real live tellers. We cannot just clone a new one if more clients come. The kind of waiting done by the threads (or by Tom) is usually referred to as <em class="italic">busy waiting</em>. The thread is not doing anything, but it's not available for any work, since it's busy doing something – it's busy waiting. Just like Tom was actually busy chatting with the client while waiting for a response from the credit bureau.</p>
			<p>We have a system that can be massively parallel and concurrent, but still, each part of it is run synchronously. The benefit of this approach is that we can serve many, many clients at the same time. One obvious downside is the cost, both in hardware and in complexity. While we managed to keep the client processing simple, we'll need a huge infrastructure that takes care of everything else – adding tellers, removing tellers, queueing customers, managing access to the office printer, and similar tasks.</p>
			<p>This will use all the available resources of the bank (or the server), but that is fine, since that's the whole point – to serve clients, as many and as fast as possible, and nothing else. </p>
			<p>However, there is another approach – asynchronous execution.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor241"/>The Asynchronous Execution Approach</h2>
			<p>The other approach, the one taken by the web and, by extension, JavaScript and TypeScript, is to use just a single thread – so Tom is still on his own. But, instead of Tom idly chatting with a waiting client, he could do something else. If a situation arises where he needs some verification from the back office, he just writes down what he was doing and how far he got on a piece of paper, gives that paper to the client, and sends them to the back of the queue. Tom is now ready to start serving the next client in line. If that client does not need external resources, they are processed completely and are free to leave. If they need something else that Tom needs to wait for, they too are sent to the back of the line. And so on, and so forth. This way, if Tom has any clients at all, he's processing their requests. He's never busy waiting, instead, he's busy working. If a client needs to wait for a response, they do so separately from Tom. The only time Tom is idle is when he has no clients at all.</p>
			<p>The benefit of this approach is fairly obvious – before, Tom spent a lot of his time chatting, now he is working all the time (of course, this benefit is from Tom's boss' point of view – Tom liked the small talk). An additional benefit is that we know our resource consumption up front. If we only have one teller, we know the square footage that we will need for the office. However, there are some downsides as well. The most important downside is that our clients now have to know our process quite intimately. They will need to understand how to queue and requeue, how to continue working from where they left off, and so on. Tom's work also got a lot more complicated. He needs to know how to pause the processing of a client, how to continue, how to behave if an external response is not received, and so on. This model of working is usually called asynchronous and concurrent. Doing his job, Tom will jump between multiple clients at the same time. More than one client will have their process started but not finished. And there's no way for a client to estimate how long it will take to process their task once it is started – it depends on how many other clients Tom processes at the same time.</p>
			<p>From the early days, this model made much more sense for the web. For starters, web applications are processed on the device of the client. We should not make any technical assumptions about it – as we cannot be sure about the kind of device that the client might be using. In essence, a web page is a guest on the client's device – and it should behave properly. For example, using up all of a device's resources to show what amounts to a fancy animation is not proper behavior at all. Another important issue is security. If we think of web pages as applications that contain some code, we're basically executing someone's code on our machine whenever we enter a web address in the browser's address bar. </p>
			<p>The browser needs to make sure that the code on the page, even if it's malicious, is restricted in what it can do to our machine. The web would not have been as popular as it is today if visiting a website could make your computer explode.</p>
			<p>So, since the browser cannot know in advance which pages it will be used for, it was decided that each web page will only get access to a single thread. Also, for security reasons, each web page will get a separate thread, so a running web page cannot meddle in the execution of other pages that may execute at the same time (with features such as web workers and Chrome applications, these restrictions are somewhat loosened, but in principle, they still apply). </p>
			<p>There is simply no way for a web page to spawn enough threads to swarm the system, or for a web page to get the data from another web page. And, since a web page needs to do lots of things at once, using the synchronous and sequential approach was out of the question. That is why all the JavaScript execution environments completely embraced the asynchronous, concurrent approach. This was done to such an extent that some common synchronization techniques are, intentionally, just not available in JavaScript.</p>
			<p>For example, lots of other languages have a "wait some time" primitive, or a library function that does that. For example, in the C# programming language, we can have this code:</p>
			<p class="source-code">Console.WriteLine("We will wait 10 s");</p>
			<p class="source-code">Thread.Sleep(10000);</p>
			<p class="source-code">Console.WriteLine("... 10 seconds later");</p>
			<p class="source-code">Thread.Sleep(15000);</p>
			<p class="source-code">Console.WriteLine("... 15 more seconds later");</p>
			<p>This code will write some text to the console, and 10 seconds later, write some more text. During the 25 seconds of the wait, the thread this executes on will be completely non-responsive, but the code written is simple and linear – easily understood, easily changeable, and easily debuggable. JavaScript simply does not have such a synchronous primitive, but it has an asynchronous variant in the <strong class="source-inline">setTimeout</strong> function. The simplest equivalent code would be the following:</p>
			<p class="source-code">console.log("We will wait 10 s");</p>
			<p class="source-code">setTimeout(() =&gt; {</p>
			<p class="source-code">    console.log("... 10 seconds later");</p>
			<p class="source-code">    setTimeout(() =&gt; {</p>
			<p class="source-code">        console.log("... 15 more seconds later");</p>
			<p class="source-code">    }, 15000);</p>
			<p class="source-code">}, 10000);</p>
			<p>It's obvious that this code is much more complex than the C# equivalent, but the advantage that we get is that this code is non-blocking. In the 25 total seconds that this code is executing, our web page can do everything it needs to do. It can respond to events, the images can load and display, we can resize the window, scroll the text – basically, the application will resume the normal and expected functionalities.</p>
			<p>Note that while it's possible to block the JavaScript execution with some special synchronous code, it's not easy to do it. When it does actually happen, the browser can detect that it did happen and terminate the offending page:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B14508_10_01.jpg" alt="Figure 10.1: Unresponsive page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Unresponsive page</p>
			<h1 id="_idParaDest-200">E<a id="_idTextAnchor242"/>xecuting JavaScript</h1>
			<p>When a JavaScript execution environment, such as a node or a browser loads a JavaScript file, it parses it and then runs it. All the functions that are defined in a JavaScript file are registered, and all the code that is not in a function is executed. The order of the execution is according to the code's position in the file. So, consider a file having the following code: </p>
			<p class="source-code">console.log("First");</p>
			<p class="source-code">console.log("Second");</p>
			<p>The console will always display this:</p>
			<p class="source-code">First</p>
			<p class="source-code">Second</p>
			<p>The order of the output cannot be changed, without changing the code itself. This is because the line with <strong class="source-inline">First</strong> will be executed completely – always – and then, and only then, will the line with <strong class="source-inline">Second</strong> begin to execute. This approach is synchronous because the execution is synchronized by the environment. We are guaranteed that the second line will not start executing, until and unless the line above it is completely done. But what happens if the line calls some function? Let's take a look at the following piece of code:</p>
			<p class="source-code">function sayHello(name){</p>
			<p class="source-code">    console.log(`Hello ${name}`);</p>
			<p class="source-code">}</p>
			<p class="source-code">function first(){</p>
			<p class="source-code">    second();</p>
			<p class="source-code">}</p>
			<p class="source-code">function second(){</p>
			<p class="source-code">    third();</p>
			<p class="source-code">}</p>
			<p class="source-code">function third(){</p>
			<p class="source-code">    sayHello("Bob");</p>
			<p class="source-code">}</p>
			<p class="source-code">first();</p>
			<p>When the code is parsed, the environment will detect that we have four functions – <strong class="source-inline">first</strong>, <strong class="source-inline">second</strong>, <strong class="source-inline">third</strong>, and <strong class="source-inline">sayHello</strong>. It will also execute the line of code that is not inside a function (<strong class="source-inline">first();</strong>), and that will start the execution of the <strong class="source-inline">first</strong> function. But that function, while it's executing, calls the <strong class="source-inline">second</strong> function. The runtime will then suspend the running of the <strong class="source-inline">first</strong> function, remember where it was, and begin with the execution of the <strong class="source-inline">second</strong> function. This function, in turn, calls the <strong class="source-inline">third</strong> function. The same thing happens again – the runtime starts executing the <strong class="source-inline">third</strong> function, remembering that once that function is done, it should resume with the execution of the <strong class="source-inline">second</strong> function, and that once <strong class="source-inline">second</strong> is done, it should resume with the execution of the <strong class="source-inline">first</strong> function. </p>
			<p>The structure the runtime uses to remember which function is active, and which are waiting, is called a <strong class="bold">stack</strong>, specifically, <em class="italic">the call stack</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term "stack" is used in the sense of a stack of dishes, or a stack of pancakes. We can only add to the top, and we can only remove from the top. </p>
			<p>The executing functions are put one on top of the other, and the topmost function is the one being actively executed, as shown in the following representation:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B14508_10_02.jpg" alt="Figure 10.2: Stack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Stack</p>
			<p>In the example, the <strong class="source-inline">third</strong> function will call the <strong class="source-inline">sayHello</strong> function, which will in turn call the <strong class="source-inline">log</strong> function of the <strong class="source-inline">console</strong> object. Once the <strong class="source-inline">log</strong> function finishes executing, the stack will start unwinding. That means that once a certain function finishes executing, it will be removed from the stack, and the function below it will be able to resume executing. So, once the <strong class="source-inline">sayHello</strong> function finishes executing, the <strong class="source-inline">third</strong> function will resume and finish in turn. This will trigger the continuation of the <strong class="source-inline">second</strong> function, and when that function is done as well, the <strong class="source-inline">first</strong> function will continue, and eventually finish. When the <strong class="source-inline">first</strong> function finishes executing, the stack will become empty – and the runtime will stop executing code.</p>
			<p>It's worth noting that all of this execution is done strictly synchronously and deterministically. We can deduce the exact order and number of function calls just from looking at the code. We can also use common debugging tools such as breakpoints and stack traces.</p>
			<h2 id="_idParaDest-201">Ex<a id="_idTextAnchor243"/>ercise 10.01: Stacking Functions</h2>
			<p>In this exercise, we'll define few simple functions that call each other. Each of the functions will log to the console when it starts executing and when it's about to finish executing. We will analyze when and in what order the output is mapped to the console:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/X7QZQ">https://packt.link/X7QZQ</a>.</p>
			<ol>
				<li>Create a new file, <strong class="source-inline">stack.ts</strong>.</li>
				<li>In <strong class="source-inline">stack.ts</strong>, define three functions called <strong class="source-inline">inner</strong>, <strong class="source-inline">middle</strong>, and <strong class="source-inline">outer</strong>. None of them need to have parameters or return types:<p class="source-code">function inner () {</p><p class="source-code">}</p><p class="source-code">function middle () {</p><p class="source-code">}</p><p class="source-code">function outer () {</p><p class="source-code">}</p></li>
				<li>In the body of the <strong class="source-inline">inner</strong> function, add a single <strong class="source-inline">log</strong> statement, indented by four spaces:<p class="source-code">function inner () {</p><p class="source-code">    console.log("    Inside inner function");</p><p class="source-code">}</p></li>
				<li>In the body of the <strong class="source-inline">middle</strong> function, add a call to the <strong class="source-inline">inner</strong> function. Before and after the call, add a <strong class="source-inline">log</strong> statement, indented by two spaces:<p class="source-code">function middle () {</p><p class="source-code">    console.log("  Starting middle function");</p><p class="source-code">    inner();</p><p class="source-code">    console.log("  Finishing middle function");</p><p class="source-code">}</p></li>
				<li>In the body of the <strong class="source-inline">outer</strong> function, add a call to the <strong class="source-inline">middle</strong> function. Before and after the call, add a <strong class="source-inline">log</strong> statement:<p class="source-code">function outer () {</p><p class="source-code">    console.log("Starting outer function");</p><p class="source-code">    middle();</p><p class="source-code">    console.log("Finishing outer function");</p><p class="source-code">}</p></li>
				<li>After the function declaration, create a call only to the <strong class="source-inline">outer</strong> function:<p class="source-code">outer();</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc stack.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">stack.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node stack.js</p><p>You will see the output looks like this:</p><p class="source-code">Starting outer function</p><p class="source-code">  Starting middle function</p><p class="source-code">    Inside inner function</p><p class="source-code">  Finishing middle function</p><p class="source-code">Finishing outer function</p></li>
			</ol>
			<p>The output shows which function started executing first (<strong class="source-inline">outer</strong>), as that is the first message displayed. It can also be noted that the <strong class="source-inline">middle</strong> function finished executing after the <strong class="source-inline">inner</strong> function was already finished, but before the <strong class="source-inline">outer</strong> function was finished.</p>
			<h1 id="_idParaDest-202">Br<a id="_idTextAnchor244"/>owsers and JavaScript</h1>
			<p>When a web page is requested by the user, the browser needs to do lots of things. We won't go into the details of each of them, but we'll take a look at how it handles our code.</p>
			<p>First of all, the browser sends the request to the server and receives an HTML file as a response. Within that HTML file, there are embedded links to resources that are needed for the page, such as images, stylesheets, and JavaScript code. The browser then downloads those as well and applies them to the downloaded HTML. Images are displayed, elements are styled, and JavaScript files are parsed and run.</p>
			<p>The order in which the code is executed is according to the file's order in the HTML, then according to the code's position in the file. But when are the functions called? Let's say we have the following code in our file:</p>
			<p class="source-code">function sayHello() {</p>
			<p class="source-code">    console.log("Hello");</p>
			<p class="source-code">}</p>
			<p class="source-code">sayHello();</p>
			<p>First, the <strong class="source-inline">sayHello</strong> function is registered, and then when it's called later, the function actually executes and writes <strong class="source-inline">Hello</strong> to the console. Take a look at the following code now:</p>
			<p class="source-code">function sayHello() {</p>
			<p class="source-code">    console.log("Hello");</p>
			<p class="source-code">}</p>
			<p class="source-code">function sayHi() {</p>
			<p class="source-code">    console.log("Hi");</p>
			<p class="source-code">}</p>
			<p class="source-code">sayHello();</p>
			<p class="source-code">sayHi();</p>
			<p class="source-code">sayHello();</p>
			<p>When the file with the preceding code is processed, it will register that it has two functions, <strong class="source-inline">sayHello</strong> and <strong class="source-inline">sayHi</strong>. Then it will detect that it has three invocations, that is, there are three tasks that need to be processed. The environment has something that is called the <strong class="bold">task queue</strong>, where it will put all the functions that need to be executed, one by one. So, our code will be transformed into three tasks. Then, the environment will check if the stack is actually empty, and if it is, it will take the first task off the queue and start executing it. The stack will grow and shrink depending on the execution of the code of the first task, and eventually, when the first task is finished, it will be empty. So, after the first task is executed, the situation will be as follows:</p>
			<ol>
				<li value="1">The execution stack will be empty.</li>
				<li>The task queue will contain two tasks.</li>
				<li>The first task will be completely done.</li>
			</ol>
			<p>Once the stack is empty, the next task is dequeued and executed, and so on, until both the task queue and the stack are empty, and all the code is executed. Again, this whole process is done synchronously, in a specified order.</p>
			<h2 id="_idParaDest-203">Ev<a id="_idTextAnchor245"/>ents in the Browser</h2>
			<p>Now, take a look at a different example:</p>
			<p class="source-code">function sayHello() {</p>
			<p class="source-code">    console.log("Hello");</p>
			<p class="source-code">}</p>
			<p class="source-code">document.addEventListener("click", sayHello);</p>
			<p>If you have this code in a JavaScript file that is loaded by the browser, you can see that the <strong class="source-inline">sayHello</strong> function is registered but not executed. However, if you click anywhere on the page, you will see that the <strong class="source-inline">Hello</strong> string appears on the console, meaning the <strong class="source-inline">sayHello</strong> function got executed. If you click multiple times, you'll get multiple instances of <strong class="source-inline">"Hello"</strong> on the console. And this code did not invoke the <strong class="source-inline">sayHello</strong> function even once; you don't have the <strong class="source-inline">sayHello()</strong> invocation in the code at all.</p>
			<p>What happened is, you <em class="italic">registered</em> our function as an event listener. Consider that you don't call our function at all, but the browser's environment will call it for us, whenever a certain event occurs – in this case, the <strong class="source-inline">click</strong> event on the whole <strong class="source-inline">document</strong>. And since those events are generated by the user, we cannot know if and when our code will execute. Event listeners are the principal way that our code can communicate with the page that it's on, and they are called asynchronously – you don't know when or if the function will be invoked, nor how many times it will be invoked.</p>
			<p>What the browser does, when an event occurs, is to look up its own internal table of registered event handlers. In our case, if a <strong class="source-inline">click</strong> event occurs anywhere on the <strong class="source-inline">document</strong> (that's the whole web page), the browser will see that you have registered the <strong class="source-inline">sayHello</strong> function to respond to it. That function will not be executed directly – instead, the browser will place an invocation of the function in the task queue. After that, the regular behavior explained previously takes effect. If the queue and stack are empty, the event handler will begin executing immediately. Otherwise, our handler will wait for its turn.</p>
			<p>This is another core effect of asynchronous behavior – we simply cannot guarantee that the event handler will execute immediately. It might be the case that it does, but there is no way to know if the queue and stack are empty at a specific moment. If they are, we'll get immediate execution, but if they're not, we'll have to wait our turn.</p>
			<h1 id="_idParaDest-204">En<a id="_idTextAnchor246"/>vironment APIs</h1>
			<p>Most of our interaction with the browser will be done in the same pattern – you will define a function, and pass that function as a parameter to some browser API. When and if that function will actually be scheduled for execution will depend on the particulars of that API. In the previous case, you used the event handler API, <strong class="source-inline">addEventListener</strong>, which takes two parameters, the name of an event, and the code that will be scheduled when that event happens. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can get a list of different possible events at <a href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>.</p>
			<p>In the rest of this chapter, you will use two other APIs as well, the environment's method to defer some code for later execution (<strong class="source-inline">setTimeout</strong>) and the ability to call on external resources (popularly called AJAX). There are two different AJAX implementations that we will be working with, the original <strong class="source-inline">XMLHttpRequest</strong> implementation, and the more modern and flexible <strong class="source-inline">fetch</strong> implementation.</p>
			<h2 id="_idParaDest-205">se<a id="_idTextAnchor247"/>tTimeout</h2>
			<p>As mentioned previously, the environment offers no possibility to pause the execution of JavaScript for a certain amount of time. However, the need to execute some code after some set amount of time has passed arises quite often. So, instead of pausing the execution, we get to do something different that has the same outcome. We get to schedule a piece of code to get executed after an amount of time has passed. To do that we use the <strong class="source-inline">setTimeout</strong> function. This function takes two parameters: A function that will need to be executed, and the time, in milliseconds, it should defer the execution of that function by:</p>
			<p class="source-code">setTimeout(function() {</p>
			<p class="source-code">    console.log("After one second");</p>
			<p class="source-code">}, 1000);</p>
			<p>Here it means that the anonymous function that is passed as a parameter will be executed after 1,000 milliseconds, that is, one second.</p>
			<h2 id="_idParaDest-206">Ex<a id="_idTextAnchor248"/>ercise 10.02: Exploring setTimeout</h2>
			<p>In this exercise, you'll use the <strong class="source-inline">setTimeout</strong> environment API call to investigate how asynchronous execution behaves and what it does:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/W0mlS">https://packt.link/W0mlS</a>.</p>
			<ol>
				<li value="1">Create a new file, <strong class="source-inline">delays-1.ts</strong>.</li>
				<li>In <strong class="source-inline">delays-1.ts</strong>, log some text at the beginning of the file:<p class="source-code">console.log("Printed immediately");</p></li>
				<li>Add two calls to the <strong class="source-inline">setTimeout</strong> function:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after one second");</p><p class="source-code">}, 1000);</p><p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after two second");</p><p class="source-code">}, 2000);</p><p>Here, instead of creating a function and giving it to the <strong class="source-inline">setTimeout</strong> function using its name, we have used an anonymous function that we have created in-place. We can also use arrow functions instead of functions defined with the <strong class="source-inline">function</strong> keyword.</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc delays-1.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">delays-1.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node delays-1.js</p><p>You will see the output looks like this:</p><p class="source-code">Printed immediately</p><p class="source-code">Printed after one second</p><p class="source-code">Printed after two second</p><p>The second and third lines of the output should not appear immediately, but after 1 and 2 seconds respectively.</p></li>
				<li>In the <strong class="source-inline">delays-1.ts</strong> file, switch the two calls to the <strong class="source-inline">setTimeout</strong> function:<p class="source-code">console.log("Printed immediately");</p><p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after two second");</p><p class="source-code">}, 2000);</p><p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after one second");</p><p class="source-code">}, 1000);</p></li>
				<li>Compile and run the code again, and verify that the output behaves identically. Even if the former <strong class="source-inline">setTimeout</strong> was executed first, its <strong class="source-inline">function</strong> parameter is not scheduled to run until 2 seconds have passed.</li>
				<li>In the <strong class="source-inline">delays-1.ts</strong> file, move the initial <strong class="source-inline">console.log</strong> to the bottom:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after two second");</p><p class="source-code">}, 2000);</p><p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("Printed after one second");</p><p class="source-code">}, 1000);</p><p class="source-code">console.log("Printed immediately");</p></li>
				<li>Compile and run the code again, and verify that the output behaves identically. This illustrates one of the most common problems with code that behaves asynchronously. Even though the line was at the bottom of our file, it was executed first. It's much harder to mentally trace code that does not follow the top-down paradigm we're used to.</li>
				<li>Create a new file, <strong class="source-inline">delays-2.ts</strong>.</li>
				<li>In <strong class="source-inline">delays-2.ts</strong>, add a single call to the <strong class="source-inline">setTimeout</strong> function, and set its delay time to <strong class="source-inline">0</strong>. This will mean that our code needs to wait 0 milliseconds in order to execute:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log("#1 Printed immediately?");</p><p class="source-code">}, 0);</p></li>
				<li>Add a <strong class="source-inline">console.log</strong> statement after the call to <strong class="source-inline">setTimeout</strong>:<p class="source-code">console.log("#2 Printed immediately.");</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc delays-2.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">delays-2.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node delays-2.js</p><p>You will see the output looks like this:</p><p class="source-code">#2 Printed immediately.</p><p class="source-code">#1 Printed immediately?;</p><p>Well, that looks unexpected. Both lines appear basically immediately, but the one that was in the <strong class="source-inline">setTimeout</strong> block, and was first in the code, came after the line at the bottom of the script. And we explicitly told <strong class="source-inline">setTimeout</strong> not to wait, that is, to wait 0 milliseconds before the code got executed.</p></li>
			</ol>
			<p>To understand what happened, we need to go back to the call queue. When the file was loaded, the environment detected that we had two tasks that needed to be done, the call to <strong class="source-inline">setTimeout</strong> and the bottom call to <strong class="source-inline">console.log</strong> (#2). So, those two tasks were put into the task queue. Since the stack was empty at that time, the <strong class="source-inline">setTimeout</strong> call started executing, and #2 was left in the task queue. The environment saw that it has a zero delay, so immediately took the function (#1), and put it <em class="italic">at the end</em> of the task queue, after #2. So, after the <strong class="source-inline">setTimeout</strong> call was done, we were left with two <strong class="source-inline">console.log</strong> tasks in the queue, with #2 being the first, and #1 being the second.</p>
			<p>They got executed sequentially, and on our console, we got #2 first, and #1 second.</p>
			<h2 id="_idParaDest-207">AJ<a id="_idTextAnchor249"/>AX (Asynchronous JavaScript and XML)</h2>
			<p>In the early days of the web, it was not possible to get data from a server once the page was loaded. That was a huge inconvenience for developing dynamic web pages, and it was solved by the introduction of an object called <strong class="source-inline">XMLHttpRequest</strong>. This object enabled developers to get data from a server after the initial page load – and since loading data from a server means using an external resource, it had to be done in an asynchronous manner (even if it has XML right in the name, currently, it will mostly be used for JSON data). To use this object, you'll need to instantiate it and use a few of its properties.</p>
			<p>To illustrate its usage, we'll try to get data about William Shakespeare from the Open Library project. The URL that we'll use to retrieve that information is <a href="https://openlibrary.org/authors/OL9388A.json">https://openlibrary.org/authors/OL9388A.json</a>, and the access method that we will use is <strong class="source-inline">GET</strong>, as we will only be getting data.</p>
			<p>The data received is of a specific format, defined by Open Library, so you'll start by creating an interface for the data that you will actually use. You'll display only an image of the Bard (received as an array of photo IDs), and the name, so you can define the interface like this:</p>
			<p class="source-code">interface OpenLibraryAuthor {</p>
			<p class="source-code">  personal_name: string;</p>
			<p class="source-code">  photos: number[];</p>
			<p class="source-code">}</p>
			<p>Next, create the <strong class="source-inline">XMLHttpRequest</strong> object, and assign it to a variable called <strong class="source-inline">xhr</strong>:</p>
			<p class="source-code">const xhr = new XMLHttpRequest();</p>
			<p>Now you need to <strong class="source-inline">open</strong> a connection to our URL:</p>
			<p class="source-code">const url = "https://openlibrary.org/authors/OL9388A.json";</p>
			<p class="source-code">xhr.open("GET", url);</p>
			<p>This call doesn't actually send anything, but it prepares the system for accessing the external resource. Lastly, you need to actually send the request, using the <strong class="source-inline">send</strong> method:</p>
			<p class="source-code">xhr.send();</p>
			<p>Since the request is asynchronous, this call will execute and finish immediately. In order to actually process the data once this request is done, you need to add something to this object – a callback. That is a function that will not be executed by us, but by the <strong class="source-inline">xhr</strong> object, once some event happens. This object has several events, such as <strong class="source-inline">onreadystatechange</strong>, <strong class="source-inline">onload</strong>, <strong class="source-inline">onerror</strong>, <strong class="source-inline">ontimeout</strong>, and you can set different functions to react to different events, but in this case, you will just use the <strong class="source-inline">onload</strong> event. Create a function that will get the data from the response and show it on the web page where our script is running:</p>
			<p class="source-code">const showData = () =&gt; {</p>
			<p class="source-code">  if (xhr.status != 200) {</p>
			<p class="source-code">    console.log(`An error occured ${xhr.status}: ${xhr.statusText}`);</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    const response: OpenLibraryAuthor = JSON.parse(xhr.response);</p>
			<p class="source-code">    const body = document.getElementsByTagName("body")[0];</p>
			<p class="source-code">    </p>
			<p class="source-code">    const image = document.createElement("img");</p>
			<p class="source-code">    image.src = `http://covers.openlibrary.org/a/id/${response.photos[0]}-M.jpg`;</p>
			<p class="source-code">    body.appendChild(image);</p>
			<p class="source-code">    const name = document.createElement("h1");</p>
			<p class="source-code">    name.innerHTML = response.personal_name;</p>
			<p class="source-code">    body.appendChild(name);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>In this method, you will be using some properties of the <strong class="source-inline">xhr</strong> variable that was defined previously, such as <strong class="source-inline">status</strong>, which gives us the HTTP status code of the request, or <strong class="source-inline">response</strong>, which gives us the actual response. If we just call the <strong class="source-inline">showData</strong> method by ourselves, we'll most likely get empty fields or an error, as the response will not have finished. So, we need to give this function to the <strong class="source-inline">xhr</strong> object, and it will use it to call the <strong class="source-inline">showData</strong> back:</p>
			<p class="source-code">xhr.onload = showData;</p>
			<p>Save this code as <strong class="source-inline">shakespeare.ts</strong>, compile it, and add it to an HTML page using the following:</p>
			<p class="source-code">    &lt;script src="shakespeare.js"&gt;&lt;/script&gt;</p>
			<p>You will get a result similar to the following:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B14508_10_03.jpg" alt="Figure 10.3: Retrieved image of William Shakespeare&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3: Retrieved image of William Shakespeare</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor250"/>Act<a id="_idTextAnchor251"/>ivity 10.01: Movie Browser Using XHR and Callbacks</h2>
			<p>As a TypeScript developer, you have been tasked with creating a simple page to view movie data. The web page will be simple, with a text input field and a button. When you enter the name of a movie in the search input field and press the button, general information about the movie will be displayed on the web page, along with some images relevant to the movie.</p>
			<p>You can use <em class="italic">The Movie Database</em> (<a href="https://www.themoviedb.org/">https://www.themoviedb.org/</a>) as a source of general data, specifically its API. You need to issue AJAX requests using <strong class="source-inline">XmlHttpRequest</strong>, and use the data the site provides to format your own object. When using an API the data will rarely, if ever, be in the format we actually need. This means that you will need to use several API requests to get our data, and piecemeal construct our object. A common TypeScript approach to this issue is to use two sets of interfaces – one that exactly matches the format of the API, and one that matches the data that you use in your application. In this activity, you need to use the <strong class="source-inline">Api</strong> suffix to denote those interfaces that match the API format.</p>
			<p>Another important thing to note is that this particular API does not allow completely open access. You'll need to register for an API key and then send it in each API request. In the setup code for this activity, three functions (<strong class="source-inline">getSearchUrl</strong>, <strong class="source-inline">getMovieUrl</strong>, <strong class="source-inline">getPeopleUrl</strong>) will be provided that will generate the correct URLs for the needed API requests, once the <strong class="source-inline">apiKey</strong> variable is set to the value you will receive from The Movie Database. Also provided will be the base HTML, styling, as well as the code used to actually display the data – all that is missing is the data itself.</p>
			<p>Those resources are listed here:</p>
			<ul>
				<li><strong class="source-inline">display.ts</strong> – A TypeScript file that houses the <strong class="source-inline">showResult</strong> and <strong class="source-inline">clearResults</strong> methods, which you will call to display a movie and clear the screen, respectively.</li>
				<li><strong class="source-inline">interfaces.ts</strong> – A TypeScript file that contains the interfaces that you will use. All interfaces that have an <strong class="source-inline">Api</strong> suffix are objects that you will receive from The Movie Database API, and the rest (<strong class="source-inline">Movie</strong> and <strong class="source-inline">Character</strong>) will be used to display the data.</li>
				<li><strong class="source-inline">script.ts</strong> – A TypeScript file that has some boilerplate code that will start the application. The <strong class="source-inline">search</strong> function is here, and that function will be the main focus of this activity.</li>
				<li><strong class="source-inline">index.html</strong> – An HTML file that has the basic markup for our web page.</li>
				<li><strong class="source-inline">styles.css</strong> – A style sheet file that is used to style the results.</li>
			</ul>
			<p>The following steps should help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found at <a href="https://packt.link/Qo4dB">https://packt.link/Qo4dB</a>.</p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Construct a new <strong class="source-inline">XMLHttpRequest</strong> object.</li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method.</li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> methods of the <strong class="source-inline">xhr</strong> object.</li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> object's <strong class="source-inline">onload</strong> event. Take the response and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">SearchResultApi</strong> interface. This data will have the results of our search in a <strong class="source-inline">results</strong> field. If you get no results, this means that our search failed.</li>
				<li>If the search returned no results, call the <strong class="source-inline">clearResults</strong> method.</li>
				<li>If the search returned some results, just take the first one and store it in a variable, ignoring the other ones.</li>
				<li>Inside the <strong class="source-inline">onload</strong> handler, in the successful search branch, create a new <strong class="source-inline">XMLHttpRequest</strong> object.</li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getMovieUrl</strong> method.</li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> method of the constructed <strong class="source-inline">xhr</strong> object.</li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> objects's <strong class="source-inline">onload</strong> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">MovieResultApi</strong> interface. This response will have the general data for our movie, specifically, everything except the people who were involved in the movie. You will need to have another call to the API to get the data about the people.</li>
				<li>Inside the <strong class="source-inline">onload</strong> handler, in the successful search branch, create a new <strong class="source-inline">XMLHttpRequest</strong> object.</li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getPeopleUrl</strong> method.</li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> method of the constructed <strong class="source-inline">xhr</strong> object.</li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> object's <strong class="source-inline">onload</strong> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">PeopleResultApi</strong> interface. This response will have data about the people who were involved in the movie.</li>
				<li>Now you actually have all the data you need, so you can create your own object inside the people <strong class="source-inline">onload</strong> handler, which is inside the movie <strong class="source-inline">onload</strong> handler, which is inside the search <strong class="source-inline">onload</strong> handler.</li>
				<li>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. You'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into our own <strong class="source-inline">Character</strong> objects. You need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property.</li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, you'll only need the director and the writer. Since there can be multiple directors and writers, you'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses you prepared so far.</li>
				<li>Call the <strong class="source-inline">showResults</strong> function with the movie you constructed.</li>
				<li>In your parent directory (<strong class="source-inline">Activity01</strong> in this case), install dependencies with <strong class="source-inline">npm i</strong>.</li>
				<li>Compile the program using <strong class="source-inline">tsc ./script.ts ./interfaces.ts ./display.ts</strong>.</li>
				<li>Verify that the compilation ended successfully.</li>
				<li>Open <strong class="source-inline">index.html</strong> using the browser of your choice. <p>You<a id="_idTextAnchor252"/> should see the following in your browser:</p><div id="_idContainer132" class="IMG---Figure"><img src="image/B14508_10_04.jpg" alt="Figure 10.4: The final web page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.4: The final web page</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor431">this link</a>.</p>
			<p>We w<a id="_idTextAnchor253"/>ill improve this application further in <em class="italic">Activity 10.02, Movie Browser using fetch and Promises,</em> and <em class="italic">Activity 10.03, Movie Browser using fetch and async/await</em>. However, before we do that, you need to learn about Promises and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> in TypeScript.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor254"/>Promises</h1>
			<p>Using callbacks for asynchronous development gets the job done – and that is great. However, in many applications, our code needs to use external or asynchronous resources all the time. So, very quickly, we'll get to a situation where inside our callback, there is another asynchronous call, which requires a callback inside the callback, which in turn needs a callback on its own….</p>
			<p>It was (and in some cases, it still is) not uncommon to be a dozen levels deep inside the callback hole.</p>
			<h2 id="_idParaDest-210">Exer<a id="_idTextAnchor255"/>cise 10.03: Counting to Five</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last word was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/zD7TT">https://packt.link/zD7TT</a>.</p>
			<ol>
				<li value="1">Create a new file, <strong class="source-inline">counting-1.ts</strong>.</li>
				<li>In <strong class="source-inline">counting-1.ts</strong>, add an array with the English number names up to and including five:<p class="source-code">const numbers = ["One", "Two", "Three", "Four", "Five"];</p></li>
				<li>Add a single call to the <strong class="source-inline">setTimeout</strong> function, and print out the first number after a second:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">}, 1000);</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc counting-1.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">counting-1.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node counting-1.js</p><p>You will see the output looks like this:</p><p class="source-code">One</p><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <strong class="source-inline">counting-1.ts</strong> file, inside the <strong class="source-inline">setTimeout</strong> function, below <strong class="source-inline">console.log</strong>, add another, nested, call to the <strong class="source-inline">setTimeout</strong> function:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">    setTimeout(function() {</p><p class="source-code">        console.log(numbers[1]);</p><p class="source-code">    }, 1000);</p><p class="source-code">}, 1000);</p></li>
				<li>Compile and run the code again, and verify that the output has an extra line, displayed 1 second after the first:<p class="source-code">One</p><p class="source-code">Two</p></li>
				<li>In the <strong class="source-inline">counting-1.ts</strong> file, inside the nested <strong class="source-inline">setTimeout</strong> function, above <strong class="source-inline">console.log</strong>, add another nested call to the <strong class="source-inline">setTimeout</strong> function:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">    setTimeout(function() {</p><p class="source-code">        setTimeout(function() {</p><p class="source-code">            console.log(numbers[2]);</p><p class="source-code">        }, 1000);</p><p class="source-code">        console.log(numbers[1]);</p><p class="source-code">    }, 1000);</p><p class="source-code">}, 1000);</p></li>
				<li>In the innermost <strong class="source-inline">setTimeout</strong> function, below <strong class="source-inline">console.log</strong>, add yet another nested call to <strong class="source-inline">setTimeout</strong>, and repeat the process for the fifth number as well. The code should look like this:<p class="source-code">setTimeout(function() {</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">    setTimeout(function() {</p><p class="source-code">        setTimeout(function() {</p><p class="source-code">            console.log(numbers[2]);</p><p class="source-code">            setTimeout(function() {</p><p class="source-code">                console.log(numbers[3]);</p><p class="source-code">                setTimeout(function() {</p><p class="source-code">                    console.log(numbers[4]);</p><p class="source-code">                }, 1000);</p><p class="source-code">            }, 1000);</p><p class="source-code">        }, 1000);</p><p class="source-code">        console.log(numbers[1]);</p><p class="source-code">    }, 1000);</p><p class="source-code">}, 1000);</p></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order as shown:<p class="source-code">One</p><p class="source-code">Two</p><p class="source-code">Three</p><p class="source-code">Four</p><p class="source-code">Five</p></li>
			</ol>
			<p>In this simple example, we implemented a simple functionality – counting to five. But as you can already see, the code is becoming extremely messy. Just imagine if we needed to count to 20 instead of 5. That would be a downright unmaintainable mess. While there are ways to make this specific code look a bit better and more maintainable, in general, that's not the case. The use of callbacks is intrinsically connected with messy and hard-to-read code. And messy and hard-to-read code is the best place for bugs to hide, so callbacks do have a reputation of being the cause of difficult-to-diagnose bugs.</p>
			<p>An additional problem with callbacks is that there cannot be a unified API across different objects. For example, we needed to explicitly know that in order to receive data using the <strong class="source-inline">xhr</strong> object, we need to call the <strong class="source-inline">send</strong> method and add a callback for the <strong class="source-inline">onload</strong> event. And we needed to know that in order to check whether the request was successful or not, we have to check the <strong class="source-inline">status</strong> property of the <strong class="source-inline">xhr</strong> object.</p>
			<h2 id="_idParaDest-211">What<a id="_idTextAnchor256"/> are Promises?</h2>
			<p>Fortunately, we can promise you that there is a better way. That way was initially done by third-party libraries, but it has proven to be so useful and so widely adopted that it was included in the JavaScript language itself. The logic behind this solution is rather simple. Each asynchronous call is basically a promise that, sometime in the future, some task will be done and some result will be acquired. As with promises in real life, we can have three different states for a promise:</p>
			<ul>
				<li>A promise might not be resolved yet. This means that we need to wait some more time before we get a result. In TypeScript, we call these promises "pending."</li>
				<li>A promise might be resolved negatively – the one who promised broke the promise. In TypeScript, we call these promises "rejected" and usually we get some kind of an error as a result.</li>
				<li>A promise might be resolved positively – the one who promised fulfilled the promise. In TypeScript, we call these promises "resolved" and we get a value out of them – the actual result.</li>
			</ul>
			<p>And since promises are objects themselves, this means that promises can be assigned to variables, returned from functions, passed as arguments into functions, and lots of other things we're able to do with regular objects.</p>
			<p>Another great feature of promises is that it is relatively easy to write a promisified wrapper around an existing callback-based function. Let's try to promisify the Shakespeare example. We'll start by taking a look at the <strong class="source-inline">showData</strong> function. This function needs to do a lot of things, and those things are sometimes not connected to one another. It needs to both process the <strong class="source-inline">xhr</strong> variable to extract the data, and it needs to know what to do with that data. So, if the API we're using changes, we'll need to change our function. If the structure of our web page changes, that is, if we need to display a <strong class="source-inline">div</strong> instead of an <strong class="source-inline">h1</strong> element, we'll need to change our function. If we need to use the author data for something else, we'll also need to change our function. Basically, if anything needs to happen to the response, it needs to happen then and there. We have no way to somehow defer that decision to another piece of code. This creates unnecessary coupling inside our code, which makes it harder to maintain.</p>
			<p>Let's change that. We can create a new function that will return a promise,  which will provide the data about the author. It will have no idea what that data will be used for:</p>
			<p class="source-code">const getShakespeareData = () =&gt; {</p>
			<p class="source-code">  const result = new Promise&lt;OpenLibraryAuthor&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">      const xhr = new XMLHttpRequest();</p>
			<p class="source-code">      const url = "https://openlibrary.org/authors/OL9388A.json";</p>
			<p class="source-code">      xhr.open("GET", url);</p>
			<p class="source-code">      xhr.send();</p>
			<p class="source-code">      xhr.onload = () =&gt; {</p>
			<p class="source-code">        if (xhr.status != 200) {</p>
			<p class="source-code">            reject({</p>
			<p class="source-code">                error: xhr.status,</p>
			<p class="source-code">                message: xhr.statusText</p>
			<p class="source-code">            })</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            const response: OpenLibraryAuthor = JSON.parse(xhr.response);</p>
			<p class="source-code">            resolve(response);</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return result;</p>
			<p class="source-code">};</p>
			<p>This function returns a <strong class="source-inline">Promise</strong> object, which was created using the <strong class="source-inline">Promise</strong> constructor. This constructor takes a single argument, which is a function. That function takes two arguments as well (also functions), which are by convention called <strong class="source-inline">resolve</strong> and <strong class="source-inline">reject</strong>. You can see that the function inside the constructor just creates an <strong class="source-inline">xhr</strong> object, calls its <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> methods, sets its <strong class="source-inline">onload</strong> property, and returns. So, basically, nothing gets done, except that the request is fired off.</p>
			<p>A promise thus created will be in the pending state. And the promise stays in this state until one of the <strong class="source-inline">resolve</strong> or <strong class="source-inline">reject</strong> functions is called inside the body. If the <strong class="source-inline">reject</strong> function is called, it will transition to a rejected state, and we'll be able to use the <strong class="source-inline">catch</strong> method of the <strong class="source-inline">Promise</strong> object to handle the error, and if the <strong class="source-inline">resolve</strong> function is called, it will transition to the resolved state, and we'll be able to use the <strong class="source-inline">then</strong> method of the <strong class="source-inline">Promise</strong> object.</p>
			<p>One thing that we should note is that this method does nothing that is UI-related. It does not print any errors on the console or change any DOM elements. It simply promises us that it will get us an <strong class="source-inline">OpenLibraryAuthor</strong> object. Now, we're free to use this object however we want:</p>
			<p class="source-code">getShakespeareData()</p>
			<p class="source-code">  .then(author =&gt; {</p>
			<p class="source-code">    const body = document.getElementsByTagName("body")[0];</p>
			<p class="source-code">    </p>
			<p class="source-code">    const image = document.createElement("img");</p>
			<p class="source-code">    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;</p>
			<p class="source-code">    body.appendChild(image);</p>
			<p class="source-code">    const name = document.createElement("h1");</p>
			<p class="source-code">    name.innerHTML = author.personal_name;</p>
			<p class="source-code">    body.appendChild(name);</p>
			<p class="source-code">  })</p>
			<p class="source-code">  .catch(error =&gt; {</p>
			<p class="source-code">    console.log(`An error occured ${error.error}: ${error.message}`);</p>
			<p class="source-code">  })</p>
			<p>In this piece of code, we call the <strong class="source-inline">getShakespeareData</strong> data function, and then on its result, we're calling two methods, <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong>. The <strong class="source-inline">then</strong> method only executes if the promise is in the resolved state and it takes in a function that will get the result. The <strong class="source-inline">catch</strong> method only executes if the promise is in the rejected state, and it will get the error as an argument to its function.</p>
			<p>One important note for the <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong> methods – they also return promises. This means that <strong class="source-inline">Promise</strong> objects are chainable, so instead of going in depth, as we did with callbacks, we can go in length, so to say. To illustrate that point, let's count to five once again.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A more comprehensive discussion of Promises will be presented in <em class="italic">Chapter 12, Guide to Promises in TypeScript</em>.</p>
			<h2 id="_idParaDest-212">Exer<a id="_idTextAnchor257"/>cise 10.04: Counting to Five with Promises</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last one was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/nlge8">https://packt.link/nlge8</a>.</p>
			<ol>
				<li value="1">Create a new file, <strong class="source-inline">counting-2.ts</strong>.</li>
				<li>In <strong class="source-inline">counting-2.ts</strong>, add an array with the English number names up to and including five:<p class="source-code">const numbers = ["One", "Two", "Three", "Four", "Five"];</p></li>
				<li>Add a promisified wrapper of the <strong class="source-inline">setTimeout</strong> function. This wrapper will only execute when the given timeout expires:<p class="source-code">const delay = (ms: number) =&gt; {</p><p class="source-code">    const result = new Promise&lt;void&gt;((resolve, reject) =&gt; {</p><p class="source-code">        setTimeout(() =&gt; {</p><p class="source-code">            resolve();</p><p class="source-code">        }, ms)</p><p class="source-code">    });</p><p class="source-code">    return result;</p><p class="source-code">}</p><p>Since our promise will not return any meaningful result, instead just resolving after a given amount of milliseconds, we have provided <strong class="source-inline">void</strong> as its type.</p></li>
				<li>Call the <strong class="source-inline">delay</strong> method with a parameter of <strong class="source-inline">1000</strong>, and after its resolution, print out the first number:<p class="source-code">delay(1000)</p><p class="source-code">.then(() =&gt; console.log(numbers[0]))</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc counting-2.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">counting-2.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node counting-2.js</p><p>You will see the output looks like this:</p><p class="source-code">One</p><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <strong class="source-inline">counting-2.ts</strong> file, after the <strong class="source-inline">then</strong> line, add another <strong class="source-inline">then</strong> line. Inside it, call the <strong class="source-inline">delay</strong> method again, with a timeout of 1 second:<p class="source-code">delay(1000)</p><p class="source-code">.then(() =&gt; console.log(numbers[0]))</p><p class="source-code">.then(() =&gt; delay(1000)) </p><p>We can do this because the result of the <strong class="source-inline">then</strong> method is <strong class="source-inline">Promise</strong>, which has its own <strong class="source-inline">then</strong> method.</p></li>
				<li>After the last <strong class="source-inline">then</strong> line, add another <strong class="source-inline">then</strong> line, inside which you print out the second number:<p class="source-code">delay(1000)</p><p class="source-code">.then(() =&gt; console.log(numbers[0]))</p><p class="source-code">.then(() =&gt; delay(1000))</p><p class="source-code">.then(() =&gt; console.log(numbers[1])) </p></li>
				<li>Compile and run the code again, and verify that the output has an extra line, displayed 1 second after the first.</li>
				<li>In the <strong class="source-inline">counting-2.ts</strong> file, add two more <strong class="source-inline">then</strong> lines for the third, fourth, and fifth numbers as well. The code should look like this:<p class="source-code">delay(1000)</p><p class="source-code">.then(() =&gt; console.log(numbers[0]))</p><p class="source-code">.then(() =&gt; delay(1000))</p><p class="source-code">.then(() =&gt; console.log(numbers[1]))</p><p class="source-code">.then(() =&gt; delay(1000))</p><p class="source-code">.then(() =&gt; console.log(numbers[2]))</p><p class="source-code">.then(() =&gt; delay(1000))</p><p class="source-code">.then(() =&gt; console.log(numbers[3]))</p><p class="source-code">.then(() =&gt; delay(1000))</p><p class="source-code">.then(() =&gt; console.log(numbers[4])) </p></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order.<p>Let's compare this code with the code of the previous exercise. It's not the cleanest code, but its function is relatively obvious. We can see how we could expand this code to count to 20. And the major benefit here is that this code, while asynchronous, is still sequential. We can reason about it, and the lines that are at the top will execute before the lines at the bottom. Furthermore, since we have objects now, we can even refactor this code into an even simpler and more extensible format – we can use a <strong class="source-inline">for</strong> loop.</p></li>
				<li>In the <strong class="source-inline">counting-2.ts</strong> file, remove the lines starting with <strong class="source-inline">delay(1000)</strong> until the end of the file. Add a line that will define a resolved promise:<p class="source-code">let promise = Promise.resolve();</p></li>
				<li>Add a <strong class="source-inline">for</strong> loop that, for each number of the <strong class="source-inline">numbers</strong> array, will add to the <strong class="source-inline">promise</strong> chain a delay of 1 second, and print the number:<p class="source-code">for (const number of numbers) {</p><p class="source-code">    promise = promise</p><p class="source-code">        .then(() =&gt; delay(1000))</p><p class="source-code">        .then(() =&gt; console.log(number))</p><p class="source-code">};}</p></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order as shown:<p class="source-code">One</p><p class="source-code">Two</p><p class="source-code">Three</p><p class="source-code">Four</p><p class="source-code">Five</p></li>
			</ol>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor258"/>Acti<a id="_idTextAnchor259"/>vity 10.02: Movie Browser Using fetch and Promises</h2>
			<p>In this activity, we will be repeating the previous activity. The major difference is that, instead of using <strong class="source-inline">XMLHttpRequest</strong> and its <strong class="source-inline">onload</strong> method, we'll be using the <strong class="source-inline">fetch</strong> web API. In contrast to the <strong class="source-inline">XMLHttpRequest</strong> class, the <strong class="source-inline">fetch</strong> web API returns a <strong class="source-inline">Promise</strong> object, so instead of nesting our callbacks to have multiple API calls, we can have a chain of promise resolutions that will be far easier to understand.</p>
			<p>The activity has the same files and resources as the previous activity.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Above the <strong class="source-inline">search</strong> function, create a helper function called <strong class="source-inline">getJsonData</strong>. This function will use the <strong class="source-inline">fetch</strong> API to get data from an endpoint and format it as JSON. It should take a single string called <strong class="source-inline">url</strong> as a parameter, and it should return a <strong class="source-inline">Promise</strong>.</li>
				<li>In the body of the <strong class="source-inline">getJsonData</strong> function, add code that calls the <strong class="source-inline">fetch</strong> function with the <strong class="source-inline">url</strong> parameter, and <strong class="source-inline">then</strong> call the <strong class="source-inline">json</strong> method on the returned response.</li>
				<li>In the <strong class="source-inline">search</strong> method, construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method.</li>
				<li>Call the <strong class="source-inline">getJsonData</strong> function with the <strong class="source-inline">searchUrl</strong> as a parameter.</li>
				<li>Add a <strong class="source-inline">then</strong> handler to the promise returned from <strong class="source-inline">getJsonData</strong>. The handler takes a single parameter of the type <strong class="source-inline">SearchResultApi</strong>.</li>
				<li>In the body of the handler, check whether we have any results and if we don't, throw an error. If we do have results, return the first item. Note that the handler returns an object with <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> properties, but the <strong class="source-inline">then</strong> method actually returns a <strong class="source-inline">Promise</strong> of that data. This means that after the handler, we can chain other <strong class="source-inline">then</strong> calls.</li>
				<li>Add another <strong class="source-inline">then</strong> call to the previous handler. This handler will take a <strong class="source-inline">movieResult</strong> parameter that contains the <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> of the movie. Use the <strong class="source-inline">id</strong> property to call the <strong class="source-inline">getMovieUrl</strong> and <strong class="source-inline">getPeopleUrl</strong> methods to, respectively, get the correct URLs for the movie details and for the cast and crew.</li>
				<li>After getting the URLs, call the <strong class="source-inline">getJsonData</strong> function with both, and assign the resulting values to variables. Note that the <strong class="source-inline">getJsonData(movieUrl)</strong> call will return a <strong class="source-inline">Promise</strong> of <strong class="source-inline">MovieResultApi</strong>, and <strong class="source-inline">getJsonData(peopleUrl)</strong> will return a <strong class="source-inline">Promise</strong> of <strong class="source-inline">PeopleResultApi</strong>. Assign those result values to variables called <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong>.</li>
				<li>Call the static <strong class="source-inline">Promise.all</strong> method with <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a <strong class="source-inline">Promise</strong> of an array of results.</li>
				<li>Return the promise generated by the <strong class="source-inline">Promise.all</strong> call from the handler.</li>
				<li>Add another <strong class="source-inline">then</strong> handler to the chain. This handler will take the array returned from <strong class="source-inline">Promise.all</strong> as a single parameter.</li>
				<li>Deconstruct the parameter into two variables. The first element of the array should be the <strong class="source-inline">movieData</strong> variable of type <strong class="source-inline">MovieResultApi</strong>, and the second element of the array should be the <strong class="source-inline">peopleData</strong> variable of type <strong class="source-inline">PeopleResultApi</strong>.</li>
				<li>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. We'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into your own <strong class="source-inline">Character</strong> objects. We need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property.</li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses we've prepared so far.</li>
				<li>Return the <strong class="source-inline">Movie</strong> object from the handler.</li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <strong class="source-inline">click</strong> event handler of the <strong class="source-inline">search</strong> button. We should simply add a <strong class="source-inline">then</strong> handler to the <strong class="source-inline">search</strong> call that will call the <strong class="source-inline">showResults</strong> method, and a <strong class="source-inline">catch</strong> handler that will call the <strong class="source-inline">clearResults</strong> method.</li>
			</ol>
			<p>Although we used <strong class="source-inline">fetch</strong> and promises in this activity, and our code is now much more efficient but complex, the basic function of the website will be the same and you should see an output similar to the previous activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found at <a href="https://packt.link/IeDTF">https://packt.link/IeDTF</a>. The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor433">this link</a>.</p>
			<h2 id="_idParaDest-214">async<a id="_idTextAnchor260"/>/await</h2>
			<p>Promises solved the problem of callbacks quite nicely. However, often, they carry with them lots of unneeded fluff. We need to write lots of <strong class="source-inline">then</strong> calls, and we need to be careful not to forget to close any parentheses.</p>
			<p>The next step is to add a piece of syntactic sugar to our TypeScript skills. Unlike the other things in this chapter, this feature originated in TypeScript, and was later adopted in JavaScript as well. I'm talking about the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords. These are two separate keywords, but they are always used together, so the whole feature became known as <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>.</p>
			<p>What we do is we can add the <strong class="source-inline">async</strong> modifier to a certain function, and then, in that function, we can use the <strong class="source-inline">await</strong> modifier to execute promises easily. Let's go once more to our Shakespearean example, and let's wrap the code we used to call <strong class="source-inline">getShakespeareData</strong> inside another function, simply called <strong class="source-inline">run</strong>:</p>
			<p class="source-code">function run() {</p>
			<p class="source-code">    getShakespeareData()</p>
			<p class="source-code">    .then(author =&gt; {</p>
			<p class="source-code">        const body = document.getElementsByTagName("body")[0];</p>
			<p class="source-code">        </p>
			<p class="source-code">        const image = document.createElement("img");</p>
			<p class="source-code">        image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;</p>
			<p class="source-code">        body.appendChild(image);</p>
			<p class="source-code">        const name = document.createElement("h1");</p>
			<p class="source-code">        name.innerHTML = author.personal_name;</p>
			<p class="source-code">        body.appendChild(name);</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .catch(error =&gt; {</p>
			<p class="source-code">        console.log(`An error occured ${error.error}: ${error.message}`);</p>
			<p class="source-code">    })</p>
			<p class="source-code">}</p>
			<p class="source-code">run();</p>
			<p>This code is functionally equivalent to the code we had previously. But now, we have a function that we can mark as an <strong class="source-inline">async</strong> function, like this:</p>
			<p class="source-code">async function run() {</p>
			<p>Now, we're allowed to just get the result of a promise and put it inside of a variable. So, the whole <strong class="source-inline">then</strong> invocation will become this:</p>
			<p class="source-code">    const author = await getShakespeareData();</p>
			<p class="source-code">    const body = document.getElementsByTagName("body")[0];</p>
			<p class="source-code">    </p>
			<p class="source-code">    const image = document.createElement("img");</p>
			<p class="source-code">    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;</p>
			<p class="source-code">    body.appendChild(image);</p>
			<p class="source-code">    </p>
			<p class="source-code">    const name = document.createElement("h1");</p>
			<p class="source-code">    name.innerHTML = author.personal_name;</p>
			<p class="source-code">    body.appendChild(name);</p>
			<p>You can see that we don't have any wrapping function calls anymore. The <strong class="source-inline">catch</strong> invocation can be replaced with a simple <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> construct, and the final version of the <strong class="source-inline">run</strong> function will look like this:</p>
			<p class="source-code">async function run () {</p>
			<p class="source-code">  try {</p>
			<p class="source-code">    const author = await getShakespeareData();</p>
			<p class="source-code">    const body = document.getElementsByTagName("body")[0];</p>
			<p class="source-code">    </p>
			<p class="source-code">    const image = document.createElement("img");</p>
			<p class="source-code">    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;</p>
			<p class="source-code">    body.appendChild(image);</p>
			<p class="source-code">    </p>
			<p class="source-code">    const name = document.createElement("h1");</p>
			<p class="source-code">    name.innerHTML = author.personal_name;</p>
			<p class="source-code">    body.appendChild(name);</p>
			<p class="source-code">  } catch (error) {</p>
			<p class="source-code">    console.log(`An error occured ${error.error}: ${error.message}`);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>You will notice that the amount of code that is deeply nested is drastically reduced. Now we can look at the code, and have a good idea of what it does, just from a quick glance. This is still the same, deeply asynchronous code, the only difference is that it looks almost synchronous and definitely sequential.</p>
			<h2 id="_idParaDest-215">Exerc<a id="_idTextAnchor261"/>ise 10.05: Counting to Five with async and await</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last one was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/TaH6b">https://packt.link/TaH6b</a>.</p>
			<ol>
				<li value="1">Create a new file, <strong class="source-inline">counting-3.ts</strong>.</li>
				<li>In <strong class="source-inline">counting-3.ts</strong>, add an array with the English number names up to and including five:<p class="source-code">const numbers = ["One", "Two", "Three", "Four", "Five"];</p></li>
				<li>Add a promisified wrapper of the <strong class="source-inline">setTimeout</strong> function. This wrapper will only execute when the given timeout expires:<p class="source-code">const delay = (ms: number) =&gt; {</p><p class="source-code">    const result = new Promise&lt;void&gt;((resolve, reject) =&gt; {</p><p class="source-code">        setTimeout(() =&gt; {</p><p class="source-code">            resolve();</p><p class="source-code">        }, ms)</p><p class="source-code">    });</p><p class="source-code">    return result;</p><p class="source-code">}</p><p>Since our promise will not return any meaningful results, instead of just resolving after a given number of milliseconds, we have provided <strong class="source-inline">void</strong> as its type.</p></li>
				<li>Create an empty <strong class="source-inline">async</strong> function called <strong class="source-inline">countNumbers</strong> and execute it on the last line of the file:<p class="source-code">async function countNumbers() {</p><p class="source-code">}</p><p class="source-code">countNumbers();</p></li>
				<li>Inside the <strong class="source-inline">countNumbers</strong> function, await the <strong class="source-inline">delay</strong> method with a parameter of <strong class="source-inline">1000</strong>, and after its resolution, print out the first number:<p class="source-code">async function countNumbers() {</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">}</p></li>
				<li>Save the file, and compile it with the following command:<p class="source-code">tsc counting-3.ts</p></li>
				<li>Verify that the compilation ended successfully and that there is a <strong class="source-inline">counting-3.js</strong> file generated in the same folder. Execute it in the <strong class="source-inline">node</strong> environment with this command:<p class="source-code">node counting-3.js</p><p>You will see the output looks like this:</p><p class="source-code">One</p><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <strong class="source-inline">counting-3.ts</strong> file, after the <strong class="source-inline">console.log</strong> line, add two more lines for the rest of the numbers as well. The code should look like this:<p class="source-code">async function countNumbers() {</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[0]);</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[1]);</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[2]);</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[3]);</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(numbers[4]);</p><p class="source-code">}</p></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order.<p>Since the code is completely identical for all the numbers, it's trivial to replace it with a <strong class="source-inline">for</strong> loop.</p></li>
				<li>In the <strong class="source-inline">counting-3.ts</strong> file, remove the body of the <strong class="source-inline">countNumbers</strong> function, and replace it with a <strong class="source-inline">for</strong> loop that, for each number of the <strong class="source-inline">numbers</strong> array, will <strong class="source-inline">await</strong> a delay of a second, and then print the number:<p class="source-code">for (const number of numbers) {</p><p class="source-code">    await delay(1000);</p><p class="source-code">    console.log(number);</p><p class="source-code">};</p></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order:<p class="source-code">One</p><p class="source-code">Two</p><p class="source-code">Three</p><p class="source-code">Four</p><p class="source-code">Five</p></li>
			</ol>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor262"/>Activ<a id="_idTextAnchor263"/><a id="_idTextAnchor264"/>ity 10.03: Movie Browser Using fetch and async/await</h2>
			<p>In this activity, we will be improving on the previous activity. The major difference is that instead of using the <strong class="source-inline">then</strong> method of the <strong class="source-inline">Promises</strong> class, we'll use the <strong class="source-inline">await</strong> keyword to do that for us magically. Instead of a chain of <strong class="source-inline">then</strong> calls, we'll just have code that looks completely regular, with some <strong class="source-inline">await</strong> statements peppered throughout.</p>
			<p>The activity has the same files and resources as the previous activity.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty. Note that this function is now marked with the <strong class="source-inline">async</strong> keywords, which allows us to use the <strong class="source-inline">await</strong> operator.</li>
				<li>Above the <strong class="source-inline">search</strong> function, create a helper function called <strong class="source-inline">getJsonData</strong>. This function will use the <strong class="source-inline">fetch</strong> API to get data from an endpoint and format it as JSON. It should take a single string called <strong class="source-inline">url</strong> as a parameter, and it should return a promise.</li>
				<li>In the body of the <strong class="source-inline">getJsonData</strong> function, add code that calls the <strong class="source-inline">fetch</strong> function with the <strong class="source-inline">url</strong> parameter, and <strong class="source-inline">then</strong> call the <strong class="source-inline">json</strong> method on the returned response.</li>
				<li>In the <strong class="source-inline">search</strong> method, construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method.</li>
				<li>Call the <strong class="source-inline">getJsonData</strong> function with <strong class="source-inline">searchUrl</strong> as a parameter, and <strong class="source-inline">await</strong> the result. Place the result into the <strong class="source-inline">SearchResultApi</strong> variable.</li>
				<li>Check whether we have any results and if we don't, throw an error. If we do have results, set the first item of the <strong class="source-inline">result</strong> property into a variable called <strong class="source-inline">movieResult</strong>. This object will contain the <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> properties of the movie.</li>
				<li>Use the <strong class="source-inline">id</strong> property to call the <strong class="source-inline">getMovieUrl</strong> and <strong class="source-inline">getPeopleUrl</strong> methods to, respectively, get the correct URLs for the movie details and for the cast and crew.</li>
				<li>After getting the URLs, call the <strong class="source-inline">getJsonData</strong> function with both, and assign the resulting values to variables. Note that the <strong class="source-inline">getJsonData(movieUrl)</strong> call will return a promise of <strong class="source-inline">MovieResultApi</strong>, and <strong class="source-inline">getJsonData(peopleUrl)</strong> will return a promise of <strong class="source-inline">PeopleResultApi</strong>. Assign those result values to variables called <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong>.</li>
				<li>Call the static <strong class="source-inline">Promise.all</strong> method with <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results. <strong class="source-inline">await</strong> this promise, and place its result into a variable of type <strong class="source-inline">array</strong>.</li>
				<li>Deconstruct that array into two variables. The first element of the array should be the <strong class="source-inline">movieData</strong> variable of type <strong class="source-inline">MovieResultApi</strong>, and the second element of the array should be the <strong class="source-inline">peopleData</strong> variable of type <strong class="source-inline">PeopleResultApi</strong>.</li>
				<li>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. We'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into our own <strong class="source-inline">Character</strong> objects. We need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property.</li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between.</li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses we've prepared so far.</li>
				<li>Return the <strong class="source-inline">Movie</strong> object from the function.</li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <strong class="source-inline">click</strong> event handler of the <strong class="source-inline">search</strong> button. We should simply add a <strong class="source-inline">then</strong> handler to the <strong class="source-inline">search</strong> call that will call the <strong class="source-inline">showResults</strong> method, and a <strong class="source-inline">catch</strong> handler that will call the <strong class="source-inline">clearResults</strong> method. <p>Although we used <strong class="source-inline">fetch</strong> and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> in this activity, and our code is now just as efficient but less complex compared with the previous activity, the basic function of the website will be the same and you should see an output similar to the previous activity.</p><p class="callout-heading">Note</p><p class="callout">The code files for this activity can be found at <a href="https://packt.link/fExtR">https://packt.link/fExtR</a>. The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor435">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-217">Summar<a id="_idTextAnchor265"/>y</h1>
			<p>In this chapter, we looked at the execution model that is used on the web, and how we can use it to actually execute code. We glanced at the surface of the intricacies of asynchronous development – and how we can use it to load data from external resources. We showed the problems that arise when we get too deep into the hole of callbacks and managed to exit it using promises. Finally, we were able to await our asynchronous code, and have the best of both words – code that looks like it's synchronous, but that executes asynchronously.</p>
			<p>We also tested the skills developed in the chapter by creating a movie data viewer browser, first using XHR and callbacks, and then improved it progressively using <strong class="source-inline">fetch</strong> and promises, and then using <strong class="source-inline">fetch</strong> and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>.</p>
			<p>The next chapter will teach you about higher-order functions and callbacks.</p>
		</div>
		<div>
			<div id="_idContainer134" class="Content">
			</div>
		</div>
	</body></html>