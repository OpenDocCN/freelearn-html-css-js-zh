<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-196"><a id="_idTextAnchor236"/>10. Event Loop and Asynchronous Behavior</h1>
		</div>
		<div><p class="callout-heading"><a id="_idTextAnchor237"/>Overview</p>
			<p class="callout">In this chapter, you'll investigate how a web page actually works within the browser, with a special focus on how, when, and why the browser executes the JavaScript code we provide. You'll dive deep into the intricacies of the event loop and see how we can manage it. Lastly, you'll learn about the tools that TypeScript offers you. By the end of this chapter, you will be able to better manage the asynchronous nature of the execution.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor238"/>Introduction</h1>
			<p>In the previous chapter, you learned the fundamentals of generics and conditional types. This chapter introduces you to event loops and asynchronous behavior. However, before you proceed with learning these topics, let's have a look at a hypothetical scenario to really understand how synchronous and asynchronous executions work. </p>
			<p><a id="_idTextAnchor239"/>Imagine a small bank that has a single teller. His name is Tom, and he's serving clients all day. Since it's a small bank and there are few clients, there's no queue. So, when a client comes in, they get Tom's undivided attention. The client provides all the necessary paperwork, and Tom processes it. If the process needs some kind of outside input, such as from a credit bureau or the bank's back-office department, Tom submits the request, and he and the client wait for the response together. They might chat a bit, and when the response comes, Tom resumes his work. If a document needs to be printed, Tom sends it to the printer that's right on his desk, and they wait and chat. When the printing is done, Tom resumes his work. Once the work is completed, the bank has another satisfied client, and Tom continues with his day. If somebody comes while Tom is serving a client (which happens seldom), they wait until Tom is completely done with the previous client, and only then do they begin their process. Even if Tom is waiting on an external response, the other client will have to wait their turn, while Tom idly chats with the current client.</p>
			<p>Tom effectively works synchronously and sequentially. There are lots of benefits of this approach to working, namely, Tom (and his bosses) can always tell whether he is serving a client or not, he always knows who his current client is, and he can completely forget all the data about the client as soon as the client leaves, knowing that they have been serviced completely. There are no issues with mixing up documents from different clients. Any problems are easy to diagnose and easy to fix. And since the queue never gets crowded, this setup works to everyone's satisfaction.</p>
			<p>So far, so good. But what happens when the bank suddenly gets more clients? As more and more clients arrive, we get a long queue, and everyone is waiting, while Tom chats with the current client, waiting on a response from the credit bureau. Tom's boss is, understandably, not happy with the situation. The current system does not scale – at all. So, he wants to change the system somehow, to be able to serve more clients. How can he do that? You will look at a couple of solutions in the following section.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor240"/>The Multi-Threaded Approach</h1>
			<p>Basically, there are two different approaches. One is to have multiple Toms. So, every single teller will still work in the exact same simple and synchronous way as before – we just have lots of them. Of course, the boss will need to have some kind of organization to know which teller is available and which is working, whether there are separate queues for each teller, or a single large queue, along with some kind of distribution mechanism (that is, a system where a number is assigned to each customer). The boss might also get one of those big office printers, instead of having one printer per teller, and have some kind of rule in order to not mix up the print jobs. The organization will be complex, but the task of every single teller will be straightforward.</p>
			<p>By now, you know we're not really discussing banks. This is the usual approach for server-side processing. Grossly simplified, the server process will have multiple sub-processes (called threads) that will work in parallel, and the main process will orchestrate everything. Each thread will execute synchronously, with a well-defined beginning, middle, and end. Since servers are usually machines with lots of resources, with heavy loads, this approach makes sense. It can accommodate low or high loads nicely, and the code that processes each request can be relatively simple and easy to debug. It even makes sense to have the thread wait for some external resource (a file from the file system, or data from the network or database), since we can always spin up new threads if we have more requests. This is not the case with real live tellers. We cannot just clone a new one if more clients come. The kind of waiting done by the threads (or by Tom) is usually referred to as <em class="italic">busy waiting</em>. The thread is not doing anything, but it's not available for any work, since it's busy doing something – it's busy waiting. Just like Tom was actually busy chatting with the client while waiting for a response from the credit bureau.</p>
			<p>We have a system that can be massively parallel and concurrent, but still, each part of it is run synchronously. The benefit of this approach is that we can serve many, many clients at the same time. One obvious downside is the cost, both in hardware and in complexity. While we managed to keep the client processing simple, we'll need a huge infrastructure that takes care of everything else – adding tellers, removing tellers, queueing customers, managing access to the office printer, and similar tasks.</p>
			<p>This will use all the available resources of the bank (or the server), but that is fine, since that's the whole point – to serve clients, as many and as fast as possible, and nothing else. </p>
			<p>However, there is another approach – asynchronous execution.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor241"/>The Asynchronous Execution Approach</h2>
			<p>The other approach, the one taken by the web and, by extension, JavaScript and TypeScript, is to use just a single thread – so Tom is still on his own. But, instead of Tom idly chatting with a waiting client, he could do something else. If a situation arises where he needs some verification from the back office, he just writes down what he was doing and how far he got on a piece of paper, gives that paper to the client, and sends them to the back of the queue. Tom is now ready to start serving the next client in line. If that client does not need external resources, they are processed completely and are free to leave. If they need something else that Tom needs to wait for, they too are sent to the back of the line. And so on, and so forth. This way, if Tom has any clients at all, he's processing their requests. He's never busy waiting, instead, he's busy working. If a client needs to wait for a response, they do so separately from Tom. The only time Tom is idle is when he has no clients at all.</p>
			<p>The benefit of this approach is fairly obvious – before, Tom spent a lot of his time chatting, now he is working all the time (of course, this benefit is from Tom's boss' point of view – Tom liked the small talk). An additional benefit is that we know our resource consumption up front. If we only have one teller, we know the square footage that we will need for the office. However, there are some downsides as well. The most important downside is that our clients now have to know our process quite intimately. They will need to understand how to queue and requeue, how to continue working from where they left off, and so on. Tom's work also got a lot more complicated. He needs to know how to pause the processing of a client, how to continue, how to behave if an external response is not received, and so on. This model of working is usually called asynchronous and concurrent. Doing his job, Tom will jump between multiple clients at the same time. More than one client will have their process started but not finished. And there's no way for a client to estimate how long it will take to process their task once it is started – it depends on how many other clients Tom processes at the same time.</p>
			<p>From the early days, this model made much more sense for the web. For starters, web applications are processed on the device of the client. We should not make any technical assumptions about it – as we cannot be sure about the kind of device that the client might be using. In essence, a web page is a guest on the client's device – and it should behave properly. For example, using up all of a device's resources to show what amounts to a fancy animation is not proper behavior at all. Another important issue is security. If we think of web pages as applications that contain some code, we're basically executing someone's code on our machine whenever we enter a web address in the browser's address bar. </p>
			<p>The browser needs to make sure that the code on the page, even if it's malicious, is restricted in what it can do to our machine. The web would not have been as popular as it is today if visiting a website could make your computer explode.</p>
			<p>So, since the browser cannot know in advance which pages it will be used for, it was decided that each web page will only get access to a single thread. Also, for security reasons, each web page will get a separate thread, so a running web page cannot meddle in the execution of other pages that may execute at the same time (with features such as web workers and Chrome applications, these restrictions are somewhat loosened, but in principle, they still apply). </p>
			<p>There is simply no way for a web page to spawn enough threads to swarm the system, or for a web page to get the data from another web page. And, since a web page needs to do lots of things at once, using the synchronous and sequential approach was out of the question. That is why all the JavaScript execution environments completely embraced the asynchronous, concurrent approach. This was done to such an extent that some common synchronization techniques are, intentionally, just not available in JavaScript.</p>
			<p>For example, lots of other languages have a "wait some time" primitive, or a library function that does that. For example, in the C# programming language, we can have this code:</p>
			<pre>Console.WriteLine("We will wait 10 s");
Thread.Sleep(10000);
Console.WriteLine("... 10 seconds later");
Thread.Sleep(15000);
Console.WriteLine("... 15 more seconds later");</pre>
			<p>This code will write some text to the console, and 10 seconds later, write some more text. During the 25 seconds of the wait, the thread this executes on will be completely non-responsive, but the code written is simple and linear – easily understood, easily changeable, and easily debuggable. JavaScript simply does not have such a synchronous primitive, but it has an asynchronous variant in the <code>setTimeout</code> function. The simplest equivalent code would be the following:</p>
			<pre>console.log("We will wait 10 s");
setTimeout(() =&gt; {
    console.log("... 10 seconds later");
    setTimeout(() =&gt; {
        console.log("... 15 more seconds later");
    }, 15000);
}, 10000);</pre>
			<p>It's obvious that this code is much more complex than the C# equivalent, but the advantage that we get is that this code is non-blocking. In the 25 total seconds that this code is executing, our web page can do everything it needs to do. It can respond to events, the images can load and display, we can resize the window, scroll the text – basically, the application will resume the normal and expected functionalities.</p>
			<p>Note that while it's possible to block the JavaScript execution with some special synchronous code, it's not easy to do it. When it does actually happen, the browser can detect that it did happen and terminate the offending page:</p>
			<div><div><img src="img/B14508_10_01.jpg" alt="Figure 10.1: Unresponsive page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Unresponsive page</p>
			<h1 id="_idParaDest-200">E<a id="_idTextAnchor242"/>xecuting JavaScript</h1>
			<p>When a JavaScript execution environment, such as a node or a browser loads a JavaScript file, it parses it and then runs it. All the functions that are defined in a JavaScript file are registered, and all the code that is not in a function is executed. The order of the execution is according to the code's position in the file. So, consider a file having the following code: </p>
			<pre>console.log("First");
console.log("Second");</pre>
			<p>The console will always display this:</p>
			<pre>First
Second</pre>
			<p>The order of the output cannot be changed, without changing the code itself. This is because the line with <code>First</code> will be executed completely – always – and then, and only then, will the line with <code>Second</code> begin to execute. This approach is synchronous because the execution is synchronized by the environment. We are guaranteed that the second line will not start executing, until and unless the line above it is completely done. But what happens if the line calls some function? Let's take a look at the following piece of code:</p>
			<pre>function sayHello(name){
    console.log(`Hello ${name}`);
}
function first(){
    second();
}
function second(){
    third();
}
function third(){
    sayHello("Bob");
}
first();</pre>
			<p>When the code is parsed, the environment will detect that we have four functions – <code>first</code>, <code>second</code>, <code>third</code>, and <code>sayHello</code>. It will also execute the line of code that is not inside a function (<code>first();</code>), and that will start the execution of the <code>first</code> function. But that function, while it's executing, calls the <code>second</code> function. The runtime will then suspend the running of the <code>first</code> function, remember where it was, and begin with the execution of the <code>second</code> function. This function, in turn, calls the <code>third</code> function. The same thing happens again – the runtime starts executing the <code>third</code> function, remembering that once that function is done, it should resume with the execution of the <code>second</code> function, and that once <code>second</code> is done, it should resume with the execution of the <code>first</code> function. </p>
			<p>The structure the runtime uses to remember which function is active, and which are waiting, is called a <strong class="bold">stack</strong>, specifically, <em class="italic">the call stack</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term "stack" is used in the sense of a stack of dishes, or a stack of pancakes. We can only add to the top, and we can only remove from the top. </p>
			<p>The executing functions are put one on top of the other, and the topmost function is the one being actively executed, as shown in the following representation:</p>
			<div><div><img src="img/B14508_10_02.jpg" alt="Figure 10.2: Stack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Stack</p>
			<p>In the example, the <code>third</code> function will call the <code>sayHello</code> function, which will in turn call the <code>log</code> function of the <code>console</code> object. Once the <code>log</code> function finishes executing, the stack will start unwinding. That means that once a certain function finishes executing, it will be removed from the stack, and the function below it will be able to resume executing. So, once the <code>sayHello</code> function finishes executing, the <code>third</code> function will resume and finish in turn. This will trigger the continuation of the <code>second</code> function, and when that function is done as well, the <code>first</code> function will continue, and eventually finish. When the <code>first</code> function finishes executing, the stack will become empty – and the runtime will stop executing code.</p>
			<p>It's worth noting that all of this execution is done strictly synchronously and deterministically. We can deduce the exact order and number of function calls just from looking at the code. We can also use common debugging tools such as breakpoints and stack traces.</p>
			<h2 id="_idParaDest-201">Ex<a id="_idTextAnchor243"/>ercise 10.01: Stacking Functions</h2>
			<p>In this exercise, we'll define few simple functions that call each other. Each of the functions will log to the console when it starts executing and when it's about to finish executing. We will analyze when and in what order the output is mapped to the console:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/X7QZQ">https://packt.link/X7QZQ</a>.</p>
			<ol>
				<li>Create a new file, <code>stack.ts</code>.</li>
				<li>In <code>stack.ts</code>, define three functions called <code>inner</code>, <code>middle</code>, and <code>outer</code>. None of them need to have parameters or return types:<pre>function inner () {
}
function middle () {
}
function outer () {
}</pre></li>
				<li>In the body of the <code>inner</code> function, add a single <code>log</code> statement, indented by four spaces:<pre>function inner () {
    console.log("    Inside inner function");
}</pre></li>
				<li>In the body of the <code>middle</code> function, add a call to the <code>inner</code> function. Before and after the call, add a <code>log</code> statement, indented by two spaces:<pre>function middle () {
    console.log("  Starting middle function");
    inner();
    console.log("  Finishing middle function");
}</pre></li>
				<li>In the body of the <code>outer</code> function, add a call to the <code>middle</code> function. Before and after the call, add a <code>log</code> statement:<pre>function outer () {
    console.log("Starting outer function");
    middle();
    console.log("Finishing outer function");
}</pre></li>
				<li>After the function declaration, create a call only to the <code>outer</code> function:<pre>outer();</pre></li>
				<li>Save the file, and compile it with the following command:<pre>tsc stack.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>stack.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node stack.js</pre><p>You will see the output looks like this:</p><pre>Starting outer function
  Starting middle function
    Inside inner function
  Finishing middle function
Finishing outer function</pre></li>
			</ol>
			<p>The output shows which function started executing first (<code>outer</code>), as that is the first message displayed. It can also be noted that the <code>middle</code> function finished executing after the <code>inner</code> function was already finished, but before the <code>outer</code> function was finished.</p>
			<h1 id="_idParaDest-202">Br<a id="_idTextAnchor244"/>owsers and JavaScript</h1>
			<p>When a web page is requested by the user, the browser needs to do lots of things. We won't go into the details of each of them, but we'll take a look at how it handles our code.</p>
			<p>First of all, the browser sends the request to the server and receives an HTML file as a response. Within that HTML file, there are embedded links to resources that are needed for the page, such as images, stylesheets, and JavaScript code. The browser then downloads those as well and applies them to the downloaded HTML. Images are displayed, elements are styled, and JavaScript files are parsed and run.</p>
			<p>The order in which the code is executed is according to the file's order in the HTML, then according to the code's position in the file. But when are the functions called? Let's say we have the following code in our file:</p>
			<pre>function sayHello() {
    console.log("Hello");
}
sayHello();</pre>
			<p>First, the <code>sayHello</code> function is registered, and then when it's called later, the function actually executes and writes <code>Hello</code> to the console. Take a look at the following code now:</p>
			<pre>function sayHello() {
    console.log("Hello");
}
function sayHi() {
    console.log("Hi");
}
sayHello();
sayHi();
sayHello();</pre>
			<p>When the file with the preceding code is processed, it will register that it has two functions, <code>sayHello</code> and <code>sayHi</code>. Then it will detect that it has three invocations, that is, there are three tasks that need to be processed. The environment has something that is called the <strong class="bold">task queue</strong>, where it will put all the functions that need to be executed, one by one. So, our code will be transformed into three tasks. Then, the environment will check if the stack is actually empty, and if it is, it will take the first task off the queue and start executing it. The stack will grow and shrink depending on the execution of the code of the first task, and eventually, when the first task is finished, it will be empty. So, after the first task is executed, the situation will be as follows:</p>
			<ol>
				<li value="1">The execution stack will be empty.</li>
				<li>The task queue will contain two tasks.</li>
				<li>The first task will be completely done.</li>
			</ol>
			<p>Once the stack is empty, the next task is dequeued and executed, and so on, until both the task queue and the stack are empty, and all the code is executed. Again, this whole process is done synchronously, in a specified order.</p>
			<h2 id="_idParaDest-203">Ev<a id="_idTextAnchor245"/>ents in the Browser</h2>
			<p>Now, take a look at a different example:</p>
			<pre>function sayHello() {
    console.log("Hello");
}
document.addEventListener("click", sayHello);</pre>
			<p>If you have this code in a JavaScript file that is loaded by the browser, you can see that the <code>sayHello</code> function is registered but not executed. However, if you click anywhere on the page, you will see that the <code>Hello</code> string appears on the console, meaning the <code>sayHello</code> function got executed. If you click multiple times, you'll get multiple instances of <code>"Hello"</code> on the console. And this code did not invoke the <code>sayHello</code> function even once; you don't have the <code>sayHello()</code> invocation in the code at all.</p>
			<p>What happened is, you <em class="italic">registered</em> our function as an event listener. Consider that you don't call our function at all, but the browser's environment will call it for us, whenever a certain event occurs – in this case, the <code>click</code> event on the whole <code>document</code>. And since those events are generated by the user, we cannot know if and when our code will execute. Event listeners are the principal way that our code can communicate with the page that it's on, and they are called asynchronously – you don't know when or if the function will be invoked, nor how many times it will be invoked.</p>
			<p>What the browser does, when an event occurs, is to look up its own internal table of registered event handlers. In our case, if a <code>click</code> event occurs anywhere on the <code>document</code> (that's the whole web page), the browser will see that you have registered the <code>sayHello</code> function to respond to it. That function will not be executed directly – instead, the browser will place an invocation of the function in the task queue. After that, the regular behavior explained previously takes effect. If the queue and stack are empty, the event handler will begin executing immediately. Otherwise, our handler will wait for its turn.</p>
			<p>This is another core effect of asynchronous behavior – we simply cannot guarantee that the event handler will execute immediately. It might be the case that it does, but there is no way to know if the queue and stack are empty at a specific moment. If they are, we'll get immediate execution, but if they're not, we'll have to wait our turn.</p>
			<h1 id="_idParaDest-204">En<a id="_idTextAnchor246"/>vironment APIs</h1>
			<p>Most of our interaction with the browser will be done in the same pattern – you will define a function, and pass that function as a parameter to some browser API. When and if that function will actually be scheduled for execution will depend on the particulars of that API. In the previous case, you used the event handler API, <code>addEventListener</code>, which takes two parameters, the name of an event, and the code that will be scheduled when that event happens. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can get a list of different possible events at <a href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>.</p>
			<p>In the rest of this chapter, you will use two other APIs as well, the environment's method to defer some code for later execution (<code>setTimeout</code>) and the ability to call on external resources (popularly called AJAX). There are two different AJAX implementations that we will be working with, the original <code>XMLHttpRequest</code> implementation, and the more modern and flexible <code>fetch</code> implementation.</p>
			<h2 id="_idParaDest-205">se<a id="_idTextAnchor247"/>tTimeout</h2>
			<p>As mentioned previously, the environment offers no possibility to pause the execution of JavaScript for a certain amount of time. However, the need to execute some code after some set amount of time has passed arises quite often. So, instead of pausing the execution, we get to do something different that has the same outcome. We get to schedule a piece of code to get executed after an amount of time has passed. To do that we use the <code>setTimeout</code> function. This function takes two parameters: A function that will need to be executed, and the time, in milliseconds, it should defer the execution of that function by:</p>
			<pre>setTimeout(function() {
    console.log("After one second");
}, 1000);</pre>
			<p>Here it means that the anonymous function that is passed as a parameter will be executed after 1,000 milliseconds, that is, one second.</p>
			<h2 id="_idParaDest-206">Ex<a id="_idTextAnchor248"/>ercise 10.02: Exploring setTimeout</h2>
			<p>In this exercise, you'll use the <code>setTimeout</code> environment API call to investigate how asynchronous execution behaves and what it does:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/W0mlS">https://packt.link/W0mlS</a>.</p>
			<ol>
				<li value="1">Create a new file, <code>delays-1.ts</code>.</li>
				<li>In <code>delays-1.ts</code>, log some text at the beginning of the file:<pre>console.log("Printed immediately");</pre></li>
				<li>Add two calls to the <code>setTimeout</code> function:<pre>setTimeout(function() {
    console.log("Printed after one second");
}, 1000);
setTimeout(function() {
    console.log("Printed after two second");
}, 2000);</pre><p>Here, instead of creating a function and giving it to the <code>setTimeout</code> function using its name, we have used an anonymous function that we have created in-place. We can also use arrow functions instead of functions defined with the <code>function</code> keyword.</p></li>
				<li>Save the file, and compile it with the following command:<pre>tsc delays-1.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>delays-1.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node delays-1.js</pre><p>You will see the output looks like this:</p><pre>Printed immediately
Printed after one second
Printed after two second</pre><p>The second and third lines of the output should not appear immediately, but after 1 and 2 seconds respectively.</p></li>
				<li>In the <code>delays-1.ts</code> file, switch the two calls to the <code>setTimeout</code> function:<pre>console.log("Printed immediately");
setTimeout(function() {
    console.log("Printed after two second");
}, 2000);
setTimeout(function() {
    console.log("Printed after one second");
}, 1000);</pre></li>
				<li>Compile and run the code again, and verify that the output behaves identically. Even if the former <code>setTimeout</code> was executed first, its <code>function</code> parameter is not scheduled to run until 2 seconds have passed.</li>
				<li>In the <code>delays-1.ts</code> file, move the initial <code>console.log</code> to the bottom:<pre>setTimeout(function() {
    console.log("Printed after two second");
}, 2000);
setTimeout(function() {
    console.log("Printed after one second");
}, 1000);
console.log("Printed immediately");</pre></li>
				<li>Compile and run the code again, and verify that the output behaves identically. This illustrates one of the most common problems with code that behaves asynchronously. Even though the line was at the bottom of our file, it was executed first. It's much harder to mentally trace code that does not follow the top-down paradigm we're used to.</li>
				<li>Create a new file, <code>delays-2.ts</code>.</li>
				<li>In <code>delays-2.ts</code>, add a single call to the <code>setTimeout</code> function, and set its delay time to <code>0</code>. This will mean that our code needs to wait 0 milliseconds in order to execute:<pre>setTimeout(function() {
    console.log("#1 Printed immediately?");
}, 0);</pre></li>
				<li>Add a <code>console.log</code> statement after the call to <code>setTimeout</code>:<pre>console.log("#2 Printed immediately.");</pre></li>
				<li>Save the file, and compile it with the following command:<pre>tsc delays-2.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>delays-2.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node delays-2.js</pre><p>You will see the output looks like this:</p><pre>#2 Printed immediately.
#1 Printed immediately?;</pre><p>Well, that looks unexpected. Both lines appear basically immediately, but the one that was in the <code>setTimeout</code> block, and was first in the code, came after the line at the bottom of the script. And we explicitly told <code>setTimeout</code> not to wait, that is, to wait 0 milliseconds before the code got executed.</p></li>
			</ol>
			<p>To understand what happened, we need to go back to the call queue. When the file was loaded, the environment detected that we had two tasks that needed to be done, the call to <code>setTimeout</code> and the bottom call to <code>console.log</code> (#2). So, those two tasks were put into the task queue. Since the stack was empty at that time, the <code>setTimeout</code> call started executing, and #2 was left in the task queue. The environment saw that it has a zero delay, so immediately took the function (#1), and put it <em class="italic">at the end</em> of the task queue, after #2. So, after the <code>setTimeout</code> call was done, we were left with two <code>console.log</code> tasks in the queue, with #2 being the first, and #1 being the second.</p>
			<p>They got executed sequentially, and on our console, we got #2 first, and #1 second.</p>
			<h2 id="_idParaDest-207">AJ<a id="_idTextAnchor249"/>AX (Asynchronous JavaScript and XML)</h2>
			<p>In the early days of the web, it was not possible to get data from a server once the page was loaded. That was a huge inconvenience for developing dynamic web pages, and it was solved by the introduction of an object called <code>XMLHttpRequest</code>. This object enabled developers to get data from a server after the initial page load – and since loading data from a server means using an external resource, it had to be done in an asynchronous manner (even if it has XML right in the name, currently, it will mostly be used for JSON data). To use this object, you'll need to instantiate it and use a few of its properties.</p>
			<p>To illustrate its usage, we'll try to get data about William Shakespeare from the Open Library project. The URL that we'll use to retrieve that information is <a href="https://openlibrary.org/authors/OL9388A.json">https://openlibrary.org/authors/OL9388A.json</a>, and the access method that we will use is <code>GET</code>, as we will only be getting data.</p>
			<p>The data received is of a specific format, defined by Open Library, so you'll start by creating an interface for the data that you will actually use. You'll display only an image of the Bard (received as an array of photo IDs), and the name, so you can define the interface like this:</p>
			<pre>interface OpenLibraryAuthor {
  personal_name: string;
  photos: number[];
}</pre>
			<p>Next, create the <code>XMLHttpRequest</code> object, and assign it to a variable called <code>xhr</code>:</p>
			<pre>const xhr = new XMLHttpRequest();</pre>
			<p>Now you need to <code>open</code> a connection to our URL:</p>
			<pre>const url = "https://openlibrary.org/authors/OL9388A.json";
xhr.open("GET", url);</pre>
			<p>This call doesn't actually send anything, but it prepares the system for accessing the external resource. Lastly, you need to actually send the request, using the <code>send</code> method:</p>
			<pre>xhr.send();</pre>
			<p>Since the request is asynchronous, this call will execute and finish immediately. In order to actually process the data once this request is done, you need to add something to this object – a callback. That is a function that will not be executed by us, but by the <code>xhr</code> object, once some event happens. This object has several events, such as <code>onreadystatechange</code>, <code>onload</code>, <code>onerror</code>, <code>ontimeout</code>, and you can set different functions to react to different events, but in this case, you will just use the <code>onload</code> event. Create a function that will get the data from the response and show it on the web page where our script is running:</p>
			<pre>const showData = () =&gt; {
  if (xhr.status != 200) {
    console.log(`An error occured ${xhr.status}: ${xhr.statusText}`);
  } else {
    const response: OpenLibraryAuthor = JSON.parse(xhr.response);
    const body = document.getElementsByTagName("body")[0];
    
    const image = document.createElement("img");
    image.src = `http://covers.openlibrary.org/a/id/${response.photos[0]}-M.jpg`;
    body.appendChild(image);
    const name = document.createElement("h1");
    name.innerHTML = response.personal_name;
    body.appendChild(name);
  }
};</pre>
			<p>In this method, you will be using some properties of the <code>xhr</code> variable that was defined previously, such as <code>status</code>, which gives us the HTTP status code of the request, or <code>response</code>, which gives us the actual response. If we just call the <code>showData</code> method by ourselves, we'll most likely get empty fields or an error, as the response will not have finished. So, we need to give this function to the <code>xhr</code> object, and it will use it to call the <code>showData</code> back:</p>
			<pre>xhr.onload = showData;</pre>
			<p>Save this code as <code>shakespeare.ts</code>, compile it, and add it to an HTML page using the following:</p>
			<pre>    &lt;script src="img/shakespeare.js"&gt;&lt;/script&gt;</pre>
			<p>You will get a result similar to the following:</p>
			<div><div><img src="img/B14508_10_03.jpg" alt="Figure 10.3: Retrieved image of William Shakespeare&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3: Retrieved image of William Shakespeare</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor250"/>Act<a id="_idTextAnchor251"/>ivity 10.01: Movie Browser Using XHR and Callbacks</h2>
			<p>As a TypeScript developer, you have been tasked with creating a simple page to view movie data. The web page will be simple, with a text input field and a button. When you enter the name of a movie in the search input field and press the button, general information about the movie will be displayed on the web page, along with some images relevant to the movie.</p>
			<p>You can use <em class="italic">The Movie Database</em> (<a href="https://www.themoviedb.org/">https://www.themoviedb.org/</a>) as a source of general data, specifically its API. You need to issue AJAX requests using <code>XmlHttpRequest</code>, and use the data the site provides to format your own object. When using an API the data will rarely, if ever, be in the format we actually need. This means that you will need to use several API requests to get our data, and piecemeal construct our object. A common TypeScript approach to this issue is to use two sets of interfaces – one that exactly matches the format of the API, and one that matches the data that you use in your application. In this activity, you need to use the <code>Api</code> suffix to denote those interfaces that match the API format.</p>
			<p>Another important thing to note is that this particular API does not allow completely open access. You'll need to register for an API key and then send it in each API request. In the setup code for this activity, three functions (<code>getSearchUrl</code>, <code>getMovieUrl</code>, <code>getPeopleUrl</code>) will be provided that will generate the correct URLs for the needed API requests, once the <code>apiKey</code> variable is set to the value you will receive from The Movie Database. Also provided will be the base HTML, styling, as well as the code used to actually display the data – all that is missing is the data itself.</p>
			<p>Those resources are listed here:</p>
			<ul>
				<li><code>display.ts</code> – A TypeScript file that houses the <code>showResult</code> and <code>clearResults</code> methods, which you will call to display a movie and clear the screen, respectively.</li>
				<li><code>interfaces.ts</code> – A TypeScript file that contains the interfaces that you will use. All interfaces that have an <code>Api</code> suffix are objects that you will receive from The Movie Database API, and the rest (<code>Movie</code> and <code>Character</code>) will be used to display the data.</li>
				<li><code>script.ts</code> – A TypeScript file that has some boilerplate code that will start the application. The <code>search</code> function is here, and that function will be the main focus of this activity.</li>
				<li><code>index.html</code> – An HTML file that has the basic markup for our web page.</li>
				<li><code>styles.css</code> – A style sheet file that is used to style the results.</li>
			</ul>
			<p>The following steps should help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found at <a href="https://packt.link/Qo4dB">https://packt.link/Qo4dB</a>.</p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Construct a new <code>XMLHttpRequest</code> object.</li>
				<li>Construct a new string for the search result URL using the <code>getSearchUrl</code> method.</li>
				<li>Call the <code>open</code> and <code>send</code> methods of the <code>xhr</code> object.</li>
				<li>Add an event handler for the <code>xhr</code> object's <code>onload</code> event. Take the response and parse it as a JSON object. Store the result in a variable of the <code>SearchResultApi</code> interface. This data will have the results of our search in a <code>results</code> field. If you get no results, this means that our search failed.</li>
				<li>If the search returned no results, call the <code>clearResults</code> method.</li>
				<li>If the search returned some results, just take the first one and store it in a variable, ignoring the other ones.</li>
				<li>Inside the <code>onload</code> handler, in the successful search branch, create a new <code>XMLHttpRequest</code> object.</li>
				<li>Construct a new string for the search result URL using the <code>getMovieUrl</code> method.</li>
				<li>Call the <code>open</code> and <code>send</code> method of the constructed <code>xhr</code> object.</li>
				<li>Add an event handler for the <code>xhr</code> objects's <code>onload</code> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <code>MovieResultApi</code> interface. This response will have the general data for our movie, specifically, everything except the people who were involved in the movie. You will need to have another call to the API to get the data about the people.</li>
				<li>Inside the <code>onload</code> handler, in the successful search branch, create a new <code>XMLHttpRequest</code> object.</li>
				<li>Construct a new string for the search result URL using the <code>getPeopleUrl</code> method.</li>
				<li>Call the <code>open</code> and <code>send</code> method of the constructed <code>xhr</code> object.</li>
				<li>Add an event handler for the <code>xhr</code> object's <code>onload</code> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <code>PeopleResultApi</code> interface. This response will have data about the people who were involved in the movie.</li>
				<li>Now you actually have all the data you need, so you can create your own object inside the people <code>onload</code> handler, which is inside the movie <code>onload</code> handler, which is inside the search <code>onload</code> handler.</li>
				<li>The people data has <code>cast</code> and <code>crew</code> properties. You'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into our own <code>Character</code> objects. You need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property.</li>
				<li>From the <code>crew</code> property of the people data, you'll only need the director and the writer. Since there can be multiple directors and writers, you'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses you prepared so far.</li>
				<li>Call the <code>showResults</code> function with the movie you constructed.</li>
				<li>In your parent directory (<code>Activity01</code> in this case), install dependencies with <code>npm i</code>.</li>
				<li>Compile the program using <code>tsc ./script.ts ./interfaces.ts ./display.ts</code>.</li>
				<li>Verify that the compilation ended successfully.</li>
				<li>Open <code>index.html</code> using the browser of your choice. <p>You<a id="_idTextAnchor252"/> should see the following in your browser:</p><div><img src="img/B14508_10_04.jpg" alt="Figure 10.4: The final web page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.4: The final web page</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor431">this link</a>.</p>
			<p>We w<a id="_idTextAnchor253"/>ill improve this application further in <em class="italic">Activity 10.02, Movie Browser using fetch and Promises,</em> and <em class="italic">Activity 10.03, Movie Browser using fetch and async/await</em>. However, before we do that, you need to learn about Promises and <code>async</code>/<code>await</code> in TypeScript.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor254"/>Promises</h1>
			<p>Using callbacks for asynchronous development gets the job done – and that is great. However, in many applications, our code needs to use external or asynchronous resources all the time. So, very quickly, we'll get to a situation where inside our callback, there is another asynchronous call, which requires a callback inside the callback, which in turn needs a callback on its own….</p>
			<p>It was (and in some cases, it still is) not uncommon to be a dozen levels deep inside the callback hole.</p>
			<h2 id="_idParaDest-210">Exer<a id="_idTextAnchor255"/>cise 10.03: Counting to Five</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last word was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/zD7TT">https://packt.link/zD7TT</a>.</p>
			<ol>
				<li value="1">Create a new file, <code>counting-1.ts</code>.</li>
				<li>In <code>counting-1.ts</code>, add an array with the English number names up to and including five:<pre>const numbers = ["One", "Two", "Three", "Four", "Five"];</pre></li>
				<li>Add a single call to the <code>setTimeout</code> function, and print out the first number after a second:<pre>setTimeout(function() {
    console.log(numbers[0]);
}, 1000);</pre></li>
				<li>Save the file, and compile it with the following command:<pre>tsc counting-1.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>counting-1.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node counting-1.js</pre><p>You will see the output looks like this:</p><pre>One</pre><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <code>counting-1.ts</code> file, inside the <code>setTimeout</code> function, below <code>console.log</code>, add another, nested, call to the <code>setTimeout</code> function:<pre>setTimeout(function() {
    console.log(numbers[0]);
    setTimeout(function() {
        console.log(numbers[1]);
    }, 1000);
}, 1000);</pre></li>
				<li>Compile and run the code again, and verify that the output has an extra line, displayed 1 second after the first:<pre>One
Two</pre></li>
				<li>In the <code>counting-1.ts</code> file, inside the nested <code>setTimeout</code> function, above <code>console.log</code>, add another nested call to the <code>setTimeout</code> function:<pre>setTimeout(function() {
    console.log(numbers[0]);
    setTimeout(function() {
        setTimeout(function() {
            console.log(numbers[2]);
        }, 1000);
        console.log(numbers[1]);
    }, 1000);
}, 1000);</pre></li>
				<li>In the innermost <code>setTimeout</code> function, below <code>console.log</code>, add yet another nested call to <code>setTimeout</code>, and repeat the process for the fifth number as well. The code should look like this:<pre>setTimeout(function() {
    console.log(numbers[0]);
    setTimeout(function() {
        setTimeout(function() {
            console.log(numbers[2]);
            setTimeout(function() {
                console.log(numbers[3]);
                setTimeout(function() {
                    console.log(numbers[4]);
                }, 1000);
            }, 1000);
        }, 1000);
        console.log(numbers[1]);
    }, 1000);
}, 1000);</pre></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order as shown:<pre>One
Two
Three
Four
Five</pre></li>
			</ol>
			<p>In this simple example, we implemented a simple functionality – counting to five. But as you can already see, the code is becoming extremely messy. Just imagine if we needed to count to 20 instead of 5. That would be a downright unmaintainable mess. While there are ways to make this specific code look a bit better and more maintainable, in general, that's not the case. The use of callbacks is intrinsically connected with messy and hard-to-read code. And messy and hard-to-read code is the best place for bugs to hide, so callbacks do have a reputation of being the cause of difficult-to-diagnose bugs.</p>
			<p>An additional problem with callbacks is that there cannot be a unified API across different objects. For example, we needed to explicitly know that in order to receive data using the <code>xhr</code> object, we need to call the <code>send</code> method and add a callback for the <code>onload</code> event. And we needed to know that in order to check whether the request was successful or not, we have to check the <code>status</code> property of the <code>xhr</code> object.</p>
			<h2 id="_idParaDest-211">What<a id="_idTextAnchor256"/> are Promises?</h2>
			<p>Fortunately, we can promise you that there is a better way. That way was initially done by third-party libraries, but it has proven to be so useful and so widely adopted that it was included in the JavaScript language itself. The logic behind this solution is rather simple. Each asynchronous call is basically a promise that, sometime in the future, some task will be done and some result will be acquired. As with promises in real life, we can have three different states for a promise:</p>
			<ul>
				<li>A promise might not be resolved yet. This means that we need to wait some more time before we get a result. In TypeScript, we call these promises "pending."</li>
				<li>A promise might be resolved negatively – the one who promised broke the promise. In TypeScript, we call these promises "rejected" and usually we get some kind of an error as a result.</li>
				<li>A promise might be resolved positively – the one who promised fulfilled the promise. In TypeScript, we call these promises "resolved" and we get a value out of them – the actual result.</li>
			</ul>
			<p>And since promises are objects themselves, this means that promises can be assigned to variables, returned from functions, passed as arguments into functions, and lots of other things we're able to do with regular objects.</p>
			<p>Another great feature of promises is that it is relatively easy to write a promisified wrapper around an existing callback-based function. Let's try to promisify the Shakespeare example. We'll start by taking a look at the <code>showData</code> function. This function needs to do a lot of things, and those things are sometimes not connected to one another. It needs to both process the <code>xhr</code> variable to extract the data, and it needs to know what to do with that data. So, if the API we're using changes, we'll need to change our function. If the structure of our web page changes, that is, if we need to display a <code>div</code> instead of an <code>h1</code> element, we'll need to change our function. If we need to use the author data for something else, we'll also need to change our function. Basically, if anything needs to happen to the response, it needs to happen then and there. We have no way to somehow defer that decision to another piece of code. This creates unnecessary coupling inside our code, which makes it harder to maintain.</p>
			<p>Let's change that. We can create a new function that will return a promise,  which will provide the data about the author. It will have no idea what that data will be used for:</p>
			<pre>const getShakespeareData = () =&gt; {
  const result = new Promise&lt;OpenLibraryAuthor&gt;((resolve, reject) =&gt; {
      const xhr = new XMLHttpRequest();
      const url = "https://openlibrary.org/authors/OL9388A.json";
      xhr.open("GET", url);
      xhr.send();
      xhr.onload = () =&gt; {
        if (xhr.status != 200) {
            reject({
                error: xhr.status,
                message: xhr.statusText
            })
        } else {
            const response: OpenLibraryAuthor = JSON.parse(xhr.response);
            resolve(response);
        }
      }
  });
  return result;
};</pre>
			<p>This function returns a <code>Promise</code> object, which was created using the <code>Promise</code> constructor. This constructor takes a single argument, which is a function. That function takes two arguments as well (also functions), which are by convention called <code>resolve</code> and <code>reject</code>. You can see that the function inside the constructor just creates an <code>xhr</code> object, calls its <code>open</code> and <code>send</code> methods, sets its <code>onload</code> property, and returns. So, basically, nothing gets done, except that the request is fired off.</p>
			<p>A promise thus created will be in the pending state. And the promise stays in this state until one of the <code>resolve</code> or <code>reject</code> functions is called inside the body. If the <code>reject</code> function is called, it will transition to a rejected state, and we'll be able to use the <code>catch</code> method of the <code>Promise</code> object to handle the error, and if the <code>resolve</code> function is called, it will transition to the resolved state, and we'll be able to use the <code>then</code> method of the <code>Promise</code> object.</p>
			<p>One thing that we should note is that this method does nothing that is UI-related. It does not print any errors on the console or change any DOM elements. It simply promises us that it will get us an <code>OpenLibraryAuthor</code> object. Now, we're free to use this object however we want:</p>
			<pre>getShakespeareData()
  .then(author =&gt; {
    const body = document.getElementsByTagName("body")[0];
    
    const image = document.createElement("img");
    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;
    body.appendChild(image);
    const name = document.createElement("h1");
    name.innerHTML = author.personal_name;
    body.appendChild(name);
  })
  .catch(error =&gt; {
    console.log(`An error occured ${error.error}: ${error.message}`);
  })</pre>
			<p>In this piece of code, we call the <code>getShakespeareData</code> data function, and then on its result, we're calling two methods, <code>then</code> and <code>catch</code>. The <code>then</code> method only executes if the promise is in the resolved state and it takes in a function that will get the result. The <code>catch</code> method only executes if the promise is in the rejected state, and it will get the error as an argument to its function.</p>
			<p>One important note for the <code>then</code> and <code>catch</code> methods – they also return promises. This means that <code>Promise</code> objects are chainable, so instead of going in depth, as we did with callbacks, we can go in length, so to say. To illustrate that point, let's count to five once again.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A more comprehensive discussion of Promises will be presented in <em class="italic">Chapter 12, Guide to Promises in TypeScript</em>.</p>
			<h2 id="_idParaDest-212">Exer<a id="_idTextAnchor257"/>cise 10.04: Counting to Five with Promises</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last one was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/nlge8">https://packt.link/nlge8</a>.</p>
			<ol>
				<li value="1">Create a new file, <code>counting-2.ts</code>.</li>
				<li>In <code>counting-2.ts</code>, add an array with the English number names up to and including five:<pre>const numbers = ["One", "Two", "Three", "Four", "Five"];</pre></li>
				<li>Add a promisified wrapper of the <code>setTimeout</code> function. This wrapper will only execute when the given timeout expires:<pre>const delay = (ms: number) =&gt; {
    const result = new Promise&lt;void&gt;((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
        }, ms)
    });
    return result;
}</pre><p>Since our promise will not return any meaningful result, instead just resolving after a given amount of milliseconds, we have provided <code>void</code> as its type.</p></li>
				<li>Call the <code>delay</code> method with a parameter of <code>1000</code>, and after its resolution, print out the first number:<pre>delay(1000)
.then(() =&gt; console.log(numbers[0]))</pre></li>
				<li>Save the file, and compile it with the following command:<pre>tsc counting-2.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>counting-2.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node counting-2.js</pre><p>You will see the output looks like this:</p><pre>One</pre><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <code>counting-2.ts</code> file, after the <code>then</code> line, add another <code>then</code> line. Inside it, call the <code>delay</code> method again, with a timeout of 1 second:<pre>delay(1000)
.then(() =&gt; console.log(numbers[0]))
.then(() =&gt; delay(1000)) </pre><p>We can do this because the result of the <code>then</code> method is <code>Promise</code>, which has its own <code>then</code> method.</p></li>
				<li>After the last <code>then</code> line, add another <code>then</code> line, inside which you print out the second number:<pre>delay(1000)
.then(() =&gt; console.log(numbers[0]))
.then(() =&gt; delay(1000))
.then(() =&gt; console.log(numbers[1])) </pre></li>
				<li>Compile and run the code again, and verify that the output has an extra line, displayed 1 second after the first.</li>
				<li>In the <code>counting-2.ts</code> file, add two more <code>then</code> lines for the third, fourth, and fifth numbers as well. The code should look like this:<pre>delay(1000)
.then(() =&gt; console.log(numbers[0]))
.then(() =&gt; delay(1000))
.then(() =&gt; console.log(numbers[1]))
.then(() =&gt; delay(1000))
.then(() =&gt; console.log(numbers[2]))
.then(() =&gt; delay(1000))
.then(() =&gt; console.log(numbers[3]))
.then(() =&gt; delay(1000))
.then(() =&gt; console.log(numbers[4])) </pre></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order.<p>Let's compare this code with the code of the previous exercise. It's not the cleanest code, but its function is relatively obvious. We can see how we could expand this code to count to 20. And the major benefit here is that this code, while asynchronous, is still sequential. We can reason about it, and the lines that are at the top will execute before the lines at the bottom. Furthermore, since we have objects now, we can even refactor this code into an even simpler and more extensible format – we can use a <code>for</code> loop.</p></li>
				<li>In the <code>counting-2.ts</code> file, remove the lines starting with <code>delay(1000)</code> until the end of the file. Add a line that will define a resolved promise:<pre>let promise = Promise.resolve();</pre></li>
				<li>Add a <code>for</code> loop that, for each number of the <code>numbers</code> array, will add to the <code>promise</code> chain a delay of 1 second, and print the number:<pre>for (const number of numbers) {
    promise = promise
        .then(() =&gt; delay(1000))
        .then(() =&gt; console.log(number))
};}</pre></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order as shown:<pre>One
Two
Three
Four
Five</pre></li>
			</ol>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor258"/>Acti<a id="_idTextAnchor259"/>vity 10.02: Movie Browser Using fetch and Promises</h2>
			<p>In this activity, we will be repeating the previous activity. The major difference is that, instead of using <code>XMLHttpRequest</code> and its <code>onload</code> method, we'll be using the <code>fetch</code> web API. In contrast to the <code>XMLHttpRequest</code> class, the <code>fetch</code> web API returns a <code>Promise</code> object, so instead of nesting our callbacks to have multiple API calls, we can have a chain of promise resolutions that will be far easier to understand.</p>
			<p>The activity has the same files and resources as the previous activity.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Above the <code>search</code> function, create a helper function called <code>getJsonData</code>. This function will use the <code>fetch</code> API to get data from an endpoint and format it as JSON. It should take a single string called <code>url</code> as a parameter, and it should return a <code>Promise</code>.</li>
				<li>In the body of the <code>getJsonData</code> function, add code that calls the <code>fetch</code> function with the <code>url</code> parameter, and <code>then</code> call the <code>json</code> method on the returned response.</li>
				<li>In the <code>search</code> method, construct a new string for the search result URL using the <code>getSearchUrl</code> method.</li>
				<li>Call the <code>getJsonData</code> function with the <code>searchUrl</code> as a parameter.</li>
				<li>Add a <code>then</code> handler to the promise returned from <code>getJsonData</code>. The handler takes a single parameter of the type <code>SearchResultApi</code>.</li>
				<li>In the body of the handler, check whether we have any results and if we don't, throw an error. If we do have results, return the first item. Note that the handler returns an object with <code>id</code> and <code>title</code> properties, but the <code>then</code> method actually returns a <code>Promise</code> of that data. This means that after the handler, we can chain other <code>then</code> calls.</li>
				<li>Add another <code>then</code> call to the previous handler. This handler will take a <code>movieResult</code> parameter that contains the <code>id</code> and <code>title</code> of the movie. Use the <code>id</code> property to call the <code>getMovieUrl</code> and <code>getPeopleUrl</code> methods to, respectively, get the correct URLs for the movie details and for the cast and crew.</li>
				<li>After getting the URLs, call the <code>getJsonData</code> function with both, and assign the resulting values to variables. Note that the <code>getJsonData(movieUrl)</code> call will return a <code>Promise</code> of <code>MovieResultApi</code>, and <code>getJsonData(peopleUrl)</code> will return a <code>Promise</code> of <code>PeopleResultApi</code>. Assign those result values to variables called <code>dataPromise</code> and <code>peoplePromise</code>.</li>
				<li>Call the static <code>Promise.all</code> method with <code>dataPromise</code> and <code>peoplePromise</code> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a <code>Promise</code> of an array of results.</li>
				<li>Return the promise generated by the <code>Promise.all</code> call from the handler.</li>
				<li>Add another <code>then</code> handler to the chain. This handler will take the array returned from <code>Promise.all</code> as a single parameter.</li>
				<li>Deconstruct the parameter into two variables. The first element of the array should be the <code>movieData</code> variable of type <code>MovieResultApi</code>, and the second element of the array should be the <code>peopleData</code> variable of type <code>PeopleResultApi</code>.</li>
				<li>The people data has <code>cast</code> and <code>crew</code> properties. We'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into your own <code>Character</code> objects. We need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property.</li>
				<li>From the <code>crew</code> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses we've prepared so far.</li>
				<li>Return the <code>Movie</code> object from the handler.</li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <code>click</code> event handler of the <code>search</code> button. We should simply add a <code>then</code> handler to the <code>search</code> call that will call the <code>showResults</code> method, and a <code>catch</code> handler that will call the <code>clearResults</code> method.</li>
			</ol>
			<p>Although we used <code>fetch</code> and promises in this activity, and our code is now much more efficient but complex, the basic function of the website will be the same and you should see an output similar to the previous activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found at <a href="https://packt.link/IeDTF">https://packt.link/IeDTF</a>. The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor433">this link</a>.</p>
			<h2 id="_idParaDest-214">async<a id="_idTextAnchor260"/>/await</h2>
			<p>Promises solved the problem of callbacks quite nicely. However, often, they carry with them lots of unneeded fluff. We need to write lots of <code>then</code> calls, and we need to be careful not to forget to close any parentheses.</p>
			<p>The next step is to add a piece of syntactic sugar to our TypeScript skills. Unlike the other things in this chapter, this feature originated in TypeScript, and was later adopted in JavaScript as well. I'm talking about the <code>async</code>/<code>await</code> keywords. These are two separate keywords, but they are always used together, so the whole feature became known as <code>async</code>/<code>await</code>.</p>
			<p>What we do is we can add the <code>async</code> modifier to a certain function, and then, in that function, we can use the <code>await</code> modifier to execute promises easily. Let's go once more to our Shakespearean example, and let's wrap the code we used to call <code>getShakespeareData</code> inside another function, simply called <code>run</code>:</p>
			<pre>function run() {
    getShakespeareData()
    .then(author =&gt; {
        const body = document.getElementsByTagName("body")[0];
        
        const image = document.createElement("img");
        image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;
        body.appendChild(image);
        const name = document.createElement("h1");
        name.innerHTML = author.personal_name;
        body.appendChild(name);
    })
    .catch(error =&gt; {
        console.log(`An error occured ${error.error}: ${error.message}`);
    })
}
run();</pre>
			<p>This code is functionally equivalent to the code we had previously. But now, we have a function that we can mark as an <code>async</code> function, like this:</p>
			<pre>async function run() {</pre>
			<p>Now, we're allowed to just get the result of a promise and put it inside of a variable. So, the whole <code>then</code> invocation will become this:</p>
			<pre>    const author = await getShakespeareData();
    const body = document.getElementsByTagName("body")[0];
    
    const image = document.createElement("img");
    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;
    body.appendChild(image);
    
    const name = document.createElement("h1");
    name.innerHTML = author.personal_name;
    body.appendChild(name);</pre>
			<p>You can see that we don't have any wrapping function calls anymore. The <code>catch</code> invocation can be replaced with a simple <code>try</code>/<code>catch</code> construct, and the final version of the <code>run</code> function will look like this:</p>
			<pre>async function run () {
  try {
    const author = await getShakespeareData();
    const body = document.getElementsByTagName("body")[0];
    
    const image = document.createElement("img");
    image.src = `http://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;
    body.appendChild(image);
    
    const name = document.createElement("h1");
    name.innerHTML = author.personal_name;
    body.appendChild(name);
  } catch (error) {
    console.log(`An error occured ${error.error}: ${error.message}`);
  }
}</pre>
			<p>You will notice that the amount of code that is deeply nested is drastically reduced. Now we can look at the code, and have a good idea of what it does, just from a quick glance. This is still the same, deeply asynchronous code, the only difference is that it looks almost synchronous and definitely sequential.</p>
			<h2 id="_idParaDest-215">Exerc<a id="_idTextAnchor261"/>ise 10.05: Counting to Five with async and await</h2>
			<p>In this exercise, we'll create a function that, when executed, will output the English words one through five. Each word will appear on the screen 1 second after the last one was displayed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/TaH6b">https://packt.link/TaH6b</a>.</p>
			<ol>
				<li value="1">Create a new file, <code>counting-3.ts</code>.</li>
				<li>In <code>counting-3.ts</code>, add an array with the English number names up to and including five:<pre>const numbers = ["One", "Two", "Three", "Four", "Five"];</pre></li>
				<li>Add a promisified wrapper of the <code>setTimeout</code> function. This wrapper will only execute when the given timeout expires:<pre>const delay = (ms: number) =&gt; {
    const result = new Promise&lt;void&gt;((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
        }, ms)
    });
    return result;
}</pre><p>Since our promise will not return any meaningful results, instead of just resolving after a given number of milliseconds, we have provided <code>void</code> as its type.</p></li>
				<li>Create an empty <code>async</code> function called <code>countNumbers</code> and execute it on the last line of the file:<pre>async function countNumbers() {
}
countNumbers();</pre></li>
				<li>Inside the <code>countNumbers</code> function, await the <code>delay</code> method with a parameter of <code>1000</code>, and after its resolution, print out the first number:<pre>async function countNumbers() {
    await delay(1000);
    console.log(numbers[0]);
}</pre></li>
				<li>Save the file, and compile it with the following command:<pre>tsc counting-3.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>counting-3.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with this command:<pre>node counting-3.js</pre><p>You will see the output looks like this:</p><pre>One</pre><p>The line should appear 1 second after the application was run.</p></li>
				<li>In the <code>counting-3.ts</code> file, after the <code>console.log</code> line, add two more lines for the rest of the numbers as well. The code should look like this:<pre>async function countNumbers() {
    await delay(1000);
    console.log(numbers[0]);
    await delay(1000);
    console.log(numbers[1]);
    await delay(1000);
    console.log(numbers[2]);
    await delay(1000);
    console.log(numbers[3]);
    await delay(1000);
    console.log(numbers[4]);
}</pre></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order.<p>Since the code is completely identical for all the numbers, it's trivial to replace it with a <code>for</code> loop.</p></li>
				<li>In the <code>counting-3.ts</code> file, remove the body of the <code>countNumbers</code> function, and replace it with a <code>for</code> loop that, for each number of the <code>numbers</code> array, will <code>await</code> a delay of a second, and then print the number:<pre>for (const number of numbers) {
    await delay(1000);
    console.log(number);
};</pre></li>
				<li>Compile and run the code again, and verify that the output appears in the correct order:<pre>One
Two
Three
Four
Five</pre></li>
			</ol>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor262"/>Activ<a id="_idTextAnchor263"/><a id="_idTextAnchor264"/>ity 10.03: Movie Browser Using fetch and async/await</h2>
			<p>In this activity, we will be improving on the previous activity. The major difference is that instead of using the <code>then</code> method of the <code>Promises</code> class, we'll use the <code>await</code> keyword to do that for us magically. Instead of a chain of <code>then</code> calls, we'll just have code that looks completely regular, with some <code>await</code> statements peppered throughout.</p>
			<p>The activity has the same files and resources as the previous activity.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty. Note that this function is now marked with the <code>async</code> keywords, which allows us to use the <code>await</code> operator.</li>
				<li>Above the <code>search</code> function, create a helper function called <code>getJsonData</code>. This function will use the <code>fetch</code> API to get data from an endpoint and format it as JSON. It should take a single string called <code>url</code> as a parameter, and it should return a promise.</li>
				<li>In the body of the <code>getJsonData</code> function, add code that calls the <code>fetch</code> function with the <code>url</code> parameter, and <code>then</code> call the <code>json</code> method on the returned response.</li>
				<li>In the <code>search</code> method, construct a new string for the search result URL using the <code>getSearchUrl</code> method.</li>
				<li>Call the <code>getJsonData</code> function with <code>searchUrl</code> as a parameter, and <code>await</code> the result. Place the result into the <code>SearchResultApi</code> variable.</li>
				<li>Check whether we have any results and if we don't, throw an error. If we do have results, set the first item of the <code>result</code> property into a variable called <code>movieResult</code>. This object will contain the <code>id</code> and <code>title</code> properties of the movie.</li>
				<li>Use the <code>id</code> property to call the <code>getMovieUrl</code> and <code>getPeopleUrl</code> methods to, respectively, get the correct URLs for the movie details and for the cast and crew.</li>
				<li>After getting the URLs, call the <code>getJsonData</code> function with both, and assign the resulting values to variables. Note that the <code>getJsonData(movieUrl)</code> call will return a promise of <code>MovieResultApi</code>, and <code>getJsonData(peopleUrl)</code> will return a promise of <code>PeopleResultApi</code>. Assign those result values to variables called <code>dataPromise</code> and <code>peoplePromise</code>.</li>
				<li>Call the static <code>Promise.all</code> method with <code>dataPromise</code> and <code>peoplePromise</code> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results. <code>await</code> this promise, and place its result into a variable of type <code>array</code>.</li>
				<li>Deconstruct that array into two variables. The first element of the array should be the <code>movieData</code> variable of type <code>MovieResultApi</code>, and the second element of the array should be the <code>peopleData</code> variable of type <code>PeopleResultApi</code>.</li>
				<li>The people data has <code>cast</code> and <code>crew</code> properties. We'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array.</li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into our own <code>Character</code> objects. We need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property.</li>
				<li>From the <code>crew</code> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between.</li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses we've prepared so far.</li>
				<li>Return the <code>Movie</code> object from the function.</li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <code>click</code> event handler of the <code>search</code> button. We should simply add a <code>then</code> handler to the <code>search</code> call that will call the <code>showResults</code> method, and a <code>catch</code> handler that will call the <code>clearResults</code> method. <p>Although we used <code>fetch</code> and <code>async</code>/<code>await</code> in this activity, and our code is now just as efficient but less complex compared with the previous activity, the basic function of the website will be the same and you should see an output similar to the previous activity.</p><p class="callout-heading">Note</p><p class="callout">The code files for this activity can be found at <a href="https://packt.link/fExtR">https://packt.link/fExtR</a>. The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor435">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-217">Summar<a id="_idTextAnchor265"/>y</h1>
			<p>In this chapter, we looked at the execution model that is used on the web, and how we can use it to actually execute code. We glanced at the surface of the intricacies of asynchronous development – and how we can use it to load data from external resources. We showed the problems that arise when we get too deep into the hole of callbacks and managed to exit it using promises. Finally, we were able to await our asynchronous code, and have the best of both words – code that looks like it's synchronous, but that executes asynchronously.</p>
			<p>We also tested the skills developed in the chapter by creating a movie data viewer browser, first using XHR and callbacks, and then improved it progressively using <code>fetch</code> and promises, and then using <code>fetch</code> and <code>async</code>/<code>await</code>.</p>
			<p>The next chapter will teach you about higher-order functions and callbacks.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>