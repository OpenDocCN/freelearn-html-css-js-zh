["```js\nlocalStorage.setItem('myKey', 'myValue');\nlocalStorage.setItem('name', 'John Doe');\n```", "```js\nlocalStorage.getItem('myKey'); // myValue\nlocalStorage.getItem('name'); // John Doe\nlocalStorage.getItem('notExists'); // null\n```", "```js\nlocalStorage.removeItem('name');\nlocalStorage.getItem('name'); // null\n```", "```js\nvarmyObj = {name: 'John Doe', age: 26};\nlocalStorage.setItem('object', myObj);\nlocalStorage.getItem('object'); // [Object object]\n```", "```js\nvarmyObj = {name: 'John Doe', age: 26};\nvar serialized = JSON.stringify(myObj);\n\nlocalStorage.setItem('object', serialized);\n```", "```js\nvar data = localStorage.getItem('object');\nvarobj = JSON.parse(data);\n```", "```js\nvar data = localStorage.get('contacts'); // index name\nvaravailableIds = data.split(',');\nvarcontactList = [];\n\n// Get all contacts\nfor (leti = 0; i<availableIds.length; i++) {\nlet id = availableIds[i];\nlet contact = JSON.parse(localStorage.getItem(id));\ncontactList.push(contact);\n}\n```", "```js\nvar data = localStorage.get('contacts'); // 1, 5, 6\nvaravailableIds = data.split(',');\nvarcontactList = [];\n\n// Get all contacts\nfor (let i = 0; i<availableIds.length; i++) {\nlet id = 'contacts-' + availableIds[i];\nlet contact = JSON.parse(localStorage.getItem(id));\ncontactList.push(contact);\n}\n```", "```js\nclass DataStore {\n  constructor(name) {\n    this.name = name;\n\n    // Keep track of all ids stored for a particular collection\nthis.index = this.getIndex();\n  }\n\ngetIndex() {\nvar index = localStorage.getItem(this.name);\n    return (index &&index.split(',')) || [];\n  }\n}\n```", "```js\nclass DataStore {\n// ...\n\n  create(model) {\n    // Assign an id to new models\n    if (!model.id&& model.id !== 0) {\n      model.id = generateId();\nmodel.set(model.idAttribute, model.id);\n    }\n\n    // Save model in the store with an unique name,\n    // e.g. collectionName-modelId\nlocalStorage.setItem(\nthis.itemName(model.id), this.serialize(model)\n    );\n\n    // Keep track of stored id\nthis.index.push(model.get(model.idAttribute));\nthis.updateIndex();\n\n    // Return stored model\n    return this.find(model);\n  }\n}\n```", "```js\nvar crispy = require('crispy-string');\n\nconst ID_LENGTH = 10;\n\nfunction generateId() {\n return crispy.base32String(ID_LENGTH);\n}\n\n```", "```js\nclass DataStore {\n// ...\n\n  update(model) {\n    // Overwrite the data stored in the store,\n    // actually makes the update\nlocalStorage.setItem(\nthis.itemName(model.id), this.serialize(model)\n    );\n\n    // Keep track of the model id in the collection\nvarmodelId = model.id.toString();\n    if (_.indexOf((this.index, modelId)) >= 0) {\nthis.index.push(modelId);\nthis.updateIndex();\n    }\n\n    // Return stored model\n    return this.find(model);\n  }\n}\n```", "```js\nclass DataStore {\n// ...\n\n  find(model) {\n    return this.deserialize(\nlocalStorage.getItem(this.itemName(model.id))\n    );\n  }\n}\n```", "```js\nclass DataStore {\n// ...\n\nfindAll() {\nvar result = [];\n\n    // Get all items with the id tracked for the given collection\n    for (let i = 0, id, data; i<this.index.length; i++) {\n      id = this.index[i];\n      data = this.deserialize(localStorage.getItem(\nthis.itemName(id)\n      ));\n\n      if (data) {\nresult.push(data);\n      }\n    }\n\n    return result;\n  }\n}\n```", "```js\nclass DataStore {\n// ...\n\n  destroy(model) {\n    // Remove item from the store\nlocalStorage.removeItem(this.itemName(model.id));\n\n    // Rmoeve id from tracked ids\nvarmodelId = model.id.toString();\n    for (let i = 0; i<this.index.length; i++) {\n      if (this.index[i] === modelId) {\nthis.index.splice(i, 1);\n      }\n    }\nthis.updateIndex();\n\n    return model;\n  }\n}\n```", "```js\nclass DataStore {\n// ...\n\n  // Save the ids comma separated for a given collection\nupdateIndex() {\nlocalStorage.setItem(this.name, this.index.join(','));\n  }\n}\n```", "```js\nclass DataStore {\n// ...\nitemName(id) {\n    return this.name + '-' + id;\n  }\n}\n```", "```js\n// read operation will issue a GET /contacts/1\nvarjohn= new Contact({id: 1});\njohn.fetch();\n\n// update operation will issue a PUT /contacts/1\njohn.set('name', 'Johnson');\njohn.save();\n\n// delete operation will issue a DELETE /contacts/1\njohn.destroy();\nvarjane = new Contact({name: 'Jane'});\n// create operation will issue a POST /contacts\njane.save();\n```", "```js\nsync(method, model, [options])\n```", "```js\nBackbone.sync = function(method, model, options) {\nvar response;\nvar store = model.dataStore ||\n (model.collection&&model.collection.dataStore);\nvar defer = Backbone.$.Deferred();\n\n if (store) {\n // Use localstorage in the model to execute the query\n switch(method) {\n case 'read':\n response = model.id ?store.find(model) : store.findAll();\n break;\n\n case 'create':\n response = store.create(model);\n break;\n\n case 'update':\n response = store.update(model);\n break;\n\n case 'delete':\n response = store.destroy(model);\n break;\n }\n }\n\n // Respond as promise and as options callbacks\n if (response) {\ndefer.resolve(response);\n if (options &&options.success) {\noptions.success(response);\n }\n } else {\ndefer.reject('Not found');\n if (options &&options.error) {\noptions.error(response);\n }\n }\n\n return defer.promise();\n};\n\n```", "```js\n// apps/contacts/models/contact.js\nclass Contact extends Backbone.Model {\n  constructor(options) {\n    super(options);\n\nthis.validation = {\n      name: {\n        required: true,\nminLength: 3\n      }\n    };\n\nthis.dataStore = new DataStore('contacts');\n  }\n  // ...\n}\n\n// apps/contacts/collections/contactCollection.js\nclass ContactCollection extends Backbone.Collection {\n  constructor(options) {\n    super(options);\nthis.dataStore = new DataStore('contacts');\n  }\n\n// ...\n}\n```", "```js\n// cachedSync.js\nvar _ = require('underscore');\nvar Backbone = require('backbone');\n\nfunction getStore(model) {\n  return model.dataStore;\n}\n\nmodule.exports =  _.wrap(Backbone.sync, (sync, method, model, options) => {\nvar store = getStore(model);\n\n  // Try to read from cache store\n  if (method === 'read') {\n    let cachedModel = getCachedModel(model);\n\n    if (cachedModel) {\n      let defer = Backbone.$.Deferred();\ndefer.resolve(cachedModel);\n\n      if (options &&options.success) {\noptions.success(cachedModel);\n      }\n\n      return defer.promise();\n    }\n  }\n\n  return sync(method, model, options).then((data) => {\n    // When getting a collection data is an array, if is a\n    // model is a single object. Ensure that data is always\n    // an array\n    if (!_.isArray(data)) {\n      data = [data];\n    }\n\ndata.forEach(item => {\n      let model = new Backbone.Model(item);\ncacheResponse(method, store, model);\n    });\n  });\n});\n```", "```js\n// cachedSync\nfunction cacheResponse(method, store, model) {\n  if (method !== 'delete') {\nupdateCache(store, model);\n  } else {\ndropCache(store, model);\n  }\n}\n```", "```js\nfunction dropCache(store, model) {\n  // Ignore if cache is not supported for the model\n  if (store) {\nstore.destroy(model);\n  }\n}\n```", "```js\n// cachedSync.js\n// ...\n\nconst SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\nconst TTL = 15 * MINUTES;\n\nfunction cacheExpire(data) {\n  if (data &&data.fetchedAt) {\n    let now = new Date();\n    let fetchedAt = new Date(data.fetchedAt);\n    let difference = now.getTime() - fetchedAt.getTime();\n\n    return difference > TTL;\n  }\n\n  return false;\n}\n\nfunction getCachedModel(model) {\nvar store = getStore(model);\n\n  // If model does not support localStorage cache or is a\n  // collection\n  if (!store&& !model.id) {\n    return null;\n  }\n\nvar data = store.find(model);\n\n  if (cacheExpire(data)) {\ndropCache(store, model);\n    data = null;\n  }\n\n  return data;\n}\n```", "```js\n// cachedSync.js\nfunction updateCache(store, model) {\n  // Ignore if cache is not supported for the model\n  if (store) {\nvarcachedModel = store.find(model);\n\n    // Use fetchedAt attribute mdoel is already cached\n    if (cachedModel&&cachedModel.fetchedAt) {\nmodel.set('fetchedAt', cachedModel.fetchedAt);\n    } else {\nmodel.set('fetchedAt', new Date());\n    }\n\nstore.update(model);\n  }\n}\n```", "```js\n// app.js\nvarcachedSync = require('./cachedSync');\n\n// ...\n\nBackbone.sync = cachedSync;\n```", "```js\nindexedDB.open(<database name>, <version number>)\n```", "```js\nvar request = indexedDB.open(\"library\");\n\n// In this callback the database is in the versionchange state\nrequest.onupgradeneeded = function() {\n  // The database did not previously exist, so that\n  // we can create object stores and indexes.\nvardb = request.result;\nvar store = db.createObjectStore(\"books\", {keyPath: \"isbn\"});\n\n  // Populate with initial data.\nstore.put({\ntitle: \"Quarry Memories\",\n author: \"Fred\",\nisbn: 123456});\nstore.put({\ntitle: \"Water Buffaloes\",\n author: \"Fred\",\nisbn: 234567});\nstore.put({\ntitle: \"Bedrock Nights\",\n author: \"Barney\",\nisbn: 345678});\n};\n\nrequest.onsuccess = function() {\nwindow.db = request.result;\n};\n```", "```js\ncreateObjectStore(name, options)\n```", "```js\nindexedDB.deleteDatabase('library');\n```", "```js\nvartx = db.transaction(\"books\", \"readwrite\");\nvar store = tx.objectStore(\"books\");\n\nstore.put({\n  title: \"Quarry Memories\",\n  author: \"Fred\",\nisbn: 123456\n});\nstore.put({\n  title: \"Water Buffaloes\",\n  author: \"Fred\",\nisbn: 234567\n});\nstore.put({\n  title: \"Bedrock Nights\",\n  author: \"Barney\",\nisbn: 345678\n});\n\ntx.oncomplete = function() {\nconsole.log('Records added!');\n};\n```", "```js\nvartx = db.transaction(\"books\", \"readonly\");\nvar store = tx.objectStore(\"books\");\n\nvar request = store.openCursor(IDBKeyRange.only(123456));\nrequest.onsuccess = function() {\nvar cursor = request.result;\n  if (cursor) {\n    // Called for each matching record.\nconsole.log(cursor.value);\ncursor.continue();\n} else {\n    // No more matching records, cursor === null\nconsole.log('Done!');\n  }\n};\n```", "```js\nvar request = indexedDB.open(\"library\", 2);\n\nrequest.onupgradeneeded = function() {\nvardb = request.result;\nvar store = db.createObjectStore(\"books\", {keyPath: \"isbn\"});\nvartitleIndex = store.createIndex(\"by_title\", \"title\", {\n    unique: true\n  });\nvarauthorIndex = store.createIndex(\"by_author\", \"author\");\n\n  // ...\n};\n\nrequest.onsuccess = function() {\ndb = request.result;\n\nvartx = db.transaction(\"books\", \"readonly\");\nvar store = tx.objectStore(\"books\");\nvar index = store.index(\"by_title\");\n\nvar request = index.get(\"Bedrock Nights\");\nrequest.onsuccess = function() {\n    // ...\n  };\n};\n```", "```js\nvartx = db.transaction(\"books\", \"readwrite\");\nvar store = tx.objectStore(\"books\");\n\nstore.delete(123456); // deletes book with isbn == 123456\nstore.delete(IDBKeyRange.lowerBound(456789)); // deletes books with store <= 456789\n```", "```js\n// indexedDB/dataStore.js\n'use strict';\n\nvar Backbone = require('backbone');\n\nconst ID_LENGTH = 10;\n\nvar contacts = [\n  // ...\n];\n\nclass DataStore {\nconstructor() {\nthis.databaseName = 'contacts';\n  }\n\nopenDatabase() {\nvar defer = Backbone.$.Deferred();\n\n    // If a database connection is already active use it,\n    // otherwise open a new connection\n    if (this.db) {\ndefer.resolve(this.db);\n    } else {\n      let request = indexedDB.open(this.databaseName, 1);\n\nrequest.onupgradeneeded = () => {\n        let db = request.result;\nthis.createStores(db);\n      };\n\nrequest.onsuccess = () => {\n        // Cache recently opened connection\nthis.db = request.result;\ndefer.resolve(this.db);\n      };\n    }\n\n    return defer.promise();\n  }\n\ncreateStores(db) {\nvar store = db.createObjectStore('contacts', {keyPath: 'id'});\n\n    // Create the first records\ncontacts.forEach(contact => {\nstore.put(contact);\n    });\n  }\n}\n```", "```js\n// indexedDB/dataStore.js\n\nvar crispy = require('crispy-string');\n\n// ...\n\nclass DataStore {\n  create(model) {\nvar defer = Backbone.$.Deferred();\n\n    // Assign an id to new models\n    if (!model.id&& model.id !== 0) {\n      let id = this.generateId();\nmodel.set(model.idAttribute, id);\n    }\n\n    // Get the database connection\nthis.openDatabase()\n.then(db =>this.store(db, model))\n.then(result =>defer.resolve(result));\n\n    return defer.promise();\n  }\n\ngenerateId() {\n    return crispy.base32String(ID_LENGTH);\n  }\n  // ...\n}\n```", "```js\n// indexedDB/dataStore.js\n\nvar crispy = require('crispy-string');\n\n// ...\n\nclass DataStore {\n  // ...\n\nstore(db, model) {\nvar defer = Backbone.$.Deferred();\n\n    // Get the name of the object store\nvarstoreName = model.store;\n\n    // Get the object store handler\nvartx = db.transaction(storeName, 'readwrite');\nvar store = tx.objectStore(storeName);\n\n    // Save the model in the store\nvarobj = model.toJSON();\nstore.put(obj);\n\ntx.oncomplete = function() {\ndefer.resolve(obj);\n    };\n\ntx.onerror = function() {\ndefer.reject(obj);\n    };\n\n    return defer.promise();\n  }\n\n  // ...\n}\n```", "```js\n// indexedDB/dataStore.js\nclass DataStore {\n  // ...\n\n  update(model) {\nvar defer = Backbone.$.Deferred();\n\n    // Get the database connection\nthis.openDatabase()\n.then(db =>this.store(db, model))\n.then(result =>defer.resolve(result));\n\n    return defer.promise();\n  }\n\n  // ...\n}\n```", "```js\n// indexedDB/dataStore.js\nclass DataStore {\n  // ...\n\ndestroy(model) {\nvar defer = Backbone.$.Deferred();\n\n    // Get the database connection\nthis.openDatabase().then(function(db) {\n      // Get the name of the object store\n      let storeName = model.store;\n\n      // Get the store handler\nvartx = db.transaction(storeName, 'readwrite');\nvar store = tx.objectStore(storeName);\n\n      // Delete object from the database\n      let obj = model.toJSON();\nstore.delete(model.id);\n\ntx.oncomplete = function() {\ndefer.resolve(obj);\n      };\n\ntx.onerror = function() {\ndefer.reject(obj);\n      };\n    });\n\n    return defer.promise();\n  }\n\n  // ...\n}\n```", "```js\n// indexedDB/dataStore.js\nclass DataStore {\n  // ...\n\nfindAll(model) {\nvar defer = Backbone.$.Deferred();\n\n    // Get the database connection\nthis.openDatabase().then(db => {\n      let result = [];\n\n      // Get the name of the object store\n      let storeName = model.store;\n\n      // Get the store handler\n      let tx = db.transaction(storeName, 'readonly');\n      let store = tx.objectStore(storeName);\n\n      // Open the query cursor\n      let request = store.openCursor();\n\n      // onsuccesscallback will be called for each record\n      // found for the query\nrequest.onsuccess = function() {\n        let cursor = request.result;\n\n        // Cursor will be null at the end of the cursor\n        if (cursor) {\nresult.push(cursor.value);\n\n          // Go to the next record\ncursor.continue();\n        } else {\ndefer.resolve(result);\n        }\n      };\n    });\n\n    return defer.promise();\n  }\n\n  // ...\n}\n```", "```js\n// indexedDB/dataStore.js\nclass DataStore {\n  // ...\n\n  find(model) {\nvar defer = Backbone.$.Deferred();\n\n    // Get the database connection\nthis.openDatabase().then(db => {\n      // Get the name of the collection/store\n      let storeName = model.store;\n\n      // Get the store handler\n      let tx = db.transaction(storeName, 'readonly');\n      let store = tx.objectStore(storeName);\n\n      // Open the query cursor\n      let request = store.openCursor(IDBKeyRange.only(model.id));\n\nrequest.onsuccess = function() {\n        let cursor = request.result;\n\n        // Cursor will be null if record was not found\n        if (cursor) {\ndefer.resolve(cursor.value);\n        } else {\ndefer.reject();\n        }\n      };\n    });\n\n    return defer.promise();\n  }\n\n  // ...\n}\n```", "```js\n// app.js\nvar store = new DataStore();\n\n// ...\n\nBackbone.sync = function(method, model, options) {\nvar response;\nvar defer = Backbone.$.Deferred();\n\n  switch(method) {\n    case 'read':\n      if (model.id) {\n        response = store.find(model);\n      } else {\n        response = store.findAll(model);\n      }\n      break;\n\n    case 'create':\n      response = store.create(model);\n      break;\n\n    case 'update':\n      response = store.update(model);\n      break;\n\n    case 'delete':\n      response = store.destroy(model);\n      break;\n  }\n\nresponse.then(function(result) {\n    if (options &&options.success) {\noptions.success(result);\ndefer.resolve(result);\n    }\n  });\n\n  return defer.promise();\n};\n```", "```js\nclass Contact extends Backbone.Model {\n  constructor(options) {\n// ,,,\nthis.store = 'contacts';\n  }\n\n  // ...\n}\n\nclass ContactCollection extends Backbone.Collection {\n  constructor(options) {\n// ...\nthis.store = 'contacts';\n  }\n\n// ...\n}\n```", "```js\nclass ContactPreview extends ModelView {\n  // ...\n\nfileSelected(event) {\nevent.preventDefault();\n\nvar $img = this.$('img');\n\n    // Get a blob instance of the file selected\nvar $fileInput = this.$('#avatar')[0];\nvarfileBlob = $fileInput.files[0];\n\n    // Render the image selected in the img tag\nvarfileReader = new FileReader();\nfileReader.onload = event => {\n      $img.attr('src', event.target.result);\n\nthis.model.set({\n        avatar: {\nurl: event.target.result\n        }\n      });\n    };\nfileReader.readAsDataURL(fileBlob);\n\nthis.trigger('avatar:selected', fileBlob);\n  }\n}\n```", "```js\nclass ContactEditor {\n// ...\n\nshowEditor(contact) {\n    // ...\n\n    // When avatar is selected, we can save it inmediatly if the\n    // contact already exists on the server, otherwise just\n    // remember the file selected\n    //this.listenTo(contactPreview, 'avatar:selected', blob => {\n    //  this.avatarSelected = blob;\n\n    //  if (!contact.isNew()) {\n    //    this.uploadAvatar(contact);\n    //  }\n    //});\n  }\nsaveContact(contact) {\n// ...\n\n    // The avatar attribute is read-only\n    //if (contact.has('avatar')) {\n    //  contact.unset('avatar');\n    //}\n\n// ...\n  }\n\n  // ...\n}\n```"]