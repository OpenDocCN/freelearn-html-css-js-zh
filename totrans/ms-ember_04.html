<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Writing Application Templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Writing Application Templates</h1></div></div></div><p class="calibre7">Now that we know how to manage the states in Ember.js applications using routes, this chapter will help us master how to present application logic to users using templates. You will soon realize that the bulk of your application resides in templates. This being said, the chapter will frequently revisit what we already learned so far. Therefore, by the end of this chapter, the following concepts will be learned:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating templates</li><li class="listitem">Writing binding template expressions and conditionals</li><li class="listitem">Changing contexts in templates</li><li class="listitem">Creating event listeners in templates</li><li class="listitem">Extending templates</li><li class="listitem">Writing custom template helpers</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Writing Application Templates">
<div class="book" title="Registering templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec38" class="calibre1"/>Registering templates</h1></div></div></div><p class="calibre7">As promised, we <a id="id117" class="calibre1"/>will continue to explore the chapter sample introduced in the previous chapter in the context of templates. When an application transitions into a state, each of the route handlers in that state path renders a template into the page. These templates are defined in the following signature:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" id="index"&gt;
 &lt;h1&gt;My Index Template&lt;/h1&gt;&lt;/script&gt;</pre></div><p class="calibre7">As shown, templates are registered using <span class="strong"><strong class="calibre8">script</strong></span> tags<a id="id118" class="calibre1"/> of the <code class="email">text/x-handlebars</code> type. The <code class="email">id</code> or <a id="id119" class="calibre1"/>
<code class="email">data-template-name</code> attribute is used to identify the template. For instance, the chapter sample <code class="email">contacts</code> template was defined as:</p><div class="informalexample"><pre class="programlisting">  &lt;script type="text/x-handlebars" data-template-name="contacts"&gt;
    ...
  &lt;/script&gt;</pre></div><p class="calibre7">One thing to note is that it's wiser to identify templates using the <code class="email">data-template-name</code> attribute instead of the <code class="email">id</code> attribute, as the former is more likely to collide with other existing elements. Also, notice <a id="id120" class="calibre1"/>that the first template was not <span class="strong"><em class="calibre9">identified</em></span>. This is because any unidentified template is considered as the <code class="email">application</code> template:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars"&gt;
  &lt;div class="container"&gt;
    {{outlet}}
  &lt;/div&gt;
&lt;/script&gt;</pre></div></div></div>
<div class="book" title="Inserting templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec39" class="calibre1"/>Inserting templates</h1></div></div></div><p class="calibre7">In the previous chapter, we<a id="id121" class="calibre1"/> discussed how a state in an application is composed of various routes whose handlers are sequentially called in order to perform various functions that make up this state. As a recap, when the user loaded the application in the chapter sample, the application transitioned into the <code class="email">application</code> state. The <code class="email">application</code> route handler then rendered its corresponding <code class="email">application</code> template into the DOM. The next route handler to be called was the <code class="email">contacts</code> route handler that also loaded and rendered its template into the <code class="email">application</code> template. We already discussed that the <code class="email">{{outlet}}</code> Handlebars expression was the portion of the <code class="email">application</code> template that got swapped out. This process repeated itself until the application settled on the destination state.</p><p class="calibre7">As we will discuss later, a <span class="strong"><em class="calibre9">parent</em></span> template can specify named outlets into which multiple <span class="strong"><em class="calibre9">child</em></span> templates can be rendered. Route (not resource) handlers need not include this expression because they usually render the final template.</p></div>
<div class="book" title="Writing out templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Writing out templates</h1></div></div></div><p class="calibre7">As discussed earlier, Ember.js <a id="id122" class="calibre1"/>templates are written in the Handlebars (<a class="calibre1" href="http://www.handlebarsjs.com">www.handlebarsjs.com</a>) syntax <a id="id123" class="calibre1"/>whose library was created by the same authors to simplify the creation of client-side templates. Handlebars is a powerful templating library that offers many features, which will be discussed in the upcoming sections.</p></div>
<div class="book" title="Expressing variables"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec41" class="calibre1"/>Expressing variables</h1></div></div></div><p class="calibre7">We just <a id="id124" class="calibre1"/>mentioned<a id="id125" class="calibre1"/> that templates are backed by data that is proxied by the corresponding controller. Handlebars walks down a template, replacing defined expressions with matching values obtained from this data. These expressions are usually variable names enclosed in curly braces. The <code class="email">{{outlet}}</code> expression<a id="id126" class="calibre1"/> we just discussed is one such expression. In the <a id="id127" class="calibre1"/>chapter sample, the <code class="email">contact.index</code> state is responsible for displaying a contact's detail on the right-hand side of the page. In its corresponding template, we notice that the contact's attributes are expressed using these expressions, but later get replaced, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" data-template-name="contact/index"&gt;
  {{#with controller.controllers.contact}}
  &lt;div class="row"&gt;
    &lt;div class="col-sm-4 text-right"&gt;name&lt;/div&gt;
    &lt;div class="col-sm-8"&gt;{{name}}&lt;/div&gt;
  &lt;/div&gt;
  &lt;br&gt;
  ...
&lt;/script&gt;</pre></div><p class="calibre7">In the preceding example, Handlebars finds the name expression, retrieves this variable from the <a id="id128" class="calibre1"/>provided model, and performs the swap. Handlebars always works in the provided controller context, which in turn proxies requests to its model. Therefore, the value used to swap the preceding expression is evaluated as:</p><div class="informalexample"><pre class="programlisting">model.name;</pre></div><p class="calibre7">This value can also be:</p><div class="informalexample"><pre class="programlisting">{{controller.model.name}}</pre></div><p class="calibre7">Whenever the <code class="email">name</code> variable reference request is made, Ember.js first checks if the controller defines the variable. Since this is not true, the controller <span class="strong"><em class="calibre9">proxies</em></span> this request to its model.</p></div>
<div class="book" title="Writing bound and unbound expressions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec42" class="calibre1"/>Writing bound and unbound expressions</h1></div></div></div><p class="calibre7">We just<a id="id129" class="calibre1"/> learned that an expression is resolved <a id="id130" class="calibre1"/>by referencing the specified variable from the binding context. Ember.js goes further and makes<a id="id131" class="calibre1"/> these <a id="id132" class="calibre1"/>expressions <span class="strong"><em class="calibre9">reactive</em></span>. This means that if the underlying variable changes, the replaced expression portion will also be updated. Sometimes, we might not want to suppress this behavior, especially when the variable is too large and constitutes unbound expressions. </p><p class="calibre7">These expressions only resolve once on render, and no further changes of the corresponding variable are subscribed. These expressions are written using three braces instead of two, as shown in the following example, where the main content of an Ember.js-powered blog post can be rendered:</p><div class="informalexample"><pre class="programlisting">{{{post}}}</pre></div></div>
<div class="book" title="Adding comments in templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec43" class="calibre1"/>Adding comments in templates</h1></div></div></div><p class="calibre7">Comments<a id="id133" class="calibre1"/> in <a id="id134" class="calibre1"/>Handlebars have the <code class="email">{{! … }}</code> signature. For example, we can add a documentation that signifies the end of a footer:</p><div class="informalexample"><pre class="programlisting">  &lt;/footer&gt; {{! end of footer}}</pre></div><p class="calibre7">These expressions serve the same purpose as normal HTML comments, other than the fact that they are not actually converted to the latter. Therefore, a good reason to use them is when we don't want comments to appear in the rendered output.</p></div>
<div class="book" title="Writing conditionals"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec44" class="calibre1"/>Writing conditionals</h1></div></div></div><p class="calibre7">Handlebars <a id="id135" class="calibre1"/>supports the <code class="email">if</code>, <code class="email">if...else</code>, <code class="email">unless</code>, and <code class="email">unless...else</code> conditionals. This means <a id="id136" class="calibre1"/>that <a id="id137" class="calibre1"/>we can <a id="id138" class="calibre1"/>render different portions of our <a id="id139" class="calibre1"/>templates based on specified conditions. They are block expressions that wrap template portions and usually begin and end with the <code class="email">{{#</code> and <code class="email">{{/</code> template tags, respectively. For example, if the user has no stored contacts in the <code class="email">contacts</code> template of the chapter sample, the application will transition into the <code class="email">contacts.new</code> state to force the user to add one. Therefore, we need to display a placeholder string in the now blank left-hand side of the page. We do this by checking whether the passed contact list is indeed empty, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">{{#if model.length}}
  ...
{{else}}
    &lt;h1&gt;Create contact&lt;/h1&gt;
{{/if}}</pre></div><p class="calibre7">The placeholder element is placed inside the <code class="email">else</code> block. As illustrated, the block expression is only met when the value passed evaluates to <code class="email">True</code>. Hence, the following values will result in the <code class="email">else</code> block being rendered instead:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">false</code></li><li class="listitem"><code class="email">undefined</code></li><li class="listitem"><code class="email">null</code></li><li class="listitem"><code class="email">[] (empty array)</code></li><li class="listitem"><code class="email">''</code></li><li class="listitem"><code class="email">0</code></li><li class="listitem"><code class="email">NaN</code></li></ul></div><p class="calibre7">The <code class="email">unless</code> expression, on <a id="id140" class="calibre1"/>the other hand, is only met when the variable evaluated is <code class="email">False</code>.</p><p class="calibre7">Note that Handlebars is <code class="email">logic-less</code>, hence we cannot express conditions using the bitwise operators, as in the following cases:</p><div class="informalexample"><pre class="programlisting">  {{#if user.score &gt; 1000 }}
     &lt;span&gt;Level passed.&lt;/span&gt;
   {{else}}
     &lt;span&gt;Level failed.&lt;/span&gt;
   {{/if}}
  
   {{#if (temp.high + temp.low)/2 &gt; 100   }}
     &lt;span&gt;It's hot today&lt;/span&gt;
   {{/if}}</pre></div><p class="calibre7">We can, however, define <a id="id141" class="calibre1"/>these conditions in the controller layer using computed properties or bindings. For example, the preceding samples can be implemented correctly as:</p><div class="informalexample"><pre class="programlisting">App.ApplicationController = Em.Controller.extend({
  levelPassed: function(){
     return this.get('user.score') &gt; 1000;
  }.property('user.score')
});

{{#if controller.levelPassed }}
  &lt;span&gt;Level passed.&lt;/span&gt;
{{else}}
  &lt;span&gt;Level failed.&lt;/span&gt;
{{/if}}



App.ApplicationController = Em.Controller.extend({
  isHot: function(){
    var temp = this.get('temp');
    return (temp.high + temp.low)/2 &gt; 100;
  }.property('temp.high', 'temp.high')
});

{{#if controller.isHot }}
  &lt;span&gt;It's hot today&lt;/span&gt;
{{/if}}</pre></div></div>
<div class="book" title="Switching contexts"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec45" class="calibre1"/>Switching contexts</h1></div></div></div><p class="calibre7">As <a id="id142" class="calibre1"/>previously <a id="id143" class="calibre1"/>discussed, Ember.js resolves expressions against the model context. The <code class="email">{{#with}}...{{/with}}</code> helper<a id="id144" class="calibre1"/> allows us to specify the context to prioritize during the check. A good case is illustrated in the chapter sample, where we need to reuse the form used to create or update contacts. This form is contained in the <code class="email">contacts/form</code> template. The only problem is that while the context of the <code class="email">contacts/new</code> template is a newly created contact object, the <code class="email">contact/edit</code> template<a id="id145" class="calibre1"/> has to reference the contact proxied by the contact controller. Thanks to the <code class="email">with</code> helper and controller dependencies, we are able to change the context of the latter template as:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" data-template- name="contact/edit"&gt;
  {{#with controller.controllers.contact}}
  {{partial "contacts/form"}}
  {{/with}}
&lt;/script&gt;</pre></div><p class="calibre7">We will revisit this case when discussing the <code class="email">partial</code> helper, but the important thing to note is that the main context is not the corresponding route handler model now, it is rather the <code class="email">contact</code> controller.</p><p class="calibre7">Just like the <code class="email">each</code> helper, we can create a new context without losing the existing one, as shown in the following examples:</p><div class="informalexample"><pre class="programlisting">  &lt;script
   type="text/x-handlebars"
  data-template-name="contact/edit"&gt;
    {{#with controller.controllers.contact as contact}}
    {{partial "contacts/form"}}
    {{/with}}
  &lt;/script&gt;

 &lt;script
   type="text/x-handlebars"
  data-template-name="contacts/new"&gt;
    {{#with model as contact}}
    {{partial "contacts/form"}}
    {{/with}}
  &lt;/script&gt;</pre></div><p class="calibre7">With the two cases, the <code class="email">email</code> field in the form, for example, will now need to bind to the contact context as:</p><div class="informalexample"><pre class="programlisting">{{input type="text" id="form-email" value=contact.email}}</pre></div></div>
<div class="book" title="Rendering enumerable data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec46" class="calibre1"/>Rendering enumerable data</h1></div></div></div><p class="calibre7">Often, applications<a id="id146" class="calibre1"/> will need to display enumerable data<a id="id147" class="calibre1"/> that can be accomplished using the <a id="id148" class="calibre1"/>
<code class="email">{{#each}} ... {{/each}}</code> block expression. For example, our <code class="email">contacts</code> template used this expression to display the list of contacts on the left as:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="nav nav-pills nav-stacked"&gt;
  {{#each model}}
  &lt;li&gt;
    ...{{name}}...
  &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">We left out the <code class="email">link-to</code> expression, which we'll discuss shortly. The <code class="email">each</code> block expression switches the working context on each iteration, as discussed in the previous section. If we don't wish to do so, we can specify the name of the current iteration object, as shown in the following reimplementation:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="nav nav-pills nav-stacked"&gt;
  {{#each contact in model}}
  &lt;li&gt;
    ...{{contact.name}}...
  &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">One good thing about this block expression is that we can check if the iterator is empty using the <code class="email">else</code> expression. For example, the use of the <code class="email">else</code> and <code class="email">if...else</code> expressions in our <code class="email">contacts</code> template can be reduced to the following:</p><div class="informalexample"><pre class="programlisting">  &lt;ul class="nav nav-pills nav-stacked"&gt;
    {{#each model}}
    &lt;li&gt;
      ...{{name}}...
    &lt;/li&gt;
    {{else}}
      &lt;h1&gt;Create contact&lt;/h1&gt;
    {{/each}}
  &lt;/ul&gt;</pre></div></div>
<div class="book" title="Writing template bindings"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec47" class="calibre1"/>Writing template bindings</h1></div></div></div><p class="calibre7">In the <span class="strong"><em class="calibre9">Writing bound and unbound expressions</em></span> section, we<a id="id149" class="calibre1"/> mentioned <a id="id150" class="calibre1"/>that the Ember.js Handlers library enables a variable defined in an expression to subscribe and, hence, updates to the changes of the bound context. The library also enables us to bind these variables to HTML element attributes, including classes using the <a id="id151" class="calibre1"/>
<code class="email">{{bind-attr .. }}</code> helper. In the following example, we define a link whose <code class="email">href</code> property is bound to the provided user profile as:</p><div class="informalexample"><pre class="programlisting">    &lt;a {{bind-attr href="profile.link"}}&gt;User Profile&lt;/a&gt;</pre></div><p class="calibre7">By now we all know <a id="id152" class="calibre1"/>how the profile context will be provided by the route handler's model hook. For example, if this is the application's template, the corresponding route handler will provide the context as:</p><div class="informalexample"><pre class="programlisting">  App.ApplicationRoute = Em.Route.extend({
    model: function(){
     return { profile: {
       link: '/@jondoe'
     }}
    }
  });</pre></div><p class="calibre7">The resulting <a id="id153" class="calibre1"/>rendered template will then resemble:</p><div class="informalexample"><pre class="programlisting">    &lt;a  HYPERLINK "mailto:href%3D'/@jondoe"href='/@jondoe'&gt;User Profile&lt;/a&gt;</pre></div><p class="calibre7">Every time the profile link changes, the link element's <code class="email">href</code> property will automatically be updated.</p><p class="calibre7">We might also wish to toggle states in attributes, for example, the commonly used <code class="email">required</code> and <code class="email">disabled</code> attributes. A common use case is when we want to allow single clicks in e-commerce applications, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;button {{bind-attr disabled='isCheckingOut'}}&gt;
  Checkout
&lt;/button&gt;</pre></div><p class="calibre7">In the preceding example, when the user clicks on the checkout button, the checkout action should toggle the <code class="email">isCheckedOut</code> property, which will result in the button being disabled. Therefore, attributes can be added or removed from DOM elements if the passed conditions become <code class="email">True</code> or <code class="email">False</code>, respectively.</p><p class="calibre7">Element class names can also be dynamically updated in the same way, with a little difference in the binding behavior. For example, we might wish to add an <code class="email">active</code> property to a clicked link in an application, as shown:</p><div class="informalexample"><pre class="programlisting">    &lt;a href='/'  {{bind-attr class='selected'}}&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">When the context's <code class="email">selected</code> property evaluates to <code class="email">active</code>, the link will be updated to:</p><div class="informalexample"><pre class="programlisting">  &lt;a href='/' class='active'&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">On the other hand, if the property becomes undefined, the link changes to:</p><div class="informalexample"><pre class="programlisting">  &lt;a href='/'&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">Just like an <a id="id154" class="calibre1"/>attribute's presence can be updated dynamically, class names can also be inserted and removed from elements, depending on specified bound conditions. Hence, the preceding example can be reimplemented as:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/ {{bind-attr class='selected:active:inactive'}}&gt; Click me
&lt;/a&gt;</pre></div><p class="calibre7">Here, the<a id="id155" class="calibre1"/> element's class will be <code class="email">active</code> and <code class="email">inactive</code> when the context's <code class="email">selected</code> property becomes <code class="email">True</code> and <code class="email">False</code>, respectively.</p><p class="calibre7">If only one argument is passed after the semicolon, the passed argument will be used as the class name instead. For example, the following code demonstrates this:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/' {{bind-attr class='isSelected:selected'}}&gt; Click me
&lt;/a&gt;</pre></div><p class="calibre7">This yields the following if the context's <code class="email">isSelected</code> property becomes <code class="email">True</code>:</p><div class="informalexample"><pre class="programlisting">     &lt;a href='/' class='selected'&gt;Click me&lt;/a&gt; </pre></div><p class="calibre7">It's also worth noting that <code class="email">camelCase</code> class names get <span class="strong"><em class="calibre9">dasherized</em></span>, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/' {{bind-attr class='isSelected'}}&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">This becomes the following:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/' class='is-selected'&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">Unlike other attributes, we can bind to multiple classes with the same signature, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/' {{bind-attr class='isSelected isActive'}}&gt; Click me
&lt;/a&gt;</pre></div><p class="calibre7">This becomes the following:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/' class='is-selected is-active'&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">Sometimes, we might want to use both bound and unbound classes in an element. The following example demonstrates this:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/'  {{bind-attr class='isSelected :active'}}&gt; Click me
&lt;/a&gt;</pre></div><p class="calibre7">This yields the following:</p><div class="informalexample"><pre class="programlisting">&lt;a href=' class='is-selected active'&gt;Click me&lt;/a&gt;</pre></div><p class="calibre7">As shown, the <a id="id156" class="calibre1"/>unbound class names begin with a semicolon. Note that the following example won't<a id="id157" class="calibre1"/> work since all the class names should be defined inside the <code class="email">bind-attr</code> expression if one of them is bound:</p><div class="informalexample"><pre class="programlisting">&lt;a href='/'  class='active' {{bind-attr class='isSelected'}}&gt; Click me
&lt;/a&gt;</pre></div></div>
<div class="book" title="Defining route links"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec48" class="calibre1"/>Defining route links</h1></div></div></div><p class="calibre7">A typical Ember.js application <a id="id158" class="calibre1"/>has several routes that we might need<a id="id159" class="calibre1"/> to link to in templates. The <code class="email">{{#link-to}}...{{/link-to}}</code> helper<a id="id160" class="calibre1"/> serves this purpose and lets the application create anchors to these routes easily. For example, the list on the left-hand side of our sample application is composed of links that the user can use to view the details of the various contacts. We use this helper to generate these links as:</p><div class="informalexample"><pre class="programlisting">  &lt;ul class="nav nav-pills nav-stacked"&gt;
  {{#each model}}
  &lt;li&gt;
    {{#link-to "contact.index" this}}{{name}}{{/link-to}}
  &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">If we inspect one of the generated links, we notice that it resembles the following line of code:</p><div class="informalexample"><pre class="programlisting">&lt;a href="#/contacts/1"&gt;Jon Doe&lt;/a&gt;</pre></div><p class="calibre7">The helper takes the route name as the first handler, followed by the resources needed by the corresponding route. As discussed in the previous chapter, since the path of the affected route has dynamic segments, its handler is responsible for resolving the required parameters to replace these segments. In this case, the <code class="email">contact</code> route path has one dynamic segment, <code class="email">contact_id</code>, which is used as discussed in the previous chapter.</p><p class="calibre7">If we want to link to the blog route, we only need to specify the route name as:</p><div class="informalexample"><pre class="programlisting">{{#link-to "about"}}about{{/link-to}}</pre></div><p class="calibre7">Just like the <code class="email">bind-to</code> expression, the <code class="email">link-to</code> expression also accepts other element attributes such as <code class="email">rel</code>, <code class="email">target</code>, or <code class="email">class</code>. The following example opens the link in a new tab or window:</p><div class="informalexample"><pre class="programlisting">{{#link-to "about" target="_blank"}}about{{/link-to}}</pre></div></div>
<div class="book" title="Registering DOM element event listeners"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec49" class="calibre1"/>Registering DOM element event listeners</h1></div></div></div><p class="calibre7">In vanilla <a id="id161" class="calibre1"/>JavaScript, an application<a id="id162" class="calibre1"/> script traverses the DOM, setting up event listeners along the way. A typical form might look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;form name='tweet'&gt;
    &lt;textarea name='content' required&gt;&lt;/textarea&gt;
     &lt;input type='submit' value='tweet'&gt;&lt;/form&gt;

&lt;script&gt;
    var form = document.forms.tweet;
    form.onsubmit = function(event){
      event.preventDefault();
       alert(form.content.value); 
};
&lt;/script&gt;</pre></div><p class="calibre7">Ember.js provides an abstraction over this, which allows developers to easily subscribe to element-specific events using the <code class="email">{{action ...}}</code> helper. Our chapter contains such a form, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;form
    class="form form-horizontal"
    role="form"
    {{action "saveContact" this on="submit"}}&gt;

  ...
  
  &lt;button class="btn" type="submit"&gt;
  done
  &lt;/button&gt;

  ...
&lt;/form&gt;</pre></div><p class="calibre7">The preceding snippet shows an action that gets triggered when the form gets submitted. As shown, the action helper takes the following arguments:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A function to trigger</li><li class="listitem">An optional context object</li><li class="listitem">An optional type of event to listen to which defaults to click on</li></ul></div><p class="calibre7">The function to call is usually defined in the <code class="email">actions</code> property of the route and takes an unlimited number of arguments. By default, the default event type to bind to is usually the <code class="email">click</code> event. However, you can specify this type using the <code class="email">on</code> attribute. The <code class="email">actions</code> property can be defined on either the corresponding route or controller. For example, the action handler for the preceding action was defined in the <code class="email">contacts</code> route as:</p><div class="informalexample"><pre class="programlisting">App.ContactsRoute = Ember.Route.extend({
  actions: {
    saveContact: function(contact){
      var id = contact.get('id');
      contact.save();
      if (!id){
        this.controllerFor('contacts').pushObject(contact);
      }
      this.transitionTo('contact.index', contact);
    }
  }
});
    </pre></div><p class="calibre7">As <a id="id163" class="calibre1"/>mentioned, this <a id="id164" class="calibre1"/>action can still be defined in the controller layer as:</p><div class="informalexample"><pre class="programlisting">App.ContactsController = Ember.ArrayController.extend({
  actions: {
    saveContact: function(contact){
      var id = contact.get('id');
      contact.save();
      if (!id){
        this.pushObject(contact);
      }
      this.transitionToRoute('contact.index', contact);
    }
  }
});</pre></div><p class="calibre7">The main point to consider when deciding where to put an action is when we need to take advantage of the <a id="id165" class="calibre1"/>
<span class="strong"><strong class="calibre8">bubbling</strong></span> action. When an action is triggered, the function specified is looked up in the corresponding controller. If this action is defined, it gets executed. If the action is not defined, Ember.js performs the check in the corresponding route handler. If this action is defined in either controller or route handler and returns a value equal to <code class="email">True</code>, Ember.js goes ahead and checks for a similar function in the parent route handlers, until one of them doesn't contain the function or does not define it.</p><p class="calibre7">One important thing to note is that the bubbling action occurs in the route handler layer only. This is one of the reasons we will opt to define the function in the route handler. For example, since we should be able to call the <code class="email">saveContact</code> action from both the <code class="email">contacts.new</code> and <code class="email">contact.edit</code> templates, we define it in the <code class="email">contacts</code> route. Here's an illustration of how the action is propagated in both cases:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Registering DOM element event listeners" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The preceding <a id="id166" class="calibre1"/>action function can still be located in any controller if we specify the <code class="email">target</code> object of the action. The <code class="email">target</code> object <a id="id167" class="calibre1"/>contains the <code class="email">actions</code> hash that Ember.js checks for the <code class="email">action</code> function. By default, it is usually the corresponding controller of the template, as shown in the preceding figure. Therefore, we can define the <code class="email">action</code> function in the <code class="email">contact</code> controller, and then set the target as:</p><div class="informalexample"><pre class="programlisting">&lt;form
    class="form form-horizontal"
    role="form"
    {{action "saveContact" this target="controllers.contact" on="submit"}}&gt;
 ...
&lt;/form&gt;</pre></div></div>
<div class="book" title="Writing form inputs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec50" class="calibre1"/>Writing form inputs</h1></div></div></div><p class="calibre7">Writing<a id="id168" class="calibre1"/> forms<a id="id169" class="calibre1"/> is a common practice that Ember.js simplifies by providing template helpers of the many HTML5 form controls. The following table shows these common controls and the attributes they can accept:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Control</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Attributes</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">input</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">value</code>
</p>
<p class="calibre19">
<code class="literal">size</code>
</p>
<p class="calibre19">
<code class="literal">name</code>
</p>
<p class="calibre19">
<code class="literal">pattern</code>
</p>
<p class="calibre19">
<code class="literal">placeholder</code>
</p>
<p class="calibre19">
<code class="literal">disabled</code>
</p>
<p class="calibre19">
<code class="literal">maxlength</code>
</p>
<p class="calibre19">
<code class="literal">tabindex</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">textarea</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">checked</code>
</p>
<p class="calibre19">
<code class="literal">disabled</code>
</p>
<p class="calibre19">
<code class="literal">tabindex</code>
</p>
<p class="calibre19">
<code class="literal">indeterminate</code>
</p>
<p class="calibre19">
<code class="literal">name</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">checkbox</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">rows</code>
</p>
<p class="calibre19">
<code class="literal">cols</code>
</p>
<p class="calibre19">
<code class="literal">placeholder</code>
</p>
<p class="calibre19">
<code class="literal">disabled</code>
</p>
<p class="calibre19">
<code class="literal">maxlength</code>
</p>
<p class="calibre19">
<code class="literal">tabindex</code>
</p>
</td></tr></tbody></table></div><p class="calibre7">In the <a id="id170" class="calibre1"/>sample<a id="id171" class="calibre1"/> application, the user is able to edit a contact by clicking on the <span class="strong"><strong class="calibre8">edit</strong></span> button in the footer, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Writing form inputs" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If the <a id="id172" class="calibre1"/>user <a id="id173" class="calibre1"/>edits the first name of the contact, we notice that their names are updated in the sidebar. The input helper is used in the <code class="email">contacts/form</code> template to <span class="strong"><em class="calibre9">bind</em></span> the input element's value with the first name of the contact as:</p><div class="informalexample"><pre class="programlisting">{{input
  type="text"
  id="form-first-name"
  value=first_name
  required='required'}}</pre></div><p class="calibre7">Here, we defined four attributes that were either bound or unbound. A bound attribute gets updated each time the specified variable changes and vice versa. For example, in the preceding case, the <code class="email">value</code> attribute was bound while the <code class="email">required</code> attribute was not. Unbound attributes are quoted while those bound are not.</p><p class="calibre7">Here are more examples that show how to use the other two form helpers:</p><div class="informalexample"><pre class="programlisting">{{textarea value=model.content}}
{{checkbox checked=model.isPaid}}</pre></div></div>
<div class="book" title="Extending templates"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec51" class="calibre1"/>Extending templates</h1></div></div></div><p class="calibre7">In the course of <a id="id174" class="calibre1"/>application development, you might find the need to abstract templates for reuse. There <a id="id175" class="calibre1"/>are several helpers that can help us implement this easily:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">partial</code></li><li class="listitem"><code class="email">view</code></li><li class="listitem"><code class="email">render</code></li><li class="listitem"><code class="email">named outlets</code></li></ul></div><p class="calibre7">The<a id="id176" class="calibre1"/> <code class="email">partial</code> helper<a id="id177" class="calibre1"/> is used to include templates inside others. It simply inserts the desired template where the <code class="email">partial</code> expression has been specified. As discussed earlier, the chapter sample used this helper in two instances:</p><div class="informalexample"><pre class="programlisting">  &lt;script
   type="text/x-handlebars"
  data-template-name="contact/edit"&gt;
    {{#with controller.controllers.contact}}
    {{partial "contacts/form"}}
    {{/with}}
  &lt;/script&gt;

 &lt;script
   type="text/x-handlebars"
  data-template-name="contacts/new"&gt;
    {{partial "contacts/form"}}

  &lt;/script&gt;</pre></div><p class="calibre7">This helper takes the template that should be inserted into the current template as the only argument. One thing to note is that using the helper doesn't lead to the loss of context, as seen in the <code class="email">contact/edit</code> case.</p><p class="calibre7">We might also wish to insert views inside other templates. In this case, the view's template will be inserted into the specified portion of the current template and the defined event listeners will be set up. For example, the first name input we saw earlier can also be written as:</p><div class="informalexample"><pre class="programlisting">{{view
  Em.TextField
  id="form-first-name"
  value=first_name
  required='required'
}}</pre></div><p class="calibre7">We will discuss this in more detail in <a class="calibre1" title="Chapter 6. Views and Event Management" href="part0069_split_000.html#page">Chapter 6</a>, <span class="strong"><em class="calibre9">Views and Event Management</em></span>, where we will deal with views. The important thing to note here is that the input helpers named are actually Handlebars helpers defined from these views. We will discuss how these helpers are created in a moment. The <code class="email">render</code> helper<a id="id178" class="calibre1"/> works in the same way as the <code class="email">partial</code> helper, except that it takes an optional context as the second argument. For example, we will define the <code class="email">contact/edit</code> and <code class="email">contact/edit</code> templates as:</p><div class="informalexample"><pre class="programlisting">  &lt;script
   type="text/x-handlebars"
  data-template-name="contact/edit"&gt;
    {{render "contacts/form" controller.controllers.contact}}
  &lt;/script&gt;

 &lt;script
   type="text/x-handlebars"
  data-template-name="contacts/new"&gt;
    {{render "contacts/form"}}
  &lt;/script&gt;</pre></div><p class="calibre7">Instead of <a id="id179" class="calibre1"/>switching the context in the first template, we simply passed the controller to be used as the context. Note that, by default, the context passed is the corresponding controller instance, and so we did not need to specify this context in the case of the <code class="email">contacts/new</code> template.</p><p class="calibre7">The last way to extend templates is by the use of named outlets we already discussed in the preceding chapter. Here is the example we used:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" data-template-name="game"&gt;
  &lt;div id="leaderboard"&gt;{{outlet leaderboard}}&lt;/div&gt;
  &lt;div id="mainboard"&gt;{{outlet mainboard}}&lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">We then render the outlets via the handler as:</p><div class="informalexample"><pre class="programlisting">App.GameRoute = Ember.Route.extend({
  renderTemplate: function() {
    this.render('mainboard', {
      into: 'game',
      outlet: 'mainboard',
      controller: 'mainboard'
    });
    this.render('leaderboard', {
      into: 'game',
      outlet: 'leaderboard',
      controller: 'leaderboard'
    });
  }
});</pre></div><p class="calibre7">It's very similar to how the <code class="email">partial</code> helper is used, but in this case, we also specify the template in the route handler's <code class="email">renderTemplate</code> hook.</p></div>
<div class="book" title="Defining custom helpers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec52" class="calibre1"/>Defining custom helpers</h1></div></div></div><p class="calibre7">Handlebars <a id="id180" class="calibre1"/>provides ways to create your own helpers. The<a id="id181" class="calibre1"/> following is the format used to register new helpers:</p><div class="informalexample"><pre class="programlisting">Ember.Handlebars.register(helper_name, helper_function_or_class);</pre></div><p class="calibre7">For example, let's create a <code class="email">heading</code> helper that creates <code class="email">h1</code> tags:</p><div class="informalexample"><pre class="programlisting">  Ember.Handlebars.register('heading', function(text, options){
    var escapedText = Handlebars.Utils.escapeExpression(text);
     var heading = '&lt;h1&gt;'+escapedText+'&lt;/h1&gt;';
               return new Handlebars.SafeString(heading);
  });</pre></div><p class="calibre7">This can then be used in our application templates as:</p><div class="informalexample"><pre class="programlisting">  {{heading 'Title'}}</pre></div><p class="calibre7">Now, yield the following:</p><div class="informalexample"><pre class="programlisting">  &lt;h1&gt;Title&lt;/h1&gt;</pre></div><p class="calibre7">The following example also demonstrates how to create helpers from existing views:</p><div class="informalexample"><pre class="programlisting">    Ember.Handlebars.register('loader', App.LoaderView}}</pre></div><p class="calibre7">This can now be used simply as:</p><div class="informalexample"><pre class="programlisting">  {{loader}}</pre></div><p class="calibre7">This is equivalent to the following:</p><div class="informalexample"><pre class="programlisting">  {{view App.LoaderView}}</pre></div></div>
<div class="book" title="Creating subexpressions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec53" class="calibre1"/>Creating subexpressions</h1></div></div></div><p class="calibre7">A <a id="id182" class="calibre1"/>subexpression, as <a id="id183" class="calibre1"/>the name suggests, is an expression contained in another expression, which takes the following signature:</p><div class="informalexample"><pre class="programlisting">   {{outer-helper (inner-helper 'arg1') 'arg2'}}</pre></div><p class="calibre7">Here's an example that implements a <a id="id184" class="calibre1"/>
<code class="email">Number.toFixed</code> helper:</p><div class="informalexample"><pre class="programlisting">Ember.Handlebars.registerHelper('to-fixed', function(num, decimals) {
  return new Ember.Handlebars.SafeString(
    num.toFixed(decimals)
  );
});</pre></div><p class="calibre7">This can be used inside a <code class="email">link-to</code> helper as:</p><div class="informalexample"><pre class="programlisting">  {{#link-to 'checkout' (to-fixed cart.total)}}
  checkout
  {{/link-to}}</pre></div><p class="calibre7">This<a id="id185" class="calibre1"/> will <a id="id186" class="calibre1"/>result in something like the following:</p><div class="informalexample"><pre class="programlisting">   &lt;a href='#/checkout/10.10'&gt;checkout&lt;/a&gt;</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec54" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This has been an exciting chapter that walked us through the template layer. This chapter will be revisited when we will discuss controllers in the next chapter. Here are the key concepts we learned and those that will be revisited in the next chapters:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Writing binding template expressions</li><li class="listitem">Writing conditionals in templates</li><li class="listitem">Changing contexts in templates</li><li class="listitem">Creating event listeners in templates</li><li class="listitem">Extending templates</li><li class="listitem">Writing custom template helpers</li></ul></div></div></body></html>