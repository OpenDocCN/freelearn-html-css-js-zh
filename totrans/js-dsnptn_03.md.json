["```js\nclass Implementation {\n  someFn() {\n    return 'some-output';\n  }\n  sensitiveFn() {\n    return 'sensitive-output';\n  }\n}\n```", "```js\nclass RedactionProxy {\n  constructor() {\n    this.impl = new Implementation();\n  }\n  someFn() {\n    return this.impl.someFn();\n  }\n  sensitiveFn() {\n    return this.impl.sensitiveFn().replace('sensitive',\n      '[REDACTED]');\n  }\n}\n```", "```js\nconst redactionProxy = new RedactionProxy();\nconsole.assert(\n  redactionProxy.someFn() === newImplementation().someFn(),\n    'Proxy implementation calls through to original'\n);\n```", "```js\nconsole.assert(\n  redactionProxy.sensitiveFn() !== new\n    Implementation().sensitiveFn()&&\n      redactionProxy.sensitiveFn() === '[REDACTED]-output',\n      'Proxy implementation adds new behaviour'\n);\n```", "```js\nclass Implementation {\n  someFn() {\n    return 'sensitive-some-output';\n  }\n  sensitiveFn() {\n    return 'sensitive-output';\n  }\n  otherSensitiveFn() {\n    return 'sensitive-other-output';\n  }\n}\n```", "```js\nclass RedactionProxyNaive {\n  constructor() {\n    this.impl = new Implementation();\n  }\n  someFn() {\n    return this.impl.someFn().replace\n      ('sensitive', '[REDACTED]');\n  }\n  sensitiveFn() {\n    return this.impl.sensitiveFn().replace('sensitive',\n      '[REDACTED]');\n  }\n  otherSensitiveFn() {\n    return this.impl.otherSensitiveFn().\n      replace('sensitive', '[REDACTED]');\n  }\n}\n```", "```js\nconsole.assert(\n  !new RedactionProxyNaive().someFn().includes('sensitive')\n    &&\n    !new RedactionProxyNaive().sensitiveFn().includes\n      ('sensitive') &&\n    !new RedactionProxyNaive().otherSensitiveFn().includes\n      ('sensitive'),\n  'naive proxy redacts correctly'\n);\n```", "```js\nclass RedactionProxyNaiveRefactored {\n  constructor() {\n    this.impl = new Implementation();\n  }\n  #redact(str) {\n    return str.replace('sensitive', '[REDACTED]');\n  }\n  someFn() {\n    return this.#redact(this.impl.someFn());\n  }\n  sensitiveFn() {\n    return this.#redact(this.impl.sensitiveFn());\n  }\n  otherSensitiveFn() {\n    return this.#redact(this.impl.otherSensitiveFn());\n  }\n}\nconsole.assert(\n  !new RedactionProxyNaiveRefactored().someFn().includes\n    ('sensitive') &&\n    !new RedactionProxyNaiveRefactored().sensitiveFn().\n      includes('sensitive') &&\n    !new RedactionProxyNaiveRefactored()\n      .otherSensitiveFn()\n      .includes('sensitive'),\n  'refactored naive proxy redacts correctly'\n);\n```", "```js\nconst obj = {\n  someFn() {\n    return 'sensitive-some-output';\n  },\n  sensitiveFn() {\n    return 'sensitive-output';\n  },\n  otherSensitiveFn() {\n    return 'sensitive-other-output';\n  },\n  field: 'sensitive-data',\n  sensitiveField: 'redact-everything',\n};\n```", "```js\nconst redactedObjProxy = new Proxy(obj, {\n  get(target, property, _receiver) {\n    if (target[property] instanceof Function) {\n      return (...args) => {\n        if (property.includes('sensitive')) {\n          return '[REDACTED]';\n        }\n        const output = target[property](...args);\n        if (typeof output === 'string') {\n          return output.replace('sensitive', '[REDACTED]');\n        }\n        return output;\n      };\n    }\n    if (property.includes('sensitive')) {\n      return '[REDACTED]';\n    }\n    return target[property].replace('sensitive',\n      '[REDACTED]');\n  },\n});\n```", "```js\nconsole.assert(\n  !redactedObjProxy.someFn().includes('sensitive') &&\n    !redactedObjProxy.sensitiveFn().includes('sensitive') &&\n    !redactedObjProxy.otherSensitiveFn().includes\n      ('sensitive'),\n  'JavaScript Proxy redacts correctly for all functions'\n);\nconsole.assert(\n  !redactedObjProxy.field.includes('sensitive'),\n  'JavaScript Proxy redacts field values by value\n    correctly'\n);\nconsole.assert(\n  redactedObjProxy.sensitiveField === '[REDACTED]',\n  'JavaScript Proxy redacts field values by property name\n    correctly'\n);\n```", "```js\nconst redact = (propertyName, redactionValue) => {\n  if (propertyName.includes('sensitive')) {\n    return '[REDACTED]';\n  }\n  if (typeof redactionValue === 'string') {\n    return redactionValue.replace('sensitive','[REDACTED]'\n    );\n  }\n  // Could implement redaction of objects/Arrays and so on\n  return redactionValue;\n};\n```", "```js\nconst redactedObjProxyImproved = new Proxy(obj, {\n  get(target, property, receiver) {\n    const targetPropertyValue = Reflect.get(target,\n      property, receiver);\n    if (targetPropertyValue instanceof Function) {\n      return (...args) => {\n        const output = Reflect.apply(\n          targetPropertyValue,\n          this === receiver ? this : target,\n          args\n        );\n        return redact(property, output);\n      };\n    }\n    return redact(property, targetPropertyValue);\n  },\n});\n```", "```js\nconsole.assert(\n  !redactedObjProxyImproved.someFn().includes\n    ('sensitive') &&\n    !redactedObjProxyImproved.sensitiveFn().includes\n      ('sensitive') &&\n    !redactedObjProxyImproved.otherSensitiveFn().includes\n      ('sensitive'),\n  'JavaScript Proxy with Reflect redacts correctly for all\n    functions'\n);\nconsole.assert(\n  !redactedObjProxyImproved.field.includes('sensitive'),\n  'JavaScript Proxy with Reflect redacts field values\n    correctly'\n);\nconsole.assert(\n  redactedObjProxyImproved.sensitiveField === '[REDACTED]',\n  'JavaScript Proxy with Reflect redacts field values\n    correctly'\n);\n```", "```js\nclass HttpClient {\n  async getJson(url) {\n    const response = await fetch(url);\n    if (response.ok) {\n      return response.json();\n    }\n    throw new Error(`Error loading ${url}`);\n  }\n}\n```", "```js\nclass InstrumentedHttpClient {\n  constructor(client) {\n    this.client = client;\n    this.requestTimings = {};\n  }\n  async getJson(url) {\n    const start = performance.now();\n    const output = await this.client.getJson(url);\n    const end = performance.now();\n    if (!Array.isArray(this.requestTimings[url])) {\n      this.requestTimings[url] = [];\n    }\n    this.requestTimings[url].push(end - start);\n    return output;\n  }\n}\n```", "```js\nconst httpClient = new HttpClient();\nconst instrumentedClient = new InstrumentedHttpClient\n  (httpClient);\nawait instrumentedClient.getJson\n  ('https://ifconfig.io/all.json');\nconsole.assert(\n  Object.keys(instrumentedClient.requestTimings).length >0,\n  'Tracks request timings'\n);\nawait instrumentedClient.getJson\n  ('https://ifconfig.io/all.json');\nconsole.assert(\n  instrumentedClient.requestTimings\n    ['https://ifconfig.io/all.json'].length === 2,\n  'Tracks per URL timings'\n);\n```", "```js\nasync function getJson(url) {\n  const response = await fetch(url);\n  if (response.ok) {\n    return response.json();\n  }\n  throw new Error(`Error loading ${url}`);\n}\n```", "```js\nconst allOperationTimings = new Map();\nfunction addTiming(getJson) {\n  return async (url) => {\n    const start = performance.now();\n    const output = await getJson(url);\n    const end = performance.now();\n    const previousOperationTimings =\n       allOperationTimings.get(url) || [];\n    allOperationTimings.set(url,\n      previousOperationTimings.concat(end - start));\n    return output;\n  };\n}\n```", "```js\nconst getJsonWithTiming = addTiming(getJson);\n```", "```js\nawait getJsonWithTiming('https://ifconfig.io/all.json');\nawait getJsonWithTiming('https://ifconfig.io/all.json');\nconsole.assert(\n  allOperationTimings.size === 1,\n  'operation timings tracks by url'\n);\nconsole.assert(\n  allOperationTimings.get('https://ifconfig.io/all.json').\n    length === 2,\n  'operation timings tracks number of calls by url'\n);\n```", "```js\nclass CoinFlyweight {\n  /**\n   * @param {Number} amount – amount in minor currency\n   * @param {String} currency\n   */\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n}\n```", "```js\nclass CoinFlyweightFactory {\n  static flyweights = {};\n  static get(amount, currency) {\n    const flyWeightKey = `${amount}-${currency}`;\n    if (this.flyweights[flyWeightKey]) {\n      return this.flyweights[flyWeightKey];\n    }\n    const instance = new CoinFlyweight(amount, currency);\n    this.flyweights[flyWeightKey] = instance;\n    return instance;\n  }\n  static getCount() {\n    return Object.keys(this.flyweights).length;\n  }\n}\n```", "```js\nclass MaterialFlyweight {\n  constructor(materialName) {\n    this.name = materialName;\n  }\n}\nclass MaterialFlyweightFactory {\n  static flyweights = {};\n  static get(materialName) {\n    if (this.flyweights[materialName]) {\n      return this.flyweights[materialName];\n    }\n    const instance = new MaterialFlyweight(materialName);\n    this.flyweights[materialName] = instance;\n    return instance;\n  }\n  static getCount() {\n    return Object.keys(this.flyweights).length;\n  }\n}\n```", "```js\nclass Coin {\n  constructor(amount, currency, yearOfIssue, materials) {\n    this.flyweight = CoinFlyweightFactory.get\n      (amount, currency);\n    this.yearOfIssue = yearOfIssue;\n    this.materials = materials.map((material) =>\n      MaterialFlyweightFactory.get(material)\n    );\n  }\n}\n```", "```js\nclass Wallet {\n  constructor() {\n    this.coins = [];\n  }\n  add(amount, currency, yearOfIssue, materials) {\n    const coin = new Coin(amount, currency, yearOfIssue,\n      materials);\n    this.coins.push(coin);\n  }\n  getCount() {\n    return this.coins.length;\n  }\n  getTotalValueForCurrency(currency) {\n    return this.coins\n      .filter((coin) => coin.flyweight.currency ===\n        currency)\n      .reduce((acc, curr) => acc + curr.flyweight.amount, 0);\n  }\n}\n```", "```js\nconst wallet = new Wallet();\nwallet.add(100, 'GBP', '2023', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2022', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2021', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2021', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(200, 'GBP', '2021', ['nickel-brass',\n  'cupro-nickel']);\nwallet.add(100, 'USD', '1990', ['copper', 'nickel']);\nwallet.add(5, 'USD', '1990', ['copper', 'nickel']);\nwallet.add(1, 'USD', '2010', ['copper', 'zinc']);\n```", "```js\nconsole.assert(\n  wallet.getCount() === 8,\n  'wallet.add adds coin instances are created once given\n    the same cache key'\n);\nconsole.assert(\n  CoinFlyweightFactory.getCount() === 5,\n  'CoinFlyweights are created once given the same\n    cache key'\n);\nconsole.assert(\n  MaterialFlyweightFactory.getCount() === 6,\n  'MaterialFlyweights are created once given the same\n     cache key'\n);\nconsole.assert(\n  wallet.getTotalValueForCurrency('GBP') === 600,\n  'Summing GBP works'\n);\nconsole.assert(\n  wallet.getTotalValueForCurrency('USD') === 106,\n  'Summing USD works'\n);\n```", "```js\nclass CoinFlyweightFactory {\n  static #flyweights = new Map();\n  static get(amount, currency) {\n    const flyWeightKey = `${amount}-${currency}`;\n    if (this.#flyweights.get(flyWeightKey)) {\n      return this.#flyweights.get(flyWeightKey);\n    }\n    const instance = new CoinFlyweight(amount, currency);\n    this.#flyweights.set(flyWeightKey, instance);\n    return instance;\n  }\n  static getCount() {\n    return this.#flyweights.size;\n  }\n}\n```", "```js\nclass Coin {\n  #flyweight;\n  constructor(amount, currency, yearOfIssue, materials) {\n    this.#flyweight = CoinFlyweightFactory.get\n      (amount, currency);\n    this.yearOfIssue = yearOfIssue;\n    this.materials = materials;\n  }\n  get amount() {\n    return this.#flyweight.amount;\n  }\n  get currency() {\n    return this.#flyweight.currency;\n  }\n}\n```", "```js\nclass Wallet {\n  constructor() {\n    this.coins = [];\n  }\n  add(amount, currency, yearOfIssue, materials) {\n    const coin = new Coin(amount, currency, yearOfIssue,\n      materials);\n    this.coins.push(coin);\n  }\n  getCount() {\n    return this.coins.length;\n  }\n  getTotalValueForCurrency(currency) {\n    return this.coins\n      .filter((coin) => coin.currency === currency)\n      .reduce((acc, curr) => acc + curr.amount, 0);\n  }\n}\n```", "```js\nconst wallet = new Wallet();\nwallet.add(100, 'GBP', '2023', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2022', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2021', ['nickel-brass',\n  'nickel-plated alloy']);\nwallet.add(100, 'GBP', '2021', ['nickel-brass',\n  'nickel-plated alloy']);\nWallet.add(200, 'GBP', '2021', ['nickel-brass',\n  'cupro-nickel']);\nwallet.add(100, 'USD', '1990', ['copper', 'nickel']);\nwallet.add(5, 'USD', '1990', ['copper', 'nickel']);\nwallet.add(1, 'USD', '2010', ['copper', 'zinc']);\nconsole.assert(\n  wallet.getCount() === 8,\n  'wallet.add adds coin instances are created once\n    given the same cache key'\n);\nconsole.assert(\n  CoinFlyweightFactory.getCount() === 5,\n  'CoinFlyweights are created once given the same\n   cache key'\n);\nconsole.assert(\n  wallet.getTotalValueForCurrency('GBP') === 600,\n  'Summing GBP works'\n);\nconsole.assert(\n  wallet.getTotalValueForCurrency('USD') === 106,\n  'Summing USD works'\n);\n```", "```js\nclass IdGenerator {\n  get(entry) {\n    return JSON.stringify(entry);\n  }\n}\nclass Database {\n  constructor(idGenerator) {\n    this.idGenerator = idGenerator;\n    this.entries = {};\n  }\n  createEntry(entryData) {\n    const id = this.idGenerator.get(entryData);\n    this.entries[id] = entryData;\n    return id;\n  }\n  get(id) {\n    return this.entries[id];\n  }\n}\n```", "```js\nconst naiveIdDatabase = new Database(new IdGenerator());\nnaiveIdDatabase.createEntry({\n  name: 'pear',\n});\nconsole.assert(\n  naiveIdDatabase.get('{\"name\":\"pear\"}').name === 'pear',\n  'stringIdDatabase recalls entries by stringified entry'\n);\n```", "```js\nimport { v4 as uuidv4 } from 'uuid';\nclass UuidFactory {\n  generateUuid() {\n    return uuidv4();\n  }\n}\n```", "```js\nclass UuidIdGeneratorAdapter {\n  constructor() {\n    this.uuidFactory = new UuidFactory();\n  }\n  get(_entry) {\n    return this.uuidFactory.generateUuid();\n  }\n}\n```", "```js\nconst uuidIdDatabase = new Database(new UuidIdGeneratorAdapter());\nconst uuidEntryId = uuidIdDatabase.createEntry({\n  name: 'pear',\n});\nconsole.assert(\n  uuidIdDatabase.get(uuidEntryId).name === 'pear',\n  'uuidIdDatabase recalls entries by uuid'\n);\nimport { validate as isUuid } from 'uuid';\nconsole.assert(isUuid(uuidEntryId), 'uuidIdDatabase generated uuid ids');\n```", "```js\nclass Counter {\n  constructor(startValue = 1) {\n    this.startValue = startValue;\n    this.nextId = startValue;\n    this.nextIdByPrefix = {};\n  }\n  getAndIncrement(prefix) {\n    if (prefix) {\n      if (!this.nextIdByPrefix[prefix]) {\n        this.nextIdByPrefix[prefix] = this.startValue;\n      }\n      const nextId = this.nextIdByPrefix[prefix]++;\n      return `${prefix}:${nextId}`;\n    }\n    return String(this.nextId++);\n  }\n}\n```", "```js\nclass PrefixedAutoIncrementIdGeneratorAdapter {\n  constructor() {\n    this.counter = new Counter();\n  }\n  get(entry) {\n    return this.counter.getAndIncrement(entry.name);\n  }\n}\n```", "```js\nconst prefixAutoIncrementDatabase = new Database(\n  new PrefixedAutoIncrementIdGeneratorAdapter()\n);\n```", "```js\nconst noPrefixIncrementingEntryId1 =\n  prefixAutoIncrementDatabase.createEntry({\n  type: 'no-prefix',\n});\nconst noPrefixIncrementingEntryId2 =\n  prefixAutoIncrementDatabase.createEntry({\n  type: 'no-prefix',\n});\nconsole.assert(\n  noPrefixIncrementingEntryId1 === '1' &&\n    noPrefixIncrementingEntryId2 === '2',\n  'prefixAutoIncrementDatabase generates autoincrementing\n    ids with no prefix if no name property is set'\n);\nconsole.assert(\n  prefixAutoIncrementDatabase.get\n    (noPrefixIncrementingEntryId1).type ===\n    'no-prefix' &&\n    prefixAutoIncrementDatabase.get\n      (noPrefixIncrementingEntryId2).type ===\n      'no-prefix',\n  'prefixAutoIncrementDatabase recalls entries by\n     autoincrementing id'\n);\n```", "```js\nconst prefixIncrementingEntryIdPear1 =\n  prefixAutoIncrementDatabase.createEntry({\n  name: 'pear',\n});\nconst prefixIncrementingEntryIdPear2 =\n  prefixAutoIncrementDatabase.createEntry({\n  name: 'pear',\n});\nconst prefixIncrementingEntryIdApple1 =\n  prefixAutoIncrementDatabase.createEntry(\n  {\n    name: 'apple',\n  }\n);\nconsole.assert(\n  prefixIncrementingEntryIdPear1 === 'pear:1' &&\n    prefixIncrementingEntryIdPear2 === 'pear:2' &&\n    prefixIncrementingEntryIdApple1 === 'apple:1',\n  'prefixAutoIncrementDatabase generates prefixed\n    autoincrementing ids'\n);\nconsole.assert(\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdPear1).name ===\n    'pear',\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdPear2).name ===\n    'pear',\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdApple1).name ===\n    'apple',\n  'prefixAutoIncrementDatabase recalls entries by prefixed\n    id'\n);\n```", "```js\nfunction defaultIdGenerator(entry) {\n  return JSON.stringify(entry);\n}\n```", "```js\nclass Database {\n  constructor(idGenerator) {\n    this.idGenerator = idGenerator;\n    this.entries = {};\n  }\n  createEntry(entryData) {\n    const id = this.idGenerator(entryData);\n    this.entries[id] = entryData;\n    return id;\n  }\n  get(id) {\n    return this.entries[id];\n  }\n}\n```", "```js\nconst naiveIdDatabase = new Database(defaultIdGenerator);\nnaiveIdDatabase.createEntry({\n  name: 'pear',\n});\nconsole.assert(\n  naiveIdDatabase.get('{\"name\":\"pear\"}').name === 'pear',\n  'stringIdDatabase recalls entries by stringified entry'\n);\n```", "```js\nfunction uuidGenerator() {\n  return uuidv4();\n}\nconst uuidIdDatabase = new Database(uuidGenerator);\nconst uuidEntryId = uuidIdDatabase.createEntry({\n  name: 'pear',\n});\nconsole.assert(\n  uuidIdDatabase.get(uuidEntryId).name === 'pear',\n  'uuidIdDatabase recalls entries by uuid'\n);\nconsole.assert(isUuid(uuidEntryId), 'uuidIdDatabase\n  generated uuid ids');\n```", "```js\nconst startValue = 1;\nlet nextId = startValue;\nlet nextIdByPrefix = {};\nfunction prefixAutoIncrementIdGenerator(entry) {\n  const prefix = entry.name;\n  if (prefix) {\n    if (!nextIdByPrefix[prefix]) {\n      nextIdByPrefix[prefix] = startValue;\n    }\n    const nextId = nextIdByPrefix[prefix]++;\n    return `${prefix}:${nextId}`;\n  }\n  return String(nextId++);\n}\n```", "```js\nconst prefixAutoIncrementDatabase = new Database(\n  prefixAutoIncrementIdGenerator\n);\nconst noPrefixIncrementingEntryId1 =\n  prefixAutoIncrementDatabase.createEntry({\n  type: 'no-prefix',\n});\nconst noPrefixIncrementingEntryId2 =\n  prefixAutoIncrementDatabase.createEntry({\n  type: 'no-prefix',\n});\nconsole.assert(\n  noPrefixIncrementingEntryId1 === '1' &&\n    noPrefixIncrementingEntryId2 === '2',\n  'prefixAutoIncrementDatabase generates autoincrementing\n     ids with no prefix if no name property is set'\n);\nconsole.assert(\n  prefixAutoIncrementDatabase.get\n    (noPrefixIncrementingEntryId1).type ===\n    'no-prefix' &&\n    prefixAutoIncrementDatabase.get\n      (noPrefixIncrementingEntryId2).type ===\n      'no-prefix',\n  'prefixAutoIncrementDatabase recalls entries by\n    autoincrementing id'\n);\nconst prefixIncrementingEntryIdPear1 =\n  prefixAutoIncrementDatabase.createEntry({\n  name: 'pear',\n});\nconst prefixIncrementingEntryIdPear2 =\n  prefixAutoIncrementDatabase.createEntry({\n  name: 'pear',\n});\nconst prefixIncrementingEntryIdApple1 =\n  prefixAutoIncrementDatabase.createEntry(\n  {\n    name: 'apple',\n  }\n);\nconsole.assert(\n  prefixIncrementingEntryIdPear1 === 'pear:1' &&\n    prefixIncrementingEntryIdPear2 === 'pear:2' &&\n    prefixIncrementingEntryIdApple1 === 'apple:1',\n  'prefixAutoIncrementDatabase generates prefixed\n    autoincrementing ids'\n);\nconsole.assert(\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdPear1).name ===\n    'pear',\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdPear2).name ===\n    'pear',\n  prefixAutoIncrementDatabase.get\n    (prefixIncrementingEntryIdApple1).name ===\n    'apple',\n  'prefixAutoIncrementDatabase recalls entries by prefixed\n    id'\n);\n```"]