- en: Chapter 1. Contact Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn how to build a Contact manager application.
    The application will be divided into two separate parts: one part consisting of
    the backend, our Node.js API written using Express, and the client application
    crafted using Angular 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry! This chapter will be more of a guideline, setting up a base project
    and wrapping your head around TDD (short for **Test-driven development**) in Node.js.
    We'll also get to see Angular 2 in action. We are not going to write tests on
    the client side as there are enough things to accumulate in one chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to start is with a solid base. That's why we are going to focus
    on building the base structure of our application. A good base gives you modularity
    and flexibility and also files should be easily located by you and even your team
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Always start with something simple and start building around it. As your application
    grows, you'll probably outgrow your initial application structure, so thinking
    ahead will bring you big benefits in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before jumping in and building your features right away, you should take a
    moment and sketch out your initial application''s structure. In the planning process,
    a pen and paper should always do it, but I''ve already saved some time and come
    up with an initial version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at a more detailed explanation of our folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app`: This folder contains all the server files used in the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: This folder is going to store the application controllers, mainly
    the backend business logic.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlewares`: In this folder, we''ll store all our pieces of functions that
    will manipulate the request and response object. A good example would be an authentication
    middleware.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models`: This folder will store all the backend models.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes`: This folder will contain all the routing files, which is where we
    are going to define all Express routes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: All application configuration files go here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environments`: This folder contains files loaded according to the current
    environment'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strategies`: All your authentication strategies should go here'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: This folder contains all the tests necessary to test the application
    backend logic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integration`: If something uses external modules, it''s good practice to create
    an integration test'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unit`: This should contain tests for small units of code, such as password
    hashing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: This should contain all the static files served by our application.
    I like this separation because it''s easy to just tell another web server to handle
    our static files. Let''s say you want nginx to handle static file serving:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app`: This is our client-side application''s folder. All compiled TypeScript
    files will go here. This folder should be automatically populated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: This folder contains all the client-side files used to build our application.
    We are going to use TypeScript to build our Angular application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`typings`: This contains TypeScript definitions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After setting up the initial folder structure, the next thing to do is to create
    the `package.json` file. This file will hold all the application''s metadata and
    dependencies. The `package.json` file will be placed at the root of our project
    folder. The path should be `contact-manager/package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We added a few scripts to our `package.json` file to run our unit and integration
    tests and compile the Less files. You can always use `npm` to directly run different
    scripts instead of using build tools such as Grunt or Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, we are using the defined dependencies and
    their versions. This should do it for now. Let''s install them using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see `npm` pulling a bunch of files and adding the necessary dependencies
    to the `node_modules` folder. Wait patiently until everything is installed and
    done. You will be returned to Command Prompt. Now you should see the `node_modules`
    folder created and with all the dependencies in place.
  prefs: []
  type: TYPE_NORMAL
- en: The first application file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before everything, we need to create a simple configuration file for our environment.
    Let''s create the file in the `config` folder at `contact-manager/config/environments/development.js`
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the main `server.js` file for our application. This file
    will be the heart of our application. The file should be in the root of our folder,
    `contact-manager/server.js`. Start with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We define some of our main dependencies and initialize the necessary modules
    of our application. To modularize things, we are going to put each package of
    our stack into a separate configuration file. These configuration files will have
    some logic in them. I like to call them smart configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry! We are going to go through each config file one by one. Finally,
    we will export our Express app instance. If our module is not loaded by another
    module, for example, a test case, then we can safely start listening to incoming
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Express configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a configuration file for Express. The file should be created
    in the `config` folder at `contact-manager/config/express.js` and we have to add
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with many lines from the preceding code by now, for example,
    setting the desired body parser of our Express application. Also, we set up the
    session management, and just in case we set to the server static files, we define
    the path to the server files.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, you should use something different from the default
    in-memory storage for sessions. That's why we added a special session store, which
    will store data in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice to get the global environment configuration file is to set
    a root config file that all application files will load, create a new file called
    `contact-manager/config/index.js`, and add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will just load the necessary environment configuration file
    based on the `NODE_ENV` process environment variable. If the environment variable
    is not present, a default development state will be considered for the application.
    This is a good practice so that we don't make mistakes and connect to the wrong
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the `NODE_ENV` variable can be set when you start your node server;
    for example, under Unix systems, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting up mocha for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we implement any functionality, we are going to write tests for it. Mocha
    is a testing framework built on Node.js. This approach will give us the advantage
    of knowing what code we are going to write and testing our Node.js API before
    even writing a single line of the client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have Mocha, you can install it globally. If you want Mocha to
    be globally available in your command line, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Mongoose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to store data in MongoDB, we are going to use Mongoose. Mongoose provides
    an easy way to define schemas to model application data. We have already included
    mongoose in the `package.json` file, so it should be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a config file for our mongoose library. Let''s create our
    config file `contact-manager/config/mongoose.js`. First, we start by loading the
    Mongoose library, getting the appropriate environment config, and establishing
    a connection with the database. Add the following code to the `mongoose.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, we are using a `cleanup()` function to close all connections to the MongoDB
    database. The preceding code will export the necessary `init()` function used
    in the main `server.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Managing contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the files necessary to start development and add features,
    we can start implementing all of the business logic related to managing contacts.
    To do this, we first need to define the data model of a contact.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the contact mongoose schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our system needs some sort of functionality to store the possible clients or
    just contact persons of other companies. For this, we are going to create a contact
    schema that will represent the same collection storing all the contacts in MongoDB.
    We are going to keep our contact schema simple. Let''s create a model file in
    `contact-manager/app/models/contact.js`, which will hold the schema, and add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table gives a description of the fields in the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | The e-mail of the contact |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The full name of the contact |'
  prefs: []
  type: TYPE_TB
- en: '| `company` | The name of the company at which the contact person works |'
  prefs: []
  type: TYPE_TB
- en: '| `phoneNumber` | The full phone number of the person or company |'
  prefs: []
  type: TYPE_TB
- en: '| `city` | The location of the contact |'
  prefs: []
  type: TYPE_TB
- en: '| `createdAt` | The date at which the contact object was created |'
  prefs: []
  type: TYPE_TB
- en: 'All our model files will be registered in the following configuration file,
    found under `contact-manager/config/models.js`. The final version of this file
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Describing the contact route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to communicate with the server, we need to expose routes for client
    applications to consume. These are going to be endpoints (URIs) that respond to
    client requests. Mainly, our routes will send a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by describing the CRUD functionality of the contact module.
    The routes should expose the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a contact by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update a contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a contact by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to cover bulk insert and delete in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows how these operations can be mapped to HTTP routes
    and verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Route | Verb | Description | Data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/contacts` | `POST` | Create a new contact | `email`, `name`, `company`,
    `phoneNumber`, and `city` |'
  prefs: []
  type: TYPE_TB
- en: '| `/contacts` | `GET` | Get all contacts from the system |   |'
  prefs: []
  type: TYPE_TB
- en: '| `/contacts/<id>` | `GET` | Get a particular contact |   |'
  prefs: []
  type: TYPE_TB
- en: '| `/contacts/<id>` | `PUT` | Update a particular contact | `email`, `name`,
    `company`, `phoneNumber`, and `city` |'
  prefs: []
  type: TYPE_TB
- en: '| `/contacts/<id>` | `DELETE` | Delete a particular contact |   |'
  prefs: []
  type: TYPE_TB
- en: Following the earlier table as a guide, we are going to describe our main functionality
    and test using Mocha. Mocha allows us to describe the features that we are implementing
    by giving us the ability to use a describe function that encapsulates our expectations.
    The first argument of the function is a simple string that describes the feature.
    The second argument is a function body that represents the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already created a folder called `contact-manger/tests`. In your `tests`
    folder, create another folder called `integration`. Create a file called `contact-manager/tests/integration/contact_test.js`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test file, we required our dependencies and used Chai as our assertion
    library. As you can see, besides the `describe()` function, mocha gives us additional
    methods: `before()`, `after()`, `beforeEach()`, and `afterEach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: These are hooks and they can be async or sync, but we are going to use the async
    version of them. Hooks are useful for preparing preconditions before running tests;
    for example, you can populate your database with mock data or clean it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main description body, we used three hooks: `before()`, `after()`, and
    `afterEach()`. In the `before()` hook, which will run before any of the `describe()`
    functions, we set up our server to listen on a given port, and we called the `done()`
    function when the server started listening.'
  prefs: []
  type: TYPE_NORMAL
- en: The `after()` function will run after all the `describe()` functions have finished
    running and will stop the server from running. Now, the `afterEach()` hook will
    run after each `describe()` function, and it will grant us the ability to remove
    all the contacts from the database after running each test.
  prefs: []
  type: TYPE_NORMAL
- en: The final version can be found in the code bundle of the application. You can
    still follow how we add all the necessary descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also added four to five individual descriptions that will define CRUD operations
    from the earlier table. First, we want to be able to create a new contact. Add
    the following code to the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Getting contacts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we want to get all contacts from the system. The following code should
    describe this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've also added a `before()` hook in the description. This
    is absolutely normal and can be done. Mocha permits this behavior in order to
    easily set up preconditions. We used a bulk insert, `Contact.collection.insert()`,
    to add data into MongoDB before getting all the contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a contact by ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When getting a contact by ID, we would also want to check whether the inserted
    ID meets our `ObjectId` criteria. If a contact is not found, we will want to return
    a 404 HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We used the `.create()` method. It's more convenient to use it for single inserts,
    to prepopulate the database with data. When getting a single contact by ID we
    want to ensure that it's a valid ID, so we added a test which should reflect this
    and get a `404 Not Found` response if it's invalid, or no contact was found.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also want to be able to update an existing contact with a given ID. Add
    the following code to describe this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Removing a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we''ll describe the remove contact operation (DELETE from CRUD) by
    adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After deleting a contact, the server should respond with an `HTTP 204 No Content`
    status code, meaning that the server has successfully interpreted the request
    and processed it, but no content should be returned due to the fact that the contact
    was deleted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Running our tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we will get a bunch of `HTTP 404 Not Found` status codes, because
    our routes are not implemented yet. The output should be similar to something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the contact routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''ll start implementing the contact CRUD operations. We''ll begin by
    creating our controller. Create a new file, `contact-manager/app/controllers/contact.js`,
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code does is export all methods of the controller for CRUD
    operations. To create a new contact, we use the `create()` method from the `Contact`
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: We are returning a JSON response with the newly created contact. In case of
    an error, we just call the `next()` function with the error object. We will add
    a special handler to catch all of our errors later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file for our routes, `contact-manager/app/routes/contacts.js`.
    The following lines of code should be a good start for our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we run our test now using this, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding all endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will add the rest of the routes, by adding the following code into
    the `contact-manager/app/routes/contact.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We defined all the routes and also added a callback trigger to the `contactId`
    route parameter. In Express, we can add callback triggers on route parameters
    using the `param()` method with the name of a parameter and a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback function is similar to any normal route callback, but it gets
    an extra parameter representing the value of the route parameter. A concrete example
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Following the preceding example, when :`contactId` is present in a route path,
    we can map a contact loading logic and provide the contact to the next handler.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a contact by ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to add the rest of the missing functionalities in our controller
    file, located at `contact-manager/app/controllers/contact.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function is a special case. It will get four parameter, and the
    last one will be the ID matching the triggered parameters value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting contact information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get all contacts, we are going to query the database. We will sort our results
    based on the creation date. One good practice is to always limit your returned
    dataset''s size. For that, we use a `MAX_LIMIT` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To return a single contact, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Theoretically, we'll have the :`contactId` parameter in a route definition.
    In that case, the `param` callback is triggered, populating the `req` object with
    the requested contact.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same principle is applied when updating a contact; the requested entity
    should be populated by the `param` callback. We just need to assign the incoming
    data to the contact object and save the changes into MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Removing a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing a contact should be fairly simple, as it has no dependent documents.
    So, we can just remove the document from the database, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Running the contact test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we should have implemented all the requirements for managing
    contacts on the backend. To test everything, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means that all the tests have passed successfully and we have implemented
    all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your application routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably don't want to let anyone see your contacts, so it's time to secure
    your endpoints. There are many strategies that we can use to authenticate trusted
    users in an application. We are going to use a classic, state-full e-mail and
    password based authentication. This means that the session will be stored on the
    server side.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed at the beginning of the chapter how we are going to store
    our session on the server side? We choose two integrations, one with default in-memory
    session management and one that stores sessions in MongoDB. Everything is configurable
    from the environment configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to handling authentication in Node.js, a good go-to module is
    Passport, which is a piece of authentication middleware. Passport has a comprehensive
    set of authentication strategies using a simple username-and-password combination
    for Facebook, Google, Twitter, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: We have already added this dependency to our application and made the necessary
    initializations in the express configuration file. We still need to add a few
    things, but before that, we have to create some reusable components in our backend
    application. We are going to create a helper file that will ease our interactions
    with passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the password helper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive deeper into the authentication mechanism, we need to be able
    to store in MongoDB a password hash instead of the plain password. We want to
    create a helper for this task that enables us to make operations related to passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in the `tests` folder, named `unit`. Add a new file, `contact-manager/tests/unit/password.test.js`,
    and then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main description body, we are going to add segments that represent our
    features in more detail. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Mocha also provides an `it()` function, which we are going to use to set up
    a concrete test. The `it()` function is very similar to `describe()`, except that
    we put only what the feature is supposed to do. For assertion, we are going to
    use the Chai library. Add the following code to the `tests/unit/password.test.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `passwordHelper` should also test whether a password matches the given
    hash and salt combo. For this, we are going to add the following describe method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the password helper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement our password helper in the following file: `contact-manager/app/helpers/password.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first description of our password helper describes a function that creates
    a hash from a plain password. In our implementation, we will use a key derivation
    function that will compute a hash from our password, also known as key stretching.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the `pbkdf2` function from the built-in Node.js `crypto`
    library. The asynchronous version of the function takes a plain password and applies
    an HMAC digest function. We will use `sha256` to get a derived key of a given
    length, combined with a salt through a number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use the same hashing function for both cases: when we already have
    a password hash and a salt and when we have only a plain password. Let''s see
    the final code for our hashing function. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we get if we run our tests now. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have successfully implemented our hashing function. All the
    requirements from the test case have passed. Notice that it takes up to 2 seconds
    to run the tests. Don't worry about this; it's because of the key stretching function
    taking time to generate the hash from the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to implement the `verify()` function, which checks whether
    a password matches an existing user''s password-hash-and-salt combination. From
    the description in our tests, this function accepts four parameters: the plain
    password, a hash that was generated using the third salt parameter, and a callback
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback gets two arguments: `err` and `result`. The `result` can be `true`
    or `false`. This will reflect whether the password matches the existing hash or
    not. Considering the constraints from the tests and the preceding explanation,
    we can append the following code to our `password.helpr.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By now, we should have implemented all the specifications from our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user Mongoose schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to grant access to users in the application, we need to store them
    in a MongoDB collection. We''ll create a new file called `contact-manager/app/models/user.model.js`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table gives a description of the fields in the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | The e-mail of the user. This is used to identify the user. E-mails
    will be unique in the system. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The full name of the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | This is the password provided by the user. It will not be stored
    in plaintext in the database but in a hashed form instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `passwordSalt` | Every password will be generated using a unique salt for
    the given user. |'
  prefs: []
  type: TYPE_TB
- en: '| `active` | This specifies the state of the user. It can be active or inactive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createdAt` | The date when the user was created. |'
  prefs: []
  type: TYPE_TB
- en: Describing the authentication method from the user model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll describe a user authentication method. It will check whether a user
    has valid credentials. The following file, `contact-manager/tests/integration/user.model.test.js`,
    should contain all the test cases regarding the `User` model. These lines of code
    will test the `authenticate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the authentication method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mongoose lets us add static methods to compiled models from schemas. The `authenticate()`
    method will search for a user in the database by its e-mail and use the password
    helper's `verify()` function to check whether the sent password is a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code to the `contact-manager/app/models/user.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when selecting the user from MongoDB, we explicitly selected
    the password and `passwordSalt` fields. This was necessary because we set the
    password and `passwordSalt` fields to not be selected in the query result. Another
    thing to note is that we want to remove the password and salt from the result
    when returning the user.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to authenticate in the system we are building, we need to expose some
    endpoints that will execute the necessary business logic to authenticate a user
    with valid credentials. Before jumping into any code, we are going to describe
    the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the authentication routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are only going to take a look at a partial code from the integration test
    of the authentication functionality, found in `contact-manager/tests/integration/authentication.test.js`.
    It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, we've described an `auth/signin` endpoint; it will authenticate a user using
    an e-mail-and-password combination. We are testing two scenarios. The first one
    is when a user has valid credentials and the second is when an incorrect password
    is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Passport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned Passport earlier in the chapter and added some basic logic for
    this purpose, but we still need to make a proper integration. The Passport module
    should already be installed and the session management is already in place. So
    next, we need to create a proper configuration file, `contact-manager/config/passport.js`,
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For each subsequent request, we need to serialize and deserialize the user instance
    to and from the session. We are only going to serialize the user's ID into the
    session. When subsequent requests are made, the user's ID is used to find the
    matching user and restore the data in `req.user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passport gives us the ability to use different strategies to authenticate our
    users. We are only going to use e-mail and password to authenticate a user. To
    keep everything modular, we are going to move the strategies into separate files.
    The so-called local strategy, which will be used to authenticate users using an
    e-mail and a password, is going to be in the `contact-manager/config/strategies/local.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the authentication routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have passport up and running, we can define our authentication
    controller logic and a proper route to sign in users. Create a new file called
    `contact-manager/app/controllers/authentication.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `.authenticate()` function from Passport to check a user''s
    credentials using the local strategy implemented earlier. Next, we are going to
    add the authentication route, create a new file called `contact-manager/app/routes/auth.js`,
    and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that we skipped the register user functionality, but don't worry! The final
    bundled project source code will have all of the necessary logic.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to contacts routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created all the requirements to authenticate our users. Now it's time to
    restrict access to some of the routes, so technically we are going to create a
    simple ACL. To restrict access, we are going to use a piece of middleware that
    will check whether users are authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our middleware file, `contact-manager/app/middlewares/authentication.js`.
    This should contain these lines of carefully crafted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We have already added the necessary logic to restrict users to the contact routes;
    that was when we first created them. We succeeded in adding all the necessary
    pieces of code to manage contacts and restrict access to our endpoints. Now we
    can continue and start building our Angular 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Angular 2 into our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The frontend application is going to be built using Angular 2\. At the time
    of writing this book, the project is still in beta, but it will come in handy
    to start playing around with Angular and have a good understanding of the environment.
    Most of the code will follow the official docs view of the tooling and integration
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first described our folder structure, we saw a `package.json` file
    for the client application too. Let''s take a look at it, found under the `contact-manager/public/package.json`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the necessary dependencies, just use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You will see `npm` pulling down different packages, specified in the `package.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we''ll use TypeScript in our client-side application. If you
    have installed it globally, you can use the following command to compile and watch
    for changes to your `.ts` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Only the most important parts of the application will be discussed. The rest
    of the necessary files and folders can be found in the final bundled source code.
  prefs: []
  type: TYPE_NORMAL
- en: Granting access to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have restricted access to our API's endpoints, so now we have to grant users
    sign-in functionality from the client application. I like to group the Angular
    2 application files based on their domain context. So, for example, all our authentication,
    registration, and business logic should go into a separate folder; we can call
    it `auth`.
  prefs: []
  type: TYPE_NORMAL
- en: If your module directory grows, it's good practice to break it down into separate
    folders based on their context by type. There is no magic number for the file
    count. Usually, you will get a good feeling when it's time to move files around.
    Your files should always be easy to locate and give you enough information from
    their placement in a certain context.
  prefs: []
  type: TYPE_NORMAL
- en: AuthService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use `AuthService` to implement the data access layer and make
    calls to the backend. This service is going to be the bridge between our API''s
    sign-in and register features. Create a new file called `contact-manager/src/auth/auth.service.ts`,
    and add the following TypeScript code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We import the necessary modules, define the `AuthService` class, and export
    it. The Injectable marker metadata will mark our class to be available to be injected.
    In order to communicate with the backend, we use the HTTP service. Don't forget
    to add the `HTTP_PROVIDERS` when bootstrapping the application so that the service
    is available to be injected in the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign in a user, we are going to add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `.map()` operator to transform the response into a JSON file.
    When performing HTTP requests, this will return an `Observable`. You have probably
    already figured it out—we are going to use **RxJs** (**Reactive Extensions**)
    heavily, which is a third-party library favored by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: RxJs implements asynchronous observable pattern. In other words, it enables
    you to work with asynchronous data streams and apply different operators. Observables
    are used widely in Angular applications. At the time of writing this book, Angular
    2 exposes a stripped-down version of the `Observable` module from RxJs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry; we''ll get familiar with this technique and the benefits of it
    as we dive further into the book. Now let''s continue with the rest of the missing
    methods we want to expose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We added the `register()` method to our service, which will handle user registration.
    Also note that we moved our serialization into a separate private method. I've
    left this method in the same class so that it's easier to follow, but you can
    move it into a helper class.
  prefs: []
  type: TYPE_NORMAL
- en: User sign-in component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a start, we are going to implement the sign-in component. Let''s create
    a new file called `contact-manager/public/src/auth/sigin.ts` and add the following
    lines of TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to add the `Component` annotation before our `Signin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Signin` component is going to be our sign-in form and it uses the `AuthService`
    to communicate with the backend. In the component's template, we are using local
    variables marked with a `#` sign for the email and password fields.
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier, the HTTP service returns an `Observable` when making a request.
    This is the reason we can subscribe to the response generated by the requests
    made from our `AuthService`. On successful authentication, the user is redirected
    to the default home path.
  prefs: []
  type: TYPE_NORMAL
- en: The `Register` component will look similar to the `Signin` component, so there
    is no need to detail this scenario. The final version of the `auth` module will
    be available in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Custom HTTP service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to restrict access to our API endpoints, we have to make sure that,
    if a request is unauthorized, we redirect the user to the sign-in page. Angular
    2 has no support for Interceptors and we don't want to add a handler for each
    request we integrate into our services.
  prefs: []
  type: TYPE_NORMAL
- en: A more convenient solution would be to build our own custom service on top of
    the built-in HTTP service. We could call it `AuthHttp`, from authorized HTTP requests.
    Its purpose would be to check whether a request returned a `401 Unauthorized HTTP
    status` code.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to take this thought even further and bring a hint of reactive
    programming, because we are already using RxJS. So, we can benefit from the full
    set of functionalities it provides. Reactive programming is oriented around data.
    Streams of data propagate in your application and it reacts to those changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to business and start building our custom service. Create a file
    called `contact-manager/public/src/auth/auth-http.ts`. We are going to add a few
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things we imported at the top of the file. We'll need all of
    them in this module. We defined a public property named `unauthorized`, which
    is a Subject. A **Subject** is both an `Observable` and `Observer`. This means
    that we can subscribe our subject to a backend data source and also all observers
    can subscribe to the subject.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the subject will be a proxy between our data source and all the
    subscribed observers. If a request is unauthorized, all subscribers get notified
    with the change. This enables us to just subscribe to the subject and redirect
    the user to the sign-in page when we detect an unauthorized request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To succeed in doing this, we have to add a few more methods to our `AuthHttp`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method creates a new request with the desired `RequestOptions`
    and invokes the `request` method from the base HTTP service. Additionally, the
    `catch` method captures all requests with status code not 200-level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this technique, we can send the unauthorized request to all subscribers
    by using our `unauthorized` subject. Now that we have our private `request` method,
    we just need to add the rest of the public HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: I've added only the most commonly used methods; the rest is available in the
    full version. The preceding code calls our request method and sets the necessary
    options for each request type. Theoretically, we have created a façade to handle
    unauthorized requests.
  prefs: []
  type: TYPE_NORMAL
- en: I think we've made good progress and it's time to move on to the rest of the
    modules of our contact manager application.
  prefs: []
  type: TYPE_NORMAL
- en: The Contact module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module will hold all the necessary files to manage contacts. As we discussed
    earlier, we are grouping our files by context, related to their domain. The starting
    point of our module will be the data layer, which means we'll start implementing
    the necessary service.
  prefs: []
  type: TYPE_NORMAL
- en: Contact service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our contact service will have basic CRUD operations and Observable streams to
    subscribe to. This implementation will use the backend API built using Node.js
    and Express, but it can be converted anytime to a WebSocket-based API with little
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service file called `contact-manager/src/contact/contact.service.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the contact service, we have a few moving parts. First we defined our Observables
    so that any other component or module can subscribe and start getting the streams
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we declared a private data store. This is where we are going to store
    our contacts. This is good practice as you can easily return all resources from
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in our service, we are going to keep private the returned Observers when
    new instances of Observables are generated. Using the Observers, we can push new
    data streams to our Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our public methods, we are going to expose the get all contacts, get one,
    update, and delete functionalities. To get all contacts, we are going to add the
    following method to our `ContactService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We use our custom build `AuthHttp` service to load data from our Express application.
    When a response is received, we transform it into a JSON file, and after that,
    we just instantiate a new contact for each entity from the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of returning the whole `Observable` from the HTTP service, we use our
    internal data store to persist all the contacts. After we have successfully updated
    the data store with the new data, we push the changes to our `contactsObserver`.
  prefs: []
  type: TYPE_NORMAL
- en: Any component that is subscribed to our stream of contacts will get the new
    values from the `Observable` data stream. In this way, we always keep our components
    synced using one single point of entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of our public method''s logic is the same, but we still have a few distinct
    elements, for example, the update method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `update` method is almost the same as the `create()` method, however it
    takes the contact's ID as the URL param. Instead of pushing new values down a
    data stream, we return the `Observable` from the `Http` service, in order to apply
    operations from the caller module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we would like to make changes directly on the `datastore` and push
    the new values through the `contacts` data stream, we could showcase this in the
    remove contact method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We simply use the `map()` function to find the contact we deleted and remove
    it from the internal store. Afterwards, we send new data to the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Contact component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have moved everything related to the contact domain, we can define a
    main component in our module. Let''s call it `contact-manager/public/src/contact/contact.component.ts`.
    Add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Our component has no logic associated with it, but we used the `RouterConfig`
    annotation. The route config decorator takes an array of routes. Each path specified
    in the config will match the browser's URL. Each route will load the mounted component.
    In order to reference routes in the template, we need to give them a name.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the most appealing part is that we can take this component with the configured
    routes and mount it on another component to have `Child`/`Parent` routes. In this
    case, it becomes nested routing, which is a very powerful feature added to Angular
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Our application's routes will have a tree-like structure; other components load
    components with their configured routes. I was pretty amazed by this feature because
    it enables us to truly modularize our application and create amazing, reusable
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: List contacts component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous component, we used three different components and mounted them
    on different routes. We are not going to discuss each of them, so we will choose
    one. As we have already worked with forms in the `Signin` component, let's try
    something different and implement the list contacts functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `contact-manager/public/src/contact/contact-list.component.ts`
    and add the following code for your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In our component's `ngOnInit()`, we subscribe to the contacts data stream. Afterwards,
    we retrieve all the contacts from the backend. In the template, we use `ngFor`
    to iterate over the dataset and display each contact.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a contact component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can list contacts in our application, we should also be able to
    add new entries. Remember that earlier we used the `RouterLink` to be able to
    navigate to the `CreateContact` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding route will load the `CreateContactComponent`, which will enable
    us to add new contact entries into our database, through the Express API. Let''s
    create a new component file `public/src/contact/components/contact-create.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using an embedded template, we are using an external template file
    that is configured using the `templateUrl` property in the component annotation.
    There are pros and cons for each situation. The benefits of using an external
    template file would be that you can reuse the same file for more than one component.
  prefs: []
  type: TYPE_NORMAL
- en: The downfall, at the moment of writing the book, in Angular 2 is that it's hard
    to use relative paths to your template files, so this would make your components
    less portable. Also I like to keep my templates short, so they can fit easily
    inside the component, so in most cases I'll probably use embedded templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the template before further discussing the component,
    `public/src/contact/components/contact-form.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the template we are using a `onSubmit()` method from the component to piggyback
    the form submission and in this case create a new contact and store the data in
    MongoDB. When we successfully create the contact we want to navigate to the `ContactList`
    route.
  prefs: []
  type: TYPE_NORMAL
- en: We are not using local variables, instead we are using two-way data binding
    with the `ngModel` for each input, mapped to the properties of the contact object.
    Now, each time the user changes the inputs value, this is stored in the contact
    object and on submit it's sent across the wire to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: The `RouterLink` is used to construct the navigation to the `ContactList` component
    from the template. I've left a small improvement, the view title will be the same
    both for creating and editing, more precisely "Add new contact", and I'll let
    you figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing contact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When editing a contact, we want to load a specific resource by ID from the
    backend API and make changes for that contact. Lucky for us this is quite simple
    to achieve in Angular. Create a new file `public/src/contact/components/contact-edit.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We are not so far away from the `ContactCreateComponent`, the structure of the
    class is almost the same. Instead of the `Router`, we are using `RouteParams`
    to load the ID from the URL and retrieve the desired contact from the Express
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We subscribe to the contact `Observable` returned by the `ContactService` to
    get the new data. In other words our component will react to the data stream and
    when the data is available it will display it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: When submitting the form, we update the contact persisted in MongoDB and change
    the view's `contact` object with the freshly received data from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added all the necessary modules into our application. We should also
    take a final look at our main app component, found under the following path—`contact-manager/public/src/app.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We mount all the components to their specific routes. Also, when we mount the
    `Contact` component, we'll bring in all the configured routes from the component.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be notified when a request is unauthorized, we subscribe to the
    `AuthHttp` service's `unauthorized` data stream. If a request needs authentication,
    we redirect the user to the sign-in page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boot file for our application will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We import and define the necessary providers and also add the operators we used
    from RxJs. This is because Angular, by default, uses only a stripped-down version
    of the Observable module.
  prefs: []
  type: TYPE_NORMAL
- en: Through the contact module we used a custom class named `Contact`, which plays
    the role of a `Contact` model. This will be instantiated any time we want to make
    sure we are working with a contact entity. Besides, the nice thing about TypeScript
    is that it enables us to use structured code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes come in handy when we want to have initial values, for example, in
    our components we used a `contact.image` property to display a contact''s profile
    image. This was not implemented in the backend, so we use a mock URL for an image.
    Let''s see the `Contact` class, `public/src/contact/contact.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see we just define what properties a contact instance can have and
    create a default value for the `image` property. Arguments passed to the `constructor`
    marked with `?` are optional.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, we should have everything in place; in case you missed something,
    you can check out the final version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key takeaways from this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building backend web services using Node.js, Express, and MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests first, before actually implementing functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing our API routes using Passport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Angular 2 and Express communicate and work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting into Reactive Extensions and reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom Angular HTTP service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this rather introductory chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We went full stack, right from implementing our backend logic to learning to
    write tests before actual implementations. We exposed a RESTful route for our
    resources from MongoDB. We also built a small Angular 2 frontend application that
    interacts with the web server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive deeper into MongoDB and start working with monetary
    data. It should be a fun ride!
  prefs: []
  type: TYPE_NORMAL
