<html><head></head><body>
		<div id="_idContainer068">
			<h1 id="_idParaDest-260" class="chapter-number"><a id="_idTextAnchor267"/>10</h1>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor268"/>Building Web Applications with Express</h1>
			<p>Express is the most popular web framework for JavaScript and has been the de-facto standard for many years. It is a very minimalistic framework, very easy to learn, and provides a lot of flexibility to build <span class="No-Break">web applications.</span></p>
			<p>In this chapter, we will start with the most basic “hello world” application to build a solid and well-tested REST API application. We will explore in detail all the critical components of Express, including request and response, middleware, and routing. We will also learn how to use the most common Express middleware and how to build our <span class="No-Break">own middleware.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Serving static files for <span class="No-Break">your project</span></li>
				<li>Building a server-rendered landing page using <span class="No-Break">template engines</span></li>
				<li>Building a typical CRUD REST API application <span class="No-Break">with Express</span></li>
				<li>Using the most common Express middleware, including <span class="No-Break">third-party libraries</span></li>
				<li>Building your <span class="No-Break">own middleware</span></li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor269"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners "/></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/8QyDZVa7CNg"><span class="No-Break">https://youtu.be/8QyDZVa7CNg</span></a></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor270"/>Getting familiar with the Express library</h1>
			<p>Express is defined<a id="_idIndexMarker539"/> on its own<a id="_idIndexMarker540"/> website (<a href="https://expressjs.com/">https://expressjs.com/</a>) <span class="No-Break">as follows:</span></p>
			<p class="author-quote">Fast, unopinionated, minimalist web framework for Node.js</p>
			<p>So, the good news is that we have a lot of freedom to build our application. The bad news is that we must make a lot of decisions, and we must be careful to not <span class="No-Break">make mistakes.</span></p>
			<p>Express is very minimalistic<a id="_idIndexMarker541"/> in comparison with other web frameworks, so we have to add third-party libraries or build our own abstractions when needed. Express has a very active community, so we can find a lot of libraries to solve <span class="No-Break">common problems.</span></p>
			<p>Additionally, the official documentation is of great quality and there are plenty of resources to learn more about Express, which makes Express a great choice <span class="No-Break">for beginners.</span></p>
			<p>As Express is an unopinionated framework, when you follow a tutorial or a course you will find that sometimes the code is not consistent and doesn’t follow the same patterns. This is because you have a lot of freedom in Express, and over time you will develop your own patterns and your own way of building applications that best <span class="No-Break">fits you.</span></p>
			<p>In this book, we will use Express version 4.18.3, but any Express 4.x version should be fine as well. We will use Node.js version 20.11.0. Both are the latest versions available at the time <span class="No-Break">of writing.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor271"/>Installing Express</h2>
			<p>To install Express, we must run<a id="_idIndexMarker542"/> the following command in a new <span class="No-Break">Node.js project:</span></p>
			<pre class="console">
npm install express@4</pre>			<p>You don’t need any additional configuration; just install it and you are ready <span class="No-Break">to go.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor272"/>Hello World</h2>
			<p>Let’s start with a simple<a id="_idIndexMarker543"/> example, a Hello World application. Create a new file called <strong class="source-inline">helloWorld.js</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import express from 'express'
const app = express()
const port = 3000
app.get('/', (req, res) =&gt; {
  res.send('Hello World from Express!')
})
app.listen(port, () =&gt; {
  console.log(`Hello World app listening on port ${port}`)
})</pre>			<p>Very simple, right? Let’s break <span class="No-Break">it down:</span></p>
			<ol>
				<li>We import the Express library and create an instance of the <span class="No-Break">Express application.</span></li>
				<li>We define a route for the <strong class="source-inline">/</strong> root path and we send a response with the text <strong class="source-inline">Hello World </strong><span class="No-Break"><strong class="source-inline">from Express!</strong></span><span class="No-Break">.</span></li>
				<li>We start the server and listen on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">3000</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>To run the application, we use the <span class="No-Break">following command:</span></p>
			<pre class="console">
node helloWorld.js</pre>			<p>If everything is OK, you should see the <span class="No-Break">following output:</span></p>
			<pre class="console">
Hello World app listening on port 3000</pre>			<p>Now, if you open your browser and go to <strong class="source-inline">http://localhost:3000</strong>, you should see the text <strong class="bold">Hello World from Express!</strong>, as shown in the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker544"/></span><span class="No-Break"> screenshot:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B21678_10_1.jpg" alt="Figure 10.1 – Web browser screenshot showing a simple Express project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Web browser screenshot showing a simple Express project</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor273"/>Using the generator</h2>
			<p>Express has a command-line tool<a id="_idIndexMarker545"/> to generate a basic application. To use it, we must run the <span class="No-Break">following command:</span></p>
			<pre class="console">
npx express-generator@4</pre>			<p>This will generate a new application with many files and folders. I recommend you create a new folder and run the command there, so you don’t mess up your <span class="No-Break">current project.</span></p>
			<p>The output on execution should <a id="_idIndexMarker546"/>be something like <span class="No-Break">the following:</span></p>
			<pre class="console">
   create : public/
   create : public/javascripts/
   create : public/images/
   create : public/stylesheets/
   create : public/stylesheets/style.css
   create : routes/
   create : routes/index.js
   create : routes/users.js
   create : views/
   create : views/error.jade
   create : views/index.jade
   create : views/layout.jade
   create : app.js
   create : package.json
   create : bin/
   create : bin/www
   install dependencies:
     $ npm install
   run the app:
     $ DEBUG=generated:* npm start</pre>			<p>Then the next step is to install <span class="No-Break">the dependencies:</span></p>
			<pre class="console">
npm install</pre>			<p>Finally, we can start <span class="No-Break">the application:</span></p>
			<pre class="console">
npm start</pre>			<p>If everything is OK, you should see the <span class="No-Break">following output:</span></p>
			<pre class="console">
&gt; generated@0.0.0 start
&gt; node ./bin/www
GET / 304 125.395 ms - -
GET /stylesheets/style.css 304 1.265 ms - -
GET / 304 11.043 ms - -
GET /stylesheets/style.css 304 0.396 ms - -
GET /ws 404 11.822 ms - 1322</pre>			<p>If you access <strong class="source-inline">http://localhost:3000</strong> in the browser, you should<a id="_idIndexMarker547"/> see the <span class="No-Break">following page:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B21678_10_2.jpg" alt="Figure 10.2 – Web browser screenshot showing the Express app generated using the express-generator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Web browser screenshot showing the Express app generated using the <strong class="source-inline">express-generator</strong></p>
			<p>Feel free to explore the generated code, but don’t worry if you don’t understand everything as we will cover all the important parts in the following sections. Note that also the route <a href="http://localhost:3000/users">http://localhost:3000/users</a> is working and if you try any other route, you will get a 404 error, as with <a href="http://localhost:3000/invented">http://localhost:3000/invented</a> <span class="No-Break">for example.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor274"/>Debugging</h2>
			<p>Now, let me show another<a id="_idIndexMarker548"/> cool thing that the Express generator includes and that we will use in our project later. If you start the application with the command <strong class="source-inline">DEBUG=* npm start</strong> or <strong class="source-inline">set DEBUG=* &amp;&amp; npm start</strong> (if you use Windows) in the terminal output will be more verbose and you will see a lot of information about the requests <span class="No-Break">and responses:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B21678_10_3.jpg" alt="Figure 10.3 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Terminal screenshot</p>
			<p>This is because Express and many other<a id="_idIndexMarker549"/> dependencies use the <strong class="source-inline">debug</strong> library (<a href="https://www.npmjs.com/package/debug">https://www.npmjs.com/package/debug</a>) to log information. By using the <strong class="source-inline">DEBUG=*</strong> environment variable, we are telling to debug library to print the information related to all the namespaces. But we can be more selective and limit the scope for Express, for example, by using the <strong class="source-inline">DEBUG=express:* npm start</strong> <span class="No-Break">environment variable.</span></p>
			<p>Now, that we have a basic understanding of Express, it is time to explore how we can use template engines to render the HTML pages that will be sent to <span class="No-Break">the browser.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor275"/>Understanding template engines</h1>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we learned<a id="_idIndexMarker550"/> the difference between <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>) and <span class="No-Break">server-side</span><span class="No-Break"><a id="_idIndexMarker551"/></span><span class="No-Break"> rendering.</span></p>
			<p>Express provides a way to render HTML pages using template engines. This is the key feature to build server-side rendered applications <span class="No-Break">with Express.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor276"/>Choosing a template engine</h2>
			<p>The first thing that we must do is to choose<a id="_idIndexMarker552"/> a template engine. There are many options available. The most popular<a id="_idIndexMarker553"/> option historically was Jade (<a href="https://www.npmjs.com/package/jade">https://www.npmjs.com/package/jade</a>), but it was renamed<a id="_idIndexMarker554"/> to Pug (<a href="https://www.npmjs.com/package/pug">https://www.npmjs.com/package/pug</a>). You can find many tutorials and examples by searching using <span class="No-Break">both names.</span></p>
			<p>I personally prefer <strong class="bold">Embedded JavaScript templating</strong> (<strong class="bold">ejs</strong>) (<a href="https://www.npmjs.com/package/ejs">https://www.npmjs.com/package/ejs</a>) for its simplicity<a id="_idIndexMarker555"/> and because it is well <a id="_idIndexMarker556"/>documented. Over time, you will get more familiar with the template engines and will be able to choose the one that better fits <span class="No-Break">your needs.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor277"/>Rendering a template</h2>
			<p>So, going back to our hello world<a id="_idIndexMarker557"/> example, let’s create a new file called <strong class="source-inline">helloWorldTemplate.js</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import express from ('express')
const app = express()
const port = 3000
app.set('view engine', 'ejs')
app.get('/', (req, res) =&gt; {
  res.render('index', {
    title: 'This is an Express app',
    subtitle: 'using EJS as template engine'})
})
app.listen(port, () =&gt; {
  console.log(`Application running in http://localhost:${port}`)
})</pre>			<p>Now, we have to create<a id="_idIndexMarker558"/> a new folder called <strong class="source-inline">views</strong>, inside of which we create a new file called <strong class="source-inline">index.ejs</strong> with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
  &lt;h2&gt;&lt;%= subtitle %&gt;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<p>As you can see, the template engine uses the <strong class="source-inline">&lt;%=</strong> and <strong class="source-inline">%&gt;</strong> tags to interpolate the values. In this case, we are passing the <strong class="source-inline">title</strong> variable to <span class="No-Break">the template.</span></p>
			<p>Finally, we have to install the <span class="No-Break"><strong class="source-inline">ejs</strong></span><span class="No-Break"> dependency:</span></p>
			<pre class="console">
npm install ejs@3</pre>			<p>Then we start the application <span class="No-Break">as follows:</span></p>
			<pre class="console">
node helloWorldTemplate.js</pre>			<p>If you access <strong class="source-inline">http://localhost:3000</strong> in the browser, you should<a id="_idIndexMarker559"/> see the <span class="No-Break">following displayed:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B21678_10_4.jpg" alt="Figure 10.4 – Web browser screenshot showing the templeate rendered for the end user."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Web browser screenshot showing the templeate rendered for the end user.</p>
			<p>Additionally, if you access <strong class="source-inline">view-source:http://localhost:3000/</strong>, you will see the raw HTML that Express is sending to <span class="No-Break">the browser:</span></p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;This is an Express app&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;This is an Express app&lt;/h1&gt;
  &lt;h2&gt;using EJS as template engine&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<p>As you can see the template engine<a id="_idIndexMarker560"/> is interpolating the values and generating the HTML <span class="No-Break">for us.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor278"/>Understanding the process</h2>
			<p>Now, let’s understand<a id="_idIndexMarker561"/> what is actually happening in <span class="No-Break">the code:</span></p>
			<pre class="source-code">
app.set('view engine', 'ejs')</pre>			<p>The preceding line tells Express that we are going to use <strong class="source-inline">ejs</strong> as our template engine, so now we can use <strong class="source-inline">res.render</strong> to render <span class="No-Break">the template.</span></p>
			<pre class="source-code">
res.render('index', {
    title: 'This is an Express app',
    subtitle: 'using EJS as template engine'
})</pre>			<p>In the preceding code, the <strong class="source-inline">res.render</strong> method receives two parameters. The first one is the name of the template, in this case, <strong class="source-inline">index</strong> (<strong class="source-inline">views/index.ejs</strong>), and the second one is the data that we want to interpolate in <span class="No-Break">the template.</span></p>
			<p>Then the template engine will replace the <strong class="source-inline">&lt;%= title %&gt;</strong> and <strong class="source-inline">&lt;%= subtitle %&gt;</strong> tags with the values that we are passing in the second parameter of the <span class="No-Break"><strong class="source-inline">res.render</strong></span><span class="No-Break"> method.</span></p>
			<p>In real-world applications, the data that we pass to the template will be dynamic; for example, the data that we get from a database or an external API. But for now, we are going to use static data to keep the <span class="No-Break">example simple.</span></p>
			<p>In the next section, we will learn how we can take advantage of the request object to build more rich and <span class="No-Break">powerful applications.</span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor279"/>Mastering requests</h1>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we learned all the theory<a id="_idIndexMarker562"/> around HTTP requests and responses. Here, we will cover how to handle these <span class="No-Break">with Express.</span></p>
			<p>In this section, we are going to focus on this snippet <span class="No-Break">of pseudo-code:</span></p>
			<pre class="source-code">
import express from ('express')
const app = express()
app.method(route, handler)</pre>			<p>We have three elements here <span class="No-Break">to understand:</span></p>
			<ul>
				<li><strong class="source-inline">method</strong>, that is, the HTTP method that we want to handle, for example, <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and <span class="No-Break">so on</span></li>
				<li><strong class="source-inline">route</strong>, that is, the path that we want to handle, for example, <strong class="source-inline">/</strong>, <strong class="source-inline">/users</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">/users/:id</strong></span></li>
				<li><strong class="source-inline">handler</strong>, that is, the callback function that will be executed when <strong class="source-inline">method</strong> and <span class="No-Break"><strong class="source-inline">route</strong></span><span class="No-Break"> match</span></li>
			</ul>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor280"/>HTTP methods</h2>
			<p>Express provides<a id="_idIndexMarker563"/> a method for each HTTP<a id="_idIndexMarker564"/> method. There are many out there (<strong class="source-inline">get</strong>, <strong class="source-inline">post</strong>, <strong class="source-inline">put</strong>, <strong class="source-inline">head</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">options</strong>, <strong class="source-inline">trace</strong>, <strong class="source-inline">copy</strong>, <strong class="source-inline">lock</strong>, <strong class="source-inline">mkcol</strong>, <strong class="source-inline">move</strong>, <strong class="source-inline">purge</strong>, <strong class="source-inline">propfind</strong>, <strong class="source-inline">proppatch</strong>, <strong class="source-inline">unlock</strong>, <strong class="source-inline">report</strong>, <strong class="source-inline">mkactivity</strong>, <strong class="source-inline">checkout</strong>, <strong class="source-inline">merge</strong>, <strong class="source-inline">m-search</strong>, <strong class="source-inline">notify</strong>, <strong class="source-inline">subscribe</strong>, <strong class="source-inline">unsubscribe</strong>, <strong class="source-inline">patch</strong>, <strong class="source-inline">search</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">connect</strong></span><span class="No-Break">).</span></p>
			<p>The most common are <strong class="source-inline">get</strong>, <strong class="source-inline">post</strong>, <strong class="source-inline">put</strong>, and <strong class="source-inline">delete</strong>, so we are going to focus <span class="No-Break">on them:</span></p>
			<pre class="source-code">
app.get ('/', () =&gt; {})
app.post('/', () =&gt; {})
app.put('/', () =&gt; {})
app.delete('/', () =&gt; {})</pre>			<p>If you want to manage all the HTTP methods<a id="_idIndexMarker565"/> in the same route, you can use<a id="_idIndexMarker566"/> the <span class="No-Break"><strong class="source-inline">all</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
app.all('/', () =&gt; {})</pre>			<h2 id="_idParaDest-274"><a id="_idTextAnchor281"/>Routes</h2>
			<p>The routes are very<a id="_idIndexMarker567"/> flexible<a id="_idIndexMarker568"/> and can be dynamic. We can define them in different ways, including <span class="No-Break">regular expressions.</span></p>
			<h3>Static paths</h3>
			<p>Static paths are the<a id="_idIndexMarker569"/> most common<a id="_idIndexMarker570"/> way of defining routes. They are used to handle requests to a specific path, for example, <strong class="source-inline">/</strong>, <strong class="source-inline">/users</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">/user/me</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/', () =&gt; {})
app.get('/users', () =&gt; {})
app.get('/user/me', () =&gt; {})</pre>			<h3>Dynamic parameters</h3>
			<p>Dynamic parameters are used<a id="_idIndexMarker571"/> to handle<a id="_idIndexMarker572"/> the requests t<a id="_idTextAnchor282"/>o a specific path. We can use the <strong class="source-inline">:</strong> character to define a dynamic parameter, such as <strong class="source-inline">/users/:id</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">/users/:id/profile</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/users/:id', () =&gt; {})</pre>			<p>In this case, <strong class="source-inline">:id</strong> is a dynamic parameter, so it will match with any value, including <strong class="source-inline">/users/1</strong>, <strong class="source-inline">/users/peter</strong>, <strong class="source-inline">/users/jane-doe</strong>, and <span class="No-Break">so on.</span></p>
			<p>You can even combine static and dynamic parameters, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/users/:id/profile</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/users/:id/profile', () =&gt; {})</pre>			<p>The preceding example will resolve requests to <strong class="source-inline">/users/1/profile</strong>, <strong class="source-inline">/users/peter/profile</strong>, <strong class="source-inline">/users/jane-doe/profile</strong>, and <span class="No-Break">so on.</span></p>
			<p>This pattern is quite common in transportation apps, for example, where you can have a route such as <strong class="source-inline">/users/:id/rides/:rideId</strong> to get the details of a specific ride, or when you book tickets for a flight using a route such as <strong class="source-inline">/flights/from/:originCity/to/:destinationCity</strong>. Express will provide the values<a id="_idIndexMarker573"/> of the dynamic<a id="_idIndexMarker574"/> parameters in the <span class="No-Break"><strong class="source-inline">req.params</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
app.get('/users/:id', (req, res) =&gt; {
    const { originCity, destinationCity } = req.params
    res.send(`You are flying from ${originCity} to ${destinationCity}`)
})</pre>			<h3>Optional parameters</h3>
			<p>The optional parameters<a id="_idIndexMarker575"/> are used to handle the requests<a id="_idIndexMarker576"/> to a specific path, but the parameter is optional. This can be done with the <strong class="source-inline">?</strong> character, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/invoice/:id?</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/invoice/:id?', (req, res) =&gt; {
    const id = parseInt(req.params.id)
    if (id) {
        res.send(`You are looking for the invoice with id ${id}`)
    } else {
        res.send(`You are looking for all the invoices`)
    }
})</pre>			<p>In this case the <strong class="source-inline">:id</strong> parameter is optional, so it will match with <strong class="source-inline">/invoice</strong>, <strong class="source-inline">/invoice/167</strong>, <strong class="source-inline">/invoice/G123S8123SD123MJ</strong>, and <span class="No-Break">so on.</span></p>
			<h3>Regular expressions</h3>
			<p>We can use regular expressions<a id="_idIndexMarker577"/> to define routes. This is quite useful when<a id="_idIndexMarker578"/> we want to match the route using predictable patterns – for example, <strong class="source-inline">/.*fly$/</strong> will identify any text that ends <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">fly</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get(/.*fly$/, (req, res) =&gt; {
  res.send(`Match with any route that ends with fly`)
})</pre>			<p>The preceding route will match with <strong class="source-inline">/butterfly</strong>, <strong class="source-inline">/dragonfly</strong>, <strong class="source-inline">/fly</strong>, <strong class="source-inline">/mcfly</strong>, and so on. Let’s create a less <span class="No-Break">exotic example:</span></p>
			<pre class="source-code">
app.get('/msg/:id/:action(edit|delete)', (req, res, next) =&gt; {
  res.send(`You request the action ${req.params.action} for the message ${req.params.id}`);
});</pre>			<p>In this case, the route<a id="_idIndexMarker579"/> will match with <strong class="source-inline">/msg/1/edit</strong>, <strong class="source-inline">/msg/1/delete</strong>, and <span class="No-Break">so on.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you’re unfamiliar with regular expressions, don’t worry: you can use the other options to define your routes. But if you want to explore regular expressions more deeply, I recommend you to try <em class="italic">Regular Expressions </em><span class="No-Break"><em class="italic">101</em></span><span class="No-Break"> (</span><a href="https://regex101.com/"><span class="No-Break">https://regex101.com/</span></a><span class="No-Break">).</span></p>
			<h3>Query params</h3>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we learned<a id="_idIndexMarker580"/> about the different parts<a id="_idIndexMarker581"/> of the URL and saw that the query params are those parts that start with <strong class="source-inline">?</strong>. These are used to send extra information to the server. For example, in the URL <strong class="source-inline">/films?category=scifi&amp;director=George+Lucas</strong> we are sending two query params, <strong class="source-inline">category</strong> and <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">director</strong></span><span class="No-Break">.</span></p>
			<p>We can capture the query params in the <strong class="source-inline">req.query</strong> object to use them in <span class="No-Break">our routes:</span></p>
			<pre class="source-code">
app.get('/films', (req, res) =&gt; {
    const { category, director } = req.query
    res.send(`You are looking for films with category ${category} and director ${director}`)
})</pre>			<p>It is important to note that query params are optional, meaning that requests might not have any query param at all. In that<a id="_idIndexMarker582"/> case, the <strong class="source-inline">req.query</strong> object<a id="_idIndexMarker583"/> would <span class="No-Break">be empty.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">URL fragments (i.e., <strong class="source-inline">/mypath#fragment</strong>) are not part of requests and will not be included as such by the browser, so we can’t capture them. See https://github.com/expressjs/express/issues/1083 for <span class="No-Break">more info.</span></p>
			<h3>The importance of order</h3>
			<p>The routes are registered <a id="_idIndexMarker584"/>in the order that you defined them, which allows Express to avoid conflicts between routes. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
app.get('/users/:id', () =&gt; {
    res.send(`You are looking for the user with id ${req.params.id}`)
})
app.get('/users/me', () =&gt; {
    res.send(`You are looking for the current user`)
})</pre>			<p>If you try to access <strong class="source-inline">/users/me</strong>, you will get the message <strong class="source-inline">You are looking for the user with id me</strong> because the <strong class="source-inline">/users/:id</strong> route is registered first, so it will match with <strong class="source-inline">/users/me</strong> and the <strong class="source-inline">me</strong> value will be stored in the <span class="No-Break"><strong class="source-inline">req.params.id</strong></span><span class="No-Break"> property.</span></p>
			<p>You can solve this issue by shifting the order of <span class="No-Break">the routes:</span></p>
			<pre class="source-code">
app.get('/users/me', () =&gt; {})
app.get('/users/:id', () =&gt; {})</pre>			<p>In big projects, this can become<a id="_idIndexMarker585"/> a problem if you don’t have a good strategy to define the routes. This is also a good reason to include automated tests in your project to avoid accidental misconfigurations <span class="No-Break">of routes.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor283"/>Handlers</h2>
			<p>Handlers are the<a id="_idIndexMarker586"/> functions<a id="_idIndexMarker587"/> that are executed when a request matches with a route. While a handler is a simple function with three parameters (<strong class="source-inline">req</strong>, <strong class="source-inline">res</strong>, and <strong class="source-inline">next</strong>), it has the big responsibility of handling the response to the request or delegating the request to <span class="No-Break">other handlers:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.send("Hello World")
})</pre>			<p>Let’s see the parameters of the handler in <span class="No-Break">more detail.</span></p>
			<h3>request</h3>
			<p>The request object (<strong class="source-inline">req</strong>) contains all the information<a id="_idIndexMarker588"/> about the request, including<a id="_idIndexMarker589"/> the parameters, IP, headers, body, and so on. If you use other libraries that extend the capabilities of Express, very often you will find more properties in <span class="No-Break">this object.</span></p>
			<p>You can find more information about the request object<a id="_idIndexMarker590"/> in the Express <span class="No-Break">documentation (</span><a href="https://expressjs.com/en/4x/api.html#req"><span class="No-Break">https://expressjs.com/en/4x/api.html#req</span></a><span class="No-Break">).</span></p>
			<h3>response</h3>
			<p>The response object (<strong class="source-inline">res</strong>) contains all the methods<a id="_idIndexMarker591"/> to handle the<a id="_idIndexMarker592"/> response of the request, including simple methods like <strong class="source-inline">send</strong> or <strong class="source-inline">json</strong> to more complex methods like download <span class="No-Break">or redirect.</span></p>
			<p>In the following section, we will learn more about the response <span class="No-Break">object capabilities.</span></p>
			<h3>next</h3>
			<p>The next function (<strong class="source-inline">next</strong>) is used to delegate the request<a id="_idIndexMarker593"/> to the next handler. This<a id="_idIndexMarker594"/> is useful when you want to split the logic of the handler into multiple functions or delegate <span class="No-Break">error management.</span></p>
			<p>We will learn both strategies in the next two sections, when we will discuss the middleware pattern<a id="_idIndexMarker595"/> and <span class="No-Break">mastering responses.</span></p>
			<p>In the next section, we will learn how we can take advantage of the response object and how to customize the responses based on many different scenarios, such as HTTP redirection, HTTP header customization, <span class="No-Break">and more.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor284"/>Mastering responses</h1>
			<p>Responses are the way by which the server<a id="_idIndexMarker596"/> communicates back to the client after a request, so it is crucial to understand how to manage them. In this section, we will learn about adding headers, status codes, redirects, sending data, and <span class="No-Break">sending files.</span></p>
			<p>You will discover the available methods when you start to build more complex applications. You can find more information about<a id="_idIndexMarker597"/> the response object in the Express <span class="No-Break">documentation (</span><a href="https://expressjs.com/en/4x/api.html#res"><span class="No-Break">https://expressjs.com/en/4x/api.html#res</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor285"/>Header management</h2>
			<p>Headers are used<a id="_idIndexMarker598"/> to send extra information<a id="_idIndexMarker599"/> about the response. Express handles headers by using the <strong class="source-inline">set</strong> method, which receives two parameters, the name of the header and the value of <span class="No-Break">the header:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'text/html')
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are setting the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">text/html</strong> so the browser will know<a id="_idIndexMarker600"/> that the response is an HTML document and will render it <span class="No-Break">as HTML.</span></p>
			<h3>Multiple headers</h3>
			<p>You can also use the <strong class="source-inline">set</strong> method<a id="_idIndexMarker601"/> to set multiple headers at the same time by passing an object as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set({
        'Content-Type': 'text/html',
        'x-powered-by': 'Unicorns and rainbows'
    })
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding code, we are setting two headers, <strong class="source-inline">Content-Type</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">x-powered-by</strong></span><span class="No-Break">.</span></p>
			<h3>Removing headers</h3>
			<p>You can remove a header <a id="_idIndexMarker602"/>by using the <strong class="source-inline">removeHeader</strong> method, which receives the name of the header as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set({
        'Content-Type': 'text/html',
        'x-powered-by': 'Unicorns and rainbows'
    })
    res.removeHeader('x-powered-by')
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are removing<a id="_idIndexMarker603"/> the <strong class="source-inline">x-powered-by</strong> header that we just added in the <span class="No-Break">previous statement.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor286"/>Status codes</h2>
			<p>A status code is a number <a id="_idIndexMarker604"/>that represents<a id="_idIndexMarker605"/> the status of the response. It is used to communicate the status of the request to the client. It is important to use the correct status code, as it is part of the HTTP protocol that we discussed in <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p>You can manage status codes using the <strong class="source-inline">status</strong> method, which receives the status code as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.status(200)
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are setting the status code to <strong class="source-inline">200</strong>, which means that the request was successful, By default, Express will set the status code to <strong class="source-inline">200</strong> if you don’t <span class="No-Break">set it.</span></p>
			<h3>Chaining methods</h3>
			<p>You can chain the <strong class="source-inline">status</strong> method<a id="_idIndexMarker606"/> with other methods, such as <strong class="source-inline">set</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">send</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.status(200).set('Content-Type', 'text/html').send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<h3>Sending status codes only</h3>
			<p>If you want to send <a id="_idIndexMarker607"/>only the status code, you can use the <strong class="source-inline">sendStatus</strong> method, which receives the status code as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.sendStatus(500)
})</pre>			<p>In the preceding example, we are sending<a id="_idIndexMarker608"/> the <strong class="source-inline">500</strong> status code, which means that the request was <span class="No-Break">not successful.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor287"/>Redirects</h2>
			<p>You can redirect the request<a id="_idIndexMarker609"/> to another URL by using the <strong class="source-inline">redirect</strong> method, which receives the URL as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('https://ulisesgascon.com/')
})</pre>			<p>In the preceding example, we are redirecting the request <span class="No-Break">to </span><a href="https://ulisesgascon.com"><span class="No-Break">https://ulisesgascon.com</span></a><span class="No-Break">.</span></p>
			<p>The default status code for redirects is <strong class="source-inline">302</strong>, but you can change this by specifying the status code as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect(301, 'https://ulisesgascon.com/')
})</pre>			<p>The <strong class="source-inline">redirect</strong> method also accepts relative URLs, so you can redirect to another route in <span class="No-Break">your application:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('/about')
})</pre>			<p>You can even redirect to a higher level in <span class="No-Break">the URL:</span></p>
			<pre class="source-code">
app.get('/about/me', (req, res, next) =&gt; {
    res.redirect('..')
})</pre>			<p>In this case, the request will be redirected to <strong class="source-inline">/about</strong>, similar to when you do <strong class="source-inline">cd..</strong> in <span class="No-Break">the terminal.</span></p>
			<p>It is also possible to redirect<a id="_idIndexMarker610"/> to the referrer URL using the <strong class="source-inline">back</strong> method. If the referrer header is not present in the request, then the request will be redirected <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('back')
})</pre>			<h2 id="_idParaDest-280"><a id="_idTextAnchor288"/>Sending data</h2>
			<p>At the beginning of the<a id="_idIndexMarker611"/> chapter, we saw how to use <strong class="source-inline">res.render</strong> to render<a id="_idIndexMarker612"/> a template, but there are other ways to send data to the client. The most common way to send data is by using the <strong class="source-inline">send</strong> method, which receives the data as a parameter. This can be any type of data, <span class="No-Break">including buffers:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.send("Hello World")
})</pre>			<h3>Using res.send()</h3>
			<p>Under the hood, the <strong class="source-inline">send</strong> method<a id="_idIndexMarker613"/> will convert the data to a string and will set the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">text/html</strong> unless you specify otherwise using <strong class="source-inline">res.set()</strong>. It will also <span class="No-Break">include </span><span class="No-Break"><strong class="source-inline">Content-Length</strong></span><span class="No-Break">.</span></p>
			<p>If you use buffers, the <strong class="source-inline">Content-Type</strong> will be set to <strong class="source-inline">application/octet-stream</strong> and <strong class="source-inline">Content-Length</strong> will be set to the length of the buffer, but you can change this by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">res.set()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'text/html')
    res.send(Buffer.from('&lt;p&gt;Hello World&lt;/p&gt;'))
})</pre>			<h3>Using res.json()</h3>
			<p>If you want to send JSON<a id="_idIndexMarker614"/> data, you can use the <strong class="source-inline">json</strong> method directly, which receives the data as the first parameter. It will set the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">application/json</strong> and perform the serialization of the data <span class="No-Break">for you:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.json({message: 'Hello World'})
})</pre>			<p>This is the most common way to send JSON data, but you can also use the <strong class="source-inline">send</strong> method and set the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">application/json</strong>, performing the serialization of the <span class="No-Break">data yourself:</span></p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'application/json')
    res.send(JSON.stringify({message: 'Hello World'}))
})</pre>			<p>This can be very useful if you want to use<a id="_idIndexMarker615"/> a different stringification library, such as <span class="No-Break"><strong class="source-inline">fast-json-stringify</strong></span><span class="No-Break"> (</span><a href="https://www.npmjs.com/package/fast-json-stringify"><span class="No-Break">https://www.npmjs.com/package/fast-json-stringify</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor289"/>Sending files</h2>
			<p>You can send files<a id="_idIndexMarker616"/> to the client<a id="_idIndexMarker617"/> by using the <strong class="source-inline">sendFile</strong> method, which receives the path to the file as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/report', (req, res, next) =&gt; {
    res.sendFile('/path/to/file.txt')
})</pre>			<p>In the preceding example, we are sending the <strong class="source-inline">/path/to/file.txt</strong> file to the client. This method allows for huge flexibility including a callback to manage possible errors. Consult<a id="_idIndexMarker618"/> the documentation (<a href="http://expressjs.com/en/4x/api.html#res.sendFile">http://expressjs.com/en/4x/api.html#res.sendFile</a>) for <span class="No-Break">more information.</span></p>
			<p>Another way to send files is by using the <strong class="source-inline">res.download()</strong> method, which receives the path to the file as the <span class="No-Break">first parameter:</span></p>
			<pre class="source-code">
app.get('/report', (req, res, next) =&gt; {
    res.attachment('/path/to/file.txt')
})</pre>			<p>This method will set the <strong class="source-inline">Content-Disposition</strong> header to <strong class="source-inline">attachment</strong> and the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">application/octet-stream</strong> unless you specify otherwise using <strong class="source-inline">res.set()</strong>. This method allows huge flexibility, including a callback to manage possible errors. You can<a id="_idIndexMarker619"/> check the documentation (<a href="http://expressjs.com/en/4x/api.html#res.download">http://expressjs.com/en/4x/api.html#res.download</a>) for <span class="No-Break">more information.</span></p>
			<p>In the next section, we will learn<a id="_idIndexMarker620"/> just how powerful the middleware pattern<a id="_idIndexMarker621"/> is and how we can use it to build more complex applications.Express is based on the middleware pattern, so it is important to understand it because it will allow us to extend the capabilities of <span class="No-Break">Express easily.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor290"/>Using the middleware pattern</h1>
			<p>The heart of Express is the middleware<a id="_idIndexMarker622"/> pattern, which allows you to extend the functionality of the framework by adding functions that will be executed in the request-response cycle. The middleware functions are executed in the order that they are added to the application, and they can be added to the application or alternatively to <span class="No-Break">a route.</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B21678_10_5.jpg" alt="Figure 10.5 – Middleware pattern full process from application middleware to main function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Middleware pattern full process from application middleware to main function</p>
			<p>We can understand the middleware<a id="_idIndexMarker623"/> pattern as a pipeline, where the request is passed through the pipeline, and each middleware function can modify the request and the response, and pass the request to the next middleware function in the pipeline. The middleware functions can also end the request-response cycle by sending a response to <span class="No-Break">the client.</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B21678_10_6.jpg" alt="Figure 10.6 – Middleware pattern limited to Application Middleware"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Middleware pattern limited to Application Middleware</p>
			<p>We can add a global middleware<a id="_idIndexMarker624"/> to the application, which will validate whether the request is authenticated. When the user is properly authenticated, we can pass the request to the next middleware function in the pipeline, and if the user is not authenticated, we can end the request-response cycle by sending a response to the client with an <span class="No-Break">error message.</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B21678_10_7.jpg" alt="Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware</p>
			<p>We can also add a middleware function<a id="_idIndexMarker625"/> to a route, to validate (for example) that the user has the proper permissions to access the route, and if so then we can pass the request to the next middleware function in the pipeline, and if the user doesn’t have the proper permissions we can end the request-response cycle by sending a response to the client with an <span class="No-Break">error message.</span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B21678_10_8.jpg" alt="Figure 10.8 – Middleware pattern  full process from application middleware to main function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Middleware pattern  full process from application middleware to main function</p>
			<p>When the main function of the middleware has any kind of problem, such as an exception, that doesn’t allow the middleware to continue with the request-response cycle, then the error middleware can take control and respond to the client with the <span class="No-Break">error message.</span></p>
			<p>As you can see, the middleware pattern<a id="_idIndexMarker626"/> is quite complex to get familiar with, but at the same time is very powerful, because it allows us to abstract and reuse code easily. We can resolve the requests as sequence of functions where each function can take ownership when needed  so we can isolate the proper business logic <span class="No-Break">quite well.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor291"/>Understanding the scope</h2>
			<p>So, we have three possible<a id="_idIndexMarker627"/> scopes for the <span class="No-Break">middleware functions:</span></p>
			<ul>
				<li><strong class="bold">Global middleware</strong>: This will be executed for all<a id="_idIndexMarker628"/> the requests that are received by <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Route middleware</strong>: This will be executed<a id="_idIndexMarker629"/> for all the requests that are received by <span class="No-Break">the route.</span></li>
				<li><strong class="bold">Error middleware</strong>: This will be executed<a id="_idIndexMarker630"/> when an error is thrown by a <span class="No-Break">middleware function.</span></li>
			</ul>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor292"/>Middleware anatomy</h2>
			<p>So, let’s see the anatomy <a id="_idIndexMarker631"/>of a <span class="No-Break">middleware function:</span></p>
			<pre class="source-code">
const middleware(req, res, next) {}</pre>			<p>Basically, a middleware function receives three parameters: the request object, the response object, and the <span class="No-Break">next function.</span></p>
			<p>Now let’s see what we can do with a middleware function <span class="No-Break">in detail.</span></p>
			<h3>Adding context to the request</h3>
			<p>One very common use case for middleware<a id="_idIndexMarker632"/> functions is to add context to the request object. The idea is to extend the request object with additional properties that will be used by the next middleware functions in the pipeline. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const detectLangMiddleware(req, res, next) {
    req.lang = req.headers['accept-language'] || 'en'
    next()
}</pre>			<p>In the preceding example, we are adding a new property to the request object called <strong class="source-inline">lang</strong>. This property can be consumed by the next middleware functions in the pipeline <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">req.lang</strong></span><span class="No-Break">.</span></p>
			<p>This is a very simple example but is quite commonly deployed to create simple and focused middleware functions that can be <span class="No-Break">composed easily.</span></p>
			<p>As you can see, <strong class="source-inline">detectLangMiddleware</strong> is using <strong class="source-inline">next()</strong> to let Express know that the middleware has finished and there were no errors. In this case, if we don’t call <strong class="source-inline">next()</strong>, the application will <span class="No-Break">hang forever.</span></p>
			<h3>Managing responses</h3>
			<p>Another common use case for middleware<a id="_idIndexMarker633"/> functions is to manage the response. For example, we can add a middleware function that will redirect the user to <a href="https://updatemybrowser.org/">https://updatemybrowser.org/</a> if the user is using <span class="No-Break">Internet Explorer:</span></p>
			<pre class="source-code">
const legacyBrowsersMiddleware(req, res, next) {
    if (req.headers['user-agent'].includes('MSIE')) {
        res.redirect('https://updatemybrowser.org/')
    } else {
        next()
    }
}</pre>			<p>As you can see, if the user is using Internet Explorer, they will be redirected to <a href="https://updatemybrowser.org/">https://updatemybrowser.org/</a>. We do not call <strong class="source-inline">next()</strong> because we don’t want to continue with the request-response cycle as we have already sent a response to the client <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">res.redirect()</strong></span><span class="No-Break">.</span></p>
			<p>If the user is not using Internet<a id="_idIndexMarker634"/> Explorer, we call <strong class="source-inline">next()</strong> to continue with the request-response cycle <span class="No-Break">as usual.</span></p>
			<h3>Additional configuration</h3>
			<p>In <a href="B21678_03.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we learned how closures<a id="_idIndexMarker635"/> work. It is quite common to use closures to add additional configuration to the middleware functions. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const detectLangMiddleware = defaultLang =&gt; (req, res, next) =&gt; {
    req.lang = req.headers['accept-language'] || defaultLang
    next()
}</pre>			<p>In the preceding code, we have changed the middleware function from before to use a closure to receive the default language as a parameter, so we don’t need to use <strong class="source-inline">en</strong> <span class="No-Break">by default.</span></p>
			<p>So now this middleware function will be executed <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import { detectLangMiddleware } from './utils'
// With the closure
app.use(detectLangMiddleware('es'))
// without the closure
app.use(detectLangMiddleware)</pre>			<p>This is a common pattern for middleware functions that require additional configuration, such as the default language in this case, or tokens, and <span class="No-Break">so on.</span></p>
			<h3>Testing</h3>
			<p>An additional advantage<a id="_idIndexMarker636"/> of this middleware pattern is that we can unit test the middleware functions easily because they are just functions that receive a request, a response, and a next function as parameters, and then execute them. We can mock the request and the response, and we can mock the next function to check that the middleware is <span class="No-Break">working properly.</span></p>
			<p>We will see this in more detail later this chapter, but<a id="_idIndexMarker637"/> in the meantime, you can check my library called <strong class="source-inline">user-language-middleware</strong> (<a href="https://www.npmjs.com/package/user-language-middleware">https://www.npmjs.com/package/user-language-middleware</a>). The full test suite can be found at <a href="https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js">https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js</a> to get more familiar with the testing of <span class="No-Break">middleware functions.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor293"/>Adding middleware to the application</h2>
			<p>You can add middleware<a id="_idIndexMarker638"/> to the application<a id="_idIndexMarker639"/> using the <strong class="source-inline">app.use()</strong> method. This method receives a middleware function as a parameter and will be executed for all the requests received by <span class="No-Break">the application:</span></p>
			<pre class="source-code">
app.use(legacyBrowsersMiddleware)</pre>			<p>Note that the order of the middleware functions is important because they will be executed in the same order that they are added to <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor294"/>Adding middleware to a route</h2>
			<p>You can add the<a id="_idIndexMarker640"/> middleware<a id="_idIndexMarker641"/> to a route the same way that you add it to an application, only using the <strong class="source-inline">app.METHOD()</strong> method instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">app.use()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
app.get('/users', legacyBrowsersMiddleware, (req, res) =&gt; {
    res.send('Hello world')
})</pre>			<p>So, <strong class="source-inline">legacyBrowsersMiddleware</strong> will be executed only for the <strong class="source-inline">GET /users</strong> route, and if <strong class="source-inline">legacyBrowsersMiddleware</strong> calls <strong class="source-inline">next()</strong> the next middleware function in the pipeline will be executed, whichi in this case is <strong class="source-inline">(req, res) =&gt; { res.send('Hello </strong><span class="No-Break"><strong class="source-inline">world') }</strong></span><span class="No-Break">.</span></p>
			<p>Yes, we have been using this pattern<a id="_idIndexMarker642"/> since the beginning of the chapter! It is indeed<a id="_idIndexMarker643"/> fair to say <em class="italic">all the routes are middleware functions </em><span class="No-Break"><em class="italic">in Express.</em></span></p>
			<h3>Chaining middleware</h3>
			<p>You can chain middleware functions<a id="_idIndexMarker644"/> in the same <strong class="source-inline">app.METHOD()</strong> method, simply by adding <span class="No-Break">the following:</span></p>
			<pre class="source-code">
app.get('/users', legacyBrowsersMiddleware, detectLangMiddleware, (req, res) =&gt; {
    res.send('Hello world')
})</pre>			<p>This is very common in large applications where you have a lot of middleware functions that are executed in a specific order. It is a good practice to review the order of the middleware functions to avoid unexpected behaviors and to migrate them to the application level if they are used in multiple routes, adapting the business logic <span class="No-Break">if needed.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor295"/>Common middleware used in Express</h2>
			<p>Historically, the Express team<a id="_idIndexMarker645"/> has included some middleware functions in the framework, but most of them have been moved to external packages since Express 4. However, there are still a few middleware functions included in <span class="No-Break">the framework.</span></p>
			<h3>Static files</h3>
			<p>Express includes a middleware<a id="_idIndexMarker646"/> function to serve static files from a directory. This is very useful to serve the static assets of a web application, such as images, CSS files, or <span class="No-Break">JavaScript files:</span></p>
			<pre class="source-code">
app.use(express.static('public'))</pre>			<p>You can also use multiple<a id="_idIndexMarker647"/> directories to serve <span class="No-Break">static files:</span></p>
			<pre class="source-code">
app.use(express.static('public'))
app.use(express.static('files'))</pre>			<h3>Error handling</h3>
			<p>Express includes a middleware<a id="_idIndexMarker648"/> function to handle errors. This middleware function must be the last one in the pipeline, and it must receive four parameters instead of three. The first parameter is the error, the second is the request, third is the response, and the fourth one is the <span class="No-Break">next function:</span></p>
			<pre class="source-code">
app.use((err, req, res, next) =&gt; {
    console.error(err.stack)
    res.status(500).send('Ohh! The Server needs some love')
})</pre>			<p>If you have an error in any middleware function, you can call <strong class="source-inline">next(err)</strong> and this middleware function will be executed, as it also will if you throw an error in a route handler. Let’s see it <span class="No-Break">in action:</span></p>
			<pre class="source-code">
import express from 'express'
const app = express()
const port = 3000
app.get('/next-error', (req, res, next) =&gt; {
    next(new Error('Ohh! Something went wrong'))
})
app.get('/throw-error', (req, res) =&gt; {
    throw new Error('Ohh! Something went wrong')
})
app.use((err, req, res, next) =&gt; {
    console.error(err.stack)
    res.status(500).send('Ohh! The Server needs some love')
})
app.listen(port, () =&gt; {
  console.log(`running at http://localhost:${port}`)
})</pre>			<p>If you now go to <a href="http://localhost:3000/next-error">http://localhost:3000/next-error</a> or <a href="http://localhost:3000/throw-error">http://localhost:3000/throw-error</a>, you will see that the error handler middleware function is <span class="No-Break">taking control.</span></p>
			<p>In the next section, we will continue learning about the middleware pattern, but we will focus on the third-party middleware functions available in the ecosystem. Currently, there is huge amount of middleware functions that you can use in your Express applications, so it is important to know how to use them properly. While using third-party middleware functions<a id="_idIndexMarker649"/> you can save a lot of time and effort, you need to be careful because it means adding more dependencies to <span class="No-Break">your project.</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor296"/>Using third-party middleware</h1>
			<p>There are a lot of third-party middleware<a id="_idIndexMarker650"/> functions that you can use in your Express applications. Let’s see how to install and <span class="No-Break">use them.</span></p>
			<p>One of the most popular<a id="_idIndexMarker651"/> middleware functions is <strong class="source-inline">body-parser</strong> (<a href="https://www.npmjs.com/package/body-parser">https://www.npmjs.com/package/body-parser</a>). Basically, it will parse the HTTP body of the incoming request and make it available under the <span class="No-Break"><strong class="source-inline">req.body</strong></span><span class="No-Break"> property.</span></p>
			<p>Install it using <strong class="source-inline">npm</strong> <span class="No-Break">as follows:</span></p>
			<pre class="console">
npm install body-parser@1</pre>			<p>Then you can import it and use it in your application. Create a new file called <strong class="source-inline">echo_payload.js</strong> with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
const app = express()
const port = 3000
app.use(bodyParser.json())
app.post('/echo', (req, res) =&gt; {
    // Echo the request body
    res.json(req.body)
})
app.listen(port, () =&gt; {
  console.log(`running at http://localhost:${port}`)
})</pre>			<p>Now run the application with <strong class="source-inline">node echo_payload.js</strong> and then use <strong class="source-inline">curl</strong> or a similar tool to send a POST request to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">echo</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
curl -X POST -H "Content-Type: application/json" -d '{"name":"John"}' http://localhost:3000/echo</pre>			<p>You will see that the response<a id="_idIndexMarker652"/> is the same JSON that you sent in the <span class="No-Break">request body.</span></p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor297"/>Summary</h1>
			<p>In this chapter, we learned about the many uses of Express, including how to create a basic server, how to add routes, how to add static files, and how to <span class="No-Break">use templates.</span></p>
			<p>Additionally, we learned how the middleware pattern works and how we can create our own middleware and use it at different levels in our application. We also checked out some third-party middleware <span class="No-Break">including </span><span class="No-Break"><strong class="source-inline">body-parser</strong></span><span class="No-Break">.</span></p>
			<p>In the next chapter, we will learn how to use a super test to test our first API in depth. We will cover how to test the routes and the stores and will create a solid API that we will develop in the <span class="No-Break">coming chapters.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor298"/>Further reading</h1>
			<ul>
				<li>Express <span class="No-Break">documentation: </span><a href="https://expressjs.com/"><span class="No-Break">https://expressjs.com/</span></a></li>
				<li><em class="italic">Express, State of the Union</em> by Doug <span class="No-Break">Wilson: </span><a href="https://www.youtube.com/watch?v=HxGt_3F0ULg"><span class="No-Break">https://www.youtube.com/watch?v=HxGt_3F0ULg</span></a></li>
				<li><em class="italic">Node.js Foundation to Add Express as an Incubator </em><span class="No-Break"><em class="italic">Project</em></span><span class="No-Break">: </span><a href="https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70"><span class="No-Break">https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer069" class="Content">
			<h1 id="_idParaDest-291" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor299"/>Part 4: Building Solid Web Applications with Node.js</h1>
			<p>In <em class="italic">Part 4</em>, we will build a web application together using Express and MongoDB as the main stack. You will learn advanced topics such as error handling or security by implementing them in the project while learning all the theories and best practices to secure your <span class="No-Break">web application.</span></p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21678_11.xhtml#_idTextAnchor300"><em class="italic">Chapter 11</em></a>, <em class="italic">Building a Web Application Project from Scratch</em></li>
				<li><a href="B21678_12.xhtml#_idTextAnchor320"><em class="italic">Chapter 12</em></a>, <em class="italic">Data Persistence with MongoDB</em></li>
				<li><a href="B21678_13.xhtml#_idTextAnchor348"><em class="italic">Chapter 13</em></a>, <em class="italic">User Authentication and Authorization with Passport.js</em></li>
				<li><a href="B21678_14.xhtml#_idTextAnchor376"><em class="italic">Chapter 14</em></a>, <em class="italic">Error handling in Node.js</em></li>
				<li><a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>, <em class="italic">Securing Web Applications</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer070" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>