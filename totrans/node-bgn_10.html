<html><head></head><body>
		<div><h1 id="_idParaDest-260" class="chapter-number"><a id="_idTextAnchor267"/>10</h1>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor268"/>Building Web Applications with Express</h1>
			<p>Express is the most popular web framework for JavaScript and has been the de-facto standard for many years. It is a very minimalistic framework, very easy to learn, and provides a lot of flexibility to build web applications.</p>
			<p>In this chapter, we will start with the most basic “hello world” application to build a solid and well-tested REST API application. We will explore in detail all the critical components of Express, including request and response, middleware, and routing. We will also learn how to use the most common Express middleware and how to build our own middleware.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>Serving static files for your project</li>
				<li>Building a server-rendered landing page using template engines</li>
				<li>Building a typical CRUD REST API application with Express</li>
				<li>Using the most common Express middleware, including third-party libraries</li>
				<li>Building your own middleware</li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor269"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners "/></p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/8QyDZVa7CNg">https://youtu.be/8QyDZVa7CNg</a></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor270"/>Getting familiar with the Express library</h1>
			<p>Express is defined<a id="_idIndexMarker539"/> on its own<a id="_idIndexMarker540"/> website (<a href="https://expressjs.com/">https://expressjs.com/</a>) as follows:</p>
			<p class="author-quote">Fast, unopinionated, minimalist web framework for Node.js</p>
			<p>So, the good news is that we have a lot of freedom to build our application. The bad news is that we must make a lot of decisions, and we must be careful to not make mistakes.</p>
			<p>Express is very minimalistic<a id="_idIndexMarker541"/> in comparison with other web frameworks, so we have to add third-party libraries or build our own abstractions when needed. Express has a very active community, so we can find a lot of libraries to solve common problems.</p>
			<p>Additionally, the official documentation is of great quality and there are plenty of resources to learn more about Express, which makes Express a great choice for beginners.</p>
			<p>As Express is an unopinionated framework, when you follow a tutorial or a course you will find that sometimes the code is not consistent and doesn’t follow the same patterns. This is because you have a lot of freedom in Express, and over time you will develop your own patterns and your own way of building applications that best fits you.</p>
			<p>In this book, we will use Express version 4.18.3, but any Express 4.x version should be fine as well. We will use Node.js version 20.11.0. Both are the latest versions available at the time of writing.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor271"/>Installing Express</h2>
			<p>To install Express, we must run<a id="_idIndexMarker542"/> the following command in a new Node.js project:</p>
			<pre class="console">
npm install express@4</pre>			<p>You don’t need any additional configuration; just install it and you are ready to go.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor272"/>Hello World</h2>
			<p>Let’s start with a simple<a id="_idIndexMarker543"/> example, a Hello World application. Create a new file called <code>helloWorld.js</code> and add the following code:</p>
			<pre class="source-code">
import express from 'express'
const app = express()
const port = 3000
app.get('/', (req, res) =&gt; {
  res.send('Hello World from Express!')
})
app.listen(port, () =&gt; {
  console.log(`Hello World app listening on port ${port}`)
})</pre>			<p>Very simple, right? Let’s break it down:</p>
			<ol>
				<li>We import the Express library and create an instance of the Express application.</li>
				<li>We define a route for the <code>/</code> root path and we send a response with the text <code>Hello World </code><code>from Express!</code>.</li>
				<li>We start the server and listen on port <code>3000</code>.</li>
			</ol>
			<p>To run the application, we use the following command:</p>
			<pre class="console">
node helloWorld.js</pre>			<p>If everything is OK, you should see the following output:</p>
			<pre class="console">
Hello World app listening on port 3000</pre>			<p>Now, if you open your browser and go to <code>http://localhost:3000</code>, you should see the text <strong class="bold">Hello World from Express!</strong>, as shown in the following<a id="_idIndexMarker544"/> screenshot:</p>
			<div><div><img src="img/B21678_10_1.jpg" alt="Figure 10.1 – Web browser screenshot showing a simple Express project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Web browser screenshot showing a simple Express project</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor273"/>Using the generator</h2>
			<p>Express has a command-line tool<a id="_idIndexMarker545"/> to generate a basic application. To use it, we must run the following command:</p>
			<pre class="console">
npx express-generator@4</pre>			<p>This will generate a new application with many files and folders. I recommend you create a new folder and run the command there, so you don’t mess up your current project.</p>
			<p>The output on execution should <a id="_idIndexMarker546"/>be something like the following:</p>
			<pre class="console">
   create : public/
   create : public/javascripts/
   create : public/images/
   create : public/stylesheets/
   create : public/stylesheets/style.css
   create : routes/
   create : routes/index.js
   create : routes/users.js
   create : views/
   create : views/error.jade
   create : views/index.jade
   create : views/layout.jade
   create : app.js
   create : package.json
   create : bin/
   create : bin/www
   install dependencies:
     $ npm install
   run the app:
     $ DEBUG=generated:* npm start</pre>			<p>Then the next step is to install the dependencies:</p>
			<pre class="console">
npm install</pre>			<p>Finally, we can start the application:</p>
			<pre class="console">
npm start</pre>			<p>If everything is OK, you should see the following output:</p>
			<pre class="console">
&gt; generated@0.0.0 start
&gt; node ./bin/www
GET / 304 125.395 ms - -
GET /stylesheets/style.css 304 1.265 ms - -
GET / 304 11.043 ms - -
GET /stylesheets/style.css 304 0.396 ms - -
GET /ws 404 11.822 ms - 1322</pre>			<p>If you access <code>http://localhost:3000</code> in the browser, you should<a id="_idIndexMarker547"/> see the following page:</p>
			<div><div><img src="img/B21678_10_2.jpg" alt="Figure 10.2 – Web browser screenshot showing the Express app generated using the express-generator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Web browser screenshot showing the Express app generated using the <code>express-generator</code></p>
			<p>Feel free to explore the generated code, but don’t worry if you don’t understand everything as we will cover all the important parts in the following sections. Note that also the route <a href="http://localhost:3000/users">http://localhost:3000/users</a> is working and if you try any other route, you will get a 404 error, as with <a href="http://localhost:3000/invented">http://localhost:3000/invented</a> for example.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor274"/>Debugging</h2>
			<p>Now, let me show another<a id="_idIndexMarker548"/> cool thing that the Express generator includes and that we will use in our project later. If you start the application with the command <code>DEBUG=* npm start</code> or <code>set DEBUG=* &amp;&amp; npm start</code> (if you use Windows) in the terminal output will be more verbose and you will see a lot of information about the requests and responses:</p>
			<div><div><img src="img/B21678_10_3.jpg" alt="Figure 10.3 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Terminal screenshot</p>
			<p>This is because Express and many other<a id="_idIndexMarker549"/> dependencies use the <code>debug</code> library (<a href="https://www.npmjs.com/package/debug">https://www.npmjs.com/package/debug</a>) to log information. By using the <code>DEBUG=*</code> environment variable, we are telling to debug library to print the information related to all the namespaces. But we can be more selective and limit the scope for Express, for example, by using the <code>DEBUG=express:* npm start</code> environment variable.</p>
			<p>Now, that we have a basic understanding of Express, it is time to explore how we can use template engines to render the HTML pages that will be sent to the browser.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor275"/>Understanding template engines</h1>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, we learned<a id="_idIndexMarker550"/> the difference between <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>) and server-side<a id="_idIndexMarker551"/> rendering.</p>
			<p>Express provides a way to render HTML pages using template engines. This is the key feature to build server-side rendered applications with Express.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor276"/>Choosing a template engine</h2>
			<p>The first thing that we must do is to choose<a id="_idIndexMarker552"/> a template engine. There are many options available. The most popular<a id="_idIndexMarker553"/> option historically was Jade (<a href="https://www.npmjs.com/package/jade">https://www.npmjs.com/package/jade</a>), but it was renamed<a id="_idIndexMarker554"/> to Pug (<a href="https://www.npmjs.com/package/pug">https://www.npmjs.com/package/pug</a>). You can find many tutorials and examples by searching using both names.</p>
			<p>I personally prefer <strong class="bold">Embedded JavaScript templating</strong> (<strong class="bold">ejs</strong>) (<a href="https://www.npmjs.com/package/ejs">https://www.npmjs.com/package/ejs</a>) for its simplicity<a id="_idIndexMarker555"/> and because it is well <a id="_idIndexMarker556"/>documented. Over time, you will get more familiar with the template engines and will be able to choose the one that better fits your needs.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor277"/>Rendering a template</h2>
			<p>So, going back to our hello world<a id="_idIndexMarker557"/> example, let’s create a new file called <code>helloWorldTemplate.js</code> and add the following code:</p>
			<pre class="source-code">
import express from ('express')
const app = express()
const port = 3000
app.set('view engine', 'ejs')
app.get('/', (req, res) =&gt; {
  res.render('index', {
    title: 'This is an Express app',
    subtitle: 'using EJS as template engine'})
})
app.listen(port, () =&gt; {
  console.log(`Application running in http://localhost:${port}`)
})</pre>			<p>Now, we have to create<a id="_idIndexMarker558"/> a new folder called <code>views</code>, inside of which we create a new file called <code>index.ejs</code> with the following content:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
  &lt;h2&gt;&lt;%= subtitle %&gt;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<p>As you can see, the template engine uses the <code>&lt;%=</code> and <code>%&gt;</code> tags to interpolate the values. In this case, we are passing the <code>title</code> variable to the template.</p>
			<p>Finally, we have to install the <code>ejs</code> dependency:</p>
			<pre class="console">
npm install ejs@3</pre>			<p>Then we start the application as follows:</p>
			<pre class="console">
node helloWorldTemplate.js</pre>			<p>If you access <code>http://localhost:3000</code> in the browser, you should<a id="_idIndexMarker559"/> see the following displayed:</p>
			<div><div><img src="img/B21678_10_4.jpg" alt="Figure 10.4 – Web browser screenshot showing the templeate rendered for the end user."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Web browser screenshot showing the templeate rendered for the end user.</p>
			<p>Additionally, if you access <code>view-source:http://localhost:3000/</code>, you will see the raw HTML that Express is sending to the browser:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;This is an Express app&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;This is an Express app&lt;/h1&gt;
  &lt;h2&gt;using EJS as template engine&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<p>As you can see the template engine<a id="_idIndexMarker560"/> is interpolating the values and generating the HTML for us.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor278"/>Understanding the process</h2>
			<p>Now, let’s understand<a id="_idIndexMarker561"/> what is actually happening in the code:</p>
			<pre class="source-code">
app.set('view engine', 'ejs')</pre>			<p>The preceding line tells Express that we are going to use <code>ejs</code> as our template engine, so now we can use <code>res.render</code> to render the template.</p>
			<pre class="source-code">
res.render('index', {
    title: 'This is an Express app',
    subtitle: 'using EJS as template engine'
})</pre>			<p>In the preceding code, the <code>res.render</code> method receives two parameters. The first one is the name of the template, in this case, <code>index</code> (<code>views/index.ejs</code>), and the second one is the data that we want to interpolate in the template.</p>
			<p>Then the template engine will replace the <code>&lt;%= title %&gt;</code> and <code>&lt;%= subtitle %&gt;</code> tags with the values that we are passing in the second parameter of the <code>res.render</code> method.</p>
			<p>In real-world applications, the data that we pass to the template will be dynamic; for example, the data that we get from a database or an external API. But for now, we are going to use static data to keep the example simple.</p>
			<p>In the next section, we will learn how we can take advantage of the request object to build more rich and powerful applications.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor279"/>Mastering requests</h1>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, we learned all the theory<a id="_idIndexMarker562"/> around HTTP requests and responses. Here, we will cover how to handle these with Express.</p>
			<p>In this section, we are going to focus on this snippet of pseudo-code:</p>
			<pre class="source-code">
import express from ('express')
const app = express()
app.method(route, handler)</pre>			<p>We have three elements here to understand:</p>
			<ul>
				<li><code>method</code>, that is, the HTTP method that we want to handle, for example, <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and so on</li>
				<li><code>route</code>, that is, the path that we want to handle, for example, <code>/</code>, <code>/users</code>, or <code>/users/:id</code></li>
				<li><code>handler</code>, that is, the callback function that will be executed when <code>method</code> and <code>route</code> match</li>
			</ul>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor280"/>HTTP methods</h2>
			<p>Express provides<a id="_idIndexMarker563"/> a method for each HTTP<a id="_idIndexMarker564"/> method. There are many out there (<code>get</code>, <code>post</code>, <code>put</code>, <code>head</code>, <code>delete</code>, <code>options</code>, <code>trace</code>, <code>copy</code>, <code>lock</code>, <code>mkcol</code>, <code>move</code>, <code>purge</code>, <code>propfind</code>, <code>proppatch</code>, <code>unlock</code>, <code>report</code>, <code>mkactivity</code>, <code>checkout</code>, <code>merge</code>, <code>m-search</code>, <code>notify</code>, <code>subscribe</code>, <code>unsubscribe</code>, <code>patch</code>, <code>search</code>, and <code>connect</code>).</p>
			<p>The most common are <code>get</code>, <code>post</code>, <code>put</code>, and <code>delete</code>, so we are going to focus on them:</p>
			<pre class="source-code">
app.get ('/', () =&gt; {})
app.post('/', () =&gt; {})
app.put('/', () =&gt; {})
app.delete('/', () =&gt; {})</pre>			<p>If you want to manage all the HTTP methods<a id="_idIndexMarker565"/> in the same route, you can use<a id="_idIndexMarker566"/> the <code>all</code> method:</p>
			<pre class="source-code">
app.all('/', () =&gt; {})</pre>			<h2 id="_idParaDest-274"><a id="_idTextAnchor281"/>Routes</h2>
			<p>The routes are very<a id="_idIndexMarker567"/> flexible<a id="_idIndexMarker568"/> and can be dynamic. We can define them in different ways, including regular expressions.</p>
			<h3>Static paths</h3>
			<p>Static paths are the<a id="_idIndexMarker569"/> most common<a id="_idIndexMarker570"/> way of defining routes. They are used to handle requests to a specific path, for example, <code>/</code>, <code>/users</code>, or <code>/user/me</code>:</p>
			<pre class="source-code">
app.get('/', () =&gt; {})
app.get('/users', () =&gt; {})
app.get('/user/me', () =&gt; {})</pre>			<h3>Dynamic parameters</h3>
			<p>Dynamic parameters are used<a id="_idIndexMarker571"/> to handle<a id="_idIndexMarker572"/> the requests t<a id="_idTextAnchor282"/>o a specific path. We can use the <code>:</code> character to define a dynamic parameter, such as <code>/users/:id</code> or <code>/users/:id/profile</code>:</p>
			<pre class="source-code">
app.get('/users/:id', () =&gt; {})</pre>			<p>In this case, <code>:id</code> is a dynamic parameter, so it will match with any value, including <code>/users/1</code>, <code>/users/peter</code>, <code>/users/jane-doe</code>, and so on.</p>
			<p>You can even combine static and dynamic parameters, such as <code>/users/:id/profile</code>:</p>
			<pre class="source-code">
app.get('/users/:id/profile', () =&gt; {})</pre>			<p>The preceding example will resolve requests to <code>/users/1/profile</code>, <code>/users/peter/profile</code>, <code>/users/jane-doe/profile</code>, and so on.</p>
			<p>This pattern is quite common in transportation apps, for example, where you can have a route such as <code>/users/:id/rides/:rideId</code> to get the details of a specific ride, or when you book tickets for a flight using a route such as <code>/flights/from/:originCity/to/:destinationCity</code>. Express will provide the values<a id="_idIndexMarker573"/> of the dynamic<a id="_idIndexMarker574"/> parameters in the <code>req.params</code> object:</p>
			<pre class="source-code">
app.get('/users/:id', (req, res) =&gt; {
    const { originCity, destinationCity } = req.params
    res.send(`You are flying from ${originCity} to ${destinationCity}`)
})</pre>			<h3>Optional parameters</h3>
			<p>The optional parameters<a id="_idIndexMarker575"/> are used to handle the requests<a id="_idIndexMarker576"/> to a specific path, but the parameter is optional. This can be done with the <code>?</code> character, such as <code>/invoice/:id?</code>:</p>
			<pre class="source-code">
app.get('/invoice/:id?', (req, res) =&gt; {
    const id = parseInt(req.params.id)
    if (id) {
        res.send(`You are looking for the invoice with id ${id}`)
    } else {
        res.send(`You are looking for all the invoices`)
    }
})</pre>			<p>In this case the <code>:id</code> parameter is optional, so it will match with <code>/invoice</code>, <code>/invoice/167</code>, <code>/invoice/G123S8123SD123MJ</code>, and so on.</p>
			<h3>Regular expressions</h3>
			<p>We can use regular expressions<a id="_idIndexMarker577"/> to define routes. This is quite useful when<a id="_idIndexMarker578"/> we want to match the route using predictable patterns – for example, <code>/.*fly$/</code> will identify any text that ends with <code>fly</code>:</p>
			<pre class="source-code">
app.get(/.*fly$/, (req, res) =&gt; {
  res.send(`Match with any route that ends with fly`)
})</pre>			<p>The preceding route will match with <code>/butterfly</code>, <code>/dragonfly</code>, <code>/fly</code>, <code>/mcfly</code>, and so on. Let’s create a less exotic example:</p>
			<pre class="source-code">
app.get('/msg/:id/:action(edit|delete)', (req, res, next) =&gt; {
  res.send(`You request the action ${req.params.action} for the message ${req.params.id}`);
});</pre>			<p>In this case, the route<a id="_idIndexMarker579"/> will match with <code>/msg/1/edit</code>, <code>/msg/1/delete</code>, and so on.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you’re unfamiliar with regular expressions, don’t worry: you can use the other options to define your routes. But if you want to explore regular expressions more deeply, I recommend you to try <em class="italic">Regular Expressions </em><em class="italic">101</em> (<a href="https://regex101.com/">https://regex101.com/</a>).</p>
			<h3>Query params</h3>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, we learned<a id="_idIndexMarker580"/> about the different parts<a id="_idIndexMarker581"/> of the URL and saw that the query params are those parts that start with <code>?</code>. These are used to send extra information to the server. For example, in the URL <code>/films?category=scifi&amp;director=George+Lucas</code> we are sending two query params, <code>category</code> and the <code>director</code>.</p>
			<p>We can capture the query params in the <code>req.query</code> object to use them in our routes:</p>
			<pre class="source-code">
app.get('/films', (req, res) =&gt; {
    const { category, director } = req.query
    res.send(`You are looking for films with category ${category} and director ${director}`)
})</pre>			<p>It is important to note that query params are optional, meaning that requests might not have any query param at all. In that<a id="_idIndexMarker582"/> case, the <code>req.query</code> object<a id="_idIndexMarker583"/> would be empty.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">URL fragments (i.e., <code>/mypath#fragment</code>) are not part of requests and will not be included as such by the browser, so we can’t capture them. See https://github.com/expressjs/express/issues/1083 for more info.</p>
			<h3>The importance of order</h3>
			<p>The routes are registered <a id="_idIndexMarker584"/>in the order that you defined them, which allows Express to avoid conflicts between routes. Let’s see an example:</p>
			<pre class="source-code">
app.get('/users/:id', () =&gt; {
    res.send(`You are looking for the user with id ${req.params.id}`)
})
app.get('/users/me', () =&gt; {
    res.send(`You are looking for the current user`)
})</pre>			<p>If you try to access <code>/users/me</code>, you will get the message <code>You are looking for the user with id me</code> because the <code>/users/:id</code> route is registered first, so it will match with <code>/users/me</code> and the <code>me</code> value will be stored in the <code>req.params.id</code> property.</p>
			<p>You can solve this issue by shifting the order of the routes:</p>
			<pre class="source-code">
app.get('/users/me', () =&gt; {})
app.get('/users/:id', () =&gt; {})</pre>			<p>In big projects, this can become<a id="_idIndexMarker585"/> a problem if you don’t have a good strategy to define the routes. This is also a good reason to include automated tests in your project to avoid accidental misconfigurations of routes.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor283"/>Handlers</h2>
			<p>Handlers are the<a id="_idIndexMarker586"/> functions<a id="_idIndexMarker587"/> that are executed when a request matches with a route. While a handler is a simple function with three parameters (<code>req</code>, <code>res</code>, and <code>next</code>), it has the big responsibility of handling the response to the request or delegating the request to other handlers:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.send("Hello World")
})</pre>			<p>Let’s see the parameters of the handler in more detail.</p>
			<h3>request</h3>
			<p>The request object (<code>req</code>) contains all the information<a id="_idIndexMarker588"/> about the request, including<a id="_idIndexMarker589"/> the parameters, IP, headers, body, and so on. If you use other libraries that extend the capabilities of Express, very often you will find more properties in this object.</p>
			<p>You can find more information about the request object<a id="_idIndexMarker590"/> in the Express documentation (<a href="https://expressjs.com/en/4x/api.html#req">https://expressjs.com/en/4x/api.html#req</a>).</p>
			<h3>response</h3>
			<p>The response object (<code>res</code>) contains all the methods<a id="_idIndexMarker591"/> to handle the<a id="_idIndexMarker592"/> response of the request, including simple methods like <code>send</code> or <code>json</code> to more complex methods like download or redirect.</p>
			<p>In the following section, we will learn more about the response object capabilities.</p>
			<h3>next</h3>
			<p>The next function (<code>next</code>) is used to delegate the request<a id="_idIndexMarker593"/> to the next handler. This<a id="_idIndexMarker594"/> is useful when you want to split the logic of the handler into multiple functions or delegate error management.</p>
			<p>We will learn both strategies in the next two sections, when we will discuss the middleware pattern<a id="_idIndexMarker595"/> and mastering responses.</p>
			<p>In the next section, we will learn how we can take advantage of the response object and how to customize the responses based on many different scenarios, such as HTTP redirection, HTTP header customization, and more.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor284"/>Mastering responses</h1>
			<p>Responses are the way by which the server<a id="_idIndexMarker596"/> communicates back to the client after a request, so it is crucial to understand how to manage them. In this section, we will learn about adding headers, status codes, redirects, sending data, and sending files.</p>
			<p>You will discover the available methods when you start to build more complex applications. You can find more information about<a id="_idIndexMarker597"/> the response object in the Express documentation (<a href="https://expressjs.com/en/4x/api.html#res">https://expressjs.com/en/4x/api.html#res</a>).</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor285"/>Header management</h2>
			<p>Headers are used<a id="_idIndexMarker598"/> to send extra information<a id="_idIndexMarker599"/> about the response. Express handles headers by using the <code>set</code> method, which receives two parameters, the name of the header and the value of the header:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'text/html')
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are setting the <code>Content-Type</code> header to <code>text/html</code> so the browser will know<a id="_idIndexMarker600"/> that the response is an HTML document and will render it as HTML.</p>
			<h3>Multiple headers</h3>
			<p>You can also use the <code>set</code> method<a id="_idIndexMarker601"/> to set multiple headers at the same time by passing an object as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set({
        'Content-Type': 'text/html',
        'x-powered-by': 'Unicorns and rainbows'
    })
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding code, we are setting two headers, <code>Content-Type</code> and <code>x-powered-by</code>.</p>
			<h3>Removing headers</h3>
			<p>You can remove a header <a id="_idIndexMarker602"/>by using the <code>removeHeader</code> method, which receives the name of the header as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set({
        'Content-Type': 'text/html',
        'x-powered-by': 'Unicorns and rainbows'
    })
    res.removeHeader('x-powered-by')
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are removing<a id="_idIndexMarker603"/> the <code>x-powered-by</code> header that we just added in the previous statement.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor286"/>Status codes</h2>
			<p>A status code is a number <a id="_idIndexMarker604"/>that represents<a id="_idIndexMarker605"/> the status of the response. It is used to communicate the status of the request to the client. It is important to use the correct status code, as it is part of the HTTP protocol that we discussed in <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>.</p>
			<p>You can manage status codes using the <code>status</code> method, which receives the status code as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.status(200)
    res.send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<p>In the preceding example, we are setting the status code to <code>200</code>, which means that the request was successful, By default, Express will set the status code to <code>200</code> if you don’t set it.</p>
			<h3>Chaining methods</h3>
			<p>You can chain the <code>status</code> method<a id="_idIndexMarker606"/> with other methods, such as <code>set</code> or <code>send</code>:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.status(200).set('Content-Type', 'text/html').send("&lt;h1&gt;Hello World&lt;/h1&gt;")
})</pre>			<h3>Sending status codes only</h3>
			<p>If you want to send <a id="_idIndexMarker607"/>only the status code, you can use the <code>sendStatus</code> method, which receives the status code as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.sendStatus(500)
})</pre>			<p>In the preceding example, we are sending<a id="_idIndexMarker608"/> the <code>500</code> status code, which means that the request was not successful.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor287"/>Redirects</h2>
			<p>You can redirect the request<a id="_idIndexMarker609"/> to another URL by using the <code>redirect</code> method, which receives the URL as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('https://ulisesgascon.com/')
})</pre>			<p>In the preceding example, we are redirecting the request to <a href="https://ulisesgascon.com">https://ulisesgascon.com</a>.</p>
			<p>The default status code for redirects is <code>302</code>, but you can change this by specifying the status code as the first parameter:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect(301, 'https://ulisesgascon.com/')
})</pre>			<p>The <code>redirect</code> method also accepts relative URLs, so you can redirect to another route in your application:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('/about')
})</pre>			<p>You can even redirect to a higher level in the URL:</p>
			<pre class="source-code">
app.get('/about/me', (req, res, next) =&gt; {
    res.redirect('..')
})</pre>			<p>In this case, the request will be redirected to <code>/about</code>, similar to when you do <code>cd..</code> in the terminal.</p>
			<p>It is also possible to redirect<a id="_idIndexMarker610"/> to the referrer URL using the <code>back</code> method. If the referrer header is not present in the request, then the request will be redirected to <code>/</code>:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.redirect('back')
})</pre>			<h2 id="_idParaDest-280"><a id="_idTextAnchor288"/>Sending data</h2>
			<p>At the beginning of the<a id="_idIndexMarker611"/> chapter, we saw how to use <code>res.render</code> to render<a id="_idIndexMarker612"/> a template, but there are other ways to send data to the client. The most common way to send data is by using the <code>send</code> method, which receives the data as a parameter. This can be any type of data, including buffers:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.send("Hello World")
})</pre>			<h3>Using res.send()</h3>
			<p>Under the hood, the <code>send</code> method<a id="_idIndexMarker613"/> will convert the data to a string and will set the <code>Content-Type</code> header to <code>text/html</code> unless you specify otherwise using <code>res.set()</code>. It will also include <code>Content-Length</code>.</p>
			<p>If you use buffers, the <code>Content-Type</code> will be set to <code>application/octet-stream</code> and <code>Content-Length</code> will be set to the length of the buffer, but you can change this by using <code>res.set()</code>:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'text/html')
    res.send(Buffer.from('&lt;p&gt;Hello World&lt;/p&gt;'))
})</pre>			<h3>Using res.json()</h3>
			<p>If you want to send JSON<a id="_idIndexMarker614"/> data, you can use the <code>json</code> method directly, which receives the data as the first parameter. It will set the <code>Content-Type</code> header to <code>application/json</code> and perform the serialization of the data for you:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.json({message: 'Hello World'})
})</pre>			<p>This is the most common way to send JSON data, but you can also use the <code>send</code> method and set the <code>Content-Type</code> header to <code>application/json</code>, performing the serialization of the data yourself:</p>
			<pre class="source-code">
app.get('/', (req, res, next) =&gt; {
    res.set('Content-Type', 'application/json')
    res.send(JSON.stringify({message: 'Hello World'}))
})</pre>			<p>This can be very useful if you want to use<a id="_idIndexMarker615"/> a different stringification library, such as <code>fast-json-stringify</code> (<a href="https://www.npmjs.com/package/fast-json-stringify">https://www.npmjs.com/package/fast-json-stringify</a>).</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor289"/>Sending files</h2>
			<p>You can send files<a id="_idIndexMarker616"/> to the client<a id="_idIndexMarker617"/> by using the <code>sendFile</code> method, which receives the path to the file as the first parameter:</p>
			<pre class="source-code">
app.get('/report', (req, res, next) =&gt; {
    res.sendFile('/path/to/file.txt')
})</pre>			<p>In the preceding example, we are sending the <code>/path/to/file.txt</code> file to the client. This method allows for huge flexibility including a callback to manage possible errors. Consult<a id="_idIndexMarker618"/> the documentation (<a href="http://expressjs.com/en/4x/api.html#res.sendFile">http://expressjs.com/en/4x/api.html#res.sendFile</a>) for more information.</p>
			<p>Another way to send files is by using the <code>res.download()</code> method, which receives the path to the file as the first parameter:</p>
			<pre class="source-code">
app.get('/report', (req, res, next) =&gt; {
    res.attachment('/path/to/file.txt')
})</pre>			<p>This method will set the <code>Content-Disposition</code> header to <code>attachment</code> and the <code>Content-Type</code> header to <code>application/octet-stream</code> unless you specify otherwise using <code>res.set()</code>. This method allows huge flexibility, including a callback to manage possible errors. You can<a id="_idIndexMarker619"/> check the documentation (<a href="http://expressjs.com/en/4x/api.html#res.download">http://expressjs.com/en/4x/api.html#res.download</a>) for more information.</p>
			<p>In the next section, we will learn<a id="_idIndexMarker620"/> just how powerful the middleware pattern<a id="_idIndexMarker621"/> is and how we can use it to build more complex applications.Express is based on the middleware pattern, so it is important to understand it because it will allow us to extend the capabilities of Express easily.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor290"/>Using the middleware pattern</h1>
			<p>The heart of Express is the middleware<a id="_idIndexMarker622"/> pattern, which allows you to extend the functionality of the framework by adding functions that will be executed in the request-response cycle. The middleware functions are executed in the order that they are added to the application, and they can be added to the application or alternatively to a route.</p>
			<div><div><img src="img/B21678_10_5.jpg" alt="Figure 10.5 – Middleware pattern full process from application middleware to main function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Middleware pattern full process from application middleware to main function</p>
			<p>We can understand the middleware<a id="_idIndexMarker623"/> pattern as a pipeline, where the request is passed through the pipeline, and each middleware function can modify the request and the response, and pass the request to the next middleware function in the pipeline. The middleware functions can also end the request-response cycle by sending a response to the client.</p>
			<div><div><img src="img/B21678_10_6.jpg" alt="Figure 10.6 – Middleware pattern limited to Application Middleware"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Middleware pattern limited to Application Middleware</p>
			<p>We can add a global middleware<a id="_idIndexMarker624"/> to the application, which will validate whether the request is authenticated. When the user is properly authenticated, we can pass the request to the next middleware function in the pipeline, and if the user is not authenticated, we can end the request-response cycle by sending a response to the client with an error message.</p>
			<div><div><img src="img/B21678_10_7.jpg" alt="Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware</p>
			<p>We can also add a middleware function<a id="_idIndexMarker625"/> to a route, to validate (for example) that the user has the proper permissions to access the route, and if so then we can pass the request to the next middleware function in the pipeline, and if the user doesn’t have the proper permissions we can end the request-response cycle by sending a response to the client with an error message.</p>
			<div><div><img src="img/B21678_10_8.jpg" alt="Figure 10.8 – Middleware pattern  full process from application middleware to main function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Middleware pattern  full process from application middleware to main function</p>
			<p>When the main function of the middleware has any kind of problem, such as an exception, that doesn’t allow the middleware to continue with the request-response cycle, then the error middleware can take control and respond to the client with the error message.</p>
			<p>As you can see, the middleware pattern<a id="_idIndexMarker626"/> is quite complex to get familiar with, but at the same time is very powerful, because it allows us to abstract and reuse code easily. We can resolve the requests as sequence of functions where each function can take ownership when needed  so we can isolate the proper business logic quite well.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor291"/>Understanding the scope</h2>
			<p>So, we have three possible<a id="_idIndexMarker627"/> scopes for the middleware functions:</p>
			<ul>
				<li><strong class="bold">Global middleware</strong>: This will be executed for all<a id="_idIndexMarker628"/> the requests that are received by the application.</li>
				<li><strong class="bold">Route middleware</strong>: This will be executed<a id="_idIndexMarker629"/> for all the requests that are received by the route.</li>
				<li><strong class="bold">Error middleware</strong>: This will be executed<a id="_idIndexMarker630"/> when an error is thrown by a middleware function.</li>
			</ul>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor292"/>Middleware anatomy</h2>
			<p>So, let’s see the anatomy <a id="_idIndexMarker631"/>of a middleware function:</p>
			<pre class="source-code">
const middleware(req, res, next) {}</pre>			<p>Basically, a middleware function receives three parameters: the request object, the response object, and the next function.</p>
			<p>Now let’s see what we can do with a middleware function in detail.</p>
			<h3>Adding context to the request</h3>
			<p>One very common use case for middleware<a id="_idIndexMarker632"/> functions is to add context to the request object. The idea is to extend the request object with additional properties that will be used by the next middleware functions in the pipeline. Let’s see an example:</p>
			<pre class="source-code">
const detectLangMiddleware(req, res, next) {
    req.lang = req.headers['accept-language'] || 'en'
    next()
}</pre>			<p>In the preceding example, we are adding a new property to the request object called <code>lang</code>. This property can be consumed by the next middleware functions in the pipeline as <code>req.lang</code>.</p>
			<p>This is a very simple example but is quite commonly deployed to create simple and focused middleware functions that can be composed easily.</p>
			<p>As you can see, <code>detectLangMiddleware</code> is using <code>next()</code> to let Express know that the middleware has finished and there were no errors. In this case, if we don’t call <code>next()</code>, the application will hang forever.</p>
			<h3>Managing responses</h3>
			<p>Another common use case for middleware<a id="_idIndexMarker633"/> functions is to manage the response. For example, we can add a middleware function that will redirect the user to <a href="https://updatemybrowser.org/">https://updatemybrowser.org/</a> if the user is using Internet Explorer:</p>
			<pre class="source-code">
const legacyBrowsersMiddleware(req, res, next) {
    if (req.headers['user-agent'].includes('MSIE')) {
        res.redirect('https://updatemybrowser.org/')
    } else {
        next()
    }
}</pre>			<p>As you can see, if the user is using Internet Explorer, they will be redirected to <a href="https://updatemybrowser.org/">https://updatemybrowser.org/</a>. We do not call <code>next()</code> because we don’t want to continue with the request-response cycle as we have already sent a response to the client with <code>res.redirect()</code>.</p>
			<p>If the user is not using Internet<a id="_idIndexMarker634"/> Explorer, we call <code>next()</code> to continue with the request-response cycle as usual.</p>
			<h3>Additional configuration</h3>
			<p>In <a href="B21678_03.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a>, we learned how closures<a id="_idIndexMarker635"/> work. It is quite common to use closures to add additional configuration to the middleware functions. Let’s see an example:</p>
			<pre class="source-code">
const detectLangMiddleware = defaultLang =&gt; (req, res, next) =&gt; {
    req.lang = req.headers['accept-language'] || defaultLang
    next()
}</pre>			<p>In the preceding code, we have changed the middleware function from before to use a closure to receive the default language as a parameter, so we don’t need to use <code>en</code> by default.</p>
			<p>So now this middleware function will be executed as follows:</p>
			<pre class="source-code">
import { detectLangMiddleware } from './utils'
// With the closure
app.use(detectLangMiddleware('es'))
// without the closure
app.use(detectLangMiddleware)</pre>			<p>This is a common pattern for middleware functions that require additional configuration, such as the default language in this case, or tokens, and so on.</p>
			<h3>Testing</h3>
			<p>An additional advantage<a id="_idIndexMarker636"/> of this middleware pattern is that we can unit test the middleware functions easily because they are just functions that receive a request, a response, and a next function as parameters, and then execute them. We can mock the request and the response, and we can mock the next function to check that the middleware is working properly.</p>
			<p>We will see this in more detail later this chapter, but<a id="_idIndexMarker637"/> in the meantime, you can check my library called <code>user-language-middleware</code> (<a href="https://www.npmjs.com/package/user-language-middleware">https://www.npmjs.com/package/user-language-middleware</a>). The full test suite can be found at <a href="https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js">https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js</a> to get more familiar with the testing of middleware functions.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor293"/>Adding middleware to the application</h2>
			<p>You can add middleware<a id="_idIndexMarker638"/> to the application<a id="_idIndexMarker639"/> using the <code>app.use()</code> method. This method receives a middleware function as a parameter and will be executed for all the requests received by the application:</p>
			<pre class="source-code">
app.use(legacyBrowsersMiddleware)</pre>			<p>Note that the order of the middleware functions is important because they will be executed in the same order that they are added to the application.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor294"/>Adding middleware to a route</h2>
			<p>You can add the<a id="_idIndexMarker640"/> middleware<a id="_idIndexMarker641"/> to a route the same way that you add it to an application, only using the <code>app.METHOD()</code> method instead of <code>app.use()</code>:</p>
			<pre class="source-code">
app.get('/users', legacyBrowsersMiddleware, (req, res) =&gt; {
    res.send('Hello world')
})</pre>			<p>So, <code>legacyBrowsersMiddleware</code> will be executed only for the <code>GET /users</code> route, and if <code>legacyBrowsersMiddleware</code> calls <code>next()</code> the next middleware function in the pipeline will be executed, whichi in this case is <code>(req, res) =&gt; { res.send('Hello </code><code>world') }</code>.</p>
			<p>Yes, we have been using this pattern<a id="_idIndexMarker642"/> since the beginning of the chapter! It is indeed<a id="_idIndexMarker643"/> fair to say <em class="italic">all the routes are middleware functions </em><em class="italic">in Express.</em></p>
			<h3>Chaining middleware</h3>
			<p>You can chain middleware functions<a id="_idIndexMarker644"/> in the same <code>app.METHOD()</code> method, simply by adding the following:</p>
			<pre class="source-code">
app.get('/users', legacyBrowsersMiddleware, detectLangMiddleware, (req, res) =&gt; {
    res.send('Hello world')
})</pre>			<p>This is very common in large applications where you have a lot of middleware functions that are executed in a specific order. It is a good practice to review the order of the middleware functions to avoid unexpected behaviors and to migrate them to the application level if they are used in multiple routes, adapting the business logic if needed.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor295"/>Common middleware used in Express</h2>
			<p>Historically, the Express team<a id="_idIndexMarker645"/> has included some middleware functions in the framework, but most of them have been moved to external packages since Express 4. However, there are still a few middleware functions included in the framework.</p>
			<h3>Static files</h3>
			<p>Express includes a middleware<a id="_idIndexMarker646"/> function to serve static files from a directory. This is very useful to serve the static assets of a web application, such as images, CSS files, or JavaScript files:</p>
			<pre class="source-code">
app.use(express.static('public'))</pre>			<p>You can also use multiple<a id="_idIndexMarker647"/> directories to serve static files:</p>
			<pre class="source-code">
app.use(express.static('public'))
app.use(express.static('files'))</pre>			<h3>Error handling</h3>
			<p>Express includes a middleware<a id="_idIndexMarker648"/> function to handle errors. This middleware function must be the last one in the pipeline, and it must receive four parameters instead of three. The first parameter is the error, the second is the request, third is the response, and the fourth one is the next function:</p>
			<pre class="source-code">
app.use((err, req, res, next) =&gt; {
    console.error(err.stack)
    res.status(500).send('Ohh! The Server needs some love')
})</pre>			<p>If you have an error in any middleware function, you can call <code>next(err)</code> and this middleware function will be executed, as it also will if you throw an error in a route handler. Let’s see it in action:</p>
			<pre class="source-code">
import express from 'express'
const app = express()
const port = 3000
app.get('/next-error', (req, res, next) =&gt; {
    next(new Error('Ohh! Something went wrong'))
})
app.get('/throw-error', (req, res) =&gt; {
    throw new Error('Ohh! Something went wrong')
})
app.use((err, req, res, next) =&gt; {
    console.error(err.stack)
    res.status(500).send('Ohh! The Server needs some love')
})
app.listen(port, () =&gt; {
  console.log(`running at http://localhost:${port}`)
})</pre>			<p>If you now go to <a href="http://localhost:3000/next-error">http://localhost:3000/next-error</a> or <a href="http://localhost:3000/throw-error">http://localhost:3000/throw-error</a>, you will see that the error handler middleware function is taking control.</p>
			<p>In the next section, we will continue learning about the middleware pattern, but we will focus on the third-party middleware functions available in the ecosystem. Currently, there is huge amount of middleware functions that you can use in your Express applications, so it is important to know how to use them properly. While using third-party middleware functions<a id="_idIndexMarker649"/> you can save a lot of time and effort, you need to be careful because it means adding more dependencies to your project.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor296"/>Using third-party middleware</h1>
			<p>There are a lot of third-party middleware<a id="_idIndexMarker650"/> functions that you can use in your Express applications. Let’s see how to install and use them.</p>
			<p>One of the most popular<a id="_idIndexMarker651"/> middleware functions is <code>body-parser</code> (<a href="https://www.npmjs.com/package/body-parser">https://www.npmjs.com/package/body-parser</a>). Basically, it will parse the HTTP body of the incoming request and make it available under the <code>req.body</code> property.</p>
			<p>Install it using <code>npm</code> as follows:</p>
			<pre class="console">
npm install body-parser@1</pre>			<p>Then you can import it and use it in your application. Create a new file called <code>echo_payload.js</code> with the following content:</p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
const app = express()
const port = 3000
app.use(bodyParser.json())
app.post('/echo', (req, res) =&gt; {
    // Echo the request body
    res.json(req.body)
})
app.listen(port, () =&gt; {
  console.log(`running at http://localhost:${port}`)
})</pre>			<p>Now run the application with <code>node echo_payload.js</code> and then use <code>curl</code> or a similar tool to send a POST request to the <code>/</code><code>echo</code> route:</p>
			<pre class="source-code">
curl -X POST -H "Content-Type: application/json" -d '{"name":"John"}' http://localhost:3000/echo</pre>			<p>You will see that the response<a id="_idIndexMarker652"/> is the same JSON that you sent in the request body.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor297"/>Summary</h1>
			<p>In this chapter, we learned about the many uses of Express, including how to create a basic server, how to add routes, how to add static files, and how to use templates.</p>
			<p>Additionally, we learned how the middleware pattern works and how we can create our own middleware and use it at different levels in our application. We also checked out some third-party middleware including <code>body-parser</code>.</p>
			<p>In the next chapter, we will learn how to use a super test to test our first API in depth. We will cover how to test the routes and the stores and will create a solid API that we will develop in the coming chapters.</p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor298"/>Further reading</h1>
			<ul>
				<li>Express documentation: <a href="https://expressjs.com/">https://expressjs.com/</a></li>
				<li><em class="italic">Express, State of the Union</em> by Doug Wilson: <a href="https://www.youtube.com/watch?v=HxGt_3F0ULg">https://www.youtube.com/watch?v=HxGt_3F0ULg</a></li>
				<li><em class="italic">Node.js Foundation to Add Express as an Incubator </em><em class="italic">Project</em>: <a href="https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70">https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-291" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor299"/>Part 4: Building Solid Web Applications with Node.js</h1>
			<p>In <em class="italic">Part 4</em>, we will build a web application together using Express and MongoDB as the main stack. You will learn advanced topics such as error handling or security by implementing them in the project while learning all the theories and best practices to secure your web application.</p>
			<p>This part includes the following chapters:</p>
			<ul>
				<li><a href="B21678_11.xhtml#_idTextAnchor300"><em class="italic">Chapter 11</em></a>, <em class="italic">Building a Web Application Project from Scratch</em></li>
				<li><a href="B21678_12.xhtml#_idTextAnchor320"><em class="italic">Chapter 12</em></a>, <em class="italic">Data Persistence with MongoDB</em></li>
				<li><a href="B21678_13.xhtml#_idTextAnchor348"><em class="italic">Chapter 13</em></a>, <em class="italic">User Authentication and Authorization with Passport.js</em></li>
				<li><a href="B21678_14.xhtml#_idTextAnchor376"><em class="italic">Chapter 14</em></a>, <em class="italic">Error handling in Node.js</em></li>
				<li><a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>, <em class="italic">Securing Web Applications</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>