<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer010">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Lifecycles in Svelte</h1>
<p>Svelte is a frontend framework. You can use Svelte to build websites and web applications. A Svelte application is made up of components. You write a Svelte component within a file with <strong class="source-inline">.svelte</strong> extension. Each <strong class="source-inline">.svelte</strong> file is one <span class="No-Break">Svelte component.</span></p>
<p>When you create and use a Svelte component, the component goes through various stages of the component lifecycle. Svelte provides lifecycle functions, allowing you to hook into the different stages of <span class="No-Break">the component.</span></p>
<p>In this chapter, we will start by talking about the various lifecycles and the lifecycle functions in Svelte. With a clear idea of lifecycles in mind, you will then learn the basic rule of using the lifecycle functions. This is essential, as you will see that this understanding will allow us to use the lifecycle functions in a lot of <span class="No-Break">creative ways.</span></p>
<p>This chapter contains sections on the <span class="No-Break">following topics:</span></p>
<ul>
<li>What are Svelte <span class="No-Break">lifecycle functions?</span></li>
<li>The rule of calling <span class="No-Break">lifecycle functions</span></li>
<li>How to reuse and compose <span class="No-Break">lifecycle functions</span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>Writing Svelte applications is very easy and does not require any paid tools. Despite the added value of most paid tools, we decided to use only free tools to make the content of this book available to you without <span class="No-Break">any limitations.</span></p>
<p>You will require <span class="No-Break">the following:</span></p>
<ul>
<li>Visual Studio Code as the integrated development <span class="No-Break">environment (</span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">)</span></li>
<li>A decent web browser (Chrome, Firefox, or Edge, <span class="No-Break">for instance)</span></li>
<li>Node.js as the JavaScript runtime <span class="No-Break">environment (</span><a href="https://nodejs.org/"><span class="No-Break">https://nodejs.org/</span></a><span class="No-Break">)</span></li>
</ul>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01</span></a></p>
<p>Code for all chapters can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-19">Understanding the <a id="_idTextAnchor018"/>Svelte lifecycle functions</h1>
<p>When using a Svelte component, it goes through different stages throughout its lifetime: mounting, updating, and destroying. This is similar to a human being. We go through various stages in our lifetime, such as birth, growth, old age, and death, throughout our lifetime. We call the different <span class="No-Break">stages lifecycles.</span></p>
<p>Before we talk about lifecycles<a id="_idIndexMarker000"/> in Svelte, let’s look at a <span class="No-Break">Svelte component.</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount, beforeUpdate, afterUpdate, onDestroy } from 'svelte';
  let count = 0;
  onMount(() =&gt; { console.log('onMount!'); });
  beforeUpdate(() =&gt; { console.log('beforeUpdate!'); });
  afterUpdate(() =&gt; { console.log('afterUpdate!'); });
  onDestroy(() =&gt; { console.log('onDestroy!'); });
&lt;/script&gt;
&lt;button on:click={() =&gt; { count ++; }}&gt;
  Counter: {count}
&lt;/button&gt;</pre> <p>Can you tell me when each part of the code <span class="No-Break">is executed?</span></p>
<p>Not every part of the code is executed at once; different parts of the code are executed at different stages of the <span class="No-Break">component lifecycle.</span></p>
<p>A Svelte component has four different lifecycle stages: initializing, mounting, updating, <span class="No-Break">and destroying.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Initializing the component</h2>
<p>When you create a<a id="_idIndexMarker001"/> component, the component first goes through the initialization phase. You can think of this as the setup phase, where the component sets up its <span class="No-Break">internal state.</span></p>
<p>This is where lines 2–7 are <span class="No-Break">being executed.</span></p>
<p>The <strong class="source-inline">count</strong> variable is declared and initialized. The <strong class="source-inline">onMount</strong>, <strong class="source-inline">beforeUpdate</strong>, <strong class="source-inline">afterUpdate</strong>, and <strong class="source-inline">onDestroy</strong> lifecycle functions are called, with callback functions passed in, to register them at the specific stages of the <span class="No-Break">component lifecycles.</span></p>
<p>After the component is initialized, Svelte starts to create elements in the template, in this case, a <strong class="source-inline">&lt;button&gt;</strong> element and text elements for <strong class="source-inline">"Counter: "</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">{count}</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Mounting the component</h2>
<p>After all the elements are created, Svelte<a id="_idIndexMarker002"/> will insert them in order into the <strong class="bold">Document Object Model</strong> <strong class="bold">(DOM)</strong>. This is called the mounting phase, where<a id="_idIndexMarker003"/> elements are mounted onto <span class="No-Break">the DOM.</span></p>
<p>If you add Svelte actions to an element, then the actions are called with <span class="No-Break">the element:</span></p>
<pre class="source-code">
&lt;script&gt;
  function action(node) {}
&lt;/script&gt;
&lt;div use:action&gt;</pre> <p>We will explore Svelte actions in more depth in <a href="B18887_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> <span class="No-Break">to </span><span class="No-Break"><em class="italic">7</em></span><span class="No-Break">.</span></p>
<p>If and when you add event listeners to the element, this is when Svelte will attach the event listeners to <span class="No-Break">the element.</span></p>
<p>In the case of the preceding example, Svelte attaches the <strong class="source-inline">click</strong> event listener onto the button after it is inserted into <span class="No-Break">the DOM.</span></p>
<p>When we add bindings to an element, the bound variable gets updated with values from <span class="No-Break">the element:</span></p>
<pre class="source-code">
&lt;script&gt;
  let element;
&lt;/script&gt;
&lt;div bind:this={element} /&gt;</pre> <p>This is when the <strong class="source-inline">element</strong> variable gets updated with the reference to the <strong class="source-inline">&lt;div&gt;</strong> element created <span class="No-Break">by Svelte.</span></p>
<p>If and when you <a id="_idIndexMarker004"/>add transitions to an element, this is when the transitions are initialized and <span class="No-Break">start playing.</span></p>
<p>The following snippet is an example of adding a transition to an element. You can add a transition to an element using the <strong class="source-inline">transition:</strong>, <strong class="source-inline">in:</strong>, and <strong class="source-inline">out:</strong> directives. We will explore more about Svelte transitions in <a href="B18887_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> <span class="No-Break">to </span><span class="No-Break"><em class="italic">15</em></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;div in:fade /&gt;</pre> <p>After all the directives, <strong class="source-inline">use:</strong> (actions), <strong class="source-inline">on:</strong> (event listeners), <strong class="source-inline">bind:</strong> bindings, <strong class="source-inline">in:</strong>, <strong class="source-inline">transition:</strong> (transitions), are processed, the mounting phase comes to an end by calling all the functions registered in the <strong class="source-inline">onMount</strong> <span class="No-Break">lifecycle functions.</span></p>
<p>This is when the function on line 4 is executed, and you will see <strong class="source-inline">"onMount!"</strong> printed in <span class="No-Break">the logs.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Updating the component</h2>
<p>When you<a id="_idIndexMarker005"/> click on the button, the <strong class="source-inline">click</strong> event listener is called. The function on line 9 is executed. The <strong class="source-inline">count</strong> variable <span class="No-Break">is incremented.</span></p>
<p>Right before Svelte modifies the DOM based on the latest value of the <strong class="source-inline">count</strong> variable, the functions registered in the <strong class="source-inline">beforeUpdate</strong> lifecycle function <span class="No-Break">are called.</span></p>
<p>The function on line 5 is executed, and you will see the text <strong class="source-inline">"beforeUpdate!"</strong> printed in <span class="No-Break">the logs.</span></p>
<p>At this point, if you attempt to retrieve the text content within the button, it would still be <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Counter: 0"</strong></span><span class="No-Break">.</span></p>
<p>Svelte then proceeds to modify the DOM, updating the text content of the button to <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Counter: 1"</strong></span><span class="No-Break">.</span></p>
<p>After updating all the elements within the component, Svelte calls all the functions registered in the <strong class="source-inline">afterUpdate</strong> <span class="No-Break">lifecycle function.</span></p>
<p>The function on line 6 is executed, and you will see the text <strong class="source-inline">"afterUpdate!"</strong> printed in <span class="No-Break">the logs.</span></p>
<p>If you click on the button <a id="_idIndexMarker006"/>again, Svelte will go through another cycle of <strong class="source-inline">beforeUpdate</strong>, and then update the DOM elements, and <span class="No-Break">then </span><span class="No-Break"><strong class="source-inline">afterUpdate</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Destroying the component</h2>
<p>A component that is <a id="_idIndexMarker007"/>conditionally shown to a user will remain while the condition holds; when the condition no longer holds, Svelte will proceed to destroy <span class="No-Break">the component.</span></p>
<p>Let’s say the component in our example now enters the <span class="No-Break">destroy stage.</span></p>
<p>Svelte calls all the functions registered in the <strong class="source-inline">onDestroy</strong> lifecycle function. The function on line 7 is executed, and you will see the text <strong class="source-inline">"onDestroy!"</strong> printed in <span class="No-Break">the logs.</span></p>
<p>After that, Svelte removes the elements from <span class="No-Break">the DOM.</span></p>
<p>Svelte then cleans up the directives if necessary, such as removing the event listeners and calling the destroy method from <span class="No-Break">the action.</span></p>
<p>And that’s it! If you try to recreate the component again, a new cycle <span class="No-Break">starts again.</span></p>
<p>The Svelte component lifecycle starts with initializing, mounting, updating, and destroying. Svelte provides lifecycle methods, allowing you to run functions at different stages of <span class="No-Break">the component.</span></p>
<p>Since the component lifecycle functions are just functions exported from <strong class="source-inline">'svelte'</strong>, can you import and use them anywhere? Are there any rules or constraints when importing and <span class="No-Break">using them?</span></p>
<p>Let’s <span class="No-Break">find out.</span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>The one rule for calling lifecycle functions</h1>
<p>The only rule for calling<a id="_idIndexMarker008"/> component lifecycle functions is that you should call them during component initialization. If no component is being initialized, Svelte will complain by throwing <span class="No-Break">an error.</span></p>
<p>Let’s look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  function buttonClicked() {
    onMount(() =&gt; console.log('onMount!'));
  }
&lt;/script&gt;
&lt;button on:click={buttonClicked} /&gt;</pre> <p>When you click on the button, it will call <strong class="source-inline">buttonClicked</strong>, which will call <strong class="source-inline">onMount</strong>. As no component is being initialized when <strong class="source-inline">onMount</strong> is being called, (the component above has initialized and mounted by the time you click on the button), Svelte throws <span class="No-Break">an error:</span></p>
<pre class="source-code">
Error: Function called outside component initialization</pre> <p>Yes, Svelte does not allow lifecycle functions to be called outside of the component initialization phase. This rule dictates when you can call the lifecycle functions. What it does not dictate is where or how you call the lifecycle functions. This allows us to refactor lifecycle functions and call them in <span class="No-Break">other ways.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Refactoring lifecycle functions</h2>
<p>If you look<a id="_idIndexMarker009"/> carefully at the rule for calling lifecycle functions, you will notice that it is about when you call them, and not where you <span class="No-Break">call them.</span></p>
<p>It is not necessary to call lifecycle functions at the top level within the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">script&gt;</strong></span><span class="No-Break"> tag.</span></p>
<p>In the following example, the <strong class="source-inline">setup</strong> function is called during component initialization, and in turn calls the <span class="No-Break"><strong class="source-inline">onMount</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  setup();
  function setup() {
    onMount(() =&gt; console.log('onMount!'));
  }
&lt;/script&gt;</pre> <p>Since the component is still initializing, this is <span class="No-Break">perfectly fine.</span></p>
<p>It is also not necessary to import the <strong class="source-inline">onMount</strong> function within the component. As you see in the following <a id="_idIndexMarker010"/>example, you can import it in another file; as long as the <strong class="source-inline">onMount</strong> function is called during component initialization, it is <span class="No-Break">perfectly fine:</span></p>
<pre class="source-code">
// file-a.js
import { onMount } from 'svelte';
export function setup() {
  onMount(() =&gt; console.log('onMount!'));
}</pre> <p>In the preceding code snippet, we’ve moved the <strong class="source-inline">setup</strong> function we defined previously to a new module called <strong class="source-inline">file-a.js</strong>. Then, in the original Svelte component, rather than defining the <strong class="source-inline">setup</strong> function, we import it from <strong class="source-inline">file-a.js</strong>, shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { setup } from './file-a.js';
  setup();
&lt;/script&gt;</pre> <p>Since the <strong class="source-inline">setup</strong> function calls the <strong class="source-inline">onMount</strong> function, the same rule applies to the <strong class="source-inline">setup</strong> function<a id="_idIndexMarker011"/> too! You can no longer call the <strong class="source-inline">setup</strong> function outside <span class="No-Break">component initialization.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Which component to register?</h2>
<p>Looking at just the <strong class="source-inline">setup</strong> function, you may be wondering, when you call the <strong class="source-inline">onMount</strong> function, how <a id="_idIndexMarker012"/>does Svelte know which component’s lifecycle you are <span class="No-Break">referring to?</span></p>
<p>Internally, Svelte keeps track of which component is initializing. When you call the lifecycle functions, it will register your function to the lifecycle of the component that is <span class="No-Break">being initialized.</span></p>
<p>So, the same <strong class="source-inline">setup</strong> function can be called within different components and registers the <strong class="source-inline">onMount</strong> function for <span class="No-Break">different components.</span></p>
<p>This unlocks the first pattern in this chapter: reusing <span class="No-Break">lifecycle functions.</span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Reusing lifecycle functions in Svelte components</h1>
<p>In the previous section, we<a id="_idIndexMarker013"/> learned that we can extract the calling of lifecycle functions into a function and reuse the function in <span class="No-Break">other</span><span class="No-Break"><a id="_idIndexMarker014"/></span><span class="No-Break"> components.</span></p>
<p>Let’s look at an example. In this example, after the component is added to the screen for 5 seconds, it will call the <strong class="source-inline">showPopup</strong> function. I want to reuse this logic of calling <strong class="source-inline">showPopup</strong> in <span class="No-Break">other components:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  import { showPopup } from './popup';
  onMount(() =&gt; {
    const timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
&lt;/script&gt;</pre> <p>Here, I can extract<a id="_idIndexMarker015"/> the logic into a <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">showPopupOnMount</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
// popup-on-mount.js
import { onMount } from 'svelte';
import { showPopup } from './popup';
export function showPopupOnMount() {
  onMount(() =&gt; {
    const timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
}</pre> <p>And now, I can import<a id="_idIndexMarker016"/> this function and reuse it in <span class="No-Break">any component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  showPopupOnMount();
&lt;/script&gt;</pre> <p>You may be wondering, why not only extract the callback function and reuse <span class="No-Break">that instead?</span></p>
<pre class="source-code">
// popup-on-mount.js
import { showPopup } from './popup';
export function showPopupOnMount() {
  const timeoutId = setTimeout(() =&gt; {
    showPopup();
  }, 5000);
  return () =&gt; clearTimeout(timeoutId);
}</pre> <p>Over here, we extract <a id="_idIndexMarker017"/>only <strong class="source-inline">setTimeout</strong> and <strong class="source-inline">clearTimeout</strong> logic<a id="_idIndexMarker018"/> into <strong class="source-inline">showPopupOnMount</strong>, and pass the function <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">onMount</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  import { showPopupOnMount } from './popup-on-mount';
  onMount(showPopupOnMount);
&lt;/script&gt;</pre> <p>In my opinion, the second approach of refactoring and reusing is not as good as the first approach. There are a few pros in extracting the entire calling of the lifecycle functions into a function, as it allows you to do much more than you <span class="No-Break">can otherwise:</span></p>
<ul>
<li><em class="italic">You can pass in different input parameters to your </em><span class="No-Break"><em class="italic">lifecycle functions.</em></span><p class="list-inset">Let’s say you wish to allow different components to customize the duration before showing the popup. It is much easier to pass that in <span class="No-Break">this way:</span></p><pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  <strong class="bold">showPopupOnMount(2000);</strong> // change it to 2s
&lt;/script&gt;</pre></li> <li><em class="italic">You can return values from </em><span class="No-Break"><em class="italic">the function.</em></span><p class="list-inset">Let’s say you want to return the <strong class="source-inline">timeoutId</strong> used in the <strong class="source-inline">onMount</strong> function so that you can cancel it if the user clicks on any button within <span class="No-Break">the component.</span></p><p class="list-inset">It is near impossible <a id="_idIndexMarker019"/>to do so if you just reuse the <a id="_idIndexMarker020"/>callback function, as the value returned from the callback function will be used to register for the <strong class="source-inline">onDestroy</strong> <span class="No-Break">lifecycle function:</span></p><pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  <strong class="bold">const timeoutId = showPopupOnMount(2000);</strong>
&lt;/script&gt;
&lt;button on:click={() =&gt; clearTimeout(timeoutId)} /&gt;</pre><p class="list-inset">See how easy it is to implement it to return anything if we write it <span class="No-Break">this way:</span></p><pre class="source-code">// popup-on-mount.js
export function showPopupOnMount(duration) {
  let timeoutId;
  onMount(() =&gt; {
    timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, duration ?? 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
  <strong class="bold">return timeoutId;</strong>
}</pre></li> <li><em class="italic">You can encapsulate more logic along with the </em><span class="No-Break"><em class="italic">lifecycle functions.</em></span><p class="list-inset">Sometimes, the code in your lifecycle functions callback function does not work in a silo; it interacts <a id="_idIndexMarker021"/>with and modifies other variables. To reuse lifecycle functions like this, you must encapsulate those variables and logic into a <span class="No-Break">reusable function.</span></p><p class="list-inset">To illustrate this, let’s look at<a id="_idIndexMarker022"/> a <span class="No-Break">new example.</span></p><p class="list-inset">Here, I have a counter that starts counting when a component is added to <span class="No-Break">the screen:</span></p><pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let counter = 0;
  onMount(() =&gt; {
    const intervalId = setInterval(() =&gt; counter++, 1000);
    return () =&gt; clearInterval(intervalId);
  });
&lt;/script&gt;
&lt;span&gt;{counter}&lt;/span&gt;</pre><p class="list-inset">The <strong class="source-inline">counter</strong> variable is coupled with the <strong class="source-inline">onMount</strong> lifecycle functions; to reuse this logic, the <strong class="source-inline">counter</strong> variable and the <strong class="source-inline">onMount</strong> function should be extracted together into a <span class="No-Break">reusable function:</span></p><pre class="source-code">import { writable } from 'svelte/store';
import { onMount } from 'svelte';
export function startCounterOnMount() {
  const counter = writable(0);
  onMount(() =&gt; {
    const intervalId = setInterval(() =&gt; counter.update($counter =&gt; $counter + 1), 1000);
    return () =&gt; clearInterval(intervalId);
  });
  return counter;
}</pre><p class="list-inset">In this example, we use a <strong class="source-inline">writable</strong> Svelte store to make the <strong class="source-inline">counter</strong> variable reactive. We <a id="_idIndexMarker023"/>will delve more into Svelte stores in <em class="italic">Part 3</em> of <span class="No-Break">this book.</span></p><p class="list-inset">For now, all <a id="_idIndexMarker024"/>you need to understand is that a Svelte store allows Svelte to track changes in a variable across modules, and you can subscribe to and retrieve the value of the store by prefixing a <strong class="source-inline">$</strong> in front of a Svelte store variable. For example, if you have a Svelte store named <strong class="source-inline">counter</strong>, then to get the value of the Svelte store, you would need to use the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">counter</strong></span><span class="No-Break"> variable.</span></p><p class="list-inset">Now, we can use the <strong class="source-inline">startCounterOnMount</strong> function in any <span class="No-Break">Svelte component:</span></p><pre class="source-code">&lt;script&gt;
  import { startCounterOnMount } from './counter';
  const counter = startCounterOnMount();
&lt;/script&gt;
&lt;span&gt;{$counter}&lt;/span&gt;</pre></li> </ul>
<p>I hope I’ve convinced you about the pros of extracting the calling of lifecycle functions into a function. Let’s try it out in <span class="No-Break">an example.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Exercise 1 – Update counter</h2>
<p>In the following<a id="_idIndexMarker025"/> example code, I want to know how many times the component has gone through the <span class="No-Break">update cycle.</span></p>
<p>Using the fact that every time the component goes through the update cycle, the <strong class="source-inline">afterUpdate</strong> callback function will be called, I created a counter that will be incremented every time the <strong class="source-inline">afterUpdate</strong> callback function <span class="No-Break">is called.</span></p>
<p>To help us measure only the update count of a certain user operation, we have functions to start <a id="_idIndexMarker026"/>measuring and stop measuring, so the update counter is only incremented when we <span class="No-Break">are measuring:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { afterUpdate } from 'svelte';
  let updateCount = 0;
  let measuring = false;
  afterUpdate(() =&gt; {
    if (measuring) {
      updateCount ++;
    }
  });
  function startMeasuring() {
    updateCount = 0;
    measuring = true;
  }
  function stopMeasuring() {
    measuring = false;
  }
&lt;/script&gt;
&lt;button on:click={startMeasuring}&gt;Measure&lt;/button&gt;
&lt;button on:click={stopMeasuring}&gt;Stop&lt;/button&gt;
&lt;span&gt;Updated {updateCount} times&lt;/span&gt;</pre> <p>To reuse all the logic of the <strong class="source-inline">counter:</strong> – the counting of update cycles and the starting and stopping of the <a id="_idIndexMarker027"/>measurement – we should move all of it into a function, which ends up looking <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { createUpdateCounter } from './update-counter';
  const { updateCount, startMeasuring, stopMeasuring } = createUpdateCounter();
&lt;/script&gt;
&lt;button on:click={startMeasuring}&gt;Measure&lt;/button&gt;
&lt;button on:click={stopMeasuring}&gt;Stop&lt;/button&gt;
&lt;span&gt;Updated {$updateCount} times&lt;/span&gt;</pre> <p>The update counter returns an object that contains the <strong class="source-inline">updateCount</strong> variable and the <strong class="source-inline">startMeasuring</strong> and <span class="No-Break"><strong class="source-inline">stopMeasuring</strong></span><span class="No-Break"> functions.</span></p>
<p>The implementation of the <strong class="source-inline">createUpdateCounter</strong> function is left as an exercise to you, and you can check the answer <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter</span></a><span class="No-Break">.</span></p>
<p>We’ve learned how to extract a lifecycle function and reuse it, so let’s take it up a notch and reuse multiple lifecycle functions in the next pattern: composing <span class="No-Break">lifecycle functions.</span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Composing lifecycle functions into reusable hooks</h1>
<p>So far, we’ve mainly <a id="_idIndexMarker028"/>talked about reusing one lifecycle function. However, there’s nothing stopping us from grouping multiple lifecycle functions to perform <span class="No-Break">a function.</span></p>
<p>Here’s an excerpt from the example at <a href="https://svelte.dev/examples/update">https://svelte.dev/examples/update</a>. The example shows a list of messages. When new messages are added to the list, the container will automatically scroll to the bottom to show the new message. In the code snippet, we see that this automatic scrolling behavior is achieved by using a combination of <strong class="source-inline">beforeUpdate</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">afterUpdate</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { beforeUpdate, afterUpdate } from 'svelte';
  let div;
  let autoscroll;
  beforeUpdate(() =&gt; {
    autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
  });
  afterUpdate(() =&gt; {
    if (autoscroll) div.scrollTo(0, div.scrollHeight);
  });
&lt;/script&gt;
&lt;div bind:this={div} /&gt;</pre> <p>To reuse this <strong class="source-inline">autoscroll</strong> logic in other components, we can extract the <strong class="source-inline">beforeUpdate</strong> and <strong class="source-inline">afterUpdate</strong> logic together into a <span class="No-Break">new function:</span></p>
<pre class="source-code">
export function setupAutoscroll() {
  let div;
  let autoscroll;
  beforeUpdate(() =&gt; {
    autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
  });
  afterUpdate(() =&gt; {
    if (autoscroll) div.scrollTo(0, div.scrollHeight);
  });
  return {
  setDiv(_div) {
  div = _div;
    },
  };
}</pre> <p>We can then use<a id="_idIndexMarker029"/> the extracted function, <strong class="source-inline">setupAutoScroll</strong>, in <span class="No-Break">any component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { setupAutoscroll } from './autoscroll';
  const { setDiv } = setupAutoscroll();
  let div;
  $: setDiv(div);
&lt;/script&gt;
&lt;div bind:this={div} /&gt;</pre> <p>In the refactored <strong class="source-inline">setupAutoscroll</strong> function, we return a <strong class="source-inline">setDiv</strong> function to allow us to update the reference of the <strong class="source-inline">div</strong> used within the <span class="No-Break"><strong class="source-inline">setupAutoscroll</strong></span><span class="No-Break"> function.</span></p>
<p>As you’ve seen, by adhering to the one rule of calling lifecycle functions during component initialization, you can compose multiple lifecycle functions into reusable hooks. What you’ve learned so far is sufficient for composing lifecycle functions, but there are more alternatives on the horizon. In the upcoming chapters, you’ll explore Svelte actions in <a href="B18887_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> and the Svelte store in <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, expanding your options further. Here’s a sneak peek at some of <span class="No-Break">these alternatives.</span></p>
<p>An alternative<a id="_idIndexMarker030"/> implementation could be to make <strong class="source-inline">div</strong> a writable store and return it from the <strong class="source-inline">setupAutoscroll</strong> function. This way, we could bind to the <strong class="source-inline">div</strong> writable store directly instead of having to call <span class="No-Break"><strong class="source-inline">setDiv</strong></span><span class="No-Break"> manually.</span></p>
<p>Alternatively, we could return a function that follows the Svelte action contract and use the action on <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
export function setupAutoscroll() {
  let div;
  // ...
  return function (node) {
    div = node;
    return {
      destroy() {
        div = undefined;
      },
    };
  };
}</pre> <p><strong class="source-inline">setupAutoscroll</strong> now returns an action, and we use the action on our <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> container:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { setupAutoscroll } from './autoscroll';
  const autoscroll = setupAutoscroll();
&lt;/script&gt;
&lt;div use:autoscroll /&gt;</pre> <p>We will discuss the Svelte action contract in more detail later in <span class="No-Break">the book.</span></p>
<p>We’ve seen how <a id="_idIndexMarker031"/>we can extract lifecycle functions into a separate file and reuse it in multiple Svelte components. Currently, the components call the lifecycle functions independently and function as standalone units. Is it possible to synchronize or coordinate actions across components that uses the same lifecycle functions? Let’s <span class="No-Break">find out.</span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Coordinating lifecycle functions across components</h1>
<p>As we reuse the same<a id="_idIndexMarker032"/> function across components, we can keep track globally of the components that use the same <span class="No-Break">lifecycle function.</span></p>
<p>Let me show you an example. Here, I would like to keep track of how many components on the screen are using our <span class="No-Break">lifecycle function.</span></p>
<p>To count the number of components, we can define a module-level variable and update it within our <span class="No-Break">lifecycle function:</span></p>
<pre class="source-code">
import { onMount, onDestroy } from 'svelte';
import { writable } from 'svelte/store';
let counter = writable(0);
export function setupGlobalCounter() {
  onMount(() =&gt; counter.update($counter =&gt; $counter + 1));
  onDestroy(() =&gt; counter.update($counter =&gt; $counter - 1));
  return counter;
}</pre> <p>As the <strong class="source-inline">counter</strong> variable is declared outside the <strong class="source-inline">setupGlobalCounter</strong> function, the same <strong class="source-inline">counter</strong> variable instance is used and shared across all <span class="No-Break">the components.</span></p>
<p>When any component is mounted, it will increment the <strong class="source-inline">counter</strong>, and any component that is referring to the <strong class="source-inline">counter</strong> will get updated with the latest <span class="No-Break">counter value.</span></p>
<p>This pattern is extremely<a id="_idIndexMarker033"/> useful when you want to set up a shared communication channel between components and tear it down in <strong class="source-inline">onDestroy</strong> when the component is <span class="No-Break">being destroyed.</span></p>
<p>Let’s try to use this technique in our <span class="No-Break">next exercise.</span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Exercise 2 – Scroll blocker</h2>
<p>Usually, when you<a id="_idIndexMarker034"/> add a pop-up component onto the screen, you want the document to not be scrollable so that the user focuses on the popup and only scrolls within <span class="No-Break">the popup.</span></p>
<p>This can be done by setting the <strong class="source-inline">overflow</strong> CSS property of the body <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"hidden"</strong></span><span class="No-Break">.</span></p>
<p>Write a reusable function used by pop-up components that disables scrolling when the pop-up component is mounted. Restore the initial <strong class="source-inline">overflow</strong> property value when the pop-up component <span class="No-Break">is destroyed.</span></p>
<p>Do note that it is possible to have more than one pop-up component mounted on the screen at once, so you should only restore the <strong class="source-inline">overflow</strong> property value when all the popups <span class="No-Break">are destroyed.</span></p>
<p>You can check the answer <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
<p>In this chapter, we went through the lifecycles of a Svelte component. We saw the different stages of a component lifecycle and learned when the lifecycle function callbacks will <span class="No-Break">be called.</span></p>
<p>We also covered the rule of calling lifecycle functions. This helps us to realize the different patterns of reusing and composing <span class="No-Break">lifecycle functions.</span></p>
<p>In the next chapter, we will start to look at the different patterns for styling and theming a <span class="No-Break">Svelte component.</span></p>
</div>
</div></body></html>