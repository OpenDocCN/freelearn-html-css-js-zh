<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Lifecycles in Svelte</h1>
<p>Svelte is a frontend framework. You can use Svelte to build websites and web applications. A Svelte application is made up of components. You write a Svelte component within a file with <code>.svelte</code> extension. Each <code>.svelte</code> file is one Svelte component.</p>
<p>When you create and use a Svelte component, the component goes through various stages of the component lifecycle. Svelte provides lifecycle functions, allowing you to hook into the different stages of the component.</p>
<p>In this chapter, we will start by talking about the various lifecycles and the lifecycle functions in Svelte. With a clear idea of lifecycles in mind, you will then learn the basic rule of using the lifecycle functions. This is essential, as you will see that this understanding will allow us to use the lifecycle functions in a lot of creative ways.</p>
<p>This chapter contains sections on the following topics:</p>
<ul>
<li>What are Svelte lifecycle functions?</li>
<li>The rule of calling lifecycle functions</li>
<li>How to reuse and compose lifecycle functions</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>Writing Svelte applications is very easy and does not require any paid tools. Despite the added value of most paid tools, we decided to use only free tools to make the content of this book available to you without any limitations.</p>
<p>You will require the following:</p>
<ul>
<li>Visual Studio Code as the integrated development environment (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>)</li>
<li>A decent web browser (Chrome, Firefox, or Edge, for instance)</li>
<li>Node.js as the JavaScript runtime environment (<a href="https://nodejs.org/">https://nodejs.org/</a>)</li>
</ul>
<p>All the code examples for this chapter can be found on GitHub at: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01</a></p>
<p>Code for all chapters can be found at <a href="https://github.com/PacktPublishing/Real-World-Svelte">https://github.com/PacktPublishing/Real-World-Svelte</a>.</p>
<h1 id="_idParaDest-19">Understanding the <a id="_idTextAnchor018"/>Svelte lifecycle functions</h1>
<p>When using a Svelte component, it goes through different stages throughout its lifetime: mounting, updating, and destroying. This is similar to a human being. We go through various stages in our lifetime, such as birth, growth, old age, and death, throughout our lifetime. We call the different stages lifecycles.</p>
<p>Before we talk about lifecycles<a id="_idIndexMarker000"/> in Svelte, let’s look at a Svelte component.</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount, beforeUpdate, afterUpdate, onDestroy } from 'svelte';
  let count = 0;
  onMount(() =&gt; { console.log('onMount!'); });
  beforeUpdate(() =&gt; { console.log('beforeUpdate!'); });
  afterUpdate(() =&gt; { console.log('afterUpdate!'); });
  onDestroy(() =&gt; { console.log('onDestroy!'); });
&lt;/script&gt;
&lt;button on:click={() =&gt; { count ++; }}&gt;
  Counter: {count}
&lt;/button&gt;</pre> <p>Can you tell me when each part of the code is executed?</p>
<p>Not every part of the code is executed at once; different parts of the code are executed at different stages of the component lifecycle.</p>
<p>A Svelte component has four different lifecycle stages: initializing, mounting, updating, and destroying.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Initializing the component</h2>
<p>When you create a<a id="_idIndexMarker001"/> component, the component first goes through the initialization phase. You can think of this as the setup phase, where the component sets up its internal state.</p>
<p>This is where lines 2–7 are being executed.</p>
<p>The <code>count</code> variable is declared and initialized. The <code>onMount</code>, <code>beforeUpdate</code>, <code>afterUpdate</code>, and <code>onDestroy</code> lifecycle functions are called, with callback functions passed in, to register them at the specific stages of the component lifecycles.</p>
<p>After the component is initialized, Svelte starts to create elements in the template, in this case, a <code>&lt;button&gt;</code> element and text elements for <code>"Counter: "</code> and <code>{count}</code>.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Mounting the component</h2>
<p>After all the elements are created, Svelte<a id="_idIndexMarker002"/> will insert them in order into the <strong class="bold">Document Object Model</strong> <strong class="bold">(DOM)</strong>. This is called the mounting phase, where<a id="_idIndexMarker003"/> elements are mounted onto the DOM.</p>
<p>If you add Svelte actions to an element, then the actions are called with the element:</p>
<pre class="source-code">
&lt;script&gt;
  function action(node) {}
&lt;/script&gt;
&lt;div use:action&gt;</pre> <p>We will explore Svelte actions in more depth in <a href="B18887_05.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a> to <em class="italic">7</em>.</p>
<p>If and when you add event listeners to the element, this is when Svelte will attach the event listeners to the element.</p>
<p>In the case of the preceding example, Svelte attaches the <code>click</code> event listener onto the button after it is inserted into the DOM.</p>
<p>When we add bindings to an element, the bound variable gets updated with values from the element:</p>
<pre class="source-code">
&lt;script&gt;
  let element;
&lt;/script&gt;
&lt;div bind:this={element} /&gt;</pre> <p>This is when the <code>element</code> variable gets updated with the reference to the <code>&lt;div&gt;</code> element created by Svelte.</p>
<p>If and when you <a id="_idIndexMarker004"/>add transitions to an element, this is when the transitions are initialized and start playing.</p>
<p>The following snippet is an example of adding a transition to an element. You can add a transition to an element using the <code>transition:</code>, <code>in:</code>, and <code>out:</code> directives. We will explore more about Svelte transitions in <a href="B18887_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a> to <em class="italic">15</em>:</p>
<pre class="source-code">
&lt;div in:fade /&gt;</pre> <p>After all the directives, <code>use:</code> (actions), <code>on:</code> (event listeners), <code>bind:</code> bindings, <code>in:</code>, <code>transition:</code> (transitions), are processed, the mounting phase comes to an end by calling all the functions registered in the <code>onMount</code> lifecycle functions.</p>
<p>This is when the function on line 4 is executed, and you will see <code>"onMount!"</code> printed in the logs.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Updating the component</h2>
<p>When you<a id="_idIndexMarker005"/> click on the button, the <code>click</code> event listener is called. The function on line 9 is executed. The <code>count</code> variable is incremented.</p>
<p>Right before Svelte modifies the DOM based on the latest value of the <code>count</code> variable, the functions registered in the <code>beforeUpdate</code> lifecycle function are called.</p>
<p>The function on line 5 is executed, and you will see the text <code>"beforeUpdate!"</code> printed in the logs.</p>
<p>At this point, if you attempt to retrieve the text content within the button, it would still be <code>"</code><code>Counter: 0"</code>.</p>
<p>Svelte then proceeds to modify the DOM, updating the text content of the button to <code>"</code><code>Counter: 1"</code>.</p>
<p>After updating all the elements within the component, Svelte calls all the functions registered in the <code>afterUpdate</code> lifecycle function.</p>
<p>The function on line 6 is executed, and you will see the text <code>"afterUpdate!"</code> printed in the logs.</p>
<p>If you click on the button <a id="_idIndexMarker006"/>again, Svelte will go through another cycle of <code>beforeUpdate</code>, and then update the DOM elements, and then <code>afterUpdate</code>.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Destroying the component</h2>
<p>A component that is <a id="_idIndexMarker007"/>conditionally shown to a user will remain while the condition holds; when the condition no longer holds, Svelte will proceed to destroy the component.</p>
<p>Let’s say the component in our example now enters the destroy stage.</p>
<p>Svelte calls all the functions registered in the <code>onDestroy</code> lifecycle function. The function on line 7 is executed, and you will see the text <code>"onDestroy!"</code> printed in the logs.</p>
<p>After that, Svelte removes the elements from the DOM.</p>
<p>Svelte then cleans up the directives if necessary, such as removing the event listeners and calling the destroy method from the action.</p>
<p>And that’s it! If you try to recreate the component again, a new cycle starts again.</p>
<p>The Svelte component lifecycle starts with initializing, mounting, updating, and destroying. Svelte provides lifecycle methods, allowing you to run functions at different stages of the component.</p>
<p>Since the component lifecycle functions are just functions exported from <code>'svelte'</code>, can you import and use them anywhere? Are there any rules or constraints when importing and using them?</p>
<p>Let’s find out.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>The one rule for calling lifecycle functions</h1>
<p>The only rule for calling<a id="_idIndexMarker008"/> component lifecycle functions is that you should call them during component initialization. If no component is being initialized, Svelte will complain by throwing an error.</p>
<p>Let’s look at the following example:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  function buttonClicked() {
    onMount(() =&gt; console.log('onMount!'));
  }
&lt;/script&gt;
&lt;button on:click={buttonClicked} /&gt;</pre> <p>When you click on the button, it will call <code>buttonClicked</code>, which will call <code>onMount</code>. As no component is being initialized when <code>onMount</code> is being called, (the component above has initialized and mounted by the time you click on the button), Svelte throws an error:</p>
<pre class="source-code">
Error: Function called outside component initialization</pre> <p>Yes, Svelte does not allow lifecycle functions to be called outside of the component initialization phase. This rule dictates when you can call the lifecycle functions. What it does not dictate is where or how you call the lifecycle functions. This allows us to refactor lifecycle functions and call them in other ways.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Refactoring lifecycle functions</h2>
<p>If you look<a id="_idIndexMarker009"/> carefully at the rule for calling lifecycle functions, you will notice that it is about when you call them, and not where you call them.</p>
<p>It is not necessary to call lifecycle functions at the top level within the <code>&lt;</code><code>script&gt;</code> tag.</p>
<p>In the following example, the <code>setup</code> function is called during component initialization, and in turn calls the <code>onMount</code> function:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  setup();
  function setup() {
    onMount(() =&gt; console.log('onMount!'));
  }
&lt;/script&gt;</pre> <p>Since the component is still initializing, this is perfectly fine.</p>
<p>It is also not necessary to import the <code>onMount</code> function within the component. As you see in the following <a id="_idIndexMarker010"/>example, you can import it in another file; as long as the <code>onMount</code> function is called during component initialization, it is perfectly fine:</p>
<pre class="source-code">
// file-a.js
import { onMount } from 'svelte';
export function setup() {
  onMount(() =&gt; console.log('onMount!'));
}</pre> <p>In the preceding code snippet, we’ve moved the <code>setup</code> function we defined previously to a new module called <code>file-a.js</code>. Then, in the original Svelte component, rather than defining the <code>setup</code> function, we import it from <code>file-a.js</code>, shown in the following code snippet:</p>
<pre class="source-code">
&lt;script&gt;
  import { setup } from './file-a.js';
  setup();
&lt;/script&gt;</pre> <p>Since the <code>setup</code> function calls the <code>onMount</code> function, the same rule applies to the <code>setup</code> function<a id="_idIndexMarker011"/> too! You can no longer call the <code>setup</code> function outside component initialization.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Which component to register?</h2>
<p>Looking at just the <code>setup</code> function, you may be wondering, when you call the <code>onMount</code> function, how <a id="_idIndexMarker012"/>does Svelte know which component’s lifecycle you are referring to?</p>
<p>Internally, Svelte keeps track of which component is initializing. When you call the lifecycle functions, it will register your function to the lifecycle of the component that is being initialized.</p>
<p>So, the same <code>setup</code> function can be called within different components and registers the <code>onMount</code> function for different components.</p>
<p>This unlocks the first pattern in this chapter: reusing lifecycle functions.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Reusing lifecycle functions in Svelte components</h1>
<p>In the previous section, we<a id="_idIndexMarker013"/> learned that we can extract the calling of lifecycle functions into a function and reuse the function in other<a id="_idIndexMarker014"/> components.</p>
<p>Let’s look at an example. In this example, after the component is added to the screen for 5 seconds, it will call the <code>showPopup</code> function. I want to reuse this logic of calling <code>showPopup</code> in other components:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  import { showPopup } from './popup';
  onMount(() =&gt; {
    const timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
&lt;/script&gt;</pre> <p>Here, I can extract<a id="_idIndexMarker015"/> the logic into a function, <code>showPopupOnMount</code>:</p>
<pre class="source-code">
// popup-on-mount.js
import { onMount } from 'svelte';
import { showPopup } from './popup';
export function showPopupOnMount() {
  onMount(() =&gt; {
    const timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
}</pre> <p>And now, I can import<a id="_idIndexMarker016"/> this function and reuse it in any component:</p>
<pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  showPopupOnMount();
&lt;/script&gt;</pre> <p>You may be wondering, why not only extract the callback function and reuse that instead?</p>
<pre class="source-code">
// popup-on-mount.js
import { showPopup } from './popup';
export function showPopupOnMount() {
  const timeoutId = setTimeout(() =&gt; {
    showPopup();
  }, 5000);
  return () =&gt; clearTimeout(timeoutId);
}</pre> <p>Over here, we extract <a id="_idIndexMarker017"/>only <code>setTimeout</code> and <code>clearTimeout</code> logic<a id="_idIndexMarker018"/> into <code>showPopupOnMount</code>, and pass the function into <code>onMount</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  import { showPopupOnMount } from './popup-on-mount';
  onMount(showPopupOnMount);
&lt;/script&gt;</pre> <p>In my opinion, the second approach of refactoring and reusing is not as good as the first approach. There are a few pros in extracting the entire calling of the lifecycle functions into a function, as it allows you to do much more than you can otherwise:</p>
<ul>
<li><em class="italic">You can pass in different input parameters to your </em><em class="italic">lifecycle functions.</em><p class="list-inset">Let’s say you wish to allow different components to customize the duration before showing the popup. It is much easier to pass that in this way:</p><pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  <strong class="bold">showPopupOnMount(2000);</strong> // change it to 2s
&lt;/script&gt;</pre></li> <li><em class="italic">You can return values from </em><em class="italic">the function.</em><p class="list-inset">Let’s say you want to return the <code>timeoutId</code> used in the <code>onMount</code> function so that you can cancel it if the user clicks on any button within the component.</p><p class="list-inset">It is near impossible <a id="_idIndexMarker019"/>to do so if you just reuse the <a id="_idIndexMarker020"/>callback function, as the value returned from the callback function will be used to register for the <code>onDestroy</code> lifecycle function:</p><pre class="source-code">
&lt;script&gt;
  import { showPopupOnMount } from './popup-on-mount';
  <strong class="bold">const timeoutId = showPopupOnMount(2000);</strong>
&lt;/script&gt;
&lt;button on:click={() =&gt; clearTimeout(timeoutId)} /&gt;</pre><p class="list-inset">See how easy it is to implement it to return anything if we write it this way:</p><pre class="source-code">// popup-on-mount.js
export function showPopupOnMount(duration) {
  let timeoutId;
  onMount(() =&gt; {
    timeoutId = setTimeout(() =&gt; {
      showPopup();
    }, duration ?? 5000);
    return () =&gt; clearTimeout(timeoutId);
  });
  <strong class="bold">return timeoutId;</strong>
}</pre></li> <li><em class="italic">You can encapsulate more logic along with the </em><em class="italic">lifecycle functions.</em><p class="list-inset">Sometimes, the code in your lifecycle functions callback function does not work in a silo; it interacts <a id="_idIndexMarker021"/>with and modifies other variables. To reuse lifecycle functions like this, you must encapsulate those variables and logic into a reusable function.</p><p class="list-inset">To illustrate this, let’s look at<a id="_idIndexMarker022"/> a new example.</p><p class="list-inset">Here, I have a counter that starts counting when a component is added to the screen:</p><pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let counter = 0;
  onMount(() =&gt; {
    const intervalId = setInterval(() =&gt; counter++, 1000);
    return () =&gt; clearInterval(intervalId);
  });
&lt;/script&gt;
&lt;span&gt;{counter}&lt;/span&gt;</pre><p class="list-inset">The <code>counter</code> variable is coupled with the <code>onMount</code> lifecycle functions; to reuse this logic, the <code>counter</code> variable and the <code>onMount</code> function should be extracted together into a reusable function:</p><pre class="source-code">import { writable } from 'svelte/store';
import { onMount } from 'svelte';
export function startCounterOnMount() {
  const counter = writable(0);
  onMount(() =&gt; {
    const intervalId = setInterval(() =&gt; counter.update($counter =&gt; $counter + 1), 1000);
    return () =&gt; clearInterval(intervalId);
  });
  return counter;
}</pre><p class="list-inset">In this example, we use a <code>writable</code> Svelte store to make the <code>counter</code> variable reactive. We <a id="_idIndexMarker023"/>will delve more into Svelte stores in <em class="italic">Part 3</em> of this book.</p><p class="list-inset">For now, all <a id="_idIndexMarker024"/>you need to understand is that a Svelte store allows Svelte to track changes in a variable across modules, and you can subscribe to and retrieve the value of the store by prefixing a <code>$</code> in front of a Svelte store variable. For example, if you have a Svelte store named <code>counter</code>, then to get the value of the Svelte store, you would need to use the <code>$</code><code>counter</code> variable.</p><p class="list-inset">Now, we can use the <code>startCounterOnMount</code> function in any Svelte component:</p><pre class="source-code">&lt;script&gt;
  import { startCounterOnMount } from './counter';
  const counter = startCounterOnMount();
&lt;/script&gt;
&lt;span&gt;{$counter}&lt;/span&gt;</pre></li> </ul>
<p>I hope I’ve convinced you about the pros of extracting the calling of lifecycle functions into a function. Let’s try it out in an example.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Exercise 1 – Update counter</h2>
<p>In the following<a id="_idIndexMarker025"/> example code, I want to know how many times the component has gone through the update cycle.</p>
<p>Using the fact that every time the component goes through the update cycle, the <code>afterUpdate</code> callback function will be called, I created a counter that will be incremented every time the <code>afterUpdate</code> callback function is called.</p>
<p>To help us measure only the update count of a certain user operation, we have functions to start <a id="_idIndexMarker026"/>measuring and stop measuring, so the update counter is only incremented when we are measuring:</p>
<pre class="source-code">
&lt;script&gt;
  import { afterUpdate } from 'svelte';
  let updateCount = 0;
  let measuring = false;
  afterUpdate(() =&gt; {
    if (measuring) {
      updateCount ++;
    }
  });
  function startMeasuring() {
    updateCount = 0;
    measuring = true;
  }
  function stopMeasuring() {
    measuring = false;
  }
&lt;/script&gt;
&lt;button on:click={startMeasuring}&gt;Measure&lt;/button&gt;
&lt;button on:click={stopMeasuring}&gt;Stop&lt;/button&gt;
&lt;span&gt;Updated {updateCount} times&lt;/span&gt;</pre> <p>To reuse all the logic of the <code>counter:</code> – the counting of update cycles and the starting and stopping of the <a id="_idIndexMarker027"/>measurement – we should move all of it into a function, which ends up looking like this:</p>
<pre class="source-code">
&lt;script&gt;
  import { createUpdateCounter } from './update-counter';
  const { updateCount, startMeasuring, stopMeasuring } = createUpdateCounter();
&lt;/script&gt;
&lt;button on:click={startMeasuring}&gt;Measure&lt;/button&gt;
&lt;button on:click={stopMeasuring}&gt;Stop&lt;/button&gt;
&lt;span&gt;Updated {$updateCount} times&lt;/span&gt;</pre> <p>The update counter returns an object that contains the <code>updateCount</code> variable and the <code>startMeasuring</code> and <code>stopMeasuring</code> functions.</p>
<p>The implementation of the <code>createUpdateCounter</code> function is left as an exercise to you, and you can check the answer at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter</a>.</p>
<p>We’ve learned how to extract a lifecycle function and reuse it, so let’s take it up a notch and reuse multiple lifecycle functions in the next pattern: composing lifecycle functions.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Composing lifecycle functions into reusable hooks</h1>
<p>So far, we’ve mainly <a id="_idIndexMarker028"/>talked about reusing one lifecycle function. However, there’s nothing stopping us from grouping multiple lifecycle functions to perform a function.</p>
<p>Here’s an excerpt from the example at <a href="https://svelte.dev/examples/update">https://svelte.dev/examples/update</a>. The example shows a list of messages. When new messages are added to the list, the container will automatically scroll to the bottom to show the new message. In the code snippet, we see that this automatic scrolling behavior is achieved by using a combination of <code>beforeUpdate</code> and <code>afterUpdate</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { beforeUpdate, afterUpdate } from 'svelte';
  let div;
  let autoscroll;
  beforeUpdate(() =&gt; {
    autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
  });
  afterUpdate(() =&gt; {
    if (autoscroll) div.scrollTo(0, div.scrollHeight);
  });
&lt;/script&gt;
&lt;div bind:this={div} /&gt;</pre> <p>To reuse this <code>autoscroll</code> logic in other components, we can extract the <code>beforeUpdate</code> and <code>afterUpdate</code> logic together into a new function:</p>
<pre class="source-code">
export function setupAutoscroll() {
  let div;
  let autoscroll;
  beforeUpdate(() =&gt; {
    autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
  });
  afterUpdate(() =&gt; {
    if (autoscroll) div.scrollTo(0, div.scrollHeight);
  });
  return {
  setDiv(_div) {
  div = _div;
    },
  };
}</pre> <p>We can then use<a id="_idIndexMarker029"/> the extracted function, <code>setupAutoScroll</code>, in any component:</p>
<pre class="source-code">
&lt;script&gt;
  import { setupAutoscroll } from './autoscroll';
  const { setDiv } = setupAutoscroll();
  let div;
  $: setDiv(div);
&lt;/script&gt;
&lt;div bind:this={div} /&gt;</pre> <p>In the refactored <code>setupAutoscroll</code> function, we return a <code>setDiv</code> function to allow us to update the reference of the <code>div</code> used within the <code>setupAutoscroll</code> function.</p>
<p>As you’ve seen, by adhering to the one rule of calling lifecycle functions during component initialization, you can compose multiple lifecycle functions into reusable hooks. What you’ve learned so far is sufficient for composing lifecycle functions, but there are more alternatives on the horizon. In the upcoming chapters, you’ll explore Svelte actions in <a href="B18887_05.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a> and the Svelte store in <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, expanding your options further. Here’s a sneak peek at some of these alternatives.</p>
<p>An alternative<a id="_idIndexMarker030"/> implementation could be to make <code>div</code> a writable store and return it from the <code>setupAutoscroll</code> function. This way, we could bind to the <code>div</code> writable store directly instead of having to call <code>setDiv</code> manually.</p>
<p>Alternatively, we could return a function that follows the Svelte action contract and use the action on the <code>div</code>:</p>
<pre class="source-code">
export function setupAutoscroll() {
  let div;
  // ...
  return function (node) {
    div = node;
    return {
      destroy() {
        div = undefined;
      },
    };
  };
}</pre> <p><code>setupAutoscroll</code> now returns an action, and we use the action on our <code>div</code> container:</p>
<pre class="source-code">
&lt;script&gt;
  import { setupAutoscroll } from './autoscroll';
  const autoscroll = setupAutoscroll();
&lt;/script&gt;
&lt;div use:autoscroll /&gt;</pre> <p>We will discuss the Svelte action contract in more detail later in the book.</p>
<p>We’ve seen how <a id="_idIndexMarker031"/>we can extract lifecycle functions into a separate file and reuse it in multiple Svelte components. Currently, the components call the lifecycle functions independently and function as standalone units. Is it possible to synchronize or coordinate actions across components that uses the same lifecycle functions? Let’s find out.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Coordinating lifecycle functions across components</h1>
<p>As we reuse the same<a id="_idIndexMarker032"/> function across components, we can keep track globally of the components that use the same lifecycle function.</p>
<p>Let me show you an example. Here, I would like to keep track of how many components on the screen are using our lifecycle function.</p>
<p>To count the number of components, we can define a module-level variable and update it within our lifecycle function:</p>
<pre class="source-code">
import { onMount, onDestroy } from 'svelte';
import { writable } from 'svelte/store';
let counter = writable(0);
export function setupGlobalCounter() {
  onMount(() =&gt; counter.update($counter =&gt; $counter + 1));
  onDestroy(() =&gt; counter.update($counter =&gt; $counter - 1));
  return counter;
}</pre> <p>As the <code>counter</code> variable is declared outside the <code>setupGlobalCounter</code> function, the same <code>counter</code> variable instance is used and shared across all the components.</p>
<p>When any component is mounted, it will increment the <code>counter</code>, and any component that is referring to the <code>counter</code> will get updated with the latest counter value.</p>
<p>This pattern is extremely<a id="_idIndexMarker033"/> useful when you want to set up a shared communication channel between components and tear it down in <code>onDestroy</code> when the component is being destroyed.</p>
<p>Let’s try to use this technique in our next exercise.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Exercise 2 – Scroll blocker</h2>
<p>Usually, when you<a id="_idIndexMarker034"/> add a pop-up component onto the screen, you want the document to not be scrollable so that the user focuses on the popup and only scrolls within the popup.</p>
<p>This can be done by setting the <code>overflow</code> CSS property of the body to <code>"hidden"</code>.</p>
<p>Write a reusable function used by pop-up components that disables scrolling when the pop-up component is mounted. Restore the initial <code>overflow</code> property value when the pop-up component is destroyed.</p>
<p>Do note that it is possible to have more than one pop-up component mounted on the screen at once, so you should only restore the <code>overflow</code> property value when all the popups are destroyed.</p>
<p>You can check the answer at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker</a>.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
<p>In this chapter, we went through the lifecycles of a Svelte component. We saw the different stages of a component lifecycle and learned when the lifecycle function callbacks will be called.</p>
<p>We also covered the rule of calling lifecycle functions. This helps us to realize the different patterns of reusing and composing lifecycle functions.</p>
<p>In the next chapter, we will start to look at the different patterns for styling and theming a Svelte component.</p>
</div>
</div></body></html>