- en: Chapter 6. Building and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perfect code is a unicorn; what good developers do is introduce the smallest
    amount of bad code. Any code is, therefore, somewhat flawed, so errors and inefficiency
    are an inescapable pathology in software development. Accordingly, **technical
    debt** naturally compounds as more code is written. Some of the more expensive
    technical realities of modern application development are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: There are rigidly coupled components that do not easily allow change at either
    the technical level or the business level. Allowing such unprincipled interpenetration
    leads to complex capillary networks growing throughout the body of your code.
    The edges of these networks are nearly impossible to trace, concretizing entanglements
    that obscure how a change in one function might affect other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor gatekeeping allows untested code to enter production, often leading to
    quick fixes, which, in turn, can lead to intractable patches and bridge code as
    well as relentless bugs that regularly resurface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are code units built in isolation in parallel without objective *big picture*
    guidelines that are merged into a single codebase sloppily and joined together
    by undocumented, ad hoc bindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for refactoring reaches a critical point, and further development,
    in any sense, becomes nearly impossible. Scaling ceilings typify this situation,
    and wholesale rewrites are inevitable and nearly always doomed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debt accumulates interest. Software, like many long-term pursuits, requires
    constant debt management. It is in your interest to reduce debt. In the previous
    chapter, we learned how to profile *deployed* applications at a level of detail
    sufficient to expose errors, weaknesses, and other unwanted characteristics. In
    this chapter, we will explore strategies that help software developers and teams
    catch errors before the membranes of their applications are breached. We will
    also explore workflows to manage the integration of independently written programs.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Gulp, Browserify, and Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript you are working on will likely be transformed and augmented before
    it makes it to production. At the very least, it will be checked for errors, minified,
    packaged, and so on. It will be deployed only after that. Deployment, therefore,
    follows a build step and how each step in the build is instrumented must be clearly
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, certain patterns of development have emerged within the Node community.
    Many of these patterns map to other environments, while others are unique to the
    *full-stack JavaScript* Node.js world. The ability to run identical code on the
    client and server is perhaps the most prominent example. Because deployed codebases
    often contain the end result of transpilation (for example, CoffeeScript, and
    SASS), deployment workflows are assembled to run preprocessors, concatenate files,
    create source maps, compress images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at three technologies that are regularly seen
    in the Node build/deploy process. We'll use **Gulp** to create a build system,
    using **Browserify** to bundle application code and **Handlebars** as a templating
    language for compiling static pages. Finally, we'll look at how to improve our
    development experience by using **BrowserSync**
  prefs: []
  type: TYPE_NORMAL
- en: Using Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new folder and initialize a `package.json` file in that folder with
    `npm init`. When this is done, you''ll end up with a `package.json` file that
    looks somewhat like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This basic scaffold will be fleshed out and explained as we proceed. The point
    is simply that you will now hang the modules and other dependencies of your application
    on this scaffold, using npm, neatly describing dependencies, test harnesses, and
    more. Since we''ll use the Gulp build system, it is reasonable to install the
    Gulp module first and to assert that it is a dependency of this package. Run these
    two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command installs Gulp globally, meaning that you can now use the
    `gulp` command directly from the command line (you can also abbreviate `--global`
    with `-g`). The next command installs Gulp locally, adding the following new property
    to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Gulp has been installed and saved as a dependency. We are prepared to construct
    a build system.
  prefs: []
  type: TYPE_NORMAL
- en: One goal of a build system is the instrumentation of your development environment
    such that you can work naturally with uncompressed, unminified code while developing
    and, later, issue commands to convert your *raw* code and assets into an optimized
    state suitable for staging environments, production environments, and so on. Providing
    developers with an expressive and simple syntax for describing how to convert
    source code into deployable code is what Gulp aims to provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new folders in your working directory: a `/source` folder and a
    `/build` folder. We''re going to create a set of instructions for transforming
    the files in `source/` into files in `/build`. This set of instructions is stored
    in a file that is specifically called `gulpfile.js`. Create that file and insert
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Gulp works on the idea of running a number of tasks in a certain order. The
    general format is `gulp.task(<task name>, <task runner>)`. A Gulpfile is typically
    extended with several such task definitions. As we''ll see, tasks can be named
    anything you''d like, but there must always be a default task named *default*,
    and the preceding code establishes such a task to do one simple thing: ensure
    that a `/build` folder exists, and, if not, to create one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice is the first argument a task runner function receives:
    a callback function, here named `cb`. Because Node programs customarily run asynchronous
    code, it is important to have a mechanism to *tell* `gulp` that a task is finished.
    We''re running asynchronous code to check for the existence of a folder, so we
    use this callback system, but note that, if your code either runs synchronously
    or if the moment of task completion is irrelevant to subsequent tasks, you can
    skip running a callback, and Gulp will simply continue with the next task as soon
    as the task runner exits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the `gulp` command in the folder containing your Gulpfile.
    You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To check that the task is doing its job correctly, delete the `/build` folder
    and run `gulp` again. You'll see that the folder is recreated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that Gulp expects its Gulpfile to contain a *default* task, the `gulp`
    command is simply a shortcut for `gulp default`. You can execute a specific task
    by running `gulp <taskname>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typical build, many tasks will be run. Each task should be as simple and
    specific as possible, and the Gulpfile should neatly organize them so that they
    execute in a certain order. For this reason, the default task, typically, doesn''t
    do much on its own but is used as a way to hint at the list of tasks that will
    be run. Let''s rewrite the preceding code in a more directed way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see more clearly how `gulp` works. A second array argument is passed
    to the `gulp` task''s definition, listing other tasks on which the current task
    depends—a task will not run until all of its dependencies have completed. Let''s
    add another task to this execution chain that copies files in the `/source` folder
    to the `/build` folder. Add the following to your Gulpfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, tell `gulp` about this new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to `task`, you will use the `src`, `pipe`, and `dest` Gulp commands
    frequently. Gulp is a *streaming* build system—within a task, you will normally
    identify a collection of files, run a chain of transformations against them, and
    put the transformed files somewhere useful, typically the folder containing a
    deployable application. The `src` command is used to identify this collection
    and convert the contained files into streamable objects such that `pipe` can be
    used on them to gulp plugins. We will provide more information on this later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguments to Gulp's `src` command often contain *globs* (for example, `/source/**`),
    flavors of pattern matching that are useful when we target files within folders.
    More on how they work can be found at [https://github.com/isaacs/node-glob#glob-primer](https://github.com/isaacs/node-glob#glob-primer).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code creates a collection of files in the `/source` directory
    and pipes them to the (built-in) `dest` gulp plugin, which writes them to `/build`.
    Run gulp again. You will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Did you see anything problematic? The `move` task ran prior to the completion
    of `initialize`, which creates a race condition—will the `/build` directory be
    created before `move` tries to add files to it? A build should be as fast as possible,
    and, to that end, Gulp aims for maximum concurrency—unless you specify otherwise,
    Gulp will run all of its tasks concurrently. As illustrated in the preceding code,
    `initialize` and `move` start simultaneously. How can a specific ordering be enforced?
  prefs: []
  type: TYPE_NORMAL
- en: 'The ordering of the dependency list passed to `default` does *not* reflect
    their execution order. However, it does represent a list of tasks that must complete
    prior to the execution of `default`. To ensure that `move` follows `initialize`,
    simply make `initialize` a dependency of `move`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Erecting a build scaffold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have an idea of how Gulp works, let''s build a representative
    build process. We''ll develop a Gulpfile step by step. To start with, use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the head of this file, you''ll see a lot of require statements. Excepting
    `path`, they will all be used as either Gulp plugins or helpers. You can just
    copy the `package.json` file found in the `/building` folder of you code bundle
    for this chapter, or go ahead and install them using the `--save-dev` directive:
    `npm install --save-dev gulp-coffee gulp-changed [...]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, install the `jquery` and `handlebars` npm modules as dependencies using
    `npm install --save jquery handlebars`. We will provide more information on why
    we do this when we discuss Browserify.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clean` and `scaffold` tasks exist to build a folder structure for your
    app and to clean the relevant build directories whenever a new build happens (making
    room for newly built files without leaving the residue of old ones). Take a look
    at those tasks; they ultimately ensure the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following demonstration, we'll write our JavaScript in **CoffeeScript**,
    storing `.coffee` files in the `source/scripts` directory, which will be compiled
    and moved to the `build/js` directory. The `build/css` directory will receive
    transformed `.scss` files contained in `source/styles`. Handlebars templates will
    be precompiled and moved from `source/templates` to `build/templates`. Finally,
    the `.html` files forming the main "pages" of our application will be located
    in `/source` and moved to the root `/build` folder. Later on, we will add tasks
    to expose these HTML views via a web server.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the snippet, you will see the list of tasks that we'll define
    bound as dependencies of the default Gulp task. Let's go over those one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linting files involves running a syntax checker on your scripts, enforcing
    various rules, such as indentation, whether or not certain constructs are allowed,
    whether to force the use of the semicolon, and so on. We''ll use CoffeeScript
    exclusively, so we implement a lint task using the `gulp-coffeelint` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We're simply checking the syntax of the CoffeeScript files that will be transpiled
    into JavaScript files residing in the `/js` build folder. Any discrepancies will
    be reported to `stdout` but will not stop the build. A `coffeelint.json` file
    containing syntax rules is applied. You should investigate this file and modify
    it to fit your needs—more information can be found at [http://www.coffeelint.org](http://www.coffeelint.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to build these newly linted scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several build steps happening here. We could simply transform CoffeeScript
    files to JavaScript files and copy them to the `build/scripts` folder. However,
    as the transpiled JavaScript file is not the original source file, we need to
    create a **sourcemap**—an essential tool that will map errors in JavaScript to
    *the original CoffeeScript source* that generated the said JavaScript. This is
    invaluable when we are debugging in a browser. As you saw in the code, we simply
    use the `gulp-sourcemaps` plugin to track the compilation step, and it automatically
    appends a sourcemap to the generated JavaScript file, which looks somewhat like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `gulp-changed` plugin intelligently tracks whether any targeted files have
    changed, and, if they have not, the plugin removes them from processing. This
    plugin can drastically reduce the execution time of any task processing a large
    numbers of files. Note that we set the extension argument to `.js` as an option
    as the original file extension (`.coffeescript`) will be changed and the plugin
    must be told about this naming change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create styles in our system using the **Sass** CSS preprocessor ([http://sass-lang.com/](http://sass-lang.com/))
    denoted by their `.scss` extension. In the following task definition, they are
    converted to standard CSS. In addition, they are bundled up into a single output
    file (`app.css`) using the `gulp-concat` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Bundled into a single file at the build step, global styles can be added to
    any view with a single `<link>` tag, while maintaining the necessary separation
    of style documents during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is slightly more complicated. We are going to use Handlebars
    templates, which (might) look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For Handlebars to feed the preceding iterator some JSON to process, the template
    must be compiled into a JavaScript function via the `Handlebars.template` method.
    While this could be done on the client side, it is much more efficient to simply
    precompile our templates at the build step. So, what we''re going to do is export
    each template as an individual Node module such that they can be used as one normally
    uses modules. To accomplish this, we''ll use the `gulp-wrap` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This task wraps each source file in code that will use the Handlebars runtime
    to compile the source code into an exportable JavaScript function. Now, the template
    can be used in your client code without the overhead of loading Handlebars at
    runtime or using it for compilation. For example, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be saying to yourself, "But wait...client-side JavaScript doesn''t
    have a `require` statement!"...and you''d be right! Enter the power of Browserify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned at [http://browserify.org/](http://browserify.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"With Browserify, you can write code that uses require in the same way that
    you would use it in Node."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This allows us to write our client application code as if it was running within
    Node, with a DOM document thrown in. In the preceding task, Browserify automatically
    fetches all `app.js` dependencies (instances of `require`), bundles them up into
    a file that will run on the client, runs the `gulp-uglify` plugin to minify the
    resulting JavaScript, and replaces the old file with the Browserified bundle.
    The `app.js` file can contain all of the code we need, in one file, thus simplifying
    and standardizing client integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browserify isn''t just about concatenation, however. The point is that, with
    Browserify, we can use npm modules on both the client and the server, *normalizing*
    our process, and, therefore, leveraging intelligent package management for client-side
    JavaScript. This is new and important: we have gained the power of package management
    and its standardized loading system on the client side. While some client frameworks
    provide something resembling module management systems, none of these *hacks*
    can replace the solid npm system. Consider this example `source/scripts/app.coffee`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you check your code bundle, you will find this file. Notice how we `require`
    the npm module version of jQuery, as well as the precompiled templates we created
    previously from Handlebars templates. Yet, we are running in the client, so we
    can use jQuery operations to add HTML to the DOM—the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task for `views` is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We're just compressing HTML and moving the file, with no further changes, to
    the build directory.
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing your build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have all the tasks set up to manage the key files for our
    repository. Let''s use `browser-sync` to automatically spawn a server and a browser
    window that will load the `index.html` file from our build directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` and `watch` tasks will be explained next. For now, notice how easy
    it is to add a server to your build process. This task starts a server on the
    provided port and automatically loads `index.html` found in `baseDir` onto an
    automatically spawned browser window. The `notify` option tell BrowserSync not
    to display debugging notifications in connected browsers. Now, every time we run
    Gulp, our app will load up in a browser. Your terminal should display information
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing your build](img/1403OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: BrowserSync allows multiple clients to view your build, so an external access
    URL is provided. Additionally, they will see your interactions. For example, if
    you scroll the page, the pages of connected clients will also scroll. Additionally,
    the UI URL will expose a sort of dashboard for your build, allowing you to control
    connected clients, reload their views, and so on. This is a great tool when you
    are doing demonstrations for your team or for a client. To learn more about BrowserSync
    and its configuration, visit [http://www.browsersync.io/](http://www.browsersync.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A good build system should provide a testing harness as the final arbiter of
    whether the build should be certified. We''ll do a deep dive into testing with
    **Mocha**, **Chai**, and **Sinon** later in this chapter, so here we''ll just
    demonstrate a very simple testing stub that you can build on when designing your
    Gulp workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a test file written in CoffeeScript within the tests directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will load one of our template modules, which exports an array with
    seven members—the days of the week. The test uses Node''s core `assert` library
    (discussed in detail later in this chapter) to test whether this array has the
    correct length of seven characters. Mocha provides the testing harness, via `describe`
    and `it`, allowing you to design tests that read like a natural language. When
    you run through Gulp, you should see something like this (if everything goes right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and testing your build](img/1403OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final task is provided by another native Gulp method: `watch`. The purpose
    of `watch` is to bind file watchers to certain directories such that any file
    change will automatically trigger a rerun of the relevant build tasks. For example,
    you might want to run the `scripts` task again if any file in `source/scripts`
    changes. The following code demonstrates how (changes in) certain folders automatically
    trigger a number of build tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that BrowserSync is bound to changes as well, thus creating
    a very natural development process. Once you have a running build displayed in
    a browser, any change you make to, for example, `index.html`, will be *automatically*
    reflected in that view. As you change the CSS, you will see the change immediately,
    and so on. There will be no more constant reloading when you are developing; BrowserSync
    pushes changes for you.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other things you might need to do. For example, you might want
    to compress images before pushing them to production. As a practice, create the
    relevant image folders in your source and build directory and implement an `images`
    task using `gulp-imagemin` ([https://github.com/sindresorhus/gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The people behind Gulp provide a good collection of suggested patterns to implement
    common build tasks at [https://github.com/gulpjs/gulp/tree/master/docs/recipes](https://github.com/gulpjs/gulp/tree/master/docs/recipes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a final note: you will regularly *hand-code* these sorts of build systems,
    typically reusing the same patterns. For this reason, certain automated tools
    have been created that can often reduce the creation of boilerplate build code
    to a few commands. A popular one is **Yeoman** ([http://yeoman.io/](http://yeoman.io/)),
    which makes it easy to construct common "stacks" of build steps, databases, servers,
    and frameworks. Other notable solutions are **Brunch** ([http://brunch.io/](http://brunch.io/))
    and **Mimosa** ([http://mimosa.io/](http://mimosa.io/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Node's native testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is simply the act of checking whether your assumptions about the state
    of something are false. In this way, testing software follows the scientific method
    in that you will express a theory, make a prediction, and run an experiment to
    see whether the data matches your prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike scientists, software developers can change reality—Einstein's joke about
    changing the facts if they don't fit the theory actually applies, without irony,
    to the testing process. In fact, it is required! When your tests (theories) fail,
    you must change "the world" until the tests do not fail.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to use Node's native debugger for *live*
    code testing and how to use the `assert` module to make predictions, run experiments,
    and test results.
  prefs: []
  type: TYPE_NORMAL
- en: The Node debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most developers have used an IDE for development. A key feature of all good
    development environments is access to a debugger, which allows breakpoints to
    be set in a program in places where the state or other aspects of the runtime
    need to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'V8 is distributed with a powerful debugger (commonly seen powering the Google
    Chrome browser''s developer tools panel), and this is accessible to Node. It is
    invoked using the `debug` directive, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple stepthrough and inspection debugging can now be achieved within a Node
    program. Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `debugger` directive. Executing this program *without* using the `debug`
    directive will result in `"hello"` being displayed, followed by `"world"` one
    second later. When using the directive, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a breakpoint is hit, we are presented with a CLI to the debugger itself,
    from within which we can execute standard debugging and other commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cont, c`: This continues execution from the last breakpoint until the next
    breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step, s`: Step in—this keeps running until a new source line (or breakpoint)
    is hit; after that, return control to the debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next, n`: This is like the preceding command, but function calls made on the
    new source line are executed without stopping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`out, o`: Step out—this executes the remainder of the current function and
    back out to the parent function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backtrace, bt`: This traces the steps to the current execution frame in a
    manner similar to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setBreakpoint(), sb()`: This sets a breakpoint on the current line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setBreakpoint(Integer), sb(Integer)`: This sets a breakpoint on the specified
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearBreakpoint(), cb()`: This clears a breakpoint on the current line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearBreakpoint(Integer), cb(Integer)`: This clears a breakpoint on the specified
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: If the debugger''s script has terminated, this will start it again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: This terminates and restarts the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause, p`: This pauses the running code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: This kills the running script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit`: This exits the debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This displays the V8 version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: This lists all loaded scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To repeat the last debugger command, simply hit *Enter* on your keyboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returning to the script we are debugging, entering `cont` in the debugger results
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `"hello"` was not printed when we started the debugger even though
    you would expect the `console.log('hello')` command to execute prior to the breakpoint
    being reached in the `setTimeout` callback. The debugger does not execute at runtime;
    it is evaluating at compile time *as well as at run time*, giving you deep visibility
    into how the bytecode for your program is being assembled and, eventually, will
    be executed, not simply a postcompilation printout, which `console.log` gives.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is normally useful at a breakpoint to do some inspection, such as of the
    value of variables. There is an additional command available to the debugger,
    `repl`, which enables this. Currently, our debugger has stopped after having successfully
    parsed the script and executed `console.log(''hello'')`, the first function pushed
    into the event loop. What if we wanted to check the value of `myVar`? Use `repl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Play around with REPL here, experimenting with how it might be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our program has a single remaining instruction to execute—printing
    `"world"`. An immediate `cont` command will execute this last command, the event
    loop will have nothing further to do, and our script will terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As an experiment, `run` the script again, using `next` instead of `cont` just
    before the execution of this final context. Keep hitting *Enter* and try to follow
    the code that is being executed. You will see that, after `"world"` is printed,
    the `timers.js` script will be introduced into this execution context as Node
    cleans up after firing a timeout. Run the `scripts` command in the debugger at
    this point. You will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It will be useful to experiment with various methods, learning about what happens
    when Node executes scripts at a deep level as well as about Node helping with
    your debugging needs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be useful to read the following document, describing how the Google
    Chrome debugger interface is used: [https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints](https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints).'
  prefs: []
  type: TYPE_NORMAL
- en: Miroslav Bajtos's **node-inspector** module is strongly recommended for debugging,
    allowing a developer to remotely debug a Node application from the Chrome browser.
    You can find more information on this at [https://github.com/node-inspector/node-inspector](https://github.com/node-inspector/node-inspector).
  prefs: []
  type: TYPE_NORMAL
- en: The 'assert' module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node''s assert module is used for simple unit testing. In many cases, it suffices
    as a basic scaffolding for tests or is used as the assertion library for testing
    frameworks (such as Mocha, as we''ll see later). Its usage is straightforward;
    we want to assert the truth of something and throw an error if our assertion is
    not true. For example, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the assertion was `true` (both values are equal), nothing would be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Following the UNIX Rule of Silence, *when a program has nothing surprising,
    interesting, or useful to say, it should say nothing*, assertions only return
    a value when the assertion fails. The value returned can be customized by using
    an optional message argument, as seen in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` module API is composed of a set of comparison operations with identical
    call signatures—the actual value, the expected value, and an optional message
    to display when comparison fails. Alternate methods functioning as shortcuts or
    handlers for special cases are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'A distinction must be made between **identity comparison (===)** and **equality
    comparison (==)**; the former is often referred to as *strict equality comparison*
    (as is the case of the `assert` API). Because JavaScript employs dynamic typing,
    when two values of different types are compared using the equality operator ==,
    an attempt is made to coerce (or cast) one value into the other—a sort of *common
    denominator* operation. For example, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, these sorts of comparisons can lead to surprising results.
    Notice the more predictable results when identity comparison is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing to remember is that the === operator *does not perform type coercion*
    prior to the comparison, while the equality operator compares *after type coercion*.
    Additionally, because objects in JavaScript are passed by reference, the identity
    of two objects with the same values is distinct—for objects, identity requires
    that both operands *refer to the same object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the concept of *deep equality* is used for object comparisons where
    identity need not be exact. Two objects are deeply equal if they both posses the
    same number of owned properties, the same prototype, the same set of keys (though
    not necessarily in the same order), and equivalent (not identical) values for
    each of their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to test your assumptions about how values are understood in comparison
    to each other by designing assertion tests. The results may surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rounds out the assertions you can make using this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert.equal(actual, expected, [message])`: This is used to test coerced equality
    with ==.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notEqual(actual, expected, [message])`: This is used to test coerced
    equality with !=.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.deepEqual(actual, expected, [message])`: This is used to test for deep
    equality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notDeepEqual(actual, expected, [message])`: This is used to test for
    deep inequality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.strictEqual(actual, expected, [message])`: This is used to test identity
    equivalence ===.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notStrictEqual(actual, expected, [message])`: This is used to test
    for identity mismatch !==.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert(value, [message])`: This throws an error if the sent value is not truthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.ok(value, [message])`: This is identical to `assert(value)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.ifError(value)`: This throws an error if the value is truthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.throws(block, [error], [message])`: This is used to test whether or
    not the supplied code block throws. The optional error value can be an error constructor,
    regular expression, or a validation function returning a Boolean value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.doesNotThrow(block, [error], [message])`: This is used to test whether
    the supplied code block does not throw an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.fail(actual, expected, message, operator)`: This throws an exception.
    This is most useful when the exception is trapped by a try/catch block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A shortcut method to log assertion results is available in the `console` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed explanation of how comparison is done in JavaScript, consult
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at testing with more advanced testing frameworks and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Mocha, Chai, Sinon, and npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great benefits of writing tests for your code is that you will be
    forced to think through how what you've written works. A test that is difficult
    to write might indicate code that is difficult to understand. On the other hand,
    comprehensive coverage with good tests helps others (and you) understand how an
    application works.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least three notions to consider when setting up your test environment.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of testing is to make comparisons between the value of what is received
    and what is expected by your application code. As we saw earlier, Node's `assert`
    module is designed for this purpose, but its functionality is limited to individual,
    isolated assertions. We'll use the Chai library ([http://chaijs.com](http://chaijs.com)),
    which provides you with a richer choice of languages and idioms to make assertions
    with.
  prefs: []
  type: TYPE_NORMAL
- en: It is not unusual for an application to be covered by several hundred tests.
    When assertions are grouped, say by feature or business unit, these groups can
    provide a clearer picture of your application's state. Designing and instrumenting
    tools to do this grouping, especially with asynchronous code, is difficult. Thankfully,
    several well-known, well-designed test runners exist for you to use. We'll use
    Mocha ([http://mochajs.org](http://mochajs.org)), which makes it easier to organize,
    control, and display the results of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is normally done on development boxes and not in live production environments.
    How can you write tests for code that does not run in a real environment? For
    example, how do I test my code's ability to handle responses from a network endpoint
    that I cannot connect to locally? How do I check the arguments a function is being
    sent without rewriting the function? We'll use Sinon ([http://sinonjs.org/](http://sinonjs.org/)),
    which lets you create synthetic methods and other simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other popular test runners are Jasmine ([https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine))
    and Vows ([https://github.com/vowsjs/vows](https://github.com/vowsjs/vows)). Should
    ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    is a popular assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, set up a folder containing the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `/scripts` folder contains the JavaScript we'll test. The `/spec` folder
    contains configuration and test files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, initialize a `package.json` file with `npm init`. You can just hit *Enter*
    at the prompts, but when you are asked for a test command, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This will make more sense as we move forward. For now, recognize that this assignation
    to npm's `test` attribute asserts that we will use Mocha for testing. Mocha's
    test report will be of the `spec` type and that test will exist in the `/spec`
    directory. We will also require a configuration file for Chai, which will be explained
    in one of the following sections. Importantly, this has now created a script declaration
    in npm that will allow you to run your test suite with the `npm test` command.
    Use that command whenever you need to run the Mocha tests we'll be developing
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already, install Mocha globally with `npm install mocha -g`.
    Also, install the local modules that we'll need for testing using the `npm install
    mocha chai sinon redis --save-dev` command.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocha is a test runner that does not concern itself with test assertions themselves.
    Mocha is used to organize and run your tests, primarily through the use of the
    `describe` and `it`. operators. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated, the Mocha harness leaves open how the tests are described and
    organized and makes no assumptions about how test assertions are designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set up tests that run synchronously, as described in the preceding
    code, or asynchronously, using the completion handler passed to all `it` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Blocks can also be nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Mocha offers *hooks* that enable you to run code before and/or after
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeEach()` runs before each test in a `describe` block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()` runs after each test in a `describe` block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before()` runs code once prior to any test—prior to any run of `beforeEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after()` runs code once after all tests have run—after any run of `afterEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, these are used to set up test contexts, such as creating variables
    before certain tests and cleaning those up prior to certain other tests.
  prefs: []
  type: TYPE_NORMAL
- en: This simple collection of tools is expressive enough to handle most testing
    needs. Additionally, Mocha provides various test reporters that offer differently
    formatted results. We'll see those in action later as we build realistic test
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw earlier with Node''s native `assert` module, at its base, testing
    involves asserting what we expect a chunk of code to do, executing that code,
    and checking whether our expectations were met. Chai is an assertion library with
    a more expressive syntax, offering three assertion styles: **expect**, **should**,
    and **assert**. We will use Chai to provide the assertions (tests) to be wrapped
    within Mocha `it` statements, favoring the *expect* style of assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that while `Chai.assert` is modeled after the core Node `assert` syntax,
    Chai augments the object with additional methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we are going to create a configuration file called `chai.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Place this file in the `/spec/helpers` folder. This will tell Chai to display
    the full-stack trace of any errors and to expose the `expect` assertion style
    as a `global` variable. Similarly, Sinon is also exposed as a `global` variable.
    This file will augment the Mocha test run context such that we can use these tools
    without having to redeclare them in each test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `expect` style of assertion reads like a sentence, with *sentences* composed
    from words like *to*, *be*, *is*, and more. Take the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To explore the extensive list of *words* available when you are creating `expect`
    test chains, consult the full documentation at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, Mocha does not have an opinion on how you create assertions.
    We will use `expect` to create assertions in the tests that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider testing the `capitalize` function in the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This Chai assertion will be `true` and Mocha will report the same results.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chai](img/1403OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll look at how to add Sinon to our test process.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within a testing environment, you typically emulate the realities of a production
    environment as access to real users, data, or other live systems is unsafe or
    otherwise undesirable. Being able to simulate environments is, therefore, an important
    part of testing. Also, you will often want to inspect more than just call results—you
    might want to test whether a given function is being called in the right context
    or with the right examples. Sinon is a tool that helps you to simulate external
    services, emulate functions, track function calls, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sinon-chai` module extends Chai with Sinon assertions. For more information
    on `sinon-chai`, visit [https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai).
  prefs: []
  type: TYPE_NORMAL
- en: The key Sinon technologies are **spies**, **stubs**, and **mocks**. Additionally,
    you can set fake timers, create fake servers, and more (see [http://sinonjs.org/](http://sinonjs.org/)).
    This section focuses on the first three. Let's go over examples of each.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at this text from the Sinon documentation that defines a test spy:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A test spy is a function that records arguments, return value, the value
    of this and exception thrown (if any) for all its calls. A test spy can be an
    anonymous function or it can wrap an existing function."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A spy gathers information on the function it is tracking. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The spy was called twice, once with `foo`, once with `bar`, and never with `baz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we wanted to test whether our code properly connects to the
    pub/sub functionality of Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we do more with spy and with Mocha. We deploy spy to proxy
    the native `subscribe` method of `client1`, importantly setting up and tearing
    down the spy proxy (restoring original functionality) within Mocha's `before`
    and `after` methods. The Chai assertions prove that both `subscribe` and `nowPublish`
    are functioning correctly and receiving the right arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on spies can be found at [http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies).
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A stub, when used as a spy, can be wrapped around an existing function such
    that it can fake the behavior of that function (rather than simply recording function
    execution as we saw earlier). Take a look at this definition of test stubs taken
    from the Sinon documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Test stubs are functions (spies) with pre-programmed behavior. They support
    the full test spy API in addition to methods which can be used to alter the stub''s
    behavior."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s assume that you have a functionality in your application that makes
    calls to an HTTP endpoint. The code may be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When it''s successful, the call will log `Got status: 200`. Should the endpoint
    be unavailable, you''ll see something like `Got error: getaddrinfo ENOTFOUND`.'
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that you will need to test the ability of your application to handle
    alternate status codes, and, of course, explicit errors. It may not be in your
    power to force endpoints to emit these, yet you must prepare for them should they
    occur. Stubs are useful here to create synthetic responses such that your response
    handlers can be comprehensively tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use stubs to emulate a response without actually calling the `http.get`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This stub yields a simulated response by wrapping the original method, which
    is never called, resulting in a `404` error being returned from a call that would
    normally return a status code of `200`. Importantly, note how we `restore` the
    stubbed method to its original state when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following *pseudo* code describes a module that makes HTTP
    calls, parses the response, and responds with `''handled''` if everything went
    OK and `''not handled''` if the HTTP response was unexpected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Mocha test ensures that the `Caller.parseReponse` method can
    handle all response codes we need handled using stubs to simulate the entire expected
    response range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'By proxying the original `makeCall` method, we can test `parseResponse` against
    a range of status codes without the difficulty of forcing remote network behavior.
    Noting that the preceding test should fail (there is no handler for 403 codes),
    the output of this test should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stubs](img/1403OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The full API for stubs can be seen at [http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs).
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than checking expectations *after the fact*, mocks can be used to check
    whether the unit under test is being used correctly—they enforce implementation
    details. Take a look at this definition of mocks taken from the Sinon documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Mocks (and mock expectations) are fake methods (like spies) with pre-programmed
    behavior (like stubs) as well as pre-programmed expectations. A mock will fail
    your test if it is not used as expected."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the following example, we check not only the number of times a specific
    function is called (easy with spies) but also whether it is called with specific,
    expected arguments. Specifically, we again test the `capitalize` method of `Utils`,
    this time using mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: After setting up a mock on `utils`, we map a five-element array to `capitalize`,
    expecting `capitalize` to be called exactly five times, with the array's elements
    as arguments (using `apply` to spread the array into individual arguments). The
    well-named `mock.verify` function is then checked to see whether our expectations
    were satisfied. As usual, when we are done with it, we unwrap the `utils` object
    with `mock.restore`. You should see `true` logged to your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remove one element from the tested array, frustrating expectations. When
    you run the test again, you should see the following near the top of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This should clarify the type of test results that mocks are designed to produce.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that mocked functions do not execute—`mock` overrides its target. In the
    preceding example, no array members are ever run through `capitalize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit our earlier example, this time testing Redis pub/sub using mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than checking for conclusions, here we assert our expectation that the
    mocked `subscribe` method will receive the exact argument `channel` only `once`.
    Mocha expects `mock.verify` to return `true`. To make this test fail, add one
    more `client.subscribe(''channel'')` line, producing something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on how to use mocks can be found at [http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks).
  prefs: []
  type: TYPE_NORMAL
- en: Automated browser testing with PhantomJS and CasperJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to test whether a UI is working is to pay several people to interact
    with a website via a browser and report any errors they find. This can become
    a very expensive and ultimately unreliable process. Also, it requires putting
    potentially failing code into production in order to test it. It is better to
    test whether application views are rendering correctly from within the build process
    itself prior to releasing any views "into the wild". PhantomJS was created to
    address this need, among others.
  prefs: []
  type: TYPE_NORMAL
- en: A browser, stripped of its buttons and other controls, is, at its heart, a program
    that validates and runs JavaScript, HTML, and CSS. That the validated HTML is
    rendered visually on your screen is simply a consequence of humans being able
    to see only with their eyes. A server can interpret the logic of compiled code
    and see the results of interactions with that code without a visual component.
    Perhaps because eyes are usually found in one's head, a browser running on a server
    is typically referred to as a headless browser. PhantomJS provides a headless
    version of the WebKit engine that is scriptable via a JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: Headless testing with PhantomJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PhantomJS ([http://phantomjs.org/build.html](http://phantomjs.org/build.html))
    allows you to create scripts that can be executed in a headless browser context.
    It allows you to capture a browser context within a scriptable environment, enabling
    various operations, such as loading an HTML page into that context. This allows
    you to perform operations on that browser context, such as manipulating the DOM
    of a loaded page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, fetching a Twitter user''s recent tweets can be accomplished by
    hitting the following endpoint in your browser: `http://mobile.twitter.com/<twitter
    user>`. We can also use PhantomJS to do the same thing within a headless, scriptable
    environment and then write code to fetch those tweets. Create a `phantom-twitter.js`
    file containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the CLI to pass that script to PhantomJS, sending the Twitter handle
    of the person you''d like to read as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: A new file called `kanyewest.json` will be created, containing recent tweets
    in the JSON format. Let's examine the code.
  prefs: []
  type: TYPE_NORMAL
- en: We first require some of PhantomJS's core modules, importantly the `page` library
    that allows us to load pages, and the `system` and `fs` modules (which resemble
    Node's `process` and `fs` modules, respectively). We'll use `system` to fetch
    command-line arguments and `fs` to write fetched tweets to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The `page.open` command does what you would expect—loading a web page into the
    PhantomJS context. We can now perform operations on the rendered DOM. In this
    case, we are going to use `evaluate` on JavaScript within the context of that
    page, fetching the elements containing tweets identified by the `div.tweet-text`
    CSS selector and stripping out `innerText`. Because `evaluate` is running in the
    context of a headless WebKit, there is no way for us to access the outer PhantomJS
    scope, so we simply return what we find within the evaluation scope to the outer
    scope, where a file can be generated using `fs`.
  prefs: []
  type: TYPE_NORMAL
- en: PhantomJS offers an extensive API to interact with WebKit ([http://phantomjs.org/api/](http://phantomjs.org/api/)),
    allowing script injection, creating screen captures, navigating rendered pages,
    and so on. A whole range of client tests can be created using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing server tests, you will probably not want to use PhantomJS from
    the CLI. For this reason, various Node-PhantomJS bridges have been written that
    let you interact with PhantomJS via a Node module. A good one is `phantomjs` ([https://github.com/sgentle/phantomjs-node](https://github.com/sgentle/phantomjs-node)).
    For example, the following will load a page, as shown earlier, and execute JavaScript
    to fetch the page''s title attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code should result in something like the following being
    logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Navigation scenarios with CasperJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because PhantomJS is not specifically designed to be a test runner, others have
    created tools to simplify testing with PhantomJS. **CasperJS** ([http://casperjs.org/](http://casperjs.org/))
    is a navigation and testing utility for PhantomJS and **SlimerJS** (which uses
    the Gecko engine that powers Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: 'CasperJS offers an extensive toolkit to create complex chains of interactions
    using an expressive Promises-like interface. Describing page interaction tests
    with CasperJS requires much less code and is clearer. For example, the earlier
    `phantom` example demonstrating how to fetch a page title can be simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding code were saved as a file called `pagetitle.js` and run with
    the `casperjs test pagefile.js` command, you would see the following logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A much terser syntax produces identical results. Let''s look at another example
    that demonstrates how to fetch one page, click on a link on that page, and read
    some information from the resulting page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see how a Promise-like chaining of interactions results in clear
    and expressive code. After fetching Google''s search page, we will evaluate a
    piece of JavaScript that inserts the `node.js` string into its famous search box
    and submit the search form. Then, CasperJS is asked to click on the first result
    link (`h3.r a`) and to finally display the current URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that a full-page navigation has occurred, at which point we
    can chain even more interaction steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s use some of the CasperJS test assertions and demonstrate how
    to take snapshots of web pages while testing Google''s translation service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Google's translation page is dynamic. As you type into the translation box,
    the service detects keyboard events, attempts to infer the language you are using
    based on any available text, and, in "real time", provides a translation, all
    without refreshing the page. In other words, we are not submitting a form and
    waiting for the resulting page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, once we have the page loaded, we send keystrokes (`sendKeys`) into
    the `#source` input box with the Italian word `"Ciao"`. Testing that this results
    in the correct translation, we wait for `"Hello"` to arrive—`waitForText` fires
    when the text passed appears on a page. To ensure that the text has arrived in
    the right place, we assert that the element with the `#result_box` selector contains
    `"Hello"`. If all is well, you will see the following logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, within the same folder, you will find the `snapshot.png` image
    visualizing the DOM-based interactions just executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation scenarios with CasperJS](img/1403OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully, this demonstrates how CasperJS can be used to harness the power of
    PhantomJS when you're writing client tests. If you'd like to use CasperJS as a
    Node module, give SpookyJS ([https://github.com/SpookyJS/SpookyJS](https://github.com/SpookyJS/SpookyJS))
    a try.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at testing and building your application such
    that you can get a good sense of its ability to *stand up* in production. We worked
    through a representative build system that used Gulp and Browserify, along with
    some other tools, to show how a codebase can be optimized and packaged for deployment.
    Also, you learned about Node's native debugging tools and assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: The Node community has embraced testing from the beginning, and many testing
    frameworks and native tools are made available to developers. You learned how
    to set up a proper test system using Gulp, Mocha, Chai, and Sinon, in the process
    experimenting with headless browser testing.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be focused on taking the builds you have tested and deploying
    them to production servers. You'll learn about setting up local development environments
    on virtual machines, provisioning remote servers, setting up continuous integration
    with webhooks and Jenkins, maintaining your application dependencies and, generally,
    keeping your applications running smoothly as changes are made.
  prefs: []
  type: TYPE_NORMAL
