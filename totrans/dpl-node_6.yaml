- en: Chapter 6. Building and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。构建和测试
- en: 'Perfect code is a unicorn; what good developers do is introduce the smallest
    amount of bad code. Any code is, therefore, somewhat flawed, so errors and inefficiency
    are an inescapable pathology in software development. Accordingly, **technical
    debt** naturally compounds as more code is written. Some of the more expensive
    technical realities of modern application development are listed here:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的代码是独角兽；优秀开发者所做的就是引入尽可能少的坏代码。因此，任何代码多少都有缺陷，错误和低效是软件开发中不可避免的病理。相应地，**技术债务**会随着代码量的增加而自然累积。以下是现代应用程序开发中一些更昂贵的技术现实：
- en: There are rigidly coupled components that do not easily allow change at either
    the technical level or the business level. Allowing such unprincipled interpenetration
    leads to complex capillary networks growing throughout the body of your code.
    The edges of these networks are nearly impossible to trace, concretizing entanglements
    that obscure how a change in one function might affect other functions.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一些严格耦合的组件，它们在技术层面或业务层面都不容易改变。允许这种无原则的渗透会导致复杂的毛细血管网络在你的代码主体中生长。这些网络的边缘几乎无法追踪，具体化了纠缠，掩盖了某个函数的变化可能如何影响其他函数。
- en: Poor gatekeeping allows untested code to enter production, often leading to
    quick fixes, which, in turn, can lead to intractable patches and bridge code as
    well as relentless bugs that regularly resurface.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕的守门人让未经测试的代码进入生产环境，通常会导致快速修复，这反过来又可能导致难以解决的补丁和桥接代码，以及不断出现的顽固错误。
- en: There are code units built in isolation in parallel without objective *big picture*
    guidelines that are merged into a single codebase sloppily and joined together
    by undocumented, ad hoc bindings.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一些在并行中独立构建的代码单元，没有客观的 *大局观* 指南，它们被粗略地合并到一个代码库中，并通过未记录的、临时的绑定连接在一起。
- en: The need for refactoring reaches a critical point, and further development,
    in any sense, becomes nearly impossible. Scaling ceilings typify this situation,
    and wholesale rewrites are inevitable and nearly always doomed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构的需求达到临界点，任何意义上的进一步开发几乎都变得不可能。扩展天花板是这种情况的典型，全面重写是不可避免的，并且几乎总是注定要失败。
- en: Debt accumulates interest. Software, like many long-term pursuits, requires
    constant debt management. It is in your interest to reduce debt. In the previous
    chapter, we learned how to profile *deployed* applications at a level of detail
    sufficient to expose errors, weaknesses, and other unwanted characteristics. In
    this chapter, we will explore strategies that help software developers and teams
    catch errors before the membranes of their applications are breached. We will
    also explore workflows to manage the integration of independently written programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 债务会累积利息。软件，就像许多长期追求一样，需要不断的债务管理。减少债务对你有利。在前一章中，我们学习了如何以足够的详细程度分析 *已部署* 应用程序，以暴露错误、弱点和其他不受欢迎的特征。在本章中，我们将探讨帮助软件开发者和团队在应用程序的膜被突破之前捕捉错误的策略。我们还将探讨管理独立编写的程序集成的流程。
- en: Building with Gulp, Browserify, and Handlebars
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gulp、Browserify 和 Handlebars 构建
- en: The JavaScript you are working on will likely be transformed and augmented before
    it makes it to production. At the very least, it will be checked for errors, minified,
    packaged, and so on. It will be deployed only after that. Deployment, therefore,
    follows a build step and how each step in the build is instrumented must be clearly
    defined.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在工作的 JavaScript 代码在进入生产之前可能会被转换和增强。至少，它将被检查错误、压缩、打包等。只有在之后才会部署。因此，部署遵循构建步骤，并且必须明确定义构建中每个步骤的仪器化。
- en: Over time, certain patterns of development have emerged within the Node community.
    Many of these patterns map to other environments, while others are unique to the
    *full-stack JavaScript* Node.js world. The ability to run identical code on the
    client and server is perhaps the most prominent example. Because deployed codebases
    often contain the end result of transpilation (for example, CoffeeScript, and
    SASS), deployment workflows are assembled to run preprocessors, concatenate files,
    create source maps, compress images, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Node 社区内部已经出现了一些发展模式。其中许多模式映射到其他环境中，而另一些则是 *全栈 JavaScript* Node.js 世界的独特之处。在客户端和服务器上运行相同代码的能力可能是最突出的例子。由于部署的代码库通常包含编译后的最终结果（例如，CoffeeScript
    和 SASS），因此部署工作流程被组装起来以运行预处理器、合并文件、创建源映射、压缩图像等。
- en: In this section, we will look at three technologies that are regularly seen
    in the Node build/deploy process. We'll use **Gulp** to create a build system,
    using **Browserify** to bundle application code and **Handlebars** as a templating
    language for compiling static pages. Finally, we'll look at how to improve our
    development experience by using **BrowserSync**
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在 Node 构建和部署过程中经常遇到的三种技术。我们将使用 **Gulp** 来创建构建系统，使用 **Browserify**
    来打包应用程序代码，以及使用 **Handlebars** 作为静态页面的模板语言。最后，我们将探讨如何通过使用 **BrowserSync** 来提升我们的开发体验。
- en: Using Gulp
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gulp
- en: 'Create a new folder and initialize a `package.json` file in that folder with
    `npm init`. When this is done, you''ll end up with a `package.json` file that
    looks somewhat like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并在该文件夹中使用 `npm init` 初始化一个 `package.json` 文件。完成此操作后，你将得到一个看起来类似于以下内容的
    `package.json` 文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This basic scaffold will be fleshed out and explained as we proceed. The point
    is simply that you will now hang the modules and other dependencies of your application
    on this scaffold, using npm, neatly describing dependencies, test harnesses, and
    more. Since we''ll use the Gulp build system, it is reasonable to install the
    Gulp module first and to assert that it is a dependency of this package. Run these
    two commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，这个基本框架将被完善并解释。重点是，你现在将使用 npm 将应用程序的模块和其他依赖项挂载在这个框架上，整洁地描述依赖项、测试工具等。由于我们将使用
    Gulp 构建系统，因此首先安装 Gulp 模块并将其声明为该包的依赖项是合理的。运行以下两个命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first command installs Gulp globally, meaning that you can now use the
    `gulp` command directly from the command line (you can also abbreviate `--global`
    with `-g`). The next command installs Gulp locally, adding the following new property
    to the `package.json` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令全局安装 Gulp，这意味着你现在可以直接从命令行使用 `gulp` 命令（你也可以用 `-g` 简写 `--global`）。下一个命令本地安装
    Gulp，向 `package.json` 文件添加以下新属性：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Gulp has been installed and saved as a dependency. We are prepared to construct
    a build system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 已被安装并保存为依赖项。我们已准备好构建构建系统。
- en: One goal of a build system is the instrumentation of your development environment
    such that you can work naturally with uncompressed, unminified code while developing
    and, later, issue commands to convert your *raw* code and assets into an optimized
    state suitable for staging environments, production environments, and so on. Providing
    developers with an expressive and simple syntax for describing how to convert
    source code into deployable code is what Gulp aims to provide.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的一个目标是在你的开发环境中进行仪表化，这样你可以在开发时自然地使用未压缩、未优化的代码，稍后可以发出命令将你的 *原始* 代码和资源转换为适合预演环境、生产环境等优化的状态。为开发者提供一个表达性和简单的语法来描述如何将源代码转换为可部署的代码是
    Gulp 力求实现的。
- en: 'Create two new folders in your working directory: a `/source` folder and a
    `/build` folder. We''re going to create a set of instructions for transforming
    the files in `source/` into files in `/build`. This set of instructions is stored
    in a file that is specifically called `gulpfile.js`. Create that file and insert
    the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工作目录中创建两个新的文件夹：一个名为 `/source` 的文件夹和一个名为 `/build` 的文件夹。我们将创建一组指令，用于将 `source/`
    中的文件转换为 `/build` 中的文件。这组指令存储在一个特定命名为 `gulpfile.js` 的文件中。创建该文件并插入以下代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Gulp works on the idea of running a number of tasks in a certain order. The
    general format is `gulp.task(<task name>, <task runner>)`. A Gulpfile is typically
    extended with several such task definitions. As we''ll see, tasks can be named
    anything you''d like, but there must always be a default task named *default*,
    and the preceding code establishes such a task to do one simple thing: ensure
    that a `/build` folder exists, and, if not, to create one.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 基于运行一系列任务按特定顺序执行的理念。一般格式是 `gulp.task(<任务名称>, <任务执行器>)`。Gulpfile 通常通过添加多个此类任务定义来扩展。正如我们将看到的，任务可以命名为任何你想要的名称，但必须始终有一个名为
    *default* 的默认任务，并且前面的代码建立了一个这样的任务来执行一个简单的事情：确保存在一个 `/build` 文件夹，如果不存在，则创建一个。
- en: 'One thing to notice is the first argument a task runner function receives:
    a callback function, here named `cb`. Because Node programs customarily run asynchronous
    code, it is important to have a mechanism to *tell* `gulp` that a task is finished.
    We''re running asynchronous code to check for the existence of a folder, so we
    use this callback system, but note that, if your code either runs synchronously
    or if the moment of task completion is irrelevant to subsequent tasks, you can
    skip running a callback, and Gulp will simply continue with the next task as soon
    as the task runner exits.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是任务运行器函数接收的第一个参数：一个回调函数，这里命名为`cb`。由于Node程序通常运行异步代码，因此有一个机制来*告知* `gulp`
    任务已完成是很重要的。我们正在运行异步代码来检查文件夹的存在，因此我们使用这个回调系统，但请注意，如果你的代码是同步运行的，或者任务完成的时刻对后续任务无关紧要，你可以跳过运行回调，Gulp将在任务运行器退出后立即继续执行下一个任务。
- en: 'Go ahead and run the `gulp` command in the folder containing your Gulpfile.
    You should see something like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含你的Gulpfile的文件夹中运行`gulp`命令。你应该会看到以下类似的内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To check that the task is doing its job correctly, delete the `/build` folder
    and run `gulp` again. You'll see that the folder is recreated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查任务是否正确执行其工作，删除`/build`文件夹并再次运行`gulp`。你会看到文件夹被重新创建。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Given that Gulp expects its Gulpfile to contain a *default* task, the `gulp`
    command is simply a shortcut for `gulp default`. You can execute a specific task
    by running `gulp <taskname>`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gulp期望其Gulpfile包含一个*默认*任务，因此`gulp`命令只是`gulp default`的快捷方式。你可以通过运行`gulp <taskname>`来执行特定的任务。
- en: 'In a typical build, many tasks will be run. Each task should be as simple and
    specific as possible, and the Gulpfile should neatly organize them so that they
    execute in a certain order. For this reason, the default task, typically, doesn''t
    do much on its own but is used as a way to hint at the list of tasks that will
    be run. Let''s rewrite the preceding code in a more directed way:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的构建过程中，将运行许多任务。每个任务应该尽可能简单和具体，Gulpfile应该整齐地组织它们，以便它们按特定顺序执行。因此，默认任务通常本身不做什么，而是用作提示将要运行的任务列表的方式。让我们以前述代码更直接的方式重写代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we see more clearly how `gulp` works. A second array argument is passed
    to the `gulp` task''s definition, listing other tasks on which the current task
    depends—a task will not run until all of its dependencies have completed. Let''s
    add another task to this execution chain that copies files in the `/source` folder
    to the `/build` folder. Add the following to your Gulpfile:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以更清楚地看到`gulp`是如何工作的。将第二个数组参数传递给`gulp`任务的定义，列出当前任务所依赖的其他任务——一个任务将在所有依赖任务完成后才运行。让我们向这个执行链添加另一个任务，该任务将`/source`文件夹中的文件复制到`/build`文件夹。将以下内容添加到你的Gulpfile中：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, tell `gulp` about this new task:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，告诉`gulp`关于这个新任务的信息：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to `task`, you will use the `src`, `pipe`, and `dest` Gulp commands
    frequently. Gulp is a *streaming* build system—within a task, you will normally
    identify a collection of files, run a chain of transformations against them, and
    put the transformed files somewhere useful, typically the folder containing a
    deployable application. The `src` command is used to identify this collection
    and convert the contained files into streamable objects such that `pipe` can be
    used on them to gulp plugins. We will provide more information on this later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`task`之外，你还将频繁使用`src`、`pipe`和`dest` Gulp命令。Gulp是一个*流式*构建系统——在任务中，你通常将一组文件识别出来，对它们运行一系列转换，并将转换后的文件放置在有用的位置，通常是包含可部署应用程序的文件夹。`src`命令用于识别这个集合，并将包含的文件转换为可流式传输的对象，以便可以使用`pipe`对它们进行操作以使用gulp插件。我们将在稍后提供更多相关信息。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Arguments to Gulp's `src` command often contain *globs* (for example, `/source/**`),
    flavors of pattern matching that are useful when we target files within folders.
    More on how they work can be found at [https://github.com/isaacs/node-glob#glob-primer](https://github.com/isaacs/node-glob#glob-primer).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp的`src`命令的参数通常包含*通配符*（例如，`/source/**`），这是一种用于在文件夹内定位文件的模式匹配方式。更多关于它们如何工作的信息可以在[https://github.com/isaacs/node-glob#glob-primer](https://github.com/isaacs/node-glob#glob-primer)找到。
- en: 'The preceding code creates a collection of files in the `/source` directory
    and pipes them to the (built-in) `dest` gulp plugin, which writes them to `/build`.
    Run gulp again. You will see something like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在`/source`目录中创建一组文件，并将它们通过（内置的）`dest` gulp插件管道传输，该插件将它们写入`/build`。再次运行gulp。你会看到以下类似的内容：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Did you see anything problematic? The `move` task ran prior to the completion
    of `initialize`, which creates a race condition—will the `/build` directory be
    created before `move` tries to add files to it? A build should be as fast as possible,
    and, to that end, Gulp aims for maximum concurrency—unless you specify otherwise,
    Gulp will run all of its tasks concurrently. As illustrated in the preceding code,
    `initialize` and `move` start simultaneously. How can a specific ordering be enforced?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么问题吗？`move`任务在`initialize`完成之前运行，这会创建一个竞争条件——在`move`尝试向其中添加文件之前，`/build`目录会被创建吗？构建应该尽可能快，为此，Gulp旨在实现最大并发性——除非你指定了其他方式，否则Gulp将并发运行所有任务。如前述代码所示，`initialize`和`move`是同时开始的。如何强制执行特定的顺序？
- en: 'The ordering of the dependency list passed to `default` does *not* reflect
    their execution order. However, it does represent a list of tasks that must complete
    prior to the execution of `default`. To ensure that `move` follows `initialize`,
    simply make `initialize` a dependency of `move`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`default`的依赖项列表的顺序**并不**反映它们的执行顺序。然而，它确实代表了一个列表，这些任务必须在执行`default`之前完成。为了确保`move`在`initialize`之后执行，只需将`initialize`作为`move`的依赖项即可：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Erecting a build scaffold
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立构建脚手架
- en: 'Now that you have an idea of how Gulp works, let''s build a representative
    build process. We''ll develop a Gulpfile step by step. To start with, use the
    following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了Gulp的工作原理，让我们构建一个代表性的构建过程。我们将逐步开发一个Gulpfile。首先，使用以下代码：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the head of this file, you''ll see a lot of require statements. Excepting
    `path`, they will all be used as either Gulp plugins or helpers. You can just
    copy the `package.json` file found in the `/building` folder of you code bundle
    for this chapter, or go ahead and install them using the `--save-dev` directive:
    `npm install --save-dev gulp-coffee gulp-changed [...]`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件的顶部，你会看到很多require语句。除了`path`之外，它们都将被用作Gulp插件或辅助工具。你可以直接复制你代码包`/building`文件夹中找到的`package.json`文件，或者继续使用`--save-dev`指令安装它们：`npm
    install --save-dev gulp-coffee gulp-changed [...]`。
- en: Also, install the `jquery` and `handlebars` npm modules as dependencies using
    `npm install --save jquery handlebars`. We will provide more information on why
    we do this when we discuss Browserify.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`npm install --save jquery handlebars`命令安装`jquery`和`handlebars`npm模块作为依赖项。当我们讨论Browserify时，我们将提供更多关于为什么这样做的原因。
- en: 'The `clean` and `scaffold` tasks exist to build a folder structure for your
    app and to clean the relevant build directories whenever a new build happens (making
    room for newly built files without leaving the residue of old ones). Take a look
    at those tasks; they ultimately ensure the following folder structure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`和`scaffold`任务存在是为了为你的应用程序构建文件夹结构，并在每次新构建发生时清理相关的构建目录（为新构建的文件腾出空间，而不留下旧文件的残留）。看看那些任务；它们最终确保以下文件夹结构：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following demonstration, we'll write our JavaScript in **CoffeeScript**,
    storing `.coffee` files in the `source/scripts` directory, which will be compiled
    and moved to the `build/js` directory. The `build/css` directory will receive
    transformed `.scss` files contained in `source/styles`. Handlebars templates will
    be precompiled and moved from `source/templates` to `build/templates`. Finally,
    the `.html` files forming the main "pages" of our application will be located
    in `/source` and moved to the root `/build` folder. Later on, we will add tasks
    to expose these HTML views via a web server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的演示中，我们将使用**CoffeeScript**编写我们的JavaScript代码，将`.coffee`文件存储在`source/scripts`目录中，这些文件将被编译并移动到`build/js`目录。`build/css`目录将接收存储在`source/styles`中的转换后的`.scss`文件。Handlebars模板将被预编译并从`source/templates`移动到`build/templates`。最后，构成我们应用程序主要“页面”的`.html`文件将位于`/source`，并移动到根目录`/build`。稍后，我们将添加任务以通过Web服务器公开这些HTML视图。
- en: At the bottom of the snippet, you will see the list of tasks that we'll define
    bound as dependencies of the default Gulp task. Let's go over those one by one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的底部，你会看到我们将定义的任务列表，这些任务将作为默认Gulp任务的依赖项绑定。让我们逐一过一遍这些任务。
- en: 'Linting files involves running a syntax checker on your scripts, enforcing
    various rules, such as indentation, whether or not certain constructs are allowed,
    whether to force the use of the semicolon, and so on. We''ll use CoffeeScript
    exclusively, so we implement a lint task using the `gulp-coffeelint` plugin:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 文件检查涉及在脚本上运行语法检查器，强制执行各种规则，例如缩进、是否允许某些结构、是否强制使用分号等。我们将仅使用CoffeeScript，因此我们使用`gulp-coffeelint`插件实现一个检查任务：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We're simply checking the syntax of the CoffeeScript files that will be transpiled
    into JavaScript files residing in the `/js` build folder. Any discrepancies will
    be reported to `stdout` but will not stop the build. A `coffeelint.json` file
    containing syntax rules is applied. You should investigate this file and modify
    it to fit your needs—more information can be found at [http://www.coffeelint.org](http://www.coffeelint.org).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是检查将要转换成 `/js` 构建文件夹中 JavaScript 文件的 CoffeeScript 文件的语法。任何差异都会报告到 `stdout`，但不会停止构建。应用包含语法规则的
    `coffeelint.json` 文件。你应该调查此文件，并根据需要修改它——更多信息可以在 [http://www.coffeelint.org](http://www.coffeelint.org)
    找到。
- en: 'The next step is to build these newly linted scripts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建这些新清理过的脚本：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are several build steps happening here. We could simply transform CoffeeScript
    files to JavaScript files and copy them to the `build/scripts` folder. However,
    as the transpiled JavaScript file is not the original source file, we need to
    create a **sourcemap**—an essential tool that will map errors in JavaScript to
    *the original CoffeeScript source* that generated the said JavaScript. This is
    invaluable when we are debugging in a browser. As you saw in the code, we simply
    use the `gulp-sourcemaps` plugin to track the compilation step, and it automatically
    appends a sourcemap to the generated JavaScript file, which looks somewhat like
    the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在进行几个构建步骤。我们可以简单地转换 CoffeeScript 文件到 JavaScript 文件，并将它们复制到 `build/scripts`
    文件夹。然而，由于转换后的 JavaScript 文件不是原始源文件，我们需要创建一个 **源映射**——这是一个将错误映射到生成该 JavaScript
    的 **原始 CoffeeScript 源** 的基本工具。这在我们在浏览器中进行调试时非常有价值。正如你在代码中所看到的，我们简单地使用 `gulp-sourcemaps`
    插件来跟踪编译步骤，并且它会自动将源映射附加到生成的 JavaScript 文件，其外观大致如下：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `gulp-changed` plugin intelligently tracks whether any targeted files have
    changed, and, if they have not, the plugin removes them from processing. This
    plugin can drastically reduce the execution time of any task processing a large
    numbers of files. Note that we set the extension argument to `.js` as an option
    as the original file extension (`.coffeescript`) will be changed and the plugin
    must be told about this naming change.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-changed` 插件智能地跟踪是否有任何目标文件已更改，如果没有，则插件会将其从处理中移除。此插件可以显著减少处理大量文件的任务的执行时间。请注意，我们将扩展名参数设置为
    `.js` 作为选项，因为原始文件扩展名（`.coffeescript`）将更改，并且插件必须被告知这种命名更改。'
- en: 'We will create styles in our system using the **Sass** CSS preprocessor ([http://sass-lang.com/](http://sass-lang.com/))
    denoted by their `.scss` extension. In the following task definition, they are
    converted to standard CSS. In addition, they are bundled up into a single output
    file (`app.css`) using the `gulp-concat` plugin:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Sass** CSS 预处理器（通过 `.scss` 扩展名表示）在我们的系统中创建样式。在以下任务定义中，它们被转换为标准 CSS。此外，它们使用
    `gulp-concat` 插件捆绑成一个单独的输出文件（`app.css`）：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Bundled into a single file at the build step, global styles can be added to
    any view with a single `<link>` tag, while maintaining the necessary separation
    of style documents during development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建步骤中捆绑成一个单独的文件，全局样式可以通过单个 `<link>` 标签添加到任何视图中，同时在开发过程中保持样式文档的必要分离。
- en: 'The next step is slightly more complicated. We are going to use Handlebars
    templates, which (might) look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步稍微复杂一些。我们将使用 Handlebars 模板，它们（可能）看起来像这样：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For Handlebars to feed the preceding iterator some JSON to process, the template
    must be compiled into a JavaScript function via the `Handlebars.template` method.
    While this could be done on the client side, it is much more efficient to simply
    precompile our templates at the build step. So, what we''re going to do is export
    each template as an individual Node module such that they can be used as one normally
    uses modules. To accomplish this, we''ll use the `gulp-wrap` plugin:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Handlebars 向前面的迭代器提供一些 JSON 以进行处理，模板必须通过 `Handlebars.template` 方法编译成 JavaScript
    函数。虽然这可以在客户端完成，但在构建步骤中简单地预编译我们的模板会更有效率。所以，我们将做的是将每个模板导出为一个单独的 Node 模块，这样就可以像使用模块一样使用它们。为了实现这一点，我们将使用
    `gulp-wrap` 插件：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This task wraps each source file in code that will use the Handlebars runtime
    to compile the source code into an exportable JavaScript function. Now, the template
    can be used in your client code without the overhead of loading Handlebars at
    runtime or using it for compilation. For example, use the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务将每个源文件包裹在将使用Handlebars运行时将源代码编译成可导出JavaScript函数的代码中。现在，模板可以在你的客户端代码中使用，而无需在运行时加载Handlebars或使用它进行编译。例如，使用以下代码：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You might be saying to yourself, "But wait...client-side JavaScript doesn''t
    have a `require` statement!"...and you''d be right! Enter the power of Browserify:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对自己说，“但是等等……客户端JavaScript没有`require`语句！”……你是对的！这就是Browserify的强大之处：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As mentioned at [http://browserify.org/](http://browserify.org/):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如[http://browserify.org/](http://browserify.org/)所述：
- en: '*"With Browserify, you can write code that uses require in the same way that
    you would use it in Node."*'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"使用Browserify，你可以像在Node中使用一样使用require。"*'
- en: This allows us to write our client application code as if it was running within
    Node, with a DOM document thrown in. In the preceding task, Browserify automatically
    fetches all `app.js` dependencies (instances of `require`), bundles them up into
    a file that will run on the client, runs the `gulp-uglify` plugin to minify the
    resulting JavaScript, and replaces the old file with the Browserified bundle.
    The `app.js` file can contain all of the code we need, in one file, thus simplifying
    and standardizing client integration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们像在Node中运行一样编写我们的客户端应用程序代码，同时加入一个DOM文档。在前面的任务中，Browserify自动获取所有`app.js`依赖（`require`的实例），将它们捆绑成一个将在客户端运行的文件，运行`gulp-uglify`插件来压缩生成的JavaScript，并用Browserified捆绑包替换旧文件。`app.js`文件可以包含我们需要的所有代码，在一个文件中，从而简化并标准化客户端集成。
- en: 'Browserify isn''t just about concatenation, however. The point is that, with
    Browserify, we can use npm modules on both the client and the server, *normalizing*
    our process, and, therefore, leveraging intelligent package management for client-side
    JavaScript. This is new and important: we have gained the power of package management
    and its standardized loading system on the client side. While some client frameworks
    provide something resembling module management systems, none of these *hacks*
    can replace the solid npm system. Consider this example `source/scripts/app.coffee`
    file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify不仅仅关于连接。重点是，使用Browserify，我们可以在客户端和服务器上使用npm模块，*标准化*我们的流程，因此利用智能包管理来处理客户端JavaScript。这是新的且重要的：我们在客户端获得了包管理和其标准加载系统的力量。虽然一些客户端框架提供了类似模块管理系统的东西，但没有任何这些*黑客*可以取代稳固的npm系统。考虑以下示例`source/scripts/app.coffee`文件：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you check your code bundle, you will find this file. Notice how we `require`
    the npm module version of jQuery, as well as the precompiled templates we created
    previously from Handlebars templates. Yet, we are running in the client, so we
    can use jQuery operations to add HTML to the DOM—the best of both worlds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查你的代码包，你会找到这个文件。注意我们是如何`require` jQuery的npm模块版本，以及我们之前从Handlebars模板创建的预编译模板。然而，我们在客户端运行，因此我们可以使用jQuery操作将HTML添加到DOM中——这是两者的最佳结合。
- en: 'The task for `views` is very simple:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`views`的任务非常简单：'
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We're just compressing HTML and moving the file, with no further changes, to
    the build directory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在压缩HTML并将文件移动到构建目录，没有进行任何其他更改。
- en: Running and testing your build
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试你的构建
- en: 'At this point, we have all the tasks set up to manage the key files for our
    repository. Let''s use `browser-sync` to automatically spawn a server and a browser
    window that will load the `index.html` file from our build directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了所有任务来管理我们仓库的关键文件。让我们使用`browser-sync`来自动启动一个服务器和一个浏览器窗口，该窗口将从我们的构建目录加载`index.html`文件：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `test` and `watch` tasks will be explained next. For now, notice how easy
    it is to add a server to your build process. This task starts a server on the
    provided port and automatically loads `index.html` found in `baseDir` onto an
    automatically spawned browser window. The `notify` option tell BrowserSync not
    to display debugging notifications in connected browsers. Now, every time we run
    Gulp, our app will load up in a browser. Your terminal should display information
    similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务将解释`test`和`watch`任务。现在，请注意添加服务器到构建过程是多么容易。这个任务在提供的端口上启动一个服务器，并自动将`baseDir`中找到的`index.html`加载到一个自动生成的浏览器窗口中。`notify`选项告诉BrowserSync不要在连接的浏览器中显示调试通知。现在，每次我们运行Gulp，我们的应用程序都会在浏览器中加载。你的终端应该显示类似以下的信息：
- en: '![Running and testing your build](img/1403OS_06_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![运行和测试你的构建](img/1403OS_06_01.jpg)'
- en: BrowserSync allows multiple clients to view your build, so an external access
    URL is provided. Additionally, they will see your interactions. For example, if
    you scroll the page, the pages of connected clients will also scroll. Additionally,
    the UI URL will expose a sort of dashboard for your build, allowing you to control
    connected clients, reload their views, and so on. This is a great tool when you
    are doing demonstrations for your team or for a client. To learn more about BrowserSync
    and its configuration, visit [http://www.browsersync.io/](http://www.browsersync.io/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: BrowserSync 允许多个客户端查看你的构建，因此提供了一个外部访问 URL。此外，他们还将看到你的交互。例如，如果你滚动页面，连接的客户端的页面也会滚动。此外，UI
    URL 将暴露一个用于构建的仪表板，允许你控制连接的客户端、重新加载他们的视图等等。当你为团队或客户进行演示时，这是一个非常好的工具。要了解更多关于 BrowserSync
    及其配置的信息，请访问 [http://www.browsersync.io/](http://www.browsersync.io/)。
- en: 'A good build system should provide a testing harness as the final arbiter of
    whether the build should be certified. We''ll do a deep dive into testing with
    **Mocha**, **Chai**, and **Sinon** later in this chapter, so here we''ll just
    demonstrate a very simple testing stub that you can build on when designing your
    Gulp workflow:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的构建系统应该提供一个测试框架作为构建是否应该获得认证的最终裁决者。我们将在本章后面深入探讨使用 **Mocha**、**Chai** 和 **Sinon**
    进行测试，所以在这里我们只演示一个非常简单的测试占位符，你可以在设计 Gulp 工作流程时在此基础上构建：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is a test file written in CoffeeScript within the tests directory:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试目录中有一个用 CoffeeScript 编写的测试文件：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This test will load one of our template modules, which exports an array with
    seven members—the days of the week. The test uses Node''s core `assert` library
    (discussed in detail later in this chapter) to test whether this array has the
    correct length of seven characters. Mocha provides the testing harness, via `describe`
    and `it`, allowing you to design tests that read like a natural language. When
    you run through Gulp, you should see something like this (if everything goes right):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将加载我们的模板模块之一，该模块导出一个包含七个成员的数组——一周中的日子。测试使用 Node 的核心 `assert` 库（将在本章后面详细讨论）来测试这个数组是否具有正确的七个字符长度。Mocha
    通过 `describe` 和 `it` 提供测试框架，允许你设计看起来像自然语言的测试。当你运行 Gulp 时，你应该看到类似以下内容（如果一切顺利）：
- en: '![Running and testing your build](img/1403OS_06_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![运行和测试你的构建](img/1403OS_06_02.jpg)'
- en: 'The final task is provided by another native Gulp method: `watch`. The purpose
    of `watch` is to bind file watchers to certain directories such that any file
    change will automatically trigger a rerun of the relevant build tasks. For example,
    you might want to run the `scripts` task again if any file in `source/scripts`
    changes. The following code demonstrates how (changes in) certain folders automatically
    trigger a number of build tasks:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务由另一个本地的 Gulp 方法提供：`watch`。`watch` 的目的是将文件监视器绑定到特定的目录，以便任何文件更改都会自动触发相关构建任务的重新运行。例如，如果你发现
    `source/scripts` 目录中的任何文件发生了变化，你可能希望再次运行 `scripts` 任务。以下代码演示了如何（更改）某些文件夹自动触发一系列构建任务：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will notice that BrowserSync is bound to changes as well, thus creating
    a very natural development process. Once you have a running build displayed in
    a browser, any change you make to, for example, `index.html`, will be *automatically*
    reflected in that view. As you change the CSS, you will see the change immediately,
    and so on. There will be no more constant reloading when you are developing; BrowserSync
    pushes changes for you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 BrowserSync 也会绑定到更改上，从而创建一个非常自然的发展过程。一旦你在浏览器中显示了一个正在运行的构建，你对例如 `index.html`
    所做的任何更改都会 *自动* 反映在该视图中。当你更改 CSS 时，你会立即看到更改，依此类推。在开发过程中将不再需要不断重新加载；BrowserSync
    会为你推送更改。
- en: There are many other things you might need to do. For example, you might want
    to compress images before pushing them to production. As a practice, create the
    relevant image folders in your source and build directory and implement an `images`
    task using `gulp-imagemin` ([https://github.com/sindresorhus/gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要做许多其他事情。例如，你可能希望在将图像推送到生产之前压缩它们。作为一个练习，在你的源目录和构建目录中创建相关的图像文件夹，并使用 `gulp-imagemin`
    实现一个 `images` 任务（[https://github.com/sindresorhus/gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)）。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The people behind Gulp provide a good collection of suggested patterns to implement
    common build tasks at [https://github.com/gulpjs/gulp/tree/master/docs/recipes](https://github.com/gulpjs/gulp/tree/master/docs/recipes).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp背后的团队提供了一组建议的模式，用于在[https://github.com/gulpjs/gulp/tree/master/docs/recipes](https://github.com/gulpjs/gulp/tree/master/docs/recipes)中实现常见的构建任务。
- en: 'Here''s a final note: you will regularly *hand-code* these sorts of build systems,
    typically reusing the same patterns. For this reason, certain automated tools
    have been created that can often reduce the creation of boilerplate build code
    to a few commands. A popular one is **Yeoman** ([http://yeoman.io/](http://yeoman.io/)),
    which makes it easy to construct common "stacks" of build steps, databases, servers,
    and frameworks. Other notable solutions are **Brunch** ([http://brunch.io/](http://brunch.io/))
    and **Mimosa** ([http://mimosa.io/](http://mimosa.io/)).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最后的注意事项：你将经常*手动编码*这类构建系统，通常重用相同的模式。因此，已经创建了某些自动化工具，这些工具通常可以将创建样板构建代码的过程简化为几个命令。其中之一是**Yeoman**([http://yeoman.io/](http://yeoman.io/))，它使得构建常见的“堆栈”构建步骤、数据库、服务器和框架变得容易。其他值得注意的解决方案包括**Brunch**([http://brunch.io/](http://brunch.io/))和**Mimosa**([http://mimosa.io/](http://mimosa.io/))。
- en: Using Node's native testing tools
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node的本地测试工具
- en: Testing is simply the act of checking whether your assumptions about the state
    of something are false. In this way, testing software follows the scientific method
    in that you will express a theory, make a prediction, and run an experiment to
    see whether the data matches your prediction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仅仅是检查你对某物状态的假设是否错误的行为。这样，测试软件遵循科学方法，即你将表达一个理论，做出预测，并运行一个实验来查看数据是否与你的预测相符。
- en: Unlike scientists, software developers can change reality—Einstein's joke about
    changing the facts if they don't fit the theory actually applies, without irony,
    to the testing process. In fact, it is required! When your tests (theories) fail,
    you must change "the world" until the tests do not fail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与科学家不同，软件开发者可以改变现实——爱因斯坦关于改变事实以适应理论的笑话实际上毫无讽刺意味地适用于测试过程。事实上，这是必需的！当你的测试（理论）失败时，你必须改变“世界”，直到测试不再失败。
- en: In this section, you will learn how to use Node's native debugger for *live*
    code testing and how to use the `assert` module to make predictions, run experiments,
    and test results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Node的本地调试器进行*实时*代码测试，以及如何使用`assert`模块进行预测、运行实验和测试结果。
- en: The Node debugger
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node调试器
- en: Most developers have used an IDE for development. A key feature of all good
    development environments is access to a debugger, which allows breakpoints to
    be set in a program in places where the state or other aspects of the runtime
    need to be checked.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都使用IDE进行开发。所有良好开发环境的关键特性之一是访问调试器，它允许在程序中设置断点，以便在需要检查状态或其他运行时方面的地方。
- en: 'V8 is distributed with a powerful debugger (commonly seen powering the Google
    Chrome browser''s developer tools panel), and this is accessible to Node. It is
    invoked using the `debug` directive, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: V8与一个强大的调试器一起分发（通常用于Google Chrome浏览器开发者工具面板），并且Node可以访问它。它通过`debug`指令调用，如下所示：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Simple stepthrough and inspection debugging can now be achieved within a Node
    program. Consider the following program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的逐步调试和检查现在可以在Node程序中实现。考虑以下程序：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note the `debugger` directive. Executing this program *without* using the `debug`
    directive will result in `"hello"` being displayed, followed by `"world"` one
    second later. When using the directive, you will see this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`debugger`指令。在不使用`debug`指令的情况下执行此程序将导致显示“hello”，一秒后显示“world”。当使用指令时，你会看到以下内容：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once a breakpoint is hit, we are presented with a CLI to the debugger itself,
    from within which we can execute standard debugging and other commands:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遇到断点，我们将获得一个到调试器本身的CLI，从其中我们可以执行标准的调试和其他命令：
- en: '`cont, c`: This continues execution from the last breakpoint until the next
    breakpoint'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cont, c`：这将从最后一个断点继续执行，直到下一个断点'
- en: '`step, s`: Step in—this keeps running until a new source line (or breakpoint)
    is hit; after that, return control to the debugger'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step, s`：进入步骤——这将一直运行，直到遇到新的源行（或断点）；之后，将控制权返回给调试器'
- en: '`next, n`: This is like the preceding command, but function calls made on the
    new source line are executed without stopping'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next, n`：这与前面的命令类似，但新源行上的函数调用将执行而不停止'
- en: '`out, o`: Step out—this executes the remainder of the current function and
    back out to the parent function'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out, o`: 跳出——这将执行当前函数的剩余部分并返回到父函数'
- en: '`backtrace, bt`: This traces the steps to the current execution frame in a
    manner similar to the following:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backtrace, bt`: 这将以类似于以下方式追踪到当前执行帧的步骤：'
- en: '[PRE29]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`setBreakpoint(), sb()`: This sets a breakpoint on the current line'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setBreakpoint(), sb()`: 这将在当前行设置一个断点'
- en: '`setBreakpoint(Integer), sb(Integer)`: This sets a breakpoint on the specified
    line'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setBreakpoint(Integer), sb(Integer)`: 这将在指定的行设置一个断点'
- en: '`clearBreakpoint(), cb()`: This clears a breakpoint on the current line'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearBreakpoint(), cb()`: 这将在当前行清除一个断点'
- en: '`clearBreakpoint(Integer), cb(Integer)`: This clears a breakpoint on the specified
    line'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearBreakpoint(Integer), cb(Integer)`: 这将在指定的行清除一个断点'
- en: '`run`: If the debugger''s script has terminated, this will start it again'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 如果调试器的脚本已终止，这将再次启动它'
- en: '`restart`: This terminates and restarts the script'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`: 这将终止并重新启动脚本'
- en: '`pause, p`: This pauses the running code'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause, p`: 这将暂停正在运行的代码'
- en: '`kill`: This kills the running script'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`: 这将终止正在运行的脚本'
- en: '`quit`: This exits the debugger'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quit`: 这将退出调试器'
- en: '`version`: This displays the V8 version'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 这将显示 V8 版本'
- en: '`scripts`: This lists all loaded scripts'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`: 这将列出所有已加载的脚本'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To repeat the last debugger command, simply hit *Enter* on your keyboard.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要重复最后的调试器命令，只需在键盘上按 *Enter* 键。
- en: 'Returning to the script we are debugging, entering `cont` in the debugger results
    in the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们正在调试的脚本，在调试器中输入 `cont` 将产生以下输出：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how `"hello"` was not printed when we started the debugger even though
    you would expect the `console.log('hello')` command to execute prior to the breakpoint
    being reached in the `setTimeout` callback. The debugger does not execute at runtime;
    it is evaluating at compile time *as well as at run time*, giving you deep visibility
    into how the bytecode for your program is being assembled and, eventually, will
    be executed, not simply a postcompilation printout, which `console.log` gives.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们开始调试器时，尽管你可能会期望在 `setTimeout` 回调中的断点被达到之前执行 `console.log('hello')` 命令，但
    `"hello"` 并没有被打印出来。调试器在运行时不会执行；它在编译时以及运行时进行评估，让你深入了解你的程序的字节码是如何被组装的，最终将如何执行，而不仅仅是编译后的打印输出，这是
    `console.log` 提供的。
- en: 'It is normally useful at a breakpoint to do some inspection, such as of the
    value of variables. There is an additional command available to the debugger,
    `repl`, which enables this. Currently, our debugger has stopped after having successfully
    parsed the script and executed `console.log(''hello'')`, the first function pushed
    into the event loop. What if we wanted to check the value of `myVar`? Use `repl`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在断点处进行一些检查是有用的，例如检查变量的值。调试器还有一个额外的命令 `repl`，它允许这样做。目前，我们的调试器在成功解析脚本并执行 `console.log('hello')`，即第一个推入事件循环的函数后停止。如果我们想检查
    `myVar` 的值呢？使用 `repl`：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Play around with REPL here, experimenting with how it might be used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里尝试使用 REPL，实验它可能的使用方式。
- en: 'At this point, our program has a single remaining instruction to execute—printing
    `"world"`. An immediate `cont` command will execute this last command, the event
    loop will have nothing further to do, and our script will terminate:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的程序只剩下一个要执行的指令——打印 `"world"`。立即的 `cont` 命令将执行这个最后的命令，事件循环将没有其他事情要做，我们的脚本将终止：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As an experiment, `run` the script again, using `next` instead of `cont` just
    before the execution of this final context. Keep hitting *Enter* and try to follow
    the code that is being executed. You will see that, after `"world"` is printed,
    the `timers.js` script will be introduced into this execution context as Node
    cleans up after firing a timeout. Run the `scripts` command in the debugger at
    this point. You will see something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，再次 `run` 脚本，在执行这个最终上下文之前使用 `next` 而不是 `cont`。继续按 *Enter* 并尝试跟随正在执行的代码。你将看到，在打印
    `"world"` 之后，`timers.js` 脚本将被引入这个执行上下文，因为 Node 在触发超时后进行清理。在这个时候在调试器中运行 `scripts`
    命令。你将看到类似以下的内容：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It will be useful to experiment with various methods, learning about what happens
    when Node executes scripts at a deep level as well as about Node helping with
    your debugging needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实验各种方法将是有用的，了解 Node 在深层执行脚本时会发生什么，以及 Node 如何帮助满足你的调试需求。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It can be useful to read the following document, describing how the Google
    Chrome debugger interface is used: [https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints](https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下文档可能会有所帮助，该文档描述了如何使用 Google Chrome 调试器接口：[https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints](https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints)。
- en: Miroslav Bajtos's **node-inspector** module is strongly recommended for debugging,
    allowing a developer to remotely debug a Node application from the Chrome browser.
    You can find more information on this at [https://github.com/node-inspector/node-inspector](https://github.com/node-inspector/node-inspector).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈推荐使用 Miroslav Bajtos 的 **node-inspector** 模块进行调试，它允许开发者从 Chrome 浏览器远程调试 Node
    应用程序。您可以在[https://github.com/node-inspector/node-inspector](https://github.com/node-inspector/node-inspector)上找到更多相关信息。
- en: The 'assert' module
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '''assert'' 模块'
- en: 'Node''s assert module is used for simple unit testing. In many cases, it suffices
    as a basic scaffolding for tests or is used as the assertion library for testing
    frameworks (such as Mocha, as we''ll see later). Its usage is straightforward;
    we want to assert the truth of something and throw an error if our assertion is
    not true. For example, use the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 assert 模块用于简单的单元测试。在许多情况下，它足以作为测试的基本脚手架，或者用作测试框架（如我们稍后将看到的 Mocha）的断言库。其用法简单；我们想要断言某事的真实性，如果我们的断言不正确，则抛出错误。例如，使用以下命令：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the assertion was `true` (both values are equal), nothing would be returned:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言为 `true`（两个值相等），则不会返回任何内容：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Following the UNIX Rule of Silence, *when a program has nothing surprising,
    interesting, or useful to say, it should say nothing*, assertions only return
    a value when the assertion fails. The value returned can be customized by using
    an optional message argument, as seen in the preceding code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 UNIX 的沉默规则，*当程序没有令人惊讶、有趣或有用的内容要说时，它应该保持沉默*，断言仅在断言失败时返回值。返回的值可以通过使用可选的消息参数进行自定义，如前述代码所示。
- en: The `assert` module API is composed of a set of comparison operations with identical
    call signatures—the actual value, the expected value, and an optional message
    to display when comparison fails. Alternate methods functioning as shortcuts or
    handlers for special cases are also provided.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块 API 由一组具有相同调用签名的比较操作组成——实际值、预期值以及当比较失败时显示的可选消息。还提供了作为快捷方式或特殊情况的处理器的方法。'
- en: 'A distinction must be made between **identity comparison (===)** and **equality
    comparison (==)**; the former is often referred to as *strict equality comparison*
    (as is the case of the `assert` API). Because JavaScript employs dynamic typing,
    when two values of different types are compared using the equality operator ==,
    an attempt is made to coerce (or cast) one value into the other—a sort of *common
    denominator* operation. For example, use the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 必须区分 **身份比较（===）** 和 **相等比较（==）**；前者通常被称为*严格相等比较*（如 `assert` API 的情况）。由于 JavaScript
    使用动态类型，当使用等号操作符 == 比较不同类型的两个值时，会尝试将一个值强制转换为另一个值——这是一种*通分*操作。例如，使用以下代码：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you might expect, these sorts of comparisons can lead to surprising results.
    Notice the more predictable results when identity comparison is used:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，这类比较可能会导致令人惊讶的结果。注意当使用身份比较时，结果更加可预测：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The thing to remember is that the === operator *does not perform type coercion*
    prior to the comparison, while the equality operator compares *after type coercion*.
    Additionally, because objects in JavaScript are passed by reference, the identity
    of two objects with the same values is distinct—for objects, identity requires
    that both operands *refer to the same object*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，=== 操作符在比较之前不执行类型强制转换，而等号操作符在类型强制转换之后进行比较。此外，由于 JavaScript 中的对象是通过引用传递的，因此具有相同值的两个对象的身份是不同的——对于对象来说，身份要求两个操作数都*引用同一个对象*：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the concept of *deep equality* is used for object comparisons where
    identity need not be exact. Two objects are deeply equal if they both posses the
    same number of owned properties, the same prototype, the same set of keys (though
    not necessarily in the same order), and equivalent (not identical) values for
    each of their properties:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于不需要精确身份的对象比较，使用了 *深度相等* 的概念。如果两个对象都具有相同数量的自有属性、相同的原型、相同的键集（尽管不一定按相同的顺序），并且每个属性的值都等效（但不相同），则这两个对象是深度相等的：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is useful to test your assumptions about how values are understood in comparison
    to each other by designing assertion tests. The results may surprise you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计断言测试来测试你对值之间相互理解的假设是有用的。结果可能会让你感到惊讶。
- en: 'The following rounds out the assertions you can make using this module:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对使用此模块可以进行的断言的总结：
- en: '`assert.equal(actual, expected, [message])`: This is used to test coerced equality
    with ==.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.equal(actual, expected, [message])`: 这用于测试使用 == 进行强制相等性。'
- en: '`assert.notEqual(actual, expected, [message])`: This is used to test coerced
    equality with !=.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notEqual(actual, expected, [message])`: 这用于测试使用 != 进行强制相等性。'
- en: '`assert.deepEqual(actual, expected, [message])`: This is used to test for deep
    equality.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.deepEqual(actual, expected, [message])`: 这用于测试深度相等性。'
- en: '`assert.notDeepEqual(actual, expected, [message])`: This is used to test for
    deep inequality.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notDeepEqual(actual, expected, [message])`: 这用于测试深度不等性。'
- en: '`assert.strictEqual(actual, expected, [message])`: This is used to test identity
    equivalence ===.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.strictEqual(actual, expected, [message])`: 这用于测试身份等价 ===。'
- en: '`assert.notStrictEqual(actual, expected, [message])`: This is used to test
    for identity mismatch !==.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notStrictEqual(actual, expected, [message])`: 这用于测试身份不匹配 !==。'
- en: '`assert(value, [message])`: This throws an error if the sent value is not truthy.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert(value, [message])`: 如果发送的值不是真实的，则抛出错误。'
- en: '`assert.ok(value, [message])`: This is identical to `assert(value)`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.ok(value, [message])`: 这与 `assert(value)` 相同。'
- en: '`assert.ifError(value)`: This throws an error if the value is truthy.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.ifError(value)`: 如果值是真实的，则抛出错误。'
- en: '`assert.throws(block, [error], [message])`: This is used to test whether or
    not the supplied code block throws. The optional error value can be an error constructor,
    regular expression, or a validation function returning a Boolean value.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.throws(block, [error], [message])`: 这用于测试提供的代码块是否抛出错误。可选的错误值可以是错误构造函数、正则表达式或返回布尔值的验证函数。'
- en: '`assert.doesNotThrow(block, [error], [message])`: This is used to test whether
    the supplied code block does not throw an error.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.doesNotThrow(block, [error], [message])`: 这用于测试提供的代码块是否没有抛出错误。'
- en: '`assert.fail(actual, expected, message, operator)`: This throws an exception.
    This is most useful when the exception is trapped by a try/catch block.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.fail(actual, expected, message, operator)`: 这会抛出异常。这在异常被 try/catch
    块捕获时最有用。'
- en: 'A shortcut method to log assertion results is available in the `console` API:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `console` API 中有一个快捷方法来记录断言结果：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed explanation of how comparison is done in JavaScript, consult
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如何在 JavaScript 中进行比较的更详细解释，请参阅 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)。
- en: Now, let's look at testing with more advanced testing frameworks and tools.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用更高级的测试框架和工具进行测试。
- en: Testing with Mocha, Chai, Sinon, and npm
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha、Chai、Sinon 和 npm 进行测试
- en: One of the great benefits of writing tests for your code is that you will be
    forced to think through how what you've written works. A test that is difficult
    to write might indicate code that is difficult to understand. On the other hand,
    comprehensive coverage with good tests helps others (and you) understand how an
    application works.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的代码编写测试的一个巨大好处是，你将被迫思考你所写的内容是如何工作的。难以编写的测试可能表明代码难以理解。另一方面，全面的测试覆盖和良好的测试有助于他人（和你）理解应用程序的工作方式。
- en: There are at least three notions to consider when setting up your test environment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置测试环境时，至少有三个概念需要考虑。
- en: The purpose of testing is to make comparisons between the value of what is received
    and what is expected by your application code. As we saw earlier, Node's `assert`
    module is designed for this purpose, but its functionality is limited to individual,
    isolated assertions. We'll use the Chai library ([http://chaijs.com](http://chaijs.com)),
    which provides you with a richer choice of languages and idioms to make assertions
    with.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目的是比较接收到的值和应用程序代码期望的值。如我们之前所见，Node 的 `assert` 模块是为了这个目的而设计的，但它的功能仅限于单个、孤立的断言。我们将使用
    Chai 库 ([http://chaijs.com](http://chaijs.com))，它为你提供了更丰富的语言和成语来做出断言。
- en: It is not unusual for an application to be covered by several hundred tests.
    When assertions are grouped, say by feature or business unit, these groups can
    provide a clearer picture of your application's state. Designing and instrumenting
    tools to do this grouping, especially with asynchronous code, is difficult. Thankfully,
    several well-known, well-designed test runners exist for you to use. We'll use
    Mocha ([http://mochajs.org](http://mochajs.org)), which makes it easier to organize,
    control, and display the results of your tests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序被数百个测试覆盖并不罕见。当断言被分组，例如按功能或业务单元分组时，这些组可以为你提供关于应用程序状态的更清晰图景。设计和实施工具来进行这种分组，尤其是在异步代码中，是困难的。幸运的是，存在几个知名且设计良好的测试运行器供你使用。我们将使用
    Mocha ([http://mochajs.org](http://mochajs.org))，它使得组织、控制和显示测试结果变得更加容易。
- en: Testing is normally done on development boxes and not in live production environments.
    How can you write tests for code that does not run in a real environment? For
    example, how do I test my code's ability to handle responses from a network endpoint
    that I cannot connect to locally? How do I check the arguments a function is being
    sent without rewriting the function? We'll use Sinon ([http://sinonjs.org/](http://sinonjs.org/)),
    which lets you create synthetic methods and other simulations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常在开发环境中进行，而不是在实时生产环境中。你如何为不在真实环境中运行的代码编写测试？例如，我如何测试我的代码处理无法本地连接的网络端点的响应的能力？我如何检查函数被发送的参数，而无需重写该函数？我们将使用
    Sinon ([http://sinonjs.org/](http://sinonjs.org/))，它允许你创建合成方法和其他模拟。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other popular test runners are Jasmine ([https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine))
    and Vows ([https://github.com/vowsjs/vows](https://github.com/vowsjs/vows)). Should
    ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    is a popular assertion library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的测试运行器包括 Jasmine ([https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine))
    和 Vows ([https://github.com/vowsjs/vows](https://github.com/vowsjs/vows))。Should
    ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    是一个流行的断言库。
- en: 'To start with, set up a folder containing the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一个包含以下结构的文件夹：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `/scripts` folder contains the JavaScript we'll test. The `/spec` folder
    contains configuration and test files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`/scripts` 文件夹包含我们将要测试的 JavaScript 代码。`/spec` 文件夹包含配置和测试文件。'
- en: 'Now, initialize a `package.json` file with `npm init`. You can just hit *Enter*
    at the prompts, but when you are asked for a test command, enter the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `npm init` 初始化一个 `package.json` 文件。你可以在提示时直接按 *Enter*，但当你被要求输入测试命令时，请输入以下内容：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will make more sense as we move forward. For now, recognize that this assignation
    to npm's `test` attribute asserts that we will use Mocha for testing. Mocha's
    test report will be of the `spec` type and that test will exist in the `/spec`
    directory. We will also require a configuration file for Chai, which will be explained
    in one of the following sections. Importantly, this has now created a script declaration
    in npm that will allow you to run your test suite with the `npm test` command.
    Use that command whenever you need to run the Mocha tests we'll be developing
    in the following section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，这会更有意义。现在，认识到这个分配给 npm 的 `test` 属性断言我们将使用 Mocha 进行测试。Mocha 的测试报告将是
    `spec` 类型，并且该测试将存在于 `/spec` 目录中。我们还将需要一个 Chai 的配置文件，这将在接下来的某个部分中解释。重要的是，这已经在 npm
    中创建了一个脚本声明，允许你使用 `npm test` 命令运行你的测试套件。在接下来的部分中，你需要运行 Mocha 测试时，请使用该命令。
- en: If you haven't already, install Mocha globally with `npm install mocha -g`.
    Also, install the local modules that we'll need for testing using the `npm install
    mocha chai sinon redis --save-dev` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装，请使用 `npm install mocha -g` 全局安装 Mocha。同时，使用 `npm install mocha chai
    sinon redis --save-dev` 命令安装我们需要的本地测试模块。
- en: Mocha
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha
- en: 'Mocha is a test runner that does not concern itself with test assertions themselves.
    Mocha is used to organize and run your tests, primarily through the use of the
    `describe` and `it`. operators. The following code shows this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个不关心测试断言本身的测试运行器。Mocha 用于组织和运行你的测试，主要通过使用 `describe` 和 `it` 操作符。以下代码展示了这一点：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As illustrated, the Mocha harness leaves open how the tests are described and
    organized and makes no assumptions about how test assertions are designed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Mocha 测试框架留出了测试的描述和组织方式，并且不对测试断言的设计做出任何假设。
- en: 'You can set up tests that run synchronously, as described in the preceding
    code, or asynchronously, using the completion handler passed to all `it` callbacks:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置同步运行的测试，如前述代码所述，或者使用传递给所有 `it` 回调的完成处理程序异步运行：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Blocks can also be nested:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 块也可以嵌套：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, Mocha offers *hooks* that enable you to run code before and/or after
    tests:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Mocha 提供 *hooks*，允许你在测试前后运行代码：
- en: '`beforeEach()` runs before each test in a `describe` block'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()` 在 `describe` 块中的每个测试之前运行'
- en: '`afterEach()` runs after each test in a `describe` block'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()` 在 `describe` 块中的每个测试之后运行'
- en: '`before()` runs code once prior to any test—prior to any run of `beforeEach`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before()` 在任何测试之前运行代码——在 `beforeEach` 任何运行之前'
- en: '`after()` runs code once after all tests have run—after any run of `afterEach`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after()` 在所有测试运行之后运行代码——在 `afterEach` 任何运行之后'
- en: Usually, these are used to set up test contexts, such as creating variables
    before certain tests and cleaning those up prior to certain other tests.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些用于设置测试上下文，例如在特定测试之前创建变量，并在某些其他测试之前清理这些变量。
- en: This simple collection of tools is expressive enough to handle most testing
    needs. Additionally, Mocha provides various test reporters that offer differently
    formatted results. We'll see those in action later as we build realistic test
    scenarios.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的工具集合足以处理大多数测试需求。此外，Mocha 提供了各种测试报告器，提供不同格式的结果。当我们构建实际的测试场景时，我们将在后面看到这些报告器的实际应用。
- en: Chai
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chai
- en: 'As we saw earlier with Node''s native `assert` module, at its base, testing
    involves asserting what we expect a chunk of code to do, executing that code,
    and checking whether our expectations were met. Chai is an assertion library with
    a more expressive syntax, offering three assertion styles: **expect**, **should**,
    and **assert**. We will use Chai to provide the assertions (tests) to be wrapped
    within Mocha `it` statements, favoring the *expect* style of assertion.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在 Node 的原生 `assert` 模块中看到的，在基础层面，测试涉及断言我们期望代码块执行的操作，执行该代码，并检查我们的期望是否得到满足。Chai
    是一个具有更丰富语法的断言库，提供三种断言风格：**expect**、**should** 和 **assert**。我们将使用 Chai 为 Mocha
    `it` 语句提供断言（测试），优先使用 *expect* 断言风格。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while `Chai.assert` is modeled after the core Node `assert` syntax,
    Chai augments the object with additional methods.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 `Chai.assert` 是基于核心 Node `assert` 语法构建的，但 Chai 通过添加额外的方法增强了该对象。
- en: 'To begin with, we are going to create a configuration file called `chai.js`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为 `chai.js` 的配置文件：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Place this file in the `/spec/helpers` folder. This will tell Chai to display
    the full-stack trace of any errors and to expose the `expect` assertion style
    as a `global` variable. Similarly, Sinon is also exposed as a `global` variable.
    This file will augment the Mocha test run context such that we can use these tools
    without having to redeclare them in each test file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件放在 `/spec/helpers` 文件夹中。这将告诉 Chai 显示任何错误的完整堆栈跟踪，并将 `expect` 断言风格作为 `global`
    变量暴露。同样，Sinon 也作为 `global` 变量暴露。此文件将增强 Mocha 测试运行上下文，这样我们就可以使用这些工具而无需在每个测试文件中重新声明它们。
- en: 'The `expect` style of assertion reads like a sentence, with *sentences* composed
    from words like *to*, *be*, *is*, and more. Take the following code as an example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 风格的断言读起来像一句话，由像 *to*, *be*, *is* 这样的单词组成的 *句子*。以下代码作为例子：'
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To explore the extensive list of *words* available when you are creating `expect`
    test chains, consult the full documentation at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索创建 `expect` 测试链时可用的大量 *单词*，请参阅完整的文档[http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)。
- en: As stated earlier, Mocha does not have an opinion on how you create assertions.
    We will use `expect` to create assertions in the tests that follow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Mocha 对你如何创建断言没有意见。我们将使用 `expect` 在接下来的测试中创建断言。
- en: 'Consider testing the `capitalize` function in the following object:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑测试以下对象中的 `capitalize` 函数：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We might do something like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会做类似这样的事情：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This Chai assertion will be `true` and Mocha will report the same results.
    This is shown in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Chai 断言将是 `true`，Mocha 将报告相同的结果。这在上面的屏幕截图中有显示：
- en: '![Chai](img/1403OS_06_05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Chai](img/1403OS_06_05.jpg)'
- en: Next, we'll look at how to add Sinon to our test process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何将 Sinon 添加到我们的测试过程中。
- en: Sinon
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sinon
- en: Within a testing environment, you typically emulate the realities of a production
    environment as access to real users, data, or other live systems is unsafe or
    otherwise undesirable. Being able to simulate environments is, therefore, an important
    part of testing. Also, you will often want to inspect more than just call results—you
    might want to test whether a given function is being called in the right context
    or with the right examples. Sinon is a tool that helps you to simulate external
    services, emulate functions, track function calls, and so on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，你通常会模拟生产环境的现实情况，因为访问真实用户、数据或其他实时系统是不安全或不可取的。因此，能够模拟环境是测试的重要部分。此外，你通常会想检查的不仅仅是调用结果——你可能想测试某个函数是否在正确的上下文中被调用，或者是否使用了正确的示例。Sinon是一个帮助你模拟外部服务、模拟函数、跟踪函数调用等的工具。
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `sinon-chai` module extends Chai with Sinon assertions. For more information
    on `sinon-chai`, visit [https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon-chai`模块扩展了Chai，增加了Sinon断言。有关`sinon-chai`的更多信息，请访问[https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai)。'
- en: The key Sinon technologies are **spies**, **stubs**, and **mocks**. Additionally,
    you can set fake timers, create fake servers, and more (see [http://sinonjs.org/](http://sinonjs.org/)).
    This section focuses on the first three. Let's go over examples of each.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的Sinon技术是**间谍**、**存根**和**模拟**。此外，你可以设置假的计时器，创建假的服务器等（见[http://sinonjs.org/](http://sinonjs.org/)）。本节重点介绍前三者。让我们逐一介绍每个的示例。
- en: Spies
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间谍
- en: 'Take a look at this text from the Sinon documentation that defines a test spy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下来自Sinon文档的文本，它定义了一个测试间谍：
- en: '*"A test spy is a function that records arguments, return value, the value
    of this and exception thrown (if any) for all its calls. A test spy can be an
    anonymous function or it can wrap an existing function."*'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"测试间谍是一个记录所有调用参数、返回值、`this`的值以及抛出的异常（如果有）的函数。测试间谍可以是一个匿名函数，或者它可以包装一个现有的函数。"*'
- en: 'A spy gathers information on the function it is tracking. For example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍收集它跟踪的函数的信息。例如：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will log the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录以下内容：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The spy was called twice, once with `foo`, once with `bar`, and never with `baz`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍被调用了两次，一次是使用`foo`，一次是使用`bar`，从未使用`baz`。
- en: 'Let''s suppose we wanted to test whether our code properly connects to the
    pub/sub functionality of Redis:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想测试我们的代码是否正确连接到Redis的pub/sub功能：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we do more with spy and with Mocha. We deploy spy to proxy
    the native `subscribe` method of `client1`, importantly setting up and tearing
    down the spy proxy (restoring original functionality) within Mocha's `before`
    and `after` methods. The Chai assertions prove that both `subscribe` and `nowPublish`
    are functioning correctly and receiving the right arguments.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用间谍和Mocha做了更多的事情。我们将间谍部署为代理`client1`的本地`subscribe`方法，重要的是在Mocha的`before`和`after`方法中设置和拆除间谍代理（恢复原始功能）。Chai断言证明了`subscribe`和`nowPublish`都正常工作，并接收了正确的参数。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on spies can be found at [http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于间谍的信息可以在[http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies)找到。
- en: Stubs
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存根
- en: 'A stub, when used as a spy, can be wrapped around an existing function such
    that it can fake the behavior of that function (rather than simply recording function
    execution as we saw earlier). Take a look at this definition of test stubs taken
    from the Sinon documentation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当用作间谍时，存根可以围绕现有函数包装，以便它可以模拟该函数的行为（而不仅仅是像我们之前看到的那样记录函数执行）。查看以下来自Sinon文档的测试存根定义：
- en: '*"Test stubs are functions (spies) with pre-programmed behavior. They support
    the full test spy API in addition to methods which can be used to alter the stub''s
    behavior."*'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"测试存根是具有预编程行为的函数（间谍）。它们支持完整的测试间谍API，以及可以用来改变存根行为的其他方法。"*'
- en: 'Let''s assume that you have a functionality in your application that makes
    calls to an HTTP endpoint. The code may be something like the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序中有一个功能，它调用HTTP端点。代码可能如下所示：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When it''s successful, the call will log `Got status: 200`. Should the endpoint
    be unavailable, you''ll see something like `Got error: getaddrinfo ENOTFOUND`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '当调用成功时，将记录`Got status: 200`。如果端点不可用，你将看到类似`Got error: getaddrinfo ENOTFOUND`的内容。'
- en: It is likely that you will need to test the ability of your application to handle
    alternate status codes, and, of course, explicit errors. It may not be in your
    power to force endpoints to emit these, yet you must prepare for them should they
    occur. Stubs are useful here to create synthetic responses such that your response
    handlers can be comprehensively tested.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你需要测试你的应用程序处理替代状态码的能力，当然，还有显式错误。你可能无法强制端点发出这些错误，但如果你遇到这些错误，你必须做好准备。在这里，存根很有用，可以创建合成响应，以便可以全面测试响应处理程序。
- en: 'We can use stubs to emulate a response without actually calling the `http.get`
    method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用存根来模拟响应，而不实际调用`http.get`方法：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This stub yields a simulated response by wrapping the original method, which
    is never called, resulting in a `404` error being returned from a call that would
    normally return a status code of `200`. Importantly, note how we `restore` the
    stubbed method to its original state when we are done with it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根通过包装原始方法（该方法从未被调用）来产生模拟响应，导致从通常返回状态码200的调用返回`404`错误。重要的是要注意，我们在完成时如何将存根方法恢复到其原始状态。
- en: 'For example, the following *pseudo* code describes a module that makes HTTP
    calls, parses the response, and responds with `''handled''` if everything went
    OK and `''not handled''` if the HTTP response was unexpected:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下*伪代码*描述了一个模块，该模块执行HTTP调用，解析响应，并在一切顺利时响应`'handled'`，如果HTTP响应意外，则响应`'not
    handled'`：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following Mocha test ensures that the `Caller.parseReponse` method can
    handle all response codes we need handled using stubs to simulate the entire expected
    response range:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Mocha测试确保`Caller.parseReponse`方法可以使用存根模拟整个预期的响应范围来处理我们需要的所有响应代码：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By proxying the original `makeCall` method, we can test `parseResponse` against
    a range of status codes without the difficulty of forcing remote network behavior.
    Noting that the preceding test should fail (there is no handler for 403 codes),
    the output of this test should look something like the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代理原始的`makeCall`方法，我们可以测试`parseResponse`对一系列状态码的响应，而无需强制远程网络行为。注意，前面的测试应该失败（没有处理403代码的处理程序），这个测试的输出应该类似于以下内容：
- en: '![Stubs](img/1403OS_06_03.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![存根](img/1403OS_06_03.jpg)'
- en: The full API for stubs can be seen at [http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 存根的完整API可以在[http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs)中看到。
- en: Mocks
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Rather than checking expectations *after the fact*, mocks can be used to check
    whether the unit under test is being used correctly—they enforce implementation
    details. Take a look at this definition of mocks taken from the Sinon documentation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与在事后检查期望不同，模拟可以用来检查被测试的单元是否被正确使用——它们强制实施实现细节。看看以下从Sinon文档中摘取的模拟定义：
- en: '*"Mocks (and mock expectations) are fake methods (like spies) with pre-programmed
    behavior (like stubs) as well as pre-programmed expectations. A mock will fail
    your test if it is not used as expected."*'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"模拟（以及模拟期望）是具有预编程行为（如存根）的假方法（如间谍），以及预编程的期望。如果模拟没有被按预期使用，它将使你的测试失败。"*'
- en: 'In the following example, we check not only the number of times a specific
    function is called (easy with spies) but also whether it is called with specific,
    expected arguments. Specifically, we again test the `capitalize` method of `Utils`,
    this time using mocks:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们不仅检查一个特定函数被调用的次数（通过间谍很容易做到），还检查它是否以特定的、预期的参数被调用。具体来说，我们再次测试`Utils`的`capitalize`方法，这次使用模拟：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After setting up a mock on `utils`, we map a five-element array to `capitalize`,
    expecting `capitalize` to be called exactly five times, with the array's elements
    as arguments (using `apply` to spread the array into individual arguments). The
    well-named `mock.verify` function is then checked to see whether our expectations
    were satisfied. As usual, when we are done with it, we unwrap the `utils` object
    with `mock.restore`. You should see `true` logged to your terminal.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`上设置模拟后，我们将一个包含五个元素的数组映射到`capitalize`，期望`capitalize`被精确地调用五次，数组元素作为参数（使用`apply`将数组展开为单独的参数）。然后检查命名良好的`mock.verify`函数，看我们的期望是否得到满足。像往常一样，当我们完成时，我们使用`mock.restore`解包`utils`对象。你应该在你的终端看到`true`被记录。
- en: 'Now, remove one element from the tested array, frustrating expectations. When
    you run the test again, you should see the following near the top of the output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从测试的数组中移除一个元素，使期望变得令人沮丧。当你再次运行测试时，你应该在输出顶部附近看到以下内容：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This should clarify the type of test results that mocks are designed to produce.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以阐明模拟旨在产生的测试结果类型。
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that mocked functions do not execute—`mock` overrides its target. In the
    preceding example, no array members are ever run through `capitalize`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到模拟函数不会执行——`mock` 会覆盖其目标。在上一个例子中，没有任何数组成员会通过 `capitalize` 执行。
- en: 'Let''s revisit our earlier example, this time testing Redis pub/sub using mocks:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前的例子，这次我们将使用模拟来测试 Redis pub/sub：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Rather than checking for conclusions, here we assert our expectation that the
    mocked `subscribe` method will receive the exact argument `channel` only `once`.
    Mocha expects `mock.verify` to return `true`. To make this test fail, add one
    more `client.subscribe(''channel'')` line, producing something like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是检查结论，这里我们断言模拟的 `subscribe` 方法将只接收精确的参数 `channel` 一次。Mocha 期望 `mock.verify`
    返回 `true`。为了使这个测试失败，添加一行更多的 `client.subscribe('channel')`，产生如下所示的内容：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on how to use mocks can be found at [http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用模拟的更多信息可以在 [http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks)
    找到。
- en: Automated browser testing with PhantomJS and CasperJS
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 和 CasperJS 进行自动化浏览器测试
- en: One way to test whether a UI is working is to pay several people to interact
    with a website via a browser and report any errors they find. This can become
    a very expensive and ultimately unreliable process. Also, it requires putting
    potentially failing code into production in order to test it. It is better to
    test whether application views are rendering correctly from within the build process
    itself prior to releasing any views "into the wild". PhantomJS was created to
    address this need, among others.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 UI 是否正常工作的一种方法是为几个人支付费用，让他们通过浏览器与网站交互并报告他们发现的任何错误。这可以成为一个非常昂贵且最终不可靠的过程。此外，它还需要将可能失败的业务代码投入生产以进行测试。在发布任何视图之前，最好在构建过程中本身测试应用程序视图是否正确渲染。PhantomJS
    就是为此需求而创建的，以及其他需求。
- en: A browser, stripped of its buttons and other controls, is, at its heart, a program
    that validates and runs JavaScript, HTML, and CSS. That the validated HTML is
    rendered visually on your screen is simply a consequence of humans being able
    to see only with their eyes. A server can interpret the logic of compiled code
    and see the results of interactions with that code without a visual component.
    Perhaps because eyes are usually found in one's head, a browser running on a server
    is typically referred to as a headless browser. PhantomJS provides a headless
    version of the WebKit engine that is scriptable via a JavaScript API.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 去掉了按钮和其他控制按钮的浏览器，本质上是一个验证和运行 JavaScript、HTML 和 CSS 的程序。验证的 HTML 在你的屏幕上以视觉形式呈现，这只是人类只能用眼睛看到的结果。服务器可以解释编译代码的逻辑并看到与该代码交互的结果，而不需要视觉组件。也许因为眼睛通常在人的头部，运行在服务器上的浏览器通常被称为无头浏览器。PhantomJS
    提供了一个可由 JavaScript API 脚本化的 WebKit 引擎的无头版本。
- en: Headless testing with PhantomJS
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 进行无头测试
- en: PhantomJS ([http://phantomjs.org/build.html](http://phantomjs.org/build.html))
    allows you to create scripts that can be executed in a headless browser context.
    It allows you to capture a browser context within a scriptable environment, enabling
    various operations, such as loading an HTML page into that context. This allows
    you to perform operations on that browser context, such as manipulating the DOM
    of a loaded page.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS ([http://phantomjs.org/build.html](http://phantomjs.org/build.html))
    允许你创建可以在无头浏览器上下文中执行的脚本。它允许你在可脚本化的环境中捕获浏览器上下文，从而实现各种操作，例如将 HTML 页面加载到该上下文中。这允许你在该浏览器上下文中执行操作，例如操作已加载页面的
    DOM。
- en: 'For example, fetching a Twitter user''s recent tweets can be accomplished by
    hitting the following endpoint in your browser: `http://mobile.twitter.com/<twitter
    user>`. We can also use PhantomJS to do the same thing within a headless, scriptable
    environment and then write code to fetch those tweets. Create a `phantom-twitter.js`
    file containing the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过在浏览器中访问以下端点来获取 Twitter 用户的最新推文：`http://mobile.twitter.com/<twitter user>`。我们也可以使用
    PhantomJS 在无头、可脚本化的环境中做同样的事情，然后编写代码来获取这些推文。创建一个包含以下代码的 `phantom-twitter.js` 文件：
- en: '[PRE61]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, use the CLI to pass that script to PhantomJS, sending the Twitter handle
    of the person you''d like to read as an argument:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 CLI 将该脚本传递给 PhantomJS，发送你想要阅读的人的 Twitter 处理符作为参数：
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A new file called `kanyewest.json` will be created, containing recent tweets
    in the JSON format. Let's examine the code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个名为 `kanyewest.json` 的新文件，其中包含最近的推文，格式为 JSON。让我们来看看代码。
- en: We first require some of PhantomJS's core modules, importantly the `page` library
    that allows us to load pages, and the `system` and `fs` modules (which resemble
    Node's `process` and `fs` modules, respectively). We'll use `system` to fetch
    command-line arguments and `fs` to write fetched tweets to the filesystem.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要引入一些 PhantomJS 的核心模块，重要的是 `page` 库，它允许我们加载页面，以及 `system` 和 `fs` 模块（分别类似于
    Node 的 `process` 和 `fs` 模块）。我们将使用 `system` 来获取命令行参数，并使用 `fs` 将获取的推文写入文件系统。
- en: The `page.open` command does what you would expect—loading a web page into the
    PhantomJS context. We can now perform operations on the rendered DOM. In this
    case, we are going to use `evaluate` on JavaScript within the context of that
    page, fetching the elements containing tweets identified by the `div.tweet-text`
    CSS selector and stripping out `innerText`. Because `evaluate` is running in the
    context of a headless WebKit, there is no way for us to access the outer PhantomJS
    scope, so we simply return what we find within the evaluation scope to the outer
    scope, where a file can be generated using `fs`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`page.open` 命令执行了你预期的操作——将网页加载到 PhantomJS 上下文中。我们现在可以对渲染的 DOM 执行操作。在这种情况下，我们将在该页面的
    JavaScript 上下文中使用 `evaluate`，获取由 `div.tweet-text` CSS 选择器标识的包含推文的元素，并移除 `innerText`。因为
    `evaluate` 在无头 WebKit 的上下文中运行，我们无法访问外部的 PhantomJS 作用域，所以我们只需将评估作用域内找到的内容返回到外部作用域，在那里可以使用
    `fs` 生成文件。'
- en: PhantomJS offers an extensive API to interact with WebKit ([http://phantomjs.org/api/](http://phantomjs.org/api/)),
    allowing script injection, creating screen captures, navigating rendered pages,
    and so on. A whole range of client tests can be created using these tools.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS 提供了一个广泛的 API 来与 WebKit 交互([http://phantomjs.org/api/](http://phantomjs.org/api/))，允许脚本注入、创建屏幕截图、导航渲染页面等。可以使用这些工具创建一系列客户端测试。
- en: 'When writing server tests, you will probably not want to use PhantomJS from
    the CLI. For this reason, various Node-PhantomJS bridges have been written that
    let you interact with PhantomJS via a Node module. A good one is `phantomjs` ([https://github.com/sgentle/phantomjs-node](https://github.com/sgentle/phantomjs-node)).
    For example, the following will load a page, as shown earlier, and execute JavaScript
    to fetch the page''s title attribute:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写服务器测试时，你可能不想从命令行使用 PhantomJS。因此，已经编写了各种 Node-PhantomJS 桥接器，让你可以通过 Node 模块与
    PhantomJS 交互。一个好的选择是 `phantomjs` ([https://github.com/sgentle/phantomjs-node](https://github.com/sgentle/phantomjs-node))。例如，以下代码将加载一个页面，如前所述，并执行
    JavaScript 来获取页面的标题属性：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the preceding code should result in something like the following being
    logged:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码应该会记录下类似以下内容：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Navigation scenarios with CasperJS
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CasperJS 的导航场景
- en: Because PhantomJS is not specifically designed to be a test runner, others have
    created tools to simplify testing with PhantomJS. **CasperJS** ([http://casperjs.org/](http://casperjs.org/))
    is a navigation and testing utility for PhantomJS and **SlimerJS** (which uses
    the Gecko engine that powers Firefox).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PhantomJS 并非专门设计为测试运行器，其他人已经创建了工具来简化使用 PhantomJS 的测试。**CasperJS** ([http://casperjs.org/](http://casperjs.org/))
    是 PhantomJS 和 **SlimerJS**（使用 Firefox 的 Gecko 引擎）的导航和测试实用工具。
- en: 'CasperJS offers an extensive toolkit to create complex chains of interactions
    using an expressive Promises-like interface. Describing page interaction tests
    with CasperJS requires much less code and is clearer. For example, the earlier
    `phantom` example demonstrating how to fetch a page title can be simplified:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 提供了一个广泛的工具集，使用表达式的 Promises-like 接口创建复杂的交互链。使用 CasperJS 描述页面交互测试需要更少的代码，并且更清晰。例如，前面的
    `phantom` 示例演示了如何获取页面标题，可以简化如下：
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If the preceding code were saved as a file called `pagetitle.js` and run with
    the `casperjs test pagefile.js` command, you would see the following logged:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将前面的代码保存为名为 `pagetitle.js` 的文件，并使用 `casperjs test pagefile.js` 命令运行，你会看到以下记录：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A much terser syntax produces identical results. Let''s look at another example
    that demonstrates how to fetch one page, click on a link on that page, and read
    some information from the resulting page:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更简洁的语法会产生相同的结果。让我们看看另一个示例，它演示了如何获取一页内容，点击该页上的链接，并从结果页面读取一些信息：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we can see how a Promise-like chaining of interactions results in clear
    and expressive code. After fetching Google''s search page, we will evaluate a
    piece of JavaScript that inserts the `node.js` string into its famous search box
    and submit the search form. Then, CasperJS is asked to click on the first result
    link (`h3.r a`) and to finally display the current URL:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如何通过交互的Promise-like链式调用产生清晰和表达性强的代码。在获取Google的搜索页面后，我们将评估一段将`node.js`字符串插入其著名的搜索框并提交搜索表单的JavaScript代码。然后，CasperJS被要求点击第一个结果链接(`h3.r
    a`)，并最终显示当前URL：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This demonstrates that a full-page navigation has occurred, at which point we
    can chain even more interaction steps.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了发生了全页导航，此时我们可以链式调用更多的交互步骤。
- en: 'Finally, let''s use some of the CasperJS test assertions and demonstrate how
    to take snapshots of web pages while testing Google''s translation service:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用一些CasperJS测试断言并演示如何在测试Google翻译服务时捕获网页快照：
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Google's translation page is dynamic. As you type into the translation box,
    the service detects keyboard events, attempts to infer the language you are using
    based on any available text, and, in "real time", provides a translation, all
    without refreshing the page. In other words, we are not submitting a form and
    waiting for the resulting page.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Google的翻译页面是动态的。当你输入翻译框时，服务会检测键盘事件，尝试根据任何可用的文本推断你使用的语言，并在“实时”提供翻译，所有这些都不需要刷新页面。换句话说，我们不是提交表单并等待结果页面。
- en: 'Therefore, once we have the page loaded, we send keystrokes (`sendKeys`) into
    the `#source` input box with the Italian word `"Ciao"`. Testing that this results
    in the correct translation, we wait for `"Hello"` to arrive—`waitForText` fires
    when the text passed appears on a page. To ensure that the text has arrived in
    the right place, we assert that the element with the `#result_box` selector contains
    `"Hello"`. If all is well, you will see the following logged:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦页面加载完成，我们就向`#source`输入框输入意大利语单词`"Ciao"`的按键(`sendKeys`)。为了测试这会导致正确的翻译，我们等待出现`"Hello"`——当传递的文本出现在页面上时，`waitForText`会被触发。为了确保文本已到达正确的位置，我们断言具有`#result_box`选择器的元素包含`"Hello"`。如果一切顺利，你将看到以下日志：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Additionally, within the same folder, you will find the `snapshot.png` image
    visualizing the DOM-based interactions just executed:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一个文件夹中，你将找到`snapshot.png`图像，它可视化地展示了刚刚执行的基于DOM的交互：
- en: '![Navigation scenarios with CasperJS](img/1403OS_06_04.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![使用CasperJS的导航场景](img/1403OS_06_04.jpg)'
- en: Hopefully, this demonstrates how CasperJS can be used to harness the power of
    PhantomJS when you're writing client tests. If you'd like to use CasperJS as a
    Node module, give SpookyJS ([https://github.com/SpookyJS/SpookyJS](https://github.com/SpookyJS/SpookyJS))
    a try.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能展示出CasperJS如何在你编写客户端测试时利用PhantomJS的力量。如果你想将CasperJS作为Node模块使用，可以尝试SpookyJS
    ([https://github.com/SpookyJS/SpookyJS](https://github.com/SpookyJS/SpookyJS))。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a look at testing and building your application such
    that you can get a good sense of its ability to *stand up* in production. We worked
    through a representative build system that used Gulp and Browserify, along with
    some other tools, to show how a codebase can be optimized and packaged for deployment.
    Also, you learned about Node's native debugging tools and assertion library.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试和构建你的应用程序，以便你可以对其在生产环境中的能力有一个良好的认识。我们通过一个代表性的构建系统，使用Gulp和Browserify，以及一些其他工具，展示了代码库如何被优化和打包以供部署。此外，你还了解了Node的本地调试工具和断言库。
- en: The Node community has embraced testing from the beginning, and many testing
    frameworks and native tools are made available to developers. You learned how
    to set up a proper test system using Gulp, Mocha, Chai, and Sinon, in the process
    experimenting with headless browser testing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Node社区就接受了测试，并为开发者提供了许多测试框架和原生工具。你学习了如何使用Gulp、Mocha、Chai和Sinon设置一个合适的测试系统，在这个过程中，你尝试了无头浏览器测试。
- en: The next chapter will be focused on taking the builds you have tested and deploying
    them to production servers. You'll learn about setting up local development environments
    on virtual machines, provisioning remote servers, setting up continuous integration
    with webhooks and Jenkins, maintaining your application dependencies and, generally,
    keeping your applications running smoothly as changes are made.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于将您已测试的构建部署到生产服务器。您将学习如何在虚拟机上设置本地开发环境，配置远程服务器，使用webhooks和Jenkins设置持续集成，维护应用程序依赖项，以及通常情况下，在做出更改时保持应用程序平稳运行。
