- en: Understanding the Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this book, you will probably be eager to start a new project to
    put into practice everything that you have learned so far. At this point, you
    should be able to write a small web application using TypeScript and resolve the
    potential design-time issues that you might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: However, as your new project grows, and you develop more complex features, you
    might encounter some runtime issues. This chapter should provide you with the
    missing knowledge that will help you to resolve runtime issues.
  prefs: []
  type: TYPE_NORMAL
- en: We have only briefly mentioned the TypeScript runtime in the preceding chapters,
    but depending on your background, you may already know a lot about it, because
    the TypeScript runtime is the JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is only used at design time; the TypeScript code is then compiled
    into JavaScript and finally executed at runtime. The JavaScript runtime oversees
    the execution of the JavaScript code. It is important to understand that we will
    never execute TypeScript code and we will always execute JavaScript code; for
    this reason, when we refer to the TypeScript runtime, we will, in fact, be talking
    about the JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When we compile our TypeScript code, we will generate JavaScript code, which
    will be executed on the server side or the client side. It is then that we may
    encounter some challenging runtime issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by learning about the execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The execution environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The execution environment is one of the first things that we must think about
    before we can start developing a TypeScript application. Once we have compiled
    our TypeScript code into JavaScript, it can be executed in many different environments.
    While most of those environments will be part of a web browser such as Chrome,
    Internet Explorer, or Firefox, we might also want to be able to run our code on
    the server side or in a desktop application in environments such as Node.js, RingoJS,
    or Electron.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep in mind that there are some variables and objects available
    at runtime that are environment-specific. For example, we could create a library
    and access the `document.layers` variable. While `document` is part of the W3C
    **Document Object Model** (**DOM**) standard, the layers property is only available
    in Internet Explorer and is not part of the W3C DOM standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The W3C defines the DOM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Document Object Model is a platform- and language-neutral interface that
    will allow programs and scripts to dynamically access and update the content,
    structure, and style of documents. The document can be further processed, and
    the results of that processing can be incorporated back into the presented page".'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can also access a set of objects known as the **Browser Object
    Model** (**BOM**) from a web browser runtime environment. The BOM consists of
    the objects `navigator`, `history`, `screen`, `location`, and `document`, which
    are properties of the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that the DOM is only available in web browsers. If we
    want to run our application in a web browser, we will be able to access the DOM
    and BOM. However, in environments such as Node.js or RingoJS, these APIs will
    not be available since they are standalone JavaScript environments completely
    independent of a web browser. We can also find other objects in the server-side
    environments (such as `process.stdin` in Node.js) that will not be available if
    we attempt to execute our code in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to keep in mind the existence of multiple versions of these JavaScript
    environments. In some cases, we will have to support multiple browsers and multiple
    versions of Node.js. The recommended practice when dealing with this problem is
    to add conditional statements that check for the availability of features rather
    than the availability of an environment or version.
  prefs: []
  type: TYPE_NORMAL
- en: A really good library is available that can help us to implement feature detection
    when developing for web browsers. The library is called **Modernizr** and can
    be downloaded at [http://modernizr.com/](http://modernizr.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript runtime (JavaScript) has a concurrency model based on an **event
    loop**. This model is quite different from the model in other languages, such
    as C or Java. Before we focus on the event loop itself, we must understand some
    runtime concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a visual representation of some important runtime concepts:
    heap, stack, queue, and frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9abf1c82-6d70-49f1-8ff4-3bf634ab7389.png)'
  prefs: []
  type: TYPE_IMG
- en: We will now look at the role of each of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A frame is a sequential unit of work. In the preceding diagram, the frames are
    represented by the blocks inside the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is invoked in JavaScript, the runtime creates a frame in the
    stack. The frame holds that function''s arguments and local variables. When the
    function returns, the frame is removed from the stack. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `foo` and `bar` functions, we will invoke the `bar` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When `bar` is executed, the runtime will create a new frame containing the arguments
    of `bar` and all its local variables (value). The frame (represented as blocks
    inside the stack) is then added to the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `bar` invokes `foo`. When `foo` is invoked, a new frame is created
    and allocated to the top of the stack. When the execution of `foo` is finished
    (`foo` has returned), the top frame is removed from the stack. When the execution
    of `bar` is also completed, it is removed from the stack as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to imagine what would happen if the `foo` function invoked
    the `bar` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We would create a never-ending function call loop. With each function call,
    a new frame would be added to the stack, and eventually there would be no more
    space in the stack, and an error would be thrown. Most software engineers are
    familiar with this error, known as a *stack overflow* error.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stack contains sequential steps (frames). A stack is a data structure that
    represents a simple **last-in-first-out** (**LIFO**) collection of objects. Therefore,
    when a frame is added to the stack, it is always added to the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Since the stack is a LIFO collection, the event loop processes the frames stored
    in it from top to bottom. The dependencies of a frame are added to the top of
    it in the stack to ensure that all the dependencies of each of the frames are
    met.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The queue contains a list of messages waiting to be processed. Each message
    is associated with a function. When the stack is empty, a message is taken out
    of the queue and processed. The processing consists of calling the associated
    function and adding the frames to the stack. The message processing ends when
    the stack becomes empty again.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous runtime diagram, the blocks inside the queue represent the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heap is a memory container that is not aware of the order of the items stored
    in it. The heap contains all the variables and objects currently in use. It may
    also contain frames that are currently out of scope but have not yet been removed
    from memory by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is the ability for two or more operations to be executed simultaneously.
    The runtime execution takes place on one single thread, which means that we cannot
    achieve real concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop follows a run-to-completion approach, which means that it will
    process a message from beginning to end before any other message is processed.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a function is invoked, a new message is added to the queue. If the
    stack is empty, the function is processed (the frames are added to the stack).
  prefs: []
  type: TYPE_NORMAL
- en: When all the frames have been added to the stack, the stack is cleared from
    top to bottom. At the end of the process, the stack is empty, and the next message
    is processed.
  prefs: []
  type: TYPE_NORMAL
- en: Web workers can perform background tasks in a different thread. They use a separated
    queue, heap, and stack.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of the `event loop` is that the execution order is quite
    predictable and easy to follow. Another important advantage of the `event loop`
    approach is that it features non-blocking I/O. This means that when the application
    is waiting for an input and output (I/O) operation to finish, it can still process
    other things, such as user input.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this approach is that, if a message (function) takes too long
    to complete, the application becomes unresponsive. A good practice to follow is
    to make message processing short and, if possible, split one message into several
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: The this operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, the `this` operator behaves a little differently compared to
    other languages. The value of the `this` operator is often determined by the way
    a function is invoked. Its value cannot be set by assignment during execution,
    and it may be different each time a function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` operator also has some differences when using the strict mode and
    non-strict mode. To learn more about the strict mode, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: The this operator in the global context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the global context, the `this` operator will always point to the global
    object. In a web browser, the `window` object is the global object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a JavaScript example, not a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: The this operator in a function context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The value of `this` inside a function depends on how the function is invoked.
    If we simply invoke a function in non-strict mode, the value of `this` within
    the function will point to the global object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All examples in this sub section (that is, the `this` operator in a function
    context) are JavaScript examples, not TypeScript examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we invoke a function in strict mode, the value of `this` within
    the function''s body will point to `undefined` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript.
    You can learn more about the strict mode at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the value of the `this` operator inside a function invoked as an instance
    method points to the instance. In other words, the value of the `this` operator
    within a function that is part of a class points to that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have used object literal notation to define an
    object named `p`, but the same applies when declaring objects using prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function is used as a constructor (with the `new` keyword), the `this`
    operator points to the object being constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The call, apply, and bind methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All functions inherit the `call`, `apply`, and `bind` methods from `Function.prototype`.
    We can use these methods to set the value of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` and `apply` methods are almost identical; both methods allow us to
    invoke a function and set the value of the `this` operator within the function.
    The main difference between `call` and `apply` is that, while `apply` lets us
    invoke the function with arguments as an array, `call` requires the function parameters
    to be listed explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A useful mnemonic is *A (*`apply`*) for an array and C (*`call`*) for a comma*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will start by declaring a class named `Person`.
    This class has two properties (`name` and `surname`) and one method (`greet`).
    The `greet` method uses the `this` operator to access the `name` and `surname`
    instance properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `Person` class, we will create an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the `greet` method, it will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can invoke the method using the `call` and `apply` functions.
    We have supplied the `person` object as the first parameter of both functions
    because we want the `this` operator (inside the `greet` method) to take person
    as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we provide a different value to be used as the value of `this`, we will
    not be able to access the `name` and `surname` properties within the `greet` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The two preceding examples may seem useless, because the first one invoked
    the function directly and the second one caused unexpected behavior. The `apply`
    and `call` methods make sense only when we want the `this` operator to take a
    different value when a function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` method can be used to set the value of the `this` operator (within
    a function), regardless of how it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke a function's `bind` method, it returns a new function with the
    same body and scope as the original function, but the `this` operator (within
    the body function) is permanently bound to the first argument of `bind`, regardless
    of how the function is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will start by creating an instance of the `Person`
    class that we declared in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use bind to set the `greet` function to be a new function with
    the same scope and body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to invoke the `greet` function using `bind` and `apply`, just like
    we did in the previous example, we will be able to observe that, this time, the
    `this` operator will always point to the object instance  regardless of how the
    function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we bind an object to a function with `bind`, we cannot override it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using the `bind`, `apply`, and `call` methods is often discouraged because it
    can lead to confusion. Modifying the default behavior of the `this` operator can
    lead to unexpected results. Remember to use these methods only when strictly necessary
    and to document your code properly to reduce the risk caused by potential maintainability
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we compile a TypeScript program, all classes and objects become JavaScript
    objects. However, sometimes we may encounter an unexpected behavior at runtime,
    even if the compilation was completed without errors. To be able to identify and
    understand the cause of this behavior, we need a good understanding of the JavaScript
    runtime. One of the main concepts that we need to understand is how inheritance
    works at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime inheritance system uses a prototypal inheritance model. In a prototypal
    inheritance model, objects inherit from objects, and there are no classes available.
    However, we can use prototypes to simulate classes. Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, every JavaScript object has an internal property called prototype.
    The value of the prototype attribute is an object, which contains some attributes
    (data) and methods (behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use a class-based inheritance system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a class named `Person`. At runtime, this class is declared
    using prototypes instead of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is emitted by TypeScript when we target ES5\. The `class`
    keyword is supported by ES6 at runtime, but it is syntactic sugar. In computer
    science, syntactic sugar is syntax within a programming language that is designed
    to make things easier to read or to express. This means that the `class` keyword
    is just a helper to make our lives as software engineers easier and, internally,
    prototypes are always used.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler wraps the object definition (we will not refer to it
    as a class definition because, technically, it is not a class) with an **immediately
    invoked function expression** (**IIFE**). Inside the IIFE, we can find a function
    named `Person`. If we examine the function and compare it with the TypeScript
    class, we will notice that it takes the same parameters that the class constructor
    takes in the TypeScript class. This function is used to create new instances of
    the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: After the constructor, we can see the definition of the `greet` method. As we
    can see, the `prototype` attribute is used to attach the `greet` method to the
    `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Instance properties versus class properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because JavaScript is a dynamic programming language, we can add properties
    and methods to an instance of an object at runtime, and they don''t need to be
    part of the object (class) itself. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a constructor function for an object named `person`, which
    takes two variables (`name` and `surname`) as arguments. Then, we have created
    an instance of the `Person` object and added a new property named `age` to it.
    We can use a `for...in` statement to check the properties of `person` at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All these properties are **instance properties** because they hold a value
    for each new instance. If, for example, we create a new instance of `Person`,
    both instances will hold their own values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have defined these instance properties using the `this` operator, because
    when a function is used as a constructor (with the `new` keyword), the `this`
    operator is bound to the new object being constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also explains why we can alternatively define instance properties through
    the object''s prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can also declare class-level properties and methods (also known as static
    properties). The main difference is that the values of class properties and methods
    are shared between all instances of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class properties are often used to store static values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Class methods are also often used as utility functions that perform calculations
    upon supplied parameters and return a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have accessed a class attribute (`PI`) from a
    class method (`areaOfCircle`). We can access class properties from instance methods,
    but we cannot access instance properties or methods from class properties or methods.
    We can demonstrate this by declaring `PI` as an instance property instead of a
    class property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then attempt to access `PI` from a class method, it will be undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not supposed to access class methods or properties from instance methods,
    but there is a way to do it. We can achieve it by using the prototype''s constructor
    property as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can access the `PI` class property from the `areaOfCircle` instance method
    using the prototype's constructor property, because this property returns a reference
    to the object's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `areaOfCircle`, the `this` operator returns a reference to the object''s
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The value of `this.constructor` is equal to `MathHelper.prototype.constructor`
    and, therefore, `MathHelper.prototype.constructor` is equal to `MathHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might be wondering how the `extends` keyword works. Let''s create a new
    TypeScript class, which inherits from the `Person` class, to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class is named `SuperHero` and extends the `Person` class. It
    has one extra attribute (`superpower`) and method (`useSuperPower`). If we compile
    the code, we will notice the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding code snippet is slightly more complicated in
    TypeScript 2.8\. We will use the code from the previous versions here because
    it contains fewer conditions and is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This piece of code is generated by TypeScript. Even though it is a small piece
    of code, it showcases almost every concept contained in this chapter, and understanding
    it can be quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Before the function expression is evaluated for the first time, the `this` operator
    points to the global object, which does not contain a method named `__extends`.
    This means that the `__extends` variable is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: When the function expression is evaluated for the first time, the value of the
    function expression (an anonymous function) is assigned to the `__extends` property
    in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript generates the function expression one time for each TypeScript file
    containing the `extends` keyword. However, the function expression is only evaluated
    once (when the `__extends` variable is undefined). This behavior is implemented
    by the conditional statement in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first time this line of code is executed, the function expression is evaluated.
    The value of the function expression is an anonymous function, which is assigned
    to the `__extends` variable in the global scope. Because we are in the global
    scope, `var __extends` and `this. __extends` refer to the same variable at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: When a new file is executed, the `__extends` variable is already available in
    the global scope, and the function expression is not evaluated. This means that
    the value of the function expression is only assigned to the `__extends` variable
    once, even if the snippet is executed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus now on the `__extends` variable (the anonymous function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two arguments, named `d` and `b`. When we invoke it, we
    should pass a derived object constructor (`d`) and a base object constructor (`b`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line inside the anonymous function iterates each class property and
    method from the base class and creates their copy in the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When we use a `for...in` statement to iterate an instance of an object to `a`,
    it will iterate the object's instance properties. However, if we use a `for...in`
    statement to iterate the properties of an object's constructor, the statement
    will iterate its class properties. In the preceding example, the `for...in` statement
    is used to inherit the object's class properties and methods. To inherit the instance
    properties, we will copy the object's prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line declares a new constructor function named `__`, and inside
    it, the `this` operator is used to access its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The prototype contains a special property named `constructor`, which returns
    a reference to the object's constructor. The function named `__` and `this.constructor`
    are pointing to the same variable at this point. The value of the derived object
    constructor (`d`) is then assigned to the `__` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third line, the value of the prototype object from the base object constructor
    is assigned to the prototype of the `__` object constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last line, `new __()` is invoked, and the result is assigned to the
    derived class (`d`) prototype. By performing all these steps, we can invoke the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Upon doing so, we will get an object that contains all the properties from both
    the derived class (`d`) and the base class (`b`). Furthermore, any instance objects
    constructed by the derived constructor (`d`) will be instances of the derived
    class while inheriting both the class and instance properties and methods from
    the base class (`b`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the function in action by examining the runtime code that defines
    the `SuperHero` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can see an IIFE here again. This time, the IIFE takes the `Person` object
    constructor as the argument. Inside the function, we will refer to this argument
    using the name `_super`. Inside the IIFE, the `__extends` function is invoked
    and the `SuperHero` (derived class) and `_super` (base class) arguments are passed
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we can find the declaration of the `SuperHero` object constructor
    and the `useSuperPower` function. We can use `SuperHero` as an argument of `__extend`
    before it is declared because function declarations are hoisted to the top of
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Function expressions are not hoisted. When we assign a function to a variable
    in a function expression, the variable is hoisted, but its value (the function
    itself) is not hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `SuperHero` constructor, the base class (`Person`) constructor is
    invoked using the `call` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discovered previously in this chapter, we can use `call` to set the value
    of the `this` operator in a function context. In this case, we are passing the
    `this` operator, which points to the instance of `SuperHero` being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The prototype chain and property shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to access a property or a method of an object, the runtime will
    search for that property or method in the object's properties and methods. If
    it is not found, the runtime will continue searching through the object's inherited
    properties by navigating the entire inheritance tree. Because a derived object
    is linked to its base object through the `prototype` property, we refer to this
    inheritance tree as **the prototype chain**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will declare two simple TypeScript classes named
    `Base` and `Derived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will examine the JavaScript code generated by TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create an instance of the `Derived` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to access the method named `method1`, the runtime will find it in
    the instance''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance also has an own property named `method2` (with value 2), but there
    is also an inherited property named `method2` (with value 3). The object''s property
    (`method2` with value 3) prevents the access to the `prototype` property (`method2`
    with value 2). This is known as **property shadowing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance does not have an own property named `method3`, but it has a property
    named `method3` in its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither the instance nor the objects in the prototype chain (the `Base` class)
    have a property named `method4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the prototype of an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prototypes can be accessed in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.prototype`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf(person)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person.__proto__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `__proto__` is controversial and has been discouraged by many experienced
    software engineers. It was never originally included in the ECMAScript language
    specification, but modern browsers decided to implement it anyway. Today, the
    `__proto__` property has been standardized in the ECMAScript 6 language specification
    and will be supported in the future, but it is still a slow operation that should
    be avoided if performance is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: The new operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `new` operator to generate an instance of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When we use the new operator, the runtime creates a new object that inherits
    from the `Person` class prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are one of the most powerful features available at runtime, but they
    are also one of the most misunderstood. The Mozilla developer network defines
    closures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure ''remembers'' the environment in which
    it was created".'
  prefs: []
  type: TYPE_NORMAL
- en: 'We understand independent (free) variables as variables that persist beyond
    the lexical scope from which they were created. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a JavaScript example, not a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have declared a function named `makeArmy`. Inside the function, we have
    created an array of functions named `shooters`. Each function in the `shooters`
    array will display a number, the value of which was set from the variable `i`
    inside a `for` statement. We will now invoke the `makeArmy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `army` should now contain the array of the function''s `shooters`.
    However, we will notice a problem if we execute the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet does not work as expected because we made one of
    the most common mistakes related to closures. When we declared the `shooter` function
    inside the `makeArmy` function, we created a closure without being aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that the functions assigned to `shooter` are closures;
    they consist of the function definition and the captured environment from the
    `makeArmy` function's scope. We have created ten closures, but all of them the
    same environment. By the time the `shooter` functions are executed, the loop has
    run its course, and the `i` variable (shared by all the closures) has been left
    pointing to the last entry (`10`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution, in this case, is to use more closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a TypeScript example, not a JavaScript example.
  prefs: []
  type: TYPE_NORMAL
- en: This works as expected. Rather than the shooter functions sharing a single environment,
    the immediately invoked function creates a new environment for each one in which
    `i` refers to the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables powered by closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that when a variable in a closure context
    is shared between multiple instances of a class, the variable behaves like a static
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now see how we can create variables and methods that behave like a
    static variables. Let''s start by declaring a TypeScript class named `Counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a TypeScript example, not a JavaScript example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding class contains a static member named `_COUNTER`. The TypeScript
    compiler transforms it into the resultant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a JavaScript example, not a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: As we can observe, the static variable is declared by the TypeScript compiler
    as a class property (as opposed to an `instance` property). The compiler uses
    a class property because class properties are shared across all instances of a
    class. The problem is that the private variable is not private at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could write some JavaScript (remember that all valid JavaScript
    is valid TypeScript) code to emulate static properties at runtime using closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a JavaScript example, not a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet declares a class named `Counter`. The class has some
    methods used to increment, decrement, and read the variable named `_COUNTER`.
    The `_COUNTER` variable itself is not part of the object prototype.
  prefs: []
  type: TYPE_NORMAL
- en: All the instances of the `Counter` class will share the same context, which
    means that the context (the variable `counter` and the function `changeBy`) will
    behave as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern requires an object to be declared as a static variable
    to avoid the need to create its instance whenever it is required. The object instance
    is, therefore, shared by all the components in the application. The singleton
    pattern is frequently used in scenarios where it is not beneficial, introducing
    unnecessary restrictions in situations where a unique instance of a class is not
    required and introduces global state into an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how to use closures to emulate static variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Private members powered by closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that closures can access variables that
    persist beyond the lexical scope from which they were created. These variables
    are not part of the function prototype or body, but they are part of the function
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no way we can directly invoke the function context, the context
    variables and methods can be used to emulate private members at runtime. The main
    advantage of using closures to emulate private members (instead of the TypeScript
    private access modifier) is that closures will prevent access to private members
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript avoids emulating private properties at runtime because the compiler
    will throw an error at compilation time if we attempt to access a private member.
    TypeScript avoids the use of closures to emulate private members to improve the
    application performance. If we add or remove an access modifier to or from one
    of our classes, the resultant JavaScript code will not change at all. This means
    that the private members of a class (at design time) become public members at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to use closures to emulate private properties at runtime.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a TypeScript example, not a JavaScript example.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding class is almost identical to the class that we previously declared
    to demonstrate how to emulate static variables at runtime using closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, a new closure context is created every time we invoke the `makeCounter`
    function, so each new instance of `Counter` will remember an independent context
    (`counter` and `changeBy`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the context cannot be accessed directly, we can say that the variable
    `counter` and the `changeBy` function are private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have acquired a better understanding of the runtime, which
    allows us not only to resolve runtime issues with ease but also to be able to
    write better TypeScript code. A deep understanding of closures and prototypes
    will allow us to develop some complex features that would have not been possible
    to develop without this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the **functional programming** (**FP**)
    paradigm.
  prefs: []
  type: TYPE_NORMAL
