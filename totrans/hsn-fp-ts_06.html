<html><head></head><body>
        

                            
                    <h1 class="header-title">Functional Programming Techniques</h1>
                
            
            
                
<p>After learning how to work with functions in detail, mastering asynchronous programming, and going through the main characteristics of the JavaScript runtime, we are now fully ready to focus on functional programming. In this chapter, we are going to focus on the most fundamental functional programming techniques and patterns.</p>
<p>We are going to try to avoid using external libraries and we are going to implement some of these techniques and patterns from scratch. This will be slightly more tedious, but it will help us to fully understand how these techniques work internally. Please note that some of these implementations have been simplified and do not cover all the potential edge cases. In an actual production system, using a well-tested functional programming library  is recommended.</p>
<p>In this chapter, we are going to learn about the following functional programming techniques and patterns:</p>
<ul>
<li>Composition</li>
<li>Partial application</li>
<li>Currying</li>
<li>Pipes</li>
<li>Point-free style</li>
<li>Recursion</li>
<li>Pattern matching</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition techniques</h1>
                
            
            
                
<p>In this section, we are going to learn about some functional programming techniques that are very closely linked to function composition. We are going to learn about composition, partial application, currying, and pipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition</h1>
                
            
            
                
<p><strong>Functional composition</strong> is a technique or pattern that allows us to combine multiple functions to create a more complex function.</p>
<p>The following code snippet declares two simple functions:</p>
<pre>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();</pre>
<p>That two simple functions declared by the preceding code snippet are the following:</p>
<ul>
<li>A function used to trim a string</li>
<li>A function used to transform a piece of text into uppercase</li>
</ul>
<p>We can create a function that performs both of the preceding operations by composing them as follows:</p>
<pre>const trimAndCapitalize = (s: string) =&gt; capitalize(trim(s));</pre>
<p><kbd>trimAndCapitalize</kbd> is a function that invokes the <kbd>trim</kbd> function (using <kbd>s</kbd> as its argument) and passes its return to the capitalize function. We can invoke the <kbd>trimAndCapitalize</kbd> function as follows:</p>
<pre>trimAndCapitalize("   hello world   "); // "HELLO WORLD"</pre>
<p>The composition of two functions, <kbd>f(x)</kbd> and <kbd>g(x)</kbd>, is defined as <kbd>f(g(x))</kbd>, and that is exactly what we have done in the implementation of the <kbd>trimAndCapitalize</kbd> function. However, such a behavior can be abstracted using a higher-order function:</p>
<pre>const compose = &lt;T&gt;(f: (x: T) =&gt; T, g: (x: T) =&gt; T) =&gt; (x: T) =&gt; f(g(x));</pre>
<p>We can then use the preceding function to compose two given functions:</p>
<pre>const trimAndCapitalize = compose(trim, capitalize);</pre>
<p>We can then invoke the <kbd>trimAndCapitalize</kbd> function as follows:</p>
<pre>trimAndCapitalize("   hello world   "); // "HELLO WORLD"</pre>
<p>One important thing to note is that the return of the <kbd>g</kbd> function is passed as the argument of the <kbd>f</kbd> function. This means that <kbd>f</kbd> can only take one argument (it must be a unary function). The type of the only argument of <kbd>f</kbd> must match the return type of the <kbd>g</kbd> function. These limitations can be expressed in a more correct definition of the <kbd>compose</kbd> function:</p>
<pre>const compose = &lt;T1, T2, T3&gt;( f: (x: T2) =&gt; T3, g: (x: T1) =&gt; T2) =&gt; (x: T1) =&gt; f(g(x));</pre>
<p>We can also compose in functions generated with the <kbd>compose</kbd> function:</p>
<pre>const composed1 = compose(func1, func2);<br/>const composed2 = compose(func1, func2);<br/>const composed3 = compose(composed1, composed2);</pre>
<p>Please note that the entire example is included in the companion source code.</p>
<p>Or we can declare a higher-order function to compose three functions in a single call:</p>
<pre>const compose3 = &lt;T1, T2, T3, T4&gt;(<br/>    f: (x: T3) =&gt; T4,<br/>    g: (x: T2) =&gt; T3,<br/>    h: (x: T1) =&gt; T2<br/>) =&gt; (x: T1) =&gt; f(g(h(x)));</pre>
<p>We can then invoke it as follows:</p>
<pre>const composed1 = composeMany(func1, func2, func3);</pre>
<p>We can also create a helper that allows us to compose an unlimited number of functions:</p>
<pre>const composeMany = &lt;T&gt;(...functions: Array&lt;(arg: T) =&gt; T&gt;) =&gt;<br/>    (arg: any) =&gt;<br/>        functions.reduce((prev, curr) =&gt; {<br/>            return curr(prev);<br/>        }, arg);</pre>
<p>We can then invoke it as follows:</p>
<pre>const composed1 = composeMany(func1, func2, func3, func4);<br/>const composed2 = composeMany(func1, func2, func3, func4, func5);</pre>
<p>Functional composition is an extremely powerful technique, but it can be hard to put into practice in certain scenarios, for example, when our functions are not unary functions. However, there are other techniques, such as functional partial application, that can help in those scenarios, as we will see in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Partial application</h1>
                
            
            
                
<p><strong>Partial application</strong> is a functional programming technique that allows us to pass the arguments required by a function at different points in time.</p>
<p>This technique can feel like a weird idea at first glance, because most software engineers are used to the idea of applying or invoking a function at a unique point in time (complete application), as opposed to applying a function at multiple points in time (partial application).</p>
<p>The following code snippet implements a function that doesn't support partial application and invokes it (providing all the required arguments) at a single point in time:</p>
<pre>function add(a: number, b: number) {<br/>    return a + b;<br/>}<br/><br/>const result = add(5, 5); // All arguments are provided at the same time<br/>console.log(result); // 10</pre>
<p>The following code snippet implements the preceding function using a higher-order function to allow us to provide the required arguments at different points in time:</p>
<pre>function add(a: number) {<br/> return (b: number) =&gt; {<br/> return a + b;<br/> };<br/>}<br/><br/>const add5 = add(5); // The 1st argument is provided<br/>const result = add5(5); // The 2nd argument is provided later<br/>console.log(result); // 10</pre>
<p>As we can see in the preceding code snippet, the first and second arguments are provided at a different point in time. However, the preceding cannot be considered an example of functional partial application because the two functions are unary functions and we have provided one argument at a time.</p>
<p>We can also write a function that allows both its complete and partial application:</p>
<pre>function add(a: number, b?: number) {<br/>    if (b !== undefined) {<br/>        return a + b;<br/>    } else {<br/>        return (b2: number) =&gt; {<br/>            return a + b2;<br/>        };<br/>    }<br/>}<br/><br/>const result1 = add(5, 5); // All arguments are<br/>console.log(result1); // 10<br/>const add5 = add(5) as (b: number) =&gt; number; // The 1st passed<br/>const result2 = add5(5); // The 2nd argument is passed later<br/>console.log(result2); // 10</pre>
<p>The preceding example can be considered an example of partial application because we can apply a function with all its arguments (complete application), or just some of them (partial application).</p>
<p>Now that we know how functional partial application works, let's focus on why it is useful. In the preceding section on function composition, we learned how to compose two functions, named <kbd>trim</kbd> and <kbd>capitalize</kbd>, into a third function, named <kbd>trimAndCapitalize</kbd>:</p>
<pre>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const trimAndCapitalize = compose(trim, capitalize);</pre>
<p>Function composition works very well with unary functions, but not so well with binary, ternary, or variadic functions. We are going to declare the following function to demonstrate it:</p>
<pre>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);</pre>
<p>The preceding function can be used to replace a substring in a given string. Unfortunately, the function cannot be easily used with the <kbd>compose </kbd> function because it is not a unary function:</p>
<pre>const trimCapitalizeAndReplace = compose(trimAndCapitalize, replace); // Error</pre>
<p>However, we can implement the function in a way that allows us to apply the function partially:</p>
<pre>const replace = (f: string, r: string) =&gt; (s: string) =&gt; s.split(f).join(r);</pre>
<p>We can then use the <kbd>compose</kbd> function without any difficulties:</p>
<pre>const trimCapitalizeAndReplace = compose(trimAndCapitalize, replace("/", "-"));<br/>trimCapitalizeAndReplace(" 13/feb/1989 "); // "13-FEB-1989"</pre>
<p>Thanks to our knowledge of functional partial application, we can easily use the <kbd>compose</kbd> function without having to worry about the arity of the functions. However, enabling partial application requires a significant amount of manual boilerplate. In the next section, we will learn how a functional programming technique, known as <strong>currying</strong>, can help us to solve this problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Currying</h1>
                
            
            
                
<p>Currying is a functional programming technique that allows us to partially apply a function without having to worry about the way in which we implement our functions. Currying is the process of taking a function that takes multiple arguments and transforming it into a chain of unary functions. The following function allows us to transform a function, <kbd>fn</kbd>, which takes two arguments, <kbd>a</kbd> and <kbd>b</kbd>, into a function that takes one argument, <kbd>a</kbd>, and returns another function that takes one argument, <kbd>b</kbd>:</p>
<pre>function curry2&lt;T1, T2, T3&gt;(fn: (a: T1, b: T2) =&gt; T3) {<br/> return (a: T1) =&gt; (b: T2) =&gt; fn(a, b);<br/>}</pre>
<p>The above function is a higher-order function that allows our functions to be partially applied while keeping their implementation agnostic of this concern.</p>
<pre>function add(a: number, b: number) {<br/> return a + b;<br/>}<br/><br/>const curriedAdd = curry2(add);<br/>const add5 = curriedAdd(5);<br/>const addResult = add5(5);<br/>console.log(addResult); // 10</pre>
<p>The <kbd>curry2</kbd> function allows us to transform a binary function into two unary functions. The <kbd>curry2</kbd> function is a higher-order function and can be used with any binary function. For example, in the preceding code snippet, we passed the <kbd>add</kbd> function to the <kbd>curry2</kbd> function, but the following example passes the <kbd>multiply</kbd> function to the <kbd>curry2</kbd> function instead:</p>
<pre>function multiply(a: number, b: number) {<br/> return a * b;<br/>}<br/><br/>const curriedMultiply = curry2(multiply);<br/>const multiplyBy5 = curriedMultiply(5);<br/>const multiplyResult = multiplyBy5(5);<br/>console.log(multiplyResult); // 25</pre>
<p>In the preceding section on functional partial application, we learned how to use partial application to use <kbd>compose</kbd> with functions that are not unary. We declared the following function named <kbd>replace</kbd> and then passed it to the <kbd>compose</kbd> function:</p>
<pre>const replace = (f: string, r: string) =&gt; (s: string) =&gt; s.split(f).join(r);<br/><br/>const trimCapitalizeAndReplace = compose(<br/>    trimAndCapitalize,<br/>    replace("/", "-")<br/>);</pre>
<p>We can declare a function named <kbd>curry3</kbd>, which transforms a ternary function into a chain of three unary functions:</p>
<pre>function curry3&lt;T1, T2, T3, T4&gt;(fn: (a: T1, b: T2, c: T3) =&gt; T4) {<br/>    return (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; fn(a, b, c);<br/>}</pre>
<p>We can then use the <kbd>curry3</kbd> function to rewrite the <kbd>replace</kbd> function in a way that is agnostic of the functional partial application implementation details:</p>
<pre>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);<br/><br/>const curriedReplace = curry3(replace);<br/><br/>const trimCapitalizeAndReplace = compose(<br/>    trimAndCapitalize,<br/>    curriedReplace("/")("-")<br/>);</pre>
<div><p>Please note that the entire example is included in the companion source code.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">strictBindCallApply</h1>
                
            
            
                
<p>We explored a few potential ways to implement partial application earlier in this chapter. However, we avoided an alternative implementation that uses the <kbd>function.prototype.bind</kbd> method. We have done this because the <kbd>bind</kbd> method was unsafe in TypeScript versions prior to the 3.2 release. If we install TypeScript version 3.2 or higher, and we enable the <kbd>strictBindCallApply</kbd> compilation flag in the <kbd>tsconfig.json</kbd> file, we will be able to use <kbd>bind</kbd> as follows:</p>
<pre>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);<br/>const replaceForwardSlash = replace.bind(replace, "/");<br/>const replaceForwardSlashWithDash = replaceForwardSlash.bind(replaceForwardSlash, "-");<br/>replaceForwardSlashWithDash("13/feb/1989");</pre>
<p>As we can see, the <kbd>bind</kbd> method allows us to apply the function partially. We can rewrite the currying example that we implemented earlier in this chapter and use the <kbd>bind</kbd> method instead of the currying function:</p>
<pre>const compose = &lt;T1, T2, T3&gt;( f: (x: T2) =&gt; T3, g: (x: T1) =&gt; T2) =&gt; (x: T1) =&gt; f(g(x));<br/>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const trimAndCapitalize = compose(trim, capitalize);<br/>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);<br/>const replaceForwardSlashWithDash = replace.bind(replace, "/", "-");<br/>const trimCapitalizeAndReplace = compose(trimAndCapitalize, replaceForwardSlashWithDash);<br/>const result = trimCapitalizeAndReplace(" 13/feb/1989 ");<br/>console.log(result); // "13-FEB-1989"</pre>
<p>The <kbd>strictBindCallApply</kbd> compilation flag ensures that the return as a result of invoking the <kbd>bind</kbd> method will have the correct type. In versions of TypeScript prior to 3.2, the return of the <kbd>bind</kbd> method was of the <kbd>any</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pipes</h1>
                
            
            
                
<p>A <kbd>pipe</kbd> is a function or operator that allows us to pass the output of a function as the input of another. JavaScript and TypeScript don't support pipes natively (as an operator), but we can implement our pipes using the following function:</p>
<pre>const pipe = &lt;T&gt;(...fns: Array&lt;(arg: T) =&gt; T&gt;) =&gt;<br/>    (value: T) =&gt;<br/>        fns.reduce((acc, fn) =&gt; fn(acc), value);</pre>
<p>We are going to use the <kbd>curry3</kbd>, <kbd>trim</kbd>, <kbd>capitalize</kbd>, and <kbd>replace</kbd> functions that we declared previously in this chapter:</p>
<pre>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/><br/>const replace = curry3(<br/> (s: string, f: string, r: string) =&gt; s.split(f).join(r)<br/>);</pre>
<p>We can then use the <kbd>pipe</kbd> function to declare a new function:</p>
<pre>const trimCapitalizeAndReplace = pipe(<br/>    trim,<br/>    capitalize,<br/>    replace("/")("-")<br/>);<br/><br/>trimCapitalizeAndReplace(" 13/feb/1989 "); // "13-FEB-1989"</pre>
<p>The <kbd>pipe</kbd> function ensures that the output of the <kbd>trim</kbd> function is passed to the <kbd>capitalize</kbd> function. The return of the <kbd>capitalize</kbd> function is then passed to the <kbd>replace</kbd> function, which has already been applied in part.</p>
<p>There is an official proposal to add a new operator to JavaScript known as the pipeline operator (<kbd>|&gt;</kbd>). This operator will allow us to use pipes natively as follows:</p>
<pre>const result = " 13/feb/1989 "<br/>  |&gt; trim<br/>  |&gt; capitalize<br/>  |&gt; replace("/")("-");</pre>
<div><p>Please refer to the pipeline operator proposal (<a href="https://github.com/tc39/proposal-pipeline-operator">https://github.com/tc39/proposal-pipeline-operator</a>) to learn more.</p>
<p>Please note that the entire example is included in the companion source code.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Other techniques</h1>
                
            
            
                
<p>In this section, we are going to take a look at other functional programming techniques that are not directly related to  function composition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Point-free style</h1>
                
            
            
                
<p><strong>Point-free style</strong>, also known as <strong>Tacit</strong> programming, is a programming style in which function declarations do not declare the arguments (or <em>points</em>) on which they operate.</p>
<p>The following code snippet declares a few functions that are used to determine whether a person is eligible to vote in elections:</p>
<pre>interface Person {<br/> age: number;<br/> birthCountry: string;<br/> naturalizationDate: Date;<br/>}<br/><br/>const OUR_COUNTRY = "Ireland";<br/>const wasBornInCountry = (person: Person) =&gt; person.birthCountry === OUR_COUNTRY;<br/>const wasNaturalized = (person: Person) =&gt; Boolean(person.naturalizationDate);<br/>const isOver18 = (person: Person) =&gt; person.age &gt;= 18;<br/>const isCitizen = (person: Person) =&gt; wasBornInCountry(person) || wasNaturalized(person);<br/>const isEligibleToVote = (person: Person) =&gt; isOver18(person) &amp;&amp; isCitizen(person);<br/><br/>isEligibleToVote({<br/>    age: 27,<br/>    birthCountry: "Ireland",<br/>    naturalizationDate: new Date(),<br/>});</pre>
<p>The preceding code snippet didn't use any of the functional programming techniques that we have already learned in this chapter. The following code snippet implements an alternative solution for the same problem using techniques such as partial application. This code snippet declares two functions, named <kbd>both</kbd> and <kbd>either</kbd>, that can be used to determine whether a variable matches the requirements specified by some or both functions provided to these functions:</p>
<p>The <kbd>either</kbd> and <kbd>both</kbd> functions are simplified implementations of some real algebraic data types. We will learn more about algebraic data types and category theory in the next chapter.</p>
<pre>const either = &lt;T1&gt;(<br/> funcA: (a: T1) =&gt; boolean,<br/> funcB: (a: T1) =&gt; boolean<br/>) =&gt; (arg: T1) =&gt; funcA(arg) || funcB(arg);<br/><br/>const both = &lt;T1&gt;(<br/> funcA: (a: T1) =&gt; boolean,<br/> funcB: (a: T1) =&gt; boolean<br/>) =&gt; (arg: T1) =&gt; funcA(arg) &amp;&amp; funcB(arg);<br/><br/><br/>interface Person {<br/> age: number;<br/> birthCountry: string;<br/> naturalizationDate: Date;<br/>}<br/><br/>const OUR_COUNTRY = "Ireland";<br/>const wasBornInCountry = (person: Person) =&gt; person.birthCountry === OUR_COUNTRY;<br/>const wasNaturalized = (person: Person) =&gt; Boolean(person.naturalizationDate);<br/>const isOver18 = (person: Person) =&gt; person.age &gt;= 18;<br/><br/>// Point-free style<br/><br/>const isCitizen = either(wasBornInCountry, wasNaturalized);<br/>const isEligibleToVote = both(isOver18, isCitizen);<br/><br/>isEligibleToVote({<br/> age: 27,<br/> birthCountry: "Ireland",<br/> naturalizationDate: new Date(),<br/>});</pre>
<p>As we can see, the <kbd>isCitizen</kbd> and <kbd>isElegibleToVote</kbd> functions take some functions as arguments, but they don't mention which data types they expect as arguments. For example, instead of writing the following:</p>
<pre>const isCitizen = (person: Person) =&gt; wasBornInCountry(person) || wasNaturalized(person);</pre>
<p>We can write the following:</p>
<pre>const isCitizen = either(wasBornInCountry, wasNaturalized);</pre>
<p>This style, in which we avoid referencing function arguments, is known as the point-free style, and it has a number of advantages over the more conventional function declaration style:</p>
<ul>
<li>It makes programs simpler and more concise. This isn't always a good thing, but it can be.</li>
<li>It makes algorithms easier to understand by focusing only on the functions being combined. We get a better sense of what's going on without the data arguments getting in the way.</li>
<li>It forces us to think more about how data is used than about which data is being used.</li>
<li>It helps us think about our functions as generic building blocks that can work with different kinds of data, rather than thinking about them as operations on one kind of data.</li>
</ul>
<div><p>Please note that the entire example is included in the companion source code.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Recursion</h1>
                
            
            
                
<p>A function that calls itself is known as a recursive function. The following function is a recursive function and allows us to calculate the factorial of a given number, <kbd>n</kbd>. The factorial is the product of all positive integers less than, or equal to, a given number, <kbd>n</kbd>:</p>
<pre>const factorial = (n: number): number =&gt; (n === 0) ? 1 : (n * factorial(n - 1));</pre>
<p>We can invoke the preceding function as follows:</p>
<pre>factorial(5); // 120</pre>
<p>In general, you should try to implement functions without recursion. Using recursion should be considered carefully because the JavaScript runtime is not very efficient at handling it since, in a recursive function call, a frame is added to the stack with each function call.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pattern matching</h1>
                
            
            
                
<p>Pattern matching allows you to match a value (or an object) against some patterns to select a branch of the code. In functional languages, pattern matching can be used to match on standard primitive values such as strings. TypeScript allows us to implement pattern matching using literal types and control flow analysis.</p>
<p>For example, we can define three types, named <kbd>Circle</kbd>, <kbd>Square</kbd>, and <kbd>Rectangle</kbd>. We can then define a new type, named <kbd>Shape</kbd>, which is the union of the <kbd>Circle</kbd>, <kbd>Square</kbd>, and <kbd>Rectangle</kbd> types:</p>
<pre>const enum ShapeKind {<br/>    circle = "circle",<br/>    square = "square",<br/>    rectangle = "rectangle",<br/>}<br/><br/>type Circle = { kind: ShapeKind.circle, radius: number };<br/>type Square = { kind: ShapeKind.square, size: number };<br/>type Rectangle = { kind: ShapeKind.rectangle, w: number, h: number };<br/>type Shape = Circle | Square | Rectangle;</pre>
<p>We can then implement functions that take an argument of the <kbd>Shape</kbd> type and use pattern matching to identify whether the <kbd>Shape</kbd> is a <kbd>Circle</kbd>, a <kbd>Square</kbd>, or a <kbd>Rectangle</kbd>:</p>
<pre>function area(shape: Shape) {<br/>    switch(shape.kind) {<br/>        case ShapeKind.circle:<br/>            return shape.radius ** 2;<br/>        case ShapeKind.square:<br/>            return shape.size ** 2;<br/>        case ShapeKind.rectangle:<br/>            return shape.w * shape.h;<br/>        default:<br/>            throw new Error("Invalid shape!"); <br/>    }<br/>}</pre>
<p>Pattern matching was impossible in versions of TypeScript prior to 2.0 because control flow analysis and literal types were not available.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned some of the main functional programming techniques and patterns, including functional composition, functional partial application, and currying.</p>
<p>In the next chapter, we are going to learn about category theory. We will learn how to work with some algebraic data types and how they can help make our TypeScript applications more robust.</p>


            

            
        
    </body></html>