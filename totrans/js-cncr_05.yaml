- en: Chapter 5. Working with Workers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。与 Workers 一起工作
- en: Web workers enable true parallelism within a web browser. They've spent time
    maturing, and have pretty good vendor support today. Before web workers, our JavaScript
    code was confined to the CPU, where our execution environment started when the
    page first loaded. Web workers have evolved out of necessity—web applications
    are growing more capable. They have also started to require more compute power.
    At the same time, multiple CPU cores are common place today—even on low-end hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 允许在网页浏览器内实现真正的并行处理。它们已经经过了一段时间的成熟发展，并且现在得到了很好的供应商支持。在 Web Workers
    出现之前，我们的 JavaScript 代码被限制在 CPU 上，我们的执行环境从页面首次加载时开始。Web Workers 出现是由于需求的推动——Web
    应用程序的能力在不断增强。同时，它们也开始需要更多的计算能力。在今天，多个 CPU 核心变得很常见——甚至在低端硬件上也是如此。
- en: In this chapter, we'll walk through the conceptual ideas of web workers, and
    how they relate to the concurrency principles that we're trying to achieve in
    our applications. Then, you'll learn how to use web workers by example, so that,
    later on in the book, we can start tying parallelism to some of the other ideas
    that we've already explored, such as promises and generators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Web Workers 的概念，以及它们如何与我们试图在应用程序中实现的并发原则相关联。然后，你将通过示例学习如何使用 Web Workers，这样在本书的后续部分，我们就可以开始将并行性与其他我们已经探索过的想法联系起来，例如承诺（promises）和生成器（generators）。
- en: What are workers?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者是什么？
- en: Before we dive into implementation examples, this section will give us a quick
    conceptual breakdown of what web workers are. It's good to know exactly how web
    workers cooperate with the rest of the system under the hood. Web workers are
    operating system threads—a target where we can dispatch events, and they execute
    our JavaScript code in a truly parallel fashion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现示例之前，本节将快速概述 Web Workers 的概念，以及它们在系统内部如何与其他部分协同工作。Web Workers 是操作系统线程——一个我们可以调度事件的目标，并且它们以真正的并行方式执行我们的
    JavaScript 代码。
- en: OS threads
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统线程
- en: At their core, web workers are nothing more than operating system-level threads.
    Threads are kind of like processes, except they require less overhead because
    they share memory addresses with the process from which they're created. Since
    the threads that power web workers are at the level of the operating system, we're
    at the mercy of the system and its process scheduler. Most of the time, this is
    exactly what we want—let the kernel figure out when our JavaScript code should
    run in order to best utilize the CPU.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Web Workers 仅仅是操作系统级别的线程。线程有点像进程，但它们需要的开销更少，因为它们与创建它们的进程共享内存地址。由于驱动 Web
    Workers 的线程处于操作系统级别，我们依赖于系统和其进程调度器。大多数时候，这正是我们想要的——让内核决定我们的 JavaScript 代码何时运行，以便最佳地利用
    CPU。
- en: 'Here''s a diagram showing how the browser maps its web workers to OS threads,
    and how these are mapped to CPU cores:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个图表展示了浏览器如何将 Web Workers 映射到操作系统线程，以及这些线程如何映射到 CPU 核心：  '
- en: '![OS threads](img/B05133_05_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![操作系统线程](img/B05133_05_01.jpg)'
- en: At the end of the day, it's best that the operating system be left responsible
    for handling what it's good at—scheduling software tasks on physical hardware.
    In more traditional multi-threaded programming environments, our code lives much
    closer to the operating system kernel. This isn't the case with web workers. While
    the underlying mechanism is a thread, the exposed programming interface looks
    more like something you might find in the DOM.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最好让操作系统负责处理它擅长的事情——在物理硬件上调度软件任务。在更传统的多线程编程环境中，我们的代码与操作系统内核的距离更近。Web Workers
    的情况并非如此。虽然底层机制是线程，但暴露的编程接口看起来更像是你可能在 DOM 中找到的东西。
- en: Event targets
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件目标
- en: Web workers implement the familiar event target interface. This makes web workers
    behavior similar to other components that we're used to working with, such as
    DOM elements or XHR requests. Workers trigger events, and this is how we receive
    data from them back in our main thread. We can also send data to workers, but
    this uses a simple method call.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 实现了熟悉的事件目标接口。这使得 Web Workers 的行为与其他我们习惯使用的组件相似，例如 DOM 元素或 XHR 请求。Workers
    触发事件，这就是我们如何在主线程中从它们那里接收数据的方式。我们也可以向 Workers 发送数据，但这使用的是简单的方法调用。
- en: 'When we pass data into workers, we actually trigger another event; only this
    time, it''s in the execution context of the worker and not the main page execution
    context. There isn''t much more to it than that: data in, data out. There''s no
    `mutex` construct or anything of this sort. This is actually a good thing because
    the web browser, as a platform, already has many moving parts. Imagine if we threw
    in a more complex multi-threading model instead of just a simple event-target-based
    approach. We already have enough bugs to fix day-to-day.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将数据传递到工作者中时，我们实际上触发了另一个事件；只是这次，它是在工作者的执行上下文中，而不是主页面的执行上下文中。除此之外没有更多的事情：数据输入，数据输出。没有`互斥`构造或类似的东西。这实际上是一件好事，因为作为平台的网络浏览器已经有很多移动部件。想象一下，如果我们加入一个更复杂的基于事件目标的线程模型，而不是简单的基于事件目标的模型，我们已经有足够的bug要修复了。
- en: 'Here''s a rough idea of how the web worker layout looks, relative to the main
    thread that spawned these workers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个关于web worker布局的大致概念，相对于产生这些工作者的主线程：
- en: '![Event targets](img/B05133_05_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![事件目标](img/B05133_05_02.jpg)'
- en: True parallelism
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真正的并行化
- en: Web workers are the means to achieving the parallelize principle in our architecture.
    As we know, workers are operating system threads, meaning that the JavaScript
    code that's running inside them could possibly be running at the same exact instance
    as some DOM event handler code in the main thread. The ability to do stuff like
    this has been a goal of JavaScript programmers for quite a while. Before web workers,
    true parallelism simply wasn't possible. The best we could do was to fake it,
    giving a user the impression of many things happening simultaneously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web workers是我们架构中实现并行化原则的手段。众所周知，工作者是操作系统线程，这意味着运行在其内部的JavaScript代码可能与主线程中某些DOM事件处理器的代码在同一确切时刻运行。能够做这样的事情一直是JavaScript程序员的一个目标。在Web
    workers出现之前，真正的并行化根本不可能实现。我们能做到的最好的事情就是假装它，给用户一种许多事情同时发生的印象。
- en: However, there are problems with always running on the same CPU core. We're
    fundamentally restricted in how many computations we can execute within a given
    time window. This restriction changes when true parallelism is introduced because
    the time window, in which computations may be run, grows with each CPU core that's
    added.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，始终在相同的CPU核心上运行存在一些问题。我们在给定时间窗口内可以执行的运算量受到根本性的限制。当引入真正的并行化时，这种限制会发生变化，因为可以运行的运算时间窗口会随着每个添加的CPU核心而增长。
- en: That being said, for most of the things that our application does, the single
    thread model works just fine. Machines today are powerful. We can get a lot done
    in a small time window. The problem arises when we experience spikes. These could
    be any event that disrupts the processing efficiency of our code. Our applications
    are constantly being asked to do more—more features, more data, more this, and
    more that.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对于我们的应用程序所做的许多事情，单线程模型工作得很好。今天的机器很强大。我们可以在很短的时间内完成很多事情。问题出现在我们遇到峰值时。这些可能是任何干扰我们代码处理效率的事件。我们的应用程序不断被要求做更多的事情——更多功能、更多数据、更多这样和那样的事情。
- en: The simple idea that we can make better use of the hardware that's sitting right
    in front of us, is what web workers are all about. Web workers, if used right,
    don't have to be this insurmountable new thing that we'll never use in our projects
    because it has concepts that fall outside of our comfort zone.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够更好地利用我们面前坐着的硬件的简单想法，这就是Web workers的全部内容。如果使用得当，Web workers不必成为我们项目中永远不会使用的那种不可逾越的新事物，因为它包含了一些超出我们舒适区概念。
- en: Types of workers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者类型
- en: There are three types of web workers that we're likely to encounter during the
    development of concurrent JavaScript applications. In this section, we'll compare
    the three types so that we can understand which type of worker makes sense in
    any given context.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发并发JavaScript应用程序的过程中，我们可能会遇到三种类型的Web workers。在本节中，我们将比较这三种类型，以便我们能够理解在任何特定情况下哪种类型的工作者是有意义的。
- en: Dedicated workers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用工作者
- en: Dedicated workers are probably the most common worker type. They're considered
    the default type of web worker. When our page creates a new worker, it's dedicated
    to the page's execution context and nothing else. When our page goes away, so
    do all the dedicated workers created by the page.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 专用工作者可能是最常见的工作者类型。它们被认为是Web workers的默认类型。当我们的页面创建一个新的工作者时，它仅专注于页面的执行上下文，而不关注其他任何事情。当我们的页面消失时，由页面创建的所有专用工作者也会随之消失。
- en: The communication path between the page and any dedicated worker that it creates
    is straightforward. The page posts messages to the workers, which in turn post
    messages back to the page. The exact orchestration of these messages is dependent
    on the problem that we're trying to solve using web workers. We'll dig into more
    of these messaging patterns throughout the book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 页面与其创建的任何专用工作者之间的通信路径是直接的。页面向工作者发送消息，工作者随后将消息回传给页面。这些消息的确切编排取决于我们使用Web工作者试图解决的问题。在整个书中，我们将深入探讨这些消息模式。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terms main thread and page are synonymous in this book. The main thread
    is your typical execution context, where we can manipulate the page and listen
    for input. The web worker context is largely the same, only with access to fewer
    components. We will go over these restrictions shortly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，主线程和页面是同义的。主线程是你的典型执行上下文，在那里我们可以操作页面并监听输入。Web工作者上下文在很大程度上是相同的，只是可以访问的组件更少。我们将在稍后讨论这些限制。
- en: 'Here''s a depiction of the page communicating with its dedicated workers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了页面与其专用工作者之间的通信情况：
- en: '![Dedicated workers](img/B05133_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![专用工作者](img/B05133_05_03.jpg)'
- en: As we can see, dedicated workers are, well, dedicated. They only exist to help
    serve the page that created them. They don't directly communicate with other workers,
    and they can't communicate with any other page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，专用工作者确实是“专用”的。它们只存在于帮助服务创建它们的页面。它们不会直接与其他工作者通信，也不能与任何其他页面通信。
- en: Sub-workers
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子工作者
- en: Sub-workers are very similar to dedicated workers. The main difference is that
    they're created by a dedicated worker, not by the main thread. For example, if
    a dedicated worker has a task that would benefit from parallel execution, it can
    spawn its own workers and orchestrate the execution of the task between the sub-workers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 子工作者与专用工作者非常相似。主要区别在于它们是由专用工作者创建的，而不是由主线程创建的。例如，如果一个专用工作者有一个可以从并行执行中受益的任务，它可以生成自己的工作者并编排子工作者之间任务的执行。
- en: 'Apart from having a different creator, sub-workers share the same characteristics
    of a dedicated worker. Sub-workers don''t communicate directly with JavaScript
    running in the main thread. It''s up to the worker that creates the sub-workers
    to facilitate their communication. Here''s an illustration of how sub-workers
    fit into the scheme of things:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有不同的创建者外，子工作者与专用工作者具有相同的特征。子工作者不会直接与主线程中运行的JavaScript通信。这是创建子工作者的工作者负责促进他们的通信。以下是如何将子工作者融入整个方案的示意图：
- en: '![Sub-workers](img/B05133_05_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![子工作者](img/B05133_05_04.jpg)'
- en: Shared workers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享工作者
- en: The third type of web worker is called a shared worker. Shared workers are named
    so because multiple pages can share the same instance of this type of worker.
    The pages that can access a given shared worker instance are restricted by the
    same-origin policy, which means, if a page was served from a different domain
    than the worker, the worker isn't allowed to communicate with this page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型的Web工作者被称为共享工作者。共享工作者之所以被称为共享工作者，是因为多个页面可以共享同一实例的这种类型的工作者。可以访问特定共享工作者实例的页面受同源策略的限制，这意味着如果页面是从与工作者不同的域提供的，那么工作者不允许与该页面通信。
- en: Shared workers solve different type of problem than those solved by dedicated
    workers. Think of dedicated workers as functions without side-effects. You pass
    data to them and get different data in return. Think of shared workers as an application
    object following the singleton pattern. They're a means to sharing state between
    different browsing contexts. So, for instance, we wouldn't create a shared worker
    for the sole purpose of crunching numbers; we can use a dedicated worker for this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 共享工作者解决的是与专用工作者解决的问题不同类型的问题。将专用工作者视为没有副作用的功能。你向它们传递数据，并得到不同的数据作为回报。将共享工作者视为遵循单例模式的程序对象。它们是不同浏览上下文之间共享状态的一种方式。例如，我们不会仅仅为了计算数字而创建共享工作者；我们可以使用专用工作者来完成这项工作。
- en: 'It makes sense to use shared workers when there''s application data in memory
    that we want from access from any page from the same application. Think about
    a user opening links in a new tab. This creates a new browsing context. It also
    means that our JavaScript components need to go through the process of fetching
    all the data required for the page, doing all the initialization steps, and so
    on. This gets repetitive and wasteful. Why not conserve these resources by sharing
    them between different browsing contexts? Here is an illustration of multiple
    pages from the same application communicating with a shared worker instance:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存中有我们希望从同一应用中的任何页面访问的应用数据时，使用共享工作者是有意义的。想想用户在新标签页中打开链接。这创建了一个新的浏览上下文。这也意味着我们的JavaScript组件需要经过获取页面所需所有数据的流程，执行所有初始化步骤等等。这既重复又浪费。为什么不在不同的浏览上下文之间共享这些资源呢？以下是同一应用中的多个页面与共享工作者实例通信的示意图：
- en: '![Shared workers](img/B05133_05_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![共享工作者](img/B05133_05_05.jpg)'
- en: There's actually a fourth type of web worker called a service worker. These
    are shared workers embellished with additional capabilities related to caching
    network resources and offline functionality. Service workers are still in the
    early stages of their specification, but they look promising. Anything that we
    can learn about shared workers today will be applicable to service workers should
    they ever become a viable web technology.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有一种名为Service Worker的第四种Web Worker类型。这些是增加了与缓存网络资源和离线功能相关额外能力的共享工作者。Service
    Workers仍处于其规范的早期阶段，但看起来很有希望。今天我们能从共享工作者中学到的任何东西，如果它们最终成为可行的Web技术，都将适用于Service
    Workers。
- en: Another important factor to consider here is the added complexity of service
    workers. The communication mechanism between the main thread and a service worker
    involves using ports. Likewise, the code running within the shared worker needs
    to make sure it's communicating over the correct port. We'll cover shared worker
    communication in much more depth later on in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的另一个重要因素是Service Worker增加的复杂性。主线程与Service Worker之间的通信机制涉及使用端口。同样，在共享工作者中运行的代码需要确保它通过正确的端口进行通信。我们将在本章后面更深入地介绍共享工作者通信。
- en: Worker environments
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者环境
- en: Web worker environments aren't same as the typical JavaScript environment, where
    our code usually runs. In this section, we'll point out critical differences between
    the JavaScript environment of the main thread and web worker threads.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker环境与我们的代码通常运行的典型JavaScript环境不同。在本节中，我们将指出主线程JavaScript环境和Web Worker线程之间的关键差异。
- en: What's available, what isn't?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有什么可用，有什么不可用？
- en: A common misconception of web workers is that they're radically different environments
    from the default JavaScript execution context. It's true that they're different,
    but not so different as to be unapproachable. Perhaps, it's for this reason that
    JavaScript developers shy away from using web workers when they could be beneficial.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web Workers的一个常见误解是，它们与默认的JavaScript执行环境截然不同。确实，它们是不同的，但并没有大到无法接近的程度。也许正因为如此，JavaScript开发者才会在Web
    Workers可能有益的情况下回避使用它们。
- en: The obvious gap is the DOM—it doesn't exist in web worker execution environments.
    Its absence was a conscious decision on the part of specification writers. By
    avoiding DOM integration into worker threads, browser vendors can avoid many potential
    edge cases. We all value browser stability over convenience, or at least, we should.
    And would it really be all that convenient to have DOM access from within web
    workers? We'll see throughout the next few chapters of this book that workers
    are good at lots of other tasks, which ultimately contribute to successfully implementing
    concurrency principles.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的一个差距是DOM——它不存在于Web Worker执行环境中。规范编写者的这一决定是有意为之。通过避免将DOM集成到工作线程中，浏览器供应商可以避免许多潜在的边缘情况。我们都重视浏览器的稳定性胜过便利性，至少我们应该这样。从Web
    Worker内部访问DOM真的会那么方便吗？在本书接下来的几章中，我们将看到工作者擅长许多其他任务，这些任务最终有助于成功实现并发原则。
- en: With no DOM access in our web worker code, we're less likely to shoot ourselves
    in the foot. It actually forces us to really think about why we're using the workers
    in the first place. And we might actually take a step back and rethink our approach.
    Apart from the DOM, most of what we use on a day-to-day basis is exactly where
    we expect it to be. This includes using our favorite libraries inside web workers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的web worker代码中没有DOM访问，我们就不太可能犯错误。这实际上迫使我们真正思考我们最初为什么要使用workers。我们可能实际上会退一步，重新思考我们的方法。除了DOM之外，我们日常使用的几乎所有东西都正好在我们期望的地方。这包括在web
    workers中使用我们最喜欢的库。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed breakdown of what's missing from web worker execution environments,
    see this page [https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解web worker执行环境中缺少的内容，请参阅此页面 [https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers)。
- en: Loading scripts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载脚本
- en: We would never write our entire application in a single JavaScript file. Instead,
    we will promote modularity by dividing our source code into files in a way that
    logically decomposes the design into something we can map mentally. Likewise,
    we probably don't want to compose web workers that consist of thousands of lines
    of code. Luckily, web workers come with a mechanism that allows us to import code
    into our web workers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会将整个应用程序写在一个JavaScript文件中。相反，我们将通过将源代码分解成文件来提高模块化，这样我们可以逻辑上分解设计，使其能够在大脑中映射。同样，我们可能也不希望创建由数千行代码组成的web
    workers。幸运的是，web workers自带一种机制，允许我们将代码导入到我们的web workers中。
- en: 'The first scenario is importing our own code into a web worker context. We
    are likely to have many low-level utilities that are specifically tailored for
    our application. There''s a high probability that we''ll need to use these utilities
    in both: a regular scripting context and within a worker thread. We want to keep
    our code modular, and we want our code to function the same way in workers as
    it would in any other context.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景是将我们自己的代码导入到web worker上下文中。我们可能有很多专门针对我们应用程序的低级实用工具。有很大可能性我们需要在常规脚本上下文和worker线程中同时使用这些实用工具。我们希望保持我们的代码模块化，并希望我们的代码在workers中的表现与其他任何上下文相同。
- en: 'The second scenario is loading third-party libraries in web workers. It''s
    the same principle as loading our own modules into web workers—our code will work
    in any context with a few exceptions, like DOM code. Let''s look at an example
    that creates a web worker and loads the `lodash` library. First, we''ll launch
    the worker:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个场景是在web workers中加载第三方库。这与将我们的模块加载到web workers中的原理相同——我们的代码将在任何上下文中工作，只有少数例外，如DOM代码。让我们看看一个创建web
    worker并加载`lodash`库的示例。首先，我们将启动worker：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll use the `loadScripts()` function to bring the `lodash` library
    into our library:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`loadScripts()`函数将`lodash`库引入我们的库中：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We don't need to worry about waiting for the script to load before we can start
    using it—`importScripts()` is a blocking operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心在开始使用脚本之前等待脚本加载——`importScripts()`是一个阻塞操作。
- en: Communicating with workers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与workers通信
- en: The preceding example created a web worker, which indeed ran in its own thread.
    But, this is not very helpful to us because we need to be able to communicate
    with the workers that we create. In this section, we'll cover the basic mechanisms
    involved with sending and receiving messages from web workers, including how these
    messages are serialized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了一个web worker，它确实在其自己的线程中运行。但是，这对我们来说并不很有帮助，因为我们需要能够与我们创建的workers进行通信。在本节中，我们将介绍涉及从web
    workers发送和接收消息的基本机制，包括这些消息是如何序列化的。
- en: Posting messages
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'When we want to pass data into a web worker, we use the `postMessage()` method.
    As the name suggests, this method posts the given message to the worker. If there
    are any message event handlers set up within the worker, they''ll respond to this
    call. Let''s look at a basic example that sends a string to a worker:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将数据传递给web worker时，我们使用`postMessage()`方法。正如其名所示，此方法将给定消息发送到worker。如果worker中设置了任何消息事件处理器，它们将对此调用做出响应。让我们看看一个基本示例，它将一个字符串发送到worker：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s look at the worker that responds to this message by setting up an
    event handler for the message event:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个通过为消息事件设置事件处理器来响应此消息的worker：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `addEventListener()` function is implicitly called on something called a
    global dedicated worker context. We can think of this as the window object for
    web workers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener()` 函数在全局专用工作线程上下文中隐式调用。我们可以将其视为 Web Worker 的窗口对象。'
- en: Message serialization
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息序列化
- en: The message data that gets passed from the main thread to worker threads goes
    through a serialization transformation. When this serialized data arrives at the
    worker thread, it's deserialized, and the data is usable as a JavaScript primitive
    type. The same process is in place when the worker thread wants to send data back
    to the main thread.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从主线程传递到工作线程的消息数据会经过序列化转换。当这个序列化数据到达工作线程时，它会进行反序列化，数据就可以作为 JavaScript 原始类型使用。当工作线程想要将数据发送回主线程时，也存在同样的过程。
- en: Needless to say, this is an added step that adds overhead to our possibly already
    over-worked application. Therefore, some thought must be put into passing data
    back and forth between threads, as this is not a free operation in terms of CPU
    cost. Throughout the web worker code examples in this book, we'll treat message
    serialization as a key factor in our concurrency decision-making process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这增加了一个额外的步骤，可能会给我们的应用程序增加负担。因此，在线程间传递数据时，我们必须仔细考虑，因为这并不是一个免费的 CPU 成本操作。在这本书的整个
    Web Worker 代码示例中，我们将把消息序列化视为我们并发决策过程中的一个关键因素。
- en: So the question is—why go to such lengths? If the workers that we're using in
    our JavaScript code are simply threads, we should technically be able to use the
    same objects, since these threads use the same section of memory addresses. When
    threads share resources, such as objects in memory, challenging resource contention
    scenarios are likely to occur. For example, if one worker locks an object and
    another tries to use it, then this is an error. We have to implement logic that
    gracefully waits for the object to become available, and we have to implement
    logic in the worker that frees the locked resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是——为什么要走这么长的路？如果我们使用的 JavaScript 代码中的工作线程仅仅是线程，那么从技术上讲，我们应该能够使用相同的对象，因为这些线程使用相同的内存地址部分。当线程共享资源，如内存中的对象时，很可能会出现资源竞争的场景。例如，如果一个工作线程锁定了一个对象，而另一个工作线程试图使用它，那么这就是一个错误。我们必须实现逻辑，优雅地等待对象变得可用，并且我们必须在工作线程中实现释放锁定资源的逻辑。
- en: 'In short, this is an error prone headache that we''re much better off without.
    Thankfully, there''s no resources shared between threads—only serialized messages.
    This means that we''re limited in terms of what types of things can actually be
    passed to a worker. The rule of thumb is that it''s generally safe to pass something
    that can be encoded as a JSON string. Remember, the worker has to reconstruct
    the object from this serialized string, so a string representation of a function
    or a class instance, simply will not work. Let''s look at an example to see how
    this works. First, a simple worker to log the messages it receives:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一个容易出错且令人头疼的问题，我们最好避免它。幸运的是，线程之间没有共享资源——只有序列化的消息。这意味着我们在将哪些类型的数据传递给工作线程方面受到限制。一般来说，传递可以编码为
    JSON 字符串的东西是安全的。记住，工作线程必须从这个序列化字符串中重建对象，所以函数或类实例的字符串表示形式将不起作用。让我们通过一个例子来看看这是如何工作的。首先，一个简单的用于记录接收到的消息的工作线程：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s see what kind of data we can serialize and send to this worker using
    `postMessage()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们可以使用 `postMessage()` 将什么类型的数据序列化并发送到这个工作线程：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, there's a slight problem when we try to pass a function to `postMessage()`.
    This type cannot be reconstructed once it arrives on the worker thread, and so,
    `postMessage()` simply throws an exception. These types of restrictions may seem
    overly limiting, but they do eliminate the possibility of many concurrency issues.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当我们尝试将一个函数传递给 `postMessage()` 时，会出现一点小问题。这种类型的数据一旦到达工作线程，就无法重建，因此 `postMessage()`
    简单地抛出一个异常。这类限制可能看起来过于严格，但它们确实消除了许多并发问题的可能性。
- en: Receiving messages from workers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从工作线程接收消息
- en: Without the ability to pass data back into the main thread, workers aren't all
    that useful to us. At some point, the work performed by a worker needs to be reflected
    in the UI. We may recall that worker instances are event targets. This means that
    we can listen for the message event and respond accordingly when the worker sends
    back data. Think of this as the inverse of sending data to the worker. The worker
    simply treats the main thread as another worker by posting messages to it, while
    the main thread listens for messages. The same serialization restrictions that
    we explored in the preceding section are relevant here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有将数据传回主线程的能力，工作者对我们来说并不那么有用。在某个时候，工作者执行的工作需要在UI中反映出来。我们可能会记得工作者实例是事件目标。这意味着我们可以监听消息事件，并在工作者发送回数据时相应地做出反应。把这看作是向工作者发送数据的逆过程。工作者只是通过向其发送消息将主线程视为另一个工作者，而主线程则监听消息。我们在前一节中探讨的相同的序列化限制在这里也是相关的。
- en: 'Let''s look at some worker code that sends a message back to the main thread:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些将消息发送回主线程的工作者代码：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, this worker starts, and after 2 seconds, sends a string back
    to the main thread. Now, let''s see how we can handle these incoming messages
    in the main page JavaScript:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这个工作者启动后，2秒后向主线程发送一个字符串。现在，让我们看看我们如何在主页面JavaScript中处理这些传入的消息：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that we do not explicitly terminate any of our worker threads.
    This is okay. When the browsing context is terminated, all active worker threads
    are terminated with it. We can explicitly terminate workers using the `terminate()`
    method, which will explicitly stop the thread without waiting for any existing
    code to complete. However, it's rare to explicitly terminate workers. Once created,
    workers generally survive the duration of the page. Spawning workers isn't free,
    it incurs overhead, so we should aim to only do this once, if possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有明确终止任何我们的工作者线程。这是可以的。当浏览上下文被终止时，所有活跃的工作者线程都会随之终止。我们可以使用`terminate()`方法显式地终止工作者，这将显式地停止线程，而无需等待现有代码完成。然而，显式终止工作者是罕见的。一旦创建，工作者通常会在页面的整个生命周期中存活。启动工作者不是免费的，它会产生开销，因此我们应该尽可能只做一次。
- en: Sharing application state
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享应用程序状态
- en: In this section, we'll introduce shared workers. First, we'll look at how the
    same data objects in memory can be accessed by multiple browsing contexts. Then,
    we'll look at fetching remote resources, and how to notify multiple browsing contexts
    about the arrival of new data. Finally, we'll look at how shared workers can be
    leveraged to allow for direct messaging between browser contexts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍共享工作者。首先，我们将探讨内存中相同的数据对象如何被多个浏览上下文访问。然后，我们将探讨获取远程资源，以及如何通知多个浏览上下文关于新数据到达的消息。最后，我们将探讨如何利用共享工作者来实现浏览器上下文之间的直接消息传递。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Consider this section advanced material for experimental coding. The browser
    support for shared workers isn't that great at the moment (only Firefox and Chrome).
    Web workers are still in the candidate recommendation phase at the W3C. Once they
    become a recommendation and better browser support is in place for shared workers,
    we'll be ready to use them. For extra motivation, as the service worker spec matures,
    shared worker proficiency will be all the more relevant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请将本节视为实验性编码的高级材料。目前浏览器对共享工作者的支持并不太好（只有Firefox和Chrome）。Web工作者在W3C仍处于候选推荐阶段。一旦它们成为推荐，并且对共享工作者的浏览器支持更好，我们就可以开始使用它们了。为了额外的动力，随着服务工作者规范的成熟，共享工作者的熟练度将变得更加相关。
- en: Sharing memory
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存
- en: The serialization mechanism that we've seen so far with web workers is in place
    because we cannot directly reference the same object from more than one thread.
    However, shared workers have a memory space that's not restricted to just one
    page, which means that we can indirectly access these objects in memory through
    various message-passing methods. In fact, this is a good opportunity to demonstrate
    how we pass messages using ports. Let's get down to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Web工作者中看到的序列化机制存在，因为我们不能直接从多个线程引用相同的对象。然而，共享工作者有一个不受单个页面限制的内存空间，这意味着我们可以通过各种消息传递方法间接访问这些内存中的对象。实际上，这是一个展示我们如何使用端口传递消息的好机会。让我们开始吧。
- en: The notion of a port is necessary with shared workers. Without them, there would
    be no governing mechanism to control the inflow and outflow of messages from shared
    workers. For example, let's say we had three pages using the same shared worker,
    then we would have to create three ports to communicate with this worker. Think
    of a port as a gateway into the worker from the outside world. It's a minor indirection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享工作者的场景中，端口的观念是必要的。没有它们，就没有控制共享工作者消息流入和流出的管理机制。例如，假设我们有三个页面使用相同的工作者，那么我们就需要创建三个端口来与这个工作者进行通信。将端口想象成从外部世界进入工作者的一个网关。这是一个小的间接操作。
- en: 'Here''s a basic shared worker to give us an idea of what''s involved with setting
    up these types of workers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的共享工作者示例，让我们了解设置这类工作者涉及的内容：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There''s a `connect` event that gets triggered once a page connects with this
    worker. The `connect` event has a `source` property, and this is a message port.
    We have to tell it that the worker is ready to communicate with it by calling
    `start()`. Notice that we have to call `postMessage()` on a port, not in the global
    context. How else would the worker know which page to send the message to? The
    port acts as a proxy between the worker and the page, as illustrated in the following
    diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`connect`事件，一旦页面与这个工作者连接就会被触发。`connect`事件有一个`source`属性，这是一个消息端口。我们必须通过调用`start()`来告诉工作者它准备好与之通信。注意，我们必须在端口上调用`postMessage()`，而不是在全局上下文中。否则，工作者如何知道要将消息发送到哪个页面？端口在工作者和页面之间充当代理，如下面的图示所示：
- en: '![Sharing memory](img/B05133_05_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![共享内存](img/B05133_05_06.jpg)'
- en: 'Now let''s see how we can use this shared worker from more than one page:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从多个页面使用这个共享工作者：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are only two major differences between this shared worker and a dedicated
    worker. They are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与专用工作者相比，这种共享工作者只有两个主要区别。具体如下：
- en: We have a `port` object that we can use to communicate with the worker by posting
    messages and attaching event listeners.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个`port`对象，我们可以通过发布消息和附加事件监听器来与工作者进行通信。
- en: We tell the worker that we're ready to start communication by calling the `start()`
    method on the port, just like the worker does. Think of these two `start()` calls
    as a handshake between the shared worker, and its new client.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在端口上调用`start()`方法来告诉工作者我们已准备好开始通信，就像工作者做的那样。将这些`start()`调用想象成共享工作者和其新客户端之间的握手。
- en: Fetching resources
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源获取
- en: 'The preceding example gave us a taste of how different pages from the same
    application can share data, avoiding the need to allocate the exact same structure
    twice any time a page is loaded. Let''s build on this idea and use a shared worker
    to fetch remote resources to share the result with any pages that depend on it.
    Here''s the worker code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子让我们尝到了来自同一应用程序的不同页面如何共享数据，避免了每次页面加载时都需要分配完全相同的结构。让我们在此基础上构建，并使用共享工作者来获取远程资源，以便与任何依赖它的页面共享结果。以下是工作者代码：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of responding to the port when the page connects to the worker, we simply
    store a reference to it in the `ports` array. This is how we keep track of the
    pages connected to the worker, which is important here because not all messages
    follow the command-response pattern. In this case, we want to broadcast the updated
    API resource to any page that maybe listening to it. A common case will be one
    page, but in the case where there are many browser tabs open looking at the same
    application, we can use the same data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面连接到工作者时，我们不是响应端口，而是简单地将其引用存储在`ports`数组中。这就是我们跟踪连接到工作者的页面的方式，这在当前情况下很重要，因为并非所有消息都遵循命令-响应模式。在这种情况下，我们希望向任何可能监听它的页面广播更新的API资源。一个常见的情况是一个页面，但在有多个浏览器标签页打开查看同一应用程序的情况下，我们可以使用相同的数据。
- en: 'For example, if the API resource were a large JSON array that needed to be
    parsed, this would get wasteful if the exact same data needs to be parsed by three
    different browser tabs. Another savings is that we''re not polling the API 3 times
    per second, which would be the case if each page was running its own polling code.
    When it''s in the shared worker context, it only happens once, and the data is
    distributed out to the connected pages. This is less taxing on the back-end as
    well because in the aggregate, there are far fewer requests made. Let''s look
    at the code that uses this worker now:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果API资源是一个需要解析的大型JSON数组，如果需要由三个不同的浏览器标签页解析相同的数据，这将变得非常低效。另一个节省之处在于我们不是每秒对API进行三次轮询，如果每个页面都运行自己的轮询代码，就会是这样。在共享工作者上下文中，它只发生一次，并将数据分发到连接的页面。这也减轻了后端的负担，因为在总体上，请求的数量要少得多。现在让我们看看使用此工作者的代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Communicating between pages
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面间的通信
- en: So far, we've treated data within shared workers as a central resource. That
    is, it comes from a centralized place, such as an API, and then it is read by
    the pages connected to the worker. We haven't actually modified any data directly
    from a page yet. For instance, let's say we're not even connected to a back-end,
    and a page is manipulating a data structure in the shared worker. Other pages
    would then need to know about these changes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将共享工作者中的数据视为中央资源。也就是说，它来自一个集中位置，例如API，然后由连接到工作者的页面读取。我们还没有直接从页面直接修改任何数据。例如，假设我们甚至没有连接到后端，并且一个页面正在共享工作者中操作一个数据结构。其他页面随后需要了解这些更改。
- en: 'But then, let''s say the user switches to one of these pages and makes some
    adjustments. We have to support bidirectional updating. Let''s take a look at
    how we will go about implementing such capabilities using a shared worker:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设用户切换到这些页面之一并做一些调整。我们必须支持双向更新。让我们看看我们将如何使用共享工作者来实现这些功能：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This worker is nothing more than a satellite; it simply transmits anything
    it receives to all connected ports. This is all we need, so why add more? Let''s
    take a look at the page code that connects to this worker:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作者不过是一个卫星；它只是将接收到的任何内容传输到所有连接的端口。这就是我们所需要的，为什么还要添加更多呢？让我们看看连接到这个工作者的页面代码：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Interesting! So now, if we go ahead and open up two or more browser tabs with
    this page inside, any changes we make to the input value will be reflected in
    other pages—instantly. What's neat about this design is that it works the same;
    no matter which page is performing the update, any other page receives the updated
    data. In other words, the pages take on the dual role of data producer and data
    consumer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人兴奋！现在，如果我们打开两个或更多带有此页面的浏览器标签页，我们对输入值所做的任何更改都会立即反映在其他页面上。这个设计的巧妙之处在于它的工作方式相同；无论哪个页面正在执行更新，任何其他页面都会接收到更新后的数据。换句话说，页面承担着数据生产者和数据消费者的双重角色。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the worker in this last example sends a message to
    to all ports, including the port that sent the message. We probably don't want
    to do this. To avoid sending messages to the sender, we would need to somehow
    exclude the sending port in the `for..of` loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这个最后的例子中，工作者向所有端口发送消息，包括发送消息的端口。我们可能不想这样做。为了避免向发送者发送消息，我们需要在`for..of`循环中排除发送端口。
- en: This actually isn't easy to do since no port-identifying information is sent
    with the `message` event. We can establish port identifiers and have messages
    contain IDs. There's a lot of work here, and the benefit isn't all that great.
    The concurrency design trade-off here is to simply check in the page code that
    the message is actually relevant to the page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不容易做，因为`message`事件中没有发送任何端口标识信息。我们可以建立端口标识，并让消息包含ID。这里有很多工作要做，而且好处并不大。这里的并发设计权衡是在页面代码中简单地检查消息是否确实与页面相关。
- en: Performing sub-tasks with sub-workers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子工作者执行子任务
- en: All the workers that we've created so far in this chapter—dedicated workers
    and shared workers—were launched by the main thread. In this section, we'll address
    the idea of sub-workers. They're similar to dedicated workers, only with a different
    creator. For example, a sub-worker can't directly interact with the main thread,
    only by proxy through the thread that spawned the sub-worker.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们创建的所有工作者——专用工作者和共享工作者——都是由主线程启动的。在本节中，我们将讨论子工作者的概念。它们与专用工作者类似，只是创建者不同。例如，子工作者不能直接与主线程交互，只能通过创建子工作者的线程进行代理。
- en: We'll look at dividing larger tasks into smaller ones, and we'll also look at
    some challenges surrounding sub-workers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将较大的任务分解成较小的任务，并还将探讨围绕子工作者的一些挑战。
- en: Dividing work into tasks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作分解为任务
- en: The job of our web workers is to carry out tasks in such a way that the main
    thread can continue to service things, such as DOM events, without interruption.
    Some tasks are straightforward for a web worker thread to handle. They take input,
    compute a result, and return that result as output. But, what if the task is larger?
    What if it involves a number of smaller discrete steps, allowing us to breakdown
    the larger task into smaller ones?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络工作者（web workers）的职责是以一种方式执行任务，使得主线程可以继续服务其他事物，例如DOM事件，而不会被打断。有些任务对于网络工作者线程来说处理起来很简单。它们接收输入，计算结果，并将结果作为输出返回。但是，如果任务更大呢？如果它涉及多个较小的离散步骤，允许我们将较大的任务分解成较小的任务呢？
- en: With tasks like these, it makes sense to break them down into smaller sub-tasks
    so that we can further leverage all available CPU cores. However, decomposing
    the task into smaller ones can itself incur a heavy performance penalty. If the
    decomposition is left in the main thread, our user experience could suffer. One
    technique that we would utilize here involves launching a web worker whose job
    is to break down a task into smaller steps and launch a sub-worker for each of
    these steps.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的任务，将其分解成更小的子任务是有意义的，这样我们就可以进一步利用所有可用的CPU核心。然而，将任务分解成更小的任务本身可能会带来沉重的性能惩罚。如果分解留在主线程中，我们的用户体验可能会受到影响。我们将会利用的一种技术是启动一个网络工作者，其任务是分解任务成更小的步骤，并为每个步骤启动一个子工作者。
- en: 'Let''s create a worker that searches an array for a specific item and returns
    true if the item exists. If the input array is large, we would split it into several
    smaller arrays, each of which is searched in parallel. These parallel search tasks
    will be created as sub-workers. First, we''ll take a look at the sub-worker:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个工作者，它在数组中搜索特定项，如果该项存在则返回true。如果输入数组很大，我们会将其分成几个较小的数组，每个数组都并行搜索。这些并行搜索任务将被创建为子工作者。首先，我们将看看子工作者：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, we now have a sub-worker that can take a chunk of an array and return a
    result. This is pretty simple. Now for the tricky part, let's implement the worker
    that divides the input array into smaller inputs, which are then fed into the
    sub-workers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个子工作者，它可以处理数组的一部分并返回结果。这很简单。现在到了棘手的部分，让我们实现一个将输入数组分解成更小输入的工作者，这些输入随后被喂给子工作者。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What's neat about this approach is that once we have a positive result, we can
    terminate all the existing sub-workers. So, if we work through an especially large
    data set, we can avoid having one or more sub-workers churn needlessly in the
    background.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，一旦我们得到一个肯定的结果，我们就可以终止所有现有的子工作者。所以，如果我们处理一个特别大的数据集，我们可以避免在后台让一个或多个子工作者无谓地运行。
- en: The approach that we've taken here is to slice the input array into four proportional
    (25%) chunks. This way, we limit the concurrency level to four. In the next chapter,
    we'll further address subdividing tasks and tactics for determining the concurrency
    level to use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的方法是将输入数组切成四个比例（25%）的块。这样，我们限制并发级别为四。在下一章中，我们将进一步讨论细分任务和确定使用并发级别的策略。
- en: 'For now, let''s complete our example by writing some code to use this worker
    on our page:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编写一些代码来完成我们的示例，以便在页面上使用这个工作者：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We're able to talk to the worker, passing it an input array and data to search
    for. The results are passed by to the main thread, and they include the search
    term, so we're able to reconcile the output with the original message that we
    sent to the worker. However, there are some significant hurdles to overcome here.
    While this is really useful, being able to subdivide tasks to make better use
    of multi-core CPUs, there's a lot of complexity involved. Once we have the results
    from each subworker, we have to deal with reconciliation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够与工作者通信，传递给它一个输入数组和要搜索的数据。结果被传递到主线程，并且包括搜索词，这样我们就能将输出与发送给工作者的原始消息进行匹配。然而，这里有一些重大的障碍需要克服。虽然这确实很有用，能够细分任务以更好地利用多核CPU，但其中涉及了很多复杂性。一旦我们得到了每个子工作者的结果，我们就必须处理协调问题。
- en: If this simple example can grow as complex as it has, then imagine similar code
    in the context of a large application. There are two angles from which we can
    tackle these concurrency issues. The first is the up-front design challenges around
    concurrency. These are tackled in the next chapter. Then, there are the synchronization
    challenges—how do we avoid callback hell? This topic is addressed in depth, in
    [Chapter 7](ch07.html "Chapter 7. Abstracting Concurrency"), *Abstracting Concurrency*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个简单的例子可以变得像现在这样复杂，那么想象一下在大型应用程序上下文中类似的代码。我们可以从两个角度来处理这些并发问题。第一个是关于并发的初步设计挑战。这些将在下一章中解决。然后，还有同步挑战——我们如何避免回调地狱？这个主题在[第7章](ch07.html
    "第7章。抽象并发")*抽象并发*中进行了深入探讨。
- en: A word of caution
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告
- en: While the preceding example is a powerful concurrency technique that can offer
    huge performance gains, there are a couple downsides to be aware of. So before
    diving into an implementation that involves sub-workers, consider some of these
    challenges and the trade-offs that you'll have to make.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子是一个强大的并发技术，可以提供巨大的性能提升，但也有一些需要注意的缺点。所以在深入涉及子工作者实现的实现之前，考虑一下这些挑战和你必须做出的权衡。
- en: Sub-workers don't have a parent page to directly communicate with. This complicates
    designs because even a simple response from a sub-worker needs to be proxied through
    a worker that was created directly by JavaScript running in the main thread. What
    this leads to is a pile of tangled communication paths. In other words, it's easy
    to complicate the design by adding more moving parts than might actually be warranted.
    So, before deciding on sub-workers as a design option, let's first rule out an
    approach that can rely on dedicated workers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 子工作者没有直接与其通信的父页面。这使设计变得复杂，因为即使是子工作者的一个简单响应也需要通过一个由主线程中运行的JavaScript直接创建的工作者代理。这导致了一系列复杂的通信路径。换句话说，通过添加比实际需要的更多移动部件，很容易使设计复杂化。因此，在决定将子工作者作为设计选项之前，让我们首先排除一个可以依赖于专用工作者的方法。
- en: The second problem is that since web workers are still a candidate W3C recommendation,
    not all browsers implement certain aspects of web workers consistently. Shared
    workers and sub-workers are the two areas we're likely to encounter cross-browser
    issues. On the other hand, dedicated workers have great browser support and behave
    consistently across most vendors. Once again, start with a simple dedicated worker
    design, and if that doesn't work, think about introducing shared workers, and
    sub-workers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，由于Web工作者仍然是一个候选的W3C推荐，并非所有浏览器都一致地实现了Web工作者的某些方面。共享工作者和子工作者是我们可能会遇到跨浏览器问题的两个领域。另一方面，专用工作者得到了大多数浏览器的良好支持，并且在大多数供应商之间表现一致。再次强调，从一个简单的专用工作者设计开始，如果不起作用，再考虑引入共享工作者和子工作者。
- en: Error handling in web workers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web工作者中的错误处理
- en: All the code in this chapter has made a naive assumption that the code running
    in our workers was error-free. Obviously, our workers will encounter situations
    where exceptions are thrown, or we'll just write buggy code during development—it's
    the reality we face as programmers. However, without proper error event handlers
    in place, web workers can be difficult to debug. Another approach we can take
    is to explicitly send back a message that identifies itself as being in an error
    state. We'll cover these two error-handling topics in this section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都做了一个天真假设，即运行在我们工作者中的代码是无错误的。显然，我们的工作者会遇到抛出异常的情况，或者我们在开发过程中可能会编写出有错误的代码——这是我们作为程序员面临的现实。然而，如果没有适当的错误事件处理器，调试Web工作者可能会变得困难。我们可以采取的另一方法是明确发送一个消息，表明它处于错误状态。在本节中，我们将介绍这两个错误处理主题。
- en: Error condition checking
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误条件检查
- en: 'Let''s say our main application code sends a message to a worker thread and
    expects to get some data in return. What if something goes wrong and the code
    that was expecting data needs to know about it? One possibility is to still send
    the message that the main thread is expecting; only that it has a field that indicates
    the errant state of the operation. The following illustration gives us an idea
    of what this looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的主应用程序代码向工作者线程发送一个消息，并期望得到一些数据作为回应。如果出了问题，需要让期待数据的代码知道这一点怎么办？一个可能性是仍然发送主线程期望的消息；只是它有一个字段表示操作的错误状态。以下插图为我们提供了这个样子的一些想法：
- en: '![Error condition checking](img/B05133_05_07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![错误条件检查](img/B05133_05_07.jpg)'
- en: 'Now let''s look at some code that implements this approach. First, the worker
    that determines the state of the message to return either a successful or an error
    state:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些实现这种方法的代码。首先，确定要返回的消息状态的工人，要么返回成功状态，要么返回错误状态：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This worker will always respond by posting a message, but it doesn''t always
    compute a result. First, it checks to make sure that the input value is acceptable.
    If it doesn''t get the array it''s expecting, it posts a message with the error
    state set. Otherwise, it posts the result like normal. Now, let''s write some
    code to use this worker:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工人总是会通过发送消息来响应，但它并不总是计算结果。首先，它检查输入值是否可接受。如果它没有得到期望的数组，它就会发送一个设置错误状态的消息。否则，它会像正常一样发送结果。现在，让我们编写一些代码来使用这个工人：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exception handling
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Even if we explicitly check for error conditions in our workers, as we did in
    the last example, there are cases where exceptions might be thrown. From the perspective
    of our main application thread, we need to handle these types of uncaught errors.
    Without the proper error-handling mechanism in place, our web workers will fail
    silently. Sometimes, it seems that the workers don't even load—dealing with this
    radio silence is a nightmare to debug.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在工人中明确检查错误条件，就像我们在上一个例子中所做的那样，仍然有可能抛出异常。从我们的主应用程序线程的角度来看，我们需要处理这些类型的未捕获错误。如果没有适当的错误处理机制，我们的Web
    Workers将默默地失败。有时，似乎工人甚至没有加载——处理这种无线电静默是一个噩梦，调试起来非常困难。
- en: 'Let''s take a look at an example that listens to the `error` event of a web
    worker. Here''s a web worker that tries to access a non-existent property:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个监听Web Worker的`error`事件的例子。这里有一个尝试访问不存在属性的Web Worker：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There''s no error-handling code here. All we''re doing is responding to a message
    by reading the `name` property and sending it back. Let''s take a look at some
    code that uses this worker, and how it can respond to exceptions raised in this
    worker:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有错误处理代码。我们只是在读取`name`属性并将其发送回去时响应消息。让我们看看一些使用这个工人并展示它如何响应在这个工人中引发的异常的代码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can see that the first message posted to the worker results in an exception
    being thrown within the worker. However, this exception is encapsulated within
    the worker—it isn't thrown in our main thread. Since we're listening to the `error`
    event in our main thread, we can respond accordingly. In this case, we simply
    log the error message. However, in other cases, we may need to take more elaborate
    corrective action, such as freeing resources or posting a different message to
    the worker.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到第一个发送给工人的消息导致工人在内部抛出异常。然而，这个异常被封装在工人内部——它并没有在我们的主线程中抛出。由于我们在主线程中监听`error`事件，我们可以相应地做出反应。在这种情况下，我们只是记录错误信息。然而，在其他情况下，我们可能需要采取更复杂的纠正措施，例如释放资源或向工人发送不同的消息。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the concept of parallel execution using web workers.
    Before web workers, there were no means for our JavaScript to utilize the multiple
    CPU cores found on most hardware today.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Web Workers进行并行执行的概念。在Web Workers出现之前，我们的JavaScript无法利用大多数硬件上找到的多个CPU核心。
- en: We started off with a high-level overview of what web workers are. They're operating-system-level
    threads at their foundation. From a JavaScript perspective, they're event targets
    where we can post messages and listen to `message` events. Workers come in three
    varieties—dedicated, shared, and sub-workers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对Web Workers的概述开始。它们是基于操作系统的线程。从JavaScript的角度来看，它们是事件目标，我们可以向它们发送消息并监听`message`事件。工人有三种类型——专用、共享和子工人。
- en: You then learned how to communicate with web workers by posting messages and
    listening to events. You learned that there's a limitation in place in terms of
    what can be passed in a message. This is due to the fact that all message data
    is serialized and reconstructed in the target thread.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了如何通过发送消息和监听事件与Web Workers进行通信。您了解到在消息中可以传递的内容存在限制。这是由于所有消息数据都在目标线程中进行序列化和重建。
- en: We wrapped up the chapter with a look at how to go about handling errors and
    exceptions in web workers. In the following chapter, we'll address the practical
    aspects of parallelization—the types of work should we perform in parallel, and
    the best way to implement it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查看如何在Web Workers中处理错误和异常的章节中结束了这一章。在下一章中，我们将讨论并行化的实际方面——我们应该并行执行哪些类型的工作，以及如何最好地实现它。
