<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer140">
			</div>
		</div>
		<div class="Content" id="_idContainer141">
			<h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>6. Understanding Core Concepts</h1>
		</div>
		<div class="Content" id="_idContainer169">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to apply timeouts and intervals to include asynchronous functionality in applications; identify the different browser event types; capture and handle user interaction; intercept and prevent events; impersonate events to improve application user experience; summarize the different browser supported input controls; and work with forms, form submission, and form event handling.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor272"/>Introduction</h1>
			<p>In the previous chapter, you were introduced to the many data types supported by the JavaScript language and runtime, including functions, JavaScript's most impressive first-class data type. Understanding the differences between data types is an important first step for building practical, efficient, and bug-free applications. Software applications have many forms and may have many uses. In its simplest form, an application may read parameters on execution, process the data, and return a response. It may not even interact with any other applications or outside services. Terminal commands are a good example of this. For instance, executing <strong class="source-inline">dir</strong> in a Windows command window or <strong class="source-inline">ls</strong> in a <strong class="source-inline">Linux Terminal</strong> would simply read the contents of a directory on the hard disk and display the details of those files and directories within the Terminal window. The Linux operating system is built on the premise of such very small and simple applications working together to create a much larger ecosystem. The converse of this may be modern multiplayer video games, which typically react to user interaction and receive streamed data from remote locations. The former of these concepts can be considered much like a function: input enters from the top and is output somewhere within the body, typically, the end of the function.</p>
			<p>JavaScript applications can facilitate both ends of this spectrum, and indeed, anything in between. Modern browsers are now fully capable of providing the foundations for immense and processor-intensive 3D multiplayer games, responding to data from numerous sources, but JavaScript is also frequently used for the simplest of tasks, such as formatting a <strong class="source-inline">string</strong> or rounding a <strong class="source-inline">number</strong>.</p>
			<p>At the core of all of these applications are <strong class="source-inline">events</strong>. Events, conceptually speaking, are triggers that execute code. This might, for example, be the ready state when a page has finished loading or a mouse event when the user clicks an element within the page. Typically, without events, functions won't know when to execute and, therefore, nothing can happen.</p>
			<p>Throughout this chapter, we will examine the options JavaScript provides for listening to and handling different types of events within the browser environment.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor273"/>Event Types</h1>
			<p>An event is simply a notification or a "<strong class="source-inline">triggered</strong>" alert within the JavaScript runtime. These notifications can represent practically anything but are a means to invoke one or more of your own functions when such an event occurs. </p>
			<p>When a web page loads, the browser will typically display content as soon as it is available. This means some content will be presented to the user before the entire page has finished downloading. The browser does this to prevent long-loading assets from withholding other content from being available to the user.</p>
			<p>Now, imagine you want to invoke a function immediately within a web page to rotate an image. JavaScript code embedded into a web page is able to run immediately once it has been parsed by the JavaScript engine, which could possibly be before the image in question is available. To overcome this conundrum, JavaScript provides an <strong class="source-inline">onload</strong> event, which is dispatched as soon as all the page's content has finished downloading. By refraining from invoking your function until this event has been dispatched, you can ensure that your image can be rotated.</p>
			<p>Of course, there are many other such events. Arguably, there are four specific types of events within the JavaScript ecosystem:</p>
			<ul>
				<li><strong class="bold">Timer events</strong> provide forced asynchronous functionality within your applications. They allow you to invoke a function after a period of time, either once or repeatedly.</li>
				<li><strong class="bold">Asynchronous events</strong>, such as <strong class="source-inline">callbacks</strong>, are dispatched when something has finished executing but has occurred in parallel to any other function execution in your application. This means the process has not stopped your application from doing other tasks.</li>
				<li><strong class="bold">Interaction events</strong>, such as <strong class="source-inline">DOM</strong> or keyboard events, are events that are dispatched due to the user interacting with your application.</li>
				<li><strong class="bold">Custom events</strong> are events that you create yourself. These can be almost anything but are usually created as a response to one of the JavaScript event types listed previously.</li>
			</ul>
			<p>The type of event you will require is very specific to a given use case. In this chapter, we will examine both timer-based events and interaction events.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor274"/>Timer Events</h2>
			<p>In some languages, such as C, the base application may be run using a continuous loop. In C, specifically, an application runs during the lifetime of its <strong class="source-inline">main</strong> function; when this function returns, the application exits. Typically, applications that need to run for some time and respond to events would utilize a simple loop. In fact, it's not uncommon to see applications start with something like this:</p>
			<p class="source-code">int main(int ac, char** av) {</p>
			<p class="source-code">    while (true) {</p>
			<p class="source-code">        // .. do stuff ..</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 1;</p>
			<p class="source-code">}</p>
			<p>Here, the application simply enters an indefinite loop. If the application needs to quit, it would call a command similar to JavaScript's <strong class="source-inline">break</strong> keyword. Otherwise, the application would quite happily run and invoke functions as needed.</p>
			<p>Applications written in C are able to do this for several reasons. The first is that C is a multi-threaded platform. This means that several processes, known as threads, can be created within a C application and may run concurrently, providing the underlying hardware it supports. In the worst-case scenario, these threads are cycled, allowing each one to utilize a period of execution time within the CPU. Another reason this is possible is that C applications run very close to the hardware and, unlike JavaScript, are unencumbered by a lower-level engine that dictates execution flow.</p>
			<p>Since a program can exist with a loop at its core, it stands to reason that functions will, or can, be called with each iteration. However, if a function was called indefinitely with every iteration, such a process may be overly resource-intensive or simply run too fast. An alternative is to make the function conditional by requiring it to execute only when enough time has passed since its last execution. This is the essential basis of a timer event.</p>
			<p>Unlike C, JavaScript is a <strong class="source-inline">single-threaded</strong> platform, meaning it can only execute a single thread throughout your entire application. A thread is an execution space in the CPU. If you have one thread, then only a single series of function executions can occur at once. In JavaScript, this does not mean the underlying engine doesn't use, or have access to, more than one thread; only that your application has programmatic access to one single thread.</p>
			<p>Since JavaScript runs within an engine, known as a virtual machine, it is driven by a number of rules that determine how your code is run. The JavaScript virtual machine follows an architecture known as an event loop. This means that the loop in the preceding C example is already occurring within the JavaScript engine that your application runs within. However, within that loop, the JavaScript engine manages code execution for each of the function calls your application makes, among other things, regardless of whether those calls invoke your own functions or those native to JavaScript.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor275"/>Exercise 6.01: Custom Timer</h2>
			<p>As we mentioned previously, many developers coming from lower-level languages will consider a loop as a means to create timed function invocations. If a loop can occur indefinitely, then we only need to check the current system time and invoke functions when sufficient time has passed. For instance, when animating, in order to control the <strong class="source-inline">speed</strong> of the animation, you may want to ensure your frame update functions are executed with a sufficient period of time between each invocation. Without this control, your animation frames will update with every possible cycle of the JavaScript runtime, which may be very fast on some machines, while not so fast on weaker machines. In this exercise, you will implement one such loop. Let's get started:</p>
			<ol>
				<li>To begin, you'll need three variables. The first will store the current time in milliseconds for each iteration, the second variable will contain the time in milliseconds of the last time the custom timer function executed, and the third variable will be the required minimal interval between timer function calls in milliseconds:<p class="source-code">var curTime, lastTime,</p><p class="source-code">  interval = 500;</p></li>
				<li>Next, we open the <strong class="source-inline">main</strong> function and the indefinite loop. Similar to the preceding example, we'll simply use a <strong class="source-inline">while</strong> loop and pass it a decrementing value:<p class="source-code">function main() {  // primary function</p><p class="source-code">  let running = true;  // loop running flag</p><p class="source-code">  while (running) {  // enter loop</p></li>
				<li>Now, the first thing that needs to happen with each iteration is that we need to get the current time in milliseconds and compare it to the last stored time:<p class="source-code">    curTime = new Date().getTime();</p><p class="source-code">    lastTime = lastTime || curTime;</p><p class="source-code">    if (curTime - lastTime &gt; interval) {</p><p>The <strong class="source-inline">lastTime</strong> variable, if it is <strong class="source-inline">null</strong>, will be passed the value of <strong class="source-inline">curTime</strong>. This way, it will execute correctly from its first iteration since <strong class="source-inline">null</strong> cannot be deducted from an <strong class="source-inline">integer</strong>.</p></li>
				<li>If the values are sufficiently different (greater than the <strong class="source-inline">interval</strong> amount), you can invoke your timed functions. You will then need to update the <strong class="source-inline">lastTime</strong> variable to equal the current time so that the function doesn't execute again in succession and instead waits for the next duration to occur:<p class="source-code">      console.log(curTime);</p><p class="source-code">      lastTime = curTime;</p><p class="source-code">      running = false;</p></li>
				<li>Finally, you close out the conditional, loop, and function:<p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>That's it. If you execute the function by calling <strong class="source-inline">main()</strong>, you will see the current time in milliseconds output to the console every <strong class="source-inline">500</strong> milliseconds:<p class="source-code">main(); // ==&gt; 1558632112316</p></li>
			</ol>
			<p>What you have just created is similar to an application loop. Many programming languages support the notion of an application loop. In fact, languages such as C++ require such a loop in order to prevent an application from exiting. In such circumstances, the loop is a simple "<strong class="source-inline">keep-alive</strong>" mechanism whereby checks for potential events occur manually within the loop. In JavaScript, such loops are unnecessary. This is because the JavaScript engine already enlists the help of such a loop under the hood, known as the event loop.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor276"/>Event Timers</h2>
			<p>The previous exercise exhibits perfectly legitimate code and would facilitate a working function invocation timer. However, creating timers in this fashion has a number of drawbacks. The first issue here is that since JavaScript is single-threaded, the entire application will be contained within the loop. There is no way to continue processing data outside of the loop without breaking out of it.</p>
			<p>The second issue in the previous exercise is that since the JavaScript engine is already running its own event loop, the example code is actually performing two infinite loops, one nested within the other:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer142">
					<img alt="Figure 6.1: Nested infinite event loop&#13;&#10;" src="image/C14377_06_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Nested infinite event loop</p>
			<p>Since delayed and repeated function invocation is a common programming requirement, the JavaScript language provides two functions that make timers simple without us having to construct our own loops. These are <strong class="source-inline">setInterval</strong> and <strong class="source-inline">setTimeout</strong>.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor277"/>The setInterval Function</h2>
			<p><strong class="source-inline">setInterval</strong> is a native implementation of our previous infinite loop. The premise is that, given a function and an interval value in milliseconds, JavaScript will repeatedly execute the function whenever the interval time has passed:</p>
			<p class="source-code">intervalReference = setInterval(timerFun, milliseconds);</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The time-based execution in JavaScript is "as near to" the interval value as possible. JavaScript is unable to guarantee absolute accuracy when executing triggers due to various limitations with the underlying hardware, operating system, and resource availability.</p>
			<p>We can reproduce our previous example with the following code:</p>
			<p class="source-code">var timerFunction = function() {</p>
			<p class="source-code">  var time = new Date().getTime();</p>
			<p class="source-code">  console.log(time);}</p>
			<p class="source-code">setInterval(timerFunction, 500);</p>
			<p class="source-code">// ==&gt; 1558632112316</p>
			<p>The function expression in this example will be executed <strong class="source-inline">500</strong> milliseconds after we call <strong class="source-inline">setInterval</strong> and every <strong class="source-inline">500</strong> milliseconds thereafter. It is executed asynchronously, so the code that follows the <strong class="source-inline">setInterval</strong> call is executed without delay:</p>
			<p class="source-code">function main() {</p>
			<p class="source-code">  setInterval(() =&gt; console.log("executed"), 500);</p>
			<p class="source-code">  console.log("after execution");</p>
			<p class="source-code">  console.log("another message");</p>
			<p class="source-code">}();// ==&gt;   after execution</p>
			<p class="source-code">// ==&gt;   another message</p>
			<p class="source-code">// ==&gt;   executed</p>
			<p class="source-code">// ==&gt;   executed</p>
			<p>The <strong class="source-inline">setInterval</strong> function itself, when invoked, returns a reference to the resulting interval handler, that is, the execution stack that invokes the passed <strong class="source-inline">callback</strong> function. This reference may be used to terminate the interval loop at any time using the <strong class="source-inline">clearInterval</strong> function:</p>
			<p class="source-code">var ref = setInterval(someFunc, 100);</p>
			<p class="source-code">clearInterval(ref);</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor278"/>The setTimeout Function</h2>
			<p>The <strong class="source-inline">setTimeout</strong> function works identically to the <strong class="source-inline">setInterval</strong> function, the difference being that its passed <strong class="source-inline">callback</strong> function is only ever called once. The <strong class="source-inline">setTimeout</strong> function is useful when animating elements within an HTML page, or when you wish to delay a process for a period of time, such as clearing a visible error message or dialog:</p>
			<p class="source-code">setTimeout(someFunc, 500);</p>
			<p>Like <strong class="source-inline">setInterval</strong>, the <strong class="source-inline">setTimeout</strong> function also returns a reference to its execution handler so that the timer can be cleared with <strong class="source-inline">clearTimeout</strong>. Since the <strong class="source-inline">setTimeout</strong> callback is only executed once, calling <strong class="source-inline">clearTimeout</strong> after the <strong class="source-inline">callback</strong> has executed has no effect. It is, however, possible to cancel <strong class="source-inline">setTimeout</strong> before it executes, which is a perfectly reasonable requirement:</p>
			<p class="source-code">var ref = setTimeout(() =&gt; console.log("fire!"), 200);</p>
			<p class="source-code">setInterval(function() {</p>
			<p class="source-code">  console.log("waiting...");</p>
			<p class="source-code">  clearTimeout(ref);</p>
			<p class="source-code">}, 100);</p>
			<p class="source-code">// ==&gt; waiting...</p>
			<p class="source-code">// ==&gt; waiting...</p>
			<p class="source-code">// ==&gt; waiting...</p>
			<p>The <strong class="source-inline">setTimeout</strong> function can be mimicked by the <strong class="source-inline">setInterval</strong> function by simply clearing its reference after its first timer iteration, like so:</p>
			<p class="source-code">var ref = setInterval(function() {</p>
			<p class="source-code">  console.log("Boo!");</p>
			<p class="source-code">  clearInterval(ref);</p>
			<p class="source-code">}, 500);</p>
			<p class="source-code">// ==&gt; Boo!</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor279"/>Timer Parameters</h2>
			<p>In modern browsers (excluding <strong class="source-inline">IE9</strong> and below), the <strong class="source-inline">setInterval</strong> and <strong class="source-inline">setTimeout</strong> functions may receive additional parameters. If any are supplied proceeding the interval parameter, those additional parameters will be passed as parameters to the <strong class="source-inline">callback</strong> function when it is invoked. This provides a useful means to customize timer functions:</p>
			<p class="source-code">var handler = function(p1, p2) {</p>
			<p class="source-code">  console.log(p1, p2);</p>
			<p class="source-code">};</p>
			<p class="source-code">setTimeout(handler, 100, "Hello,", "World!");</p>
			<p class="source-code">// ==&gt; Hello, World!</p>
			<p>If you anticipate older browsers running your scripts, the same effect may be attained by wrapping the passed <strong class="source-inline">callback</strong> within an anonymous function call:</p>
			<p class="source-code">setTimeout(function() {</p>
			<p class="source-code">  handler("Hello,", "World!");</p>
			<p class="source-code">}, 100);</p>
			<p class="source-code">// ==&gt; Hello, World!</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor280"/>Exercise 6.02: Real-Time Clock</h2>
			<p>It is now time to put your knowledge of timers to use. In this exercise, you will be creating a real-time in-page clock display that will count up in seconds and show the full time using a 24-hour digital clock format. This exercise will make use of an HTML file, albeit a simple one. Let's get started:</p>
			<ol>
				<li value="1">Create a new file called <strong class="bold">clock.html</strong>. Here, you'll add some very simple HTML. Firstly, add the opening document tag and the <strong class="source-inline">script</strong> tag:<p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;script&gt;</p><p>The <strong class="source-inline">script</strong> tag will contain the JavaScript to be executed within the page.</p></li>
				<li>Next, you'll need some placeholder variables for the <strong class="source-inline">seconds</strong>, <strong class="source-inline">minutes</strong>, <strong class="source-inline">hours</strong>, and the current <strong class="source-inline">Date</strong> object instance:<p class="source-code">    var secs, mins, hrs, date,</p></li>
				<li>The <strong class="source-inline">handler</strong> function you'll use for the timer will also be assigned to a variable called <strong class="source-inline">setTime</strong>. In it, you will simply populate the preceding variables with the current time components:<p class="source-code">    setTime = function() {</p><p class="source-code">      date = new Date();</p><p class="source-code">      hrs = date.getHours();</p><p class="source-code">      mins = date.getMinutes();</p><p class="source-code">      secs = date.getSeconds();</p></li>
				<li>To output the time to the page, you'll simply need to update the <strong class="source-inline">body</strong> content. There are better solutions to this that will be explained later in this module:<p class="source-code">    document.body.innerHTML = `${hrs}:${mins}:${secs}`;</p></li>
				<li>Finally, close the function and assign it to an interval. Set the interval to run every <strong class="source-inline">500</strong> milliseconds to ensure better accuracy:<p class="source-code">    }</p><p class="source-code">    setInterval(setTime, 500);</p></li>
				<li>With the <strong class="source-inline">script</strong> complete, you should close out the <strong class="source-inline">script</strong> tag block:<p class="source-code">  &lt;/script&gt;</p></li>
				<li>The page should end with a <strong class="source-inline">body</strong> tag block, which will contain the clock and the closing <strong class="source-inline">html</strong> tag:<p class="source-code">  &lt;body&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Now, save the page and load it (or drag it) into your browser. You should see the time displayed in the top left-hand corner of the page, and it should update every second. You have successfully built your first timer-based JavaScript application.</li>
			</ol>
			<p>Displaying a real-time clock on a web page is a practical application, particularly within corporate websites and intranets that may exhibit times for several time zones around the world. However, utilizing a timer to update page content is not limited to clocks. This same process could be utilized to update stock market prices, real-time chat forums, or just about any kind of real-time presentation.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor281"/>The JavaScript Events Model</h1>
			<p>As we noted previously, the JavaScript engine utilizes an event loop. In fact, events are at the center point of the JavaScript engine and its language. At its simplest definition, an event is a notification that something has occurred. This may be interaction by the user with a web page or the completion of some process that occurs within the browser.</p>
			<p>To make use of events, a <strong class="source-inline">callback</strong> function must be assigned to the event type, much like with the timer-based function. However, typically, events are a little more complex and feature-rich than simple timers.</p>
			<p>An event notification is known in programming as a dispatched event. When JavaScript events are dispatched, they are passed an event object. This is true of all JavaScript events. The event object contains useful details about the dispatched event, including the name of the event, a reference to the object that holds the context of the event, and a reference to the object that triggered the event.</p>
			<p>The following table lists the properties of the event object:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer143">
					<img alt="Figure 6.2:  Event Object properties&#13;&#10;" src="image/C14377_06_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2:  Event Object properties</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor282"/>Event Bubbling</h2>
			<p>In order to understand event bubbling, it helps if we understand browser-based HTML. HTML is an abbreviation for HyperText Markup Language, which itself is a derivative of eXtensible Markup Language (XML). HTML is not really a language at all, but a declarative information markup that structures data, which, in the case of websites, is page content.</p>
			<p>HTML is a hierarchical construct that can be best envisaged as a data tree. Imagine the following page content:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer144">
					<img alt="Figure 6.3: HTML mockup&#13;&#10;" src="image/C14377_06_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: HTML mockup</p>
			<p>The structure of the page consists of two columns. On the left is an image and on the right is a container with two rows; the first row contains three buttons and the second row contains a block of text. Like a tree, this layout may look something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer145">
					<img alt="Figure 6.4: HTML data tree&#13;&#10;" src="image/C14377_06_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: HTML data tree</p>
			<p>The preceding tree outlines the visible content of the page, but the <strong class="source-inline">body</strong> node is not the actual top of the literal HTML tree. Instead, the page content tree starts with a node called the <strong class="source-inline">document</strong>. This then has a child called <strong class="source-inline">html</strong>, and that node contains the <strong class="source-inline">body</strong> node.</p>
			<p>Each node within the HTML tree will raise events if interacted with, even if that node is not immediately visible. When clicking the page with your mouse, for instance, the visible node beneath the mouse arrow that is closest to the bottom of the tree will raise a <strong class="source-inline">click</strong> event. If one or more event handlers have been assigned to that node, then those handlers will be invoked and will be passed an <strong class="source-inline">event</strong> object.</p>
			<p>Event bubbling occurs when event handlers are not assigned to the node for that event type or if the event is handled but the event is allowed to continue propagating. At this point, the handlers of the parent node for that specific event are called, and the same process occurs. If the event continues to not be explicitly halted, it will <strong class="source-inline">bubble</strong> through each parent node until it reaches the <strong class="source-inline">document</strong> node.</p>
			<p>If multiple handlers exist on a given node for a specific event, any one of those handlers may halt the event, preventing it from bubbling. It is not required for all handlers to halt the event.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor283"/>Traversing the Node Tree</h2>
			<p>In order to handle an event, you first need to add an event type handler to a node. However, to do that, you need some way to acquire a reference to the node on which you wish to listen. JavaScript provides numerous functions for selecting and acquiring nodes based on many different factors, including direct named access, acquisition through node tree traversal, and acquisition by attribute value.</p>
			<p>Of all the nodes within your HTML pages, the easiest to acquire are the <strong class="source-inline">body</strong> and <strong class="source-inline">document</strong> nodes. Both of these nodes have simple attribute accessors on the global <strong class="source-inline">document</strong> object:</p>
			<p class="source-code">var document = document.documentElement;</p>
			<p class="source-code">var bodyNode = document.body;</p>
			<p class="source-code">console.log(bodyNode);</p>
			<p class="source-code">// ==&gt; &lt;body&gt;&lt;/body&gt;</p>
			<p>Once you have a reference to the top of the tree, acquiring a node elsewhere within the tree is simply a matter of traversing it. JavaScript provides several properties for acquiring a node's parent, siblings, or children, each of which uses the <strong class="source-inline">familiar relationship</strong> metaphor:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer146">
					<img alt="Figure 6.5: Node properties and their description&#13;&#10;" src="image/C14377_06_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Node properties and their description</p>
			<p>Each of these properties can be read from the given node. If a corresponding node cannot be found, then the property will return <strong class="source-inline">null</strong> (or an empty array in the case of <strong class="source-inline">childNodes</strong>):</p>
			<p class="source-code">var image = document.body.firstChild.firstChild;</p>
			<p class="source-code">image</p>
			<p class="source-code">// ==&gt; &lt;img src="./logo/packt.png" &gt;</p>
			<p class="source-code">var btn = image.parentNode.nextSibling.firstChild.childNodes[1];</p>
			<p class="source-code">btn</p>
			<p class="source-code">// ==&gt; &lt;button&gt;button 2&lt;/button&gt;</p>
			<h2 id="_idParaDest-256">Direct Node Acquisition<a id="_idTextAnchor284"/></h2>
			<p>Aside from node tree traversal, JavaScript also provides a means to specify the node reference you require by supplying a node property filter, which is a string value describing the node you require using a specific format.</p>
			<p>All HTML nodes follow a certain pattern:</p>
			<ul>
				<li>They are opened and closed, sometimes in a single tag.</li>
				<li>They have a node name or type.</li>
				<li>They may have an <a id="_idTextAnchor285"/>optional <strong class="source-inline">id</strong> property, which should be unique to the page.</li>
				<li>They may have one or more optional <strong class="source-inline">class</strong> names.</li>
				<li>They may have other optional known properties, such as <strong class="source-inline">name</strong>, <strong class="source-inline">styles</strong>, <strong class="source-inline">type</strong>, <strong class="source-inline">value</strong>, or <strong class="source-inline">src</strong>.</li>
				<li>They may have optional custom properties, named by the page creator.</li>
			</ul>
			<p>The node's signature is known as its <strong class="source-inline">tag</strong>, which is defined within angle brackets, with a left-facing angle bracket at the start of the node and a right-facing bracket at the end of the node. Immediately after the left-facing bracket is the node's name. Properties are appended to the node as <strong class="source-inline">attribute="value"</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer147">
					<img alt="Figure 6.6: HTML node structure&#13;&#10;" src="image/C14377_06_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: HTML node structure</p>
			<p>The closing tag of a node contains the node's name and is also wrapped with a left-facing and right-facing angle bracket. However, to differentiate it from a new opening tag, its left-facing angle bracket is preceded by a forward-slash (<strong class="source-inline">/</strong>) character.</p>
			<p>If a node has no children, it is acceptable to immediately close the node without supplying a distinct closing tag. This is accomplished by providing the forward-slash character immediately before the right-facing angle bracket:</p>
			<p class="source-code">&lt;img src="/images/flower.png" /&gt;</p>
			<p>The properties of a node are its description. Later, these values allow you to style the node's look-and-feel, but they specifically facilitate the node's data and identity. As such, it is perfectly legitimate to add attributes to nodes in order to make them easily acquirable. The <strong class="source-inline">id</strong> attribute is one such value that exists solely to differentiate tags and it is important that all the tags that are used within a page have a unique <strong class="source-inline">id</strong> attribute, if they have one at all. If an <strong class="source-inline">id</strong> attribute is present, the associated node can be acquired using the <strong class="source-inline">getElementById</strong> method of the <strong class="source-inline">document</strong> object:</p>
			<p class="source-code">var node = document.getElementById("myTagId");</p>
			<p>Since node IDs are deemed to be unique, the <strong class="source-inline">getElementById</strong> method returns a single node, or <strong class="source-inline">null</strong> if a matching node is not found. If, for some reason, a page contains multiple nodes with the same ID attribute value, then calling <strong class="source-inline">getElementById</strong> with that value will return the first element found within the page.</p>
			<p>Other similar functions exist in order to query using other tag descriptors, such as the <strong class="source-inline">name</strong> or <strong class="source-inline">class</strong>. The majority of these return an array since it is expected that many tags may share matching descriptors. The following table lists some of the common functions for acquiring tag references:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer148">
					<img alt="Figure 6.7: Common functions for tag references&#13;&#10;" src="image/C14377_06_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Common functions for tag references</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor286"/>Assigning and Removing an Event Handler</h2>
			<p>Once you have a node reference, you are then able to assign listeners (or handlers) for specific event types. Listeners can be assigned to a node using the <strong class="source-inline">addEventListener</strong> function, which accepts two parameters, the type of the event as a string value and the handler of the event as a function:</p>
			<p class="source-code">document.body.addEventListener("click", () =&gt; alert("I was clicked"));</p>
			<p>When an event is dispatched, the event handler is passed a single value, known as an event object. Event objects may have slightly different parameters depending on the event type being handled. The object is actually an instance of a specific event object type. For instance, mouse-based events, such as <strong class="source-inline">click</strong> or <strong class="source-inline">mousedown</strong>, generate <strong class="source-inline">MouseEvent</strong> objects. These differ from many other events in that they contain <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> values detailing the mouse coordinates within the web document at the time the event was dispatched:</p>
			<p class="source-code">document.body.addEventListener("click", function(evt) { console.log(evt); });</p>
			<p class="source-code">// ==&gt; MouseEvent {isTrusted: true, screenX: 230, screenY: 499, clientX: 163, clientY: 400, …}</p>
			<p>When attaching an event handler, it will not overwrite existing handlers attached to that node, even if the handler is assigned to the same event type. In fact, a node may have any number of event listeners attached at any one time. This way, multiple facets of your application can independently access the same event notifications for the same object, as needed. What is not possible, however, is for the same <strong class="source-inline">function reference</strong> to be assigned more than once to the same event type, like so:</p>
			<p class="source-code">var display = () =&gt; console.log("Clicked");</p>
			<p class="source-code">document.body.addEventHandler("click", () =&gt; console.log("I was clicked");</p>
			<p class="source-code">document.body.addEventHandler("click", () =&gt; console.log("I was clicked");</p>
			<p class="source-code">document.body.addEventHandler("click", display);</p>
			<p class="source-code">document.body.addEventHandler("click", display);  // this one will not be output</p>
			<p class="source-code">// ==&gt; I was clicked</p>
			<p class="source-code">// ==&gt; I was clicked</p>
			<p class="source-code">// ==&gt; Clicked</p>
			<p>In the preceding example, since the <strong class="source-inline">display</strong> function is a single reference, the second listener assignment was simply ignored. JavaScript will not repeat the function invocation more than once. However, the previous assignments were both invoked because, although the functionality was the same, the functions themselves possessed different references.</p>
			<p>If you wish to remove an event handler, you can do so with the <strong class="source-inline">removeEventListener</strong> method, which takes identical parameters to its counterpart:</p>
			<p class="source-code">document.body.removeEventListener("click", display);</p>
			<p>The <strong class="source-inline">removeEventListener</strong> method finds the handler association by reference. This means that any event listener assignments you make using anonymous functions cannot be removed using the <strong class="source-inline">removeEventListener</strong> method.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you dispose of a node that has event handlers attached to it, it will not be cleaned up by the JavaScript engine's <strong class="source-inline">garbage Collector</strong>. Removing nodes without cleaning up their event handlers is a common cause of memory leaks in JavaScript, which leads to poor application performance. If you know a node may be removed from the <strong class="source-inline">DOM</strong>, do not add event listeners to it, or its children, using anonymous functions.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor287"/>Exercise 6.03: Tabbed Content</h2>
			<p><a id="_idTextAnchor288"/>In this exercise, you'll use what you have learned so far to create a tabbed display. The display will utilize three buttons at the top of the page, with a container <strong class="source-inline">div</strong> tag at the bottom. When a button is pressed, content associated with the button handler will be displayed within the container <strong class="source-inline">div</strong> tag. Let's get started:</p>
			<ol>
				<li value="1">First, create a new document called <strong class="bold">tabs.html</strong> and add the starting HTML:<p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;title&gt;Tabbed Display&lt;/title&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p></li>
				<li>The three buttons will sit side by side in a single container <strong class="source-inline">div</strong>. Each one will have a unique ID so that we can easily reference them:<p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;button id="btn1"&gt;Tab One&lt;/button&gt;</p><p class="source-code">      &lt;button id="btn2"&gt;Tab Two&lt;/button&gt;</p><p class="source-code">      &lt;button id="btn3"&gt;Tab Three&lt;/button&gt;</p><p class="source-code">    &lt;/div&gt;</p></li>
				<li>Next, add the container <strong class="source-inline">div</strong>. We'll add a descriptive body to inform the user of the page. However, once a button has been pressed, that content will disappear for good and will be replaced by dynamic content:<p class="source-code">    &lt;div id="container"&gt;Click a button!&lt;/div&gt;</p></li>
				<li>With the structure of the page in place, you can now close out the body and begin the <strong class="source-inline">script</strong> block:<p class="source-code">  &lt;/body&gt;  &lt;script&gt;    var btn1 = document.getElementById("btn1"),</p><p class="source-code">      btn2 = document.getElementById("btn2"),</p><p class="source-code">      btn3 = document.getElementById("btn3"),</p><p class="source-code">      container = document.getElementById("container");</p><p>Here, we've created a variable for each element in the page we need to interact with. This makes the code neater and cleaner.</p></li>
				<li>Next, you'll need some content to add when the buttons are pressed, one for each button:<p class="source-code">    var content1 = "Button 1 was pressed",</p><p class="source-code">      content2 = "Button 2 was pressed",</p><p class="source-code">      content3 = "Button 3 was pressed";</p></li>
				<li>Now, we need to wire up the content. To do this, simply add an event listener to each button, updating the container <strong class="source-inline">div</strong> content in each one:<p class="source-code">    btn1.addEventListener("click", () =&gt; container.innerHTML = content1);</p><p class="source-code">    btn2.addEventListener("click", () =&gt; container.innerHTML = content2);</p><p class="source-code">    btn3.addEventListener("click", () =&gt; container.innerHTML = content3);</p></li>
				<li>Now, simply close out the open tags and save the page:<p class="source-code">  &lt;/script&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>That's it. If you now run the page in your browser and click each button, you should see that the content has been updated. <p>The interactive page is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer149">
					<img alt="Figure 6.8: Tabbed control exercise&#13;&#10;" src="image/C14377_06_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Tabbed control exercise</p>
			<p>This has been your first exploration of interactive content. Manipulating page content based on user interactivity is a common requirement for JavaScript and is something it excels at. Through careful planning and good coding practices, it is possible to create JavaScript applications that can mimic almost any kind of native software application.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor289"/>Bubbling versus Capturing</h2>
			<p>So far, you've seen that event bubbling is where an event bubbles up from the node that dispatched it to the top of the tree, but JavaScript also provides an alternative to bubbling called capturing.</p>
			<p><strong class="source-inline">Event capturing</strong> is where events are handled in the reverse order to bubbling, capturing notifications from the node that dispatched it to the bottom of the tree. This means that, when a node is interacted with, its attached event handlers may not be the first to intercept the event. Instead, a parent (or ancestor) may receive the event first, instead. If one of those ancestral handlers halts the event, then the handlers on the node that gave rise to the event may never actually be invoked at all:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer150">
					<img alt="Figure 6.9: Bubbling versus capturing&#13;&#10;" src="image/C14377_06_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Bubbling versus capturing</p>
			<p>To attach an event handler to a capture event, you simply need to pass a third parameter to the <strong class="source-inline">addEventListener</strong> method. This third parameter is known as the <strong class="source-inline">useCapture</strong> parameter and is a Boolean. If set to <strong class="source-inline">true</strong>, the attached event will be assigned in <strong class="source-inline">capture</strong> mode. Thus, not supplying the <strong class="source-inline">useCapture</strong> parameter to the <strong class="source-inline">addEventListener</strong> method is the same as supplying <strong class="source-inline">false</strong> for that parameter:</p>
			<p class="source-code">var clickHandler = () =&gt; console.log("clicked");</p>
			<p class="source-code">document.body.addEventListener("click", clickHandler);</p>
			<p class="source-code">// ==&gt; clicked</p>
			<p>Event handlers that are attached to capture events sit in a different space to bubbling event listeners. When assigning capturing events, they will not conflict with bubbling events. Therefore, assigning a function reference as an event handler as both bubbling and capturing, using the same event type on the same node, will mean that function will be called twice when that event is dispatched:</p>
			<p class="source-code">var clickHandler = () =&gt; console.log("clicked");</p>
			<p class="source-code">document.body.addEventListener("click", clickHandler);</p>
			<p class="source-code">document.body.addEventListener("click", clickHandler, true);</p>
			<p class="source-code">// ==&gt; clicked</p>
			<p class="source-code">// ==&gt; clicked</p>
			<p>To remove an event that's been added with <strong class="source-inline">useCapture</strong> set to <strong class="source-inline">true</strong>, you simply pass the same <strong class="source-inline">useCapture</strong> value to the <strong class="source-inline">removeEventListener</strong> method:</p>
			<p class="source-code">document.body.removeEventListener("click", clickHandler, true);</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor290"/>The JavaScript Event Life Cycle</h1>
			<p>R<a id="_idTextAnchor291"/>egardless of which node has dispatched the event, all event notifications start at the <strong class="source-inline">document</strong> node. They then travel in capture mode through the tree branches toward the node that dispatched it (the <strong class="source-inline">target</strong> node). Once all the appropriate capture handlers along that path have been invoked, the event then travels back to the <strong class="source-inline">document</strong> node, invoking all the appropriate bubbling handlers.</p>
			<p>When traveling down the tree, the event is said to be in its capture phase and is said to be in its bubbling phase when returning to the <strong class="source-inline">document</strong> node. It is in its target phase when the target nodes handlers are invoked, regardless of whether it is its capturing handler or bubbling handler.</p>
			<p>At any point in an event's round-trip travels, it may be halted by a handler, preventing all further event handlers from being invoked.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor292"/>Halting Event Propagation</h2>
			<p>Sometimes, when handling events, you may need to stop an event in its tracks. Knowing an event may be acted upon elsewhere in your page, it may make sense to halt an event if the conditions within your app are not in a state to allow the event to continue.</p>
			<p>For instance, if an event is dispatched when a user enters a new password within a <strong class="source-inline">textfield</strong> control, the event may be useless if the password does not meet certain requirements, such as consisting of too few characters or including characters that are not allowed.</p>
			<p>JavaScript provides two similar functions to halt events: <strong class="source-inline">stopPropagation</strong> and <strong class="source-inline">stopImmediatePropagation</strong>. Both functions are methods of the event object that are passed to event handlers as their sole parameters.</p>
			<p>The <strong class="source-inline">stopPropagation</strong> method will prevent event handlers on further nodes along its journey from being invoked, regardless of whether the event is in its capturing phase or bubbling phase. However, it will still allow all remaining as-yet-uninvoked event handlers for the current event type to execute if they are on the same node as the event handler that called <strong class="source-inline">stopPropagation</strong>. The <strong class="source-inline">stopImmediatePropagation</strong> method will stop all further handlers, including those as-yet-uninvoked on the current node:</p>
			<p class="source-code">var handler = function(ev) {</p>
			<p class="source-code">  if (ev.target.value.length &lt; 6) {</p>
			<p class="source-code">    ev.stopImmediatePropagation();</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>Either method may be invoked anywhere within a handler and may be called in multiple handlers, though only the first instance will execute.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor293"/>Halting Event Actions</h2>
			<p>Some events within the JavaScript engine result in an action. An action is a browser-specific response to an event, outside of your own custom event handlers. Examples of this include the submission of a <strong class="source-inline">form</strong> or a page redirection when clicking a link.</p>
			<p>Actions occur after the event bubbling phase, once the event has finished its journey through the node tree. If an event is stopped due to the invocation of either <strong class="source-inline">stopPropagation</strong> or <strong class="source-inline">stopImmediatePropagation</strong>, the action will still occur.</p>
			<p>To prevent an action, the event object's <strong class="source-inline">preventDefault</strong> method must be called:</p>
			<p class="source-code">var handler = function(ev) {</p>
			<p class="source-code">  ev.preventDefault();</p>
			<p class="source-code">}</p>
			<p>Calling <strong class="source-inline">preventDefault</strong> does not halt the event passing through the capture or bubbling phases. Therefore, if you want to stop an event in its tracks and prevent its action, you must call both types of method:</p>
			<p class="source-code">var handler = function(ev) {</p>
			<p class="source-code">  ev.stopPropagation();</p>
			<p class="source-code">  ev.preventDefault();</p>
			<p class="source-code">}</p>
			<p>Note that not all events can be prevented from initiating an action. Each dispatched event contains a property called cancelable. If this property is <strong class="source-inline">true</strong>, then it can be canceled by calling its <strong class="source-inline">preventDefault</strong> method. If, however, the property is <strong class="source-inline">false</strong>, then calling <strong class="source-inline">preventDefault</strong> will do nothing to change its behavior:</p>
			<p class="source-code">var handler = function(ev) {</p>
			<p class="source-code">  if (ev.cancelable) {</p>
			<p class="source-code">    ev.preventDefault();</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">onload</strong> event is one such event that can't be canceled, and with good reason, since it is imperative that the event completes its life cycle to ensure the proper functionality of the browser. Conversely, a form <strong class="source-inline">onsubmit</strong> event is cancelable since its success must be at the discretion of the page's business logic.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor294"/>Exercise 6.04: Conditional Event Prevention</h2>
			<p>In this exercise, you will create a group of links. Each link, when clicked, will raise a <strong class="source-inline">click</strong> event. Above these links, the containing <strong class="source-inline">div</strong> will listen for the event each one raises and will determine if it should stop the event propagation, stop its action, or stop both. Let's get started:</p>
			<ol>
				<li value="1">Let's start by creating a document called <strong class="bold">ev-prev.html</strong> and adding some HTML code:<p class="source-code">&lt;h<a id="_idTextAnchor295"/>tml&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;div id="container"&gt;</p><p class="source-code">      &lt;a href="https://google.com"&gt;Google&lt;/a&gt;</p><p class="source-code">      &lt;a href="https://bing.com"&gt;Bing&lt;/a&gt;</p><p class="source-code">      &lt;a href="https://yahoo.com"&gt;Yahoo&lt;/a&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div id="message"&gt;&lt;/div&gt;</p><p class="source-code">  &lt;/body&gt;</p><p>Here, we have a container with three links and a secondary container for output messages.</p></li>
				<li>Next, open a <strong class="source-inline">script</strong> tag for the JavaScript and create variables to reference the <strong class="source-inline">link</strong> container, the links themselves, and the <strong class="source-inline">message</strong> container:<p class="source-code">  &lt;script&gt;</p><p class="source-code">    var container = document.getElementById("container"),</p><p class="source-code">        links = container.children,</p><p class="source-code">        msg = document.getElementById("message");</p></li>
				<li>When each link is clicked, we want a message to display, showing which link was clicked. Therefore, we will attach an <strong class="source-inline">event listener</strong> to the <strong class="source-inline">link</strong> container so that when the events bubble up, the handler will be there to catch the event object and identify which link dispatched the event:<p class="source-code">    container.addEventListener("click", function(ev) {</p><p class="source-code">      msg.innerHTML = `$<a id="_idTextAnchor296"/>{ev.target.text} clicked`;</p><p class="source-code">      console.log(`${ev.target.text} clicked`);</p><p class="source-code">    });</p></li>
				<li>Then, we will add a behavior for each link. The first will prevent actions, the second will stop <strong class="source-inline">propagation</strong>, and the third will do both:<p class="source-code">    links[0].addEventListener("click", function(ev) {</p><p class="source-code">      ev.preventDefault();</p><p class="source-code">    });</p><p class="source-code">    links[1].addEventListener("click", function(ev) {</p><p class="source-code">      ev.stopPropagation();</p><p class="source-code">    });</p><p class="source-code">    links[2].addEventListener("click", function(ev) {</p><p class="source-code">      ev.preventDefault();</p><p class="source-code">      ev.stopPropagation();</p><p class="source-code">    });</p></li>
				<li>Finally, close out the <strong class="source-inline">script</strong> tag and <strong class="source-inline">html</strong> tag:<p class="source-code">  &lt;/script&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>By running this page in a browser, you should see that the first link will print <strong class="source-inline">Google</strong> clicked in the message container, the second will redirect the user to the <strong class="source-inline">Bing</strong> website, and the third will do nothing at all. When clicking the second link, the message is never displayed because the event propagation is stopped in the handler.<p>You have now successfully marshaled events and caught them as they bubbled up through the node tree:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer151">
					<img alt="Figure 6.10: Event prevention&#13;&#10;" src="image/C14377_06_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: Event prevention</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor297"/>Event Triggers</h1>
			<p>Yo<a id="_idTextAnchor298"/>u have seen that events are dispatched dynamically when interacting with a web page, but events can also be triggered manually, through your own code.</p>
			<p>As we mentioned previously, events in JavaScript are typed objects. When a dynamic event is raised, the JavaScript engine creates such an object and dispatches it. The object contains a type value that stores the event type as a string, such as <strong class="source-inline">click</strong>.</p>
			<p>It is possible to instantiate your own event objects and dispatch them, rather than simply relying on events being created dynamically. There are many reasons why you might like to do this, such as to simulate user interaction or to easily invoke code already assigned as an event handler without duplicating code. To do so, you simply create an instance of an <strong class="source-inline">Event</strong> using the <strong class="source-inline">new</strong> keyword and pass it the type of event you wish to raise:</p>
			<p class="source-code">var ev = new Event("click");</p>
			<p>Once created, you then simply dispatch it using the node's <strong class="source-inline">dispatchEvent</strong> method:</p>
			<p class="source-code">someNode.dispatchEvent(ev);</p>
			<p>The node that the <strong class="source-inline">dispatchEvent</strong> method is called from becomes the event object's target property. Once dispatched, the event enters the capture phase down through the <strong class="source-inline">DOM</strong> to this node, then the bubbling phase back up from it as normal, triggering event listeners as it goes.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor299"/>Custom Events</h2>
			<p>The <strong class="source-inline">Event</strong> object is the simplest type of event provided by the JavaScript framework. In fact, all the other events provided by JavaScript extend the simple <strong class="source-inline">Event</strong> type. However, the <strong class="source-inline">Event</strong> object by itself is not very flexible and does not provide a means of easily attaching additional data for an event. To alleviate this, the JavaScript language supplies the <strong class="source-inline">CustomEvent</strong> type, that is, an event specifically designed for custom developer events.</p>
			<p>When instantiated, the <strong class="source-inline">CustomEvent</strong> object accepts an additional named parameter called <strong class="source-inline">detail</strong>. By providing an object with a <strong class="source-inline">detail</strong> property as the second constructor parameter, the value of that property is then available to all event handlers that intercept it, like so:</p>
			<p class="source-code">var event = new CustomEvent("click", {detail: 123});</p>
			<p>Now, any event handlers that may intercept this event can retrieve the detail value by simply referencing it:</p>
			<p class="source-code">var handler = function(ev) {</p>
			<p class="source-code">  var value = ev.detail;  // value is now 123</p>
			<p class="source-code">};</p>
			<p><strong class="source-inline">CustomEvent</strong> exists for more than just manually triggering native event types; it is also possible to create your own event types. The name that's passed to an event object when it is created may be any string you choose. By listening for that event, you are able to handle it just like events built into the JavaScript engine:</p>
			<p class="source-code">var event = new CustomEvent("myEvent", {detail: 42});</p>
			<p class="source-code">someContainer.addEventListener("myEvent", someEventHandler);</p>
			<p class="source-code">someNode.dispatchEvent(event);</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor300"/>Native Event Triggers</h2>
			<p>The<a id="_idTextAnchor301"/>re are many native event types in the JavaScript language, some with actions and some without. So far, you have seen the <strong class="source-inline">click</strong> event being used, but there are far more than that. The mouse events group alone includes <strong class="source-inline">15</strong> different event types, and there are over <strong class="source-inline">40</strong> different groups of events, including the following:</p>
			<ul>
				<li>Network</li>
				<li>Element focus</li>
				<li>Web sockets</li>
				<li>CSS animations and transitions</li>
				<li>Forms</li>
				<li>Printing</li>
				<li>Keyboard interactivity</li>
				<li>Element drag and drop</li>
				<li>Window and document events</li>
			</ul>
			<p>There are even events that occur through touch screen display interaction, virtual reality headsets, device battery changes, smartcard events, and many, many more.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor302"/>Event Hander Attributes</h2>
			<p>When building out your HTML page, the HTML specification also caters to infix event handling notation. This is where event handlers are assigned within the HTML nodes themselves. Infix event notation is known in HTML as event attributes. There are numerous available event attribute types, though not as many as there are event types provided by JavaScript.</p>
			<p>Event attributes typically have names that are identical to their native JavaScript event type counterparts but are prepended with the word <strong class="source-inline">on</strong>. For instance, the <strong class="source-inline">click</strong> event would be assigned to a node as the <strong class="source-inline">onclick</strong> attribute:</p>
			<p class="source-code">&lt;div id="someNode" onclick="someFunction();"&gt;&lt;/div&gt;</p>
			<p>The value of the event attribute is an executable JavaScript statement, such as a function invocation.</p>
			<p>DOM nodes can only support one event attribute of each type; it is not possible, for instance, to provide two <strong class="source-inline">onclick</strong> attributes in a single node. However, event attributes can execute multiple statements within a single attribute by ensuring the correct use of the semi-colon character to distinguish the separate statements:</p>
			<p class="source-code">&lt;div id="someNode" onclick="someFun1(); someFun2();"&gt;&lt;/div&gt;</p>
			<p>Functions called as event attribute handlers are not passed an event object. However, unlike typical event handlers, they can be called with additional parameters. For instance, to pass a reference to the node containing the event attribute, the event attribute function statement can be passed the <strong class="source-inline">this</strong> context:</p>
			<p class="source-code">&lt;div id="someNode" onclick="someFunction(this);"&gt;&lt;/div&gt;</p>
			<p>In this instance, <strong class="source-inline">this</strong> resolves as the first parameter, which is a reference to the <strong class="source-inline">div</strong> node.</p>
			<p>Many developers consider event attributes to be a last resort since their inclusion mixes the view (HTML) with the logic (JavaScript). The recommended option is to always assign event handlers dynamically using <strong class="source-inline">addEventListener</strong>.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor303"/>Events and Memory</h2>
			<p>In the previous chapter, the <strong class="source-inline">delete</strong> keyword was introduced and a chapter regarding memory management was touched upon. When working with event handlers, managing memory becomes very important. If an event handler is attached to a node but that node is then removed from the page <strong class="source-inline">DOM</strong>, it may not be cleaned up by the JavaScript engine's <strong class="source-inline">garbage collector</strong> (cleaned from memory) until the handler is removed from the node. This is particularly true if the event handler is not an anonymous function.</p>
			<p>When using events against nodes that may be deleted from the <strong class="source-inline">DOM</strong>, ensure you perform a proper cleanup of your nodes and handlers. This may mean removing the event handlers and properly deleting a variable's contents prior to removal.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor304"/>Working with Forms</h1>
			<p>Forms are an integral part of the HTML specification and exist separately to the JavaScript engine, though they are also fully interactive with JavaScript. HTML forms are declarative structures are defined using the <strong class="source-inline">form</strong> tag. This tag outlines a context that can be submitted, and its data is sent to a remote server location.</p>
			<p>To understand how the <strong class="source-inline">form</strong> tag works, it helps to understand HTTP requests, their type differentiation, and how data is sent within the request.</p>
			<h2 id="_idParaDest-270">HTT<a id="_idTextAnchor305"/>P</h2>
			<p>HTT<a id="_idTextAnchor306"/>P is a specification, the long form of which is <strong class="source-inline">HyperText Transfer Protocol</strong>. It was originally released as <strong class="source-inline">HTTP 1.0</strong> in 1990 and detailed in the <strong class="source-inline">RFC 1945</strong> specification (where 1945 is the specification number, not a year). This transport format was designed for the transfer of HyperText documents across the internet, such as <strong class="source-inline">HyperText Markup Language</strong> (HTML) documents.</p>
			<p>Within the HTTP specification, numerous metadata is identified that can be sent with an <strong class="source-inline">HTTP request</strong>. This metadata is known as <strong class="bold">headers</strong>, as it sits within the starting bytes of a request packet and is used to identify how the request is read.</p>
			<p>The HTTP protocol provides an option to identify the purpose of the request packet, known as the <strong class="source-inline">Method</strong>. There are numerous <strong class="source-inline">Method</strong> options available, some of which are parsed and read differently by the HTTP servers that receive them, though their use may also be simply contextual. Two of the most common HTTP <strong class="source-inline">Methods</strong> are <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>.</p>
			<p><strong class="source-inline">GET</strong> is a method that simply means "<strong class="source-inline">get me information at this address</strong>", where the address is the URL the request was sent from. When making a <strong class="source-inline">GET</strong> request, parameters may be appended to the address in the form of query variables or as part of the path itself, which the server could then make use of in some way. However, in early versions of the <strong class="source-inline">HTTP protocol</strong>, <strong class="source-inline">Uniform Resource Locator</strong> (<strong class="source-inline">URL</strong>) addresses were only supplied with up to <strong class="source-inline">255</strong> characters, including the protocol and domain address, which proved tricky for larger amounts of data, including file uploads. To alleviate this problem, the specification also provides a <strong class="source-inline">Method</strong> called <strong class="source-inline">POST</strong>.</p>
			<p><strong class="source-inline">POST</strong> is an extension of <strong class="source-inline">GET</strong> and allows us to include a request <strong class="source-inline">body</strong>. In an HTTP request, a <strong class="source-inline">body</strong> is the packet content that is included after the headers; thus, it is the literal packet body:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer152">
					<img alt="Figure 6.11: HTTP packet&#13;&#10;" src="image/C14377_06_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11: HTTP packet</p>
			<p>Since nothing follows the <strong class="source-inline">body</strong> in the request packet, the <strong class="source-inline">body</strong> is able to be much larger than the <strong class="source-inline">GET</strong> limitation of <strong class="source-inline">255</strong> characters.</p>
			<p>When sending a <strong class="source-inline">body</strong> with a request, the sender is able to provide a <strong class="source-inline">Content-Type</strong> header, which describes the format (or MIME type) of the <strong class="source-inline">body</strong>. For instance, if the body is a <strong class="source-inline">JavaScript Object Notation</strong> (<strong class="source-inline">JSON</strong>) string, then the request's <strong class="source-inline">Content-Type</strong> may be <strong class="bold">application/json</strong>, while a body with a JPEG image could be <strong class="source-inline">application/jpeg</strong>.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor307"/>The Form Tag</h2>
			<p>The <strong class="source-inline">form</strong> tag has existed in HTML since its public inception and is detailed in the <strong class="source-inline">HTML RFC 1866</strong> specification. The <strong class="source-inline">form</strong> tag typically encloses elements of a literal form, presented visibly to users of an HTML page. As with any HTML node, a <strong class="source-inline">form</strong> tag may be styled visually or left invisible as required:</p>
			<p class="source-code">&lt;form method="POST" action="/data/form-handler.php" enctype="text/plain"&gt;</p>
			<p class="source-code">   ...</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>The attributes of the form tag include the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer153">
					<img alt="Figure 6.12: Form Tag attributes and their description&#13;&#10;" src="image/C14377_06_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12: Form Tag attributes and their description</p>
			<p>In comparison to the HTTP packet specification, the <strong class="source-inline">method</strong> attribute is equivalent to the method of the HTTP packet itself, the <strong class="source-inline">action</strong> is the same as the URL parameter, and the <strong class="source-inline">enctype</strong> is the same as the <strong class="bold">Content-Type</strong> header value.</p>
			<p>The <strong class="source-inline">form</strong> tag provides a logical request block around groups of input controls. Each <strong class="source-inline">form</strong> tag within a web page needs to be submitted for a request to be formulated and sent. Submission can occur dynamically with JavaScript or via user interaction through the use of a <strong class="source-inline">submit</strong> button control:</p>
			<p class="source-code">&lt;form method="POST" action="/data/form-handler.php" target="_top"&gt;</p>
			<p class="source-code">  &lt;input type="submit" value="submit" /&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>When you prefer direct user interaction, forms may be submitted using either a <strong class="source-inline">submit</strong> or an <strong class="source-inline">image</strong> input control, where the latter provides a means to display a styled graphic as the submission button:</p>
			<p class="source-code">&lt;form method="POST" action="/data/form-handler.php" target="_top"&gt;</p>
			<p class="source-code">  &lt;input type="image" src="images/send-btn.png" /&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor308"/>Submitting a Form with JavaScript</h2>
			<p>Sometimes, it is not appropriate to send a <strong class="source-inline">form</strong> request via user interaction. Instead, forms may send data after an animation has completed or perhaps redirect a user once their browser capabilities have been discovered. At such times, it helps to be able to trigger a form's submission dynamically using JavaScript.</p>
			<p>As with all DOM-based interaction, submitting a form first requires the acquisition of the form node. Once acquired, a form can be submitted by simply calling its <strong class="source-inline">submit</strong> function:</p>
			<p class="source-code">var form = document.getElementsByTagName("form")[0];</p>
			<p class="source-code">form.submit();</p>
			<p>Note that more than one form tag may exist within a page. Form tags may include identification and style-based attributes, the same as any other tag, such as <strong class="source-inline">name</strong>, <strong class="source-inline">id</strong>, <strong class="source-inline">class</strong>, and <strong class="source-inline">style</strong>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor309"/>Form Submission Events</h2>
			<p>The <strong class="source-inline">form</strong> tag supports a number of useful events oriented around controls and form handling. The most useful of these events is the <strong class="source-inline">submit</strong> event.</p>
			<p>The <strong class="source-inline">submit</strong> event is dispatched when the form is submitted, but prior to the request actually being sent to the designated endpoint. This event is typically used for validating the user-supplied values of the form to ensure that no obvious mistakes were made or to ensure that the required fields have been completed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since the <strong class="source-inline">submit</strong> event is dispatched before the request is sent, be sure not to redirect the user to another page using this event or to do anything that will prevent the form submission from completing. If you wish to halt the form's submission, see the Preventing Form Submission section.</p>
			<p>Like many events, the <strong class="source-inline">submit</strong> event handler may be assigned to a form node using explicit HTML attribute syntax:</p>
			<p class="source-code">&lt;form method="GET" action="/endpoint" onsubmit="myFormHandler()"&gt;</p>
			<p>The <strong class="source-inline">submit</strong> event functions just like any other event, meaning that it captures from and bubbles to the <strong class="source-inline">document</strong> node.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor310"/>Preventing Form Submission</h2>
			<p>Stopping a <strong class="source-inline">form</strong> from submitting is a common requirement in HTML and JavaScript. Often, if the validation of the <strong class="source-inline">form</strong> fails, it is preferable to cancel the submission and display appropriate messages to the user. To cancel a <strong class="source-inline">form</strong> submission, we could call the <strong class="source-inline">preventDefault</strong> method of the event, which stops the eventual action of the event, just like it does with other event types. An alternative method is to return the <strong class="source-inline">false</strong> value from the function.</p>
			<p>Returning <strong class="source-inline">false</strong> from an event handler has the same effect as calling the event's <strong class="source-inline">preventDefault</strong> function, but it doesn't halt the capturing/bubbling.</p>
			<p>If your function is handling a jQuery event, returning <strong class="source-inline">false</strong> is the same as performing both the <strong class="source-inline">preventDefault</strong> and <strong class="source-inline">stopPropagation</strong> method calls:</p>
			<p class="source-code">function formHandler(ev) {</p>
			<p class="source-code">  if (document.getElementById("password").value().length &lt; 3) {</p>
			<p class="source-code">    alert("Password is too short");</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor311"/>Resetting a Form</h2>
			<p>Resetting a form means returning the form to its initial state. This feature is provided as a way to restore a form to a clean state, or if the form was loaded with default or original values, then it returns those values to each of the controls.</p>
			<p>Website users may sometimes require a reset capability if they're working with complex values. Being able to reset a form saves the user from having to memorize the initial values present in the form, or at least to quickly return to the original state prior to repopulating the form.</p>
			<p>Like submitting, resetting a form may be carried out via user interaction through the use of a reset input control:</p>
			<p class="source-code">&lt;form method="GET" action="/endpoint"&gt;</p>
			<p class="source-code">  &lt;input type="reset" value="Reset Form" /&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>Once the control has been clicked, the <strong class="source-inline">form</strong> will revert to its initial state.</p>
			<p>Another means to reset a form is by using the <strong class="source-inline">reset</strong> method of the <strong class="source-inline">form</strong> node:</p>
			<p class="source-code">document.getElementByTagName("form")[0].reset();</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="source-inline">form</strong> <strong class="source-inline">reset</strong> cannot be reversed automatically. If such a feature is required, all the values of the form will need to be saved first and then individually reapplied to the controls.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor312"/>Form Reset Event </h2>
			<p><a id="_idTextAnchor313"/>When resetting a form, the browser will raise the <strong class="source-inline">reset</strong> event. The handler for the reset event may be applied explicitly within the HTML node's declaration:</p>
			<p class="source-code">&lt;form method="GET" action="/endpoint" onreset="myResetHandler()"&gt;</p>
			<p>Similarly, form reset events may be handled by simply assigning the event handler with JavaScript:</p>
			<p class="source-code">document.getElementByTagName("form")[0].addEventListener("reset", myResetHandler);</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor314"/>Exercise 6.05: Simple Form Handling</h2>
			<p>In this exercise, you will create a simple form with <strong class="source-inline">submit</strong> and <strong class="source-inline">reset</strong> buttons. When submitting, the form action will be canceled, but the submitted values will still be handled and displayed on the screen. This is the first step to creating a form validation system. Let's get started:</p>
			<ol>
				<li value="1">Let's begin with the standard opening HTML boilerplate:<p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;body&gt;</p></li>
				<li>Next, create the opening form tag. This will be given an ID, for ease of acquisition, and will provide a random action URL since it won't be used in this exercise:<p class="source-code">    &lt;form id="myForm" method="GET" action="http://google.com"&gt;</p></li>
				<li>To make this more interesting, let's introduce a simple <strong class="source-inline">text</strong> field control. It won't be used, per se, but it will help demonstrate the reset functionality:<p class="source-code">      &lt;input type="text" value="original text" /&gt;</p><p>Input controls will be discussed in the next section of this chapter.</p></li>
				<li>Now, you will need the two buttons: one for <strong class="source-inline">submit</strong> and one for <strong class="source-inline">reset</strong>:<p class="source-code">      &lt;input type="submit" value="Submit" /&gt;</p><p class="source-code">      &lt;input type="reset" value="Reset" /&gt;</p></li>
				<li>Finally, let's close out the <strong class="source-inline">form</strong> tag and open the <strong class="source-inline">script</strong> tag, ready for our JavaScript:<p class="source-code">    &lt;/form&gt;    &lt;script&gt;</p></li>
				<li>The <strong class="source-inline">reset</strong> button handler will be simple. Once clicked, display a message in the console. However, you won't be attaching the handler to the button's <strong class="source-inline">click</strong> event as doing that will not provide the power to stop the <strong class="source-inline">reset</strong>, should you wish to. Instead, the event will be assigned to the form's <strong class="source-inline">reset</strong> event:<p class="source-code">      function resetHandler(ev) {</p><p class="source-code">        console.log("form has been reset");</p><p class="source-code">      };</p><p class="source-code">      document.getElementById("myForm").addEventListener("reset", resetHandler);</p></li>
				<li>Likewise, with the <strong class="source-inline">submit</strong> handler, the form's <strong class="source-inline">submit</strong> event will be listened to. In this instance, however, you will call <strong class="source-inline">ev.preventDefault()</strong> from the handler to prevent the form from actually submitting:<p class="source-code">      function submitHandler(ev) {</p><p class="source-code">        console.log("form has been submitted");</p><p class="source-code">        ev.preventDefault();</p><p class="source-code">      };</p><p class="source-code">      document.getElementById("myForm").addEventListener("submit", submitHandler);</p></li>
				<li>Finally, close out the <strong class="source-inline">script</strong> tag and the page:<p class="source-code">    &lt;/script&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer154">
					<img alt="Figure 6.13: Form buttons&#13;&#10;" src="image/C14377_06_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13: Form buttons</p>
			<p>That's it. Now, if you run the page in the browser, you will see that clicking <strong class="source-inline">submit</strong> will display one message in the console, while the <strong class="source-inline">reset</strong> button will show another. Also, clicking <strong class="source-inline">reset</strong> will always revert the text in the text field to the words original text.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor315"/>Form Controls</h1>
			<p>Form tags are pretty useless without data to send. This data is typically provided using the various form controls or widgets that are available in the HTML specification. Where possible, and where the control has no child nodes, a form control typically utilizes the <strong class="source-inline">input</strong> node tag type. Other controls include <strong class="source-inline">select</strong>, <strong class="source-inline">textarea</strong>, <strong class="source-inline">button</strong>, and <strong class="source-inline">datalist</strong>. We will look at each of these control types throughout the rest of this chapter.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor316"/>Input Controls </h2>
			<p>The majority of the controls that are available to HTML forms are provided using the <strong class="source-inline">input</strong> tag. The <strong class="source-inline">input</strong> tag requires a <strong class="source-inline">type</strong> parameter, which displays a relative control within the HTML page:</p>
			<p class="source-code">&lt;input type="text" /&gt;</p>
			<p>The following are the types that are available in modern browsers when using the <strong class="source-inline">input</strong> control.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor317"/>The Button Control </h2>
			<p>The <strong class="source-inline">button</strong> control appears very much like the <strong class="source-inline">submit</strong> and <strong class="source-inline">reset</strong> form buttons. However, unlike <strong class="source-inline">submit</strong> and <strong class="source-inline">reset</strong>, the <strong class="source-inline">button</strong> control has no default action:</p>
			<p class="source-code">&lt;input type="button" onclick="buttonHandler();" value="Clickable Button" /&gt;</p>
			<p>The <strong class="source-inline">button</strong> control also has an alternative tag format, which we can use by using the <strong class="source-inline">button</strong> tag:</p>
			<p class="source-code">&lt;button onclick="buttonHandler();"&gt;Clickable Button&lt;/button&gt;</p>
			<p>Note that the <strong class="source-inline">input</strong> format requires a label to be passed in the <strong class="source-inline">value</strong> attribute, while the <strong class="source-inline">button</strong> tag format requires the button text to be passed as content using a closing <strong class="source-inline">button</strong> tag, like so:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer155">
					<img alt="Figure 6.14: Button input control&#13;&#10;" src="image/C14377_06_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14: Button input control</p>
			<p>The button control supports the <strong class="source-inline">click</strong> event, or the <strong class="source-inline">onclick</strong> attribute, as we explained earlier in this chapter.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor318"/>The Checkbox Control </h2>
			<p>The <strong class="source-inline">checkbox</strong> control represents a "true or false," "on or off," or "yes or no" control:</p>
			<p class="source-code">&lt;input type="checkbox" checked /&gt;</p>
			<p>The <strong class="source-inline">checked</strong> parameter in the preceding example is a valueless attribute. When supplied, the <strong class="source-inline">checkbox</strong> is presented checked by default and will be set to check whether the encompassing <strong class="source-inline">form</strong> is reset.</p>
			<p>An alternative implementation of this is to supply a value for <strong class="source-inline">checked</strong>:</p>
			<p class="source-code">&lt;input type="checkbox" checked="checked" /&gt;</p>
			<p>Any values supplied with valueless attributes are disregarded, and thus any value may be provided:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer156">
					<img alt="Figure 6.15: Checkbox input control&#13;&#10;" src="image/C14377_06_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15: Checkbox input control</p>
			<p>The <strong class="source-inline">checkbox</strong> control supports the <strong class="source-inline">change</strong> and <strong class="source-inline">input</strong> events. The <strong class="source-inline">input</strong> event will be dispatched whenever the <strong class="source-inline">value</strong> parameter of a control is changed, while the <strong class="source-inline">change</strong> event is raised only when the <strong class="source-inline">value</strong> of that control is committed, such as when losing focus or when the <em class="italic">Enter</em> key is pressed. Typically, there is very little difference between the two events when they're used with the <strong class="source-inline">checkbox</strong> control, though it is deemed preferable to always use the <strong class="source-inline">change</strong> event.</p>
			<p>When a <strong class="source-inline">checkbox</strong> is present in a form, its value is only submitted if it is <strong class="source-inline">checked</strong>. When unchecked, no value is passed to the handling script at all.</p>
			<p>To check the checked status of a checkbox using JavaScript, simply query its <strong class="source-inline">checked</strong> parameter:</p>
			<p class="source-code">&lt;input type="checkbox" id="check" value="1" checked /&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">  var chk = document.getElementById("check");</p>
			<p class="source-code">  console.log(chk.checked);  // ==&gt; true</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The value of <strong class="source-inline">checked</strong> will be <strong class="source-inline">true</strong> if the control is checked, or <strong class="source-inline">false</strong> if it isn't.</p>
			<p>To set the <strong class="source-inline">checked</strong> state of the control, simply pass a <strong class="source-inline">Boolean</strong> value to the <strong class="source-inline">checked</strong> parameter.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor319"/>The Radio Control </h2>
			<p>The <strong class="source-inline">radio</strong> control is similar to the <strong class="source-inline">checkbox</strong> control, with the exception that it handles multiple-choice options. Unlike a <strong class="source-inline">checkbox</strong> control, a <strong class="source-inline">radio</strong> control cannot be deselected by clicking on it. Instead, a different option must be selected, thereby providing at least one result when submitting the <strong class="source-inline">form</strong>:</p>
			<p class="source-code">&lt;input type="radio" name="color" value="red" checked /&gt;</p>
			<p class="source-code">&lt;input type="radio" name="color" value="blue" /&gt;</p>
			<p class="source-code">&lt;input type="radio" name="color" value="green" /&gt;</p>
			<p>The <strong class="source-inline">name</strong> attribute of the <strong class="source-inline">radio</strong> control provides the grouping functionality. If a different <strong class="source-inline">name</strong> is provided from previous <strong class="source-inline">radio</strong> controls, then that new control belongs to a different group. Only by clicking the <strong class="source-inline">radio</strong> controls within the same group can the previously selected <strong class="source-inline">radio</strong> control be deselected:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer157">
					<img alt="Figure 6.16: Radio input control&#13;&#10;" src="image/C14377_06_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: Radio input control</p>
			<p>Like the <strong class="source-inline">checkbox</strong> controls, the <strong class="source-inline">radio</strong> control is selected using the <strong class="source-inline">checked</strong> attribute. If a <strong class="source-inline">radio</strong> control group is present within a page, but none of the controls have been set to <strong class="source-inline">checked</strong>, none of those <strong class="source-inline">radio</strong> controls will be selected. At such times, submitting the parent form will mean that the <strong class="source-inline">radio</strong> group is absent from the sent data.</p>
			<p>To dynamically check a specific <strong class="source-inline">radio</strong> button (and thus uncheck the currently selected one), there needs to be a means to reference the specific <strong class="source-inline">radio</strong> control you wish to check. There are several ways to do this, such as providing a unique <strong class="source-inline">id</strong> for each <strong class="source-inline">radio</strong> control in a group, but by far the most efficient is to simply reference its index in the group. For instance, to select the second <strong class="source-inline">radio</strong> button in a group, we may do this:</p>
			<p class="source-code">&lt;input type="radio" name="color" value="red" checked /&gt; red</p>
			<p class="source-code">&lt;input type="radio" name="color" value="blue" /&gt; green</p>
			<p class="source-code">&lt;input type="radio" name="color" value="green" /&gt; blue</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">  var chk = document.getElementsByName("color")[1];  // select index 1</p>
			<p class="source-code">  chk.checked = true;</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p><strong class="source-inline">getElementsByName</strong> returns an array of all the elements matching the passed criteria. Therefore, providing an index enables direct access to a given element index.</p>
			<p><strong class="source-inline">radio</strong> control supports the <strong class="source-inline">input</strong> and <strong class="source-inline">change</strong> events, much like the <strong class="source-inline">checkbox</strong> control.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor320"/>The Text Control </h2>
			<p>The <strong class="source-inline">text</strong> control is the most basic of all <strong class="source-inline">input</strong> control types and is used to create free-text fields. These fields allow for single-line text strings to be entered using the keyboard, though text may also be pasted into it using the browser context menu. Text fields are created by setting the <strong class="source-inline">type</strong> attribute of the <strong class="source-inline">input</strong> control to <strong class="source-inline">text</strong>:</p>
			<p class="source-code">&lt;input type="text" name="color" value="red" /&gt;</p>
			<p>The permissible content of a <strong class="source-inline">text</strong> control may be restricted by supplying a <strong class="source-inline">pattern</strong> attribute value in the form of a regular expression. As an example, a text field can be restricted to accept only numerical values with the following code:</p>
			<p class="source-code">&lt;input type="text" name="num" pattern="[0-9]" title="Enter a number" /&gt;</p>
			<p>When using the preceding text field, submitting a value other than a number will result in the form submission terminating and a tooltip displaying alongside the <strong class="source-inline">text</strong> field with the text <strong class="bold">Enter a number</strong>. The form data will not be submitted under this circumstance:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer158">
					<img alt="Figure 6.17: Text input control with the pattern attribute&#13;&#10;" src="image/C14377_06_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: Text input control with the pattern attribute</p>
			<p>Another feature of the <strong class="source-inline">text</strong> field is the <strong class="source-inline">placeholder</strong> attribute. Placeholders allow for temporary text to exist within the field itself:</p>
			<p class="source-code">&lt;input type="text" name="num" placeholder="Enter a number" /&gt;</p>
			<p>This text does not constitute a value of the control, so the submission of the container form will not yield the <strong class="source-inline">placeholder</strong> value. Likewise, querying the text control's <strong class="source-inline">value</strong> attribute will not return the <strong class="source-inline">placeholder</strong> value if it is visible:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer159">
					<img alt="Figure 6.18: Text input control with placeholder attribute&#13;&#10;" src="image/C14377_06_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18: Text input control with placeholder attribute</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor321"/>The Password Control </h2>
			<p>The <strong class="source-inline">password</strong> control works very similarly to the <strong class="source-inline">text</strong> field control, but with a couple of differences:</p>
			<p class="source-code">&lt;input type="password" name="pass" /&gt;</p>
			<p>The primary difference with the <strong class="source-inline">password</strong> control is that any value present in the control is presented to the user as a series of dots, known as a hash, rather than as the value text itself. The purpose of the hash is for the value to be unreadable by the user and, thus, provide a level of security from unwanted attention. The user is, therefore, expected to already know the value contained within the field. When submitting the form, the value is correctly passed with the form data as clear text:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer160">
					<img alt="Figure 6.19: Password input control&#13;&#10;" src="image/C14377_06_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: Password input control</p>
			<p>Another difference with the <strong class="source-inline">password</strong> control over the <strong class="source-inline">text</strong> control is that it is not possible to highlight its content and copy it. Any attempt to copy the content of a <strong class="source-inline">password</strong> control is ignored. This prevents malicious users from copying and pasting the value of a <strong class="source-inline">password</strong> control into a text editor, or other such software, thus making the value text clearly readable. However, despite this, it is still possible to reference the control with JavaScript and output its value that way, like so:</p>
			<p class="source-code">&lt;input type="password" id="secureValue" value="secret" /&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">var pass = document.getElementById("secureValue");</p>
			<p class="source-code">console.log(pass.value);  // ==&gt; "secret"</p>
			<p class="source-code">&lt;/script&gt;</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor322"/>email, tel, and url Controls</h2>
			<p>The <strong class="source-inline">email</strong>, <strong class="source-inline">tel</strong>, and <strong class="source-inline">url</strong> controls are modern variations of the text field control. They can be created by simply passing email, tel, or url as the type attribute of the input control:</p>
			<p class="source-code">&lt;input type="email" /&gt;</p>
			<p class="source-code">&lt;input type="tel" /&gt;</p>
			<p class="source-code">&lt;input type="url" /&gt;</p>
			<p>By themselves, each of these controls provides no additional functionality over the standard <strong class="source-inline">text</strong> control. All of the attributes, events, and visual look-and-feel of these controls are identical to the <strong class="source-inline">text</strong> control and to one another. However, the benefit of these types becomes apparent when they're used with devices that present an on-screen keyboard, such as mobile phones and tablets. By using one of these <strong class="source-inline">input</strong> types, rather than a <strong class="source-inline">text</strong> control, the visible keyboard that's presented to input text into them is typically oriented toward the control's content type:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer161">
					<img alt="Figure 6.20: Mobile keyboards for the text, email, tel, and url controls&#13;&#10;" src="image/C14377_06_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20: Mobile keyboards for the text, email, tel, and url controls</p>
			<p>Note that additional work is needed to ensure that the content of the field is appropriate for the field format. This can be accomplished using the <strong class="source-inline">pattern</strong> attribute and form validation logic.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor323"/>The Hidden Control</h2>
			<p>The <strong class="source-inline">hidden</strong> control is a very useful field for storing data to be passed to the handler of a form, such as a remote server endpoint, without the user of the web page being aware of its existence. As its name implies, the <strong class="source-inline">hidden</strong> field is hidden from the user and has no visible presence:</p>
			<p class="source-code">&lt;input type="hidden" /&gt;</p>
			<p>Many of the attributes provided by the input tag are irrelevant when using the <strong class="source-inline">hidden</strong> control since it is not a control that a user will interact with. However, its <strong class="source-inline">value</strong>, <strong class="source-inline">id</strong>, and <strong class="source-inline">name</strong> attributes will prove useful and can be used and manipulated in the same way as the <strong class="source-inline">text</strong> control.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor324"/>The Number Control</h2>
			<p>A <strong class="source-inline">number</strong> field appears similar to a <strong class="source-inline">text</strong> field but will naturally constrain all text input to numerical values, the addition and subtraction symbols, and the period symbol:</p>
			<p class="source-code">&lt;input type="number" /&gt;</p>
			<p>In some browsers, the number control will also present small up and down arrow buttons, which can be used to increment or decrement the contained value:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer162">
					<img alt="Figure 6.21: Number control&#13;&#10;" src="image/C14377_06_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21: Number control</p>
			<p>The content of a <strong class="source-inline">number</strong> control can be further constrained by using its <strong class="source-inline">min</strong>, <strong class="source-inline">max</strong>, and <strong class="source-inline">step</strong> attributes. The <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> attributes are self-explanatory and constrain possible numeric entry values to these attributes. For instance, providing a <strong class="source-inline">min</strong> value of 0 will ensure a negative number cannot be entered, while a <strong class="source-inline">max</strong> value of 100 will ensure the value never exceeds 100:</p>
			<p class="source-code">&lt;input type="number" min="0" max="100" /&gt;</p>
			<p>Using <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> does not mean a value outside of these constraints cannot be physically entered as input into the control from the keyboard, but merely that the constraints cannot be breached when clicking on the provided arrow buttons or that any provided value outside of these parameters will be accepted when submitting the form:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer163">
					<img alt="Figure 6.22: Number control constraints&#13;&#10;" src="image/C14377_06_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22: Number control constraints</p>
			<p>The step attribute provides a means to increase the rate at which the arrow buttons increase or decrease the value. For instance, if large numbers are allowed within the control, incrementing by 1 with each click may be impractical. Therefore, setting a larger step size would allow the value change to happen with fewer clicks:</p>
			<p class="source-code">&lt;input type="number" min="-100000" max="100000" max="100" /&gt;</p>
			<p>When using step, the change in value when clicking the arrow buttons will change at a rate of the step value from whatever value is currently present within the control. Therefore, setting a step of 5 will not constrain the contained value to multiples of 5.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor325"/>The Image Control</h2>
			<p>The <strong class="source-inline">image</strong> control works as a hybrid of an <strong class="source-inline">img</strong> tag and a <strong class="source-inline">submit</strong> input control. The idea here is that you can use a graphical image as a submit button. You specify the image source using the <strong class="source-inline">src</strong> attribute, much like we do with the <strong class="source-inline">img</strong> tag:</p>
			<p class="source-code">&lt;input type="image" src="/path/to/img.png" /&gt;</p>
			<p>An additional benefit to using an <strong class="source-inline">image</strong> input control is that once it's clicked, the x and y coordinates of the mouse in relation to the image are also sent with the form data as an <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> value. This can prove very useful if, for instance, you wish to register a location on a map as part of form submission, or if you wish to determine the area of the image that the user clicked on:</p>
			<p class="source-code">&lt;form method="GET" action="/handler.php"&gt;</p>
			<p class="source-code">  &lt;input type="image" src="/path/to/img.png" /&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p class="source-code">// will submit to a URL like "/handler.php?x=14&amp;y=27</p>
			<p>The availability of the <strong class="source-inline">image</strong> control means forms can be stylized beyond the confines provided by HTML button controls and can be very popular with web designers.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor326"/>The File Control</h2>
			<p>The <strong class="source-inline">file</strong> control is a requirement when uploading files to a remote server. In fact, it is not actually possible to upload a file dynamically without using the <strong class="source-inline">file</strong> control in some way. This is due to security as it is unethical to be able to dynamically upload files from a user's machine without their knowledge:</p>
			<p class="source-code">&lt;input type="file" name="file" /&gt;</p>
			<p>The <strong class="source-inline">file</strong> control is typically presented to the user as a <strong class="source-inline">text</strong> field and <strong class="source-inline">label</strong> pair. It is possible to style the control so that one of these items, or both, is not visible to the user. The text that's supplied within the button and label is fixed by the browser and requires some extreme styling to be changed. </p>
			<div>
				<div class="IMG---Figure" id="_idContainer164">
					<img alt="Figure 6.23: File control&#13;&#10;" src="image/C14377_06_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23: File control</p>
			<p>When using the <strong class="source-inline">file</strong> control to upload files to a server, it is important to set the <strong class="source-inline">enctype</strong> parameter of the surrounding form to <strong class="source-inline">"multipart/form-data"</strong>. This value informs the form submission on how to encode the data when sending it to the server. Failure to do this will prevent the file from uploading since files typically require multiple packets to successfully transfer all of the file's data bytes.</p>
			<p>The file control supports an accept attribute value, which enables the filtering of accepted file format types. This attribute can support more than one value, but they must be supplied as MIME types (a predefined string representation of a file's type):</p>
			<p class="source-code">&lt;input type="file" name="file" accept="image/png, image/jpeg" /&gt;</p>
			<p>In the preceding example, only files with a .png, .jpg, or .jpeg extension will be visible when selecting files through the control.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor327"/>The Textarea Control</h2>
			<p>While the <strong class="source-inline">text</strong> control is great for accepting single lines of text, the <strong class="source-inline">textarea</strong> control is required for capturing multiline text values:</p>
			<p class="source-code">&lt;textarea name="description"&gt;</p>
			<p class="source-code">    Some default text.</p>
			<p class="source-code">&lt;/textarea&gt;</p>
			<p>As the name implies, the <strong class="source-inline">textarea</strong> control supports an area of text and is, therefore, a larger control than many of the <strong class="source-inline">input</strong> controls. Like the <strong class="source-inline">button</strong> tag, the <strong class="source-inline">textarea</strong> control consists of both an opening and a closing tag. Any text that's supplied between the tags makes up its text content.</p>
			<p>Although the textarea doesn't utilize a value attribute, its content may still be read and set using the <strong class="source-inline">value</strong> attribute in JavaScript, like so:</p>
			<p class="source-code">var desc = document.getElementsByName("description")[0];</p>
			<p class="source-code">console.log(desc.value) // ==&gt; outputs "Some default text"</p>
			<p class="source-code">desc.value = "Some other text"; // ==&gt; updates the value of the textarea to "Some other text"</p>
			<div>
				<div class="IMG---Figure" id="_idContainer165">
					<img alt="Figure 6.24: Textarea control&#13;&#10;" src="image/C14377_06_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24: Textarea control</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor328"/>The Select Control</h2>
			<p>The <strong class="source-inline">select</strong> control provides the functionality of a drop-down list control. Like <strong class="source-inline">textarea</strong>, the <strong class="source-inline">select</strong> control utilizes an opening and closing tag, both of which form the body of the control. However, the items within the control are provided as an additional tag, called <strong class="source-inline">option</strong>:</p>
			<p class="source-code">&lt;select name="colors"&gt;</p>
			<p class="source-code">  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="red"&gt;Red&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="blue"&gt;Blue&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="green"&gt;Green&lt;/option&gt;</p>
			<p class="source-code">&lt;/select&gt;</p>
			<p>The <strong class="source-inline">option</strong> elements of a <strong class="source-inline">select</strong> control typically contain two values: the <strong class="source-inline">value</strong> attribute and the <strong class="source-inline">text</strong> body. These are known simply as the <strong class="source-inline">value</strong> and <strong class="source-inline">text</strong>. The text contained between the opening and closing <strong class="source-inline">option</strong> tags is the string that's visible to the user within the control, while the <strong class="source-inline">value</strong> attribute is the string to be sent when the form is submitted if that particular <strong class="source-inline">option</strong> element is selected. When adding <strong class="source-inline">option</strong> elements, the <strong class="source-inline">value</strong> attribute may be omitted, but this will mean the <strong class="source-inline">text</strong> value will be sent with the form data instead.</p>
			<p>Similar to checkboxes and radio buttons, an option value may be preselected by passing the selected attribute to one of the option values:</p>
			<p class="source-code">&lt;select name="colors"&gt;</p>
			<p class="source-code">  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="red" selected&gt;Red&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="blue"&gt;Blue&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="green"&gt;Green&lt;/option&gt;</p>
			<p class="source-code">&lt;/select&gt;</p>
			<p>The select control can be displayed in two formats. The standard format is as a dropdown (or combo) list control:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer166">
					<img alt="Figure 6.25: Select control&#13;&#10;" src="image/C14377_06_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25: Select control</p>
			<p>The secondary format is displayed if the control needs to support multiple simultaneously selected options. As such, the control is displayed as a permanently open list control, with scrollable options. The <strong class="source-inline">select</strong> control can support multiple selected options by supplying the <strong class="source-inline">multiple</strong> attribute:</p>
			<p class="source-code">&lt;select name="colors" multiple&gt;</p>
			<p class="source-code">  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="red"&gt;Red&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="blue"&gt;Blue&lt;/option&gt;</p>
			<p class="source-code">  &lt;option value="green"&gt;Green&lt;/option&gt;</p>
			<p class="source-code">&lt;/select&gt;</p>
			<p>When displayed, the user must press and hold the Ctrl key on the keyboard while selecting items. If the Ctrl key is not pressed, then selecting an item will deselect any previously selected items:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer167">
					<img alt="Figure 6.26: Select control with multiple attributes&#13;&#10;" src="image/C14377_06_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: Select control with multiple attributes</p>
			<p>When working with a dropdown <strong class="source-inline">select</strong> control, it is possible to get the value of the selected <strong class="source-inline">option</strong> by simply querying the <strong class="source-inline">select</strong> control's <strong class="source-inline">value</strong> property:</p>
			<p class="source-code">var select = document.getElementsByName("colors")[0];</p>
			<p class="source-code">console.log(select.value); // ==&gt; outputs selected color</p>
			<p>It is also possible to output the index of the selected item by querying the <strong class="source-inline">selectedIndex</strong> property. Index values start at 0 (zero) for the first element:</p>
			<p class="source-code">var select = document.getElementsByName("colors")[0];</p>
			<p class="source-code">console.log(select.selectedIndex); // ==&gt; outputs numerical index of selected option</p>
			<p>However, when querying a multi-select list, things aren't so easy. If multiple items are selected, querying the <strong class="source-inline">value</strong> property would simply return the first selected item in the list, thus ignoring all the other selected items. Instead, developers need to make use of the <strong class="source-inline">options</strong> property of the <strong class="source-inline">select</strong> control and the <strong class="source-inline">option</strong> item's <strong class="source-inline">selected</strong> property to discern which items are selected.</p>
			<p>The <strong class="source-inline">select</strong> control's <strong class="source-inline">options</strong> property returns all the <strong class="source-inline">option</strong> elements contained within it, regardless of their selected state. The <strong class="source-inline">option</strong> item's <strong class="source-inline">selected</strong> property is simply the condition of its selected status; it's true if it is selected and false if it is not. Thus, by combining these two values, the selected <strong class="source-inline">option</strong> elements can be discerned with a simple loop, like so:</p>
			<p class="source-code">var selectedItems = [];</p>
			<p class="source-code">var select = document.getElementsByName("colors")[0];</p>
			<p class="source-code">for (let opt of select.options) {</p>
			<p class="source-code">  if (opt.selected) {</p>
			<p class="source-code">    selectedItems.push(opt.value);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">console.log(selectedItems); // ==&gt; outputs array of selected values</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor329"/>Activity 6.01: Making Changes to the Model</h2>
			<p>A lot has been covered in this chapter, but you should now have the knowledge that's required to make something visual. In this activity, your role will be to create a simple form that requests the title and description for a new <strong class="source-inline">To-Do</strong> entry which, when submitted, feeds the data to the action handler we created in the previous chapter.</p>
			<p>Once your form is in place and its data is being handled, the model functions must be updated to receive this data. Create an event handler that's able to receive <strong class="source-inline">CREATE</strong> action events and pass them appropriately to the model.</p>
			<p>Since there is no visual cue that data has been successfully stored within the model, any updates to the model should result in a notification event being dispatched. This way, other areas of your application can respond accordingly as data changes. Your project manager has requested that a custom event be dispatched from the model, called <strong class="source-inline">CHANGED</strong>. This will notify any interested party that data has either been added, updated, or removed from the model.</p>
			<p>To verify that the <strong class="source-inline">CHANGED</strong> event works, create a message banner at the top of the page that briefly displays the message "<strong class="source-inline">The To-Do model has been updated</strong>". This message should be present for three seconds, before being removed.</p>
			<p>Your project manager has asked that this information is dispatched as a custom event, to be caught by the action handler. This event should match the action types already recognized by the model. Therefore, be sure to send the object as a <strong class="source-inline">CREATE</strong> event.</p>
			<p>Save the following HTML in a file called <strong class="source-inline">index.html</strong>:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    &lt;title&gt;Create TODO&lt;/title&gt;</p>
			<p class="source-code">    &lt;script src="model.js"&gt;&lt;/script&gt;</p>
			<p class="source-code">    &lt;script src="create_todo.js"&gt;&lt;/script&gt;</p>
			<p class="source-code">  &lt;/head&gt;</p>
			<p class="source-code">  &lt;body onload="loadHandler();"&gt;</p>
			<p class="source-code">    &lt;div id="notifications"&gt;&lt;/div&gt;</p>
			<p class="source-code">    &lt;form id="todo_form" /&gt;</p>
			<p class="source-code">      &lt;label&gt;Title:</p>
			<p class="source-code">        &lt;input type="text" id="title" /&gt;</p>
			<p class="source-code">      &lt;/label&gt;</p>
			<p class="source-code">      &lt;label&gt;Description:</p>
			<p class="source-code">        &lt;textarea id="description"&gt;&lt;/textarea&gt;</p>
			<p class="source-code">      &lt;/label&gt;</p>
			<p class="source-code">      &lt;input type="submit" value="Create TODO" /&gt;</p>
			<p class="source-code">    &lt;/form&gt;</p>
			<p class="source-code">  &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>This HTML should include the model from the previous chapter, but also a new JavaScript file that will contain the logic for this activity.</p>
			<p>The following is the expected output for this activity:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer168">
					<img alt="Figure 6.27: TODO submission form&#13;&#10;" src="image/C14377_06_27.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: TODO submission form</p>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add a custom event handler to the model. This handler should receive the <strong class="source-inline">CREATE</strong> state change and update the model with the new <strong class="source-inline">TODO</strong> details from the event body.</li>
				<li>Add a <strong class="source-inline">loadHandler</strong> function to the <strong class="source-inline">create_todo.js</strong> file. This handler should listen for the submit button's <strong class="source-inline">click</strong> event, but also the custom <strong class="source-inline">CHANGED</strong> event from the model.</li>
				<li>Add a handler function in <strong class="source-inline">create_todo.js</strong> to handle the <strong class="source-inline">CHANGED</strong> event itself. This handler should temporarily display a <strong class="source-inline">The TODO model has been updated</strong> message within the <strong class="source-inline">notifications</strong> tag.</li>
				<li>Add the <strong class="source-inline">TODO</strong> to the <strong class="source-inline">create_todo.js</strong> file. This will be executed when the <strong class="source-inline">submit</strong> button click event is raised. This handler should parse the values of the form controls and dispatch them in a new <strong class="source-inline">CREATE</strong> custom event if they are valid. If any of the data is not valid, then sufficient error messages should be temporarily displayed in the <strong class="source-inline">notifications</strong> tag.</li>
				<li>Add a <strong class="source-inline">CHANGED</strong> event dispatch when the model is updated. The event body should contain a type added and a value containing the details of the new <strong class="source-inline">TODO</strong>.</li>
			</ol>
			<p>If you run the HTML page, you will expect to see messages to be written to the screen when you submit the form. Remember that the model will receive and send events. It will not be contacted directly. The handler functions will ensure that the events are attached correctly and that the data has been correctly parsed so that it can be sent to the model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 728.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor330"/>Summary</h1>
			<p>This has been the first chapter to have utilized an HTML page using JavaScript in this book, as well as the first to explain the abstract nature of the event messaging system. Understanding these concepts is very valuable when building a useful web application in JavaScript.</p>
			<p>Throughout this chapter, you have explored the various nuances of event message bubbling and capturing, along with how they can be used to control the flow of information within an application. You have also seen how to halt these events in their tracks and how to create your own custom events.</p>
			<p>By adopting the tools and skills you've learned about in this chapter, you will have a foundational arsenal at your disposal so that you can tackle applications of any size or complexity. These skills will be honed throughout the rest of this book while broadening your perspective as to what is possible with this powerful language.</p>
			<p>In the next chapter, you will dive deeper into the JavaScript event loop and gain a greater understanding of the underlying technology.</p>
		</div>
		<div>
			<div class="Content" id="_idContainer170">
			</div>
		</div>
	</body></html>