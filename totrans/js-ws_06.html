<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>6. Understanding Core Concepts</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to apply timeouts and intervals to include asynchronous functionality in applications; identify the different browser event types; capture and handle user interaction; intercept and prevent events; impersonate events to improve application user experience; summarize the different browser supported input controls; and work with forms, form submission, and form event handling.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor272"/>Introduction</h1>
			<p>In the previous chapter, you were introduced to the many data types supported by the JavaScript language and runtime, including functions, JavaScript's most impressive first-class data type. Understanding the differences between data types is an important first step for building practical, efficient, and bug-free applications. Software applications have many forms and may have many uses. In its simplest form, an application may read parameters on execution, process the data, and return a response. It may not even interact with any other applications or outside services. Terminal commands are a good example of this. For instance, executing <code>dir</code> in a Windows command window or <code>ls</code> in a <code>Linux Terminal</code> would simply read the contents of a directory on the hard disk and display the details of those files and directories within the Terminal window. The Linux operating system is built on the premise of such very small and simple applications working together to create a much larger ecosystem. The converse of this may be modern multiplayer video games, which typically react to user interaction and receive streamed data from remote locations. The former of these concepts can be considered much like a function: input enters from the top and is output somewhere within the body, typically, the end of the function.</p>
			<p>JavaScript applications can facilitate both ends of this spectrum, and indeed, anything in between. Modern browsers are now fully capable of providing the foundations for immense and processor-intensive 3D multiplayer games, responding to data from numerous sources, but JavaScript is also frequently used for the simplest of tasks, such as formatting a <code>string</code> or rounding a <code>number</code>.</p>
			<p>At the core of all of these applications are <code>events</code>. Events, conceptually speaking, are triggers that execute code. This might, for example, be the ready state when a page has finished loading or a mouse event when the user clicks an element within the page. Typically, without events, functions won't know when to execute and, therefore, nothing can happen.</p>
			<p>Throughout this chapter, we will examine the options JavaScript provides for listening to and handling different types of events within the browser environment.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor273"/>Event Types</h1>
			<p>An event is simply a notification or a "<code>triggered</code>" alert within the JavaScript runtime. These notifications can represent practically anything but are a means to invoke one or more of your own functions when such an event occurs. </p>
			<p>When a web page loads, the browser will typically display content as soon as it is available. This means some content will be presented to the user before the entire page has finished downloading. The browser does this to prevent long-loading assets from withholding other content from being available to the user.</p>
			<p>Now, imagine you want to invoke a function immediately within a web page to rotate an image. JavaScript code embedded into a web page is able to run immediately once it has been parsed by the JavaScript engine, which could possibly be before the image in question is available. To overcome this conundrum, JavaScript provides an <code>onload</code> event, which is dispatched as soon as all the page's content has finished downloading. By refraining from invoking your function until this event has been dispatched, you can ensure that your image can be rotated.</p>
			<p>Of course, there are many other such events. Arguably, there are four specific types of events within the JavaScript ecosystem:</p>
			<ul>
				<li><strong class="bold">Timer events</strong> provide forced asynchronous functionality within your applications. They allow you to invoke a function after a period of time, either once or repeatedly.</li>
				<li><code>callbacks</code>, are dispatched when something has finished executing but has occurred in parallel to any other function execution in your application. This means the process has not stopped your application from doing other tasks.</li>
				<li><code>DOM</code> or keyboard events, are events that are dispatched due to the user interacting with your application.</li>
				<li><strong class="bold">Custom events</strong> are events that you create yourself. These can be almost anything but are usually created as a response to one of the JavaScript event types listed previously.</li>
			</ul>
			<p>The type of event you will require is very specific to a given use case. In this chapter, we will examine both timer-based events and interaction events.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor274"/>Timer Events</h2>
			<p>In some languages, such as C, the base application may be run using a continuous loop. In C, specifically, an application runs during the lifetime of its <code>main</code> function; when this function returns, the application exits. Typically, applications that need to run for some time and respond to events would utilize a simple loop. In fact, it's not uncommon to see applications start with something like this:</p>
			<pre>int main(int ac, char** av) {
    while (true) {
        // .. do stuff ..
    }
    return 1;
}</pre>
			<p>Here, the application simply enters an indefinite loop. If the application needs to quit, it would call a command similar to JavaScript's <code>break</code> keyword. Otherwise, the application would quite happily run and invoke functions as needed.</p>
			<p>Applications written in C are able to do this for several reasons. The first is that C is a multi-threaded platform. This means that several processes, known as threads, can be created within a C application and may run concurrently, providing the underlying hardware it supports. In the worst-case scenario, these threads are cycled, allowing each one to utilize a period of execution time within the CPU. Another reason this is possible is that C applications run very close to the hardware and, unlike JavaScript, are unencumbered by a lower-level engine that dictates execution flow.</p>
			<p>Since a program can exist with a loop at its core, it stands to reason that functions will, or can, be called with each iteration. However, if a function was called indefinitely with every iteration, such a process may be overly resource-intensive or simply run too fast. An alternative is to make the function conditional by requiring it to execute only when enough time has passed since its last execution. This is the essential basis of a timer event.</p>
			<p>Unlike C, JavaScript is a <code>single-threaded</code> platform, meaning it can only execute a single thread throughout your entire application. A thread is an execution space in the CPU. If you have one thread, then only a single series of function executions can occur at once. In JavaScript, this does not mean the underlying engine doesn't use, or have access to, more than one thread; only that your application has programmatic access to one single thread.</p>
			<p>Since JavaScript runs within an engine, known as a virtual machine, it is driven by a number of rules that determine how your code is run. The JavaScript virtual machine follows an architecture known as an event loop. This means that the loop in the preceding C example is already occurring within the JavaScript engine that your application runs within. However, within that loop, the JavaScript engine manages code execution for each of the function calls your application makes, among other things, regardless of whether those calls invoke your own functions or those native to JavaScript.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor275"/>Exercise 6.01: Custom Timer</h2>
			<p>As we mentioned previously, many developers coming from lower-level languages will consider a loop as a means to create timed function invocations. If a loop can occur indefinitely, then we only need to check the current system time and invoke functions when sufficient time has passed. For instance, when animating, in order to control the <code>speed</code> of the animation, you may want to ensure your frame update functions are executed with a sufficient period of time between each invocation. Without this control, your animation frames will update with every possible cycle of the JavaScript runtime, which may be very fast on some machines, while not so fast on weaker machines. In this exercise, you will implement one such loop. Let's get started:</p>
			<ol>
				<li>To begin, you'll need three variables. The first will store the current time in milliseconds for each iteration, the second variable will contain the time in milliseconds of the last time the custom timer function executed, and the third variable will be the required minimal interval between timer function calls in milliseconds:<pre>var curTime, lastTime,
  interval = 500;</pre></li>
				<li>Next, we open the <code>main</code> function and the indefinite loop. Similar to the preceding example, we'll simply use a <code>while</code> loop and pass it a decrementing value:<pre>function main() {  // primary function
  let running = true;  // loop running flag
  while (running) {  // enter loop</pre></li>
				<li>Now, the first thing that needs to happen with each iteration is that we need to get the current time in milliseconds and compare it to the last stored time:<pre>    curTime = new Date().getTime();
    lastTime = lastTime || curTime;
    if (curTime - lastTime &gt; interval) {</pre><p>The <code>lastTime</code> variable, if it is <code>null</code>, will be passed the value of <code>curTime</code>. This way, it will execute correctly from its first iteration since <code>null</code> cannot be deducted from an <code>integer</code>.</p></li>
				<li>If the values are sufficiently different (greater than the <code>interval</code> amount), you can invoke your timed functions. You will then need to update the <code>lastTime</code> variable to equal the current time so that the function doesn't execute again in succession and instead waits for the next duration to occur:<pre>      console.log(curTime);
      lastTime = curTime;
      running = false;</pre></li>
				<li>Finally, you close out the conditional, loop, and function:<pre>    }
  }
}</pre></li>
				<li>That's it. If you execute the function by calling <code>main()</code>, you will see the current time in milliseconds output to the console every <code>500</code> milliseconds:<pre>main(); // ==&gt; 1558632112316</pre></li>
			</ol>
			<p>What you have just created is similar to an application loop. Many programming languages support the notion of an application loop. In fact, languages such as C++ require such a loop in order to prevent an application from exiting. In such circumstances, the loop is a simple "<code>keep-alive</code>" mechanism whereby checks for potential events occur manually within the loop. In JavaScript, such loops are unnecessary. This is because the JavaScript engine already enlists the help of such a loop under the hood, known as the event loop.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor276"/>Event Timers</h2>
			<p>The previous exercise exhibits perfectly legitimate code and would facilitate a working function invocation timer. However, creating timers in this fashion has a number of drawbacks. The first issue here is that since JavaScript is single-threaded, the entire application will be contained within the loop. There is no way to continue processing data outside of the loop without breaking out of it.</p>
			<p>The second issue in the previous exercise is that since the JavaScript engine is already running its own event loop, the example code is actually performing two infinite loops, one nested within the other:</p>
			<div><div><img alt="Figure 6.1: Nested infinite event loop&#13;&#10;" src="img/C14377_06_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Nested infinite event loop</p>
			<p>Since delayed and repeated function invocation is a common programming requirement, the JavaScript language provides two functions that make timers simple without us having to construct our own loops. These are <code>setInterval</code> and <code>setTimeout</code>.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor277"/>The setInterval Function</h2>
			<p><code>setInterval</code> is a native implementation of our previous infinite loop. The premise is that, given a function and an interval value in milliseconds, JavaScript will repeatedly execute the function whenever the interval time has passed:</p>
			<pre>intervalReference = setInterval(timerFun, milliseconds);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The time-based execution in JavaScript is "as near to" the interval value as possible. JavaScript is unable to guarantee absolute accuracy when executing triggers due to various limitations with the underlying hardware, operating system, and resource availability.</p>
			<p>We can reproduce our previous example with the following code:</p>
			<pre>var timerFunction = function() {
  var time = new Date().getTime();
  console.log(time);}
setInterval(timerFunction, 500);
// ==&gt; 1558632112316</pre>
			<p>The function expression in this example will be executed <code>500</code> milliseconds after we call <code>setInterval</code> and every <code>500</code> milliseconds thereafter. It is executed asynchronously, so the code that follows the <code>setInterval</code> call is executed without delay:</p>
			<pre>function main() {
  setInterval(() =&gt; console.log("executed"), 500);
  console.log("after execution");
  console.log("another message");
}();// ==&gt;   after execution
// ==&gt;   another message
// ==&gt;   executed
// ==&gt;   executed</pre>
			<p>The <code>setInterval</code> function itself, when invoked, returns a reference to the resulting interval handler, that is, the execution stack that invokes the passed <code>callback</code> function. This reference may be used to terminate the interval loop at any time using the <code>clearInterval</code> function:</p>
			<pre>var ref = setInterval(someFunc, 100);
clearInterval(ref);</pre>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor278"/>The setTimeout Function</h2>
			<p>The <code>setTimeout</code> function works identically to the <code>setInterval</code> function, the difference being that its passed <code>callback</code> function is only ever called once. The <code>setTimeout</code> function is useful when animating elements within an HTML page, or when you wish to delay a process for a period of time, such as clearing a visible error message or dialog:</p>
			<pre>setTimeout(someFunc, 500);</pre>
			<p>Like <code>setInterval</code>, the <code>setTimeout</code> function also returns a reference to its execution handler so that the timer can be cleared with <code>clearTimeout</code>. Since the <code>setTimeout</code> callback is only executed once, calling <code>clearTimeout</code> after the <code>callback</code> has executed has no effect. It is, however, possible to cancel <code>setTimeout</code> before it executes, which is a perfectly reasonable requirement:</p>
			<pre>var ref = setTimeout(() =&gt; console.log("fire!"), 200);
setInterval(function() {
  console.log("waiting...");
  clearTimeout(ref);
}, 100);
// ==&gt; waiting...
// ==&gt; waiting...
// ==&gt; waiting...</pre>
			<p>The <code>setTimeout</code> function can be mimicked by the <code>setInterval</code> function by simply clearing its reference after its first timer iteration, like so:</p>
			<pre>var ref = setInterval(function() {
  console.log("Boo!");
  clearInterval(ref);
}, 500);
// ==&gt; Boo!</pre>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor279"/>Timer Parameters</h2>
			<p>In modern browsers (excluding <code>IE9</code> and below), the <code>setInterval</code> and <code>setTimeout</code> functions may receive additional parameters. If any are supplied proceeding the interval parameter, those additional parameters will be passed as parameters to the <code>callback</code> function when it is invoked. This provides a useful means to customize timer functions:</p>
			<pre>var handler = function(p1, p2) {
  console.log(p1, p2);
};
setTimeout(handler, 100, "Hello,", "World!");
// ==&gt; Hello, World!</pre>
			<p>If you anticipate older browsers running your scripts, the same effect may be attained by wrapping the passed <code>callback</code> within an anonymous function call:</p>
			<pre>setTimeout(function() {
  handler("Hello,", "World!");
}, 100);
// ==&gt; Hello, World!</pre>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor280"/>Exercise 6.02: Real-Time Clock</h2>
			<p>It is now time to put your knowledge of timers to use. In this exercise, you will be creating a real-time in-page clock display that will count up in seconds and show the full time using a 24-hour digital clock format. This exercise will make use of an HTML file, albeit a simple one. Let's get started:</p>
			<ol>
				<li value="1">Create a new file called <code>script</code> tag:<pre>&lt;html&gt;
  &lt;script&gt;</pre><p>The <code>script</code> tag will contain the JavaScript to be executed within the page.</p></li>
				<li>Next, you'll need some placeholder variables for the <code>seconds</code>, <code>minutes</code>, <code>hours</code>, and the current <code>Date</code> object instance:<pre>    var secs, mins, hrs, date,</pre></li>
				<li>The <code>handler</code> function you'll use for the timer will also be assigned to a variable called <code>setTime</code>. In it, you will simply populate the preceding variables with the current time components:<pre>    setTime = function() {
      date = new Date();
      hrs = date.getHours();
      mins = date.getMinutes();
      secs = date.getSeconds();</pre></li>
				<li>To output the time to the page, you'll simply need to update the <code>body</code> content. There are better solutions to this that will be explained later in this module:<pre>    document.body.innerHTML = `${hrs}:${mins}:${secs}`;</pre></li>
				<li>Finally, close the function and assign it to an interval. Set the interval to run every <code>500</code> milliseconds to ensure better accuracy:<pre>    }
    setInterval(setTime, 500);</pre></li>
				<li>With the <code>script</code> complete, you should close out the <code>script</code> tag block:<pre>  &lt;/script&gt;</pre></li>
				<li>The page should end with a <code>body</code> tag block, which will contain the clock and the closing <code>html</code> tag:<pre>  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Now, save the page and load it (or drag it) into your browser. You should see the time displayed in the top left-hand corner of the page, and it should update every second. You have successfully built your first timer-based JavaScript application.</li>
			</ol>
			<p>Displaying a real-time clock on a web page is a practical application, particularly within corporate websites and intranets that may exhibit times for several time zones around the world. However, utilizing a timer to update page content is not limited to clocks. This same process could be utilized to update stock market prices, real-time chat forums, or just about any kind of real-time presentation.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor281"/>The JavaScript Events Model</h1>
			<p>As we noted previously, the JavaScript engine utilizes an event loop. In fact, events are at the center point of the JavaScript engine and its language. At its simplest definition, an event is a notification that something has occurred. This may be interaction by the user with a web page or the completion of some process that occurs within the browser.</p>
			<p>To make use of events, a <code>callback</code> function must be assigned to the event type, much like with the timer-based function. However, typically, events are a little more complex and feature-rich than simple timers.</p>
			<p>An event notification is known in programming as a dispatched event. When JavaScript events are dispatched, they are passed an event object. This is true of all JavaScript events. The event object contains useful details about the dispatched event, including the name of the event, a reference to the object that holds the context of the event, and a reference to the object that triggered the event.</p>
			<p>The following table lists the properties of the event object:</p>
			<div><div><img alt="Figure 6.2:  Event Object properties&#13;&#10;" src="img/C14377_06_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2:  Event Object properties</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor282"/>Event Bubbling</h2>
			<p>In order to understand event bubbling, it helps if we understand browser-based HTML. HTML is an abbreviation for HyperText Markup Language, which itself is a derivative of eXtensible Markup Language (XML). HTML is not really a language at all, but a declarative information markup that structures data, which, in the case of websites, is page content.</p>
			<p>HTML is a hierarchical construct that can be best envisaged as a data tree. Imagine the following page content:</p>
			<div><div><img alt="Figure 6.3: HTML mockup&#13;&#10;" src="img/C14377_06_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: HTML mockup</p>
			<p>The structure of the page consists of two columns. On the left is an image and on the right is a container with two rows; the first row contains three buttons and the second row contains a block of text. Like a tree, this layout may look something like this:</p>
			<div><div><img alt="Figure 6.4: HTML data tree&#13;&#10;" src="img/C14377_06_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: HTML data tree</p>
			<p>The preceding tree outlines the visible content of the page, but the <code>body</code> node is not the actual top of the literal HTML tree. Instead, the page content tree starts with a node called the <code>document</code>. This then has a child called <code>html</code>, and that node contains the <code>body</code> node.</p>
			<p>Each node within the HTML tree will raise events if interacted with, even if that node is not immediately visible. When clicking the page with your mouse, for instance, the visible node beneath the mouse arrow that is closest to the bottom of the tree will raise a <code>click</code> event. If one or more event handlers have been assigned to that node, then those handlers will be invoked and will be passed an <code>event</code> object.</p>
			<p>Event bubbling occurs when event handlers are not assigned to the node for that event type or if the event is handled but the event is allowed to continue propagating. At this point, the handlers of the parent node for that specific event are called, and the same process occurs. If the event continues to not be explicitly halted, it will <code>bubble</code> through each parent node until it reaches the <code>document</code> node.</p>
			<p>If multiple handlers exist on a given node for a specific event, any one of those handlers may halt the event, preventing it from bubbling. It is not required for all handlers to halt the event.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor283"/>Traversing the Node Tree</h2>
			<p>In order to handle an event, you first need to add an event type handler to a node. However, to do that, you need some way to acquire a reference to the node on which you wish to listen. JavaScript provides numerous functions for selecting and acquiring nodes based on many different factors, including direct named access, acquisition through node tree traversal, and acquisition by attribute value.</p>
			<p>Of all the nodes within your HTML pages, the easiest to acquire are the <code>body</code> and <code>document</code> nodes. Both of these nodes have simple attribute accessors on the global <code>document</code> object:</p>
			<pre>var document = document.documentElement;
var bodyNode = document.body;
console.log(bodyNode);
// ==&gt; &lt;body&gt;&lt;/body&gt;</pre>
			<p>Once you have a reference to the top of the tree, acquiring a node elsewhere within the tree is simply a matter of traversing it. JavaScript provides several properties for acquiring a node's parent, siblings, or children, each of which uses the <code>familiar relationship</code> metaphor:</p>
			<div><div><img alt="Figure 6.5: Node properties and their description&#13;&#10;" src="img/C14377_06_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Node properties and their description</p>
			<p>Each of these properties can be read from the given node. If a corresponding node cannot be found, then the property will return <code>null</code> (or an empty array in the case of <code>childNodes</code>):</p>
			<pre>var image = document.body.firstChild.firstChild;
image
// ==&gt; &lt;img src="img/packt.png" &gt;
var btn = image.parentNode.nextSibling.firstChild.childNodes[1];
btn
// ==&gt; &lt;button&gt;button 2&lt;/button&gt;</pre>
			<h2 id="_idParaDest-256">Direct Node Acquisition<a id="_idTextAnchor284"/></h2>
			<p>Aside from node tree traversal, JavaScript also provides a means to specify the node reference you require by supplying a node property filter, which is a string value describing the node you require using a specific format.</p>
			<p>All HTML nodes follow a certain pattern:</p>
			<ul>
				<li>They are opened and closed, sometimes in a single tag.</li>
				<li>They have a node name or type.</li>
				<li>They may have an <a id="_idTextAnchor285"/>optional <code>id</code> property, which should be unique to the page.</li>
				<li>They may have one or more optional <code>class</code> names.</li>
				<li>They may have other optional known properties, such as <code>name</code>, <code>styles</code>, <code>type</code>, <code>value</code>, or <code>src</code>.</li>
				<li>They may have optional custom properties, named by the page creator.</li>
			</ul>
			<p>The node's signature is known as its <code>tag</code>, which is defined within angle brackets, with a left-facing angle bracket at the start of the node and a right-facing bracket at the end of the node. Immediately after the left-facing bracket is the node's name. Properties are appended to the node as <code>attribute="value"</code>:</p>
			<div><div><img alt="Figure 6.6: HTML node structure&#13;&#10;" src="img/C14377_06_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: HTML node structure</p>
			<p>The closing tag of a node contains the node's name and is also wrapped with a left-facing and right-facing angle bracket. However, to differentiate it from a new opening tag, its left-facing angle bracket is preceded by a forward-slash (<code>/</code>) character.</p>
			<p>If a node has no children, it is acceptable to immediately close the node without supplying a distinct closing tag. This is accomplished by providing the forward-slash character immediately before the right-facing angle bracket:</p>
			<pre>&lt;img src="img/flower.png" /&gt;</pre>
			<p>The properties of a node are its description. Later, these values allow you to style the node's look-and-feel, but they specifically facilitate the node's data and identity. As such, it is perfectly legitimate to add attributes to nodes in order to make them easily acquirable. The <code>id</code> attribute is one such value that exists solely to differentiate tags and it is important that all the tags that are used within a page have a unique <code>id</code> attribute, if they have one at all. If an <code>id</code> attribute is present, the associated node can be acquired using the <code>getElementById</code> method of the <code>document</code> object:</p>
			<pre>var node = document.getElementById("myTagId");</pre>
			<p>Since node IDs are deemed to be unique, the <code>getElementById</code> method returns a single node, or <code>null</code> if a matching node is not found. If, for some reason, a page contains multiple nodes with the same ID attribute value, then calling <code>getElementById</code> with that value will return the first element found within the page.</p>
			<p>Other similar functions exist in order to query using other tag descriptors, such as the <code>name</code> or <code>class</code>. The majority of these return an array since it is expected that many tags may share matching descriptors. The following table lists some of the common functions for acquiring tag references:</p>
			<div><div><img alt="Figure 6.7: Common functions for tag references&#13;&#10;" src="img/C14377_06_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Common functions for tag references</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor286"/>Assigning and Removing an Event Handler</h2>
			<p>Once you have a node reference, you are then able to assign listeners (or handlers) for specific event types. Listeners can be assigned to a node using the <code>addEventListener</code> function, which accepts two parameters, the type of the event as a string value and the handler of the event as a function:</p>
			<pre>document.body.addEventListener("click", () =&gt; alert("I was clicked"));</pre>
			<p>When an event is dispatched, the event handler is passed a single value, known as an event object. Event objects may have slightly different parameters depending on the event type being handled. The object is actually an instance of a specific event object type. For instance, mouse-based events, such as <code>click</code> or <code>mousedown</code>, generate <code>MouseEvent</code> objects. These differ from many other events in that they contain <code>x</code> and <code>y</code> values detailing the mouse coordinates within the web document at the time the event was dispatched:</p>
			<pre>document.body.addEventListener("click", function(evt) { console.log(evt); });
// ==&gt; MouseEvent {isTrusted: true, screenX: 230, screenY: 499, clientX: 163, clientY: 400, …}</pre>
			<p>When attaching an event handler, it will not overwrite existing handlers attached to that node, even if the handler is assigned to the same event type. In fact, a node may have any number of event listeners attached at any one time. This way, multiple facets of your application can independently access the same event notifications for the same object, as needed. What is not possible, however, is for the same <code>function reference</code> to be assigned more than once to the same event type, like so:</p>
			<pre>var display = () =&gt; console.log("Clicked");
document.body.addEventHandler("click", () =&gt; console.log("I was clicked");
document.body.addEventHandler("click", () =&gt; console.log("I was clicked");
document.body.addEventHandler("click", display);
document.body.addEventHandler("click", display);  // this one will not be output
// ==&gt; I was clicked
// ==&gt; I was clicked
// ==&gt; Clicked</pre>
			<p>In the preceding example, since the <code>display</code> function is a single reference, the second listener assignment was simply ignored. JavaScript will not repeat the function invocation more than once. However, the previous assignments were both invoked because, although the functionality was the same, the functions themselves possessed different references.</p>
			<p>If you wish to remove an event handler, you can do so with the <code>removeEventListener</code> method, which takes identical parameters to its counterpart:</p>
			<pre>document.body.removeEventListener("click", display);</pre>
			<p>The <code>removeEventListener</code> method finds the handler association by reference. This means that any event listener assignments you make using anonymous functions cannot be removed using the <code>removeEventListener</code> method.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you dispose of a node that has event handlers attached to it, it will not be cleaned up by the JavaScript engine's <code>garbage Collector</code>. Removing nodes without cleaning up their event handlers is a common cause of memory leaks in JavaScript, which leads to poor application performance. If you know a node may be removed from the <code>DOM</code>, do not add event listeners to it, or its children, using anonymous functions.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor287"/>Exercise 6.03: Tabbed Content</h2>
			<p><a id="_idTextAnchor288"/>In this exercise, you'll use what you have learned so far to create a tabbed display. The display will utilize three buttons at the top of the page, with a container <code>div</code> tag at the bottom. When a button is pressed, content associated with the button handler will be displayed within the container <code>div</code> tag. Let's get started:</p>
			<ol>
				<li value="1">First, create a new document called <strong class="bold">tabs.html</strong> and add the starting HTML:<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Tabbed Display&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;</pre></li>
				<li>The three buttons will sit side by side in a single container <code>div</code>. Each one will have a unique ID so that we can easily reference them:<pre>    &lt;div&gt;
      &lt;button id="btn1"&gt;Tab One&lt;/button&gt;
      &lt;button id="btn2"&gt;Tab Two&lt;/button&gt;
      &lt;button id="btn3"&gt;Tab Three&lt;/button&gt;
    &lt;/div&gt;</pre></li>
				<li>Next, add the container <code>div</code>. We'll add a descriptive body to inform the user of the page. However, once a button has been pressed, that content will disappear for good and will be replaced by dynamic content:<pre>    &lt;div id="container"&gt;Click a button!&lt;/div&gt;</pre></li>
				<li>With the structure of the page in place, you can now close out the body and begin the <code>script</code> block:<pre>  &lt;/body&gt;  &lt;script&gt;    var btn1 = document.getElementById("btn1"),
      btn2 = document.getElementById("btn2"),
      btn3 = document.getElementById("btn3"),
      container = document.getElementById("container");</pre><p>Here, we've created a variable for each element in the page we need to interact with. This makes the code neater and cleaner.</p></li>
				<li>Next, you'll need some content to add when the buttons are pressed, one for each button:<pre>    var content1 = "Button 1 was pressed",
      content2 = "Button 2 was pressed",
      content3 = "Button 3 was pressed";</pre></li>
				<li>Now, we need to wire up the content. To do this, simply add an event listener to each button, updating the container <code>div</code> content in each one:<pre>    btn1.addEventListener("click", () =&gt; container.innerHTML = content1);
    btn2.addEventListener("click", () =&gt; container.innerHTML = content2);
    btn3.addEventListener("click", () =&gt; container.innerHTML = content3);</pre></li>
				<li>Now, simply close out the open tags and save the page:<pre>  &lt;/script&gt;
&lt;/html&gt;</pre></li>
				<li>That's it. If you now run the page in your browser and click each button, you should see that the content has been updated. <p>The interactive page is as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 6.8: Tabbed control exercise&#13;&#10;" src="img/C14377_06_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Tabbed control exercise</p>
			<p>This has been your first exploration of interactive content. Manipulating page content based on user interactivity is a common requirement for JavaScript and is something it excels at. Through careful planning and good coding practices, it is possible to create JavaScript applications that can mimic almost any kind of native software application.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor289"/>Bubbling versus Capturing</h2>
			<p>So far, you've seen that event bubbling is where an event bubbles up from the node that dispatched it to the top of the tree, but JavaScript also provides an alternative to bubbling called capturing.</p>
			<p><code>Event capturing</code> is where events are handled in the reverse order to bubbling, capturing notifications from the node that dispatched it to the bottom of the tree. This means that, when a node is interacted with, its attached event handlers may not be the first to intercept the event. Instead, a parent (or ancestor) may receive the event first, instead. If one of those ancestral handlers halts the event, then the handlers on the node that gave rise to the event may never actually be invoked at all:</p>
			<div><div><img alt="Figure 6.9: Bubbling versus capturing&#13;&#10;" src="img/C14377_06_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Bubbling versus capturing</p>
			<p>To attach an event handler to a capture event, you simply need to pass a third parameter to the <code>addEventListener</code> method. This third parameter is known as the <code>useCapture</code> parameter and is a Boolean. If set to <code>true</code>, the attached event will be assigned in <code>capture</code> mode. Thus, not supplying the <code>useCapture</code> parameter to the <code>addEventListener</code> method is the same as supplying <code>false</code> for that parameter:</p>
			<pre>var clickHandler = () =&gt; console.log("clicked");
document.body.addEventListener("click", clickHandler);
// ==&gt; clicked</pre>
			<p>Event handlers that are attached to capture events sit in a different space to bubbling event listeners. When assigning capturing events, they will not conflict with bubbling events. Therefore, assigning a function reference as an event handler as both bubbling and capturing, using the same event type on the same node, will mean that function will be called twice when that event is dispatched:</p>
			<pre>var clickHandler = () =&gt; console.log("clicked");
document.body.addEventListener("click", clickHandler);
document.body.addEventListener("click", clickHandler, true);
// ==&gt; clicked
// ==&gt; clicked</pre>
			<p>To remove an event that's been added with <code>useCapture</code> set to <code>true</code>, you simply pass the same <code>useCapture</code> value to the <code>removeEventListener</code> method:</p>
			<pre>document.body.removeEventListener("click", clickHandler, true);</pre>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor290"/>The JavaScript Event Life Cycle</h1>
			<p>R<a id="_idTextAnchor291"/>egardless of which node has dispatched the event, all event notifications start at the <code>document</code> node. They then travel in capture mode through the tree branches toward the node that dispatched it (the <code>target</code> node). Once all the appropriate capture handlers along that path have been invoked, the event then travels back to the <code>document</code> node, invoking all the appropriate bubbling handlers.</p>
			<p>When traveling down the tree, the event is said to be in its capture phase and is said to be in its bubbling phase when returning to the <code>document</code> node. It is in its target phase when the target nodes handlers are invoked, regardless of whether it is its capturing handler or bubbling handler.</p>
			<p>At any point in an event's round-trip travels, it may be halted by a handler, preventing all further event handlers from being invoked.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor292"/>Halting Event Propagation</h2>
			<p>Sometimes, when handling events, you may need to stop an event in its tracks. Knowing an event may be acted upon elsewhere in your page, it may make sense to halt an event if the conditions within your app are not in a state to allow the event to continue.</p>
			<p>For instance, if an event is dispatched when a user enters a new password within a <code>textfield</code> control, the event may be useless if the password does not meet certain requirements, such as consisting of too few characters or including characters that are not allowed.</p>
			<p>JavaScript provides two similar functions to halt events: <code>stopPropagation</code> and <code>stopImmediatePropagation</code>. Both functions are methods of the event object that are passed to event handlers as their sole parameters.</p>
			<p>The <code>stopPropagation</code> method will prevent event handlers on further nodes along its journey from being invoked, regardless of whether the event is in its capturing phase or bubbling phase. However, it will still allow all remaining as-yet-uninvoked event handlers for the current event type to execute if they are on the same node as the event handler that called <code>stopPropagation</code>. The <code>stopImmediatePropagation</code> method will stop all further handlers, including those as-yet-uninvoked on the current node:</p>
			<pre>var handler = function(ev) {
  if (ev.target.value.length &lt; 6) {
    ev.stopImmediatePropagation();
  }
};</pre>
			<p>Either method may be invoked anywhere within a handler and may be called in multiple handlers, though only the first instance will execute.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor293"/>Halting Event Actions</h2>
			<p>Some events within the JavaScript engine result in an action. An action is a browser-specific response to an event, outside of your own custom event handlers. Examples of this include the submission of a <code>form</code> or a page redirection when clicking a link.</p>
			<p>Actions occur after the event bubbling phase, once the event has finished its journey through the node tree. If an event is stopped due to the invocation of either <code>stopPropagation</code> or <code>stopImmediatePropagation</code>, the action will still occur.</p>
			<p>To prevent an action, the event object's <code>preventDefault</code> method must be called:</p>
			<pre>var handler = function(ev) {
  ev.preventDefault();
}</pre>
			<p>Calling <code>preventDefault</code> does not halt the event passing through the capture or bubbling phases. Therefore, if you want to stop an event in its tracks and prevent its action, you must call both types of method:</p>
			<pre>var handler = function(ev) {
  ev.stopPropagation();
  ev.preventDefault();
}</pre>
			<p>Note that not all events can be prevented from initiating an action. Each dispatched event contains a property called cancelable. If this property is <code>true</code>, then it can be canceled by calling its <code>preventDefault</code> method. If, however, the property is <code>false</code>, then calling <code>preventDefault</code> will do nothing to change its behavior:</p>
			<pre>var handler = function(ev) {
  if (ev.cancelable) {
    ev.preventDefault();
  }
};</pre>
			<p>The <code>onload</code> event is one such event that can't be canceled, and with good reason, since it is imperative that the event completes its life cycle to ensure the proper functionality of the browser. Conversely, a form <code>onsubmit</code> event is cancelable since its success must be at the discretion of the page's business logic.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor294"/>Exercise 6.04: Conditional Event Prevention</h2>
			<p>In this exercise, you will create a group of links. Each link, when clicked, will raise a <code>click</code> event. Above these links, the containing <code>div</code> will listen for the event each one raises and will determine if it should stop the event propagation, stop its action, or stop both. Let's get started:</p>
			<ol>
				<li value="1">Let's start by creating a document called <strong class="bold">ev-prev.html</strong> and adding some HTML code:<pre>&lt;h<a id="_idTextAnchor295"/>tml&gt;
  &lt;body&gt;
    &lt;div id="container"&gt;
      &lt;a href="https://google.com"&gt;Google&lt;/a&gt;
      &lt;a href="https://bing.com"&gt;Bing&lt;/a&gt;
      &lt;a href="https://yahoo.com"&gt;Yahoo&lt;/a&gt;
    &lt;/div&gt;
    &lt;div id="message"&gt;&lt;/div&gt;
  &lt;/body&gt;</pre><p>Here, we have a container with three links and a secondary container for output messages.</p></li>
				<li>Next, open a <code>script</code> tag for the JavaScript and create variables to reference the <code>link</code> container, the links themselves, and the <code>message</code> container:<pre>  &lt;script&gt;
    var container = document.getElementById("container"),
        links = container.children,
        msg = document.getElementById("message");</pre></li>
				<li>When each link is clicked, we want a message to display, showing which link was clicked. Therefore, we will attach an <code>event listener</code> to the <code>link</code> container so that when the events bubble up, the handler will be there to catch the event object and identify which link dispatched the event:<pre>    container.addEventListener("click", function(ev) {
      msg.innerHTML = `$<a id="_idTextAnchor296"/>{ev.target.text} clicked`;
      console.log(`${ev.target.text} clicked`);
    });</pre></li>
				<li>Then, we will add a behavior for each link. The first will prevent actions, the second will stop <code>propagation</code>, and the third will do both:<pre>    links[0].addEventListener("click", function(ev) {
      ev.preventDefault();
    });
    links[1].addEventListener("click", function(ev) {
      ev.stopPropagation();
    });
    links[2].addEventListener("click", function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
    });</pre></li>
				<li>Finally, close out the <code>script</code> tag and <code>html</code> tag:<pre>  &lt;/script&gt;
&lt;/html&gt;</pre></li>
				<li>By running this page in a browser, you should see that the first link will print <code>Google</code> clicked in the message container, the second will redirect the user to the <code>Bing</code> website, and the third will do nothing at all. When clicking the second link, the message is never displayed because the event propagation is stopped in the handler.<p>You have now successfully marshaled events and caught them as they bubbled up through the node tree:</p></li>
			</ol>
			<div><div><img alt="Figure 6.10: Event prevention&#13;&#10;" src="img/C14377_06_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: Event prevention</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor297"/>Event Triggers</h1>
			<p>Yo<a id="_idTextAnchor298"/>u have seen that events are dispatched dynamically when interacting with a web page, but events can also be triggered manually, through your own code.</p>
			<p>As we mentioned previously, events in JavaScript are typed objects. When a dynamic event is raised, the JavaScript engine creates such an object and dispatches it. The object contains a type value that stores the event type as a string, such as <code>click</code>.</p>
			<p>It is possible to instantiate your own event objects and dispatch them, rather than simply relying on events being created dynamically. There are many reasons why you might like to do this, such as to simulate user interaction or to easily invoke code already assigned as an event handler without duplicating code. To do so, you simply create an instance of an <code>Event</code> using the <code>new</code> keyword and pass it the type of event you wish to raise:</p>
			<pre>var ev = new Event("click");</pre>
			<p>Once created, you then simply dispatch it using the node's <code>dispatchEvent</code> method:</p>
			<pre>someNode.dispatchEvent(ev);</pre>
			<p>The node that the <code>dispatchEvent</code> method is called from becomes the event object's target property. Once dispatched, the event enters the capture phase down through the <code>DOM</code> to this node, then the bubbling phase back up from it as normal, triggering event listeners as it goes.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor299"/>Custom Events</h2>
			<p>The <code>Event</code> object is the simplest type of event provided by the JavaScript framework. In fact, all the other events provided by JavaScript extend the simple <code>Event</code> type. However, the <code>Event</code> object by itself is not very flexible and does not provide a means of easily attaching additional data for an event. To alleviate this, the JavaScript language supplies the <code>CustomEvent</code> type, that is, an event specifically designed for custom developer events.</p>
			<p>When instantiated, the <code>CustomEvent</code> object accepts an additional named parameter called <code>detail</code>. By providing an object with a <code>detail</code> property as the second constructor parameter, the value of that property is then available to all event handlers that intercept it, like so:</p>
			<pre>var event = new CustomEvent("click", {detail: 123});</pre>
			<p>Now, any event handlers that may intercept this event can retrieve the detail value by simply referencing it:</p>
			<pre>var handler = function(ev) {
  var value = ev.detail;  // value is now 123
};</pre>
			<p><code>CustomEvent</code> exists for more than just manually triggering native event types; it is also possible to create your own event types. The name that's passed to an event object when it is created may be any string you choose. By listening for that event, you are able to handle it just like events built into the JavaScript engine:</p>
			<pre>var event = new CustomEvent("myEvent", {detail: 42});
someContainer.addEventListener("myEvent", someEventHandler);
someNode.dispatchEvent(event);</pre>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor300"/>Native Event Triggers</h2>
			<p>The<a id="_idTextAnchor301"/>re are many native event types in the JavaScript language, some with actions and some without. So far, you have seen the <code>click</code> event being used, but there are far more than that. The mouse events group alone includes <code>15</code> different event types, and there are over <code>40</code> different groups of events, including the following:</p>
			<ul>
				<li>Network</li>
				<li>Element focus</li>
				<li>Web sockets</li>
				<li>CSS animations and transitions</li>
				<li>Forms</li>
				<li>Printing</li>
				<li>Keyboard interactivity</li>
				<li>Element drag and drop</li>
				<li>Window and document events</li>
			</ul>
			<p>There are even events that occur through touch screen display interaction, virtual reality headsets, device battery changes, smartcard events, and many, many more.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor302"/>Event Hander Attributes</h2>
			<p>When building out your HTML page, the HTML specification also caters to infix event handling notation. This is where event handlers are assigned within the HTML nodes themselves. Infix event notation is known in HTML as event attributes. There are numerous available event attribute types, though not as many as there are event types provided by JavaScript.</p>
			<p>Event attributes typically have names that are identical to their native JavaScript event type counterparts but are prepended with the word <code>on</code>. For instance, the <code>click</code> event would be assigned to a node as the <code>onclick</code> attribute:</p>
			<pre>&lt;div id="someNode" onclick="someFunction();"&gt;&lt;/div&gt;</pre>
			<p>The value of the event attribute is an executable JavaScript statement, such as a function invocation.</p>
			<p>DOM nodes can only support one event attribute of each type; it is not possible, for instance, to provide two <code>onclick</code> attributes in a single node. However, event attributes can execute multiple statements within a single attribute by ensuring the correct use of the semi-colon character to distinguish the separate statements:</p>
			<pre>&lt;div id="someNode" onclick="someFun1(); someFun2();"&gt;&lt;/div&gt;</pre>
			<p>Functions called as event attribute handlers are not passed an event object. However, unlike typical event handlers, they can be called with additional parameters. For instance, to pass a reference to the node containing the event attribute, the event attribute function statement can be passed the <code>this</code> context:</p>
			<pre>&lt;div id="someNode" onclick="someFunction(this);"&gt;&lt;/div&gt;</pre>
			<p>In this instance, <code>this</code> resolves as the first parameter, which is a reference to the <code>div</code> node.</p>
			<p>Many developers consider event attributes to be a last resort since their inclusion mixes the view (HTML) with the logic (JavaScript). The recommended option is to always assign event handlers dynamically using <code>addEventListener</code>.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor303"/>Events and Memory</h2>
			<p>In the previous chapter, the <code>delete</code> keyword was introduced and a chapter regarding memory management was touched upon. When working with event handlers, managing memory becomes very important. If an event handler is attached to a node but that node is then removed from the page <code>DOM</code>, it may not be cleaned up by the JavaScript engine's <code>garbage collector</code> (cleaned from memory) until the handler is removed from the node. This is particularly true if the event handler is not an anonymous function.</p>
			<p>When using events against nodes that may be deleted from the <code>DOM</code>, ensure you perform a proper cleanup of your nodes and handlers. This may mean removing the event handlers and properly deleting a variable's contents prior to removal.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor304"/>Working with Forms</h1>
			<p>Forms are an integral part of the HTML specification and exist separately to the JavaScript engine, though they are also fully interactive with JavaScript. HTML forms are declarative structures are defined using the <code>form</code> tag. This tag outlines a context that can be submitted, and its data is sent to a remote server location.</p>
			<p>To understand how the <code>form</code> tag works, it helps to understand HTTP requests, their type differentiation, and how data is sent within the request.</p>
			<h2 id="_idParaDest-270">HTT<a id="_idTextAnchor305"/>P</h2>
			<p>HTT<a id="_idTextAnchor306"/>P is a specification, the long form of which is <code>HyperText Transfer Protocol</code>. It was originally released as <code>HTTP 1.0</code> in 1990 and detailed in the <code>RFC 1945</code> specification (where 1945 is the specification number, not a year). This transport format was designed for the transfer of HyperText documents across the internet, such as <code>HyperText Markup Language</code> (HTML) documents.</p>
			<p>Within the HTTP specification, numerous metadata is identified that can be sent with an <code>HTTP request</code>. This metadata is known as <strong class="bold">headers</strong>, as it sits within the starting bytes of a request packet and is used to identify how the request is read.</p>
			<p>The HTTP protocol provides an option to identify the purpose of the request packet, known as the <code>Method</code>. There are numerous <code>Method</code> options available, some of which are parsed and read differently by the HTTP servers that receive them, though their use may also be simply contextual. Two of the most common HTTP <code>Methods</code> are <code>GET</code> and <code>POST</code>.</p>
			<p><code>GET</code> is a method that simply means "<code>get me information at this address</code>", where the address is the URL the request was sent from. When making a <code>GET</code> request, parameters may be appended to the address in the form of query variables or as part of the path itself, which the server could then make use of in some way. However, in early versions of the <code>HTTP protocol</code>, <code>Uniform Resource Locator</code> (<code>URL</code>) addresses were only supplied with up to <code>255</code> characters, including the protocol and domain address, which proved tricky for larger amounts of data, including file uploads. To alleviate this problem, the specification also provides a <code>Method</code> called <code>POST</code>.</p>
			<p><code>POST</code> is an extension of <code>GET</code> and allows us to include a request <code>body</code>. In an HTTP request, a <code>body</code> is the packet content that is included after the headers; thus, it is the literal packet body:</p>
			<div><div><img alt="Figure 6.11: HTTP packet&#13;&#10;" src="img/C14377_06_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11: HTTP packet</p>
			<p>Since nothing follows the <code>body</code> in the request packet, the <code>body</code> is able to be much larger than the <code>GET</code> limitation of <code>255</code> characters.</p>
			<p>When sending a <code>body</code> with a request, the sender is able to provide a <code>Content-Type</code> header, which describes the format (or MIME type) of the <code>body</code>. For instance, if the body is a <code>JavaScript Object Notation</code> (<code>JSON</code>) string, then the request's <code>Content-Type</code> may be <code>application/jpeg</code>.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor307"/>The Form Tag</h2>
			<p>The <code>form</code> tag has existed in HTML since its public inception and is detailed in the <code>HTML RFC 1866</code> specification. The <code>form</code> tag typically encloses elements of a literal form, presented visibly to users of an HTML page. As with any HTML node, a <code>form</code> tag may be styled visually or left invisible as required:</p>
			<pre>&lt;form method="POST" action="/data/form-handler.php" enctype="text/plain"&gt;
   ...
&lt;/form&gt;</pre>
			<p>The attributes of the form tag include the following:</p>
			<div><div><img alt="Figure 6.12: Form Tag attributes and their description&#13;&#10;" src="img/C14377_06_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12: Form Tag attributes and their description</p>
			<p>In comparison to the HTTP packet specification, the <code>method</code> attribute is equivalent to the method of the HTTP packet itself, the <code>action</code> is the same as the URL parameter, and the <code>enctype</code> is the same as the <strong class="bold">Content-Type</strong> header value.</p>
			<p>The <code>form</code> tag provides a logical request block around groups of input controls. Each <code>form</code> tag within a web page needs to be submitted for a request to be formulated and sent. Submission can occur dynamically with JavaScript or via user interaction through the use of a <code>submit</code> button control:</p>
			<pre>&lt;form method="POST" action="/data/form-handler.php" target="_top"&gt;
  &lt;input type="submit" value="submit" /&gt;
&lt;/form&gt;</pre>
			<p>When you prefer direct user interaction, forms may be submitted using either a <code>submit</code> or an <code>image</code> input control, where the latter provides a means to display a styled graphic as the submission button:</p>
			<pre>&lt;form method="POST" action="/data/form-handler.php" target="_top"&gt;
  &lt;input type="image" src="img/send-btn.png" /&gt;
&lt;/form&gt;</pre>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor308"/>Submitting a Form with JavaScript</h2>
			<p>Sometimes, it is not appropriate to send a <code>form</code> request via user interaction. Instead, forms may send data after an animation has completed or perhaps redirect a user once their browser capabilities have been discovered. At such times, it helps to be able to trigger a form's submission dynamically using JavaScript.</p>
			<p>As with all DOM-based interaction, submitting a form first requires the acquisition of the form node. Once acquired, a form can be submitted by simply calling its <code>submit</code> function:</p>
			<pre>var form = document.getElementsByTagName("form")[0];
form.submit();</pre>
			<p>Note that more than one form tag may exist within a page. Form tags may include identification and style-based attributes, the same as any other tag, such as <code>name</code>, <code>id</code>, <code>class</code>, and <code>style</code>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor309"/>Form Submission Events</h2>
			<p>The <code>form</code> tag supports a number of useful events oriented around controls and form handling. The most useful of these events is the <code>submit</code> event.</p>
			<p>The <code>submit</code> event is dispatched when the form is submitted, but prior to the request actually being sent to the designated endpoint. This event is typically used for validating the user-supplied values of the form to ensure that no obvious mistakes were made or to ensure that the required fields have been completed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since the <code>submit</code> event is dispatched before the request is sent, be sure not to redirect the user to another page using this event or to do anything that will prevent the form submission from completing. If you wish to halt the form's submission, see the Preventing Form Submission section.</p>
			<p>Like many events, the <code>submit</code> event handler may be assigned to a form node using explicit HTML attribute syntax:</p>
			<pre>&lt;form method="GET" action="/endpoint" onsubmit="myFormHandler()"&gt;</pre>
			<p>The <code>submit</code> event functions just like any other event, meaning that it captures from and bubbles to the <code>document</code> node.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor310"/>Preventing Form Submission</h2>
			<p>Stopping a <code>form</code> from submitting is a common requirement in HTML and JavaScript. Often, if the validation of the <code>form</code> fails, it is preferable to cancel the submission and display appropriate messages to the user. To cancel a <code>form</code> submission, we could call the <code>preventDefault</code> method of the event, which stops the eventual action of the event, just like it does with other event types. An alternative method is to return the <code>false</code> value from the function.</p>
			<p>Returning <code>false</code> from an event handler has the same effect as calling the event's <code>preventDefault</code> function, but it doesn't halt the capturing/bubbling.</p>
			<p>If your function is handling a jQuery event, returning <code>false</code> is the same as performing both the <code>preventDefault</code> and <code>stopPropagation</code> method calls:</p>
			<pre>function formHandler(ev) {
  if (document.getElementById("password").value().length &lt; 3) {
    alert("Password is too short");
    return false;
  }
};</pre>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor311"/>Resetting a Form</h2>
			<p>Resetting a form means returning the form to its initial state. This feature is provided as a way to restore a form to a clean state, or if the form was loaded with default or original values, then it returns those values to each of the controls.</p>
			<p>Website users may sometimes require a reset capability if they're working with complex values. Being able to reset a form saves the user from having to memorize the initial values present in the form, or at least to quickly return to the original state prior to repopulating the form.</p>
			<p>Like submitting, resetting a form may be carried out via user interaction through the use of a reset input control:</p>
			<pre>&lt;form method="GET" action="/endpoint"&gt;
  &lt;input type="reset" value="Reset Form" /&gt;
&lt;/form&gt;</pre>
			<p>Once the control has been clicked, the <code>form</code> will revert to its initial state.</p>
			<p>Another means to reset a form is by using the <code>reset</code> method of the <code>form</code> node:</p>
			<pre>document.getElementByTagName("form")[0].reset();</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">A <code>form</code> <code>reset</code> cannot be reversed automatically. If such a feature is required, all the values of the form will need to be saved first and then individually reapplied to the controls.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor312"/>Form Reset Event </h2>
			<p><a id="_idTextAnchor313"/>When resetting a form, the browser will raise the <code>reset</code> event. The handler for the reset event may be applied explicitly within the HTML node's declaration:</p>
			<pre>&lt;form method="GET" action="/endpoint" onreset="myResetHandler()"&gt;</pre>
			<p>Similarly, form reset events may be handled by simply assigning the event handler with JavaScript:</p>
			<pre>document.getElementByTagName("form")[0].addEventListener("reset", myResetHandler);</pre>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor314"/>Exercise 6.05: Simple Form Handling</h2>
			<p>In this exercise, you will create a simple form with <code>submit</code> and <code>reset</code> buttons. When submitting, the form action will be canceled, but the submitted values will still be handled and displayed on the screen. This is the first step to creating a form validation system. Let's get started:</p>
			<ol>
				<li value="1">Let's begin with the standard opening HTML boilerplate:<pre>&lt;html&gt;
  &lt;body&gt;</pre></li>
				<li>Next, create the opening form tag. This will be given an ID, for ease of acquisition, and will provide a random action URL since it won't be used in this exercise:<pre>    &lt;form id="myForm" method="GET" action="http://google.com"&gt;</pre></li>
				<li>To make this more interesting, let's introduce a simple <code>text</code> field control. It won't be used, per se, but it will help demonstrate the reset functionality:<pre>      &lt;input type="text" value="original text" /&gt;</pre><p>Input controls will be discussed in the next section of this chapter.</p></li>
				<li>Now, you will need the two buttons: one for <code>submit</code> and one for <code>reset</code>:<pre>      &lt;input type="submit" value="Submit" /&gt;
      &lt;input type="reset" value="Reset" /&gt;</pre></li>
				<li>Finally, let's close out the <code>form</code> tag and open the <code>script</code> tag, ready for our JavaScript:<pre>    &lt;/form&gt;    &lt;script&gt;</pre></li>
				<li>The <code>reset</code> button handler will be simple. Once clicked, display a message in the console. However, you won't be attaching the handler to the button's <code>click</code> event as doing that will not provide the power to stop the <code>reset</code>, should you wish to. Instead, the event will be assigned to the form's <code>reset</code> event:<pre>      function resetHandler(ev) {
        console.log("form has been reset");
      };
      document.getElementById("myForm").addEventListener("reset", resetHandler);</pre></li>
				<li>Likewise, with the <code>submit</code> handler, the form's <code>submit</code> event will be listened to. In this instance, however, you will call <code>ev.preventDefault()</code> from the handler to prevent the form from actually submitting:<pre>      function submitHandler(ev) {
        console.log("form has been submitted");
        ev.preventDefault();
      };
      document.getElementById("myForm").addEventListener("submit", submitHandler);</pre></li>
				<li>Finally, close out the <code>script</code> tag and the page:<pre>    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<div><div><img alt="Figure 6.13: Form buttons&#13;&#10;" src="img/C14377_06_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13: Form buttons</p>
			<p>That's it. Now, if you run the page in the browser, you will see that clicking <code>submit</code> will display one message in the console, while the <code>reset</code> button will show another. Also, clicking <code>reset</code> will always revert the text in the text field to the words original text.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor315"/>Form Controls</h1>
			<p>Form tags are pretty useless without data to send. This data is typically provided using the various form controls or widgets that are available in the HTML specification. Where possible, and where the control has no child nodes, a form control typically utilizes the <code>input</code> node tag type. Other controls include <code>select</code>, <code>textarea</code>, <code>button</code>, and <code>datalist</code>. We will look at each of these control types throughout the rest of this chapter.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor316"/>Input Controls </h2>
			<p>The majority of the controls that are available to HTML forms are provided using the <code>input</code> tag. The <code>input</code> tag requires a <code>type</code> parameter, which displays a relative control within the HTML page:</p>
			<pre>&lt;input type="text" /&gt;</pre>
			<p>The following are the types that are available in modern browsers when using the <code>input</code> control.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor317"/>The Button Control </h2>
			<p>The <code>button</code> control appears very much like the <code>submit</code> and <code>reset</code> form buttons. However, unlike <code>submit</code> and <code>reset</code>, the <code>button</code> control has no default action:</p>
			<pre>&lt;input type="button" onclick="buttonHandler();" value="Clickable Button" /&gt;</pre>
			<p>The <code>button</code> control also has an alternative tag format, which we can use by using the <code>button</code> tag:</p>
			<pre>&lt;button onclick="buttonHandler();"&gt;Clickable Button&lt;/button&gt;</pre>
			<p>Note that the <code>input</code> format requires a label to be passed in the <code>value</code> attribute, while the <code>button</code> tag format requires the button text to be passed as content using a closing <code>button</code> tag, like so:</p>
			<div><div><img alt="Figure 6.14: Button input control&#13;&#10;" src="img/C14377_06_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14: Button input control</p>
			<p>The button control supports the <code>click</code> event, or the <code>onclick</code> attribute, as we explained earlier in this chapter.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor318"/>The Checkbox Control </h2>
			<p>The <code>checkbox</code> control represents a "true or false," "on or off," or "yes or no" control:</p>
			<pre>&lt;input type="checkbox" checked /&gt;</pre>
			<p>The <code>checked</code> parameter in the preceding example is a valueless attribute. When supplied, the <code>checkbox</code> is presented checked by default and will be set to check whether the encompassing <code>form</code> is reset.</p>
			<p>An alternative implementation of this is to supply a value for <code>checked</code>:</p>
			<pre>&lt;input type="checkbox" checked="checked" /&gt;</pre>
			<p>Any values supplied with valueless attributes are disregarded, and thus any value may be provided:</p>
			<div><div><img alt="Figure 6.15: Checkbox input control&#13;&#10;" src="img/C14377_06_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15: Checkbox input control</p>
			<p>The <code>checkbox</code> control supports the <code>change</code> and <code>input</code> events. The <code>input</code> event will be dispatched whenever the <code>value</code> parameter of a control is changed, while the <code>change</code> event is raised only when the <code>value</code> of that control is committed, such as when losing focus or when the <em class="italic">Enter</em> key is pressed. Typically, there is very little difference between the two events when they're used with the <code>checkbox</code> control, though it is deemed preferable to always use the <code>change</code> event.</p>
			<p>When a <code>checkbox</code> is present in a form, its value is only submitted if it is <code>checked</code>. When unchecked, no value is passed to the handling script at all.</p>
			<p>To check the checked status of a checkbox using JavaScript, simply query its <code>checked</code> parameter:</p>
			<pre>&lt;input type="checkbox" id="check" value="1" checked /&gt;
&lt;script&gt;
  var chk = document.getElementById("check");
  console.log(chk.checked);  // ==&gt; true
&lt;/script&gt;</pre>
			<p>The value of <code>checked</code> will be <code>true</code> if the control is checked, or <code>false</code> if it isn't.</p>
			<p>To set the <code>checked</code> state of the control, simply pass a <code>Boolean</code> value to the <code>checked</code> parameter.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor319"/>The Radio Control </h2>
			<p>The <code>radio</code> control is similar to the <code>checkbox</code> control, with the exception that it handles multiple-choice options. Unlike a <code>checkbox</code> control, a <code>radio</code> control cannot be deselected by clicking on it. Instead, a different option must be selected, thereby providing at least one result when submitting the <code>form</code>:</p>
			<pre>&lt;input type="radio" name="color" value="red" checked /&gt;
&lt;input type="radio" name="color" value="blue" /&gt;
&lt;input type="radio" name="color" value="green" /&gt;</pre>
			<p>The <code>name</code> attribute of the <code>radio</code> control provides the grouping functionality. If a different <code>name</code> is provided from previous <code>radio</code> controls, then that new control belongs to a different group. Only by clicking the <code>radio</code> controls within the same group can the previously selected <code>radio</code> control be deselected:</p>
			<div><div><img alt="Figure 6.16: Radio input control&#13;&#10;" src="img/C14377_06_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: Radio input control</p>
			<p>Like the <code>checkbox</code> controls, the <code>radio</code> control is selected using the <code>checked</code> attribute. If a <code>radio</code> control group is present within a page, but none of the controls have been set to <code>checked</code>, none of those <code>radio</code> controls will be selected. At such times, submitting the parent form will mean that the <code>radio</code> group is absent from the sent data.</p>
			<p>To dynamically check a specific <code>radio</code> button (and thus uncheck the currently selected one), there needs to be a means to reference the specific <code>radio</code> control you wish to check. There are several ways to do this, such as providing a unique <code>id</code> for each <code>radio</code> control in a group, but by far the most efficient is to simply reference its index in the group. For instance, to select the second <code>radio</code> button in a group, we may do this:</p>
			<pre>&lt;input type="radio" name="color" value="red" checked /&gt; red
&lt;input type="radio" name="color" value="blue" /&gt; green
&lt;input type="radio" name="color" value="green" /&gt; blue
&lt;script&gt;
  var chk = document.getElementsByName("color")[1];  // select index 1
  chk.checked = true;
&lt;/script&gt;</pre>
			<p><code>getElementsByName</code> returns an array of all the elements matching the passed criteria. Therefore, providing an index enables direct access to a given element index.</p>
			<p><code>radio</code> control supports the <code>input</code> and <code>change</code> events, much like the <code>checkbox</code> control.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor320"/>The Text Control </h2>
			<p>The <code>text</code> control is the most basic of all <code>input</code> control types and is used to create free-text fields. These fields allow for single-line text strings to be entered using the keyboard, though text may also be pasted into it using the browser context menu. Text fields are created by setting the <code>type</code> attribute of the <code>input</code> control to <code>text</code>:</p>
			<pre>&lt;input type="text" name="color" value="red" /&gt;</pre>
			<p>The permissible content of a <code>text</code> control may be restricted by supplying a <code>pattern</code> attribute value in the form of a regular expression. As an example, a text field can be restricted to accept only numerical values with the following code:</p>
			<pre>&lt;input type="text" name="num" pattern="[0-9]" title="Enter a number" /&gt;</pre>
			<p>When using the preceding text field, submitting a value other than a number will result in the form submission terminating and a tooltip displaying alongside the <code>text</code> field with the text <strong class="bold">Enter a number</strong>. The form data will not be submitted under this circumstance:</p>
			<div><div><img alt="Figure 6.17: Text input control with the pattern attribute&#13;&#10;" src="img/C14377_06_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: Text input control with the pattern attribute</p>
			<p>Another feature of the <code>text</code> field is the <code>placeholder</code> attribute. Placeholders allow for temporary text to exist within the field itself:</p>
			<pre>&lt;input type="text" name="num" placeholder="Enter a number" /&gt;</pre>
			<p>This text does not constitute a value of the control, so the submission of the container form will not yield the <code>placeholder</code> value. Likewise, querying the text control's <code>value</code> attribute will not return the <code>placeholder</code> value if it is visible:</p>
			<div><div><img alt="Figure 6.18: Text input control with placeholder attribute&#13;&#10;" src="img/C14377_06_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18: Text input control with placeholder attribute</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor321"/>The Password Control </h2>
			<p>The <code>password</code> control works very similarly to the <code>text</code> field control, but with a couple of differences:</p>
			<pre>&lt;input type="password" name="pass" /&gt;</pre>
			<p>The primary difference with the <code>password</code> control is that any value present in the control is presented to the user as a series of dots, known as a hash, rather than as the value text itself. The purpose of the hash is for the value to be unreadable by the user and, thus, provide a level of security from unwanted attention. The user is, therefore, expected to already know the value contained within the field. When submitting the form, the value is correctly passed with the form data as clear text:</p>
			<div><div><img alt="Figure 6.19: Password input control&#13;&#10;" src="img/C14377_06_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: Password input control</p>
			<p>Another difference with the <code>password</code> control over the <code>text</code> control is that it is not possible to highlight its content and copy it. Any attempt to copy the content of a <code>password</code> control is ignored. This prevents malicious users from copying and pasting the value of a <code>password</code> control into a text editor, or other such software, thus making the value text clearly readable. However, despite this, it is still possible to reference the control with JavaScript and output its value that way, like so:</p>
			<pre>&lt;input type="password" id="secureValue" value="secret" /&gt;
&lt;script&gt;
var pass = document.getElementById("secureValue");
console.log(pass.value);  // ==&gt; "secret"
&lt;/script&gt;</pre>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor322"/>email, tel, and url Controls</h2>
			<p>The <code>email</code>, <code>tel</code>, and <code>url</code> controls are modern variations of the text field control. They can be created by simply passing email, tel, or url as the type attribute of the input control:</p>
			<pre>&lt;input type="email" /&gt;
&lt;input type="tel" /&gt;
&lt;input type="url" /&gt;</pre>
			<p>By themselves, each of these controls provides no additional functionality over the standard <code>text</code> control. All of the attributes, events, and visual look-and-feel of these controls are identical to the <code>text</code> control and to one another. However, the benefit of these types becomes apparent when they're used with devices that present an on-screen keyboard, such as mobile phones and tablets. By using one of these <code>input</code> types, rather than a <code>text</code> control, the visible keyboard that's presented to input text into them is typically oriented toward the control's content type:</p>
			<div><div><img alt="Figure 6.20: Mobile keyboards for the text, email, tel, and url controls&#13;&#10;" src="img/C14377_06_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20: Mobile keyboards for the text, email, tel, and url controls</p>
			<p>Note that additional work is needed to ensure that the content of the field is appropriate for the field format. This can be accomplished using the <code>pattern</code> attribute and form validation logic.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor323"/>The Hidden Control</h2>
			<p>The <code>hidden</code> control is a very useful field for storing data to be passed to the handler of a form, such as a remote server endpoint, without the user of the web page being aware of its existence. As its name implies, the <code>hidden</code> field is hidden from the user and has no visible presence:</p>
			<pre>&lt;input type="hidden" /&gt;</pre>
			<p>Many of the attributes provided by the input tag are irrelevant when using the <code>hidden</code> control since it is not a control that a user will interact with. However, its <code>value</code>, <code>id</code>, and <code>name</code> attributes will prove useful and can be used and manipulated in the same way as the <code>text</code> control.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor324"/>The Number Control</h2>
			<p>A <code>number</code> field appears similar to a <code>text</code> field but will naturally constrain all text input to numerical values, the addition and subtraction symbols, and the period symbol:</p>
			<pre>&lt;input type="number" /&gt;</pre>
			<p>In some browsers, the number control will also present small up and down arrow buttons, which can be used to increment or decrement the contained value:</p>
			<div><div><img alt="Figure 6.21: Number control&#13;&#10;" src="img/C14377_06_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21: Number control</p>
			<p>The content of a <code>number</code> control can be further constrained by using its <code>min</code>, <code>max</code>, and <code>step</code> attributes. The <code>min</code> and <code>max</code> attributes are self-explanatory and constrain possible numeric entry values to these attributes. For instance, providing a <code>min</code> value of 0 will ensure a negative number cannot be entered, while a <code>max</code> value of 100 will ensure the value never exceeds 100:</p>
			<pre>&lt;input type="number" min="0" max="100" /&gt;</pre>
			<p>Using <code>min</code> and <code>max</code> does not mean a value outside of these constraints cannot be physically entered as input into the control from the keyboard, but merely that the constraints cannot be breached when clicking on the provided arrow buttons or that any provided value outside of these parameters will be accepted when submitting the form:</p>
			<div><div><img alt="Figure 6.22: Number control constraints&#13;&#10;" src="img/C14377_06_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22: Number control constraints</p>
			<p>The step attribute provides a means to increase the rate at which the arrow buttons increase or decrease the value. For instance, if large numbers are allowed within the control, incrementing by 1 with each click may be impractical. Therefore, setting a larger step size would allow the value change to happen with fewer clicks:</p>
			<pre>&lt;input type="number" min="-100000" max="100000" max="100" /&gt;</pre>
			<p>When using step, the change in value when clicking the arrow buttons will change at a rate of the step value from whatever value is currently present within the control. Therefore, setting a step of 5 will not constrain the contained value to multiples of 5.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor325"/>The Image Control</h2>
			<p>The <code>image</code> control works as a hybrid of an <code>img</code> tag and a <code>submit</code> input control. The idea here is that you can use a graphical image as a submit button. You specify the image source using the <code>src</code> attribute, much like we do with the <code>img</code> tag:</p>
			<pre>&lt;input type="image" src="img/img.png" /&gt;</pre>
			<p>An additional benefit to using an <code>image</code> input control is that once it's clicked, the x and y coordinates of the mouse in relation to the image are also sent with the form data as an <code>x</code> and <code>y</code> value. This can prove very useful if, for instance, you wish to register a location on a map as part of form submission, or if you wish to determine the area of the image that the user clicked on:</p>
			<pre>&lt;form method="GET" action="/handler.php"&gt;
  &lt;input type="image" src="img/img.png" /&gt;
&lt;/form&gt;
// will submit to a URL like "/handler.php?x=14&amp;y=27</pre>
			<p>The availability of the <code>image</code> control means forms can be stylized beyond the confines provided by HTML button controls and can be very popular with web designers.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor326"/>The File Control</h2>
			<p>The <code>file</code> control is a requirement when uploading files to a remote server. In fact, it is not actually possible to upload a file dynamically without using the <code>file</code> control in some way. This is due to security as it is unethical to be able to dynamically upload files from a user's machine without their knowledge:</p>
			<pre>&lt;input type="file" name="file" /&gt;</pre>
			<p>The <code>file</code> control is typically presented to the user as a <code>text</code> field and <code>label</code> pair. It is possible to style the control so that one of these items, or both, is not visible to the user. The text that's supplied within the button and label is fixed by the browser and requires some extreme styling to be changed. </p>
			<div><div><img alt="Figure 6.23: File control&#13;&#10;" src="img/C14377_06_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23: File control</p>
			<p>When using the <code>file</code> control to upload files to a server, it is important to set the <code>enctype</code> parameter of the surrounding form to <code>"multipart/form-data"</code>. This value informs the form submission on how to encode the data when sending it to the server. Failure to do this will prevent the file from uploading since files typically require multiple packets to successfully transfer all of the file's data bytes.</p>
			<p>The file control supports an accept attribute value, which enables the filtering of accepted file format types. This attribute can support more than one value, but they must be supplied as MIME types (a predefined string representation of a file's type):</p>
			<pre>&lt;input type="file" name="file" accept="image/png, image/jpeg" /&gt;</pre>
			<p>In the preceding example, only files with a .png, .jpg, or .jpeg extension will be visible when selecting files through the control.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor327"/>The Textarea Control</h2>
			<p>While the <code>text</code> control is great for accepting single lines of text, the <code>textarea</code> control is required for capturing multiline text values:</p>
			<pre>&lt;textarea name="description"&gt;
    Some default text.
&lt;/textarea&gt;</pre>
			<p>As the name implies, the <code>textarea</code> control supports an area of text and is, therefore, a larger control than many of the <code>input</code> controls. Like the <code>button</code> tag, the <code>textarea</code> control consists of both an opening and a closing tag. Any text that's supplied between the tags makes up its text content.</p>
			<p>Although the textarea doesn't utilize a value attribute, its content may still be read and set using the <code>value</code> attribute in JavaScript, like so:</p>
			<pre>var desc = document.getElementsByName("description")[0];
console.log(desc.value) // ==&gt; outputs "Some default text"
desc.value = "Some other text"; // ==&gt; updates the value of the textarea to "Some other text"</pre>
			<div><div><img alt="Figure 6.24: Textarea control&#13;&#10;" src="img/C14377_06_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24: Textarea control</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor328"/>The Select Control</h2>
			<p>The <code>select</code> control provides the functionality of a drop-down list control. Like <code>textarea</code>, the <code>select</code> control utilizes an opening and closing tag, both of which form the body of the control. However, the items within the control are provided as an additional tag, called <code>option</code>:</p>
			<pre>&lt;select name="colors"&gt;
  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;
  &lt;option value="red"&gt;Red&lt;/option&gt;
  &lt;option value="blue"&gt;Blue&lt;/option&gt;
  &lt;option value="green"&gt;Green&lt;/option&gt;
&lt;/select&gt;</pre>
			<p>The <code>option</code> elements of a <code>select</code> control typically contain two values: the <code>value</code> attribute and the <code>text</code> body. These are known simply as the <code>value</code> and <code>text</code>. The text contained between the opening and closing <code>option</code> tags is the string that's visible to the user within the control, while the <code>value</code> attribute is the string to be sent when the form is submitted if that particular <code>option</code> element is selected. When adding <code>option</code> elements, the <code>value</code> attribute may be omitted, but this will mean the <code>text</code> value will be sent with the form data instead.</p>
			<p>Similar to checkboxes and radio buttons, an option value may be preselected by passing the selected attribute to one of the option values:</p>
			<pre>&lt;select name="colors"&gt;
  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;
  &lt;option value="red" selected&gt;Red&lt;/option&gt;
  &lt;option value="blue"&gt;Blue&lt;/option&gt;
  &lt;option value="green"&gt;Green&lt;/option&gt;
&lt;/select&gt;</pre>
			<p>The select control can be displayed in two formats. The standard format is as a dropdown (or combo) list control:</p>
			<div><div><img alt="Figure 6.25: Select control&#13;&#10;" src="img/C14377_06_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25: Select control</p>
			<p>The secondary format is displayed if the control needs to support multiple simultaneously selected options. As such, the control is displayed as a permanently open list control, with scrollable options. The <code>select</code> control can support multiple selected options by supplying the <code>multiple</code> attribute:</p>
			<pre>&lt;select name="colors" multiple&gt;
  &lt;option value=""&gt;--Please choose an option--&lt;/option&gt;
  &lt;option value="red"&gt;Red&lt;/option&gt;
  &lt;option value="blue"&gt;Blue&lt;/option&gt;
  &lt;option value="green"&gt;Green&lt;/option&gt;
&lt;/select&gt;</pre>
			<p>When displayed, the user must press and hold the Ctrl key on the keyboard while selecting items. If the Ctrl key is not pressed, then selecting an item will deselect any previously selected items:</p>
			<div><div><img alt="Figure 6.26: Select control with multiple attributes&#13;&#10;" src="img/C14377_06_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: Select control with multiple attributes</p>
			<p>When working with a dropdown <code>select</code> control, it is possible to get the value of the selected <code>option</code> by simply querying the <code>select</code> control's <code>value</code> property:</p>
			<pre>var select = document.getElementsByName("colors")[0];
console.log(select.value); // ==&gt; outputs selected color</pre>
			<p>It is also possible to output the index of the selected item by querying the <code>selectedIndex</code> property. Index values start at 0 (zero) for the first element:</p>
			<pre>var select = document.getElementsByName("colors")[0];
console.log(select.selectedIndex); // ==&gt; outputs numerical index of selected option</pre>
			<p>However, when querying a multi-select list, things aren't so easy. If multiple items are selected, querying the <code>value</code> property would simply return the first selected item in the list, thus ignoring all the other selected items. Instead, developers need to make use of the <code>options</code> property of the <code>select</code> control and the <code>option</code> item's <code>selected</code> property to discern which items are selected.</p>
			<p>The <code>select</code> control's <code>options</code> property returns all the <code>option</code> elements contained within it, regardless of their selected state. The <code>option</code> item's <code>selected</code> property is simply the condition of its selected status; it's true if it is selected and false if it is not. Thus, by combining these two values, the selected <code>option</code> elements can be discerned with a simple loop, like so:</p>
			<pre>var selectedItems = [];
var select = document.getElementsByName("colors")[0];
for (let opt of select.options) {
  if (opt.selected) {
    selectedItems.push(opt.value);
  }
}
console.log(selectedItems); // ==&gt; outputs array of selected values</pre>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor329"/>Activity 6.01: Making Changes to the Model</h2>
			<p>A lot has been covered in this chapter, but you should now have the knowledge that's required to make something visual. In this activity, your role will be to create a simple form that requests the title and description for a new <code>To-Do</code> entry which, when submitted, feeds the data to the action handler we created in the previous chapter.</p>
			<p>Once your form is in place and its data is being handled, the model functions must be updated to receive this data. Create an event handler that's able to receive <code>CREATE</code> action events and pass them appropriately to the model.</p>
			<p>Since there is no visual cue that data has been successfully stored within the model, any updates to the model should result in a notification event being dispatched. This way, other areas of your application can respond accordingly as data changes. Your project manager has requested that a custom event be dispatched from the model, called <code>CHANGED</code>. This will notify any interested party that data has either been added, updated, or removed from the model.</p>
			<p>To verify that the <code>CHANGED</code> event works, create a message banner at the top of the page that briefly displays the message "<code>The To-Do model has been updated</code>". This message should be present for three seconds, before being removed.</p>
			<p>Your project manager has asked that this information is dispatched as a custom event, to be caught by the action handler. This event should match the action types already recognized by the model. Therefore, be sure to send the object as a <code>CREATE</code> event.</p>
			<p>Save the following HTML in a file called <code>index.html</code>:</p>
			<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Create TODO&lt;/title&gt;
    &lt;script src="img/model.js"&gt;&lt;/script&gt;
    &lt;script src="img/create_todo.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="loadHandler();"&gt;
    &lt;div id="notifications"&gt;&lt;/div&gt;
    &lt;form id="todo_form" /&gt;
      &lt;label&gt;Title:
        &lt;input type="text" id="title" /&gt;
      &lt;/label&gt;
      &lt;label&gt;Description:
        &lt;textarea id="description"&gt;&lt;/textarea&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Create TODO" /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>This HTML should include the model from the previous chapter, but also a new JavaScript file that will contain the logic for this activity.</p>
			<p>The following is the expected output for this activity:</p>
			<div><div><img alt="Figure 6.27: TODO submission form&#13;&#10;" src="img/C14377_06_27.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: TODO submission form</p>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add a custom event handler to the model. This handler should receive the <code>CREATE</code> state change and update the model with the new <code>TODO</code> details from the event body.</li>
				<li>Add a <code>loadHandler</code> function to the <code>create_todo.js</code> file. This handler should listen for the submit button's <code>click</code> event, but also the custom <code>CHANGED</code> event from the model.</li>
				<li>Add a handler function in <code>create_todo.js</code> to handle the <code>CHANGED</code> event itself. This handler should temporarily display a <code>The TODO model has been updated</code> message within the <code>notifications</code> tag.</li>
				<li>Add the <code>TODO</code> to the <code>create_todo.js</code> file. This will be executed when the <code>submit</code> button click event is raised. This handler should parse the values of the form controls and dispatch them in a new <code>CREATE</code> custom event if they are valid. If any of the data is not valid, then sufficient error messages should be temporarily displayed in the <code>notifications</code> tag.</li>
				<li>Add a <code>CHANGED</code> event dispatch when the model is updated. The event body should contain a type added and a value containing the details of the new <code>TODO</code>.</li>
			</ol>
			<p>If you run the HTML page, you will expect to see messages to be written to the screen when you submit the form. Remember that the model will receive and send events. It will not be contacted directly. The handler functions will ensure that the events are attached correctly and that the data has been correctly parsed so that it can be sent to the model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 728.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor330"/>Summary</h1>
			<p>This has been the first chapter to have utilized an HTML page using JavaScript in this book, as well as the first to explain the abstract nature of the event messaging system. Understanding these concepts is very valuable when building a useful web application in JavaScript.</p>
			<p>Throughout this chapter, you have explored the various nuances of event message bubbling and capturing, along with how they can be used to control the flow of information within an application. You have also seen how to halt these events in their tracks and how to create your own custom events.</p>
			<p>By adopting the tools and skills you've learned about in this chapter, you will have a foundational arsenal at your disposal so that you can tackle applications of any size or complexity. These skills will be honed throughout the rest of this book while broadening your perspective as to what is possible with this powerful language.</p>
			<p>In the next chapter, you will dive deeper into the JavaScript event loop and gain a greater understanding of the underlying technology.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>