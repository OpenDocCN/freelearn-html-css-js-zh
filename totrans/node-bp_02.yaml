- en: Chapter 2. Developing a Basic Site with Node.js and Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about common programming paradigms and how
    they apply to Node.js. In this chapter, we will continue with the **Express**
    framework. It's one of the most popular frameworks available and is certainly
    a pioneering one. Express is still widely used and several developers use it as
    a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting acquainted with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express ([http://expressjs.com/](http://expressjs.com/)) is a web application
    framework for Node.js. It is built on top of Connect ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)),
    which means that it implements middleware architecture. In the previous chapter,
    when exploring Node.js, we discovered the benefit of such a design decision: the
    framework acts as a plugin system. Thus, we can say that Express is suitable for
    not only simple but also complex applications because of its architecture. We
    may use only some of the popular types of middleware or add a lot of features
    and still keep the application modular.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, most projects in Node.js perform two functions: run a server that
    listens on a specific port, and process incoming requests. Express is a wrapper
    for these two functionalities. The following is basic code that runs the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example extracted from the official documentation of Node.js. As
    shown, we use the native module `http` and run a server on the port `1337`. There
    is also a request handler function, which simply sends the `Hello world` string
    to the browser. Now, let''s implement the same thing but with the Express framework,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s pretty much the same thing. However, we don''t need to specify the response
    headers or add a new line at the end of the string because the framework does
    it for us. In addition, we have a bunch of middleware available, which will help
    us process the requests easily. Express is like a toolbox. We have a lot of tools
    to do the boring stuff, allowing us to focus on the application''s logic and content.
    That''s what Express is built for: saving time for the developer by providing
    ready-to-use functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to install Express. We'll will start with the simple one
    and then proceed to the more advanced technique. The simpler approach generates
    a template, which we may use to start writing the business logic directly. In
    some cases, this can save us time. From another viewpoint, if we are developing
    a custom application, we need to use custom settings. We can also use the boilerplate,
    which we get with the advanced technique; however, it may not work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Using package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express is like every other module. It has its own place in the packages register.
    If we want to use it, we need to add the framework in the `package.json` file.
    The ecosystem of Node.js is built on top of the Node Package Manager. It uses
    the JSON file to find out what we need and installs it in the current directory.
    So, the content of our `package.json` file looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These are the required fields that we have to add. To be more accurate, we have
    to say that the mandatory fields are `name` and `version`. However, it is always
    good to add descriptions to our modules, particularly if we want to publish our
    work in the registry, where such information is extremely important. Otherwise,
    the other developers will not know what our library is doing. Of course, there
    are a bunch of other fields, such as contributors, keywords, or development dependencies,
    but we will stick to limited options so that we can focus on Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our `package.json` file placed in the project''s folder, we have
    to call `npm install` in the console. By doing so, the package manager will create
    a `node_modules` folder and will store Express and its dependencies there. At
    the end of the command''s execution, we will see something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using package.json](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line shows us the installed version, and the proceeding lines are
    actually modules that Express depends on. Now, we are ready to use Express. If
    we type `require(''express'')`, Node.js will start looking for that library inside
    the local `node_modules` directory. Since we are not using absolute paths, this
    is normal behavior. If we miss running the `npm install` command, we will be prompted
    with `Error: Cannot find module ''express''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a command-line tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a command-line instrument called `express-generator`. Once we run `npm
    install -g express-generator`, we will install and use it as every other command
    in our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the framework in several projects, you will notice that some things
    are repeated. We can even copy and paste them from one application to another,
    and this is perfectly fine. We may even end up with our own boilerplate and can
    always start from there. The command-line version of Express does the same thing.
    It accepts few arguments and based on them, creates a skeleton for use. This can
    be very handy in some cases and will definitely save some time. Let''s have a
    look at the available arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-h, --help`: This signifies output usage information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-V, --version`: This shows the version of Express.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e, --ejs`: This argument adds the EJS template engine support. Normally,
    we need a library to deal with our templates. Writing pure HTML is not very practical.
    The default engine is set to JADE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H, --hogan`: This argument is Hogan-enabled (another template engine).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c, --css`: If we want to use the CSS preprocessors, this option lets us use
    **LESS** (short for **Leaner CSS**) or Stylus. The default is plain CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f, --force`: This forces Express to operate on a nonempty directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to generate an Express application skeleton with LESS as a CSS preprocessor.
    We use the following line of command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `myapp` folder is created with the file structure, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a command-line tool](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We still need to install the dependencies, so `cd myapp && npm install` is
    required. We will skip the explanation of the generated directories for now and
    will move to the created `app.js` file. It starts with initializing the module
    dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our framework is `express`, and `path` is a native Node.js module. The middleware
    are `favicon`, `logger`, `cookieParser`, and `bodyParser`. The `routes` and `users`
    are custom-made modules, placed in local for the project folders. Similarly, as
    in the **Model-View-Controller** (**MVC**) pattern, these are the controllers
    for our application. Immediately after, an `app` variable is created; this represents
    the Express library. We use this variable to configure our application. The script
    continues by setting some key-value pairs. The next code snippet defines the path
    to our views and the default template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The framework uses the methods `set` and `get` to define the internal properties.
    In fact, we may use these methods to define our own variables. If the value is
    a Boolean, we can replace `set` and `get` with `enable` and `disable`. For example,
    see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code adds middleware to the framework. We can see the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first middleware serves as the favicon of our application. The second is
    responsible for the output in the console. If we remove it, we will not get information
    about the incoming requests to our server. The following is a simple output produced
    by `logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json` and `urlencoded` middleware are related to the data sent along with
    the request. We need them because they convert the information in an easy-to-use
    format. There is also a middleware for the cookies. It populates the request object,
    so we later have access to the required data. The generated app uses LESS as a
    CSS preprocessor, and we need to configure it by setting the directory containing
    the `.less` files. We will talk about LESS in [Chapter 10](part0074_split_000.html#page
    "Chapter 10. Writing Flexible and Modular CSS"), *Writing Flexible and Modular
    CSS*, where will cover this in detail. Eventually, we define our static resources,
    which should be delivered by the server. These are just few lines, but we''ve
    configured the whole application. We may remove or replace some of the modules,
    and the others will continue working. The next code in the file maps two defined
    routes to two different handlers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user tries to open a missing page, Express still processes the request
    by forwarding it to the error handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The framework suggests two types of error handling: one for the development
    environment and another for the production server. The difference is that the
    second one hides the stack trace of the error, which should be visible only for
    the developers of the application. As we can see in the following code, we are
    checking the value of the `env` property and handling the error differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, the `app.js` file exports the created Express instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To run the application, we need to execute `node ./bin/www`. The code requires
    `app.js` and starts the server, which by default listens on port `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `process.env` declaration provides an access to variables defined in the
    current development environment. If there is no `PORT` setting, Express uses 3000
    as the value. The required `debug` module uses a similar approach to find out
    whether it has to show messages to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Managing routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The input of our application is the routes. The user visits our page at a specific
    URL and we have to map this URL to a specific logic. In the context of Express,
    this can be done easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We even have control over the HTTP''s method, that is, we are able to catch
    POST, PUT, or DELETE requests. This is very handy if we want to retain the address
    path but apply a different logic. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something interesting about the routing in Express. We may pass not
    just one but many handlers. This means that we can create a chain of functions
    that correspond to one URL. For example, it we need to know if the user is logged
    in, there is a module for that. We can add another method that validates the current
    user and attaches a variable to the request object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Validator` class is a class that checks the current user''s session. The
    idea is simple: we add another handler, which acts as an additional middleware.
    After performing the necessary actions, we call the `next` function, which passes
    the flow to the next handler, `getUser`. Because the request and response objects
    are the same for all the middlewares, we have access to the `userLogged` variable.
    This is what makes Express really flexible. There are a lot of great features
    available, but they are optional. At the end of this chapter, we will make a simple
    website that implements the same logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling dynamic URLs and the HTML forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Express framework also supports dynamic URLs. Let''s say we have a separate
    page for every user in our system. The address to those pages looks like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `45` is the unique number of the user in our database. It''s of course
    normal to use one route handler for this functionality. We can''t really define
    different functions for every user. The problem can be solved by using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The route is actually like a regular expression with variables inside. Later,
    that variable is accessible in the `req.params` object. We can have more than
    one variable. Here is a slightly more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open `http://localhost:3000/user/451/profile/edit`, we see `User (451):
    edit` as a response. This is how we can get a nice looking, SEO-friendly URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, sometimes we need to pass data via the GET or POST parameters. We
    may have a request like `http://localhost:3000/user?action=edit`. To parse it
    easily, we need to use the native `url` module, which has few helper functions
    to parse URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the module parses the given URL, our GET parameters are stored in the
    `.query` object. The POST variables are a bit different. We need a new middleware
    to handle that. Thankfully, Express has one, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `express.bodyParser()` middleware populates the `req.body` object with the
    POST data. Of course, we have to change the HTTP method from `.get` to `.post`
    or `.all`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to read cookies in Express, we may use the `cookieParser` middleware.
    Similar to the body parser, it should also be installed and added to the `package.json`
    file. The following example sets the middleware and demonstrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Returning a response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our server accepts requests, does some stuff, and finally, sends the response
    to the client''s browser. This can be HTML, JSON, XML, or binary data, among others.
    As we know, by default, every middleware in Express accepts two objects, `request`
    and `response`. The `response` object has methods that we can use to send an answer
    to the client. Every response should have a proper content type or length. Express
    simplifies the process by providing functions to set HTTP headers and sending
    content to the browser. In most cases, we will use the `.send` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pass a string, the framework sets the `Content-Type` header to `text/html`.
    It''s great to know that if we pass an object or array, the content type is `application/json`.
    If we develop an API, the response status code is probably going to be important
    for us. With Express, we are able to set it like in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s even possible to respond with a file from our hard disk. If we don''t
    use the framework, we will need to read the file, set the correct HTTP headers,
    and send the content. However, Express offers the `.sendfile` method, which wraps
    all these operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Again, the content type is set automatically; this time it is based on the filename's
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building websites or applications with a user interface, we normally need
    to serve an HTML. Sure, we can write it manually in JavaScript, but it''s good
    practice to use a template engine. This means we save everything in external files
    and the engine reads the markup from there. It populates them with some data and,
    at the end, provides ready-to-show content. In Express, the whole process is summarized
    in one method, `.render`. However, to work properly, we have to instruct the framework
    regarding which template engine to use. We already talked about this in the beginning
    of this chapter. The following two lines of code, set the path to our views and
    the template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we have the following template (`/views/index.jade`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Express provides a method to serve templates. It accepts the path to the template,
    the data to be applied, and a callback. To render the previous template, we should
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML produced looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we pass a third parameter, `function`, we will have access to the generated
    HTML. However, it will not be sent as a response to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The example-logging system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen the main features of Express. Now let''s build something real.
    The next few pages present a simple website where users can read only if they
    are logged in. Let''s start and set up the application. We are going to use Express''
    command-line instrument. It should be installed using `npm install -g express-generator`.
    We create a new folder for the example, navigate to it via the terminal, and execute
    `express --css less site`. A new directory, `site`, will be created. If we go
    there and run `npm install`, Express will download all the required dependencies.
    As we saw earlier, by default, we have two routes and two controllers. To simplify
    the example, we will use only the first one: `app.use(''/'', routes)`. Let''s
    change the `views/index.jade` file content to the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run `node ./bin/www` and open `http://127.0.0.1:3000`, we will see
    the page. Jade uses indentation to parse our template. So, we should not mix tabs
    and spaces. Otherwise, we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to protect our content. We check whether the current user has
    a session created; if not, a login form is shown. It's the perfect time to create
    a new middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use sessions in Express, install an additional module: `express-session`.
    We need to open our `package.json` file and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do that, a quick run of `npm install` will bring the module to our
    application. All we have to do is use it. The following code goes to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we changed the original `app.use(''/'', routes)` line. The `session`
    middleware is initialized and added to Express. The `verifyUser` function is called
    before the page rendering. It uses the `req.session` object, and checks whether
    there is a `loggedIn` variable defined and if its value is `true`. If we run the
    script again, we will see that the `show login form` textis shown for every request.
    It''s like this because no code sets the session exactly the way we want it. We
    need a form where users can type their username and password. We will process
    the result of the form and if the credentials are correct, the `loggedIn` variable
    will be set to `true`. Let''s create a new `Jade` template, `/views/login.jade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of sending just a text with `res.send("show login form");` we should
    render the new template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We choose POST as the method for the form. So, we need to add the middleware
    that populates the `req.body` object with the user''s data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Process the submitted username and password as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The valid credentials are set to `admin/admin`. In a real application, we may
    need to access a database or get this information from another place. It's not
    really a good idea to place the username and password in the code; however, for
    our little experiment, it is fine. The previous code checks whether the passed
    data matches our predefined values. If everything is correct, it sets the session,
    after which the user is forwarded to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you log in, you should be able to log out. Let''s add a link for that
    just after the content on the index page (`views/index.jade`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once users clicks on this link, they will be forward to a new page. We just
    need to create a handler for the new route, remove the session, and forward them
    to the index page where the login form is reflected. Here is what our logging
    out handler looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Setting `loggedIn` to `false` is enough to make the session invalid. The redirect
    sends users to the same content page they came from. However, this time, the content
    is hidden and the login form pops up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about one of most widely used Node.js frameworks,
    Express. We discussed its fundamentals, how to set it up, and its main characteristics.
    The middleware architecture, which we mentioned in the previous chapter, is the
    base of the library and gives us the power to write complex but, at the same time,
    flexible applications. The example we used was a simple one. We required a valid
    session to provide page access. However, it illustrates the usage of the body
    parser middleware and the process of registering the new routes. We also updated
    the `Jade` templates and saw the results in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show us how Node.js collaborated with AngularJS, a popular
    framework made by Google for client-side JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
