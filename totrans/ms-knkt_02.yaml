- en: Chapter 2. Extending Knockout with Custom Binding Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knockout''s standard bindings are great. They solve most of the general problems
    you are likely to encounter when developing web apps. But there is always the
    need to provide something special, whether you are working on your own library
    or just trying to add a bit of style to your app. When that happens, you will
    want to provide that functionality through the same binding system you are using
    everywhere else. Luckily, Knockout makes extending this system easy. In this chapter,
    we will be looking at how to make our own binding handlers. We will be covering
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a binding handler contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new binding handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom binding handlers to integrate with third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing binding contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the containerless control flow syntax with custom bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom binding handlers for new and more complex HTML interactions
    is a key to developing feature-rich applications. While the basics are easy to
    learn, there are enough extension points to support just about any use case. We
    are going to be looking at plenty of examples to get a solid idea of what binding
    handlers are capable of and how we can make the best use of them.
  prefs: []
  type: TYPE_NORMAL
- en: The data binding pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is primarily philosophical. If you feel like you already have a
    solid understanding of the *what* and *why* behind the **Model-View-ViewModel**
    (**MVVM**) pattern and binding handlers, then you might want to skip to the next
    section, *Components of a binding handler*.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's talk about patterns and practices. If you haven't worked with WPF
    before, then the MVVM pattern is probably the most confusing thing about Knockout.
    MVVM is a pattern that came out of Microsoft. It doesn't get a lot of attention
    outside the .NET community, and it's similar enough to the far more popular MVC
    pattern because of which confusion is nearly guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MVVM, the viewmodel is supposed to represent an abstraction of the view.
    Consider these two lists of message threads in iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The data binding pattern](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: They both show a list of threads, and each thread contains a title showing the
    person it is with, an excerpt from the most recent message, and a timestamp. A
    thread can be selected or deleted. To select a message, you can touch it. To delete
    a message, you can slide left to bring up the **Delete** button, and then press
    the **Delete** button to delete the thread. You might be able to spot a difference
    in behavior already though. The list on the left slides the entire thread left
    to reveal the **Delete** button, pushing the thread partially off the screen.
    The list on the right superimposes the button on top of the thread, hiding the
    timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: These differences are entirely part of the presentation of the data. Both of
    these views could, and should, be supported by the same viewmodel. They are both
    showing the same data and allow the same actions.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to consume this data using the intended behavior (slide-reveal or
    slide-superimpose), the view needs support from something besides the viewmodel.
    In the MVVM pattern, this is the domain of the binding handler, and even though
    the binding handler doesn't get a letter in the acronym, it's still a critical
    piece of the puzzle. As the viewmodel is not supposed to know about view-related
    concepts such as buttons, clicks, or finger-taps, and the view is supposed to
    be entirely declarative; a binding handler is required to glue the two together.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle here is the separation of concerns. The view is concerned
    with UI elements and interactions. The viewmodel is concerned with code objects
    and actions, and binding handlers are concerned with generically translating between
    specific UI elements or actions to and from the viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: As that's out of the way, time to get started with creating some custom binding
    handlers!
  prefs: []
  type: TYPE_NORMAL
- en: Components of a binding handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding handlers are defined by adding objects to the `ko.bindingHandlers` object,
    just like extenders. They are composed of an `init` and an `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function runs when the binding is first applied to the element either
    when `ko.applyBindings` is called or when the element is created by a control
    flow binding, such as `template` or `foreach`. It should be used for all one-time
    work such as attaching event handlers or disposal callbacks to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` function runs just after `init` does, when the binding is first
    applied. It runs again anytime when any observable dependencies are changed. The
    `update` function determines its dependencies just like a computed observable
    does. If an observable is accessed when an update runs, it subscribes to that
    observable. The `update` function should be used to keep the UI in sync with changes
    from the viewmodel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions receive the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Element`: This is the DOM element the binding was applied to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueAccessor`: This is a function that will return the result of the binding
    expression. For example, if the binding was `value: name`, then `valueAccessor`
    would return the `name` property. If `name` was an observable, you would still
    need to either call it or pass it to `ko.unwrap` (this function will be covered
    in the next section) to get the value. If the binding was `value: name() + ''!''`,
    then `valueAccessor` would return the resulting string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allBindings`: This is an object with a `get` and `has` function for accessing
    other bindings on the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Viewmodel`: In previous versions of Knockout, this gave access to the viewmodel,
    but it has been deprecated in favor of `bindingContext.$data` or `bindingContext.$rawData`
    as of Knockout 3.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindingContext`: This is an object with the current binding context for the
    binding. This has the special binding context properties such as `$parent` and
    `$root`. This parameter was introduced in Knockout 3.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom binding handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once added to the `ko.bindingHandler` object, custom bindings are no different
    from normal bindings. If you add a binding handler named `flash`, you could use
    it on an HTML element with a standard `data-bind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Simple binding handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding handlers can range from very simple to whole applications by themselves.
    As the purpose of binding handlers is to translate between the presentation layer
    (HTML) and the viewmodel (JavaScript), the binding handler's complexity is directly
    related to the complexity of the UI interaction and the bound data. Simple tasks
    such as hiding or showing an element with animation will have very thin handlers,
    while data binding on an interactive map element will require much more logic.
  prefs: []
  type: TYPE_NORMAL
- en: Animated binding handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As DOM interaction in the primary use case for jQuery, and given its popularity,
    it is not uncommon to use jQuery inside Knockout binding handlers. The canonical
    custom binding handler example from the Knockout documentation is a binding to
    hide and show elements, with the jQuery''s `slideUp` and `slideDown` methods,
    instead of using the standard `visible` binding to switch them on and off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example uses both an `init` and `update` function. The `init` function
    here is necessary to ensure that a value starting out as false doesn't cause the
    element to slide up when bindings are first applied, or vice versa. Without it,
    the `update` function would run right away and try to hide the element by sliding
    it up. The `init` function ensures that the element is already in the correct
    visible state, so that an animation doesn't occur when the binding first runs.
  prefs: []
  type: TYPE_NORMAL
- en: '`ko.unwrap` is a utility method that will return the value of an observable
    if called with one; otherwise it will just return the first argument directly.
    It''s perfect if you don''t know whether you have an observable or not as it''s
    safe to call it with anything. Most custom bindings should be able to support
    observable and nonobservable values, so you should always unwrap the `valueAccessor`
    parameter, unless you have a good reason not to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The check for `allBindings.get(''slideDuration'')` allows a configurable value
    to be used for the slide timing. The `allBinding` object gives us access to other
    bindings that were used on the same element and is commonly used to collect optional
    configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets the view determine how fast or slow to hide and show the element.
    As the animation speed is a part of the presentation, it makes sense for it to
    be configured from the view. If you want to use a viewmodel observable for `slideDuration`,
    you can modify that line to unwrap the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An example of this binding is in the `cp2-slide` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Working with third-party controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slideVisible` binding is a perfectly simple binding; it has a basic `init`
    function to start the binding and has an `update` function that modifies the DOM
    when the viewmodel changes. It is a **one way binding** though, only watching
    the viewmodel for changes. **Two way bindings** also need to watch the DOM element
    for changes and send it back to the viewmodel. Generally, this is accomplished
    by attaching an event handler in the `init` function; remember that the `update`
    function runs every time dependencies change, so attaching an event handler there
    would result in the event handler being attached multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding handlers can also be used to integrate with third-party controls. Though
    HTML5 has a native `datepicker` control, you might need one that is more backwards-compatible.
    The `datepicker` control of jQuery is a nice out-of-the-box control, but it requires
    a call to `$(element). datepicker()` to convert a standard input element. A binding
    handler is the perfect place to run this initialization logic for the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this binding in HTML, apply it to an input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example comes from a Stack Overflow answer by R. P. Niemeyer that can be
    found at [http://stackoverflow.com/a/6400701/788260](http://stackoverflow.com/a/6400701/788260).
  prefs: []
  type: TYPE_NORMAL
- en: This binding's `init` function starts out by storing the jQuery wrapped element,
    followed by a check for options. The UI datepicker for jQuery ([http://jqueryui.com/datepicker](http://jqueryui.com/datepicker))
    has a lot of them, and letting the binding control the configuration is standard.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the jQuery-ficiation of the element with `$el.datepicker(options)`.
    This attaches the event handlers that allow jQuery to hide and show the pop-up
    datepicker control and route its selection to the input element's `value`. Then,
    using Knockout's `ko.utils.registerEventHandler`, it attaches an event handler
    that takes the new `value` and writes it to the supplied observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we might want to see whether the `valueAccessor` parameter is
    an observable, so that binding against a static value can still be used to set
    the element''s initial value. You will want to use your best judgment here; in
    this case, the whole purpose of the binding is to collect user input, so it doesn''t
    make sense in this case to work with nonobservable values. If you do want to make
    the check, you could change the event handler portion in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ko.isObservable` function is a utility method that returns `true` if the
    first argument is an `observable`, `observableArray`, or `computed` observable.
    When the `valueAccessor` parameter isn't an observable, there is no need to attach
    the change handler at all, because there is nothing we would do with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece in the `init` function is a **disposal handler**. Disposal of
    bindings occurs when the element is removed from the DOM, which happens when control
    flow bindings such as `template` or `foreach` update themselves. The `datepicker`
    control of jQuery expects `$el.datepicker("destroy")` to be called to clean up
    the event handlers if attached, and remove the pop-up element from the DOM. Remember,
    the pop-up element was added by jQuery from inside this binding handler, so Knockout's
    template system is not aware of them. The `ko.utils.domNodeDisposal.addDisposeCallback`
    registers handlers that will be called by the template system when it removes
    a node from the DOM. This is an important step anytime your binding handler has
    modified the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function handles observable changes, but as it is translating between
    strings for the element's value and JavaScript `Dates` for the code, it has to
    perform its own equality check. Instead of looking at the element's value, it
    uses `$el.datepicker("getDate")`, which returns a real JavaScript date.
  prefs: []
  type: TYPE_NORMAL
- en: To see this binding in action, you can check out the `cp2-datepicker` branch.
    I've added a `span` bound by the same viewmodel property as the datepicker so
    that you can easily see the value update.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the DOM with bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous two bindings were mostly translators between the data and presentation
    logic, but binding handlers can do much more. Bindings can also be used to add
    new elements to the page. If you want to provide a UI for a 1-5 rating system,
    you should think about using a `select` element with an `options` and `value`
    binding. While this would work, a much more common way would be to provide a series
    of stars for the user to click on, with a click activating the clicked star and
    every previous star. The Knockout tutorial site ([http://learn.knockoutjs.com/#/?tutorial=custombindings](http://learn.knockoutjs.com/#/?tutorial=custombindings))
    provides a neat solution to this, which replaces a node''s content with a list
    of styled `span` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use this binding on an element in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a nice looking control that will be familiar to anyone who has
    filled out an online survey before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the DOM with bindings](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `init` function for this binding sets up three things. First, it adds five
    span elements as children of the bound node, which will serve as the stars for
    the rating. Second, it adds hover handlers to apply and remove the `hoverChosen`
    class to the star under the cursor, as well as all the previous stars. The stars
    are cumulative, so if we hover over the third star, we should see the first three
    stars fill in. Finally, it adds a click handler to each star that updates the
    `bound` property with the number the star represents. As its using the index of
    the loop, which starts at `0`, it adds `1` to the value. Again, we see that the
    binding assumes that the property being used is observable. If we wanted to support
    a read-only display, we would modify the binding to check that the property is
    observable before trying to update it.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function for this binding is different from the ones we've looked
    at so far. Instead of using the new value from the `valueAccesor` property to
    set an attribute of the original bound element, it loops through the stars and
    uses jQuery's `toggleClass` to set or remove the chosen class, applying it to
    only the stars whose index is at or below the new value. The viewmodel is still
    only aware of an integer value, and the view is only aware that the bound element
    is using `starRating` to present that number. The binding handler abstracts away
    star elements and also handles the translation between the numeric value and selected
    stars.
  prefs: []
  type: TYPE_NORMAL
- en: This binding assumes the existence of the CSS classes that it applies to the
    star spans. You can see an interactive sample of this binding and the CSS in the
    `cp2-stars` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Applying new bindings to new children elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we looked at creating children elements to present
    our data with some style. It was using jQuery to manage the classes of the children
    elements that it had added during the binding's initialization. However, when
    using Knockout bindings, sometimes it makes more sense to use the built-in binding
    handlers for this sort of thing. Luckily it's possible to add Knockout bindings
    to elements after they've been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knockout provides a utility function, `ko.applyBindingsToNode`, to manually
    apply bindings to elements. The function takes an element to bind an object. Each
    property on the object will be used to look up a binding handler, and the property''s
    value will be passed to the binding. It also takes an optional viewmodel or binding
    context as the third parameter; if left out, it will use the current binding context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will add a new input element after the original element and apply a `value`
    binding to the original observable. The `applyBindingsToNode` call takes the new
    input element and an object that will apply the `value` binding. The `valueAccessor`
    property returns the original property and passes it to the binding, essentially
    binding the new input to the same property as the original binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a binding that adds an input with a new label, it might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Its binding could be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This binding creates a new label and input that it appends as children to the
    original binding. The label's text is set to the binding's `label` property, and
    the binding's `value` is bound to the input node. Hopefully, you can start to
    see how a binding handler could be used to create not only your own behavior,
    but your own custom elements as well.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this binding can be seen in the `cp2-applynode` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Applying accessors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `applyBindingsToNode` method is available in all versions of Knockout,
    but another method is available if you are using Knockout 3.0 or higher. The `applyBindingAccessorsToNode`
    method works in a way similar to `applyBindingsToNode`, taking an object to bind
    as the first parameter and an optional binding context as the third parameter.
    However, instead of taking the values of the second parameter''s properties directly,
    it takes a function that supplies the `valueAccessor` property. The previous `apply`
    call would look like this after being converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method is actually what `applyBindingsToNode` calls internally after the
    values given to it are converted into value accessor functions such as the previous
    ones. The one fewer step of indirection gained by using `applyBindingAccessorsToNode`
    gives marginally improved performance. However, the larger benefit comes when
    the value being bound against it is an expression instead of just a simple property.
    An expression can only establish a dependency if it is evaluated from inside the
    binding that uses it. The value accessor functions will be evaluated later, allowing
    them to work correctly with expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the order of binding handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In rare cases, you may need to ensure that the binding handlers occur in a
    certain order. As of Knockout 3.0, this is possible by setting the `after` property
    on a binding handler to an array of bindings that must be processed first. For
    example, you can define a binding that require values and options to be processed
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Several of the default bindings take advantage of this. The `value` binding
    depends on `options` and `foreach`; the `checked` binding depends on `value` and
    `attr`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that if you create two bindings with an `after` reference
    to each other, Knockout will throw a cyclic dependency exception if it ever tries
    to apply both bindings to the same element.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced binding handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been looking at binding handlers that handle one or two properties
    and result in a fairly simple single-purpose control. In the previous example,
    we started looking at binding handlers that created new child elements, and this
    technique allows us to create much more complex binding behaviors. Bindings can
    also interact with complex elements such as charts or map controls (for example,
    a Google Maps widget), providing a clean API that the viewmodel can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Binding complex data with charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first time we looked at integrating with a third-party control was with
    a single-property two-way binding to a datepicker. Any time we are working with
    third-party UI tools, the goal is to abstract them away from the view and the
    viewmodel through bindings; even when those tools are for complex structures such
    as charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Charts.js ([http://www.chartjs.org](http://www.chartjs.org)) is a popular JavaScript
    library built to display data in, you guessed it right, graphical charts. Without
    going too deep into the details of how charts work, one challenge presented by
    a binding handler is that the chart doesn''t have an API for making incremental
    updates. The whole chart needs to be re-rendered for updates. This requires access
    to the `canvas` element as well as the 2D context for the canvas. If we create
    the canvas in the `init` function, getting that element in the `update` function
    can be tricky. Let''s take a look at an example of this (this is dummy code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the `init` function that a new canvas element has been made and
    appended to the bound element. However, the variable (`canvas`) needs to be used
    in the `update` function to draw, and it isn't actually available there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knockout provides two utility methods, `ko.utils.domData.set(element,` `key,
    value)` and `ko.utils.domData.get(element,` `key)`, which can be used to set values
    on the bound element. They can store any JavaScript value, including DOM node
    references, and so we could certainly use them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will work. However, it does mean that the element not only contains the
    canvas as a child, but also as a property; it also means the retrieval of the
    element every time an update runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method would be to create a computed observable in the `init` function
    that had a closure for the canvas, or even the context. This might sound like
    it''s creating an extra object, but remember, the `update` function in bindings
    is actually wrapped in a computed to take advantage of the dependency detection.
    Using this method, our binding would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One thing to consider when using this method is the disposal of the computed.
    The third argument to the computed constructor is an `options` object, and with
    it, we can specify that the computed should be disposed off with a DOM node's
    removal by specifying the element. This option can be seen in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to note in the example is the `options` variable in the `init`
    function. You should be familiar with the concept of extending objects, but just
    in case, remember that extending (also called merging) is the process of choosing
    a target and updating it with a source object by copying all of its properties.
    The result is an object with the combination of both values, with the values of
    the source being used in any cases where the target also had a value. Knockout
    provides an `extend` method on `ko.utils.extend`. I am using it here to make all
    of the chart `options` optional, by supplying these default values before the
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that must be supplied is the data for the chart to display.
    Chart.js requires Doughnut charts to supply an array of objects with a value and
    color. To provide a humane binding, we can let the binding be responsible for
    ensuring the data is sanitized, which includes parsing the value as a number and
    ensuring our color value starts with the hash (`#`) for hex codes. Along with
    some options for height and width, our final computed would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An example of this binding, including some bindings to change the data, is in
    the `cp2-charts` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically adjusting the chart type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Three of the charts in Chart.js—Doughnut, Pie, and Polar Area—use the same
    data structure of value/color pairs. If you want to support switching between
    compatible charts, you can add the type as a binding option. The bottom of our
    computed would look like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate that this new binding supports multiple types, we could update
    the name and then use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This modified example can be seen in the `cp2-charts2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing APIs through bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chart.js example demonstrated binding against multiple properties. While
    we were able to control the chart by modifying bound observables for height, width,
    and type, it didn't allow us to *interact* with the chart. We could not click
    or drag the chart to update the observable for its data. The last custom binding
    technique we are going to look at is working with complex interactive controls;
    controls that bind multiple or complex data and allow user input. By doing this,
    we can consume APIs for a control either through the UI or programmatically. The
    example we will use is a binding for the Google Maps API.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of our abstraction goals is to keep how the UI gets things done out of
    the declaration of the UI. It doesn''t matter to us that the `visible` binding
    accomplishes its hiding by adding `style="display: none;"` to an element; all
    we care about is that the element will be visible only when the property we bind
    to is `truthy`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another goal of abstraction is to keep third-party data structures out of our
    viewmodel code, especially if that third-party code is only used by a binding
    handler. Our viewmodel doesn't care that its latitude and longitude are being
    used by a map, let alone a map from Google. That's the UI's business. However,
    it is still a fact of life that our data needs to be massaged into the correct
    format if we want it to play nicely with our third-party API. Here, again binding
    handlers come to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Google Maps JavaScript API is powerful and full of features. We are going
    to look at a simple binding that lets us control the center point of a map (latitude
    and longitude), as well as the zoom level of the map. We are going to hide all
    of the details of the Google Maps API inside our binding. Our viewmodel will be
    simple, just these three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, any reasonable mapping API would let us work with these properties,
    which allows our viewmodel to be reused for any of them. We want our HTML to be
    reusable as well, so it should use a map-provider agnostic syntax as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good; nothing new here. Let''s take a look at that map binding handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The beginning should be familiar by now; we are getting our `valueAccessor`
    parameter out, using some default values (see the previous sample) and extending
    them with the bound data. The next line creates a new map using the Google Maps
    API and supplies the element and our options.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up two computed values to update the map when the zoom or latitude/longitude
    values change. Another advantage of using the computed method instead of the binding
    handlers `update` method is that the `update` method will fire when any part of
    the `valueAccessor` property changes. If only one value changes, such as zoom,
    we wouldn't want to update the map position. We would have to figure out which
    value changed, which would mean tracking it in the binding. Here, the two computed
    values will rerun only when their dependencies change, ensuring that we don't
    make unnecessary calls to update the map.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a pair of event listeners on the map to update our observable
    values when the user interacts with the map. These use the Google Maps API's `addListener`
    to get updates whenever the map is moved, which can happen by mouse dragging or
    with the keyboard arrows, and whenever the zoom is changed. The `panTo` function
    is just an animated `move` command; if the new position is close enough, `panTo`
    will ease into it.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! If our code updates these values, the map will be moved. If the user
    moves the map, the bound observables will be updated. We have a two-way binding
    with multiple properties on a third-party UI control!
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this binding could get a lot bigger if we wanted to support more
    of the Google Maps APIs, but this should give you an idea of how that would be
    done. Don't be afraid to making larger bindings. The examples in this book are
    all small out of necessity—they tell me this will be printed on dead trees—but
    you should feel free to make bindings as large as you need to in order to accomplish
    the task at hand. I would take a larger, more flexible binding over a smaller
    inflexible binding any day.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see an example of this binding, check out the `cp2-maps` branch.
    It has several inputs bound to the map so that you can see things update in both
    directions. It's pretty fun to play with.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing APIs through bindings](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Binding contexts and descendant bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the binding handlers we have created so far have respected the standard
    binding context. In this section, we are going to look at techniques to modify
    the binding context. This allows fine-grained control over how elements are bound
    and data they are bound with.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per the Knockout documentation notes ([http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html](http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html)),
    these methods are not normally used in application development. They are probably
    only useful to library or framework developers building on top of Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling descendant bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can indicate to Knockout that your binding handler is responsible for all
    of the bindings on descendant nodes by returning `controlsDescendantBindings`
    from the `init` function of a binding. The canonical example of this is the `stopBinding`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will stop the current binding context from continuing to traverse these
    element descendants, leaving them in their initial unbound state unless another
    binding context is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The heading in this `div` element will still say `Unbound` after bindings are
    applied because `stopBinding` has stopped all descendant bindings. You can see
    an example of this binding in the `cp2-stopbinding` branch. Notice that if you
    change the `stopBinding` to `false`, the heading will say `Bound`.
  prefs: []
  type: TYPE_NORMAL
- en: So that's the basic idea, but what can we do with this? Well, after interrupting
    the current binding context, we can replace it with a different one!
  prefs: []
  type: TYPE_NORMAL
- en: Child binding contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most common binding context operation is creating a child context,
    a context whose `$parent` is the current context. The `template`, `with`, and
    `foreach` bindings do this for the data they bind. A child context can access
    its parent using the special `$parent` property, and it can access the top-level
    viewmodel (the one passed to `ko.applyBindings`) by using `$root`. You can create
    your own child contexts by calling `createChildContext` on the `bindingContext`
    parameter passed to a binding handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a binding that creates a child context by merging together two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This binding takes two properties, `target` and `source`, and uses the Knockout
    utility method `extend` to merge them together. Notice that because we are applying
    bindings to descendants, we have to return the `controlsDescendantBindings` flag.
    Consider the following viewmodel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `merge` binding to bind a template against the combined properties
    of the spring and summer courses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that inside the merge binding, we can use `$parent.name` to get the viewmodel's
    name. Because the child binding was created from the binding context inside the
    merge binding handler, the original hierarchy is still accessible. You can see
    a working sample of this in the `cp2-mergecontext` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Extending binding contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to modify the current binding context without creating a new child
    in the hierarchy. Well, sort of. Extending the binding context clones the current
    context while adding properties at the same time. Other binding handlers, siblings
    or parents, won't be affected by this sort of change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we modify the previous example slightly, you can easily see the difference
    between extending and creating a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The only impact this has on the HTML binding is that the name no longer needs
    to call `$parent` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see this example in the `cp2-mergecontext2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Extending and creating child contexts are very similar as far as potential use
    cases go. It's all going to depend on what you are doing, and whether or not adding
    layers is going to help. However, there is one more way of modifying the binding
    context, and it's a whole different beast.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a new $root context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some situations, it may be desirable to create a new binding context hierarchy
    instead of adding a layer to the existing one. This would allow a binding handler
    to provide itself, or a context that it managed, as the `$root` binding context
    to any descendant bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'One use case for this would be a binding handler that used a recursive template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This binding uses a recursive template to show an object and all of its children,
    while allowing the original binding to define the properties that will be used
    to populate this data. The root node's name is used on every descendant node using
    the `$root` binding context property, instead of having to walk back up the tree
    by counting the current depth. This is done with the call to `ko.applyBindings`,
    which unlike the other `apply` calls, creates an entirely new binding context
    using the first argument. Normally, this call is used to start applications, and
    when no second parameter is given, it applies to the entire window. The second
    parameter scopes this new context to the supplied element. The `tree` binding
    uses `firstChild` of the current element. Even though the `controlsDescendantBindings`
    flag stops Knockout from binding descendants, the current element is still bound,
    and applying bindings to it would cause the double-binding error to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this binding, a viewmodel could start out with any self-same object,
    such as a person with children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `tree` binding to show this information without having to use
    a special viewmodel to match the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This allows our `tree` binding to handle any recursive structure. You can see
    an example of this binding in the `cp2-rootcontext` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Containerless syntax with custom bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we spoke about containerless bindings; bindings applied
    through comments that created a virtual container around their "child" nodes.
    Now that we have a good understanding of how to create our own binding handlers,
    it's time to learn how to make them containerless bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to make a normal binding and then look at what we need
    to do to allow it to support the virtual elements. Let''s say you want a binding
    that sorts its children elements. It would need to loop through them, check some
    property, and then rearrange the DOM so they were in order. Normally, sorting
    would be achieved by using a `foreach` binding against a sorted `observableArray`
    property, but we''re going to make a sort binding that sorts on the width of the
    DOM node, which takes into account any CSS that may have affected it. The viewmodel
    would have a hard time getting this information to determine the proper sort order,
    and HTML elements and widths don''t belong in the viewmodel logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This binding would get used with a dummy property, as we aren''t actually checking
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The binding starts out by grabbing all the real child nodes from the bound
    element. The `isWhitespaceNode` check is just looking for the whitespace in the
    HTML from line breaks in between tags. We want to ignore these nodes because they
    will break the `with` check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After grabbing the usable children from the element, it sorts them based on
    their width in the ascending order. Then, it loops through the sorted children
    and appends them to the bound element. Removal of nodes is automatic, as the DOM
    only allows a node to exist once. This produces our width-sorted list. You can
    see an example of this in the `cp2-sort` branch. It is used to sort the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the width sort uses the actual width in pixels, Orville Redenbacher
    ended up after The Kellogg brothers despite them being the same number of characters.
    Unless, of course, you are using a monospaced font.
  prefs: []
  type: TYPE_NORMAL
- en: Using the virtual elements API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you tried to use this binding as a virtual element binding right now, you
    would get an error telling you that it won''t work. Knockout requires a flag to
    be set before bindings can be used in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This flag tells Knockout that `widthSort` will work with virtual elements,
    so Knockout won''t stop you from trying. It still won''t work though, because
    our binding is making calls to the elements children. Comment nodes don''t work
    with the normal JavaScript API, but Knockout provides a virtual element API that
    will work. These functions exist on the `ko.virtualElements` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`childNodes(containerElement)`: This returns the children of `containerElement`
    as an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emptyNode(containerElement)`: This removes all children from `containerElement`.
    This also cleans any data attached to the node to prevent memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstChild(containerElement)`: This returns the first child element, or null
    if the `containerElement` has no children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertAfter(containerElement`, `nodeToInsert`, `insertAfter)`: This adds `nodeToInsert`
    to `containerElement` after the `insertAfter` node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextSibling(node)`: This returns the next sibling of the node, or null if
    none exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepend(containerElement`, `nodeToPrepend)`: This inserts `nodeToPrepend`
    as the first child of `containerElement`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDomNodeChildren(containerElement`, `arrayOfNodes)`: This removes any children
    from `containerElement` (cleaning attached data) before inserting `arrayOfNodes`
    as children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these functions will treat a virtual element as if it were a real DOM
    node with children. They are also compatible with regular DOM nodes, so the same
    functions will work for regular and containerless bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the `widthSort` binding handlers to use this API would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The only two changes are using `childNodes` to get the children for sorting,
    and `setDomNodeChildren` to set the contents instead of looping through the sorted
    children. Our binding should now support the containerless syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the virtual elements version is in the `cp2-sort2` branch. For
    demonstration, the HTML has been updated so that the first element is not inside
    the sorting, something we couldn''t have done without virtual element support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take away one thing from all these examples, it should be that binding
    handlers are solely responsible for interaction with the DOM. In our first example,
    we made the `slideVisible` binding as an animated replacement for the standard
    `visible` binding. This change from the normal "instant" hide and show to the
    "animated" hide and show was completely decoupled by our viewmodel. This is beneficial
    because it keeps these two pieces completely separated, allowing them to develop
    and evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered simple and complex binding handlers, binding context
    management, and using the virtual elements API to support containerless bindings.
    In the next chapter, we will be looking at preprocessors for bindings and nodes.
  prefs: []
  type: TYPE_NORMAL
