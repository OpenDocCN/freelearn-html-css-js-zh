- en: Chapter 2. Extending Knockout with Custom Binding Handlers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 使用自定义绑定处理器扩展Knockout
- en: 'Knockout''s standard bindings are great. They solve most of the general problems
    you are likely to encounter when developing web apps. But there is always the
    need to provide something special, whether you are working on your own library
    or just trying to add a bit of style to your app. When that happens, you will
    want to provide that functionality through the same binding system you are using
    everywhere else. Luckily, Knockout makes extending this system easy. In this chapter,
    we will be looking at how to make our own binding handlers. We will be covering
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout的标准绑定很棒。它们解决了您在开发Web应用时可能遇到的大多数一般性问题。但总有提供特殊功能的需求，无论是您正在开发自己的库还是只是尝试为您的应用添加一些样式。当这种情况发生时，您将通过您在所有其他地方使用的相同绑定系统来提供该功能。幸运的是，Knockout使扩展此系统变得容易。在本章中，我们将探讨如何创建我们自己的绑定处理器。我们将涵盖以下主题：
- en: What a binding handler contains
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定处理器包含的内容
- en: Creating new binding handlers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的绑定处理器
- en: Using custom binding handlers to integrate with third-party libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义绑定处理器与第三方库集成
- en: Managing binding contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理绑定上下文
- en: Using the containerless control flow syntax with custom bindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无容器控制流语法与自定义绑定
- en: Creating custom binding handlers for new and more complex HTML interactions
    is a key to developing feature-rich applications. While the basics are easy to
    learn, there are enough extension points to support just about any use case. We
    are going to be looking at plenty of examples to get a solid idea of what binding
    handlers are capable of and how we can make the best use of them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为新的和更复杂的HTML交互创建自定义绑定处理器是开发功能丰富应用的关键。虽然基础知识容易学习，但扩展点足够多，可以支持几乎任何用例。我们将查看许多示例，以获得绑定处理器能够做什么以及我们如何最好地利用它们的稳固概念。
- en: The data binding pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定模式
- en: This section is primarily philosophical. If you feel like you already have a
    solid understanding of the *what* and *why* behind the **Model-View-ViewModel**
    (**MVVM**) pattern and binding handlers, then you might want to skip to the next
    section, *Components of a binding handler*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要涉及哲学。如果您已经对**模型-视图-视图模型**（**MVVM**）模式和绑定处理器背后的**是什么**和**为什么**有了稳固的理解，那么您可能想要跳到下一节，*绑定处理器的组成部分*。
- en: Okay, let's talk about patterns and practices. If you haven't worked with WPF
    before, then the MVVM pattern is probably the most confusing thing about Knockout.
    MVVM is a pattern that came out of Microsoft. It doesn't get a lot of attention
    outside the .NET community, and it's similar enough to the far more popular MVC
    pattern because of which confusion is nearly guaranteed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来谈谈模式和最佳实践。如果您之前没有使用过WPF，那么MVVM模式可能是Knockout中最令人困惑的事情。MVVM是微软提出的一个模式。它并没有在.NET社区之外得到很多关注，并且由于它与更受欢迎的MVC模式相似，因此混淆几乎是必然的。
- en: 'In MVVM, the viewmodel is supposed to represent an abstraction of the view.
    Consider these two lists of message threads in iOS:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM中，视图模型应该代表视图的抽象。考虑iOS中的这两个消息线程列表：
- en: '![The data binding pattern](img/00004.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![数据绑定模式](img/00004.jpeg)'
- en: They both show a list of threads, and each thread contains a title showing the
    person it is with, an excerpt from the most recent message, and a timestamp. A
    thread can be selected or deleted. To select a message, you can touch it. To delete
    a message, you can slide left to bring up the **Delete** button, and then press
    the **Delete** button to delete the thread. You might be able to spot a difference
    in behavior already though. The list on the left slides the entire thread left
    to reveal the **Delete** button, pushing the thread partially off the screen.
    The list on the right superimposes the button on top of the thread, hiding the
    timestamp.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都显示一个线程列表，每个线程都包含一个标题，显示与之相关的人员，最近消息的摘录，以及时间戳。可以选中或删除一个线程。要选择一条消息，您可以触摸它。要删除一条消息，您可以向左滑动以显示**删除**按钮，然后按下**删除**按钮来删除线程。尽管如此，您可能已经注意到了行为上的差异。左侧的列表将整个线程向左滑动以显示**删除**按钮，使线程部分离开屏幕。右侧的列表将按钮叠加在线程上方，隐藏了时间戳。
- en: These differences are entirely part of the presentation of the data. Both of
    these views could, and should, be supported by the same viewmodel. They are both
    showing the same data and allow the same actions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异完全是数据展示的一部分。这两个视图都可以，并且应该由同一个视图模型支持。它们都显示相同的数据并允许相同的操作。
- en: To be able to consume this data using the intended behavior (slide-reveal or
    slide-superimpose), the view needs support from something besides the viewmodel.
    In the MVVM pattern, this is the domain of the binding handler, and even though
    the binding handler doesn't get a letter in the acronym, it's still a critical
    piece of the puzzle. As the viewmodel is not supposed to know about view-related
    concepts such as buttons, clicks, or finger-taps, and the view is supposed to
    be entirely declarative; a binding handler is required to glue the two together.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预期的行为（幻灯片显示或幻灯片叠加）来消费这些数据，视图需要从除视图模型之外的其他东西那里获得支持。在MVVM模式中，这是绑定处理器的领域，尽管绑定处理器在缩写中没有字母，但它仍然是这个谜题的关键部分。由于视图模型不应该知道与视图相关的概念，如按钮、点击或手指触摸，而视图应该完全是声明性的，因此需要一个绑定处理器来将两者粘合在一起。
- en: The underlying principle here is the separation of concerns. The view is concerned
    with UI elements and interactions. The viewmodel is concerned with code objects
    and actions, and binding handlers are concerned with generically translating between
    specific UI elements or actions to and from the viewmodel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本原理是关注点的分离。视图关注UI元素和交互。视图模型关注代码对象和动作，而绑定处理器关注在视图模型之间通用地转换特定的UI元素或动作。
- en: As that's out of the way, time to get started with creating some custom binding
    handlers!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些都已经说清楚，那么是时候开始创建一些自定义绑定处理器了！
- en: Components of a binding handler
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定处理器的组件
- en: Binding handlers are defined by adding objects to the `ko.bindingHandlers` object,
    just like extenders. They are composed of an `init` and an `update` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定处理器通过向`ko.bindingHandlers`对象添加对象来定义，就像扩展器一样。它们由一个`init`和一个`update`函数组成。
- en: The `init` function runs when the binding is first applied to the element either
    when `ko.applyBindings` is called or when the element is created by a control
    flow binding, such as `template` or `foreach`. It should be used for all one-time
    work such as attaching event handlers or disposal callbacks to the element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定首次应用于元素时，`init`函数会运行，无论是调用`ko.applyBindings`还是通过控制流绑定（如`template`或`foreach`）创建元素。它应该用于所有一次性工作，例如将事件处理器或销毁回调附加到元素上。
- en: 'The `update` function runs just after `init` does, when the binding is first
    applied. It runs again anytime when any observable dependencies are changed. The
    `update` function determines its dependencies just like a computed observable
    does. If an observable is accessed when an update runs, it subscribes to that
    observable. The `update` function should be used to keep the UI in sync with changes
    from the viewmodel:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数在`init`之后运行，当绑定首次应用时。每当任何可观察的依赖项发生变化时，它都会再次运行。`update`函数确定其依赖项的方式与计算可观察项相同。如果在更新运行时访问了可观察项，它会订阅该可观察项。`update`函数应用于保持UI与视图模型的变化同步：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions receive the following parameters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都接收以下参数：
- en: '`Element`: This is the DOM element the binding was applied to.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Element`：这是绑定应用到的DOM元素。'
- en: '`valueAccessor`: This is a function that will return the result of the binding
    expression. For example, if the binding was `value: name`, then `valueAccessor`
    would return the `name` property. If `name` was an observable, you would still
    need to either call it or pass it to `ko.unwrap` (this function will be covered
    in the next section) to get the value. If the binding was `value: name() + ''!''`,
    then `valueAccessor` would return the resulting string.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valueAccessor`：这是一个函数，将返回绑定表达式的结果。例如，如果绑定是`value: name`，则`valueAccessor`将返回`name`属性。如果`name`是可观察的，则仍然需要调用它或将它传递给`ko.unwrap`（此函数将在下一节中介绍）以获取值。如果绑定是`value:
    name() + ''!''`，则`valueAccessor`将返回结果字符串。'
- en: '`allBindings`: This is an object with a `get` and `has` function for accessing
    other bindings on the element.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allBindings`：这是一个具有`get`和`has`函数的对象，用于访问元素上的其他绑定。'
- en: '`Viewmodel`: In previous versions of Knockout, this gave access to the viewmodel,
    but it has been deprecated in favor of `bindingContext.$data` or `bindingContext.$rawData`
    as of Knockout 3.0.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Viewmodel`：在Knockout的早期版本中，这提供了对视图模型的访问，但自Knockout 3.0以来，它已被弃用，转而使用`bindingContext.$data`或`bindingContext.$rawData`。'
- en: '`bindingContext`: This is an object with the current binding context for the
    binding. This has the special binding context properties such as `$parent` and
    `$root`. This parameter was introduced in Knockout 3.0.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindingContext`：这是一个对象，包含当前绑定的绑定上下文。它具有特殊的绑定上下文属性，如`$parent`和`$root`。此参数是在Knockout
    3.0中引入的。'
- en: Using custom binding handlers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义绑定处理器
- en: 'Once added to the `ko.bindingHandler` object, custom bindings are no different
    from normal bindings. If you add a binding handler named `flash`, you could use
    it on an HTML element with a standard `data-bind` attribute:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加到`ko.bindingHandler`对象中，自定义绑定与普通绑定没有区别。如果你添加了一个名为`flash`的绑定处理程序，你可以在具有标准`data-bind`属性的HTML元素上使用它：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Simple binding handlers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单绑定处理程序
- en: Binding handlers can range from very simple to whole applications by themselves.
    As the purpose of binding handlers is to translate between the presentation layer
    (HTML) and the viewmodel (JavaScript), the binding handler's complexity is directly
    related to the complexity of the UI interaction and the bound data. Simple tasks
    such as hiding or showing an element with animation will have very thin handlers,
    while data binding on an interactive map element will require much more logic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定处理程序可以从非常简单到完全独立的应用程序。由于绑定处理程序的目的在于在表示层（HTML）和视图模型（JavaScript）之间进行转换，因此绑定处理程序的复杂性直接与UI交互和绑定数据的复杂性相关。简单的任务，如使用动画隐藏或显示元素，将具有非常薄的处理器，而数据绑定在交互式地图元素上将需要更多的逻辑。
- en: Animated binding handlers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画绑定处理程序
- en: 'As DOM interaction in the primary use case for jQuery, and given its popularity,
    it is not uncommon to use jQuery inside Knockout binding handlers. The canonical
    custom binding handler example from the Knockout documentation is a binding to
    hide and show elements, with the jQuery''s `slideUp` and `slideDown` methods,
    instead of using the standard `visible` binding to switch them on and off:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DOM交互是jQuery的主要用途，并且鉴于其流行程度，在Knockout绑定处理程序中使用jQuery并不罕见。Knockout文档中的典型自定义绑定处理程序示例是一个用于隐藏和显示元素的绑定，使用jQuery的`slideUp`和`slideDown`方法，而不是使用标准的`visible`绑定来切换它们的开和关：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example uses both an `init` and `update` function. The `init` function
    here is necessary to ensure that a value starting out as false doesn't cause the
    element to slide up when bindings are first applied, or vice versa. Without it,
    the `update` function would run right away and try to hide the element by sliding
    it up. The `init` function ensures that the element is already in the correct
    visible state, so that an animation doesn't occur when the binding first runs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例同时使用了`init`和`update`函数。这里的`init`函数是必要的，以确保一个初始值为假的值在绑定首次应用时不会导致元素向上滑动，反之亦然。如果没有它，`update`函数会立即运行并尝试通过滑动隐藏元素。`init`函数确保元素已经处于正确的可见状态，因此当绑定首次运行时不会发生动画。
- en: '`ko.unwrap` is a utility method that will return the value of an observable
    if called with one; otherwise it will just return the first argument directly.
    It''s perfect if you don''t know whether you have an observable or not as it''s
    safe to call it with anything. Most custom bindings should be able to support
    observable and nonobservable values, so you should always unwrap the `valueAccessor`
    parameter, unless you have a good reason not to.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.unwrap`是一个实用方法，如果调用时带有一个参数，它将返回一个可观察值的值；否则，它将直接返回第一个参数。如果你不确定是否有可观察值，这是一个完美的选择，因为它可以安全地用任何东西调用。大多数自定义绑定应该能够支持可观察值和非可观察值，所以你应该始终解包`valueAccessor`参数，除非你有充分的理由不这样做。'
- en: 'The check for `allBindings.get(''slideDuration'')` allows a configurable value
    to be used for the slide timing. The `allBinding` object gives us access to other
    bindings that were used on the same element and is commonly used to collect optional
    configuration values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`allBindings.get('slideDuration')`允许使用可配置的值来设置幻灯片的计时。`allBinding`对象使我们能够访问同一元素上使用的其他绑定，通常用于收集可选的配置值：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This lets the view determine how fast or slow to hide and show the element.
    As the animation speed is a part of the presentation, it makes sense for it to
    be configured from the view. If you want to use a viewmodel observable for `slideDuration`,
    you can modify that line to unwrap the value:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许视图决定元素隐藏和显示的速度。由于动画速度是演示的一部分，因此从视图配置它是有意义的。如果你想使用视图模型的可观察值`slideDuration`，你可以修改该行以解包值：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An example of this binding is in the `cp2-slide` branch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定的一个示例在`cp2-slide`分支中。
- en: Working with third-party controls
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与第三方控件协同工作
- en: The `slideVisible` binding is a perfectly simple binding; it has a basic `init`
    function to start the binding and has an `update` function that modifies the DOM
    when the viewmodel changes. It is a **one way binding** though, only watching
    the viewmodel for changes. **Two way bindings** also need to watch the DOM element
    for changes and send it back to the viewmodel. Generally, this is accomplished
    by attaching an event handler in the `init` function; remember that the `update`
    function runs every time dependencies change, so attaching an event handler there
    would result in the event handler being attached multiple times.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`slideVisible`绑定是一个完美的简单绑定；它有一个基本的`init`函数来启动绑定，并且有一个`update`函数，当视图模型发生变化时修改DOM。然而，它是一个**单向绑定**，只监视视图模型的变化。**双向绑定**还需要监视DOM元素的变化并将其发送回视图模型。通常，这是通过在`init`函数中附加事件处理器来实现的；记住，`update`函数会在依赖项每次更改时运行，所以在那里附加事件处理器会导致事件处理器被多次附加。'
- en: 'Binding handlers can also be used to integrate with third-party controls. Though
    HTML5 has a native `datepicker` control, you might need one that is more backwards-compatible.
    The `datepicker` control of jQuery is a nice out-of-the-box control, but it requires
    a call to `$(element). datepicker()` to convert a standard input element. A binding
    handler is the perfect place to run this initialization logic for the view:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定处理器也可以用来与第三方控件集成。尽管HTML5有一个原生的`datepicker`控件，但你可能需要一个更向后兼容的控件。jQuery的`datepicker`控件是一个很好的即用型控件，但它需要调用`$(element).datepicker()`来将标准输入元素转换为日期选择器。绑定处理器是运行视图初始化逻辑的完美位置：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use this binding in HTML, apply it to an input element:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML中使用此绑定，请将其应用于一个输入元素：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example comes from a Stack Overflow answer by R. P. Niemeyer that can be
    found at [http://stackoverflow.com/a/6400701/788260](http://stackoverflow.com/a/6400701/788260).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例来自R. P. Niemeyer在Stack Overflow上的答案，可以在[http://stackoverflow.com/a/6400701/788260](http://stackoverflow.com/a/6400701/788260)找到。
- en: This binding's `init` function starts out by storing the jQuery wrapped element,
    followed by a check for options. The UI datepicker for jQuery ([http://jqueryui.com/datepicker](http://jqueryui.com/datepicker))
    has a lot of them, and letting the binding control the configuration is standard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定的`init`函数首先存储jQuery包装的元素，然后检查选项。jQuery UI的UI日期选择器([http://jqueryui.com/datepicker](http://jqueryui.com/datepicker))有很多选项，允许绑定控制配置是标准的。
- en: Next is the jQuery-ficiation of the element with `$el.datepicker(options)`.
    This attaches the event handlers that allow jQuery to hide and show the pop-up
    datepicker control and route its selection to the input element's `value`. Then,
    using Knockout's `ko.utils.registerEventHandler`, it attaches an event handler
    that takes the new `value` and writes it to the supplied observable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用`$el.datepicker(options)`对元素进行jQuery化。这附加了允许jQuery隐藏和显示弹出日期选择器控件并将其选择路由到输入元素的`value`的事件处理器。然后，使用Knockout的`ko.utils.registerEventHandler`，它附加了一个事件处理器，该处理器接受新的`value`并将其写入提供的可观察对象。
- en: 'In some cases, we might want to see whether the `valueAccessor` parameter is
    an observable, so that binding against a static value can still be used to set
    the element''s initial value. You will want to use your best judgment here; in
    this case, the whole purpose of the binding is to collect user input, so it doesn''t
    make sense in this case to work with nonobservable values. If you do want to make
    the check, you could change the event handler portion in the following manner:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能想查看`valueAccessor`参数是否是可观察的，这样即使针对静态值，绑定也可以用来设置元素的初始值。你在这里需要使用你的最佳判断；在这种情况下，绑定的整个目的就是收集用户输入，所以在这种情况下与非可观察值一起工作是没有意义的。如果你确实想进行检查，你可以按以下方式更改事件处理器部分：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ko.isObservable` function is a utility method that returns `true` if the
    first argument is an `observable`, `observableArray`, or `computed` observable.
    When the `valueAccessor` parameter isn't an observable, there is no need to attach
    the change handler at all, because there is nothing we would do with the new value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.isObservable`函数是一个实用方法，如果第一个参数是`observable`、`observableArray`或`computed`可观察对象，则返回`true`。当`valueAccessor`参数不是可观察对象时，根本不需要附加更改处理器，因为我们不会对新的值做任何事情。'
- en: The last piece in the `init` function is a **disposal handler**. Disposal of
    bindings occurs when the element is removed from the DOM, which happens when control
    flow bindings such as `template` or `foreach` update themselves. The `datepicker`
    control of jQuery expects `$el.datepicker("destroy")` to be called to clean up
    the event handlers if attached, and remove the pop-up element from the DOM. Remember,
    the pop-up element was added by jQuery from inside this binding handler, so Knockout's
    template system is not aware of them. The `ko.utils.domNodeDisposal.addDisposeCallback`
    registers handlers that will be called by the template system when it removes
    a node from the DOM. This is an important step anytime your binding handler has
    modified the DOM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数中的最后一部分是一个**销毁处理程序**。当元素从DOM中移除时，绑定就会被销毁，这通常发生在`template`或`foreach`等控制流绑定更新自身时。jQuery的`datepicker`控件期望调用`$el.datepicker("destroy")`来清理事件处理器（如果有的话），并从DOM中移除弹出元素。记住，弹出元素是由jQuery在这个绑定处理程序内部添加的，所以Knockout的模板系统并不了解它们。《ko.utils.domNodeDisposal.addDisposeCallback》注册了当模板系统从DOM中移除节点时将被调用的处理器。这是一个重要的步骤，任何时候你的绑定处理程序修改了DOM。'
- en: The `update` function handles observable changes, but as it is translating between
    strings for the element's value and JavaScript `Dates` for the code, it has to
    perform its own equality check. Instead of looking at the element's value, it
    uses `$el.datepicker("getDate")`, which returns a real JavaScript date.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数处理可观察的变化，但由于它需要在元素值和JavaScript `Dates`代码之间进行转换，它必须执行自己的相等性检查。它不是查看元素值，而是使用`$el.datepicker("getDate")`，这返回一个真实的JavaScript日期。'
- en: To see this binding in action, you can check out the `cp2-datepicker` branch.
    I've added a `span` bound by the same viewmodel property as the datepicker so
    that you can easily see the value update.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个绑定的实际效果，你可以查看`cp2-datepicker`分支。我添加了一个与日期选择器绑定相同视图模型属性的`span`元素，这样你可以轻松地看到值的变化。
- en: Modifying the DOM with bindings
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用绑定修改DOM
- en: 'The previous two bindings were mostly translators between the data and presentation
    logic, but binding handlers can do much more. Bindings can also be used to add
    new elements to the page. If you want to provide a UI for a 1-5 rating system,
    you should think about using a `select` element with an `options` and `value`
    binding. While this would work, a much more common way would be to provide a series
    of stars for the user to click on, with a click activating the clicked star and
    every previous star. The Knockout tutorial site ([http://learn.knockoutjs.com/#/?tutorial=custombindings](http://learn.knockoutjs.com/#/?tutorial=custombindings))
    provides a neat solution to this, which replaces a node''s content with a list
    of styled `span` elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个绑定主要是数据与展示逻辑之间的转换器，但绑定处理程序可以做得更多。绑定也可以用来向页面添加新元素。如果你想提供一个1-5星级的UI，你应该考虑使用带有`options`和`value`绑定的`select`元素。虽然这可以工作，但更常见的方法是提供一系列用户可以点击的星星，点击会激活被点击的星星和所有之前的星星。Knockout教程网站([http://learn.knockoutjs.com/#/?tutorial=custombindings](http://learn.knockoutjs.com/#/?tutorial=custombindings))提供了一个很好的解决方案，它用一系列样式化的`span`元素替换了节点的内容：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You could use this binding on an element in the following manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样在元素上使用这个绑定：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result is a nice looking control that will be familiar to anyone who has
    filled out an online survey before:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个看起来很不错的控件，对于之前填写过在线调查的人来说会感到熟悉：
- en: '![Modifying the DOM with bindings](img/00005.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用绑定修改DOM](img/00005.jpeg)'
- en: The `init` function for this binding sets up three things. First, it adds five
    span elements as children of the bound node, which will serve as the stars for
    the rating. Second, it adds hover handlers to apply and remove the `hoverChosen`
    class to the star under the cursor, as well as all the previous stars. The stars
    are cumulative, so if we hover over the third star, we should see the first three
    stars fill in. Finally, it adds a click handler to each star that updates the
    `bound` property with the number the star represents. As its using the index of
    the loop, which starts at `0`, it adds `1` to the value. Again, we see that the
    binding assumes that the property being used is observable. If we wanted to support
    a read-only display, we would modify the binding to check that the property is
    observable before trying to update it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定的`init`函数设置了三件事。首先，它向绑定节点添加五个span元素作为子元素，这些元素将作为评分的星级。其次，它添加了悬停处理程序，将`hoverChosen`类应用到光标下的星级以及所有前面的星级。星级是累积的，所以如果我们悬停在第三个星级上，我们应该看到前三个星级填充。最后，它为每个星级添加了一个点击处理程序，该处理程序使用星级所代表的数字更新`bound`属性。由于它使用循环的索引，该循环从`0`开始，因此它将`1`添加到值上。再次，我们看到绑定假定所使用的属性是可观察的。如果我们想支持只读显示，我们就会修改绑定以在尝试更新之前检查属性是否可观察。
- en: The `update` function for this binding is different from the ones we've looked
    at so far. Instead of using the new value from the `valueAccesor` property to
    set an attribute of the original bound element, it loops through the stars and
    uses jQuery's `toggleClass` to set or remove the chosen class, applying it to
    only the stars whose index is at or below the new value. The viewmodel is still
    only aware of an integer value, and the view is only aware that the bound element
    is using `starRating` to present that number. The binding handler abstracts away
    star elements and also handles the translation between the numeric value and selected
    stars.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定的`update`函数与我们之前看到的函数不同。它不是使用`valueAccesor`属性的新值来设置原始绑定元素的属性，而是遍历星级并使用jQuery的`toggleClass`来设置或删除所选类，仅应用于索引在或低于新值的星级。视图模型仍然只知道一个整数值，而视图只知道绑定元素正在使用`starRating`来展示该数字。绑定处理程序抽象出星级元素，并处理数字值与所选星级之间的转换。
- en: This binding assumes the existence of the CSS classes that it applies to the
    star spans. You can see an interactive sample of this binding and the CSS in the
    `cp2-stars` branch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定假定存在应用于星级span的CSS类。您可以在`cp2-stars`分支中看到此绑定和CSS的交互式示例。
- en: Applying new bindings to new children elements
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将新绑定应用到新子元素
- en: In the previous example, we looked at creating children elements to present
    our data with some style. It was using jQuery to manage the classes of the children
    elements that it had added during the binding's initialization. However, when
    using Knockout bindings, sometimes it makes more sense to use the built-in binding
    handlers for this sort of thing. Luckily it's possible to add Knockout bindings
    to elements after they've been created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们查看如何创建子元素以使用一些样式来展示我们的数据。它是使用jQuery来管理在绑定初始化期间添加的子元素类。然而，当使用Knockout绑定时，有时使用内置的绑定处理程序来处理这类事情更有意义。幸运的是，我们可以在元素创建后添加Knockout绑定。
- en: 'Knockout provides a utility function, `ko.applyBindingsToNode`, to manually
    apply bindings to elements. The function takes an element to bind an object. Each
    property on the object will be used to look up a binding handler, and the property''s
    value will be passed to the binding. It also takes an optional viewmodel or binding
    context as the third parameter; if left out, it will use the current binding context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了一个实用函数`ko.applyBindingsToNode`，用于手动将绑定应用到元素上。该函数接受一个绑定元素的对象。对象上的每个属性都将用于查找绑定处理程序，并将属性的值传递给绑定。它还接受一个可选的视图模型或绑定上下文作为第三个参数；如果省略，它将使用当前的绑定上下文：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will add a new input element after the original element and apply a `value`
    binding to the original observable. The `applyBindingsToNode` call takes the new
    input element and an object that will apply the `value` binding. The `valueAccessor`
    property returns the original property and passes it to the binding, essentially
    binding the new input to the same property as the original binding.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在原始元素之后添加一个新的输入元素，并将一个`value`绑定应用到原始的可观察对象上。`applyBindingsToNode`调用接受一个新的输入元素和一个将应用`value`绑定的对象。`valueAccessor`属性返回原始属性并将其传递给绑定，本质上是将新的输入绑定到与原始绑定相同的属性。
- en: 'If we want to create a binding that adds an input with a new label, it might
    look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个添加带有新标签的输入的绑定，它可能看起来像这样：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Its binding could be used as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其绑定可以使用如下方式：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This binding creates a new label and input that it appends as children to the
    original binding. The label's text is set to the binding's `label` property, and
    the binding's `value` is bound to the input node. Hopefully, you can start to
    see how a binding handler could be used to create not only your own behavior,
    but your own custom elements as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定创建一个新的标签和输入，并将其作为子元素附加到原始绑定上。标签的文本设置为绑定的 `label` 属性，而绑定的 `value` 则绑定到输入节点。希望您现在可以开始看到绑定处理程序如何被用来创建不仅自己的行为，还可以创建自己的自定义元素。
- en: An example of this binding can be seen in the `cp2-applynode` branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定的一个示例可以在 `cp2-applynode` 分支中看到。
- en: Applying accessors
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用访问器
- en: 'The `applyBindingsToNode` method is available in all versions of Knockout,
    but another method is available if you are using Knockout 3.0 or higher. The `applyBindingAccessorsToNode`
    method works in a way similar to `applyBindingsToNode`, taking an object to bind
    as the first parameter and an optional binding context as the third parameter.
    However, instead of taking the values of the second parameter''s properties directly,
    it takes a function that supplies the `valueAccessor` property. The previous `apply`
    call would look like this after being converted:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyBindingsToNode` 方法在 Knockout 的所有版本中都可用，但如果您使用的是 Knockout 3.0 或更高版本，则还有一个方法可用。`applyBindingAccessorsToNode`
    方法的工作方式与 `applyBindingsToNode` 类似，它将绑定对象作为第一个参数，并将可选的绑定上下文作为第三个参数。然而，它不是直接获取第二个参数属性的值，而是获取一个提供
    `valueAccessor` 属性的函数。之前的 `apply` 调用在被转换后看起来如下：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method is actually what `applyBindingsToNode` calls internally after the
    values given to it are converted into value accessor functions such as the previous
    ones. The one fewer step of indirection gained by using `applyBindingAccessorsToNode`
    gives marginally improved performance. However, the larger benefit comes when
    the value being bound against it is an expression instead of just a simple property.
    An expression can only establish a dependency if it is evaluated from inside the
    binding that uses it. The value accessor functions will be evaluated later, allowing
    them to work correctly with expressions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法实际上是 `applyBindingsToNode` 在将其提供的值转换为值访问器函数（如之前的那些）后内部调用的。使用 `applyBindingAccessorsToNode`
    获得的少量间接步骤减少了性能。然而，更大的好处在于当绑定的值是一个表达式而不是一个简单的属性时。一个表达式只有在从使用它的绑定内部评估时才能建立依赖关系。值访问器函数将在稍后评估，允许它们正确地与表达式一起工作。
- en: Controlling the order of binding handlers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制绑定处理程序的顺序
- en: 'In rare cases, you may need to ensure that the binding handlers occur in a
    certain order. As of Knockout 3.0, this is possible by setting the `after` property
    on a binding handler to an array of bindings that must be processed first. For
    example, you can define a binding that require values and options to be processed
    first:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，您可能需要确保绑定处理程序按特定顺序发生。截至 Knockout 3.0，通过将绑定处理程序的 `after` 属性设置为必须首先处理的绑定数组，这是可能的。例如，您可以定义一个需要首先处理值和选项的绑定：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Several of the default bindings take advantage of this. The `value` binding
    depends on `options` and `foreach`; the `checked` binding depends on `value` and
    `attr`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 几个默认绑定都利用了这一点。`value` 绑定依赖于 `options` 和 `foreach`；`checked` 绑定依赖于 `value` 和
    `attr`。
- en: It should be noted that if you create two bindings with an `after` reference
    to each other, Knockout will throw a cyclic dependency exception if it ever tries
    to apply both bindings to the same element.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，如果您创建了两个具有相互 `after` 引用的绑定，Knockout 如果试图将这两个绑定应用到同一元素上，将会抛出一个循环依赖异常。
- en: Advanced binding handlers
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级绑定处理程序
- en: So far, we've been looking at binding handlers that handle one or two properties
    and result in a fairly simple single-purpose control. In the previous example,
    we started looking at binding handlers that created new child elements, and this
    technique allows us to create much more complex binding behaviors. Bindings can
    also interact with complex elements such as charts or map controls (for example,
    a Google Maps widget), providing a clean API that the viewmodel can interact with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在查看处理一个或两个属性并导致相当简单的单一用途控制的绑定处理程序。在之前的示例中，我们开始查看创建新子元素的绑定处理程序，并且这种技术允许我们创建更复杂的绑定行为。绑定还可以与复杂元素（如图表或地图控件）交互（例如，Google
    地图小部件），为 viewmodel 提供一个干净的 API，以便与之交互。
- en: Binding complex data with charts
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图表绑定复杂数据
- en: The first time we looked at integrating with a third-party control was with
    a single-property two-way binding to a datepicker. Any time we are working with
    third-party UI tools, the goal is to abstract them away from the view and the
    viewmodel through bindings; even when those tools are for complex structures such
    as charts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次我们考虑与第三方控件集成时，是与日期选择器的单属性双向绑定。每次我们与第三方UI工具一起工作时，目标是通过绑定将它们从视图和视图模型中抽象出来；即使这些工具是用于复杂结构，如图表。
- en: 'Charts.js ([http://www.chartjs.org](http://www.chartjs.org)) is a popular JavaScript
    library built to display data in, you guessed it right, graphical charts. Without
    going too deep into the details of how charts work, one challenge presented by
    a binding handler is that the chart doesn''t have an API for making incremental
    updates. The whole chart needs to be re-rendered for updates. This requires access
    to the `canvas` element as well as the 2D context for the canvas. If we create
    the canvas in the `init` function, getting that element in the `update` function
    can be tricky. Let''s take a look at an example of this (this is dummy code):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Charts.js ([http://www.chartjs.org](http://www.chartjs.org)) 是一个流行的JavaScript库，用于显示数据，正如你所猜想的，是图形图表。不深入探讨图表工作细节，一个由绑定处理程序提出的挑战是，图表没有用于制作增量更新的API。整个图表需要重新渲染以进行更新。这需要访问`canvas`元素以及画布的2D上下文。如果我们创建画布在`init`函数中，在`update`函数中获取该元素可能会很棘手。让我们看看一个这样的例子（这是示例代码）：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see in the `init` function that a new canvas element has been made and
    appended to the bound element. However, the variable (`canvas`) needs to be used
    in the `update` function to draw, and it isn't actually available there.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`init`函数中看到，一个新的画布元素已经被创建并附加到绑定元素上。然而，变量（`canvas`）需要在`update`函数中用于绘图，但实际上它并不在那里可用。
- en: 'Knockout provides two utility methods, `ko.utils.domData.set(element,` `key,
    value)` and `ko.utils.domData.get(element,` `key)`, which can be used to set values
    on the bound element. They can store any JavaScript value, including DOM node
    references, and so we could certainly use them here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了两个实用方法，`ko.utils.domData.set(element, key, value)`和`ko.utils.domData.get(element,
    key)`，它们可以用于在绑定元素上设置值。它们可以存储任何JavaScript值，包括DOM节点引用，因此我们当然可以在这里使用它们：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will work. However, it does mean that the element not only contains the
    canvas as a child, but also as a property; it also means the retrieval of the
    element every time an update runs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效。然而，这也意味着元素不仅包含画布作为子元素，还作为属性；这也意味着每次更新运行时都需要检索该元素。
- en: 'Another method would be to create a computed observable in the `init` function
    that had a closure for the canvas, or even the context. This might sound like
    it''s creating an extra object, but remember, the `update` function in bindings
    is actually wrapped in a computed to take advantage of the dependency detection.
    Using this method, our binding would look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在`init`函数中创建一个具有对画布或甚至上下文的闭包的计算可观察对象。这听起来像是创建了一个额外的对象，但请记住，绑定中的`update`函数实际上被包裹在一个计算中，以利用依赖检测的优势。使用这种方法，我们的绑定将看起来像这样：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One thing to consider when using this method is the disposal of the computed.
    The third argument to the computed constructor is an `options` object, and with
    it, we can specify that the computed should be disposed off with a DOM node's
    removal by specifying the element. This option can be seen in the previous example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时需要考虑的一点是计算的可处置性。计算构造函数的第三个参数是一个`options`对象，我们可以通过指定元素来指定计算应该与DOM节点的移除一起被销毁。这个选项可以在前面的例子中看到。
- en: 'Another thing to note in the example is the `options` variable in the `init`
    function. You should be familiar with the concept of extending objects, but just
    in case, remember that extending (also called merging) is the process of choosing
    a target and updating it with a source object by copying all of its properties.
    The result is an object with the combination of both values, with the values of
    the source being used in any cases where the target also had a value. Knockout
    provides an `extend` method on `ko.utils.extend`. I am using it here to make all
    of the chart `options` optional, by supplying these default values before the
    binding:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中需要注意的另一件事是`init`函数中的`options`变量。你应该熟悉扩展对象的概念，但以防万一，请记住，扩展（也称为合并）是指选择一个目标对象，并通过复制其所有属性来使用源对象更新它。结果是具有两者组合值的对象，在目标对象也有值的情况下，使用源对象的值。Knockout在`ko.utils.extend`上提供了一个`extend`方法。我在这里使用它来使所有的图表`options`都是可选的，通过在绑定之前提供这些默认值：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only thing that must be supplied is the data for the chart to display.
    Chart.js requires Doughnut charts to supply an array of objects with a value and
    color. To provide a humane binding, we can let the binding be responsible for
    ensuring the data is sanitized, which includes parsing the value as a number and
    ensuring our color value starts with the hash (`#`) for hex codes. Along with
    some options for height and width, our final computed would look something like
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提供的是图表显示所需的数据。Chart.js要求Doughnut图表提供一个包含值和颜色的对象数组。为了提供一个人性化的绑定，我们可以让绑定负责确保数据被清理，这包括将值解析为数字并确保我们的颜色值以哈希（`#`）开头，用于十六进制代码。除了高度和宽度的一些选项外，我们的最终计算结果可能如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An example of this binding, including some bindings to change the data, is in
    the `cp2-charts` branch.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定的一个示例，包括一些用于更改数据的绑定，可以在`cp2-charts`分支中找到。
- en: Dynamically adjusting the chart type
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态调整图表类型
- en: 'Three of the charts in Chart.js—Doughnut, Pie, and Polar Area—use the same
    data structure of value/color pairs. If you want to support switching between
    compatible charts, you can add the type as a binding option. The bottom of our
    computed would look like this instead:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Chart.js中的三个图表——Doughnut、Pie和Polar Area——使用相同的值/颜色对数据结构。如果你想支持在兼容的图表之间切换，你可以添加类型作为绑定选项。我们的计算结果将如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To indicate that this new binding supports multiple types, we could update
    the name and then use it like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表明这种新的绑定支持多种类型，我们可以更新名称，然后像这样使用它：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This modified example can be seen in the `cp2-charts2` branch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改后的示例可以在`cp2-charts2`分支中看到。
- en: Exposing APIs through bindings
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过绑定公开API
- en: The Chart.js example demonstrated binding against multiple properties. While
    we were able to control the chart by modifying bound observables for height, width,
    and type, it didn't allow us to *interact* with the chart. We could not click
    or drag the chart to update the observable for its data. The last custom binding
    technique we are going to look at is working with complex interactive controls;
    controls that bind multiple or complex data and allow user input. By doing this,
    we can consume APIs for a control either through the UI or programmatically. The
    example we will use is a binding for the Google Maps API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Chart.js示例展示了针对多个属性的绑定。虽然我们能够通过修改绑定可观察的高度、宽度和类型来控制图表，但它不允许我们与图表进行交互。我们无法点击或拖动图表来更新其数据的可观察值。我们将要查看的最后一种自定义绑定技术是处理复杂交互控件；这些控件绑定多个或复杂的数据并允许用户输入。通过这样做，我们可以通过UI或编程方式消费控件API。我们将使用的示例是Google
    Maps API的绑定。
- en: 'One of our abstraction goals is to keep how the UI gets things done out of
    the declaration of the UI. It doesn''t matter to us that the `visible` binding
    accomplishes its hiding by adding `style="display: none;"` to an element; all
    we care about is that the element will be visible only when the property we bind
    to is `truthy`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的抽象目标之一是保持UI如何完成任务与UI声明的分离。对我们来说，`visible`绑定通过向元素添加`style="display: none;"`来实现隐藏并不重要；我们只关心当绑定的属性为`truthy`时，元素才会可见。'
- en: Another goal of abstraction is to keep third-party data structures out of our
    viewmodel code, especially if that third-party code is only used by a binding
    handler. Our viewmodel doesn't care that its latitude and longitude are being
    used by a map, let alone a map from Google. That's the UI's business. However,
    it is still a fact of life that our data needs to be massaged into the correct
    format if we want it to play nicely with our third-party API. Here, again binding
    handlers come to the rescue!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的另一个目标是让第三方数据结构不进入我们的viewmodel代码，特别是如果第三方代码仅由绑定处理程序使用。我们的viewmodel不关心它的纬度和经度是否被地图使用，更不用说是一个来自Google的地图。这是UI的业务。然而，我们仍然需要将数据整理成正确的格式，如果我们希望它与第三方API友好地交互。在这里，绑定处理程序再次救命！
- en: 'The Google Maps JavaScript API is powerful and full of features. We are going
    to look at a simple binding that lets us control the center point of a map (latitude
    and longitude), as well as the zoom level of the map. We are going to hide all
    of the details of the Google Maps API inside our binding. Our viewmodel will be
    simple, just these three properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API功能强大且功能丰富。我们将查看一个简单的绑定，它允许我们控制地图的中心点（纬度和经度），以及地图的缩放级别。我们将在我们的绑定中隐藏Google
    Maps API的所有细节。我们的viewmodel将是简单的，只有这三个属性：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Hopefully, any reasonable mapping API would let us work with these properties,
    which allows our viewmodel to be reused for any of them. We want our HTML to be
    reusable as well, so it should use a map-provider agnostic syntax as well:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 希望任何合理的映射API都会允许我们使用这些属性，这允许我们的viewmodel对它们中的任何一个进行重用。我们希望我们的HTML也是可重用的，因此它应该使用一个与地图提供者无关的语法：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far so good; nothing new here. Let''s take a look at that map binding handler:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利；这里没有新的内容。让我们看看那个映射绑定处理程序：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The beginning should be familiar by now; we are getting our `valueAccessor`
    parameter out, using some default values (see the previous sample) and extending
    them with the bound data. The next line creates a new map using the Google Maps
    API and supplies the element and our options.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，开始部分应该是熟悉的了；我们正在获取`valueAccessor`参数，使用一些默认值（参见前面的示例）并将它们扩展到绑定数据。下一行使用Google
    Maps API创建一个新的映射，并提供了元素和我们的选项。
- en: Next, we set up two computed values to update the map when the zoom or latitude/longitude
    values change. Another advantage of using the computed method instead of the binding
    handlers `update` method is that the `update` method will fire when any part of
    the `valueAccessor` property changes. If only one value changes, such as zoom,
    we wouldn't want to update the map position. We would have to figure out which
    value changed, which would mean tracking it in the binding. Here, the two computed
    values will rerun only when their dependencies change, ensuring that we don't
    make unnecessary calls to update the map.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置两个计算值，以便在缩放或纬度/经度值变化时更新地图。使用计算方法而不是绑定处理程序的`update`方法的优势在于，`update`方法将在`valueAccessor`属性的任何部分发生变化时触发。如果只有一个值发生变化，例如缩放，我们不想更新地图位置。我们必须找出哪个值发生了变化，这意味着在绑定中跟踪它。在这里，这两个计算值只有在它们的依赖项发生变化时才会重新运行，确保我们不会进行不必要的调用以更新地图。
- en: Finally, we have a pair of event listeners on the map to update our observable
    values when the user interacts with the map. These use the Google Maps API's `addListener`
    to get updates whenever the map is moved, which can happen by mouse dragging or
    with the keyboard arrows, and whenever the zoom is changed. The `panTo` function
    is just an animated `move` command; if the new position is close enough, `panTo`
    will ease into it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在地图上有一对事件监听器，用于在用户与地图交互时更新我们的可观察值。这些使用Google Maps API的`addListener`来获取更新，无论地图是移动的，这可以通过鼠标拖动或使用键盘箭头完成，以及当缩放改变时。`panTo`函数只是一个动画的`move`命令；如果新位置足够接近，`panTo`将平滑地进入。
- en: That's it! If our code updates these values, the map will be moved. If the user
    moves the map, the bound observables will be updated. We have a two-way binding
    with multiple properties on a third-party UI control!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果我们的代码更新了这些值，地图将会移动。如果用户移动地图，绑定的可观察值将会更新。我们在第三方UI控件上实现了多属性的双向绑定！
- en: Obviously, this binding could get a lot bigger if we wanted to support more
    of the Google Maps APIs, but this should give you an idea of how that would be
    done. Don't be afraid to making larger bindings. The examples in this book are
    all small out of necessity—they tell me this will be printed on dead trees—but
    you should feel free to make bindings as large as you need to in order to accomplish
    the task at hand. I would take a larger, more flexible binding over a smaller
    inflexible binding any day.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想支持更多的 Google Maps API，这个绑定可以做得更大，但这应该能给你一个如何做到这一点的概念。不要害怕制作更大的绑定。这本书中的例子都是出于必要而做得很小——它们告诉我这将打印在死树上——但你应该自由地制作你完成任务所需的任何大小的绑定。我宁愿选择一个更大、更灵活的绑定，也不愿选择一个更小、更不灵活的绑定。
- en: If you want to see an example of this binding, check out the `cp2-maps` branch.
    It has several inputs bound to the map so that you can see things update in both
    directions. It's pretty fun to play with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看这个绑定的示例，请查看 `cp2-maps` 分支。它有几个输入绑定到地图上，这样你就可以看到双向更新。玩起来很有趣。
- en: '![Exposing APIs through bindings](img/00006.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![通过绑定公开 API](img/00006.jpeg)'
- en: Binding contexts and descendant bindings
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定上下文和子绑定
- en: All of the binding handlers we have created so far have respected the standard
    binding context. In this section, we are going to look at techniques to modify
    the binding context. This allows fine-grained control over how elements are bound
    and data they are bound with.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的所有绑定处理程序都尊重标准绑定上下文。在本节中，我们将探讨修改绑定上下文的技术。这允许对元素如何绑定以及它们绑定的数据进行精细控制。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As per the Knockout documentation notes ([http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html](http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html)),
    these methods are not normally used in application development. They are probably
    only useful to library or framework developers building on top of Knockout.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Knockout 文档的说明（[http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html](http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html)），这些方法通常不用于应用程序开发。它们可能只对构建在
    Knockout 之上的库或框架开发者有用。
- en: Controlling descendant bindings
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制子绑定
- en: 'You can indicate to Knockout that your binding handler is responsible for all
    of the bindings on descendant nodes by returning `controlsDescendantBindings`
    from the `init` function of a binding. The canonical example of this is the `stopBinding`
    handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从绑定处理程序的 `init` 函数返回 `controlsDescendantBindings` 来告诉 Knockout 你的绑定处理程序负责所有子节点的绑定。这个典型例子是
    `stopBinding` 处理程序：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will stop the current binding context from continuing to traverse these
    element descendants, leaving them in their initial unbound state unless another
    binding context is started:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止当前绑定上下文继续遍历这些元素的后代，除非启动另一个绑定上下文，否则它们将保持初始未绑定状态：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The heading in this `div` element will still say `Unbound` after bindings are
    applied because `stopBinding` has stopped all descendant bindings. You can see
    an example of this binding in the `cp2-stopbinding` branch. Notice that if you
    change the `stopBinding` to `false`, the heading will say `Bound`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用绑定后，这个 `div` 元素中的标题仍然会显示为 `Unbound`，因为 `stopBinding` 停止了所有子绑定的应用。你可以在 `cp2-stopbinding`
    分支中看到一个绑定示例。注意，如果你将 `stopBinding` 改为 `false`，标题将显示为 `Bound`。
- en: So that's the basic idea, but what can we do with this? Well, after interrupting
    the current binding context, we can replace it with a different one!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是基本概念，但我们能做什么呢？嗯，在打断当前绑定上下文后，我们可以用另一个上下文来替换它！
- en: Child binding contexts
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子绑定上下文
- en: Probably the most common binding context operation is creating a child context,
    a context whose `$parent` is the current context. The `template`, `with`, and
    `foreach` bindings do this for the data they bind. A child context can access
    its parent using the special `$parent` property, and it can access the top-level
    viewmodel (the one passed to `ko.applyBindings`) by using `$root`. You can create
    your own child contexts by calling `createChildContext` on the `bindingContext`
    parameter passed to a binding handler.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常用的绑定上下文操作是创建一个子上下文，其 `$parent` 是当前上下文。`template`、`with` 和 `foreach` 绑定会为它们绑定的数据执行此操作。子上下文可以使用特殊属性
    `$parent` 访问其父上下文，并且可以使用 `$root` 访问顶级视图模型（传递给 `ko.applyBindings` 的那个）。你可以通过在绑定处理程序传递的
    `bindingContext` 参数上调用 `createChildContext` 来创建自己的子上下文。
- en: 'Here is a binding that creates a child context by merging together two objects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个通过合并两个对象来创建子上下文的绑定示例：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This binding takes two properties, `target` and `source`, and uses the Knockout
    utility method `extend` to merge them together. Notice that because we are applying
    bindings to descendants, we have to return the `controlsDescendantBindings` flag.
    Consider the following viewmodel:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定使用两个属性，`target`和`source`，并使用Knockout实用方法`extend`将它们合并在一起。注意，因为我们正在将绑定应用于后代，我们必须返回`controlsDescendantBindings`标志。考虑以下视图模型：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could use the `merge` binding to bind a template against the combined properties
    of the spring and summer courses:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`merge`绑定将模板绑定到春季和夏季课程的组合属性上：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that inside the merge binding, we can use `$parent.name` to get the viewmodel's
    name. Because the child binding was created from the binding context inside the
    merge binding handler, the original hierarchy is still accessible. You can see
    a working sample of this in the `cp2-mergecontext` branch.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在合并绑定中，我们可以使用`$parent.name`来获取视图模型的名字。因为子绑定是从合并绑定处理器内部的绑定上下文中创建的，所以原始层次结构仍然可以访问。你可以在`cp2-mergecontext`分支中看到一个工作示例。
- en: Extending binding contexts
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展绑定上下文
- en: It's possible to modify the current binding context without creating a new child
    in the hierarchy. Well, sort of. Extending the binding context clones the current
    context while adding properties at the same time. Other binding handlers, siblings
    or parents, won't be affected by this sort of change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 没有在层次结构中创建新的子节点，就可以修改当前的绑定上下文。嗯，差不多吧。扩展绑定上下文会克隆当前上下文的同时添加属性。其他绑定处理器、兄弟或父节点，不会受到这种变化的影响。
- en: 'If we modify the previous example slightly, you can easily see the difference
    between extending and creating a child:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微修改前面的示例，你可以很容易地看到扩展和创建子节点之间的区别：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The only impact this has on the HTML binding is that the name no longer needs
    to call `$parent` first:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这对HTML绑定的唯一影响是名称不再需要首先调用`$parent`：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see this example in the `cp2-mergecontext2` branch.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp2-mergecontext2`分支中看到这个示例。
- en: Extending and creating child contexts are very similar as far as potential use
    cases go. It's all going to depend on what you are doing, and whether or not adding
    layers is going to help. However, there is one more way of modifying the binding
    context, and it's a whole different beast.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展和创建子上下文在潜在用途方面非常相似。这完全取决于你正在做什么，以及添加层是否会有所帮助。然而，还有另一种修改绑定上下文的方法，它是一个完全不同的概念。
- en: Setting a new $root context
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置新的$root上下文
- en: In some situations, it may be desirable to create a new binding context hierarchy
    instead of adding a layer to the existing one. This would allow a binding handler
    to provide itself, or a context that it managed, as the `$root` binding context
    to any descendant bindings.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能更希望创建一个新的绑定上下文层次结构，而不是向现有的一个添加层。这将允许绑定处理器将其自身或它管理的上下文作为`$root`绑定上下文提供给任何后代绑定。
- en: 'One use case for this would be a binding handler that used a recursive template:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的一个例子是使用递归模板的绑定处理器：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This binding uses a recursive template to show an object and all of its children,
    while allowing the original binding to define the properties that will be used
    to populate this data. The root node's name is used on every descendant node using
    the `$root` binding context property, instead of having to walk back up the tree
    by counting the current depth. This is done with the call to `ko.applyBindings`,
    which unlike the other `apply` calls, creates an entirely new binding context
    using the first argument. Normally, this call is used to start applications, and
    when no second parameter is given, it applies to the entire window. The second
    parameter scopes this new context to the supplied element. The `tree` binding
    uses `firstChild` of the current element. Even though the `controlsDescendantBindings`
    flag stops Knockout from binding descendants, the current element is still bound,
    and applying bindings to it would cause the double-binding error to occur.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定使用递归模板来显示一个对象及其所有子对象，同时允许原始绑定定义用于填充此数据的属性。根节点的名字在所有使用`$root`绑定上下文属性的子节点上使用，而不是需要通过计数当前深度回溯树。这是通过调用`ko.applyBindings`完成的，与其它`apply`调用不同，它使用第一个参数创建一个全新的绑定上下文。通常，这个调用用于启动应用程序，并且当没有提供第二个参数时，它应用于整个窗口。第二个参数将此新上下文限制在提供的元素上。`tree`绑定使用当前元素的`firstChild`。即使`controlsDescendantBindings`标志阻止Knockout绑定后代，当前元素仍然被绑定，并且对其应用绑定将导致双重绑定错误发生。
- en: 'To use this binding, a viewmodel could start out with any self-same object,
    such as a person with children:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此绑定，viewmodel 可以从任何自同对象开始，例如一个有孩子的个人：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, use the `tree` binding to show this information without having to use
    a special viewmodel to match the properties:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `tree` 绑定来显示这些信息，而无需使用一个特殊的 viewmodel 来匹配属性：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows our `tree` binding to handle any recursive structure. You can see
    an example of this binding in the `cp2-rootcontext` branch.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们的 `tree` 绑定处理任何递归结构。你可以在 `cp2-rootcontext` 分支中看到此绑定的一个示例。
- en: Containerless syntax with custom bindings
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有自定义绑定的无容器语法
- en: In the first chapter, we spoke about containerless bindings; bindings applied
    through comments that created a virtual container around their "child" nodes.
    Now that we have a good understanding of how to create our own binding handlers,
    it's time to learn how to make them containerless bindings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了无容器绑定；通过注释应用，在它们的 "子" 节点周围创建虚拟容器的绑定。现在，我们已经很好地理解了如何创建自己的绑定处理器，是时候学习如何制作无容器绑定了。
- en: 'First, we are going to make a normal binding and then look at what we need
    to do to allow it to support the virtual elements. Let''s say you want a binding
    that sorts its children elements. It would need to loop through them, check some
    property, and then rearrange the DOM so they were in order. Normally, sorting
    would be achieved by using a `foreach` binding against a sorted `observableArray`
    property, but we''re going to make a sort binding that sorts on the width of the
    DOM node, which takes into account any CSS that may have affected it. The viewmodel
    would have a hard time getting this information to determine the proper sort order,
    and HTML elements and widths don''t belong in the viewmodel logic:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个普通绑定，然后看看我们需要做什么才能让它支持虚拟元素。假设你想要一个对其子元素进行排序的绑定。它需要遍历它们，检查一些属性，然后重新排列
    DOM，使它们按顺序排列。通常，排序是通过使用 `foreach` 绑定对排序的 `observableArray` 属性进行操作来实现的，但我们将创建一个按
    DOM 节点宽度排序的排序绑定，这会考虑到可能影响它的任何 CSS。viewmodel 会很难获取这些信息以确定正确的排序顺序，并且 HTML 元素和宽度不属于
    viewmodel 逻辑：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This binding would get used with a dummy property, as we aren''t actually checking
    it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定将使用一个虚拟属性，因为我们实际上并没有检查它：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The binding starts out by grabbing all the real child nodes from the bound
    element. The `isWhitespaceNode` check is just looking for the whitespace in the
    HTML from line breaks in between tags. We want to ignore these nodes because they
    will break the `with` check:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定首先会从绑定元素中获取所有真实子节点。`isWhitespaceNode` 检查只是寻找 HTML 中的空白，这些空白来自标签之间的换行。我们想忽略这些节点，因为它们会破坏
    `with` 检查：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After grabbing the usable children from the element, it sorts them based on
    their width in the ascending order. Then, it loops through the sorted children
    and appends them to the bound element. Removal of nodes is automatic, as the DOM
    only allows a node to exist once. This produces our width-sorted list. You can
    see an example of this in the `cp2-sort` branch. It is used to sort the following
    list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在从元素中获取可用的子节点后，它会根据它们的宽度按升序对它们进行排序。然后，它会遍历排序后的子节点，并将它们追加到绑定元素中。节点的删除是自动的，因为
    DOM 只允许节点存在一次。这产生了我们的宽度排序列表。你可以在 `cp2-sort` 分支中看到这个示例。它用于对以下列表进行排序：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the width sort uses the actual width in pixels, Orville Redenbacher
    ended up after The Kellogg brothers despite them being the same number of characters.
    Unless, of course, you are using a monospaced font.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宽度排序使用实际的像素宽度，奥维尔·雷登巴赫最终排在凯洛格兄弟之后，尽管他们的字符数相同。除非，当然，你使用的是等宽字体。
- en: Using the virtual elements API
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟元素 API
- en: 'If you tried to use this binding as a virtual element binding right now, you
    would get an error telling you that it won''t work. Knockout requires a flag to
    be set before bindings can be used in this way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试将此绑定用作虚拟元素绑定，你会得到一个错误提示，告诉你这不会工作。Knockout 需要在绑定可以以这种方式使用之前设置一个标志：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This flag tells Knockout that `widthSort` will work with virtual elements,
    so Knockout won''t stop you from trying. It still won''t work though, because
    our binding is making calls to the elements children. Comment nodes don''t work
    with the normal JavaScript API, but Knockout provides a virtual element API that
    will work. These functions exist on the `ko.virtualElements` object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志告诉Knockout，`widthSort`将与虚拟元素一起工作，所以Knockout不会阻止你尝试。尽管如此，它仍然不起作用，因为我们的绑定正在调用元素的子节点。注释节点与常规JavaScript
    API不兼容，但Knockout提供了一个将工作的虚拟元素API。这些函数存在于`ko.virtualElements`对象上：
- en: '`childNodes(containerElement)`: This returns the children of `containerElement`
    as an array.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`childNodes(containerElement)`: 这个方法返回`containerElement`的子节点数组。'
- en: '`emptyNode(containerElement)`: This removes all children from `containerElement`.
    This also cleans any data attached to the node to prevent memory leaks.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyNode(containerElement)`: 这个方法从`containerElement`中移除所有子节点。这也会清理节点上附加的任何数据，以防止内存泄漏。'
- en: '`firstChild(containerElement)`: This returns the first child element, or null
    if the `containerElement` has no children.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstChild(containerElement)`: 这个方法返回第一个子元素，如果没有子节点，则返回null。'
- en: '`insertAfter(containerElement`, `nodeToInsert`, `insertAfter)`: This adds `nodeToInsert`
    to `containerElement` after the `insertAfter` node.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertAfter(containerElement, nodeToInsert, insertAfter)`: 这个方法将`nodeToInsert`添加到`containerElement`中`insertAfter`节点之后。'
- en: '`nextSibling(node)`: This returns the next sibling of the node, or null if
    none exist.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextSibling(node)`: 这个方法返回节点的下一个兄弟节点，如果没有则返回null。'
- en: '`prepend(containerElement`, `nodeToPrepend)`: This inserts `nodeToPrepend`
    as the first child of `containerElement`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepend(containerElement, nodeToPrepend)`: 这个方法将`nodeToPrepend`作为`containerElement`的第一个子节点插入。'
- en: '`setDomNodeChildren(containerElement`, `arrayOfNodes)`: This removes any children
    from `containerElement` (cleaning attached data) before inserting `arrayOfNodes`
    as children.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDomNodeChildren(containerElement, arrayOfNodes)`: 这个方法在插入`arrayOfNodes`作为子节点之前，会从`containerElement`中移除任何子节点（清理附加的数据）。'
- en: All of these functions will treat a virtual element as if it were a real DOM
    node with children. They are also compatible with regular DOM nodes, so the same
    functions will work for regular and containerless bindings.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都将虚拟元素视为一个具有子节点的真实DOM节点。它们也与常规DOM节点兼容，因此相同的函数将适用于常规和无容器绑定。
- en: 'Updating the `widthSort` binding handlers to use this API would look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将`widthSort`绑定处理器更新为使用此API的示例如下：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The only two changes are using `childNodes` to get the children for sorting,
    and `setDomNodeChildren` to set the contents instead of looping through the sorted
    children. Our binding should now support the containerless syntax.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的两个变化是使用`childNodes`来获取排序的子节点，以及使用`setDomNodeChildren`来设置内容而不是遍历排序后的子节点。现在，我们的绑定应该支持无容器语法。
- en: 'An example of the virtual elements version is in the `cp2-sort2` branch. For
    demonstration, the HTML has been updated so that the first element is not inside
    the sorting, something we couldn''t have done without virtual element support:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟元素版本的示例在`cp2-sort2`分支中。为了演示，HTML已经被更新，使得第一个元素不在排序中，这是没有虚拟元素支持我们无法做到的：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you take away one thing from all these examples, it should be that binding
    handlers are solely responsible for interaction with the DOM. In our first example,
    we made the `slideVisible` binding as an animated replacement for the standard
    `visible` binding. This change from the normal "instant" hide and show to the
    "animated" hide and show was completely decoupled by our viewmodel. This is beneficial
    because it keeps these two pieces completely separated, allowing them to develop
    and evolve independently.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从所有这些例子中提取出一个要点，那应该是绑定处理器只负责与DOM的交互。在我们的第一个例子中，我们将`slideVisible`绑定作为一个动画替换标准`visible`绑定。这种从正常的“即时”隐藏和显示到“动画”隐藏和显示的改变完全由我们的视图模型解耦。这样做的好处是它将这两部分完全分离，允许它们独立发展和演变。
- en: In this chapter, we covered simple and complex binding handlers, binding context
    management, and using the virtual elements API to support containerless bindings.
    In the next chapter, we will be looking at preprocessors for bindings and nodes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了简单和复杂的绑定处理器、绑定上下文管理以及使用虚拟元素API来支持无容器绑定。在下一章中，我们将探讨绑定和节点的预处理器。
