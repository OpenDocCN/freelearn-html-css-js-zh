["```js\nnpm install superagent –save\n\n```", "```js\nconst WEBHOOK_URL = [YOUR_WEBHOOK_URL];\n\nconst request = require('superagent');\n\nrequest\n  .post(WEBHOOK_URL)\n  .send({\n    text: 'Hello! I am an incoming Webhook bot!'\n  })\n  .end((err, res) => {\n    console.log(res);\n  });\n```", "```js\nnodemon index.js\n\n```", "```js\nrequest\n  .post(WEBHOOK_URL)\n  .send({\n    username: \"Incoming bot\",\n    channel: \"#general\",\n    icon_emoji: \":+1:\",\n    text: 'Hello! I am different from the previous bot!'\n  })\n  .end((err, res) => {\n    console.log(res);\n  });\n```", "```js\nchannel: \"@paul\"\n```", "```js\ntext: 'Hello! Here is a fun link: <http://www.github.com|Github is great!>'\n```", "```js\n'use strict';\nconst http = require('http');\n// create a simple server with node's built in http module\nhttp.createServer((req, res) => {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n\n  // get the data embedded in the POST request\n  req.on('data', (chunk) => {\n    // chunk is a buffer, so first convert it to \n    // a string and split it to make it more legible as an array\n     console.log('Body:', chunk.toString().split('&'));\n  });\n\n  // create a response\n  let response = JSON.stringify({\n    text: 'Outgoing webhook received!'\n  });\n\n  // send the response to Slack as a message\n  res.end(response);\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');\n```", "```js\nBody: [ 'token=KJcfN8xakBegb5RReelRKJng',\n  'team_id=T000001',\n  'team_domain=buildingbots',\n  'service_id=34210109492',\n  'channel_id=C0J4E5SG6',\n  'channel_name=bot-test',\n  'timestamp=1460684994.000598',\n  'user_id=U0HKKH1TR',\n  'user_name=paul',\n  'text=webhook+hi+bot%21',\n  'trigger_word=webhook' ]\n```", "```js\n/topic Sloths are great\n```", "```js\nnpm install node-wolfram –save\n\n```", "```js\n'use strict';\n\nconst http = require('http');\nconst request = require('superagent');\n\nconst WOLFRAM_TOKEN = [YOUR_WOLFRAM_API_TOKEN];\nconst SLACK_TOKEN = [YOUR_SLACK_TOKEN];\n\nconst Client = require('node-wolfram');\nconst wolfram = new Client(WOLFRAM_TOKEN);\n\n// create a simple server with node's built in http module\nhttp.createServer((req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // get the data embedded in the POST request\n    req.on('data', (chunk) => {\n      // chunk is a buffer, so first convert it \n      // to a string and split it to make it legible\n      console.log('Body:', chunk.toString().split('&'));\n\n      let bodyArray = chunk.toString().split('&');\n      let bodyObject = {};\n\n      // convert the data array to an object\n      for (let i = 0; i < bodyArray.length; i++) {\n        // convert the strings into key value pairs\n        let arr = bodyArray[i].split('=');\n        bodyObject[arr[0]] = arr[1];\n      }\n\n      // if the token doesn't match ours, abort\n      if (bodyObject.token !== SLACK_TOKEN) {\n        return res.end('Invalid token');\n      }\n\n      queryWolfram(bodyObject.text.split('+').join(' '), (err, result) => {\n        if (err) {\n          console.log(err);\n          return;\n        }\n\n        // send back the result to Slack\n        res.end(result);\n      });\n    });\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');\n\n// make sure to unescape the value so we don't get Unicode\nlet query = unescape(bodyObject.text.split('+').join(' '));\n\nqueryWolfram(query, (err, result) => {  wolfram.query(message, (err, result) => {\n    if (err) {\n      return done(err);\n    }\n\n    // if the query didn't fail, but the message wasn't understood \n    // then send a generic error message\n    if (result.queryresult.$.success === 'false') {\n      return done(null, 'Sorry, something went wrong, please try again');\n    }\n    let msg = '';\n\n    for (let i = 0; i < result.queryresult.pod.length; i++) {\n      let pod = result.queryresult.pod[i];\n      msg += pod.$.title + ': \\n';\n\n      for (let j = 0; j < pod.subpod.length; j++) {\n        let subpod = pod.subpod[j];\n\n        for (let k = 0; k <subpod.plaintext.length; k++) {\n          let text = subpod.plaintext[k];\n          msg += '\\t' + text + '\\n';\n        }\n      }\n    }\n\n    done(null, msg);\n  });\n}\n```", "```js\n/wolfram 2 x 2\n```", "```js\n/wolfram distance between earth and moon\n```", "```js\nBody: [ 'token=86oxKgPrkxrvPHpmleaP8Rbs',\n  'team_id=T00000000',\n  'team_domain=buildingbots',\n  'channel_id=C0J4E5SG6',\n  'channel_name=bot-test',\n  'user_id=U0HKKH1TR',\n  'user_name=paul',\n  'command=%2Fwolfram',\n  'text=distance+between+earth+and+moon',   'response_url=https%3A%2F%2Fhooks.slack.com%2Fcommands%2FT0HKKH1T9%2F35399194752%2Fm9mIVSHYjMdnwXWyCTYYTIZj' ]\n```", "```js\n// create a simple server with node's built in http module\nhttp.createServer((req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // get the data embedded in the POST request\n    req.on('data', (chunk) => {\n      // chunk is a buffer, so first convert it to a string \n      // and split it to make it legible\n      console.log('Body:', chunk.toString().split('&'));\n\n      let bodyArray = chunk.toString().split('&');\n      let bodyObject = {};\n\n      // convert the data array to an object\n      for (let i = 0; i < bodyArray.length; i++) {\n        // convert the strings into key value pairs\n        let arr = bodyArray[i].split('=');\n        bodyObject[arr[0]] = arr[1];\n      }\n\n      // if the token doesn't match ours, abort\n      if (bodyObject.token !== SLACK_TOKEN) {\n        return res.end('Invalid token');\n      }\n\n // send a message immediately to confirm that \n // the request was receive it's possible that the \n // query will take longer than the time Slack waits\n // for a response (3000ms), so we'll send a \n // preliminary response and then send the results later\n res.end('Calculating response, be with you shortly!');\n\n      // make sure to unescape the value so we don't get Unicode\n      let query = unescape(bodyObject.text.split('+').join(' '));\n\n      queryWolfram(query, (err, result) => {  wolfram.query(message, (err, result) => {\n        if (err) {\n          console.log(err);\n          return;\n        }\n\n // send the result from the wolfram alpha request,\n // which probably took longer than 3000ms to calculate\n request\n .post(unescape(bodyObject.response_url))\n .send({\n text: result\n })\n .end((err, res) => {\n if (err) console.log(err);\n });\n      });\n    });\n}).listen(8080, '0.0.0.0');\n```", "```js\n/wolfram distance between earth and moon\n```", "```js\n// create a simple server with node's built in http module\nhttp.createServer((req, res) => {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n```", "```js\n// get the data embedded in the POST request\nreq.on('data', (chunk) => {\n     // chunk is a buffer, so first convert it to a string \n     // and split it to make it legible\n  console.log('Body:', chunk.toString().split('&'));\n\n  let bodyArray = chunk.toString().split('&');\n  let bodyObject = {};\n\n  // convert the data array to an object\n  for (let i = 0; i < bodyArray.length; i++) {\n    // convert the strings into key value pairs\n    let arr = bodyArray[i].split('=');\n    bodyObject[arr[0]] = arr[1];\n  }\n\n  // if the token doesn't match ours, abort\n  if (bodyObject.token !== SLACK_TOKEN) {\n return res.end(JSON.stringify({\n response_type: 'ephemeral',\n text: 'Invalid token'\n }));\n}\n```", "```js\n// send a message immediately to confirm that\n// the request was receive it's possible that the\n// query will take longer than the time Slack waits\n// for a response (3000ms), so we'll send a\n// preliminary response and then send the results later\nres.end(JSON.stringify({\n response_type: 'in_channel',\n text: 'Calculating response, be with you shortly!'\n}));\n```", "```js\n// make sure to unescape the value so we don't get Unicode\nlet query = unescape(bodyObject.text.split('+').join(' '));\n\nqueryWolfram(query, (err, result) => {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n   // send the result from the wolfram alpha request,\n   // which probably took longer than 3000ms to calculate\n   request\n     .post(unescape(bodyObject.response_url))\n .send({\n response_type: 'in_channel',\n text: result\n })\n     .end((err, res) => {\n       if (err) console.log(err);\n     });\n    });\n  });\n}).listen(8080, '0.0.0.0');\n```", "```js\nfunction queryWolfram(message, done) {\n  wolfram.query(message, (err, result) => {\n    if (err) {\n      return done(err);\n    }\n\n    // if the query didn't fail, but the message wasn't understood\n    // then send a generic error message\n    if (result.queryresult.$.success === 'false') {\n      return done(null, 'Sorry, something went wrong, please try again');\n    }\n\n let msg = [];\n\n    for (let i = 0; i < result.queryresult.pod.length; i++) {\n      let pod = result.queryresult.pod[i];\n\n      // print the title in bold\n msg.push(`*${pod.$.title}:*\\n`);\n\n      for (let j = 0; j < pod.subpod.length; j++) {\n        let subpod = pod.subpod[j];\n\n        for (let k = 0; k <subpod.plaintext.length; k++) {\n          let text = subpod.plaintext[k];\n if (text) {\n // add a tab to the beginning\n msg.push('\\t' + text + '\\n');\n } else {\n // text is empty, so get rid of the title as well\n msg.pop();\n }\n        }\n      }\n    }\n\n    // join the msg array together into a string\n    done(null, msg.join(''));\n  });\n}\n```"]