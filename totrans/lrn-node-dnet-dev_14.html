<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Node.js and Beyond</h1></div></div></div><p>So far, this book has shown you how to work with JavaScript and Node.js in a variety of use cases. In this chapter, we'll look at how the JavaScript ecosystem is continuing to evolve. We'll also see how the .NET and JavaScript ecosystems influence each other and how to integrate them within a single project.</p><p>While the chapters so far have aimed to start you on your path into Node.js and JavaScript, this chapter aims to map out the remaining territory. Each of the preceding chapters has provided in-depth step-by-step coverage of a single topic. This chapter will cover a much broader range of topics, with links to resources for further reading.</p><p>In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem">Understand how Node.js and JavaScript are continuing to evolve</li><li class="listitem">Introduce some of the new and upcoming JavaScript language features</li><li class="listitem">Look at some alternative programming languages for Node.js and the web</li><li class="listitem">Consider principles from Node.js that can apply to .NET programming</li><li class="listitem">See how to integrate Node.js with .NET</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec74"/>Understanding Node.js versioning</h1></div></div></div><p>As mentioned in <a class="link" title="Chapter 1. Why Node.js?" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <em>Why Node.js?</em>, the release of Node.js v4 in 2015 shows the platform <a id="id602" class="indexterm"/>coming to maturity. If you've used Node.js before the end of 2015, you would have seen version numbers such as v0.8.0 or v0.12.0. So why the leap to v4.0.0?</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec88"/>A brief history of Node.js</h2></div></div></div><p>Node.js is an <a id="id603" class="indexterm"/>open-source project with a corporate sponsor, Joyent. This means that a single company has a lot of influence over the direction of Node.js, but anyone can create their own fork of the source code. This is exactly what happened at the end of 2014. A group of major contributors to Node.js split the project to create a new <a id="id604" class="indexterm"/>fork, named <strong>io.js</strong>. A few key properties of io.js were:</p><div><ul class="itemizedlist"><li class="listitem">A more<a id="id605" class="indexterm"/> open governance model</li><li class="listitem">A more regular release cycle, keeping more up-to-date with the underlying V8 engine, to take advantage of performance improvements and newer JavaScript language features</li><li class="listitem">A move to semantic versioning (see <a class="ulink" href="http://semver.org/">http://semver.org/</a>), resulting in major <a id="id606" class="indexterm"/>version numbers increasing more quickly</li></ul></div><p>Over the course of 2015, the Node.js project reshaped itself to take on the above properties and align with io.js. In September 2015, the release of Node.js v4 brought the two projects back together under a new governance model. Node.js v4 supersedes (and merges) both Node.js v0.12 and io.js v3.3. You can read more about the new governance model<a id="id607" class="indexterm"/> at <a class="ulink" href="https://nodejs.org/en/about/governance/">https://nodejs.org/en/about/governance/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec89"/>Introducing the Node.js LTS schedule</h2></div></div></div><p>The timetable for <a id="id608" class="indexterm"/>Node.js releases now follows a regular schedule. A new <a id="id609" class="indexterm"/>stable release occurs every 6 months. Each stable branch receives fixes as well as new features that reach maturity. The lifetime of stable releases alternates as follows (as shown in the following chart):</p><div><ul class="itemizedlist"><li class="listitem">Odd-numbered branches live for 9 months</li><li class="listitem">Even-numbered <a id="id610" class="indexterm"/>branches enter <strong>long-term support</strong> (<strong>LTS</strong>) after 6 months, receiving bug fixes but no new features</li><li class="listitem">Long-term support lasts for 30 months, with the final 12 months being maintenance mode (critical bug fixes only)</li></ul></div><div><img src="img/image00230.jpeg" alt="Introducing the Node.js LTS schedule"/></div><p style="clear:both; height: 1em;"> </p><p>You can <a id="id611" class="indexterm"/>find more<a id="id612" class="indexterm"/> details of the LTS model at <a class="ulink" href="https://github.com/nodejs/LTS">https://github.com/nodejs/LTS</a>.</p><p>The LTS model<a id="id613" class="indexterm"/> allows you to have confidence in Node.js as a platform for your application. The code in this book targets Node.js v6, the current stable release at the time of publication. This version will be in LTS through to April 2019, some three years later.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec75"/>Understanding ECMAScript versioning</h1></div></div></div><p>ECMAScript is<a id="id614" class="indexterm"/> the formal standard for the JavaScript language. The first three iterations of the language occurred between 1997 and 1999. A 10-year gap followed before ECMAScript 5 in December 2009. ES5 introduced few new features and focused on cleaning up the language. It introduced strict modes and addressed various inconsistencies, flaws, or gotchas in earlier versions.</p><p>2015 saw a major change to the language and to the versioning approach. ECMAScript 2015 (formerly ECMAScript 6) introduced many significant new language features. These include classes, <code class="literal">let</code>/<code class="literal">const</code> keywords and block-scoping, arrow functions, and native promises. In the rest of this chapter, we'll look at some of the other significant new features in ES2015.</p><p>The name change from ES6 to ES2015 indicates a new yearly versioning model. From 2015 onwards, there will be a new version of the ECMAScript standard every year. Planned features that aren't quite ready for release will wait until the following year. For this reason, ECMAScript 2016 is a small release with only a couple of new features.</p><p>Note that <a id="id615" class="indexterm"/>ECMAScript is the standard and it takes time for new features to be implemented. Indeed, some ES2015 features are still missing from the JavaScript engines in popular browsers. Note though that the major browser vendors are part of the ECMAScript standards process. So browsers, and Chrome's V8 engine (used by Node.js) in particular, should generally not lag too far behind the latest standard.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec76"/>Exploring ECMAScript 2015</h1></div></div></div><p>We have already<a id="id616" class="indexterm"/> used many of the new features of ES2015 throughout this book, such as arrow functions, template strings, and promises. We have also already seen ES2015's syntax for classes in <a class="link" title="Chapter 3. A JavaScript Primer" href="part0022.xhtml#aid-KVCC1">Chapter 3</a>, <em>A JavaScript Primer</em>.</p><p>ES2015 is a major update to the language, including many new features and syntax improvements. This section will cover some of the other useful improvements that we haven't seen so far in the book. For complete coverage of everything new in ES2015, see the <a id="id617" class="indexterm"/>excellent <em>Exploring ES6</em>, available at <a class="ulink" href="http://exploringjs.com/es6/">http://exploringjs.com/es6/</a>.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec90"/>Understanding ES2015 modules</h2></div></div></div><p>As mentioned in <a id="id618" class="indexterm"/>previous chapters, ES2015 introduces a new <a id="id619" class="indexterm"/>module specification. Recall from <a class="link" title="Chapter 4. Introducing Node.js Modules" href="part0025.xhtml#aid-NQU21">Chapter 4</a>, <em>Introducing Node.js Modules</em>, that each module system provides the following:</p><div><ul class="itemizedlist"><li class="listitem">A way of declaring a module with a name and its own scope</li><li class="listitem">A way of defining functionality provided by the module</li><li class="listitem">A way of importing a module into another script</li></ul></div><p>Modules are scoped to their containing file, as in CommonJS. Modules provide functionality via a new <code class="literal">export</code> keyword. Prefixing an expression with <code class="literal">export</code> is equivalent to making it a property of the <code class="literal">module.exports</code> variable in CommonJS. A special <code class="literal">default export</code> is equivalent to assigning the value of <code class="literal">module.exports</code> itself. Modules are imported using an <code class="literal">import</code> keyword rather than a special <code class="literal">require</code> function. There is one additional restriction: imports must come at the top of the script, before any conditional blocks or other logic.</p><p>These might seem like small syntax changes, but they have an important implication. Because defining and importing modules doesn't involve assignment and method calls, the structure of dependencies between modules is static. This allows the JavaScript engine to optimize loading of modules (particularly important in the browser). It also means that cyclic dependencies between modules can be resolved.</p><p>You can<a id="id620" class="indexterm"/> find <a id="id621" class="indexterm"/>out more <a id="id622" class="indexterm"/>about the new ES2015 module syntax at <a class="ulink" href="http://jsmodules.io/">http://jsmodules.io/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec91"/>Using syntax improvements from ES2015</h2></div></div></div><p>In this section <a id="id623" class="indexterm"/>we'll look at some of the new syntax features in ES2015 that we haven't used in the book so far. These are all available in the latest JavaScript engines, including Node.js v6.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec22"/>The for... of loop</h3></div></div></div><p>Let's say we<a id="id624" class="indexterm"/> have an array defined as follows:</p><div><pre class="programlisting">let myArray = [1, 2, 3];</pre></div><p>Let's also say that <a id="id625" class="indexterm"/>another library has added a helper function to all arrays. Perhaps something like our <code class="literal">flatMap</code> function from <a class="link" title="Chapter 13. Creating JavaScript Packages" href="part0076.xhtml#aid-28FAO2">Chapter 13</a>, <em>Creating JavaScript Packages</em>.</p><div><pre class="programlisting">Array.prototype.flatMap = function(callback) {
    return Array.prototype.concat.apply([], this.map(callback));
};</pre></div><p>If you wanted to iterate through all the members of an array, you might be tempted to use JavaScript's <code class="literal">for... in</code> construct as follows:</p><div><pre class="programlisting">for (let i in myArray) {
    console.log(myArray[i]);
}</pre></div><p>This doesn't work very well though, as it includes properties on the array's prototype and prints out the <code class="literal">flatMap</code> function as well as the elements in the array. This is a common problem with <code class="literal">for... in</code> loops, when used with objects as well as with arrays. The standard way to avoid it is by skipping prototype properties as follows:</p><div><pre class="programlisting">for (let i in myArray) {
    if (myArray.hasOwnProperty(i)) {
        console.log(myArray[i]);
    }
}</pre></div><p>This prints out just the elements of the array, as we want. A similar loop could also be used to print the properties of an object, without accidentally attempting to print out functions from the prototype (which may have been added by a third-party library).</p><p>Note that <code class="literal">for... in</code> also doesn't technically guarantee the order in which it iterates through the keys of an object. This means it's not really the best thing to use with arrays, where we expect a specific order. That's why the standard way to iterate through arrays is using a plain old <code class="literal">for</code> loop, as follows:</p><div><pre class="programlisting">for (let i = 0; i &lt; myArray.length; ++i) {
    console.log(myArray[i]);
}</pre></div><p>ES2015 addresses these issues with a new <code class="literal">for... of</code> loop, which looks like this:</p><div><pre class="programlisting">for (let value of myArray) {
    console.log(value);
}</pre></div><p>The syntax is <a id="id626" class="indexterm"/>very similar to <code class="literal">for... in</code> loops. However, you do not <a id="id627" class="indexterm"/>need to filter out prototype members as these are excluded. It can be used with any iterable objects (such as arrays) and will follow the natural ordering of the iterable. In short, <code class="literal">for... of</code> loops are like <code class="literal">for... in</code> loops but without any nasty surprises.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec23"/>The spread operator and rest parameters</h3></div></div></div><p>The <strong>spread operator</strong> allows<a id="id628" class="indexterm"/> you to treat arrays as if they were a <a id="id629" class="indexterm"/>sequence of values. For example, to<a id="id630" class="indexterm"/> call a function:</p><div><pre class="programlisting">let myArray = [1, 2, 3];
let myFunc = (foo, bar, baz) =&gt; (foo + bar) * baz;
console.log(myFunc(...values)); // Prints 9</pre></div><p>You can also use the spread operator within array literals, for example:</p><div><pre class="programlisting">let subClauses = ['2a', '2b', '2c'];
let clauses = ['1', '2', ...subClauses, '3'];
    // Equivalent to ['1', '2', '2a', '2b', '2c', '3']</pre></div><p>The <strong>rest parameter</strong> syntax <a id="id631" class="indexterm"/>serves the opposite purpose, turning a sequence of values into an array. This is similar to the <code class="literal">params</code> keyword in C# or <code class="literal">varargs</code> in Java. For example:</p><div><pre class="programlisting">function foldLeft(combine, initial, ...values) {
    let result = initial;
    for (let value of values) {
       result = combine(result, value);
    }
    return result;
}
console.log(foldLeft((x, y) =&gt; x+y, 0, 1, 2, 3, 4)); // Prints 10</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec24"/>Destructuring assignment</h3></div></div></div><p>
<strong>Destructuring</strong> allows<a id="id632" class="indexterm"/> you to use structuring syntax to assign multiple variables together. For example, you can assign variables using the array literal syntax to destructure arrays:</p><div><pre class="programlisting">let foo, bar;
[foo, bar] = [1, 2]; // Equivalent to foo = 1, bar = 2</pre></div><p>You can also combine destructuring with the spread operator:</p><div><pre class="programlisting">[foo, bar, ...rest] = [1, 2, 3, 4, 5];
    // Equivalent to foo = 1, bar = 2, rest = [3, 4, 5]</pre></div><p>Finally, you can use destructuring with the object literal syntax:</p><div><pre class="programlisting">{ foo, bar } = { foo: 1, bar: 2 }; // Equivalent to foo=1, bar=2</pre></div><p>Destructuring is particularly useful for dealing with complex return values. Imagine if any of the expressions on the right-hand side of the equals sign in the above examples were actually function calls.</p><p>Destructuring is also useful for performing multiple assignments in a single statement. For example:</p><div><pre class="programlisting">[foo, bar] = [bar, foo]; // Swap foo and bar in place
[previous, current] = [current, previous + current];
    // Calculation step for a Fibonacci sequence</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec92"/>Introducing generators</h2></div></div></div><p>ES2016 introduces <strong>generator functions</strong> and the <code class="literal">yield</code> keyword. You may already be familiar with<a id="id633" class="indexterm"/> the <code class="literal">yield</code> keyword in C#. Methods that<a id="id634" class="indexterm"/> return <code class="literal">IEnumerable</code>/<code class="literal">IEnumerator</code> can include the <code class="literal">yield</code> keyword to return one element at a time, suspending execution of the method until the next value is requested. You can do the same with generator functions in JavaScript. The following example is a JavaScript implementation of one of the examples from the MSDN documentation of C#'s <code class="literal">yield</code>. It prints the first eight powers of 2 (note the asterisk after the function keyword, which denotes this as a generator function):</p><div><pre class="programlisting">'use strict';
function* powers(number, exponent) {
    let result = 1;
    for (let i = 0; i &lt; exponent; ++i) {
        result = result * number;
        yield result;
    }
}
for (let i of powers(2, 8)) {
    console.log(i);
}</pre></div><p>Note that <code class="literal">for... of</code> loops work with generators. The above loop is equivalent to the following code:</p><div><pre class="programlisting">let generator = powers(2, 8);
let current = generator.next();
while (!current.done) {
    console.log(current.value);
    current = generator.next();
}</pre></div><p>You can see that generators are very similar to the <code class="literal">IEnumerator</code> interface in C#. Note that they are slightly more powerful than this though. We can also pass a value <em>into</em> a generator's <code class="literal">next</code> method to allow it to be used when execution continues in the generator function. The <a id="id635" class="indexterm"/>following dummy example illustrates<a id="id636" class="indexterm"/> this:</p><div><pre class="programlisting">'use strict';
function* generator() {
    let received = yield 1;
    console.log(received);
    return 3;    
}
let instance = generator();
let first = instance.next();
console.log(first);
let last = instance.next(2);
console.log(last);</pre></div><p>Running the previous example produces the following output:</p><div><pre class="programlisting"><strong>&gt; { value: 1, done: false }</strong>
<strong>&gt; 2</strong>
<strong>&gt; { value: 3, done: true }</strong>
</pre></div><p>This two-way communication makes generators much more than just <code class="literal">IEnumerator</code> for JavaScript. They are a <a id="id637" class="indexterm"/>powerful control flow mechanism, especially when combined with promises. See <a class="ulink" href="https://www.promisejs.org/generators/">https://www.promisejs.org/generators/</a> for a derivation of C#-like <code class="literal">async</code>/<code class="literal">await</code> functionality using generators and promises (with <code class="literal">yield</code> taking the place of C#'s <code class="literal">await</code> keyword). It's also worth noting that <code class="literal">async</code> functions are planned for a future version of ECMAScript (probably ES2017) and will work in a similar way. In the meantime, you can achieve a similar programming model using the <code class="literal">Promise.coroutine</code> method provided by the <a id="id638" class="indexterm"/>bluebird library, which is based on generators. See <a class="ulink" href="http://bluebirdjs.com/docs/api/promise.coroutine.html">http://bluebirdjs.com/docs/api/promise.coroutine.html</a> for details.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec77"/>Introducing ECMAScript 2016</h1></div></div></div><p>As mentioned <a id="id639" class="indexterm"/>earlier in this chapter, ECMAScript 2016 is a small release with only a couple of new features. These are an <code class="literal">includes</code> method for arrays and the exponentation operator <code class="literal">**</code>.</p><p>You can write <code class="literal">myArray.includes(value)</code> instead of <code class="literal">myArray.indexOf(value) !== -1</code>. Note that these expressions are not quite equivalent. You can use <code class="literal">includes</code> to check for the value <code class="literal">NaN</code> within an array, which you can't do with <code class="literal">indexOf</code>.</p><p>The exponential operator allows you to rewrite <code class="literal">Math.pow(coefficient, exponent)</code> as <code class="literal">coefficient ** exponent</code>.</p><p>You can also combine it with an assignment, as in <code class="literal">myVariable **= 2</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec78"/>Going beyond JavaScript</h1></div></div></div><p>If you want to<a id="id640" class="indexterm"/> target browsers or Node.js, JavaScript is the only language natively supported by these environments. This is different to VM-based environments like the .NET runtime and the JVM, which support multiple languages.</p><p>The .NET runtime supports C#, F#, VB.NET, and others. The JVM supports Java, Scala, Clojure, and others. These languages work by compiling down to an assembly language for the environment's VM. This is the Common Intermediate Language in .NET or Java bytecode in the case of the JVM.</p><p>There is a reason why programmers don't all write CIL or Java bytecode though. These are low-level machine languages and much less human-friendly than C#, Java,  and so on. In general, higher-level languages can support better productivity, as well as safety (for example, through type systems and memory management).</p><p>There is also a reason why .NET programmers don't always use C# and JVM programmers don't always use Java. A range of languages can serve different use cases better. It can also just be a matter of personal taste for the semantics of a particular language.</p><p>JavaScript has<a id="id641" class="indexterm"/> been called the <em>Assembly Language for the Web</em> (<a class="ulink" href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>). While JavaScript is not a low-level or machine language, it is a common language for its platform. Like CIL and Java bytecode, it can serve as a compile target for other languages. And, like .NET and the JVM, there is an appetite amongst developers for a variety of languages on the same platform.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec93"/>Exploring compile-to-JavaScript languages</h2></div></div></div><p>There are<a id="id642" class="indexterm"/> several languages that support web <a id="id643" class="indexterm"/>and Node.js development by compiling down to JavaScript. We'll look at a few of the more prominent of these languages in this section.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec25"/>TypeScript</h3></div></div></div><p>The TypeScript <a id="id644" class="indexterm"/>language is developed and <a id="id645" class="indexterm"/>supported by Microsoft. Its key aim is to include features that aid large-scale application development. TypeScript can be compiled down to ES2016, ES5, or even ES3. So it works in any modern JavaScript environment.</p><p>TypeScript is based closely on the JavaScript syntax. It is a superset of JavaScript, so you can write ordinary JavaScript and gradually use TypeScript features more as you learn it. TypeScript also tries to match the syntax of upcoming JavaScript features where possible. This allows developers to start using new JavaScript features earlier.</p><p>The most important TypeScript features aid large-scale application development. TypeScript has had classes and modules for some time, to help with structuring code. As the name suggests, TypeScript also adds type annotations and type inference. It also adds new ways of defining and specifying types, including enums, generic types, and interfaces. This makes for a safer language as the compiler can catch more errors. It also lets IDEs offer features like code completion (namely, Intellisense) and better source code navigation.</p><p>Finally, TypeScript makes it possible to specify type definitions for libraries written in plain<a id="id646" class="indexterm"/> JavaScript. Type definitions for many third-party libraries can be found at <a class="ulink" href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>. These provide type checking and code completion when working with library code too.</p><p>Here's an example of our <code class="literal">flatMap</code> function from the previous chapter written with type annotations:</p><div><pre class="programlisting">function flatMap&lt;T, R&gt;(
    source:T[],
    callback:(T)=&gt;R[]): R[] {
    return Array.prototype.concat.apply([],
        source.map(callback));
}
let result = flatMap([1, 2, 3], (i:number) =&gt; [i, i + 0.5]);
console.log(result); // Prints [1, 1.5, 2, 2.5, 3, 3.5]</pre></div><p>The syntax for generics may be familiar from C#. Type annotations follow the expression or parameter, separated by a colon. We could specify the generic type when we call the function too, but in this case it can be inferred. Note that our method has two generic types, as our callback could map to an array of a different element type. The TypeScript compiler will infer the type of <code class="literal">result</code> as <code class="literal">number[]</code>. Note that this inference actually takes a few steps:</p><div><ul class="itemizedlist"><li class="listitem">We specify that the <code class="literal">callback</code> parameter <code class="literal">i</code> has a type <code class="literal">number</code></li><li class="listitem">Therefore, the expressions <code class="literal">i</code> and <code class="literal">i + 0.5</code> also both have a type <code class="literal">number</code></li><li class="listitem">Therefore, the result type of our <code class="literal">callback</code> is <code class="literal">number[]</code></li><li class="listitem">Therefore, the argument for the type parameter <code class="literal">R</code> must be <code class="literal">number</code></li></ul></div><p>If we did not<a id="id647" class="indexterm"/> specify the type of <code class="literal">i</code>, then the compiler <a id="id648" class="indexterm"/>would only infer the type of <code class="literal">result</code> as <code class="literal">any[]</code>, that is an array, but of an unspecified element type.</p><p>You can learn more <a id="id649" class="indexterm"/>about TypeScript at <a class="ulink" href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>.</p><div><h3 class="title"><a id="tip16"/>Tip</h3><p>If you're more familiar with Java than .NET, and especially if you're familiar with the<a id="id650" class="indexterm"/> Eclipse IDE in particular, you may also be interested in N4JS (<a class="ulink" href="http://numberfour.github.io/n4js/">http://numberfour.github.io/n4js/</a>). This language has similar goals to TypeScript, but is inspired by Java and has an IDE based on Eclipse.</p></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec26"/>CoffeeScript</h3></div></div></div><p>CoffeeScript was <a id="id651" class="indexterm"/>one of the earliest successful <a id="id652" class="indexterm"/>compile-to-JavaScript languages. CoffeeScript streamlines the syntax of JavaScript and adds features for writing more terse and expressive code.</p><p>CoffeeScript is a good example of when taste might influence language choice. Developers may find CoffeeScript more readable and/or easier to write. Ruby or Python programmers may be particularly comfortable with CoffeeScript. They'll find its syntax and many of its language features familiar.</p><p>Many features from CoffeeScript have subsequently appeared in ES2015, for example arrow functions, destructuring, and the splat/spread operator. Unlike TypeScript, CoffeeScript does not attempt to match the syntax of JavaScript, neither for current nor upcoming features. It does however offer seamless interoperability with JavaScript code.</p><p>Comprehensions are one of CoffeeScript's most expressive features and do not appear in ES2015. You may be familiar with comprehensions from Python. They are also a little like LINQ in C#, in that they allow you to express operations on lists without using loops. The following example prints the squares of even numbers, first in JavaScript and then as a one-liner in<a id="id653" class="indexterm"/> CoffeeScript.<a id="id654" class="indexterm"/> As <code class="literal">squares.js</code>:</p><div><pre class="programlisting">var i, n;
for (n = i = 1; i &lt;= 10; n = ++i) {
    if (n % 2 === 0) {
        console.log(n * n);
    }
}</pre></div><p>As <code class="literal">squares.coffee</code>:</p><div><pre class="programlisting">console.log n*n for n in [1..10] when n%2 is 0</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec27"/>And beyond...</h3></div></div></div><p>TypeScript and CoffeeScript are specifically designed to target JavaScript. There are many other projects in existence that allow more general languages to compile JavaScript. Note that not all such projects are mature or well-maintained. Languages whose own project team supports and maintains compilation to JavaScript tend to be a safer choice. Both <a id="id655" class="indexterm"/>Dart (<a class="ulink" href="https://www.dartlang.org/">https://www.dartlang.org/</a>) and Clojure (<a class="ulink" href="http://clojure.org/">http://clojure.org/</a>) provide<a id="id656" class="indexterm"/> first-class support for compiling to JavaScript.</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec94"/>Introducing a true assembly language for the web</h2></div></div></div><p>As discussed<a id="id657" class="indexterm"/> above, while JavaScript can be a common compile<a id="id658" class="indexterm"/> target for the web and Node.js, it is not a true assembly language. It is a high-level human-readable language, rather than an optimized machine language. There are projects to introduce just such a language into the web environment though. This means defining an assembly language implemented by all browsers, including Chrome's V8 engine and therefore Node.js.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec28"/>Understanding asm.js</h3></div></div></div><p>The first attempt <a id="id659" class="indexterm"/>at such a language is asm.js (<a class="ulink" href="http://asmjs.org/">http://asmjs.org/</a>), developed <a id="id660" class="indexterm"/>by Mozilla. This is a strict subset of<a id="id661" class="indexterm"/> JavaScript, which means it can run on any browser. But browsers that support asm.js can precompile it and heavily optimize its execution. Demanding applications such as 3D games can be recompiled to target asm.js and run seamlessly in-browser. The first environment with full support for asm.js is Mozilla's own Firefox browser. It will also be supported in Microsoft's new Edge browser. The V8 engine used by Chrome (and Node.js) does not yet pre-compile asm.js, but V8 does make some optimizations to allow asm.js to run much faster than if interpreted as plain JavaScript.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec29"/>Understanding WebAssembly</h3></div></div></div><p>WebAssembly (<a class="ulink" href="https://webassembly.github.io/">https://webassembly.github.io/</a>) is a new standard for a true assembly<a id="id662" class="indexterm"/> language for the web. Unlike asm.js it is not a subset <a id="id663" class="indexterm"/>of JavaScript and won't run in today's browsers. It defines <a id="id664" class="indexterm"/>a new assembly language more like CIL or Java bytecode. It is developed by the W3C standards body, with input from the major browser vendors. There are early implementations of WebAssembly in preview releases of Mozilla Firefox, Google Chrome, and Microsoft Edge.</p><p>As an application developer, you do not need to be able to write WebAssembly any more than you need to write CIL or Java bytecode. These are all low-level languages to act as compilation targets. In future, WebAssembly may replace JavaScript as the common compile target for the web (and Node.js). Other languages, including JavaScript itself, may all compile to WebAssembly.</p><p>This would mean that JavaScript would no longer be the only native language for the web and Node.js. But JavaScript will almost certainly remain the default development language for these environments, just as C# and Java are for their respective environments. Knowledge of the execution model of Node.js will still be relevant in any language and JavaScript will still be the most natural fit for this execution model. Knowledge of JavaScript will also be important for working with the many well-established libraries based on it.</p><p>There would be other benefits to JavaScript from WebAssembly. Interoperation between JavaScript and other languages will become easier. There will be more options for implementing performance-critical code. New versions of JavaScript will be able to roll out more quickly (as a single JavaScript to WebAssembly compiler can target all browser engines).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec79"/>JavaScript and ASP.NET</h1></div></div></div><p>On the server<a id="id665" class="indexterm"/> side, we don't need to wait for WebAssembly<a id="id666" class="indexterm"/> to mature in order to work with Node.js and .NET together. There is already some convergence between programming on these two platforms and support for interoperability between them.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec95"/>Exploring .NET Core</h2></div></div></div><p>The next <a id="id667" class="indexterm"/>version of NET, called .NET Core, makes some major changes<a id="id668" class="indexterm"/> to the platform. Some of these changes might seem familiar if you've spent some time working with Node.js. This is not just a coincidence. Microsoft are incorporating good ideas that have worked in Node.js and elsewhere into their ecosystem.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec30"/>Defining project structure in .NET Core</h3></div></div></div><p>.NET Core<a id="id669" class="indexterm"/> separates the programming platform from the IDE. Microsoft still recommends using Visual Studio, but have made it much easier to use <a id="id670" class="indexterm"/>other editors. For example, the OmniSharp project (<a class="ulink" href="http://www.omnisharp.net/">http://www.omnisharp.net/</a>) supports development in other editors, providing features such as Intellisense outside of Visual Studio.</p><p>One aspect of this change is simplifying the use of <code class="literal">.csproj</code> files. In previous versions of .NET, these large XML files were the canonical description of each C# project. They included important things like compilation options, target platforms, build steps, and dependencies. They were mainly generated by Visual Studio, difficult to edit by hand, and often particularly awkward to merge in source control. To satisfy Visual Studio, they also needed to list every single source file in the project.</p><p>Many of these drawbacks are addressed in .NET Core. New tools make it much easier to edit <code class="literal">.csproj</code> files from the command line. A project's sources are just the files under its parent folder (not listed in <code class="literal">.csproj</code> or any other metadata file). Dependencies are declared separately in a more lightweight JSON-based file.</p><p>Many of these improvements are inspired by programming platforms like Node.js. In fact, early release candidates for .NET Core removed the need for <code class="literal">.csproj</code> files entirely and introduced <code class="literal">project.json</code> files (just like in Node.js) for defining projects. Although .NET Core ultimately uses <code class="literal">.csproj</code> files (for continued compatibility with MSBuild), it aims to keep those aspects of more lightweight approaches that are most important to developers.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec31"/>Managing dependencies in .NET Core</h3></div></div></div><p>The NuGet package manager has been part of the .NET ecosystem for several years. NuGet <a id="id671" class="indexterm"/>becomes even more important in .NET Core. The <a id="id672" class="indexterm"/>framework and runtime themselves are<a id="id673" class="indexterm"/> distributed as NuGet packages. Dependencies are specified as NuGet package names (and versions) rather than DLL paths. NuGet packages can also be a useful unit of deployment for your own projects.</p><p>Just like with Node.js, you can checkout the source code of one of your dependencies to a local folder and reference it there. This allows you to tinker with open source libraries and debug them as part of your program.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec32"/>Building web applications in ASP.NET Core</h3></div></div></div><p>ASP.NET Core <a id="id674" class="indexterm"/>consolidates ASP.NET MVC and <a id="id675" class="indexterm"/>WebAPI into a single framework. It also brings OWIN to the fore as the standard abstraction for implementing web applications.</p><p>OWIN simply<a id="id676" class="indexterm"/> defines a standard for passing request and response objects between a host and an application. Although OWIN has been around for a while and has its own history, this is a similar abstraction to the <code class="literal">http.createServer</code> method in Node.js. You <a id="id677" class="indexterm"/>can read more about OWIN at <a class="ulink" href="https://docs.asp.net/en/latest/fundamentals/owin.html">https://docs.asp.net/en/latest/fundamentals/owin.html</a>.</p><p>Related to <a id="id678" class="indexterm"/>this, ASP.NET also uses middleware as <a id="id679" class="indexterm"/>the standard building block for web <a id="id680" class="indexterm"/>applications. Again, although middleware in .NET has its own history, the abstraction is very similar to middleware in Express. Applications set up a pipeline of middleware, with each having access to the request, response, and the next handler in the chain. Built-in middleware is available for cross-cutting concerns <a id="id681" class="indexterm"/>such as authentication, sessions, and routing. You can read more about middleware at <a class="ulink" href="https://docs.asp.net/en/latest/fundamentals/middleware.html">https://docs.asp.net/en/latest/fundamentals/middleware.html</a>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec96"/>Integration with JavaScript</h2></div></div></div><p>Visual Studio has<a id="id682" class="indexterm"/> provided good support for client-side <a id="id683" class="indexterm"/>JavaScript development for several years. Microsoft have improved and updated this in the latest versions of ASP.NET and Visual Studio: for example, by including better integration with task runners such as <a id="id684" class="indexterm"/>Gulp and Grunt. You can read more about client-side JavaScript support at <a class="ulink" href="https://docs.asp.net/en/latest/client-side/index.html">https://docs.asp.net/en/latest/client-side/index.html</a>.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec33"/>Server-side JavaScript integration with .NET</h3></div></div></div><p>The Edge.js project (<a class="ulink" href="https://github.com/tjanczuk/edge">https://github.com/tjanczuk/edge</a>) allows Node.js and .NET to run within the <a id="id685" class="indexterm"/>same process. It also defines a very simple way for marshalling method calls between the two. This is much faster than marshalling calls out-of-process (for example, via an HTTP call to a process on the local machine).</p><p>Edge.js <a id="id686" class="indexterm"/>allows you to take the best of .NET and <a id="id687" class="indexterm"/>Node.js. Perhaps you want to use Node.js to put a web interface on top of your existing .NET business logic. Or perhaps you're using Node.js for rapid development of most of your application, but have a particularly CPU-intensive operation that would be easier to optimize in .NET.</p><p>Making calls from Node.js to .NET (or vice versa) is very simple. For example, if we have the following .NET class:</p><div><pre class="programlisting">using System;
using System.Threading.Tasks;
namespace DeepThought
{
  public class UltimateQuestion
  {
    public Task&lt;Object&gt; GetAnswer(object input) {
      var result = new
      {
        description =
          "Answer to The Ultimate Question of " + input,
        value = 42
      };
      return Task.FromResult&lt;object&gt;(result);
    }
  }
}</pre></div><p>We can use it<a id="id688" class="indexterm"/> from JavaScript as follows (after running <code class="literal">npm install edge</code>):</p><div><pre class="programlisting">'use strict';
const edge = require('edge');
let getAnswer = edge.func({
    assemblyFile: 'bin\\Debug\\DeepThought.dll',
    typeName: 'DeepThought.UltimateQuestion',
    methodName: 'GetAnswer'
});
getAnswer('Life, the Universe, and Everything', (error, result) =&gt; {
    console.log(result);
});</pre></div><p>Compiling <a id="id689" class="indexterm"/>our C# code and running our JavaScript file results in the following output:</p><div><pre class="programlisting"><strong>&gt; node index.js</strong>
<strong>&gt; { description: 'Answer to The Ultimate Question of Life, the Universe, and Everything', value: 42 }</strong>
</pre></div><p>You can find a <a id="id690" class="indexterm"/>good introduction to Edge.js at <a class="ulink" href="http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx">http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx</a>.</p><p>Finally, recall that the OWIN standard and ASP.NET middleware are quite similar to the corresponding concepts in JavaScript. Edge.js makes it easy to include a .NET OWIN application as <a id="id691" class="indexterm"/>middleware in a Node.js Express application. See the <code class="literal">connect-owin</code> project at <a class="ulink" href="https://github.com/bbaia/connect-owin">https://github.com/bbaia/connect-owin</a> for details.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec80"/>Summary</h1></div></div></div><p>In this chapter, we have seen how Node.js and JavaScript's new release cycles bring stability to the platform. We have introduced some of the new and upcoming features of JavaScript. We have explored current and future alternative languages for the JavaScript environment. We have seen some of the commonalities between .NET and Node.js and how to use these technologies together.</p><p>I hope this book has allowed you to get up-and-running with Node.js and given you an appetite to learn more. The resources in this chapter will help you take the next step on your journey with JavaScript and Node.js.</p></div></body></html>