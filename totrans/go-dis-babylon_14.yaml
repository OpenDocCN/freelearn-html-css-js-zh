- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Extended Topics, Extended
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题，扩展
- en: This is a chapter about endings, but it is also a chapter about beginnings.
    Our journey together on this long haul may be approaching its destination, but
    this is just the beginning of your personal journey with Babylon.js. In this chapter,
    we abandon any pretense of linear or sequential progress, and instead, we will
    be bouncing between several disparate topics that will each provide individual
    jumping-off points to help you go the distance with Babylon.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章关于结束，但同时也是关于开始。我们在这段漫长的旅程中可能即将到达目的地，但这只是你与 Babylon.js 个人旅程的开始。在这一章中，我们放弃任何线性或顺序进展的假象，而是将在几个不同的主题之间跳跃，每个主题都将为你提供独立的起点，帮助你与
    Babylon.js 一同走得更远。
- en: When navigating unfamiliar streets, it can be useful to have a guide, someone
    who is knowledgeable about an area. Someone with deep practical experience, who
    knows how to guide visitors and new arrivals to the best places and sights. Our
    Space-Dispatcher has located several talented individuals to show us areas of
    Babylon.js that we didn’t get to see or learn about during our trip.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航不熟悉的街道时，有一个向导是有用的，这个人对某个地区有深入了解。一个有深厚实践经验的人，知道如何引导游客和新来者到最好的地方和景点。我们的 Space-Dispatcher
    已经找到了几位有才华的人，他们将会向我们展示在旅行中我们没有看到或了解到的 Babylon.js 的区域。
- en: In this chapter, we’re going to visit two active construction sites in the metatropolies
    of BJS. At the first of those sites, we’ll learn about ongoing efforts to bring
    the simple elegance of Babylon.js out of the web and directly onto device hardware
    with Babylon Native. The second of those sites encompasses the exciting world
    (“metaverse”) of **augmented reality** (**AR**) and **virtual reality** (**VR**)
    in the form of **WebXR** – the new standard for web-based AR/VR applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将参观 BJS 的两个活跃的施工现场。在第一个施工现场，我们将了解将 Babylon.js 的简单优雅从网络直接带到设备硬件上的持续努力——Babylon
    Native。第二个施工现场涵盖了激动人心的世界（“元宇宙”）——**增强现实**（**AR**）和**虚拟现实**（**VR**）的世界，形式为 **WebXR**——基于
    Web 的 AR/VR 应用程序的新标准。
- en: After those stops, we’ll meet our first guide, BJS community member and serial
    helper of people on the forum, Andrei Stepanov, who will take us through the loading
    docks and into the Babylon.js Mall. He’ll show us glittering displays of the latest
    gadgets on a tour of how easy it is to use BJS with Content Management Systems
    and e-commerce platforms. Parting ways with Mr. Stepanov, we next visit a shiny
    new transport terminal as we go to meet our last guide, Erich Loftis.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些停留之后，我们将遇到我们的第一位向导，BJS 社区成员，论坛上的连续帮助者，Andrei Stepanov，他将带我们通过装卸码头进入 Babylon.js
    商场。他将通过一次游览展示如何轻松地将 BJS 与内容管理系统和电子商务平台结合使用，展示最新小工具的璀璨展示。与 Stepanov 先生告别后，我们接下来将访问一个闪亮的新交通枢纽，以便去见我们的最后一位向导，Erich
    Loftis。
- en: Erich has been ranging out on a journey of his own for some time now, and he’s
    going to entertain and enlighten us with the story of his quest seeking the Holy
    Grail of photorealism in 3D graphics – **Real-Time Ray (Path) Tracing**. That’s
    just a preview of what’s to come because it’s time to take a hard right and put
    on a hard hat as we pull into our first construction site for AR and VR with **WebXR**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Erich 已经在一段时间的个人旅程中四处游历，他将通过他寻求 3D 图形中真实感圣杯——**实时光线（路径）追踪**的故事来娱乐和启发我们。这只是即将到来的预览，因为现在是时候向右转，戴上安全帽，我们即将进入我们的第一个
    AR 和 VR 施工现场——**WebXR**。
- en: There’s always more to learn in any given technical arena, and that applies
    double or more when the topic is rapidly changing. **WebXR** is the standard for
    developing web-based AR and VR, and it qualifies under the “double-or-more” policy
    with its rapidly evolving mix of standard and support. As we learn about **WebXR**,
    we’re not going to focus on every feature of the standard – that would be like
    trying to ice-skate up a hill during a heatwave. What we’re going to focus on
    are the features and capabilities of Babylon.js that allow you as the developer
    to write applications that make use of **WebXR** while lowering the risks involved
    in those changing standards and APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何特定的技术领域，总有更多东西可以学习，当话题迅速变化时，这一点加倍或更多。**WebXR** 是开发基于 Web 的 AR 和 VR 的标准，并且由于其快速发展的标准和支持混合体，它符合“加倍或更多”的政策。当我们学习
    **WebXR** 时，我们不会关注标准的每一个特性——那就像在热浪中试图在山坡上滑冰一样。我们将关注 Babylon.js 的特性和功能，这些特性和功能允许你作为开发者编写利用
    **WebXR** 的应用程序，同时降低这些不断变化的标准和 API 所涉及的风险。
- en: 'Here are the topics that we’ll be covering in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章我们将涉及的主题：
- en: AR and VR with **WebXR**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**WebXR**进行AR和VR
- en: A tour of the **Babylon.js Native project**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babylon.js Native项目**之旅'
- en: Incorporating 3D content into a website
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将3D内容融入网站
- en: Tracing out a path to advanced rendering
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径追踪到高级渲染
- en: AR and VR with WebXR
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebXR进行AR和VR
- en: The inexorable march of Moore’s law has brought increasingly greater computing
    power into increasingly smaller microchips at a steady rate for long enough that
    the casual consumer has a staggering amount of raw computational silicone contained
    in their smartphones and tablets. There’s enough processing throughput in the
    average smartphone now that it’s realistic to entertain scenarios such as AR and
    VR.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔定律不可阻挡的步伐，以稳定的速度将越来越大的计算能力带入越来越小的微芯片中，已经持续了足够长的时间，以至于普通消费者在智能手机和平板电脑中拥有了惊人的原始计算硅含量。现在的智能手机处理能力已经足够强大，以至于可以设想AR和VR等场景。
- en: AR is a category of applications that encompasses a large variety of different
    use cases and scenarios. The common feature shared by these scenarios is that
    they make use of a device’s camera, location, orientation, and other sensors to
    emplace 3D content into a depiction of the real world. VR is very similar to AR,
    save that instead of the content being immersed in the user’s world (the real
    world), the user is immersed in the content (the virtual world).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: AR是一个涵盖大量不同用例和场景的应用程序类别。这些场景的共同特征是它们利用设备的摄像头、位置、朝向和其他传感器将3D内容嵌入到对现实世界的描绘中。VR与AR非常相似，只是内容不是沉浸在使用者的世界中（现实世界），而是使用者沉浸在内（虚拟世界）。
- en: Whether considering an AR and VR experience, it is important to keep in mind
    that both are more of a spectrum than a binary quality – there’s no rule that
    says something must use *X* percent of features to be considered an AR or a VR
    app. That would be a silly piece of gatekeeping.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到AR和VR体验，重要的是要记住，两者更多的是一个光谱，而不是一个二元性质——没有规则说某物必须使用*X*百分比的特性才能被认为是AR或VR应用程序。那将是一个愚蠢的守门人。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are looking for a great band name, Reality-Virtuality Spectrum/Continuum
    are both cool sounding ones! Read more about the Virtuality Spectrum at [https://creatxr.com/the-virtuality-spectrum-understanding-ar-mr-vr-and-xr/](https://creatxr.com/the-virtuality-spectrum-understanding-ar-mr-vr-and-xr/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个酷炫的乐队名字，现实-虚拟性光谱/连续体都是听起来很酷的选项！更多关于虚拟性光谱的信息，请参阅[https://creatxr.com/the-virtuality-spectrum-understanding-ar-mr-vr-and-xr/](https://creatxr.com/the-virtuality-spectrum-understanding-ar-mr-vr-and-xr/)。
- en: Consider this – an application may only support basic head tracking and stereoscopic
    views, but it is still a VR application. Similarly, a simple application that
    draws a rabbit’s ears over a person’s image in a video feed could technically
    be considered an AR application. Most of the time when discussing AR and VR in
    context of web development, it is assumed that the focus is on the VR side of
    things. Historically, that has been accurate, but it won’t always be the case.
    By examining some historical context, it will be clearer how this might have come
    to pass and when to expect that to change.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点——一个应用程序可能只支持基本的头部跟踪和立体视觉，但它仍然是一个VR应用程序。同样，一个简单的应用程序，在视频流中的人像上绘制兔耳朵，从技术上讲也可以被认为是AR应用程序。在讨论Web开发中的AR和VR时，大多数情况下都假设重点是VR方面。从历史上看，这一点是准确的，但情况并不总是如此。通过考察一些历史背景，我们可以更清楚地了解这种情况是如何发生的，以及何时可以期待这种变化。
- en: An Abridged History of AR/VR on the WWW
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网上AR/VR简史
- en: In the wide world of web development, there have been numerous attempts to bring
    about a standardized set of APIs for VR content, such as the **VRML** standard.
    The last-but-one effort was called **WebVR**, which was aimed at VR content with
    little to no consideration for AR – not out of neglect, but simply because AR
    didn’t exist in any commercially accessible form until relatively recently (let’s
    call it ca. 2015 or so).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在广泛的Web开发世界中，已经有许多尝试为VR内容制定一套标准化的API，例如**VRML**标准。最后的但不是最后一次努力被称为**WebVR**，它旨在为VR内容提供支持，几乎没有考虑AR——这不是因为忽视，而是因为AR直到最近才以任何商业可访问的形式存在（我们可以称之为大约2015年左右）。
- en: By 2018, it had become clear that to make AR a commercially viable application,
    it needed to be able to run on the web. The problem is deceptively simple but
    deviously hard to solve. Consumers don’t want to have to install five separate
    apps to browse five separate furniture stores just to display selections of furniture
    in the prospective buyer’s living room, but they’re happy to go to a website that
    offers the same! Unfortunately, requirements for even basic AR involve accessing
    device and sensor data that normally isn’t available to the browser JavaScript
    sandbox, where performance can also sometimes be suboptimal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到 2018 年，很明显，为了使 AR 成为一种商业上可行的应用，它需要在网络上运行。问题是欺骗性地简单，但解决起来却非常困难。消费者不希望不得不安装五个不同的应用程序来浏览五个不同的家具店，只是为了在潜在买家的客厅中展示家具选择，但他们很高兴去一个提供同样服务的网站！不幸的是，即使是基本的
    AR 也需要访问通常不可用于浏览器 JavaScript 沙盒的设备和传感器数据，而且性能有时也可能不尽如人意。
- en: The **WebXR** standard was introduced in 2018 by an industry-wide consortium
    of hardware and software manufacturers. This standard encapsulates and abstracts
    many areas that were left out of the previous **WebVR** standard, such as object/body
    part tracking, unified controller interfaces that account for the many different
    inputs possible with AR/VR, and in general, everything needed to program a world-class
    experience. All the cool kids (Apple, Google, Meta/Facebook, Samsung, Microsoft,
    et al) are a part of this standards body, which means that developers and consumers
    alike should be able to benefit from an explosion of innovation in the commercial
    AR/VR space. Or at least that should have been the case. Devices dedicated to
    AR, such as Microsoft’s HoloLens, as well as devices dedicated to VR, such as
    Oculus, have started to proliferate the consumer electronics market, but progress
    in general for supporting the **WebXR** standard has been stunted at best by the
    actions – or rather, a lack of action – from one of the most influential members
    of that consortium.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebXR** 标准于 2018 年由一个涵盖硬件和软件制造商的行业联盟推出。该标准封装和抽象了许多之前 **WebVR** 标准中遗漏的领域，例如物体/身体部位跟踪、统一控制器界面，这些界面考虑了
    AR/VR 可能的多种不同输入，以及一般而言，编程世界级体验所需的一切。所有酷炫的孩子们（苹果、谷歌、Meta/Facebook、三星、微软等）都是这个标准机构的一部分，这意味着开发者和消费者都应该能够从商业
    AR/VR 空间的创新爆炸中受益。或者至少应该是这样。专注于 AR 的设备，如微软的 HoloLens，以及专注于 VR 的设备，如 Oculus，已经开始在消费电子市场普及，但支持
    **WebXR** 标准的进展最多只是受到了该联盟最有影响力成员的行动——或者更确切地说，是没有采取行动——的阻碍。'
- en: 'While most of the consortium members have been busy working to implement key
    **WebXR** features and standards, one of its members – Apple – has sat mostly
    on the sidelines. They have recently released their new iOS hardware-based application
    SDK known as **ARKit**, which is a potential reason for Apple’s inaction on supporting
    **WebXR**. Allowing the hardware access that **WebXR** requires would effectively
    involve breaking the iron grip that **WebKit** has on web rendering on iOS. That’s
    unfortunate, because in the United States, iOS enjoys roughly 60 percent of the
    market share, meaning that most of the US market is inaccessible to companies,
    individuals, and organizations who want to develop and provide AR experiences
    and products on the web (for contrast, iOS holds less than 30 of the percent market
    share worldwide outside of the US. Android owns the bulk of the overseas market).
    The news doesn’t get too much better on the Apple front: as of summer 2022, it
    does not appear likely that Apple will release support for **WebXR** in its **WebKit**
    rendering engine at any point within the upcoming 6 to 12 months.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数联盟成员都在忙于实施关键的 **WebXR** 功能和标准时，其中一位成员——苹果公司——却主要坐在场边。他们最近发布了基于新 iOS 硬件的应用程序软件开发工具包，名为
    **ARKit**，这可能是苹果公司不支持 **WebXR** 的潜在原因。允许 **WebXR** 所需的硬件访问将有效地打破 **WebKit** 对
    iOS 网页渲染的铁腕控制。这是令人遗憾的，因为在美国，iOS 大约占 60% 的市场份额，这意味着大多数美国市场对那些希望在网页上开发和提供 AR 体验和产品的公司、个人和组织来说都是不可访问的（相比之下，iOS
    在美国以外的全球市场份额不到 30%。Android 拥有海外市场的大部分份额）。在苹果公司方面，情况并没有好太多：截至 2022 年夏季，苹果公司似乎不太可能在接下来的
    6 到 12 个月内在其 **WebKit** 渲染引擎中发布对 **WebXR** 的支持。
- en: Important Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Pending anti-trust litigation and legislation debate is ongoing in numerous
    courts and legislatures around the world. It is possible that the outcome of some
    of these matters could result in Apple allowing alternative web engines (such
    as Chromium) to be used in iOS. All bets are off if that happens!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 待决的反垄断诉讼和立法辩论正在世界各地的许多法院和立法机构中持续进行。有可能这些事项中的一些结果可能导致苹果允许在 iOS 上使用替代网络引擎（如 Chromium）。如果发生这种情况，所有赌注都将无效！
- en: 'With all that depressing talk of **WebXR** not being supported on iOS, constantly
    shifting standards, and frequent breaking changes, what’s the silver lining? How
    is the glass half-full, and why would you want to subject yourself to this type
    of software engineering misery? Let’s all say it together now: “Because Babylon.js’
    Got You” with the **WebXR** Experience Helper – blunting sharp pains into dull
    aches.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论 **WebXR** 不支持 iOS、标准不断变化和频繁的破坏性更改这样令人沮丧的话题时，有什么积极的一面？如何保持乐观，为什么你愿意让自己承受这种软件工程上的痛苦？现在让我们大家一起说：因为
    Babylon.js 有你的支持——用 **WebXR** 体验助手将尖锐的痛苦转化为钝痛。
- en: Building Tomorrow, Today with the WebXR Experience Helper
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WebXR 体验助手，今天构建明天
- en: It’s a founding precept of Babylon.js that backward compatibility is of paramount
    importance. Code written 10 years ago on BJS 1.0 still largely works in BJS 5.0,
    which is quite an achievement when talking about tech and the web! When dealing
    with something like **WebXR**, where features and APIs can come and go quickly
    though, does it even make sense to try and build a production application against
    such a moving target?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 的一个基本原则是向后兼容性至关重要。在 BJS 1.0 上编写 10 年前的代码在 BJS 5.0 中仍然大部分有效，这在谈论技术和网络时真是一项了不起的成就！然而，当处理像
    **WebXR** 这样一个功能和 API 可能迅速出现和消失的东西时，尝试构建一个针对这种移动目标的生产应用还有意义吗？
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recalling our previous discussion about rhetorical questions and their answers,
    you should already know the answer to that question to be “YES!”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前关于修辞疑问及其答案的讨论，你应该已经知道那个问题的答案是“YES！”
- en: The BJS `WebXRExperienceHelper` is a component that does exactly what it says
    it does on the box – that is, to help with **WebXR** implementation by setting
    up all of the necessary elements for an immersive session. The **Default Experience**
    provided is set up for a VR session along with basic features such as pointer
    tracking and teleportation while, of course, providing the ability to enable,
    attach, and use other features in collaboration with the **FeatureManager**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: BJS 的 `WebXRExperienceHelper` 是一个组件，它确实做了它所说的——即通过设置沉浸式会话所需的所有必要元素来帮助实现 **WebXR**。提供的
    **默认体验**是为 VR 会话设置的，包括基本的指针跟踪和传送功能，当然，还提供了与 **FeatureManager** 协作启用、附加和使用其他功能的能力。
- en: The important concept to understand about how the **FeatureManager** works is
    the process of enabling a given feature – at either a specific version, the “latest,”
    or “stable” version – and making it available to be attached to a Scene. Enabling
    a feature and attaching to the Scene is, along with their associated converse
    operations such as disabling and detaching, a two-step process for the application
    code. Two steps for the application, but hidden under the hood lies a whole host
    of sub-operations. Things such as browser feature detection, device capability
    enumeration, and more all occur during the feature enabling stage. The result
    of the enabling process leaves the **WebXRSession** with a new set of **Observables**
    related to the newly enabled feature(s). These Observables are now available to
    be used to attach those features to a given Scene.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 **FeatureManager** 的工作方式的重要概念是启用特定功能的过程——无论是在特定版本、最新版本还是稳定版本——并使其可用于附加到场景。启用功能并将其附加到场景是一个两步过程，包括它们相关的相反操作，如禁用和分离，这是应用程序代码中的两步。对于应用程序来说，但隐藏在引擎盖下的是一系列子操作。例如，在功能启用阶段发生浏览器功能检测、设备能力枚举等。启用过程的结果使
    **WebXRSession** 具有与新启用功能相关的新 **Observables**。现在，这些 Observables 可用于将这些功能附加到特定场景。
- en: The reason why this is an important concept is because while it isn’t necessary
    to use `WebXRExperienceHelper` or `FeatureManager`, those components provide your
    code with the critical ability to isolate itself from the effects of external
    changes. Production applications can make use of the latest VR/AR functionality
    available on a user’s device with confidence that they won’t suddenly break when
    the standard or a web browser’s support for the standard changes. The abstractions
    provided allow developers to write, extend, and maintain applications that leverage
    cutting-edge browser capabilities while gracefully degrading functionality for
    devices that don’t.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念之所以重要，是因为虽然使用 `WebXRExperienceHelper` 或 `FeatureManager` 不是必需的，但这些组件为你的代码提供了从外部变化的影响中隔离自己的关键能力。生产应用程序可以自信地利用用户设备上可用的最新
    VR/AR 功能，而不用担心当标准或网络浏览器对标准的支持发生变化时，它们会突然崩溃。提供的高级抽象允许开发者编写、扩展和维护利用尖端浏览器功能的应用程序，同时优雅地降低不支持这些功能的设备的性能。
- en: '**WebXR** has some incredibly exciting features and capabilities available
    today in Chrome- and Mozilla-based browsers, though some might require users to
    “unhide” features via flags. The types and features of applications built using
    **WebXR** are just beginning to be explored, and the Babylon.js team intends to
    be there to help developers use them the entire way. Unfortunately, that’s all
    the time we’ve got for this construction site visit – there are other places to
    go and things to see, after all, and we have a schedule to keep!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebXR** 在基于 Chrome 和 Mozilla 的浏览器中提供了许多令人兴奋的功能和能力，尽管一些可能需要用户通过标志“取消隐藏”功能。使用
    **WebXR** 构建的应用程序的类型和功能才刚刚开始被探索，Babylon.js 团队打算全程帮助开发者使用它们。不幸的是，这是我们在这个建筑工地访问的时间——毕竟，还有其他地方要去，还有其他东西要看，我们还有时间表要遵守！'
- en: Further Reading
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*WebXR Experience Helpers*: [https://doc.babylonjs.com/divingDeeper/webXR/webXRExperienceHelpers](https://doc.babylonjs.com/divingDeeper/webXR/webXRExperienceHelpers)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebXR 体验助手*: [https://doc.babylonjs.com/divingDeeper/webXR/webXRExperienceHelpers](https://doc.babylonjs.com/divingDeeper/webXR/webXRExperienceHelpers)'
- en: '*WebXR Features Manager*: [https://doc.babylonjs.com/divingDeeper/webXR/webXRFeaturesManager](https://doc.babylonjs.com/divingDeeper/webXR/webXRFeaturesManager)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebXR 功能管理器*: [https://doc.babylonjs.com/divingDeeper/webXR/webXRFeaturesManager](https://doc.babylonjs.com/divingDeeper/webXR/webXRFeaturesManager)'
- en: 'Demos and Playgrounds: [https://doc.babylonjs.com/divingDeeper/webXR/webXRDemos](https://doc.babylonjs.com/divingDeeper/webXR/webXRDemos)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示和游乐场：[https://doc.babylonjs.com/divingDeeper/webXR/webXRDemos](https://doc.babylonjs.com/divingDeeper/webXR/webXRDemos)
- en: Our next visit will be to the grounds of a sprawling new technology campus in
    the Babylon.js “Metatropolis.” This campus is the home of the **Babylon Native**
    project – an impressive, ambitious, and particularly complex undertaking. Among
    other areas of study, Native offers one potential solution to the problems posed
    around iOS support for **WebXR**. Let’s learn more about Native and what that
    solution looks like as part of our campus tour of the Babylon Native ecosystem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一次访问将是前往 Babylon.js 的“元都市”新科技园区。这个园区是 **Babylon Native** 项目的家——这是一个令人印象深刻、雄心勃勃且特别复杂的任务。在研究其他领域的同时，Native
    提供了一个可能的解决方案，以解决围绕iOS对 **WebXR** 支持的问题。让我们在参观 Babylon Native 生态系统校园的过程中了解更多关于
    Native 以及该解决方案的样子。
- en: A Tour of the Babylon.js Native Project
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babylon.js 原生项目的游览
- en: Babylon.js is primarily used as part of a web application, but that’s not the
    only place where it can add value. Sometimes, an application needs to target multiple
    platforms with the same code base. Other times, an existing device application
    wants to be able to easily add 3D rendering activities that are secondary to the
    application’s purpose (for example, in a scientific simulation, the renderer is
    simply drawing the output of the simulation onto the screen). Specific requirements
    might include the need for AR capabilities on platforms that include iOS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 主要用于作为网络应用程序的一部分，但那并不是它能增加价值的唯一地方。有时，一个应用程序需要使用相同的代码库针对多个平台。其他时候，现有的设备应用程序希望能够轻松地添加与应用程序目的次要相关的3D渲染活动（例如，在科学模拟中，渲染器只是将模拟的输出绘制到屏幕上）。具体要求可能包括在包括iOS在内的平台上需要AR功能。
- en: 'In each of those scenarios (and more that aren’t listed), there is a place
    for Babylon.js to add value to an application. What’s commonly referred to as
    “Babylon Native” in the singular, proper sense is actually a collection of technologies
    that apply to a specific range of scenarios. Every scenario is different and should
    have a solution tailored to the specific needs of the situation, and the set of
    technologies that comprise Babylon Native allows you as the developer to pick
    and choose where and when to apply them. One way to understand the technologies
    is to show them along a spectrum with a fully native app at one end and a fully
    web-native app at the other:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景（以及未列出的更多场景）中，Babylon.js 都有机会为应用程序增加价值。通常所说的“Babylon Native”在单一、正确的意义上实际上是一系列适用于特定范围场景的技术。每个场景都是不同的，应该有针对具体情况特定需求的解决方案，而构成
    Babylon Native 的技术集允许开发者根据需要选择何时何地应用它们。理解这些技术的一种方法是将它们展示在一个光谱上，一端是完全本地应用，另一端是完全网络原生应用：
- en: '![Figure 14.1 – Spectrum of application types. Source: https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md](img/Figure_14.01_B17266.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 应用类型光谱。来源：https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md](img/Figure_14.01_B17266.jpg)'
- en: 'Figure 14.1 – Spectrum of application types. Source: [https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md](https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 应用类型光谱。来源：[https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md](https://github.com/BabylonJS/BabylonNative/blob/master/Documentation/WhenToUseBabylonNative.md)
- en: The preceding diagram (taken from the BJS Native docs, linked in the caption)
    is one method of depicting the Native Collective that shows the relative scale
    of how close to the native device hardware a particular component or framework
    lies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表（摘自 BJS Native 文档，见标题中的链接）是展示 Native 集体的一种方法，它显示了特定组件或框架与本地设备硬件接近的相对规模。
- en: 'In his blog post about the technical underpinnings of BJS Native at [https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb),
    Sergio explains how the Babylon Native parts fit from a different perspective:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于 BJS Native 技术基础的博客文章中 [https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb)，Sergio
    从不同的角度解释了 Babylon Native 部分是如何适应的：
- en: '![Figure 14.2 – A layered diagram of how Babylon Native works in the absence
    of WebGL. Diagram source: https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](img/Figure_14.02_B17266.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 在没有 WebGL 的情况下 Babylon Native 的工作分层图。图源：https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](img/Figure_14.02_B17266.jpg)'
- en: 'Figure 14.2 – A layered diagram of how Babylon Native works in the absence
    of WebGL. Diagram source: [https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 在没有 WebGL 的情况下 Babylon Native 的工作分层图。图源：[https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb](https://babylonjs.medium.com/a-babylon-native-backstage-tour-f9004bebc7fb)
- en: Whether using **Babylon React Native** or simply **Babylon Native**, the preceding
    diagram shows how the unifying abstraction layer of **Babylon Native** covers
    the ugly and sometimes chaotic mess of talking to various hardware components,
    such as the BGFX cross-platform graphics driver with ARCore and ARKit for other
    device sensor and input API abstractions. Having these concepts in mind, we can
    now consider a few potential usage scenarios where it makes sense to take a good
    look at the options presented by Babylon Native.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用 **Babylon React Native** 还是简单的 **Babylon Native**，前面的图表显示了 **Babylon Native**
    的统一抽象层如何覆盖与各种硬件组件（如 BGFX 跨平台图形驱动程序、ARCore 和 ARKit 等其他设备传感器和输入 API 抽象）通信的丑陋和有时混乱的混乱。有了这些概念在心中，我们现在可以考虑一些潜在的用法场景，在这些场景中，仔细查看
    Babylon Native 提供的选项是有意义的。
- en: Choosing Babylon Native
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 Babylon Native
- en: The decision on whether Babylon Native is a good fit for a given project can
    be complex. The docs for Native have an entire page devoted to a questionnaire
    to help you determine what approaches are worth the most research – and what aren’t
    – and while helpful, they can be better understood via a contrived scenario.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将 Babylon Native 适用于特定项目是一个复杂的问题。Native 的文档有一个专门的页面，包含一个问卷，以帮助您确定哪些方法值得深入研究——哪些则不然——虽然这些信息很有帮助，但通过一个假设的场景可以更好地理解。
- en: If your application is based on **React Native**, there is a light integration
    option and a full integration option. The light option is to use a **WebView**
    to host the WebGL context and canvas. This has the advantage of being able to
    take advantage of the **Just-In-Time** (**JIT**) compilation of JavaScript, meaning
    JS code will tend to be faster than when not using a WebView for some platforms.
    The full integration option is to use **Babylon React Native**. Here’s what we
    might imagine the app this looks like.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序基于**React Native**，则有两种集成选项：轻量级集成和完全集成。轻量级选项是使用**WebView**托管WebGL上下文和画布。这有一个优点，即能够利用JavaScript的**即时编译**（**JIT**），这意味着在某些平台上，JS代码将比不使用WebView时更快。完全集成选项是使用**Babylon
    React Native**。以下是我们可以想象的应用程序可能的样子。
- en: The Evolution of a Babylon Native App
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 巴比伦本地应用的演变
- en: The LARP’in app is an app for **Live Action Role Players** – people who like
    to take the table out of tabletop games and act out the gameplay themselves using
    the app to coordinate events, chat, and so on, with all the different luxuries
    that people have come to expect from a modern Web Application. The “Player App”
    is built using React and has enjoyed a steady run of releases, enhancing and extending
    the site’s functionality. The app’s creators want to allow event schedulers to
    be able to manage events offline (because event spaces sometimes don’t have reception)
    so they’ve added PWA capabilities, making everyone happy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: LARP玩家应用程序是一个为**现场动作角色扮演者**（Live Action Role Players）设计的应用程序——这些人喜欢将桌面游戏中的桌面拿掉，并使用应用程序自己进行游戏，通过应用程序协调事件、聊天等，拥有人们从现代Web应用程序中期待的所有不同奢华功能。“玩家应用程序”使用React构建，并一直保持着稳定的发布，增强和扩展了网站的功能。应用程序的创建者希望允许活动调度员能够离线管理活动（因为有时活动空间没有信号），所以他们增加了PWA功能，让每个人都感到满意。
- en: 'Then one day, some LARP’in LARPers were playing *Pokémon Go* when they had
    the realization that while LARPing is cool, what’s even cooler is LARPing… with
    AR! Players would be able to see visualizations of their spells cast, detect traps
    with skill rolls, and walk around exploring a fantasy world brought to life. Their
    existing LARP tools consist of some home-brewed Bluetooth-connected devices embedded
    into items (for example, a sword) that register hits and similar game-management
    tasks by lighting up or beeping, but that’s the extent of it. Many of the members
    have iOS devices, while others are on Android, and there are even a few odd souls
    clinging to heavily tweaked versions of Windows Mobile (bless their souls). In
    2021, the group won first prize at a cosplay competition, which came with enough
    funds to allow the group to purchase a set of **HoloLens** headsets along with
    an **Oculus VR** device for a member whose health problems prevented them from
    attending events in person. The AR-enhanced Player App would need to be able to
    talk to these devices to be useful as well as utilize existing functionality within
    the Player App (for example, displaying the player’s inventory). Finally, the
    group has developed a custom C# desktop application they appropriately call the
    “GM App” to connect to these BT devices and to act as a game’s referee (often
    called a **GM** or **Game Master**). The app’s maintainers have the wonderful
    opportunity here to evolve the app toward their vision in valuable and discrete
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一天，一些LARP玩家在玩**宝可梦GO**时突然意识到，虽然LARP很酷，但更酷的是用AR进行LARP！玩家将能够看到他们施展的法术的视觉效果，通过技能检定来探测陷阱，并在一个被赋予生命的幻想世界中四处探索。他们现有的LARP工具包括一些嵌入到物品（例如，一把剑）中的自制的蓝牙连接设备，通过闪烁或蜂鸣来注册命中和类似的游戏管理任务，但这只是其中的一部分。许多成员拥有iOS设备，而其他人则使用Android，甚至还有一些人坚持使用经过大量修改的Windows
    Mobile版本（愿他们的灵魂得到祝福）。2021年，该小组在一项Cosplay比赛中获得了一等奖，这为他们提供了足够的资金来购买一套**HoloLens**头戴设备和一套**Oculus
    VR**设备，供一位因健康问题无法亲自参加活动的成员使用。增强现实功能的玩家应用程序需要能够与这些设备通信，以便有用，并利用玩家应用程序中的现有功能（例如，显示玩家的库存）。最后，该小组开发了一个自定义的C#桌面应用程序，他们称之为“GM应用程序”，用于连接这些蓝牙设备，并作为游戏的裁判（通常称为**GM**或**游戏大师**）。应用程序的维护者有机会以有价值且明确的方式逐步将应用程序演变为其愿景：
- en: Bring the app over into a **React Native** application that otherwise behaves
    exactly as it currently does.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用迁移到**React Native**应用程序中，该应用程序的行为与当前完全相同。
- en: Add basic rendering capabilities with Babylon in a **WebView**. This will allow
    the team to release the same functionality with the same code base as the web
    app.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Babylon在**WebView**中添加基本的渲染功能。这将允许团队以与Web应用程序相同的代码库发布相同的功能。
- en: Build local mesh connectivity between BT and WiFi devices that feeds data into
    **React Native** app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BT 和 WiFi 设备之间建立本地网格连接，将数据输入到 **React Native** 应用程序中。
- en: Integrate a **Babylon Native** rendering of a pure 3D scene in the C# application
    to show GMs different views of the action (picture a sword fight where the swords
    have sensors embedded in them, with the scene depicting the state of the swords
    as relayed by sensors).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 应用程序中集成 **Babylon Native** 的纯 3D 场景渲染，以向 GM 展示不同的动作视图（想象一下一场剑斗，剑上嵌入了传感器，场景通过传感器传达剑的状态）。
- en: Transition rendering responsibilities from a **WebView** to **Babylon React
    Native**. Use Babylon.js with **WebXR** to leverage device capabilities to render
    scenes onto a live image stream or to a VR set in a remote location.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染责任从 **WebView** 转移到 **Babylon React Native**。使用 Babylon.js 与 **WebXR** 结合，利用设备功能将场景渲染到实时图像流或远程位置的
    VR 设备上。
- en: Enjoy LARPing!
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 享受 LARPing（生活体验角色扮演游戏）的乐趣！
- en: This example isn’t intended to be comprehensive or exhaustive, but it does cover
    a decent range of potential use cases by implication. When embarking on a Native
    project, it is worth considering whether the same goals might be accomplished
    more easily using a different framework such as Unity or Unreal. It is also important
    to keep in mind that the current (summer 2022) state of the project at the time
    of writing is still immature, and thus there are limitations and gaps in supported
    functionality. Check the links in the next section to get the latest information
    on what is supported and what isn’t in Babylon Native.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例并不旨在全面或详尽，但它通过暗示涵盖了相当广泛的潜在用例。当开始一个原生项目时，考虑是否可以使用不同的框架（如 Unity 或 Unreal）更容易地实现相同的目标是值得的。同时，也要记住，在撰写本文时，项目的当前（2022
    年夏季）状态仍然不够成熟，因此存在功能支持的局限性和空白。请查看下一节中的链接，以获取 Babylon Native 支持和未支持功能的最新信息。
- en: Further Reading
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'As the project is rapidly evolving, so too is the documentation. Here are some
    places to start reading more about Babylon Native and Babylon React Native at
    the following links:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目正在快速演变，文档也在不断更新。以下是一些链接，您可以从中了解更多关于 Babylon Native 和 Babylon React Native
    的信息：
- en: '[https://www.babylonjs.com/native/](https://www.babylonjs.com/native/)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.babylonjs.com/native/](https://www.babylonjs.com/native/)'
- en: '[https://www.babylonjs.com/reactnative/](https://www.babylonjs.com/reactnative/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.babylonjs.com/reactnative/](https://www.babylonjs.com/reactnative/)'
- en: Although it was short, our overview of the Babylon Native campus has covered
    the more important guideposts and signs that mark the various trails throughout
    the area. As a collection of technologies, Babylon Native is all about fitting
    the right set of tools to the right situation. Web apps that already use React
    or apps using React Native are the most stable and advanced implementations currently
    available, but Babylon Native is the path to follow if you’re looking to build
    an AR app that runs on iOS. Each of those approaches has its benefits and drawbacks,
    some potentially quite significant. The good news is that regardless of which
    approach is chosen, the code you write that interacts with Babylon.js doesn’t
    need to change for multiplatform targeting scenarios.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间很短，但我们对 Babylon Native 校园的概述已经涵盖了该区域各个小径上标记的重要指南和标志。作为一个技术集合，Babylon Native
    主要是关于根据不同情况选择合适的工具。已经使用 React 或使用 React Native 的 Web 应用程序是目前最稳定和最先进的实现，但如果您想构建在
    iOS 上运行的 AR 应用程序，Babylon Native 是您应该遵循的道路。每种方法都有其优点和缺点，有些可能相当重要。好消息是，无论选择哪种方法，您编写的与
    Babylon.js 交互的代码在多平台目标场景中不需要更改。
- en: Moving on, we’ve got business to attend to with our first guide, Andrei Stepanov.
    Andrei has been working with Babylon.js and **Content Management Systems** (**CMSs**)
    for a long time now, so he’s the perfect person to give us a quick tour of how
    BJS can be used in e-commerce and CMS business scenarios.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将与我们的第一位指南安德烈·斯捷潘诺夫（Andrei Stepanov）一起处理业务。安德烈已经与 Babylon.js 和 **内容管理系统**（**CMSs**）合作很长时间了，因此他是给我们快速浏览
    BJS 如何用于电子商务和 CMS 商业场景的完美人选。
- en: Incorporating 3D Content into a Website
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 3D 内容集成到网站中
- en: When it comes to understanding how to make Babylon.js work in real-world, customer-centric
    business scenarios, there aren’t many people more knowledgeable about the topic
    than Andrei, who posts to the BJS community forums under the name of “Labris.”
    As a senior 3D developer at MetaDojo ([https://metadojo.io](https://metadojo.io)),
    he satisfies and delights clients with 3D experiences built to spec. Not content
    with just talking about how to build and create with Babylon.js, Andrei is also
    the creator of the **BabylonPress** site ([https://babylonpress.org](https://babylonpress.org)),
    which serves as a showcase of different examples and patterns that use BJS in
    conjunction with the **WordPress** CMS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到理解如何在现实世界的以客户为中心的业务场景中使用 Babylon.js 时，没有比 Andrei 更有知识的人了，他在 BJS 社区论坛上以“Labris”的名字发帖。作为
    MetaDojo 的资深 3D 开发者（[https://metadojo.io](https://metadojo.io)），他通过构建符合规格的 3D
    体验来满足和取悦客户。Andrei 不仅满足于仅仅谈论如何使用 Babylon.js 构建和创作，他还是 **BabylonPress** 网站的建设者（[https://babylonpress.org](https://babylonpress.org)），该网站展示了使用
    BJS 与 **WordPress** 内容管理系统结合的不同示例和模式。
- en: Babylon.js and CMS
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babylon.js 和 CMS
- en: Babylon.js lets us build very complex JS 3D applications from scratch. At the
    same time, there are a lot of cases when we need to integrate Babylon.js into
    an already existing website with CMS – an application that enables users to create,
    edit, publish and store digital content – or just to some HTML template.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 让我们从头开始构建非常复杂的 JS 3D 应用程序。同时，有许多情况需要将 Babylon.js 集成到已经存在的网站（带有 CMS）中——这是一个允许用户创建、编辑、发布和存储数字内容的应用程序——或者只是某些
    HTML 模板。
- en: There are numerous ways to do this, on different levels. They will depend on
    specific needs, especially on the “3D User Experience,” which you need to provide.
    Since the number and variety of different CMS wouldn’t allow us the luxury of
    describing all possible solutions in this space, I will explain in the next few
    subsections just some of the most common solutions and approaches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以实现这一点，在不同的层面上。它们将取决于具体需求，特别是“3D 用户体验”，你需要提供。由于不同 CMS 的数量和种类众多，我们无法在这里描述所有可能的解决方案，因此我将在接下来的几个小节中仅解释一些最常见解决方案和途径。
- en: The Babylon Viewer
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Babylon Viewer
- en: Babylon.js has an official extension, Babylon Viewer, which may simplify a lot
    of time for integration. It even has its own HTML tags, `<babylon></babylon>`,
    between which you define all needed parameters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 拥有一个官方扩展，名为 Babylon Viewer，这可能会简化许多集成所需的时间。它甚至有自己的 HTML 标签，`<babylon></babylon>`，在其中你可以定义所有需要的参数。
- en: 'To display a 3D model in a prepared environment – with already tuned lights,
    shadows, reflections, and so on – you just need to add a script reference to the
    viewer like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在准备好的环境中显示 3D 模型——其中已经调整了灯光、阴影、反射等——你只需向查看器添加一个脚本引用，如下所示：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add a `<babylon>` tag and set the model attribute to point to a `.gltf`
    or `.glb` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个 `<babylon>` 标签，并将模型属性设置为指向 `.gltf` 或 `.glb` 文件：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Besides the `.gtlf` and `.glb` formats, `.babylon`, `.obj`, and `.stl` formats.
    Its simplicity allows easy integration of Babylon Viewer into any CMS and makes
    it an ideal choice for cases where you need to display a lot of different 3D models
    (e-commerce, game websites, and 3D artist blogs) in a user-editable CMS. More
    information about different Babylon Viewer configurations is available here: [https://doc.babylonjs.com/extensions/babylonViewer/configuringViewer](https://doc.babylonjs.com/extensions/babylonViewer/configuringViewer).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `.gtlf` 和 `.glb` 格式外，还有 `.babylon`、`.obj` 和 `.stl` 格式。它的简单性使得 Babylon Viewer
    能够轻松集成到任何 CMS 中，使其成为需要在大用户可编辑的 CMS 中显示大量不同 3D 模型（电子商务、游戏网站和 3D 艺术家博客）的理想选择。有关不同
    Babylon Viewer 配置的更多信息，请参阅此处：[https://doc.babylonjs.com/extensions/babylonViewer/configuringViewer](https://doc.babylonjs.com/extensions/babylonViewer/configuringViewer)。
- en: Babylon Viewer 3D WordPress Plugin
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Babylon Viewer 3D WordPress 插件
- en: 'Built on the base of **Babylon Viewer**, there also exists a community extension:
    the **Babylon Viewer 3D Wordpress plugin**. This allows you to display 3D models
    and 3D scenes with the help of a **Shortcode**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 **Babylon Viewer** 的基础，还存在一个社区扩展：**Babylon Viewer 3D WordPress 插件**。这允许你使用
    **Shortcode** 来显示 3D 模型和 3D 场景：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use the 3D Viewer in `README` file at its home on GitHub at [https://github.com/eldinor/babylon-wordpress-plugin](https://github.com/eldinor/babylon-wordpress-plugin).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Babylon-wordpress-plugin 的 GitHub 主页上的 `README` 文件中使用 3D 查看器 [https://github.com/eldinor/babylon-wordpress-plugin](https://github.com/eldinor/babylon-wordpress-plugin)。
- en: Kiosk Mode and Iframes
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 亭式模式和 Iframes
- en: 'With regards to iframe implementations, it is worth mentioning that the **Babylon
    Sandbox** ([https://sandbox.babylonjs.com/](https://sandbox.babylonjs.com/)) has
    a special “kiosk” mode that allows you to use its functionality with any 3D model
    in appropriate format. As an example, have a look at this beautiful example (a
    3D model of an ancient mosquito in amber) of **GLTF** transparency in the **Khronos
    Group** article: [https://www.khronos.org/news/press/new-gltf-extensions-raise-the-bar-on-3d-asset-visual-realism](https://www.khronos.org/news/press/new-gltf-extensions-raise-the-bar-on-3d-asset-visual-realism).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于iframe实现，值得提一下的是，**Babylon沙盒**([https://sandbox.babylonjs.com/](https://sandbox.babylonjs.com/))有一个特殊的“展台”模式，允许您使用其功能与任何适当格式的3D模型。例如，看看这个美丽的例子（琥珀中的古蚊3D模型）——在**Khronos
    Group**文章中关于**GLTF**透明度的例子：[https://www.khronos.org/news/press/new-gltf-extensions-raise-the-bar-on-3d-asset-visual-realism](https://www.khronos.org/news/press/new-gltf-extensions-raise-the-bar-on-3d-asset-visual-realism)。
- en: The different query string elements embedded within the URL allow the content
    creator or manager to define the source 3D file and all other parameters, such
    as camera position, auto-rotation behavior, the skybox, and environment texture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: URL中嵌入的不同查询字符串元素允许内容创建者或管理员定义源3D文件以及所有其他参数，例如相机位置、自动旋转行为、天空盒和环境纹理。
- en: To use “kiosk mode,” define the URL according to the following table. The first
    parameter starts with `?` after [https://sandbox.babylonjs.com/](https://sandbox.babylonjs.com/);
    all others start with `&` before the parameter. Also note that since Babylon.js
    is an open source project, you can create and host your own version of the Sandbox!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“展台模式”，请根据以下表格定义URL。第一个参数在[https://sandbox.babylonjs.com/](https://sandbox.babylonjs.com/)之后以`?`开头；所有其他参数在参数之前以`&`开头。另外请注意，由于Babylon.js是一个开源项目，您可以创建并托管自己的Sandbox版本！
- en: '![Table 14.1 – Table of parameters for iframes for the BJS Sandbox'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![表14.1 – BJS沙盒Iframe参数表'
- en: '](img/Table_14.01_B17266.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_14.01_B17266.jpg)'
- en: Table 14.1 – Table of parameters for iframes for the BJS Sandbox
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – BJS沙盒Iframe参数表
- en: 'At the end, you’ll get something like this – quite a long HTML link:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将得到一个像这样的HTML链接——相当长的链接：
- en: '[https://sandbox.babylonjs.com/?kiosk=true&assetUrl=https://raw.githubusercontent.com/wallabyway/gltf-presskit-transparency/main/docs/MosquitoInAmber_withRefraction.glb&cameraPosition=-0.14,0.005,0.03&autoRotate=true&skybox=true&environment=https://assets.babylonjs.com/environments/studio.env](https://sandbox.babylonjs.com/?kiosk=true&assetUrl=https://raw.githubusercontent.com/wallabyway/gltf-presskit-transparency/main/docs/MosquitoInAmber_withRefraction.glb&cameraPosition=-0.14,0.005,0.03&autoRotate=true&skybox=true&environment=https://assets.babylonjs.com/environments/studio.env)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sandbox.babylonjs.com/?kiosk=true&assetUrl=https://raw.githubusercontent.com/wallabyway/gltf-presskit-transparency/main/docs/MosquitoInAmber_withRefraction.glb&cameraPosition=-0.14,0.005,0.03&autoRotate=true&skybox=true&environment=https://assets.babylonjs.com/environments/studio.env](https://sandbox.babylonjs.com/?kiosk=true&assetUrl=https://raw.githubusercontent.com/wallabyway/gltf-presskit-transparency/main/docs/MosquitoInAmber_withRefraction.glb&cameraPosition=-0.14,0.005,0.03&autoRotate=true&skybox=true&environment=https://assets.babylonjs.com/environments/studio.env)'
- en: The BJS Playground and Iframes
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BJS游乐场和Iframe
- en: Another option that is especially useful for displaying scenes directly from
    Babylon Playground is a special HTML template. Just add `frame.xhtml` before the
    Playground URL and it will show the render area in full screen, but with a bottom
    toolbar showing FPS, reload and edit buttons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特别有用的选项是直接从Babylon游乐场显示场景的特殊HTML模板。只需在游乐场URL之前添加`frame.xhtml`，它就会以全屏显示渲染区域，但底部工具栏会显示FPS、重新加载和编辑按钮。
- en: 'Here is an example: [https://www.babylonjs-playground.com/frame.xhtml#6F0LKI#2](https://www.babylonjs-playground.com/frame.xhtml%236F0LKI%232).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：[https://www.babylonjs-playground.com/frame.xhtml#6F0LKI#2](https://www.babylonjs-playground.com/frame.xhtml%236F0LKI%232)。
- en: 'To show only the render area, use `full.xhtml` as the prefix. More info about
    Playground URL formats is available here: [https://doc.babylonjs.com/toolsAndResources/tools/playground#playground-url-formats](https://doc.babylonjs.com/toolsAndResources/tools/playground#playground-url-formats).
    The result of this option is that you can then use that URL as the source for
    an iframe image element – see [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)
    for how to define an iframe element.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅显示渲染区域，请使用`full.xhtml`作为前缀。有关Playground URL格式的更多信息，请参阅此处：[https://doc.babylonjs.com/toolsAndResources/tools/playground#playground-url-formats](https://doc.babylonjs.com/toolsAndResources/tools/playground#playground-url-formats)。此选项的结果是您可以然后使用该URL作为iframe图像元素的源
    – 请参阅[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)了解如何定义iframe元素。
- en: Babylon.js within a CMS
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Babylon.js在CMS中
- en: 'Finally, if you are looking for more close integration between Babylon.js and
    a CMS, you would need to take into consideration these universal steps. Make sure
    that you have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您正在寻找Babylon.js和CMS之间更紧密的集成，您需要考虑以下通用步骤。确保您有以下条件：
- en: The Babylon.js scripts are loaded properly. Depending on the CMS, you can also
    load Babylon.js conditionally if there is 3D content to be displayed on the web
    page.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babylon.js脚本已正确加载。根据CMS的不同，如果网页上要显示3D内容，您也可以有条件地加载Babylon.js。
- en: The CMS supports the uploading of 3D files (most modern CMSs have a limited
    set of allowed file extensions).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS支持上传3D文件（大多数现代CMS都有有限的允许文件扩展名）。
- en: A proper canvas element to display. It makes sense to assign a unique ID to
    each Babylon canvas (for example, with the help of a post ID or other CMS variable).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个合适的canvas元素来显示。为每个Babylon canvas分配一个唯一的ID是有意义的（例如，借助帖子ID或其他CMS变量）。
- en: Canvas and BJS Engine elements properly hooked up to respond to resizes.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas和BJS引擎元素已正确连接，以响应调整大小。
- en: Here, the complexity and the scale of applications depends only on your creativity.
    Server-side languages can preprocess any needed data before delivering it to a
    JS client, allowing us to build a truly 3D CMS, where all user experiences and
    interactions happen in 3D space.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用的复杂性和规模仅取决于您的创造力。服务器端语言可以在将其交付给JS客户端之前预处理任何所需的数据，使我们能够构建一个真正的3D CMS，其中所有用户体验和交互都在3D空间中发生。
- en: Babylon.js is not just another JavaScript framework to use for two-dimensional
    websites; it is one of the key components required to build multi-user 3D worlds
    and metaverses, at least with the current meaning of this term.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js不仅仅是一个用于二维网站的JavaScript框架；它是构建多用户3D世界和元宇宙的关键组件之一，至少按照当前这个术语的含义来说。
- en: There’s a big difference between loading a 3D model onto a single web page and
    bringing potentially lots of 3D models onto lots of different web pages. Managing
    the content and change processes is of utmost importance, but with the Guidance
    of Andrei, you’ll be ready to face those challenges and more. Now, what does 3D
    content in an e-commerce or CMS app have to do with a roughly 50-year-old technique
    for photo-realistic renders? Why, Babylon.js, of course! It’s time to continue
    our tour as we transition from the highly practical to the highly experimental
    side of 3D programming.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个网页上加载3D模型与在许多不同的网页上加载可能的大量3D模型之间有很大的区别。管理和变更过程的管理至关重要，但在Andrei的指导下，您将准备好面对这些挑战以及更多。现在，电子商务或CMS应用中的3D内容与大约50年前的照片真实渲染技术有什么关系呢？当然，是Babylon.js！是时候继续我们的旅程，从高度实用的3D编程转向高度实验性的方面了。
- en: Tracing out a Path to Advanced Rendering
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径追踪到高级渲染
- en: Our last stop on our *Extended Topics, Extended* tour is with musician, engineer,
    and graphics wizard Erich Loftis. He’s going to guide us with the story of his
    journey to achieving **Real-Time Path Tracing** (**RTPT**) with Babylon.js. RTPT
    – also referred to as **Ray Tracing** or just **RT** – is a rendering technique
    built on top of Path Tracing that companies such as Nvidia and AMD are only just
    beginning to make available in AAA commercial titles, and only in select ways.
    Through the retelling of Erich’s journey, the reason why the technique has been
    so difficult to accomplish in real-time games and simulations will hopefully become
    abundantly clear.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们“扩展主题，扩展”之旅的最后一站是与音乐家、工程师和图形奇才Erich Loftis。他将引导我们了解他实现**实时路径追踪**（**RTPT**）与Babylon.js的故事。RTPT——也被称为**光线追踪**或简称**RT**——是一种基于路径追踪的渲染技术，Nvidia和AMD等公司才刚刚开始在AAA商业游戏中提供，而且仅以特定的方式提供。通过重述Erich的旅程，为什么这项技术在实时游戏和模拟中如此难以实现的原因可能会变得非常清晰。
- en: Ray Tracing and its History by Erich Loftis
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Erich Loftis的《光线追踪及其历史》
- en: RT is a technique for rendering realistic images and effects on a computer.
    It follows the laws of optics and models how physical light rays behave in the
    real world. Therefore, RT can produce truly photo-realistic images. **RT** is
    *the* standard for photo-realistic offline rendering. Because it has found its
    way into real-time applications and games (where Rasterization was the undisputed
    king), it’s important to have at least a basic understanding of how it all works
    under the hood.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: RT是一种在计算机上渲染逼真图像和效果的技术。它遵循光学定律，并模拟了物理光束在现实世界中的行为。因此，RT可以产生真正照片般的图像。**RT**是照片级离线渲染的标准。因为它已经进入实时应用和游戏（其中光栅化是无争议的王者），因此了解它内部的工作原理至少是基础性的。
- en: By leveraging the awesome **Babylon.js** engine, we can use this understanding
    to make our own **Physically Based Renderer** that runs right inside the browser.
    This is important because it opens the door to experiencing photo-realistic graphics
    on any platform or device, even your cellphone. Of course, the journey to get
    to this point wasn’t exactly the most straightforward or easy, but as you’ll see
    from the demos and examples, the effort is totally worth it!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用强大的**Babylon.js**引擎，我们可以利用这种理解来创建自己的**基于物理的渲染器**，它可以直接在浏览器中运行。这很重要，因为它打开了在任何平台或设备上体验照片级图形的大门，甚至包括你的手机。当然，到达这个点的旅程并不完全是最直接或容易的，但正如你将从演示和示例中看到的那样，努力是完全值得的！
- en: My Own RT Journey
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的RT之旅
- en: 'It was this dream of experiencing **RT** on all devices that led me to create
    a Path Tracing Renderer for **three.js,** starting back in 2015\. For the past
    7+ years, I have been slowly but steadily researching, building, refining, and
    optimizing a browser-based renderer that not only produces high-quality, photo-realistic
    images but also aims to do so at 30–60 frames a second! Please check out my ongoing
    project on **GitHub**, where you can try dozens of clickable demos: [https://github.com/erichlof/THREE.js-PathTracing-Renderer](https://github.com/erichlof/THREE.js-PathTracing-Renderer).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正是体验**RT**在所有设备上的梦想促使我创建了一个**three.js**的路径追踪渲染器，始于2015年。在过去的7+年里，我一直在缓慢但稳步地进行研究、构建、改进和优化一个基于浏览器的渲染器，它不仅能够产生高质量的、照片般的图像，而且旨在每秒30-60帧的速度实现这一点！请查看我在**GitHub**上持续进行的项目，在那里你可以尝试数十个可点击的演示：[https://github.com/erichlof/THREE.js-PathTracing-Renderer](https://github.com/erichlof/THREE.js-PathTracing-Renderer)。
- en: A while ago, back in 2020, a Babylon.js developer reached out to me and asked
    if I could possibly make a similar renderer for the BJS engine. I must state here
    that I have primarily worked with **three.js** all these years, but I have always
    admired and been impressed by the amazing **Babylon.js** library. When I agreed
    to do the port of my ray/path tracing system from three.js to BJS, I was equally
    impressed with the BJS forum community. They are so friendly and helpful and are
    just awesome folks! I couldn’t have gotten our BJS renderer up and running without
    their help and support. So, before we dive in, a quick shout out to you all –
    thank you, BJS community!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间以前，在2020年，一位Babylon.js开发者联系了我，问我是否可以为他们制作一个类似的渲染器。我必须在这里声明，我多年来主要使用**three.js**，但我一直钦佩并印象深刻的是令人惊叹的**Babylon.js**库。当我同意将我的光线/路径追踪系统从three.js移植到BJS时，我对BJS论坛社区同样印象深刻。他们非常友好和乐于助人，是了不起的人！没有他们的帮助和支持，我们无法让BJS渲染器运行起来。因此，在我们深入之前，我要向大家快速致谢——谢谢，BJS社区！
- en: RT or Rasterization?
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RT或光栅化？
- en: What does it take to get interactive, real-time RT working inside of BJS and
    a browser? Firstly, let’s take a quick look at the two main techniques for rendering
    3D graphics. Once we see how that works, we’ll also see why we would want to try
    this RT route with BJS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在BJS和浏览器中实现交互式、实时RT需要什么？首先，让我们快速了解一下渲染3D图形的两种主要技术。一旦我们了解了它是如何工作的，我们也会看到为什么我们想要尝试使用BJS来尝试这条RT路线。
- en: 'When it comes to displaying 3D graphics on a 2D screen, there are two main
    approaches: **Rasterization** and **RT**. In a nutshell, Rasterization works by
    first taking the **scene geometry**, in the form of 3D vertices, and then projecting
    those to the screen in the form of many flat 2D triangles. Any pixels on the device’s
    display that happen to occupy a screen triangle’s area are sent to the pixel shader
    (also known as a fragment shader). When the fragment shader is run on a pixel,
    its final display color is computed. All of these colored pixels make up the final
    image that we see on our devices.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在2D屏幕上显示3D图形时，有两种主要方法：**光栅化**和**RT**。简而言之，光栅化通过首先将**场景几何形状**（以3D顶点的形式）投影到屏幕上，然后以许多平坦的2D三角形的形式呈现。任何占据设备显示屏幕三角形区域的像素都会被发送到像素着色器（也称为片段着色器）。当片段着色器在像素上运行时，会计算其最终的显示颜色。所有这些彩色像素组成了我们在设备上看到的最终图像。
- en: In contrast, RT renders images by addressing each pixel on the display first.
    For every pixel on the screen, a geometric **Ray** is constructed that starts
    at the camera’s position. Pointing from the camera, this **Camera Ray** then shoots
    out toward its pixel wherever it lies on the view plane (usually your screen).
    After piercing through the target pixel, the Camera Ray continues out into the
    3D scene. It will then model how a physical light ray in the real world would
    interact with its environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，RT通过首先处理显示上的每个像素来渲染图像。对于屏幕上的每个像素，都会构建一个从相机位置开始的几何**射线**。从相机指向，这个**相机射线**然后向其像素所在的位置（通常是你的屏幕）发射。穿透目标像素后，相机射线继续进入3D场景。然后它会模拟现实世界中物理光射线如何与其环境相互作用。
- en: Only now at this point in the pipeline do we consider the scene geometry. Each
    of the camera pixel rays is tested for intersection against every 3D shape in
    the scene. Wherever the ray hits a surface, the color and lighting at that location
    are recorded and a “bounce” ray is then spawned and sent in a new direction. This
    direction is dictated by the material properties of the hit surface location.
    Further, the bounce ray must check the entire scene geometry (every 3D shape or
    triangle) for any intersections just as its parent ray did, thus repeating the
    whole process again and again for however long you are willing to wait for it
    to complete. After a pixel’s camera ray and its spawned bounce rays finish interacting
    with the scene, the ray tracer reports back the final color for that pixel. Just
    like Rasterization, we end up with a screen full of colored pixels but with a
    totally different path taken to arrive at these results!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在管线中的这个阶段，我们才会考虑场景几何形状。每个相机像素射线都会与场景中的每个3D形状进行交点测试。射线击中表面时，记录该位置的颜色和光照，然后产生一个“反弹”射线，并沿新方向发送。这个方向由击中表面的材料属性决定。此外，反弹射线必须像其父射线一样检查整个场景几何形状（每个3D形状或三角形）的任何交点，因此无论你愿意等待多长时间，都会重复整个过程。当像素的相机射线及其产生的反弹射线与场景完成交互后，光线追踪器会报告该像素的最终颜色。就像光栅化一样，我们最终在屏幕上得到一满屏的彩色像素，但到达这些结果所采取的路径完全不同！
- en: Both rendering approaches have trade-offs in terms of realism and speed. **Rasterization**
    (comprising 99% of all 3D graphics) has full GPU hardware support, so it is very
    fast and efficient. There’s a drawback, though. As soon as the GPU is done projecting
    and rasterizing the scene’s triangles to the 2D screen, the surrounding 3D scene
    information is lost. To retrieve this lost global scene information, sophisticated
    techniques such as light mapping, shadow mapping, reflection probes, and others
    must be used. In other words, a lot of graphics knowledge and extra effort is
    required to get close to RT-quality visuals.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种渲染方法在真实感和速度方面都有权衡。**光栅化**（占所有3D图形的99%）拥有完整的GPU硬件支持，因此非常快且高效。然而，也存在一个缺点。一旦GPU完成将场景的三角形投影和光栅化到2D屏幕上，周围3D场景的信息就会丢失。为了检索这些丢失的全局场景信息，必须使用复杂的技术，如光照贴图、阴影贴图、反射探针等。换句话说，需要大量的图形知识和额外的工作才能接近RT质量的视觉效果。
- en: RT, on the other hand, automatically produces the ultimate in realistic graphics,
    right out of the box! Lighting effects that are difficult if not impossible with
    Rasterization just naturally fall out of the RT algorithm. However, as of 2022,
    RT is not widely supported by most GPU hardware. All CPUs can run RT programs,
    but CPUs aren’t designed to be massively parallel. Therefore, traditional CPU-based
    software RT is very slow in comparison to hardware-accelerated Rasterization on
    the GPU. Even if the RT software is moved inside a shader that runs entirely on
    the GPU (as our project here will do), several RT algorithm optimizations must
    be made in that shader, and/or a decent acceleration structure such as a **Bounding
    Volume Hierarchy** (**BVH**) is required if we can have any hope of RT at interactive
    frame rates.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，RT可以自动生成最真实的图形，直接从盒子里出来！在光栅化中难以实现甚至不可能实现的光照效果，在RT算法中自然地出现。然而，截至2022年，RT并未被大多数GPU硬件广泛支持。所有CPU都可以运行RT程序，但CPU并不是为了大规模并行而设计的。因此，与GPU上的硬件加速光栅化相比，基于传统CPU的软件RT非常慢。即使RT软件被移动到完全在GPU上运行的着色器中（正如我们在这里的项目中将要做的），在该着色器中仍需要进行几个RT算法优化，并且/或者如果希望以交互式帧率实现RT，还需要一个不错的加速结构，例如**边界体积层次**（**BVH**）。
- en: Taking the RT Route
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择RT路径
- en: So, knowing most of these trade-offs in advance (and some not until I was years-deep
    into the project – ha!), I decided to go the RT route. I’ll now fast-forward to
    when I started implementing RT with Babylon.js as the host engine. I’ll give an
    overview of the necessary setup, as well as a few code snippets to show some of
    the implementation details. Let’s jump right in!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在事先了解这些权衡（以及一些直到我项目进行多年后才了解的权衡——哈哈！），我决定选择RT路径。现在，我将快速跳到我开始使用Babylon.js作为宿主引擎实现RT的时候。我将概述必要的设置，以及一些代码片段来展示一些实现细节。让我们直接进入正题！
- en: 'Since we are now following the RT approach, we must find a way to construct
    a viewing ray from the camera through to each and every pixel on the screen. A
    common method for gaining access to the screen pixels is to create a **Full-Screen
    Post-Process Effect**, or just **Post-Process** for short (as you learned in [*Chapter
    10*](B17266_10_Final_AM.xhtml#_idTextAnchor207), *Improving the Environment with
    Lighting and Materials*). Since the post-process is a common operation, BJS has
    a really handy library wrapper that takes care of all the **WebGL** boilerplate
    code and post-process setup for us. In BJS, this helper is called an **EffectWrapper**.
    Here’s an example of a typical post-process creation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在正在遵循RT方法，我们必须找到一种方法从相机构建一个视锥体射线穿过屏幕上的每一个像素。获取屏幕像素的一个常见方法是创建一个**全屏后处理效果**，或者简称为**后处理**（正如你在[*第10章*](B17266_10_Final_AM.xhtml#_idTextAnchor207)，*通过光照和材质改善环境*中学到的）。由于后处理是一个常见操作，BJS有一个非常方便的库包装器，它为我们处理了所有的**WebGL**样板代码和后处理设置。在BJS中，这个辅助工具被称为**EffectWrapper**。以下是一个典型的后处理创建示例：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, here is where the setup gets a little tricky, not because of `pathTracingEffect`),
    we ray trace on all pixels and save their color results by using a **Render Target
    Texture** (**RTT**):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里的设置变得有点棘手，不是因为`pathTracingEffect`），我们在所有像素上进行光线追踪并保存它们的颜色结果，通过使用**渲染目标纹理**（**RTT**）：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This large `screenCopyEffect`) and then fed back through to the first post-process
    (`pathTracingEffect`) on the next animation frame. Now, our GPU ray tracer can
    use its previous result (its own pixel color history) to blend with the fresh
    new pixel color results that it is currently calculating from RT. In other words,
    it keeps blending and mixing with itself again and again. Over a couple of hundred
    frames or so, this ping-pong feedback process will quickly produce very smooth
    anti-aliased results that seem to magically converge right before our eyes! The
    last piece of the rendering setup puzzle is a final monitor output post-process
    (named `screenOutputEffect`). Its job is to perform **noise filtering**, then
    **Tone Mapping** (which you learned about in *Tone Mapping and Basic Post-Processing*
    section of[*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207)*, Improving
    the Environment with Lighting and Materials*), and then finally some **gamma correction**
    (also in *Tone Mapping and Basic Post-Processing* section of [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207)*,
    Improving the Environment with Lighting and Materials*) to produce more pleasing
    color output on digital monitors and screens.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大的`screenCopyEffect`（然后反馈到下一个动画帧的第一个后处理`pathTracingEffect`）。现在，我们的GPU光线追踪器可以使用其先前的结果（它自己的像素颜色历史）与它目前从RT计算的新鲜像素颜色结果进行混合。换句话说，它不断地与自身混合和混合。经过大约几百帧，这个ping-pong反馈过程将迅速产生非常平滑的抗锯齿结果，似乎在我们眼前神奇地收敛！渲染设置的最后一块拼图是一个最终的监视器输出后处理（命名为`screenOutputEffect`）。它的任务是执行**噪声过滤**，然后是**色调映射**（你可以在[*第10章*](B17266_10_Final_AM.xhtml#_idTextAnchor207)的*色调映射和基本后处理*部分了解），最后是一些**伽玛校正**（也在[*第10章*](B17266_10_Final_AM.xhtml#_idTextAnchor207)的*色调映射和基本后处理*部分了解），以在数字监视器和屏幕上产生更令人愉悦的颜色输出。
- en: 'All in all, we need a total of three post-processing effects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们需要总共三个后处理效果：
- en: '`pathTracingEffect`: This performs all of the RT calculations on every single
    pixel. It will take whatever pixel history given to it by the following `screenCopyEffect`
    to use for blending with itself. It outputs to **RenderTargetTexture (RTT)**,
    which is finally fed to the following post-process.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathTracingEffect`: 这个效果会在每个单独的像素上进行所有RT计算。它会使用后续的`screenCopyEffect`提供的任何像素历史信息来与自身进行混合。它输出到**RenderTargetTexture
    (RTT**)，最终被传递给后续的后处理。'
- en: '`screenCopyEffect`: This takes that supplied RTT output from the preceding
    post-process and copies/saves it to its own RTT. It then sends this saved copy
    back through to the preceding `pathTracingEffect` to use for blending with itself.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screenCopyEffect`: 这个效果接收前面后处理提供的RTT输出，并将其复制/保存到自己的RTT中。然后，它将这个保存的副本发送回前面的`pathTracingEffect`以用于与自身混合。'
- en: '`screenOutputEffect`: This post-process is responsible for the screen’s final
    color output. It takes the preceding `pathTracingEffect` **RTT** (which holds
    all the refined, **ping-pong** blended, ray-traced pixel results so far), applies
    its special filters and pixel color adjustments, and then directly outputs to
    your screen.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screenOutputEffect`: 这个后处理负责屏幕的最终颜色输出。它接收前面的`pathTracingEffect` **RTT**（其中包含迄今为止所有经过精细处理、**ping-pong**混合的光线追踪像素结果），应用其特殊的过滤器和对像素颜色的调整，然后直接输出到屏幕。'
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first two effects make up the **ping-pong buffers**, or feedback loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个效果组成了**ping-pong缓冲区**，或者说是反馈循环。
- en: Now that we have our custom system set up for progressively refining our ray-traced
    images over time and can correctly display the final pixel color output, we just
    need to do one more thing – the actual RT! Let’s switch gears for a moment and
    briefly discuss the similarities and differences between RT and **Path Tracing**
    (**PT**), and what our ray tracers/path tracers will need in order to do their
    magic in the browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的自定义系统设置了逐步细化我们的光线追踪图像的功能，并且可以正确地显示最终的像素颜色输出，我们只需要做最后一件事——实际的RT！让我们暂时转换一下思路，简要讨论一下RT和**路径追踪**（**PT**）之间的相似之处和不同之处，以及我们的光线追踪器/路径追踪器在浏览器中施展魔法需要什么。
- en: The Path to PT
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PT之路
- en: To best understand how RT and PT are related, let’s follow a brief timeline/lineage
    of RT discoveries and techniques in CG history. In 1968, Arthur Appel invented
    Ray Casting, a groundbreaking technique in which mathematical rays are shot out
    from the camera through every pixel. Whatever these camera rays hit first out
    in the 3D scene determines what we see in our image. Then, in 1979, Turner Whitted
    invented RT, which relies on Appel’s earlier 1968 Ray Casting technique but does
    it many times recursively while following the laws of optics, in order to capture
    physically accurate reflections and refractions from specular surfaces (mirrors,
    glass, and so on). Then, in 1986, James Kajiya invented PT, the ultimate evolution
    of RT. Building from all the previous RT techniques, Kajiya added Monte Carlo
    integration (random sampling and averaging) to randomly sample material BRDFs
    (diffuse surfaces in particular), in order to capture physical light effects such
    as caustics and inter-reflected diffuse surface “bounce lighting.” PT gets its
    name from tracing (random sampling) all the possible paths that light rays might
    take as they interact with different types of materials in the scene, and then
    gathering all of these light paths’ contributions to produce a ground-truth, photo-realistic
    image.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地理解RT和PT之间的关系，让我们简要回顾一下CG历史中RT发现和技术的发展历程。在1968年，亚瑟·阿佩尔发明了光线投射（Ray Casting），这是一种开创性的技术，其中数学光线从摄像机通过每个像素射出。这些摄像机光线在3D场景中首先击中的物体决定了我们在图像中看到的内容。然后，在1979年，特纳·惠特德发明了RT，它依赖于阿佩尔在1968年之前的光线投射技术，但通过遵循光学定律多次递归地执行，以捕捉从镜面（镜子、玻璃等）表面反射和折射的物理上准确的反射和折射。接着，在1986年，詹姆斯·嘉吉亚发明了PT，这是RT的最终演变。在所有之前的RT技术基础上，嘉吉亚添加了蒙特卡洛积分（随机采样和平均），以随机采样材料BRDFs（特别是漫反射表面），以捕捉诸如焦散和相互反射的漫反射表面“反弹照明”等物理光效。PT的名字来源于追踪（随机采样）光线在场景中与不同类型材料相互作用时可能采取的所有可能路径，然后收集所有这些光路径的贡献，以产生一个真实、逼真的图像。
- en: Looking at this potted RT/PT history, hopefully you can see how PT is related
    to, evolved from, and improves upon RT (and Ray Casting before that). Since I
    wanted the ultimate in realistic graphics, I chose the more sophisticated **Monte
    Carlo PT** method (1986 Kajiya-style), which captures light effects that are impossible
    with Rasterization and even older-style RT. And thanks to our hard work on setting
    up the progressively refining post-process effects system, our randomly sampled
    **Monte Carlo** PT results for all pixels can be correctly averaged and refined
    over time into a **ground-truth image**. This basically means photo-realistic
    rendering in your browser!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看了这个简化的RT/PT历史，希望你能看到PT是如何与RT（以及之前的光线投射）相关联、演变并改进的。由于我想要最逼真的图形效果，我选择了更复杂的**蒙特卡洛PT**方法（1986年嘉吉亚风格），它能够捕捉到光栅化甚至更老式的RT无法实现的灯光效果。而且，多亏了我们努力建立逐步精炼的后处理效果系统，我们随机采样的**蒙特卡洛**PT结果可以正确地平均和随着时间的推移进行细化，最终形成**真实图像**。这基本上意味着在你的浏览器中实现逼真的渲染！
- en: PT in the Browser
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器中的PT
- en: Now, let’s discuss scene geometry and what PT requires in terms of how the scene
    is defined. We have two options for telling the PT fragment shader what is in
    the scene. The first and easiest option is to simply write a GLSL function in
    the fragment shader itself that defines the entire scene’s geometry as part of
    the shader. All objects/shapes are hardcoded and listed one after the other. This
    is fine if the number of shapes/objects in your scene does not exceed 20 or so,
    but as soon as you get into the hundreds of objects or, worse yet, use a typical
    model with thousands of triangles (with each triangle being tested by every ray!),
    our path tracer would grind to a halt. To speed things up tremendously and keep
    our PT interactive, we need to use an acceleration structure, such as a **BVH**. A
    **BVH** is basically just a binary tree of bounding boxes that tightly surrounds
    the triangular model(s). When testing for intersection, rays can skip large portions
    of the model if they miss some of the larger bounding boxes. To see how a BVH
    is built, check out my custom BVH builder code at [https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/BVH_Fast_Builder.js](https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/BVH_Fast_Builder.js).
    Recall that the path tracer (inside the fragment shader) must have access to the
    entire scene, and since we can’t fit most large scenes containing thousands of
    triangles into shader **uniforms** (there is a hard limit on most graphics cards),
    we tightly pack the BVH and all its bounding boxes into a data texture. This BVH
    texture will give our GPU path tracer quick and easy access to the entire optimized
    scene geometry (via simple texture lookups).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论场景几何以及PT在定义场景方面需要什么。我们有两种方法来告诉PT片段着色器场景中有什么。第一种也是最简单的方法是在片段着色器本身中简单地编写一个GLSL函数，将整个场景的几何形状作为着色器的一部分来定义。所有对象/形状都是硬编码的，并依次列出。如果场景中形状/对象的数量不超过20个左右，这没问题，但一旦你涉及到数百个对象，或者更糟糕的是，使用一个典型的具有数千个三角形（每个三角形都被每条射线测试！）的模型，我们的路径追踪器就会停止工作。为了极大地加快速度并保持PT的交互性，我们需要使用加速结构，例如**BVH**。**BVH**基本上就是一个紧密包围三角形模型（s）的边界框的二叉树。在测试交点时，如果射线错过了一些较大的边界框，它们可以跳过模型的大部分区域。要了解如何构建BVH，请查看我在[https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/BVH_Fast_Builder.js](https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/BVH_Fast_Builder.js)上的自定义BVH构建器代码。回想一下，路径追踪器（在片段着色器内部）必须能够访问整个场景，而且由于我们无法将包含数千个三角形的绝大多数大型场景放入着色器**uniforms**（大多数显卡都有一个硬性限制），我们将BVH及其所有边界框紧密打包到一个数据纹理中。这个BVH纹理将使我们的GPU路径追踪器能够快速轻松地访问整个优化后的场景几何形状（通过简单的纹理查找）。
- en: 'Next, all ray tracers and path tracers require a shape intersection library
    to have ray intersection testing with a wide variety of primitive shapes, such
    as spheres, boxes, and triangles. Historically, when RT was just coming into existence,
    computers were only fast enough to intersect rays with simple mathematical shapes.
    Examples of these shapes include spheres, cylinders, cones, and planes, and they
    all belong to a class of shapes known as quadrics. The solution for where a ray
    intersects these quadric shapes is handled by simply solving the quadratic equation
    for that shape. That’s why, when you look at more historical ray-traced images,
    the scenes only contain checkered planes and spheres (or other quadrics) of different
    sizes and materials. In these early years of RT, the math for intersecting rays
    with more complex triangle geometry (like what we use today) was well understood,
    but it would take many years for computers to get fast enough to be able to handle
    testing rays with an entire polygonal 3D model with thousands of triangles. Over
    the last 7 years, I have collected almost every routine I could find for determining
    the intersection of rays against various shapes. Here’s a link to my `PathTracingCommon.js`
    file, which contains all of these intersection routines: [https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/PathTracingCommon.js](https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/PathTracingCommon.js).
    Equally important and also included in this library file are the functions that
    handle **Monte Carlo PT**-style random sampling of different light source types
    (point, spot, directional, area, and HDRI) and material types (BRDFs from the
    *Tone Mapping and Basic Post-Processing of* [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207)*,
    Improving the Environment with Lighting and Materials*) that rays might interact
    with in any given scene.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，所有的光线追踪器和路径追踪器都需要一个形状交点库来进行与各种原始形状的射线交点测试，例如球体、盒子和三角形。在RT刚刚出现的时候，计算机的速度足够快，可以与简单的数学形状相交。这些形状的例子包括球体、圆柱体、圆锥体和平面，它们都属于称为二次曲面的形状类别。射线与这些二次曲面形状相交的解决方案是通过简单地解该形状的二次方程来处理的。这就是为什么当你查看更早期的光线追踪图像时，场景中只包含棋盘格平面和不同大小和材料的球体（或其他二次曲面）。在RT的早期几年，对于与更复杂的三角形几何体（如我们今天使用的）相交的数学是相当理解的，但需要很多年计算机才能足够快，能够处理与整个由数千个三角形组成的多边形3D模型进行射线测试。在过去的7年里，我收集了几乎所有我能找到的用于确定射线与各种形状相交的例程。以下是我`PathTracingCommon.js`文件的链接，其中包含所有这些交点例程：[https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/PathTracingCommon.js](https://github.com/erichlof/Babylon.js-PathTracing-Renderer/blob/main/js/PathTracingCommon.js)。同样重要的是，这些处理**蒙特卡洛PT**风格不同光源类型（点、聚光灯、方向性、区域和HDRI）和材料类型（来自*第10章*[*章节
    10*](B17266_10_Final_AM.xhtml#_idTextAnchor207)*，通过光照和材料改善环境*)的函数也包含在这个库文件中。
- en: Further Reading
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Well, unfortunately, there isn’t enough space in this more general, overview-style
    article to go into detail about my **GLSL** PT shader code (where all the RT/PT
    algorithms happen). However, if you want to see some nice examples of RT/PT in
    GLSL (where I have learned from too), check out a couple of these shaders on **Shadertoy**:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，很遗憾，在这篇更通用的概述风格文章中，没有足够的空间来详细说明我的**GLSL** PT着色器代码（所有RT/PT算法都在这里发生）。然而，如果你想看看一些GLSL中RT/PT的精彩示例（我也从中学习了很多），请查看Shadertoy上的这些着色器：
- en: '[https://www.shadertoy.com/view/Xtt3DB](https://www.shadertoy.com/view/Xtt3DB)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/Xtt3DB](https://www.shadertoy.com/view/Xtt3DB)'
- en: '[https://www.shadertoy.com/view/XsSSWW](https://www.shadertoy.com/view/XsSSWW)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/XsSSWW](https://www.shadertoy.com/view/XsSSWW)'
- en: '[https://www.shadertoy.com/view/XdcfRr](https://www.shadertoy.com/view/XdcfRr)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/XdcfRr](https://www.shadertoy.com/view/XdcfRr)'
- en: '[https://www.shadertoy.com/view/tddSz4](https://www.shadertoy.com/view/tddSz4)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/tddSz4](https://www.shadertoy.com/view/tddSz4)'
- en: 'And if you would like to go much deeper into the theory and practice of RT
    and PT, I can think of no better resource than **Scratchapixel**. This amazing
    website contains everything you need to know about Rasterization, RT, PT, and
    graphics in general: [https://www.scratchapixel.com/](https://www.scratchapixel.com/).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入探讨RT和PT的理论与实践，我认为没有比Scratchapixel更好的资源了。这个惊人的网站包含了你需要了解的一切关于光栅化、RT、PT以及一般图形的知识：[https://www.scratchapixel.com/](https://www.scratchapixel.com/).
- en: 'Lastly, to see all of the pieces of this article come together, check out the
    Babylon.js **PathTracing** Renderer: [https://github.com/erichlof/Babylon.js-PathTracing-Renderer](https://github.com/erichlof/Babylon.js-PathTracing-Renderer)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了看到这篇文章的所有部分融合在一起，请查看 Babylon.js **路径追踪** 渲染器：[https://github.com/erichlof/Babylon.js-PathTracing-Renderer](https://github.com/erichlof/Babylon.js-PathTracing-Renderer)
- en: This is our ongoing project, which has several clickable demos that showcase
    different areas of PT. As with the Space-Truckers OSS project, this BJS **PathTracing**
    Renderer project is open for Pull Requests. If you start getting into this fascinating
    world of RT and PT, we would love to see your contributions! A word of warning
    though – once you start down the road of RT and PT, it can be hard to stop!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们正在进行的项目，其中包含几个可点击的演示，展示了 PT 的不同领域。与 Space-Truckers OSS 项目一样，这个 BJS **路径追踪**
    渲染器项目对 Pull Requests 开放。如果你开始涉足这个令人着迷的实时渲染（RT）和路径追踪（PT）的世界，我们非常乐意看到你的贡献！不过，有一个警告——一旦你走上了
    RT 和 PT 的道路，就很难停下来！
- en: Happy rendering!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 享受渲染！
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve seen a lot of new things on our trip through the BJS *Metatropolis*. We’ve
    heard of new wonders under construction but ready for business, such as **VR**
    and **AR** with **WebXR**. To help developers make use of these wonders, we learned
    about how Babylon.js offers the **WebXRExperienceHelper**. Working in conjunction
    with the **FeaturesManager**, it allows developers to code with confidence against
    a rapidly evolving and changing standard.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们穿越 BJS **元都市** 的旅程中，我们看到了许多新事物。我们听说了一些正在建设中但已准备营业的新奇事物，例如带有 **WebXR** 的 **VR**
    和 **AR**。为了帮助开发者利用这些奇迹，我们了解了 Babylon.js 提供的 **WebXRExperienceHelper**。与 **FeaturesManager**
    协同工作，它允许开发者有信心地针对快速演变和变化的标准进行编码。
- en: Babylon.js is a project that places backward compatibility as one of its cornerstone
    principles, and so as hardware improves – or more products open up their hardware
    to **WebXR** APIs – capabilities will “light up” as browser vendors add support.
    While it would be great to include iOS (and **WebKit**) in the supported application
    list today for **WebXR**, and while we can lament for a world that could have
    been, applications using Babylon.js will be ready to best take advantage when
    that day finally does arrive.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 是一个将向后兼容性作为其基石原则之一的项目，因此随着硬件的改进——或者更多产品向 **WebXR** API 开放其硬件——功能将随着浏览器供应商添加支持而“点亮”。虽然今天将
    iOS（以及 **WebKit**）包括在支持的软件列表中将是件好事，而且虽然我们可以哀叹一个本可以存在的世界，但使用 Babylon.js 的应用程序将准备好在那天最终到来时充分利用这一机会。
- en: Until that happens, developers and designers have several potential approaches
    that will ideally allow the greatest code reuse and lowest friction to implement
    and maintain. The **Babylon.js Native** project is a collection of tools and techniques
    that people working on cross-platform or Native projects can leverage to gain
    maximum productivity and effectiveness. These tools fall into a spectrum going
    from full-on bare-metal BJS Native to the “vanilla” BJS that we’ve come to know
    and love. In between, **Babylon React Native** provides a way for developers already
    using React and React Native to incorporate BJS into their applications, while
    toward the other end of the spectrum, the hosting of a **WebGL** context in a
    **WebView** provides another avenue for potential native device application integration
    in arbitrary software apps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 直到那时，开发者和设计师有几种潜在的方法，这些方法理想上允许最大的代码重用和最低的摩擦来实现和维护。**Babylon.js Native** 项目是一系列工具和技术，跨平台或原生项目的工作者可以利用这些工具和技术来获得最大的生产力和效率。这些工具涵盖了从全功能的裸机
    BJS Native 到我们熟知并喜爱的“纯”BJS 的光谱。在两者之间，**Babylon React Native** 为已经使用 React 和 React
    Native 的开发者提供了一种将 BJS 集成到他们的应用程序中的方法，而在光谱的另一端，将 **WebGL** 上下文托管在 **WebView** 中为在任意软件应用程序中集成潜在的本地设备应用程序提供了另一条途径。
- en: Babylon.js is more than about making games such as Space-Truckers. As a general
    3D application development platform, BJS gives us access to entire universes of
    possibilities, waiting to be unlocked by curious explorers. Perhaps one of those
    curious explorers will be you! Every coin has a flip side, and the flip side of
    having so many possibilities is that it’s very difficult to give a good account
    of the more interesting ones in the same context as the rest of our journey with
    Space-Truckers. That is where our two guides come into play. As long-time explorers
    into some of these other provinces of BJS, Andrei Stepanov and Erich Loftis have
    much to share with the community.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js不仅仅关于制作像《太空卡车》这样的游戏。作为一个通用的3D应用开发平台，BJS为我们打开了整个宇宙的可能性，等待好奇的探险者去解锁。也许那些好奇的探险者中会有你！每一枚硬币都有其另一面，拥有如此多的可能性意味着很难在与其他《太空卡车》旅程的相同背景下，对其中更有趣的部分给出很好的描述。这正是我们的两位向导发挥作用的地方。作为BJS其他一些领域的长期探险者，Andrei
    Stepanov和Erich Loftis有很多东西可以与社区分享。
- en: Through his **Babylon Viewer 3D WordPress Plugin** and his extensive and detailed
    example site, [babylonpress.org](http://babylonpress.org), which shows off the
    viewer, Andrei has opened our eyes to how easy it can be to use **shortcodes**
    to include 3D models as a content editor once the proper script references have
    been injected into the CMS page. By telling us of his journey into PT/RT, Erich
    Loftis has, in turn, opened our eyes to the innovative history of graphics rendering
    technologies and how they’re used in the world of computer graphics.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过他的**Babylon Viewer 3D WordPress插件**以及他广泛而详细的示例网站[babylonpress.org](http://babylonpress.org)，该网站展示了查看器，Andrei让我们看到了如何使用**短代码**将3D模型作为内容编辑器包含进来，一旦在CMS页面中注入了适当的脚本引用。通过告诉我们他进入PT/RT的旅程，Erich
    Loftis反过来也让我们看到了图形渲染技术的创新历史以及它们在计算机图形世界中的应用。
- en: Each of them has given us their unique insights and approaches to their respective
    topics and helped to guide us to the Terminal Destination for this book. Although
    this is the end of one journey, it is just the beginning of another. Unlike this
    book though, the path for this new journey – your journey – isn’t captured or
    written out anywhere, nor is there any pre-determination on what route that path
    will take. Where this path takes and what it entails is entirely up to you, but
    wherever that destination lies, whether shrouded in mist or lit up with a beacon,
    you’re not alone. The BJS community is there to assist, support, and, of course,
    guide folks. The BJS forums at [https://forum.babylonjs.com](https://forum.babylonjs.com)
    are the best place to go to ask questions, meet folks like Erich and Andrei, and
    learn from other community members.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 他们每个人都为我们提供了他们各自主题的独特见解和方法，帮助我们指引到这本书的终点站。尽管这是旅程的结束，但它只是另一段旅程的开始。然而，与这本书不同的是，这段新旅程——你的旅程——并没有被记录或写下来，也没有任何预先确定的路线。这条路线将走向何方，它包含什么，完全取决于你。无论目的地是笼罩在雾中还是被灯塔照亮，你并不孤单。BJS社区在那里帮助你、支持你，当然，引导大家。BJS论坛[https://forum.babylonjs.com](https://forum.babylonjs.com)是提问、遇见像Erich和Andrei这样的人，以及从其他社区成员那里学习的好地方。
- en: Good luck on your journey – the world of web-based 3D and the BJS community
    awaits!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你在旅程中好运——基于Web的3D世界和BJS社区都在等待着你！
