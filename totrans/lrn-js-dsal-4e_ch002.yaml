- en: 1 Introducing Data Structures and Algorithms in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 在 JavaScript 中介绍数据结构和算法
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“learning-javascript-dsa-4e”频道）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: '**JavaScript** is an immensely powerful language. It is one of the most popular
    languages in the world and is one of the most prominent languages on the internet.
    For example, GitHub (the world''s largest code host, available at [https://github.com](https://github.com))
    hosts over 300,000 JavaScript repositories at the time of writing (the largest
    number of active repositories available on GitHub are in JavaScript; refer to
    [http://githut.info](http://githut.info)). The number of projects in JavaScript
    on GitHub grows every year.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript** 是一种功能强大的语言。它是世界上最流行的语言之一，也是互联网上最突出的语言之一。例如，GitHub（世界上最大的代码托管平台，网址为
    [https://github.com](https://github.com)）在撰写本文时托管了超过 300,000 个 JavaScript 仓库（GitHub
    上活跃的仓库中，JavaScript 仓库数量最多；请参阅 [http://githut.info](http://githut.info)）。JavaScript
    在 GitHub 上的项目数量每年都在增长。'
- en: JavaScript is an essential skill for any web developer. It offers a convenient
    environment for learning data structures and algorithms, requiring only a text
    editor or browser to get started. More importantly, JavaScript's widespread use
    in web development allows you to directly apply this knowledge to build efficient,
    scalable web applications, optimizing performance and handling complex tasks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是任何网页开发人员必备的技能。它提供了一个方便的环境来学习数据结构和算法，只需要一个文本编辑器或浏览器就可以开始。更重要的是，JavaScript
    在网页开发中的广泛应用，允许你直接将此知识应用于构建高效、可扩展的网页应用程序，优化性能并处理复杂任务。
- en: Data structures and algorithms are fundamental building blocks of software development.
    Data structures provide ways to organize and store data, while algorithms define
    the operations performed on that data. Mastering these concepts is crucial for
    creating well-structured, maintainable, and high-performing JavaScript code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和算法是软件开发的基本构建块。数据结构提供了组织和存储数据的方法，而算法定义了对这些数据执行的操作。掌握这些概念对于创建结构良好、易于维护和性能高的
    JavaScript 代码至关重要。
- en: 'In this chapter, we''ll cover the essential JavaScript syntax and functionalities
    needed to start building our own data structures and algorithms. Additionally,
    we''ll introduce TypeScript, a language that builds upon JavaScript and offers
    enhanced code safety, structure, and tooling. This will enable us to create data
    structures and algorithms using both JavaScript and TypeScript, showcasing their
    respective strengths. We will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍开始构建自己的数据结构和算法所需的必要 JavaScript 语法和功能。此外，我们还将介绍 TypeScript，这是一种基于 JavaScript
    的语言，它提供了增强的代码安全性、结构和工具。这将使我们能够使用 JavaScript 和 TypeScript 创建数据结构和算法，展示它们各自的优势。我们将涵盖：
- en: The importance of data structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构的重要性
- en: Why algorithms matter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么算法很重要
- en: Why companies ask for these concepts during interviews
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么公司在面试中要求这些概念
- en: Why choose JavaScript to learn data structures and algorithms
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 JavaScript 来学习数据结构和算法
- en: Setting up the environment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: JavaScript fundamentals
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 基础
- en: '**TypeScript** fundamentals'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript** 基础'
- en: The importance of data structures
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构的重要性
- en: A data structure is a way to organize and store data in a computer's memory,
    enabling the data to be efficiently accessed and modified.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是一种在计算机内存中组织和存储数据的方式，使数据能够被高效地访问和修改。
- en: Think about data structures as containers designed to hold specific types of
    information, that have their own way of arranging and managing the information.
    For example, in your home, you cook food in the kitchen, sleep in the bedroom,
    and take a shower in the bathroom. Each place in a house or apartment is designed
    with a specific goal for certain tasks so we can keep our home organized.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据结构视为设计用来存储特定类型信息的容器，它们有自己安排和管理信息的方式。例如，在你的家中，你在厨房烹饪食物，在卧室睡觉，在浴室洗澡。房屋或公寓中的每个地方都是为了完成特定任务而设计的，以便我们可以保持家庭整洁有序。
- en: In the real world, data can often be overly complex, due to factors such as
    volume, various forms (numbers, dates, text, images, emails), and the speed that
    data is generated, among other factors. Data structures bring order to this chaos,
    allowing computers to handle vast amounts of information systematically and efficiently.
    Think of it like a well-organized library compared to a very large pile of books.
    Finding a specific book is easier in the library as the books are organized by
    genre and by author (alphabetically).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，数据往往可能过于复杂，这归因于诸如数量、各种形式（数字、日期、文本、图像、电子邮件）以及数据生成速度等因素。数据结构为这种混乱带来了秩序，使得计算机能够系统且高效地处理大量信息。想象一下，这就像一个组织良好的图书馆与一大堆书籍相比。在图书馆中，由于书籍按类型和作者（按字母顺序）组织，因此找到特定书籍要容易得多。
- en: Good data structure choices help programs perform consistently regardless of
    the amount of data being processed. Imagine needing to store data for the weather
    forecast for 10 days versus 10 years. The use of the correct data structure can
    make a difference between an algorithm crashing or being able to scale.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的数据结构选择有助于程序在处理的数据量不同的情况下保持一致的性能。想象一下，需要存储10天或10年的天气预报数据。使用正确的数据结构可以在算法崩溃或能够扩展之间产生差异。
- en: And finally, a data structure can drastically impact how easy it is to write
    algorithms that work with that data. For example, finding the shortest route on
    a map can be efficiently solved using a graph data structure that shows which
    cities are connected by what distances, rather than an unordered array of city
    names.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据结构可以极大地影响编写与该数据一起工作的算法的难易程度。例如，使用显示城市之间距离的图数据结构来找到地图上的最短路线可以高效地解决，而不是使用无序的城市名称数组。
- en: Why algorithms matter
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么算法很重要
- en: Computers are powerful tools, but their intelligence is derived from the instructions
    we provide. Algorithms are the sets of rules and procedures that guide a computer's
    actions, enabling it to solve problems, make decisions, and perform complex tasks.
    In essence, algorithms are the language through which we communicate with computers,
    transforming them from mere machines into intelligent problem-solvers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是强大的工具，但它们的智能源于我们提供的指令。算法是一系列规则和程序，指导计算机的行动，使其能够解决问题、做出决策和执行复杂任务。本质上，算法是我们与计算机沟通的语言，将它们从单纯的机器转变为智能问题解决者。
- en: Algorithms can turn tasks into repeatable and automated processes. If you need
    to generate a report every day at work, this is a task that can be automated using
    an algorithm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可以将任务转化为可重复和自动化的过程。如果你需要在工作中每天生成一份报告，那么这是一个可以通过算法自动化的任务。
- en: Algorithms are around us every day, from search engines to social networks,
    to self-driving cars. Algorithms and data structures are what make them function.
    Understanding data structures and algorithms unlocks the ability to create and
    innovate in the technology world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 算法无处不在，从搜索引擎到社交网络，再到自动驾驶汽车。算法和数据结构是它们运作的基础。理解数据结构和算法能够解锁在技术世界中创造和创新的能力。
- en: As software developers, writing algorithms and manipulating data are core aspects
    of our work. This is precisely why companies emphasize these concepts in job interviews
    – they are essential skills for assessing a candidate's problem-solving abilities
    and their potential to contribute effectively to software development projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，编写算法和处理数据是我们工作的核心方面。这正是为什么公司在招聘面试中强调这些概念——它们是评估应聘者问题解决能力和他们为软件开发项目有效贡献潜力的关键技能。
- en: Why companies ask for these concepts during interviews
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么公司在面试中要求这些概念
- en: 'There are many reasons why companies focus on data structures and algorithms
    concepts during job interviews, even if you are not going to use some of these
    concepts during daily tasks, including:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 公司在招聘面试中关注数据结构和算法概念的原因有很多，即使你在日常任务中不会使用这些概念，包括：
- en: 'Problem-solving skills: data structures and algorithms are a great tool to
    evaluate the candidate''s problem-solving abilities. They can be used to evaluate
    how a person approaches unfamiliar problems, breaks them down into smaller tasks
    and designs a solution.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题解决技能：数据结构和算法是评估应聘者问题解决能力的优秀工具。它们可以用来评估一个人如何处理不熟悉的问题，将它们分解成更小的任务，并设计解决方案。
- en: 'Coding proficiency: companies can evaluate how candidates translate their solution
    into clean and efficient code, how candidates choose the appropriate data structure
    for the problem, design an algorithm with the correct logic, consider edge cases
    and optimize their code.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码能力：公司可以评估候选人如何将解决方案转化为干净高效的代码，候选人如何为问题选择合适的数据结构，设计具有正确逻辑的算法，考虑边缘情况并优化代码。
- en: 'Software performance: a strong understanding of data structures and algorithms
    translates directly to successful delivery of every development task, such as
    designing scalable solutions by choosing the right data structure and algorithms,
    especially when dealing with large datasets. In the realm of Big Data, where you''re
    likely dealing with massive datasets, it is crucial that your solution not only
    functions correctly but also operates efficiently at scale. Performance optimization
    often relies on selecting the optimal data structure or tweaking existing algorithms.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件性能：对数据结构和算法的深刻理解直接转化为成功交付每个开发任务，例如通过选择合适的数据结构和算法来设计可扩展的解决方案，尤其是在处理大量数据集时。在处理大数据集的大数据领域，你的解决方案不仅需要正确运行，而且还需要在规模上高效运行。性能优化通常依赖于选择最佳的数据结构或调整现有算法。
- en: 'Debugging and troubleshooting: A solid grasp of data structures and algorithms
    can help engineers pinpoint where issues might occur within their code.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和故障排除：对数据结构和算法的扎实掌握可以帮助工程师确定代码中可能出现问题的位置。
- en: 'Ability to learn and adapt: technology is always evolving, as well as programming
    languages and frameworks, however, data structures and algorithms concepts remain
    fundamental throughout the years. That is one of the reasons we often say these
    concepts are part of the basic knowledge about computer science. And once you
    learn the concepts in one language, you can easily adapt to a different programming
    language. This helps companies test if a person can adapt to changing requirements,
    which is essential in this industry.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和适应能力：技术始终在发展，编程语言和框架也是如此，然而，数据结构和算法的概念在多年间一直保持基本。这就是我们经常说这些概念是计算机科学基础知识之一的原因。一旦你学会了这些概念，你就可以轻松地适应不同的编程语言。这有助于公司测试一个人是否能够适应不断变化的要求，这对于这个行业至关重要。
- en: 'Communication: usually, when companies present a problem to be solved using
    data structures and algorithms, they are not looking for the eventual answer,
    but the process that the candidate follows to get to the definitive answer. Companies
    can evaluate how candidates are able to explain their thought process and reason
    behind their decision-making approach; and the candidate''s ability to discuss
    different trade-offs involved in choosing different data structures and algorithms
    to resolve the program. This can be used to evaluate if a person can collaborate
    within a team setting and if the candidate can clearly communicate a message.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沟通：通常，当公司提出使用数据结构和算法解决的问题时，他们并不是在寻找最终的答案，而是在寻找候选人到达最终答案的过程。公司可以评估候选人如何解释他们的思维过程和决策背后的原因；以及候选人在讨论选择不同数据结构和算法以解决程序时涉及的不同权衡的能力。这可以用来评估一个人是否能够在团队环境中协作，以及候选人是否能够清楚地传达信息。
- en: Of course, these are only some of the factors that companies will evaluate,
    and domain-specific knowledge, experience and cultural fit are also crucial factors
    when choosing the right candidate for a job position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些只是公司评估的一些因素，而特定领域的知识、经验和文化适应性也是选择合适职位候选人时的关键因素。
- en: Why choose JavaScript to learn data structures and algorithms?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 JavaScript 来学习数据结构和算法？
- en: JavaScript is one of the most popular programming languages in the world, according
    to various industry surveys, making it an excellent choice if you are already
    familiar with the basics of programming. The thriving JavaScript community and
    the abundance of online resources create a supportive and dynamic environment
    for learning, collaborating, and advancing your career as a JavaScript developer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据各种行业调查，JavaScript 是世界上最受欢迎的编程语言之一，如果你已经熟悉编程的基础知识，那么它是一个很好的选择。繁荣的 JavaScript
    社区和丰富的在线资源为学习、协作和提升 JavaScript 开发者职业生涯提供了一个支持性和动态的环境。
- en: JavaScript is also a beginner friendly language and you do not need to worry
    about complex memory management concepts that exist in other languages such as
    C++. This is extremely helpful especially when learning data structures like linked
    lists, trees, and graphs, which are dynamic data structures due to their ability
    to grow or shrink in size during program execution (runtime), and when using JavaScript,
    you can focus on the data structure concepts, without mixing with memory management
    controls.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也是一种适合初学者的语言，您无需担心像 C++ 这样的其他语言中存在的复杂内存管理概念。这对于学习像链表、树和图这样的数据结构非常有帮助，这些数据结构由于其能够在程序执行（运行时）期间增长或缩小尺寸的能力而具有动态性，并且在使用
    JavaScript 时，您可以专注于数据结构概念，而无需与内存管理控制混合。
- en: As JavaScript is used for web development, learning data structures and algorithms
    with JavaScript allows you to directly apply your skills to building interactive
    web applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 用于网页开发，使用 JavaScript 学习数据结构和算法可以使您直接将这些技能应用于构建交互式网页应用。
- en: 'However, there is one big disadvantage of using JavaScript: the lack of strict
    typing that exists in other languages such as C++ and Java. JavaScript is a dynamically
    typed language, meaning you do not need to explicitly declare the data type of
    variables. When working with data structures, we need to pay attention to not
    mix data types within the same data structure as it can lead to subtle errors.
    Typically, when working with data structures, it is considered best practice to
    ensure all data within the same structure is of the same type. We will take care
    of this gap by always using the same data type for the same data structure instance
    throughout this book and we will also resolve the lack of strict typing by providing
    the source code in **TypeScript**, which extends JavaScript by adding types to
    the language.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 JavaScript 的一大缺点是它缺乏像 C++ 和 Java 这样的其他语言中存在的严格类型。JavaScript 是一种动态类型语言，这意味着您不需要显式声明变量的数据类型。在处理数据结构时，我们需要注意不要在同一个数据结构中混合数据类型，因为这可能导致微妙的错误。通常，当处理数据结构时，确保同一结构内的所有数据类型相同被认为是最佳实践。在本书中，我们将通过始终为同一数据结构实例使用相同的数据类型来弥补这一差距，并且我们还将通过提供扩展
    JavaScript 并向语言添加类型的 **TypeScript** 源代码来解决缺乏严格类型的问题。
- en: 'And it is important to remember: the best language is the one you are most
    comfortable using and that motivates you to learn. This book will present different
    data structures and algorithms using JavaScript and TypeScript, and you can always
    adapt the concepts to another programming language as well.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并且重要的是要记住：最好的语言是您最舒适使用并且能激励您学习的语言。本书将使用 JavaScript 和 TypeScript 展示不同的数据结构和算法，您也可以将这些概念适应到其他编程语言中。
- en: Setting up the environment
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: One of the pros of the JavaScript language compared to other languages is that
    you do not need to install or configure a complicated environment to get started
    with it. To follow the examples in this book, you will need to download Node.js
    from [https://nodejs.org](https://nodejs.org) so we can execute the source code.
    On the download page, you will find detailed steps to download and install Node.js
    in your operating system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，JavaScript 语言的优点之一是您无需安装或配置复杂的环境即可开始使用。为了跟随本书中的示例，您需要从 [https://nodejs.org](https://nodejs.org)
    下载 Node.js，这样我们才能执行源代码。在下载页面，您将找到在您的操作系统上下载和安装 Node.js 的详细步骤。
- en: As a rule of thumb, always download the *LTS* (*Long Term Support*) version,
    which is often used by enterprise companies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，始终下载 *LTS* (*长期支持*) 版本，这通常是企业公司所使用的。
- en: While JavaScript can run in both browsers and Node.js, the latter provides a
    more streamlined and focused environment for studying data structures and algorithms.
    Node.js eliminates browser-specific complexities, offers powerful debugging tools,
    and facilitates a more direct approach to learning these core concepts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JavaScript 可以在浏览器和 Node.js 中运行，但后者为学习数据结构和算法提供了一个更流畅和专注的环境。Node.js 消除了浏览器特定的复杂性，提供了强大的调试工具，并促进了学习这些核心概念的更直接的方法。
- en: The source code for this book is also available in TypeScript, which offers
    enhanced type safety and structure. To run TypeScript code, including the examples
    in this book, we'll need to transpile it into JavaScript, a process we will cover
    in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码也以 TypeScript 格式提供，它提供了增强的类型安全和结构。要运行 TypeScript 代码，包括本书中的示例，我们需要将其转换为
    JavaScript，这个过程我们将在详细说明。
- en: Installing a code editor or IDE
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装代码编辑器或 IDE
- en: We also need an editor or **IDE** (*Integrated Development Environment*) to
    be able to develop an application in a comfortable environment. For the examples
    in this book, the author used **Visual Studio Code** (**VSCode**), a free and
    open-source editor. However, you can use any editor of your choice (Notepad++,
    WebStorm, and other editors or IDEs available on the market).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个编辑器或 **IDE** (*集成开发环境*) 来在舒适的环境中开发应用程序。对于本书的示例，作者使用了 **Visual Studio
    Code** (**VSCode**)，这是一个免费的开源编辑器。但是，您可以使用任何您选择的编辑器（Notepad++、WebStorm 以及市场上可用的其他编辑器或
    IDE）。
- en: You can download the **VSCode** installer for your operating system at [https://code.visualstudio.com](https://code.visualstudio.com).
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以在 [https://code.visualstudio.com](https://code.visualstudio.com) 下载适用于您操作系统的
    **VSCode** 安装程序。
- en: Now that we have everything we need, we can start coding our examples!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，我们可以开始编写我们的示例了！
- en: JavaScript Fundamentals
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 基础知识
- en: Before we start diving into the various data structures and algorithms, let's
    have a quick overview of the JavaScript language. This section will present the
    JavaScript fundamental concepts required to implement the algorithms we will create
    in the subsequent chapters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入各种数据结构和算法之前，让我们快速了解一下 JavaScript 语言。本节将介绍实现后续章节中我们将创建的算法所需的 JavaScript
    基本概念。
- en: Hello World
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hello World
- en: We will begin with the classic "Hello, World!" example, a simple program that
    displays the message "Hello, World!".
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典的 "Hello, World!" 示例开始，这是一个简单的程序，显示消息 "Hello, World!"。
- en: 'Let''s create our first example together. Follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起创建第一个示例。请按照以下步骤操作：
- en: Create a folder named `javascript-datastructures-algorithms`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `javascript-datastructures-algorithms` 的文件夹。
- en: Inside it, create a folder named `src` (source, where we will create our files
    for this book).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个名为 `src` 的文件夹（源文件夹，我们将为本书创建文件）。
- en: Inside the `src` folder, create a folder named `01-intro`
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹中，创建一个名为 `01-intro` 的文件夹
- en: 'We can place all the examples for this chapter inside this directory. Now let''s
    create a `Hello, World` example. To do so, create a file named `01-hello-variables.js`.
    Inside the file, add the code below:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将本章的所有示例都放在这个目录中。现在让我们创建一个 `Hello, World` 示例。为此，创建一个名为 `01-hello-variables.js`
    的文件。在文件中，添加以下代码：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run this example, you can use the default operating system terminal or command
    prompt (or in case you are using Visual Studio Code, open the built-in terminal)
    and execute the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，您可以使用默认的操作系统终端或命令提示符（或者如果您正在使用 Visual Studio Code，请打开内置终端）并执行以下命令：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see the "`Hello, World!`" output, as shown in the image below:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如以下图片所示的 "`Hello, World!`" 输出：
- en: '![Figure 1.1 – Visual Studio Code with JavaScript Hello, World! example](img/file1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Visual Studio Code 与 JavaScript Hello, World! 示例](img/file1.png)'
- en: Figure 1.1 – Visual Studio Code with JavaScript Hello, World! example
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Visual Studio Code 与 JavaScript Hello, World! 示例
- en: For every source file for this book, you will see in the first line the path
    of the file, followed by the source code we will create together, and the file
    will end with the command we can use to see the output in the terminal.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于本书的每个源文件，你将在第一行看到文件的路径，然后是我们将一起创建的源代码，文件将以可以在终端中查看输出的命令结束。
- en: Variables and data types
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: 'There are three ways of declaring a variable in JavaScript:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中有三种声明变量的方式：
- en: '`var`: declares a variable, and it is optional to initialize it with a value.
    This is the oldest way to declare variables in JavaScript.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var`: 声明一个变量，并且可以选择初始化它。这是在 JavaScript 中声明变量的最古老方式。'
- en: '`let`: declares a local variable, block-scoped (this means the variable is
    only accessible within the specific block of code such as inside a loop or conditional
    statement), and it is also optional to initialize it with a value. For our algorithms,
    this will be our preferred way due to its more predictable behavior.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let`: 声明一个局部变量，块级作用域（这意味着变量仅在特定的代码块内可访问，例如在循环或条件语句内），并且也可以选择初始化它。对于我们的算法，这将是我们的首选方式，因为它具有更可预测的行为。'
- en: '`const`: declares a read-only constant. It is mandatory to initialize it, and
    we will not be able to re-assign it.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const`: 声明一个只读常量。它必须初始化，并且我们无法重新分配它。'
- en: 'Let''s see a few examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个示例：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Where:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：
- en: In the first line, we have an example of how to declare a variable in JavaScript
    (the legacy way, before modern JavaScript). Although it is not necessary to use
    the `var` keyword declaration, it is a good practice to always specify when we
    declare a new variable.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们有一个如何在JavaScript中声明变量（传统方式，在现代JavaScript之前）的例子。尽管使用`var`关键字声明不是必需的，但始终指定我们声明新变量是一个好习惯。
- en: In the second line, we updated an existing variable. JavaScript is not a strongly
    typed language. This means you can declare a variable, initialize it with a number,
    and then update it with a text or any other datatype. Assigning a value to a variable
    that is different from its original type is often not considered a good practice,
    although it is possible.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们更新了一个现有的变量。JavaScript不是一种强类型语言。这意味着你可以声明一个变量，用数字初始化它，然后更新为文本或其他任何数据类型。将不同类型的值赋给变量通常不被认为是良好的实践，尽管这是可能的。
- en: In the third line, we also declared a number, but this time we are using the
    `let` keyword to specify this is a local variable.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们也声明了一个数字，但这次我们使用`let`关键字来指定这是一个局部变量。
- en: In the fourth line, we can change the value of `myVar` to a different number;
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四行，我们可以将`myVar`的值更改为不同的数字；
- en: In the fifth line, we declared another variable, but this time using the `const`
    keyword. This means the value of this variable is final and if we try to assign
    another value, we will get an error (*assignment to constant variable*).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第五行，我们声明了另一个变量，但这次使用`const`关键字。这意味着这个变量的值是最终的，如果我们尝试赋予另一个值，我们将得到一个错误（*常量变量赋值错误*）。
- en: Let's see next what datatypes are supported by JavaScript.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看JavaScript支持哪些数据类型。
- en: Data types
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'The latest **ECMAScript** standard (the JavaScript specification) defines a
    few primitive data types at the time of writing:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写本文时，最新的**ECMAScript**标准（JavaScript规范）定义了一些原始数据类型：
- en: '**Number**: an integer or floating number;'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Number**：整数或浮点数；'
- en: '**String**: a text value;'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**：文本值；'
- en: '**Boolean**: true or false values;'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Boolean**：真或假值；'
- en: '**null**: a special keyword denoting a null value;'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**null**：表示空值的特殊关键字；'
- en: '**undefined**: a variable with no value or that has not been initialized;'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**undefined**：没有值或尚未初始化的变量；'
- en: '**Symbol**, which are unique and immutable;'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Symbol**，它们是唯一且不可变的；'
- en: '**BigInt**: an integer with arbitrary precision: `1234567890n`;'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigInt**：任意精度的整数：`1234567890n`；'
- en: and **Object**.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及**Object**。
- en: 'Let''s see an example of how to declare variables that hold different data
    types:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何声明不同数据类型的变量的例子：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to see the value of each variable we declared, we can use `console.log`
    to do so, as listed in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看我们声明的每个变量的值，我们可以使用`console.log`来实现，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The console.log method also accepts more than one argument. Instead of `console.log(''num:
    '' + num)`, we can also use `console.log(''num: '', num)`. While the first option
    will concatenate the result into a single string, the second allows us to add
    a description and visualize the variable content in case it is an object.'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'console.log方法也接受多个参数。而不是`console.log(''num: '' + num)`，我们也可以使用`console.log(''num:
    '', num)`。第一个选项将结果连接成单个字符串，而第二个选项允许我们添加描述并可视化变量内容，如果它是对象的话。'
- en: 'In JavaScript, the `typeof` operator is an operator that helps to determine
    the data type of a variable or expression. It returns a string that represents
    the type of the operand. In case we would like to check the type of the declared
    variables, we can use the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`typeof`运算符是一个帮助确定变量或表达式数据类型的运算符。它返回一个表示操作数类型的字符串。如果我们想检查声明变量的类型，我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In JavaScript, `typeof null` returns "object", which can be confusing since
    `null` is not actually an object. This is considered a historical quirk or bug
    in the language.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在JavaScript中，`typeof null`返回"object"，这可能令人困惑，因为`null`实际上不是一个对象。这被认为是语言中的历史怪癖或错误。
- en: The object and symbol data types
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对象和Symbol数据类型
- en: In JavaScript, an object is a fundamental data structure that serves as a collection
    of *key-value* pairs. These key-value pairs are often referred to as properties
    or methods of the object. Think of it as a container that can store various types
    of data and functionality.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对象是一种基本的数据结构，它作为一个**键值对**的集合。这些键值对通常被称为对象的属性或方法。可以将其视为一个可以存储各种类型的数据和功能的容器。
- en: 'If we want to represent a book in JavaScript with attributes like its title,
    we can effectively do so using an object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在JavaScript中使用像标题这样的属性来表示一本书，我们可以有效地使用对象来实现：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Objects are a cornerstone of JavaScript programming, providing a powerful way
    to structure data, encapsulate logic, and model real-world entities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是JavaScript编程的基石，提供了一种强大的方式来结构化数据、封装逻辑以及模拟现实世界的实体。
- en: 'If we would like to output the title of the book, we can do so using the dot
    notation as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要输出书的标题，我们可以使用点符号如下进行操作：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although we are not able to reassign values to a constant, we can *mutate*
    it if its data type is an object. Let''s see an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不能重新赋值常量的值，但如果其数据类型是对象，我们可以*修改*它。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Mutaing an object means changing the properties within the existing object
    as we just did. Reassigning an object means changing the entire object that a
    variable refers to as showed in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象意味着改变现有对象中的属性，就像我们刚才做的那样。重新赋值对象意味着改变变量所引用的整个对象，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This concept is important, as we will use it in a lot of examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很重要，因为我们将在很多例子中使用它。
- en: 'JavaScript also supports a special and unique data type called **symbol**.
    Symbols serve as unique identifiers and are primarily used for the following purposes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还支持一种特殊且独特的数据类型，称为**符号**。符号作为唯一的标识符，主要用于以下目的：
- en: 'Unique property keys: symbols can be used as keys for object properties, ensuring
    that these properties are distinct and will not clash with any other keys (even
    strings with the same name). This is particularly useful when working with libraries
    or modules where naming conflicts might arise.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独特的属性键：符号可以用作对象属性的键，确保这些属性是独特的，不会与其他键（即使是具有相同名称的字符串）冲突。这在处理库或模块时尤其有用，因为可能会出现命名冲突。
- en: 'Hidden properties: symbols are not enumerable by default, meaning they will
    not show up in `for...in` loops or `Object.keys()`. This makes them ideal for
    creating *private* properties within objects.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏属性：符号默认是不可枚举的，这意味着它们不会出现在`for...in`循环或`Object.keys()`中。这使得它们非常适合在对象中创建*私有*属性。
- en: 'Let''s see an example for better understanding:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are creating a symbol `title` and using it as a key for
    the `book3` object. When we need to access this property, we cannot simply use
    `book3.title` using the dot notation, but `book3.[title]`, using the brackets
    notation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个符号`title`，并使用它作为`book3`对象的键。当我们需要访问这个属性时，我们不能简单地使用点符号`book3.title`，而必须使用方括号符号`book3.[title]`。
- en: We will not use symbols in the examples of this book, but it is an interesting
    concept to know.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我们不会使用符号，但了解这个概念是有趣的。
- en: Control structures
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制结构
- en: JavaScript has a similar set of control structures as the C and Java languages.
    Conditional statements are supported by `if...else` and `switch`. JavaScript also
    supports different loop statements such as `for`, `while`, `do…while`, `for…in`
    and `for…of`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript与C和Java语言具有类似的控制结构集。条件语句由`if...else`和`switch`支持。JavaScript还支持不同的循环语句，如`for`、`while`、`do…while`、`for…in`和`for…of`。
- en: In this section, we explore both conditional statements and loop statements,
    starting with conditional statements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨条件语句和循环语句，从条件语句开始。
- en: Conditionals
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件语句
- en: Conditional statements in JavaScript are essential building blocks for controlling
    the flow of your code. They allow you to make decisions based on certain conditions
    and execute different code blocks accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的条件语句是控制代码流程的基本构建块。它们允许你根据某些条件做出决策，并相应地执行不同的代码块。
- en: 'We can use the `if` statement if we want to execute a block of code only if
    the condition is true. And we can use the optional `else` statement if the condition
    is false:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在条件为真时执行一段代码，我们可以使用`if`语句。如果条件为假，我们可以使用可选的`else`语句：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `if...else` statement can also be represented by a ternary operator. For
    example, take a look at the following if...else statement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`语句也可以用三元运算符来表示。例如，看看下面的if...else语句：'
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It can also be represented as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以表示如下：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ternary operators are expressions that evaluate to a value, whereas the if-statement
    is just an imperative statement. This means we can use it directly within another
    expression, assign its result to a variable, or use it as an argument in a function
    call. For example, we can rewrite the previous example as following, without changing
    its output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符是返回一个值的表达式，而 if 语句只是一个命令式语句。这意味着我们可以在另一个表达式中直接使用它，将其结果赋给一个变量，或者将其用作函数调用的参数。例如，我们可以将前面的例子重写如下，而不改变其输出：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, if we have several scripts, we can use `if...else` several times to execute
    different scripts based on different conditions, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们有多个脚本，我们可以多次使用 `if...else` 来根据不同的条件执行不同的脚本，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have the `switch` statement. The `switch` statement provides an
    alternative way to write multiple `if...else` if chains. It evaluates an expression
    and then matches its value against a series of cases. When a match is found, the
    code associated with that case is executed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `switch` 语句。`switch` 语句提供了一种编写多个 `if...else` 条件链的替代方法。它评估一个表达式，然后将其值与一系列情况匹配。当找到匹配项时，将执行与该情况关联的代码：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: JavaScript will look for a match of the value (in this example, the variable
    `month`) in one of the `case` statements. If no match is found, then the `default`
    statement is executed. The `break` clause inside each `case` statement will halt
    the execution and break out of the `switch` statement. If we do not add the `break`
    statement, the code inside each subsequent `case` statement is also executed,
    including the `default` statement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将在 `case` 语句中查找值的匹配（在这个例子中，是变量 `month`）。如果没有找到匹配项，则执行 `default` 语句。每个
    `case` 语句内部的 `break` 子句将停止执行并跳出 `switch` 语句。如果我们不添加 `break` 语句，后续每个 `case` 语句内部的代码也会执行，包括
    `default` 语句。
- en: Loops
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环
- en: In JavaScript, loops are fundamental structures that allow you to repeatedly
    execute a block of code as long as a specified condition is `true`. They are essential
    for automating repetitive tasks and iterating over collections of data like arrays
    or objects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，循环是基本结构，允许你在指定的条件为 `true` 时重复执行代码块。它们对于自动化重复性任务和遍历数据集合（如数组或对象）是必不可少的。
- en: The `for` loop is the same as in C and Java. It consists of a loop counter that
    is usually assigned a numeric value, then the variable is compared against the
    condition to break the loop, and finally the numeric value is increased or decreased.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环与 C 和 Java 中的相同。它由一个通常赋值为数值的循环计数器组成，然后变量与条件比较以跳出循环，最后数值增加或减少。'
- en: 'In the following example, we have a `for` loop. It outputs the value of `i`
    in the console, while `i` is less than `10`. `i` is initiated with 0, so the following
    code will output the values 0 to 9:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个 `for` 循环。它在控制台输出 `i` 的值，当 `i` 小于 `10` 时。`i` 的初始值为 0，因此下面的代码将输出从
    0 到 9 的值：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `for` loop, first we have the initialization (`let i = 0`), which happens
    only once, before the loop starts. Next, we have the condition that is evaluated
    before each iteration (`i < 10`). If it evaluates to `true`, the loop's body is
    executed. If it is `false`, the loop ends. We then have the final expression,
    (`i++`), which is often used to update the counter variable. The final expression
    is executed after the body of the loop is executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环中，首先我们有初始化（`let i = 0`），这仅在循环开始之前发生一次。接下来，我们有在每次迭代之前评估的条件（`i < 10`）。如果评估结果为
    `true`，则执行循环体。如果为 `false`，则循环结束。然后我们有最终表达式（`i++`），这通常用于更新计数器变量。最终表达式在执行循环体之后执行。
- en: The next loop construct we will look at is the `while` loop. The script inside
    the while loop is executed while the condition is true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一个循环结构是 `while` 循环。当条件为真时，while 循环内部的脚本将被执行。
- en: 'In the following code, we have a variable `i`, initiated with the value 0,
    and we want the value of `i` to be logged while `i` is less than 10 (or less than
    or equal to 9). The output will be the values from 0 to 9:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有一个变量 `i`，其初始值为 0，我们希望当 `i` 小于 10（或小于或等于 9）时记录 `i` 的值。输出将是从 0 到 9
    的值：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `do...while` loop is similar. The only difference is that in the `while`
    loop, the condition is evaluated before executing the script, and in the `do...while`
    loop, the condition is evaluated after the script is executed. The `do...while`
    loop ensures that the script is executed at least once. The following code also
    outputs the values from 0 to 9:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while` 循环与 `while` 循环类似。唯一的区别是，在 `while` 循环中，条件在执行脚本之前被评估，而在 `do...while`
    循环中，条件在脚本执行后被评估。`do...while` 循环确保脚本至少执行一次。以下代码也输出了从 0 到 9 的值：'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `for…in` loop iterates a variable over the properties of an object. This
    loop is especially useful when working with dictionaries and sets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`for…in` 循环遍历对象的属性。这个循环在处理字典和集合时特别有用。'
- en: 'In the following code, we will declare an object, and output the name of each
    property, along with its value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将声明一个对象，并输出每个属性的名称及其值：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `for…of` loop iterates a variable over the values of an Array, Map or Set
    as shown by the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`for…of` 循环遍历数组、映射或集合的值，如下面的代码所示：'
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Functions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are important when working with JavaScript. Functions are blocks of
    code designed to perform specific tasks. They are one of the fundamental building
    blocks in JavaScript and offer a way to organize code, promote reusability, and
    improve maintainability. We will also use functions in our examples.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JavaScript 时，函数非常重要。函数是设计用来执行特定任务的代码块。它们是 JavaScript 的基本构建块之一，提供了一种组织代码、提高可重用性和可维护性的方法。我们也会在我们的示例中使用函数。
- en: 'The following code demonstrates the basic syntax of a function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了函数的基本语法：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The purpose of this function is to create a reusable piece of code that greets
    a person by their name. We have one parameter named `name`. A parameter acts as
    a placeholder for a value that will be provided when the function is called.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的目的是创建一段可重用的代码，通过名字问候一个人。我们有一个名为 `name` 的参数。参数在函数被调用时充当提供值的占位符。
- en: 'To execute this code, we simply use the following statement:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此代码，我们只需使用以下语句：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The string "Packt" is passed as an argument. This value is assigned to the `name`
    parameter inside the function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串 "Packt" 作为参数传递。这个值被分配给函数内部的 `name` 参数。
- en: 'A function can also return a value, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以返回一个值，如下所示：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that in JavaScript, a function will always return a value. A function can
    explicitly return a value using the `return` keyword followed by an expression.
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，在 JavaScript 中，函数总是会返回一个值。函数可以使用 `return` 关键字后跟一个表达式显式地返回一个值。
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a function doesn't have a `return` statement (as in the `sayHello` example
    above) or reaches the end of its code block without encountering a `return`, it
    implicitly returns `undefined`.
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个函数没有 `return` 语句（如上面的 `sayHello` 示例）或者在其代码块结束时没有遇到 `return`（没有返回），它将隐式返回
    `undefined`。
- en: 'This function calculates the sum of two given numbers and returns its result.
    We can use it as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算两个给定数字的和，并返回其结果。我们可以如下使用它：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also assign default values to the parameters. In case we do not pass
    the value, the function will use the default value:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为参数分配默认值。如果我们没有传递值，函数将使用默认值：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will explore more about functions throughout this book, as well as other
    advanced features related to functions, especially when covering the algorithms
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探索更多关于函数的内容，以及与函数相关的其他高级特性，尤其是在介绍算法部分时。
- en: Variable scope
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'The scope refers to where in the algorithm we can access the variable. To understand
    how variables scope work, let''s use the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域指的是在算法的哪个位置我们可以访问变量。为了理解变量作用域是如何工作的，让我们使用以下示例：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let''s log some output so we can see the results:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们记录一些输出，以便我们可以看到结果：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Following is the explanation of why we got this output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为什么我们得到这个输出的解释：
- en: We start by declaring a variable named `movie` in the global scope and assigning
    it the value "Lord of the Rings". This variable can be accessed from anywhere
    in the code. The first `console.log` statement is printing the initial value of
    this variable.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先在全局作用域中声明一个名为 `movie` 的变量，并将其值设置为 "指环王"。这个变量可以从代码的任何地方访问。第一个 `console.log`
    语句正在打印这个变量的初始值。
- en: For the `starWarsFan` function, we declared a new variable named `movie` using
    `const`. This variable has the same name as the global variable `movie`, but it
    exists only within the function's scope. This is called "**shadowing**", where
    the local variable hides the global one within the function's context. The second
    `console.log` is calling the `starWarsFan` function. It prints "Star Wars" because
    inside the function we are working with the local variable `movie`, leaving the
    global `movie` variable unchanged.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `starWarsFan` 函数，我们使用 `const` 声明了一个名为 `movie` 的新变量。这个变量与全局变量 `movie` 有相同的名称，但它只存在于函数的作用域内。这被称为
    "**遮蔽**"，在函数的上下文中，局部变量隐藏了全局变量。第二个 `console.log` 调用了 `starWarsFan` 函数。它打印 "Star
    Wars"，因为在函数内部我们正在使用局部变量 `movie`，而全局的 `movie` 变量保持不变。
- en: Next, we have the marvelFan function, which does not declare a new `movie` variable
    using `let` or `const`. Instead, it directly modifies the global `movie` variable
    by assigning it the value "The Avengers". This is possible because there is no
    local variable to shadow the global one. So, we print the third console.log calling
    this function, the output is "The Avengers".
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `marvelFan` 函数，它没有使用 `let` 或 `const` 声明一个新的 `movie` 变量。相反，它直接通过将其赋值为
    "The Avengers" 来修改全局的 `movie` 变量。这是可能的，因为没有局部变量会遮蔽全局变量。因此，当我们调用这个函数的第三个 `console.log`
    时，输出是 "The Avengers"。
- en: Finally, we have the last `console.log(movie)`. This again prints the global
    `movie` variable, which now holds the value "The Avengers" due to the previous
    `marvenFan` function call.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有最后一个 `console.log(movie)`。这再次打印了全局的 `movie` 变量，由于之前的 `marvenFan` 函数调用，它现在持有值
    "The Avengers"。
- en: 'Let''s review a second example, this time using only a function, to showcase
    how variable scope affects the visibility and value of variables within different
    parts of the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾第二个例子，这次只使用一个函数，来展示变量作用域如何影响代码不同部分中变量的可见性和值：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we call the blizzardFan() function, the output will be:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `blizzardFan()` 函数时，输出将是：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s understand why:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下原因：
- en: We start by declaring a constant variable `isFan` and initializing it with the
    value `true`. Since it is declared with `const`, its value cannot be changed.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明一个常量变量 `isFan` 并将其初始化为 `true`。由于它使用 `const` 声明，其值不能被更改。
- en: A variable `phrase` is declared using `let` and assigned the value 'Warcraft'.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `let` 声明了一个名为 `phrase` 的变量并将其赋值为 'Warcraft'。
- en: Next, we have the first console.log that outputs the current value of the phrase
    variable which is Warcraft.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个第一个 `console.log` 输出 `phrase` 变量的当前值，它是 Warcraft。
- en: Then we have the `if (isFan)` block. Since `isFan` is `true`, the code inside
    the if block is executed.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们有 `if (isFan)` 块。由于 `isFan` 是 `true`，if 块内的代码被执行。
- en: Inside the if block, we declare a new variable, also named `phrase`, within
    the if block's scope. This creates a separate, block-scoped variable that shadows
    the outer `phrase` variable.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 if 块内部，我们在 if 块的作用域内声明了一个新的变量，也命名为 `phrase`。这创建了一个独立的、块级作用域的变量，它遮蔽了外部的 `phrase`
    变量。
- en: The value of the inner `phrase` variable (the one declared within the if block)
    is changed to "For the Horde!".
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部 `phrase` 变量的值（在 if 块内声明的那个）被更改为 "For the Horde!"。
- en: '`console.log(''Inside if: '' + phrase)` prints "Inside if: For the Horde!"
    because this is the inner `phrase` variable.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`console.log(''Inside if: '' + phrase)` 打印 "Inside if: For the Horde!"，因为这是内部的
    `phrase` 变量。'
- en: After the if block, the outer `phrase` variable (the one declared at the beginning
    of the function) is still accessible. Its value is changed to "For the Alliance!".
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 if 块之后，外部的 `phrase` 变量（在函数开始时声明的那个）仍然可访问。它的值被更改为 "For the Alliance!"。
- en: 'Finally, `console.log(''After if: '' + phrase)` prints "After if: For the Alliance!"
    because we are printing the variable we declared in the first line of the function.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，`console.log(''After if: '' + phrase)` 打印 "After if: For the Alliance!"，因为我们正在打印函数第一行声明的变量。'
- en: Now that we know the basics of the JavaScript language, let's see how we can
    use it in an Object-oriented programming approach.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 JavaScript 语言的基础知识，让我们看看我们如何使用面向对象编程方法来使用它。
- en: Object-oriented programming in JavaScript
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 中的面向对象编程
- en: '**Object-Oriented Programming (OOP)** in JavaScript consist of five concepts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程（OOP）** 在 JavaScript 中包含五个概念：'
- en: 'Objects: these are the fundamental building blocks of OOP. They represent real-world
    entities or abstract concepts, encapsulating both data (properties) and behavior
    (methods).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象：这些是面向对象编程（OOP）的基本构建块。它们代表现实世界的实体或抽象概念，封装了数据（属性）和行为（方法）。
- en: 'Classes: these are a more structured way to create objects. A class serves
    as a blueprint for creating multiple objects (instances) of a similar type.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类：这是一种更结构化的创建对象的方式。类作为创建多个类似类型对象（实例）的蓝图。
- en: 'Encapsulation: this involves bundling data and the functions that operate on
    that data into a single unit (the object). It protects the object''s internal
    state and allows you to control access to its properties and methods.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装：这涉及到将数据和操作这些数据的函数捆绑成一个单一的单位（对象）。它保护对象的内部状态，并允许你控制对其属性和方法访问的控制。
- en: 'Inheritance: this allows us to create new classes (child classes) that inherit
    properties and methods from existing classes (parent classes). This promotes code
    reusability and establishes relationships between classes.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承：这允许我们创建新的类（子类），这些子类可以从现有的类（父类）继承属性和方法。这促进了代码的重用，并在类之间建立了关系。
- en: 'Polymorphism: this means *many forms*. In OOP, it refers to the ability of
    objects of different classes to respond to the same method call in their own unique
    way.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态：这意味着*多种形式*。在面向对象编程（OOP）中，它指的是不同类的对象以自己独特的方式响应相同方法调用的能力。
- en: OOP helps organize code, promotes reusability, makes code more maintainable,
    and allows for better modeling of real-world relationships. Let's review each
    concept to understand how they work in JavaScript.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）有助于组织代码，促进重用，使代码更易于维护，并允许更好地模拟现实世界的关系。让我们回顾每个概念，以了解它们在JavaScript中的工作方式。
- en: Objects, classes and encapsulation
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象、类和封装
- en: JavaScript objects are simple collections of name-value pairs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象是简单的键值对集合。
- en: 'There are two ways of creating a simple object in JavaScript. An example of
    the first way is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建简单对象有两种方式。第一种方式的例子如下：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And an example of the second way is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式的例子如下：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The example of the second way is called an object literal, which is a means
    to create and define objects directly in the code using a convenient notation.
    It is one of the most common ways to work with objects in JavaScript and also
    the preferred way over the `new Object` constructor in the first example, due
    to convenience (compact syntax), and overall performance when creating objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式的例子称为对象字面量，这是一种在代码中直接使用方便的符号创建和定义对象的方法。这是在JavaScript中处理对象最常见的方式之一，也是比第一个例子中的`new
    Object`构造函数更受欢迎的方式，因为其便利性（紧凑的语法）以及在创建对象时的整体性能。
- en: 'We can also create an object entirely, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以完全创建一个对象，如下所示：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To declare a JavaScript object, *[key, value]* pairs are used, where the key
    can be considered a property of the object and the value is the property value.
    In the previous example, `address` is the key, and its value is "Middle Earth".
    We will use this concept when creating some data structures, such as Sets or Dictionaries.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明JavaScript对象，使用*[键，值]*对，其中键可以被认为是对象的属性，而值是属性值。在先前的例子中，`address`是键，其值是"Middle
    Earth"。我们将使用这个概念来创建一些数据结构，例如集合或字典。
- en: Objects can contain other objects as their properties. We call them nested objects.
    This creates a hierarchical structure where objects can be nested within each
    other at multiple levels, as we can see in the previous example, where `name`
    is a nested object within `obj`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以作为其属性包含其他对象。我们称它们为嵌套对象。这创建了一个层次结构，其中对象可以在多个级别上嵌套，就像我们可以在先前的例子中看到的那样，其中`name`是`obj`中的嵌套对象。
- en: 'In Object-Oriented Programming (OOP), an object is an instance of a class.
    A class defines the characteristics of the object and helps us with encapsulation,
    bundling the properties and methods so they can work as one unit (an object).
    For our algorithms and data structures, we will create some classes that will
    represent them. This is how we can define a class that represents a book:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，对象是类的实例。类定义了对象的特性，并帮助我们进行封装，将属性和方法捆绑在一起，以便它们可以作为一个单元（对象）一起工作。对于我们的算法和数据结构，我们将创建一些代表它们的类。这就是我们如何定义一个代表书籍的类的例子：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can declare properties in a JavaScript class through the constructor. JavaScript
    will automatically declare a property that is public, meaning it can be accessed
    and modified directly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构造函数在JavaScript类中声明属性。JavaScript将自动声明一个公共属性，这意味着它可以被直接访问和修改。
- en: Inside the constructor, `this` refers to the object instance being created.
    In the case of our example, this is referencing itself. We could interpret the
    code as this book's title is being assigned the title value passed to the constructor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数内部，`this`指向正在创建的对象实例。在我们的例子中，这指的是自身。我们可以将代码解释为这本书的标题正在被分配给构造函数传递的标题值。
- en: Modern JavaScript also allows us to declare private properties by adding the
    prefix `#` as in `#percentagePerSale`. This property is only visible inside the
    class and cannot be accessed directly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现代JavaScript还允许我们通过添加前缀`#`来声明私有属性，例如`#percentagePerSale`。这个属性仅在类内部可见，不能直接访问。
- en: Public members (properties and methods) are accessible from anywhere, both inside
    and outside the class. By default, all members in a JavaScript class are public.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 公共成员（属性和方法）可以从任何地方访问，无论是类内部还是外部。默认情况下，JavaScript类中的所有成员都是公共的。
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Private members are accessible only from within the class itself. They cannot
    be accessed or modified directly from outside the class, providing better encapsulation
    and data protection.
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 私有成员只能在类内部访问。它们不能从类外部直接访问或修改，这提供了更好的封装和数据保护。
- en: We can also create getters using the `get` keyword (`get price()`). These can
    be used to declare a property that returns a calculated value based on the object's
    other properties. In this case, the price of the book depends on the number of
    `pages` (which is a public property) and the percentage of profit per sale, which
    is private. We access a property locally inside the class by referencing the keyword
    `this`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`get`关键字（`get price()`）创建getter。这些可以用来声明一个基于对象其他属性的返回计算值的属性。在这种情况下，书的定价取决于`pages`（这是一个公共属性）的数量和每笔销售的利润百分比，这是一个私有属性。我们通过引用关键字`this`在类内部访问本地属性。
- en: We can also declare methods in a class (`printIsbn`). Methods are simply functions
    that are associated with the class. They define the actions or behaviors that
    objects created from the class (instances) can perform.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在类中声明方法（`printIsbn`）。方法只是与类关联的函数。它们定义了从类（实例）创建的对象可以执行的操作或行为。
- en: Modern JavaScript also allows us to declare static properties using the `static`
    keyword and static methods. Static properties are shared between all instances
    of the class, which is a fantastic way to keep track of properties that are shared
    between every object in the class (such as a count of how many books have been
    sold in total, for example). In other languages such as Ruby, they are classes
    class variables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现代JavaScript也允许我们使用`static`关键字声明静态属性和静态方法。静态属性在类的所有实例之间共享，这是一种跟踪类中每个对象共享属性（例如，例如，总共卖出了多少本书）的绝佳方式。在其他语言，如Ruby中，它们是类变量。
- en: Static methods do not require an instance of the class and can be accessed directly,
    such as `Book.sellCopy()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不需要类的实例，可以直接访问，例如`Book.sellCopy()`。
- en: 'To instantiate this class, we can use the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化这个类，我们可以使用以下代码：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we can access its public properties and update them as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以访问其公共属性并更新它们如下：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use the getter method to find out the price of the book as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用getter方法来找出书的定价如下：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And access the static property and method as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样访问静态属性和方法：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What if we would like to represent another type of book, such as an e-book?
    Can we reuse some of the definitions we have declared in the `Book` class? Let's
    find out in the next section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想表示另一种类型的书，比如电子书？我们能否重用`Book`类中声明的某些定义？让我们在下一节中找出答案。
- en: Inheritance and polymorphism
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承和多态
- en: 'JavaScript also allows the use of inheritance, which is a powerful mechanism
    in OOP that allows us to create new classes (child class) that derive properties
    and methods from existing classes (parent class or superclass). Let''s look at
    an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还允许使用继承，这是面向对象编程中的一种强大机制，允许我们创建新的类（子类），这些类从现有的类（父类或超类）继承属性和方法。让我们看一个例子：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can extend another class and inherit its behavior using the keyword `extends`.
    In our example, the Ebook is the child class, and the Book is the superclass.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`extends`关键字扩展另一个类并继承其行为。在我们的例子中，Ebook是子类，而Book是超类。
- en: Inside the `constructor`, we can refer to the constructor `superclass` using
    the keyword `super`. We can add more properties to the child class (`format`).
    The child class can still access static methods (`sellCopy`) and properties (`copiesSold`)
    from the superclass.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constructor`中，我们可以使用关键字`super`来引用`superclass`构造函数。我们可以在子类中添加更多属性（`format`）。子类仍然可以访问超类中的静态方法（`sellCopy`）和属性（`copiesSold`）。
- en: A child class can also provide its own implementation of a method initially
    declared in the superclass. This is called *method overriding* and allows objects
    of the child class to exhibit different behavior for the same method call.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也可以为其在超类中最初声明的方法提供自己的实现。这被称为*方法覆盖*，允许子类的对象对同一方法调用表现出不同的行为。
- en: 'By overriding methods from the superclass, we can achieve a concept called
    polymorphism, which literally means many forms. In OOP, polymorphism is the ability
    of objects of different classes to respond to the same method call in their own
    unique way. For example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖超类的方法，我们可以实现一个称为多态的概念，字面上意味着多种形式。在面向对象编程（OOP）中，多态是不同类的对象以它们独特的方式响应相同方法调用的能力。例如：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have two book instances here, and one of them is an e-book. We can call the
    method `printIsbn` from both instances, and we will get different outputs due
    to the different behavior in each instance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有两组书实例，其中一个是电子书。我们可以从两个实例中调用`printIsbn`方法，由于每个实例中的行为不同，我们将得到不同的输出。
- en: Most of the data structures we will cover throughout this book will follow the
    JavaScript class approach.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将涵盖的大部分数据结构都将遵循JavaScript类方法。
- en: Although the class syntax in JavaScript is remarkably similar to other programming
    languages such as Java and C/C++, it is good to remember that JavaScript object-oriented
    programming is done through a prototype.
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管JavaScript中的类语法与其他编程语言（如Java和C/C++）非常相似，但记住JavaScript面向对象编程是通过原型来完成的，这是很好的。
- en: Modern Techniques
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代技术
- en: JavaScript is a language that continues to evolve and get new features each
    year. There are some features that make some concepts easier when working with
    data structures and algorithms. Let's check them out.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种不断进化并每年都获得新特性的语言。有一些特性使得在处理数据结构和算法时某些概念更容易。让我们来看看它们。
- en: Arrow functions
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are a concise and expressive way to write functions in JavaScript.
    They offer a shorter syntax and some key differences in behavior compared to traditional
    function expressions. Consider the following example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是JavaScript中编写函数的一种简洁且富有表现力的方式。它们提供了一种更短的语法，并且在行为上与传统函数表达式有一些关键的区别。考虑以下示例：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With arrow functions, we can simplify the syntax of the preceding code to the
    following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，我们可以将前面代码的语法简化为以下代码：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The main difference is in the first line of the example, on which we can omit
    the keyword `function` using `=>`, hence the name arrow function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于示例的第一行，我们可以省略关键字`function`使用`=>`，因此得名箭头函数。
- en: 'If the function has a single statement, we can use a simpler version, by omitting
    the keyword `return` and the curly brackets as demonstrated in the following code
    snippet:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只有一个语句，我们可以使用更简单的版本，通过省略关键字`return`和大括号，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the function does not receive any argument, we can use empty parenthesis
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数没有接收任何参数，我们可以使用空括号如下所示：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will be using arrow functions to code some algorithms later in this book
    for a simpler syntax.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面使用箭头函数来编写一些算法，以实现更简单的语法。
- en: Spread and rest operators
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展和剩余操作符
- en: 'In JavaScript, we can turn arrays into parameters using the `apply()` function.
    Modern JavaScript has the spread operator (`...`) for this purpose. For example,
    consider the function `sum` as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以使用`apply()`函数将数组转换为参数。现代JavaScript有扩展操作符（`...`）用于此目的。例如，考虑以下`sum`函数：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can execute the following code to pass the `x`, `y`, and `z` parameters:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下代码来传递`x`、`y`和`z`参数：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code is the same as the code written in classic JavaScript, as
    follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与以下经典JavaScript编写的代码相同：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The spread operator (`...`) can also be used as a rest parameter in functions
    to replace `arguments`. Consider the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符（`...`）也可以用作函数中的剩余参数来替换`arguments`。考虑以下示例：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code is the same as the following (also outputs 9 in the console):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与以下代码相同（在控制台中也输出9）：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The rest and spread operators are going to be useful in some data structures
    and algorithms throughout this book.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余和扩展运算符将在本书的一些数据结构和算法中非常有用。
- en: Exponentiation operator
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数运算符
- en: 'The exponentiation operator may come in handy when working with math algorithms.
    Let''s use the formula to calculate the area of a circle as an example that can
    be improved/simplified with the exponentiation operator:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数学算法时，指数运算符可能会很有用。让我们以使用公式计算圆的面积为例，这个例子可以用指数运算符来改进/简化：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expression `radius * radius` is the same as radius squared. We could also
    use the `Math.pow` function available in JavaScript to write the same code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `radius * radius` 与半径的平方相同。我们也可以使用 JavaScript 中可用的 `Math.pow` 函数来编写相同的代码：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In JavaScript, the exponentiation operator is denoted by two asterisks (**).
    It is used to raise a number (the base) to the power of another number (the exponent).
    We can calculate the area of a circle using the exponentiation operator as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，指数运算符用两个星号（**）表示。它用于将一个数（基数）提升到另一个数（指数）的幂。我们可以使用指数运算符来计算圆的面积，如下所示：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: TypeScript fundamentals
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 基础知识
- en: TypeScript is an open source **gradually typed** superset of JavaScript created
    and maintained by Microsoft. Gradual typing is a type system that combines elements
    of both static typing and dynamic typing within the same programming language.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是由 Microsoft 创建和维护的开源 **渐进式类型化**的 JavaScript 超集。渐进式类型化是一种类型系统，它将静态类型和动态类型的元素结合在同一编程语言中。
- en: TypeScript allows us to add types to our JavaScript code, improving code readability,
    improving early error detection as we can catch type-related errors during development
    and enhanced tooling as code editors and IDEs offer better code autocompletion
    and navigation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们在 JavaScript 代码中添加类型，提高代码可读性，提高早期错误检测，因为我们可以在开发过程中捕捉到类型相关错误，并增强工具，因为代码编辑器和
    IDE 提供了更好的代码自动完成和导航。
- en: Regarding the scope of this book, with TypeScript we can use some Object-Oriented
    concepts that are not available in JavaScript such as interfaces - this can be
    useful when working with data structures and sorting algorithms. And of course,
    we can also leverage the typing functionality, which is especially important for
    some data structures. In algorithms that modify data structures, like searching
    or sorting, ensuring consistent data types within the collection is crucial for
    smooth operation and predictable outcomes. TypeScript excels at automatically
    enforcing this type consistency, while JavaScript requires additional measures
    to achieve the same level of assurance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本书的范围，使用 TypeScript，我们可以使用一些在 JavaScript 中不可用的面向对象概念，例如接口 - 这在处理数据结构和排序算法时可能很有用。当然，我们还可以利用类型化功能，这对于某些数据结构尤为重要。在修改数据结构的算法中，如搜索或排序，确保集合中数据类型的一致性对于平稳运行和可预测的结果至关重要。TypeScript
    在自动强制执行这种类型一致性方面表现出色，而 JavaScript 需要采取额外措施才能达到相同水平的保证。
- en: All these functionalities are available at **compilation time**. Before TypeScript
    code can run in a browser or Node.js environment, it needs to be compiled into
    JavaScript. The TypeScript compiler (**tsc**) takes your TypeScript files (*.ts*
    extension) and generates corresponding JavaScript files. During compilation, TypeScript
    checks the code for type-related errors and provides feedback. This helps catch
    potential issues early in development, leading to more reliable and easier-to-maintain
    code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都在**编译时**可用。在 TypeScript 代码能够在浏览器或 Node.js 环境中运行之前，它需要被编译成 JavaScript。TypeScript
    编译器（**tsc**）会将你的 TypeScript 文件（*.ts 扩展名）转换为相应的 JavaScript 文件。在编译过程中，TypeScript
    会检查代码中的类型相关错误并提供反馈。这有助于在开发早期就捕捉到潜在问题，从而产生更可靠且易于维护的代码。
- en: 'To work with TypeScript in our data structures and algorithms source code,
    we will leverage **npm** (*Node Package Manager*). Let''s set up TypeScript as
    a development dependency within our "`javascript-datastructures-algorithms`" folder.
    This involves creating a `package.json` file, which will manage project dependencies.
    To initiate this process, execute the following command in the project directory
    using the terminal:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的数据结构和算法源代码中工作 TypeScript，我们将利用 **npm**（*Node 包管理器*）。让我们在 "`javascript-datastructures-algorithms`"
    文件夹内设置 TypeScript 作为开发依赖项。这涉及到创建一个 `package.json` 文件，该文件将管理项目依赖项。要启动此过程，请在项目目录中使用终端执行以下命令：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will be prompted some questions, simply press Enter to proceed. And at
    the end, we will have a `package.json` file with the following content:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到一些问题，只需按Enter键继续。最后，我们将有一个包含以下内容的`package.json`文件：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we will install TypeScript:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装TypeScript：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By running this command, we will save the TypeScript as a development dependency,
    meaning this will only be used locally during development time. This command will
    also create a `package-lock.json` file, that can help to ensure that anyone installing
    the dependencies for the source code from this book will use the exact same packages
    used for the examples.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，我们将TypeScript保存为开发依赖项，这意味着这将在开发期间仅本地使用。此命令还将创建一个`package-lock.json`文件，这可以帮助确保从本书中安装依赖项的人将使用与示例中完全相同的包。
- en: 'In case you prefer to download the source code, to install the dependencies
    locally run:'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想下载源代码，要本地安装依赖项，请运行以下命令：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we need to create a file with `ts` extension, which is the extension
    used for TypeScript files, such as `src/01-intro/08-typescript.ts` with the following
    content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个扩展名为`ts`的文件，这是TypeScript文件的扩展名，例如`src/01-intro/08-typescript.ts`，内容如下：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The code above is a simple JavaScript code. Now let''s compile it using the
    `tsc` command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个简单的JavaScript代码。现在让我们使用`tsc`命令来编译它：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Where:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：
- en: '`npx` is the Node Package eXecute, meaning it is a package runner that we will
    use to execute the TypeScript compiler command.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npx`是Node Package eXecute，这意味着它是一个包运行器，我们将使用它来执行TypeScript编译器命令。'
- en: '`tsc` is the TypeScript compiler command and will compile and transform the
    source code from src/01-intro/08-typescript.ts into JavaScript.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsc`是TypeScript编译器命令，它将编译并将src/01-intro/08-typescript.ts中的源代码转换为JavaScript。'
- en: 'On the terminal, we will get the following warning:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上，我们将得到以下警告：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The warning is due to assigning the numeric value 10 to the variable `myName`
    we initialized as string.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 警告是由于将数字值10分配给初始化为字符串的变量`myName`。
- en: 'But if we verify inside the folder `src/01-intro` where we created the file,
    we will see it created a `08-typescript.js` file with the following content:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们检查我们创建文件的`src/01-intro`文件夹，我们会看到它创建了一个`08-typescript.js`文件，内容如下：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The generated code above is JavaScript code. Even with the error in the terminal
    (which in fact is a warning, not an error), the TypeScript compiler generated
    the JavaScript code as it should. This reinforces the fact that TypeScript does
    all the type and error checking during compile-time, it does not prevent the compiler
    from generating JavaScript code. This allows developers to leverage all these
    validations while we are writing the code and get a JavaScript code with less
    chance of errors or bugs.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的生成代码是JavaScript代码。即使在终端中存在错误（实际上是一个警告，而不是错误），TypeScript编译器仍然生成了应该生成的JavaScript代码。这证实了TypeScript在编译时进行所有类型和错误检查的事实，它不会阻止编译器生成JavaScript代码。这允许开发者在编写代码时利用所有这些验证，并得到一个错误或错误更少的JavaScript代码。
- en: Type inference
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'While working with TypeScript, you can find code as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TypeScript时，您可能会找到如下代码：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'TypeScript allows us to assign a type to variable. But the code above is verbose.
    TypeScript has type inference, meaning TypeScript will verify and apply a type
    to the variable automatically based on the value that was assigned to it. Let''s
    rewrite the preceding code with a cleaner syntax:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许我们为变量分配一个类型。但上面的代码比较冗长。TypeScript具有类型推断功能，这意味着TypeScript会根据分配给变量的值自动验证并应用类型。让我们用更简洁的语法重写前面的代码：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the code above, TypeScript still knows that `age` is a number, `existsFlag`
    is a boolean and `language` is a string, based on the values that they have been
    assigned to, so no need to explicitly assign a type to these variables.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码所示，TypeScript仍然知道`age`是数字，`existsFlag`是布尔值，`language`是字符串，基于它们被分配的值，因此不需要显式地为这些变量分配类型。
- en: 'So, when do we type a variable? If we declare the variable and do not initialize
    it with a value, then it recommended to assign a type as demonstrated by the code
    below:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在什么时候为变量指定类型？如果我们声明了变量但没有初始化它，那么根据下面的代码示例，建议分配一个类型：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we do not type a variable, then it is automatically typed as `any`, meaning
    it can receive any value, as it is in JavaScript.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有为变量指定类型，那么它将自动被指定为`any`类型，这意味着它可以接收任何值，就像在JavaScript中一样。
- en: Although we have object types such as `String`, `Number`, `Boolean`, and so
    on in JavaScript, when typing a variable in TypeScript, it is not a good practice
    to use the object types with the first letter capital case. When typing a variable
    in TypeScript, always prefer `string`, `number`, `boolean` (with the lowercase).
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管在 JavaScript 中有如 `String`、`Number`、`Boolean` 等对象类型，但在 TypeScript 中声明变量时，使用首字母大写的对象类型并不是一个好的做法。在
    TypeScript 中声明变量时，始终优先使用 `string`、`number`、`boolean`（小写）。
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`String`, `Number`, and `Boolean` are wrapper objects for the respective primitive
    types. They provide additional methods and properties, but are generally less
    efficient and not typically used for basic variable typing. The primitive types
    (lowercase types) ensure better compatibility with existing JavaScript code and
    libraries.'
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`String`、`Number` 和 `Boolean` 是对应原始类型的包装对象。它们提供了额外的方法和属性，但通常效率较低，并且不常用于基本变量类型。原始类型（小写类型）确保与现有
    JavaScript 代码和库有更好的兼容性。'
- en: Interfaces
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口
- en: 'In TypeScript, there are two concepts for interfaces: types and OOP interfaces.
    Let''s review each one.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，接口有两个概念：类型和面向对象接口。让我们逐一回顾。
- en: Interface as a type
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口作为类型
- en: 'In TypeScript, interfaces are a powerful way to define the structure or shape
    of objects. Consider the following code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，接口是一种强大的定义对象结构或形状的方法。考虑以下代码：
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: By declaring a `Person` interface, we are specifying the properties and methods
    an object might have to adhere to the description of what a `Person` is, meaning
    we can use the interface `Person` as a type, as we have declared as parameters
    in the `printName` function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个 `Person` 接口，我们指定了一个对象可能具有的属性和方法，以便符合 `Person` 的描述，这意味着我们可以将接口 `Person`
    作为类型使用，正如我们在 `printName` 函数中声明的参数一样。
- en: 'This allows editors such as VSCode to have autocomplete with intellisense as
    shown below:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得像 VSCode 这样的编辑器能够具有如以下所示的自动完成和智能感知功能：
- en: '![Figure 1.2 – Visual Studio Code with intellisense for a type interface](img/file2.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 带有类型接口智能感知的 Visual Studio Code](img/file2.png)'
- en: Figure 1.2 – Visual Studio Code with intellisense for a type interface
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 带有类型接口智能感知的 Visual Studio Code
- en: 'Now let''s try using the `printName` function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用 `printName` 函数：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The code above does not have any compilation errors. The variable `john` has
    a `name` and `age` as expected by the `printName` function. The variable `mary`
    has `name` and `age`, but also has `phone` information.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码没有编译错误。变量 `john` 有 `name` 和 `age` 属性，符合 `printName` 函数的预期。变量 `mary` 有 `name`
    和 `age` 属性，但还有 `phone` 信息。
- en: So why does this code work? TypeScript has a concept called **Duck Typing**.
    If it looks like a duck, emits sounds like a duck and behaves like a duck, then
    it must be a duck! In the example, the variable `mary` behaves like the `Person`
    interface because it has `name` and `age` properties, so it must be a `Person`.
    This is a powerful feature of TypeScript.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么这段代码能正常工作呢？TypeScript 有一个称为 **鸭子类型** 的概念。如果它看起来像鸭子，发出像鸭子的声音，并且表现得像鸭子，那么它一定就是鸭子！在示例中，变量
    `mary` 的行为符合 `Person` 接口，因为它具有 `name` 和 `age` 属性，所以它必须是 `Person`。这是 TypeScript
    的一个强大特性。
- en: 'And after running the `npx tsc src/01-intro/08-typescript.ts` command again,
    we will get the following output in the `08-typescript.js` file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `npx tsc src/01-intro/08-typescript.ts` 命令后，我们将在 `08-typescript.js` 文件中得到以下输出：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The code above is plain JavaScript. The code completion and type and error checking
    are available in compile-time only.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是纯 JavaScript。代码补全、类型和错误检查仅在编译时可用。
- en: By default, TypeScript compiles to ECMAScript 3\. The variable declaration as
    let and const was only introduced in ECMAScript 6\. You can specify the target
    version by creating a `tsconfig.json` file. Please check the documentation for
    the steps in case you would like to change this behavior.
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 编译为 ECMAScript 3。变量声明 `let` 和 `const` 仅在 ECMAScript 6 中引入。你可以通过创建一个
    `tsconfig.json` 文件来指定目标版本。如果你想要更改此行为，请查阅文档中的步骤。
- en: OOP Interface
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面向对象接口
- en: The second concept for the TypeScript interface is related to object-oriented
    programming, this is the same concept as in other OO languages such as Java, C#,
    Ruby, and so on. An interface is a contract. In this contract, we can define what
    behavior the classes or interfaces that will implement this contract should have.
    Consider the ECMAScript standard. ECMAScript is an interface for the JavaScript
    language. It tells the JavaScript language what functionalities it should have,
    but each browser might have a different implementation of it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 接口的第二个概念与面向对象编程相关，这与 Java、C#、Ruby 等其他面向对象语言中的概念相同。接口是一个合约。在这个合约中，我们可以定义将实现此合约的类或接口应该具有的行为。以
    ECMAScript 标准为例。ECMAScript 是 JavaScript 语言的接口。它告诉 JavaScript 语言它应该具备哪些功能，但每个浏览器可能对此有不同的实现。
- en: 'Let''s see an example that will be useful for the data structures and algorithms
    we will implement throughout this book. Consider the code below:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个有用的例子，我们将在这个书中实现的数据结构和算法中用到。考虑下面的代码：
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The interface `Comparable` tells the class `MyObject` that it should implement
    a method called `compareTo` that receives an argument. Inside this method, we
    can code the required logic. In this case, we are comparing two numbers, but we
    could use a different logic for comparing two strings or even a more complex object
    with different attributes. The `compareTo` method returns 0 in case the object
    is the same, 1, if the current object is bigger than, and -1 in case the current
    object is smaller than the other object. This interface behavior does not exist
    in JavaScript, but it is immensely helpful when working with sorting algorithms
    as an example.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `Comparable` 告诉类 `MyObject` 应该实现一个名为 `compareTo` 的方法，该方法接收一个参数。在这个方法内部，我们可以编写所需的逻辑。在这种情况下，我们正在比较两个数字，但我们可以使用不同的逻辑来比较两个字符串，甚至是一个具有不同属性的更复杂对象。`compareTo`
    方法在对象相同的情况下返回 0，如果当前对象大于另一个对象时返回 1，如果当前对象小于另一个对象时返回 -1。这个接口的行为在 JavaScript 中不存在，但它在处理排序算法等任务时非常有帮助。
- en: 'To demonstrate the concept of polymorphism, we can use the code below:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示多态的概念，我们可以使用下面的代码：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this case, the function `compareTwoObjects` receives two objects that implement
    the Comparable interface. It can be instances of `MyObject` or any other class
    that implements this interface.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数 `compareTwoObjects` 接收两个实现了 `Comparable` 接口的对象。它可以是由 `MyObject` 或任何其他实现了此接口的类实例。
- en: Generics
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: '*Generics* are a powerful feature in TypeScript (and many other strongly typed
    programming languages) that allow you to write reusable code that can work with
    various types while maintaining type safety. Think of them as templates or blueprints
    for functions, classes, or interfaces that can be parameterized with different
    types.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*泛型* 是 TypeScript（以及许多其他强类型编程语言）中的一个强大功能，它允许你编写可重用的代码，这些代码可以与各种类型一起工作，同时保持类型安全。可以将它们视为函数、类或接口的模板或蓝图，这些模板或蓝图可以用不同的类型进行参数化。'
- en: 'Let''s modify the `Comparable` interface so we can define the type of the object
    the method `compareTo` should receive as an argument:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `Comparable` 接口，以便我们可以定义方法 `compareTo` 应接收作为参数的对象类型：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By passing the type `T` dynamically to the `Comparable` interface – between
    the diamond operator `<>`, we can specify the argument type of the `compareTo`
    function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将类型 `T` 动态传递给 `Comparable` 接口——在菱形运算符 `<>` 之间，我们可以指定 `compareTo` 函数的参数类型：
- en: '[PRE70]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is useful so we can make sure we are comparing objects of the same type.
    This is done by ensuring the parameter `b` has a type of T that matches the T
    inside the diamond operator. By using this functionality, we also get code completion
    from the editor.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为我们确保正在比较的是相同类型的对象。这是通过确保参数 `b` 的类型与菱形运算符内的 `T` 匹配来实现的。通过使用此功能，我们还可以从编辑器中获得代码补全。
- en: Enums
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: '**Enums** (short for *Enumerations*) are a way to define a set of named constants.
    They help organize your code and make it more readable by giving meaningful names
    to values.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**（简称 *枚举*）是一种定义一组命名常量的方式。它们通过给值赋予有意义的名称来帮助组织代码，并使代码更易于阅读。'
- en: We can use TypeScript `enums` to avoid code smells such as *magic numbers*.
    A magic number refers to a numerical constant with no explicit explanation of
    its meaning.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 TypeScript 的 `枚举` 来避免代码异味，如 *魔法数字*。魔法数字是指没有明确解释其含义的数值常量。
- en: When working with comparing values or objects, which is quite common in sorting
    algorithms, we often see values such as -1, 1 and 0\. But what do these numbers
    mean?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理比较值或对象时，这在排序算法中相当常见，我们经常看到 -1、1 和 0 这样的值。但这些数字代表什么意思呢？
- en: 'That is when `enums` come to the rescue to improve code readability. Let''s
    refactor the `compareTo` function from the previous example using an `enum`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这个时候，枚举（`enums`）出现以改善代码的可读性。让我们使用枚举对前面的示例中的 `compareTo` 函数进行重构：
- en: '[PRE71]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: By assigning values to each `enum` constant, we can replace the values -1, 1
    and 0 with a brief explanation without changing the output of the code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个枚举常量分配值，我们可以用简短的说明替换 -1、1 和 0 的值，而不会改变代码的输出。
- en: Type aliases
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: TypeScript also has a cool feature called **type aliases**. It allows you to
    create new names for existing types. It also makes code easier to understand,
    especially when you are dealing with complex types.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还有一个名为 **类型别名** 的酷特性。它允许你为现有类型创建新名称。它也使得代码更容易理解，尤其是在处理复杂类型时。
- en: 'Let''s check an example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个示例：
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding example, we are creating a type named `UserID` that is an alias
    for a `string`. And when declaring the second type `User`, we are saying that
    the `id` is of type `UserID`, making it easier to read the code and understand
    what the `id` means.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个名为 `UserID` 的类型，它是 `string` 的别名。当我们声明第二个类型 `User` 时，我们表示 `id`
    的类型是 `UserID`，这使得阅读代码和理解 `id` 的含义更加容易。
- en: This feature is going to be useful when working with sorting algorithms, as
    we will be able to create aliases to compare functions so we can write the algorithms
    in the most generic viable way to work with any data type.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理排序算法时，这个特性将会很有用，因为我们能够创建比较函数的别名，这样我们就可以以最通用的可行方式编写算法，以处理任何数据类型。
- en: TypeScript compile-time checking in JavaScript files
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件中进行 TypeScript 编译时检查
- en: Some developers still prefer using plain JavaScript to develop their code instead
    of TypeScript. But it would be nice if we could use some of the type and error
    checking features from TypeScript in JavaScript as well, since JavaScript does
    not provide these features.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者仍然更喜欢使用纯 JavaScript 来开发他们的代码，而不是 TypeScript。但如果我们能在 JavaScript 中也使用 TypeScript
    的一些类型和错误检查功能，那会很好，因为 JavaScript 不提供这些功能。
- en: The good news is that TypeScript has a special functionality that allows us
    to have this compile-time error and type checking! To use it, we need to have
    TypeScript installed globally in our computer using the `npm install -g TypeScript
    command`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 TypeScript 有一个特殊的功能，允许我们在编译时进行错误和类型检查！要使用它，我们需要在计算机上全局安装 TypeScript，使用
    `npm install -g TypeScript` 命令。
- en: 'Let''s see how JavaScript is handling the types of a code we used previously
    in this chapter:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 JavaScript 是如何处理我们在本章中之前使用的代码类型的：
- en: '![Figure 1.3 – JavaScript code in VSCode without TypeScript compile-time checking](img/file3.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 无 TypeScript 编译时检查的 VSCode 中的 JavaScript 代码](img/file3.png)'
- en: Figure 1.3 – JavaScript code in VSCode without TypeScript compile-time checking
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 无 TypeScript 编译时检查的 VSCode 中的 JavaScript 代码
- en: 'In the first line of the JavaScript files, if we want to use the type and error
    checking, we need to add `// @ts-check` as demonstrated below:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件的第 一行，如果我们想使用类型和错误检查，我们需要添加 `// @ts-check`，如下所示：
- en: '![Figure 1.4 – JavaScript code in VSCode with TypeScript compile-time checking](img/file4.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 使用 TypeScript 编译时检查的 VSCode 中的 JavaScript 代码](img/file4.png)'
- en: Figure 1.4 – JavaScript code in VSCode with TypeScript compile-time checking
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 使用 TypeScript 编译时检查的 VSCode 中的 JavaScript 代码
- en: 'The type checking is enabled when we add JSDoc (JavaScript documentation) to
    our code. To do this, add the following code right before the function declaration:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向代码中添加 JSDoc（JavaScript 文档）时，类型检查被启用。为此，请在函数声明之前添加以下代码：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, if we try to pass a string to our circle (or `circleAreaFn`) function,
    we will get a compilation error:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们尝试向我们的圆（或 `circleAreaFn`）函数传递一个字符串，我们将得到一个编译错误：
- en: '![Figure 1.5 – Type checking in action for JavaScript](img/file5.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – JavaScript 的类型检查动作](img/file5.png)'
- en: Figure 1.5 – Type checking in action for JavaScript
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – JavaScript 的类型检查动作
- en: To enable the inferred variable names and types in VSCode, open your settings,
    and search by *inlay hint*, and enable this feature. It can make a difference
    (for the better) when coding.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要在 VSCode 中启用推断变量名称和类型，请打开您的设置，并通过 *内联提示* 进行搜索，然后启用此功能。在编码时，这可能会带来（更好的）差异。
- en: Other TypeScript functionalities
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 TypeScript 功能
- en: 'This was a very quick introduction to TypeScript. The TypeScript documentation
    is a wonderful place for learning all the other functionalities and diving into
    the details of the topics we quickly covered in this chapter: [https://www.typescriptlang.org](https://www.typescriptlang.org).'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个对TypeScript的快速介绍。TypeScript文档是一个学习所有其他功能并深入了解本章中快速覆盖的主题细节的绝佳地方：[https://www.typescriptlang.org](https://www.typescriptlang.org)。
- en: The source code bundle of this book also contains a TypeScript version of the
    JavaScript data structures and algorithms we will develop throughout this book
    as an extra resource. And whenever TypeScript makes concepts related to data structures
    and algorithms easier to understand, we will also use it throughout this book.
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书源代码包还包含本书中将要开发的JavaScript数据结构和算法的TypeScript版本，作为额外资源。并且每当TypeScript使与数据结构和算法相关的概念更容易理解时，我们也会在本书中使用它。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the importance of learning data structures and algorithms,
    and how it can make us better developers and help us pass technical job interviews
    in technology. We also reviewed reasons why we chose JavaScript to learn and apply
    these concepts.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了学习数据结构和算法的重要性，以及它如何使我们成为更好的开发者，并帮助我们通过技术面试。我们还回顾了我们选择JavaScript来学习和应用这些概念的原因。
- en: You learned how to set up the development environment to be able to create or
    execute the examples in this book. We also covered the basics of the JavaScript
    language that are needed prior to getting started with developing the algorithms
    and data structures we will cover throughout the book.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何设置开发环境，以便能够创建或执行本书中的示例。我们还涵盖了在开始开发本书中将要涵盖的算法和数据结构之前所需的JavaScript语言的基础知识。
- en: We also covered a comprehensive introduction to TypeScript, showcasing its ability
    to enhance JavaScript with static typing and error checking for more reliable
    code. We explored essential concepts like interfaces, type inference, and generics,
    empowering us to write more robust and maintainable data structures and algorithms.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还全面介绍了TypeScript，展示了它如何通过静态类型和错误检查增强JavaScript，以实现更可靠的代码。我们探讨了接口、类型推断和泛型等基本概念，使我们能够编写更健壮和可维护的数据结构和算法。
- en: In the next chapter, we'll shift our focus to the critical topic of Big O notation,
    a fundamental tool for evaluating and understanding the efficiency and performance
    of our code implementations.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点转向一个关键主题——大O表示法，这是评估和理解我们代码实现效率和性能的基本工具。
