- en: Testing in Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to test our Elm apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Testing Elm apps with `elm-test`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure and the role of the `elm-package.json` file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure and functionality of the `tests` folder
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `describe`, `test`, and `Expect`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing easier-to-understand tests with the `left pipe operator`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `let-in` and `case-of` expressions in our tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzz testing in Elm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Have a general idea of how unit testing works
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how unit testing and fuzz testing works in Elm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand different ways in which you can test your Elm apps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to successfully deploy a variety of tests in your Elm apps
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Elm testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the compiler catches all errors at compilation, the highly-touted zero
    runtime exceptions is the expected outcome for Elm apps that compile successfully.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Since that is the case, one might ask whether we need to test our Elm apps at
    all. The answer is a resounding yes, primarily because the compiler will not test
    the *behavior* of the app. While the Elm compiler's error-checking is indeed a
    wonderful tool, it will only test for logical inconsistencies, and that is pretty
    much it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for this chapter, we'll start with the code from the previous chapter.
    Simply copy the entire folder titled `improved-weather-app-ch8` and paste it in
    another location.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The code files that come with this book have this pasted folder inside `chapter9`,
    and the copy-pasted folder that can be found *inside* the `chapter9` folder has
    been renamed to `weather-app-with-tests-ch9`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: It's sometimes helpful to simply copy and paste an existing Elm project into
    a new folder and then change it, rather than create it from scratch with, for
    example, the `create-elm-app` package.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how testing works in Elm
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin working with testing in Elm by pointing our console to the `weather-app-with-tests-ch9`
    folder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our terminal pointed to the proper directory, we will need to install
    `elm-test` as an npm package. There are a number of utilities used in the Elm
    community that have their npm versions, and `elm-test` is just one of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to install `elm-test`, let''s run:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it! The `elm-test` npm package is now available globally, because we
    passed the `-g` flag to the command. What this means is we can use elm-test in
    any folder, not just the one we are currently in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Note that the installation of the elm-test npm package will take some time,
    so feel free to take a break while it is being installed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation gets going, a number of messages will be logged to the
    console. These messages will look similar to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the last line of the preceding code, which reads:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This means that the installation took a bit over 10 minutes, which is a perfect
    opportunity to make yourself a nice beverage while waiting for the installation
    to complete. Once the installation of `elm-test` is complete, we can add the tests
    folder to our existing elm app simply by running the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着安装花费了超过10分钟的时间，这是在等待安装完成时制作一杯好饮料的完美机会。一旦`elm-test`的安装完成，我们可以通过运行以下命令将测试文件夹添加到现有的elm应用中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the preceding command gets run in the console, the console will record
    the progress by logging the following messages:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在控制台中运行前面的命令，控制台将通过记录以下消息来记录进度：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run the `dir` command to see the structure of our project, from its
    root:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`dir`命令来查看我们项目的结构，从其根目录开始：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command will return:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s change to the `tests` folder by running `cd tests`. Next, let''s
    inspect the structure of the `tests` folder by running the `dir` command again.
    What we get back is the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行`cd tests`命令切换到`tests`文件夹。接下来，让我们再次运行`dir`命令来检查`tests`文件夹的结构。我们得到以下结果：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first file in the list, `elm-package.json`, lists all the dependencies
    that are needed for our tests. Here is the content of the `elm-package.json` file
    that''s located inside the `tests` folder:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个文件，`elm-package.json`，列出了我们测试所需的所有依赖项。以下是位于`tests`文件夹内的`elm-package.json`文件的内容：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following lines from the preceding code are used for the semantic versioning
    of our package:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的行用于我们包的语义版本控制：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These lines are only relevant if you are going to publish a package on the
    Elm package page. Source directories lists the folders where our source files
    are located. In the case of our `tests` folder, it needs to have access to itself,
    signified by the `.`, and it needs to have access to its parent folder''s `src`
    folder, signified by `..\\src`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行仅在您打算在Elm包页面上发布包时才相关。源目录列出了我们的源文件所在的文件夹。在我们的`tests`文件夹的情况下，它需要访问自身，表示为`.`，并且需要访问其父文件夹的`src`文件夹，表示为`..\\src`：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exposed modules list all the modules that you want to expose to the public.
    This is only used when publishing a package and it does not need to be specified
    otherwise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露的模块列出了您希望公开的所有模块。这仅在发布包时使用，否则不需要指定。
- en: 'Dependencies lists all the packages that our tests depend on. It is interesting
    to compare the list of dependencies from the root of our weather app''s folder
    with the list of dependencies that our tests are using. To compare the two, let''s
    begin by listing the dependencies from the weather app''s folder:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项列表列出了我们的测试所依赖的所有包。将我们的天气应用文件夹根目录下的依赖项列表与我们的测试所使用的依赖项列表进行比较是很有趣的。为了比较这两个列表，让我们首先列出天气应用文件夹中的依赖项：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s list the dependencies inside the `test` folder:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们列出`test`文件夹内的依赖项：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, the `tests` folder includes all the dependencies used by our
    weather app, plus some additional dependencies. Since we already know what the
    packages inside the weather app''s `src` folder do, let''s focus on those that
    are specific to our tests folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`tests`文件夹包括了我们的天气应用所使用的所有依赖项，还有一些额外的依赖项。由于我们已经知道天气应用`src`文件夹内的包的功能，让我们专注于那些特定于我们的测试文件夹的依赖项：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, there are two packages that are specifically used in our `tests`
    folder. Before looking into what each of them does, let's briefly discuss package
    naming conventions, as well as our dependencies' versions as they were listed
    previously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有两个包是专门用于我们的`tests`文件夹的。在查看每个包的功能之前，让我们简要讨论包命名约定，以及我们之前列出的依赖项的版本。
- en: The way that Elm package naming works is simple. The part of the package name
    before the slash is the name of the GitHub account associated with the package.
    In other words, it's the GitHub username of the package author. The part of the
    package name after the slash should be as descriptive as possible. So, rather
    than enforcing unique naming for each package, Elm's philosophy is to have as
    descriptive a name as possible for a package, which will allow its potential users
    to discern the purpose of the package just by looking at its name. Thus, it's
    entirely possible that there is more than one `elm-html-test` package, and the
    uniqueness of the name is determined by the username of the package author.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 包命名的方式很简单。包名中斜杠之前的部分是与此包关联的 GitHub 账户的名称。换句话说，它是包作者的 GitHub 用户名。包名中斜杠之后的部分应该尽可能具有描述性。因此，而不是为每个包强制唯一的命名，Elm
    的理念是为包提供一个尽可能具有描述性的名称，这样它的潜在用户只需看一眼其名称就能辨别出包的用途。因此，完全有可能存在多个 `elm-html-test` 包，而名称的唯一性是由包作者的用户名决定的。
- en: The versions required for our `eeue56/elm-html-test` dependency are in a range
    between 5.1.3 and 6.0.0, meaning, that the lowest acceptable version is 5.1.3
    and the highest acceptable version is 6.0.0.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `eeue56/elm-html-test` 依赖项所需版本的范围在 5.1.3 和 6.0.0 之间，这意味着最低可接受的版本是 5.1.3，最高可接受的版本是
    6.0.0。
- en: To understand what these two packages do, we can refer to their official documentation,
    which is available at [http://package.elm-lang.org/packages/elm-community/elm-test/latest](http://package.elm-lang.org/packages/elm-community/elm-test/latest)
    and [http://package.elm-lang.org/packages/eeue56/elm-html-test/latest](http://package.elm-lang.org/packages/eeue56/elm-html-test/latest).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这两个包的功能，我们可以参考它们的官方文档，文档可在 [http://package.elm-lang.org/packages/elm-community/elm-test/latest](http://package.elm-lang.org/packages/elm-community/elm-test/latest)
    和 [http://package.elm-lang.org/packages/eeue56/elm-html-test/latest](http://package.elm-lang.org/packages/eeue56/elm-html-test/latest)
    找到。
- en: The `elm-community/elm-test` package allows us to write unit tests and fuzz
    tests. `eeue56/elm-html-test` allows us to test views by specifying the HTML values
    that we expect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`elm-community/elm-test` 包允许我们编写单元测试和模糊测试。`eeue56/elm-html-test` 允许我们通过指定我们期望的
    HTML 值来测试视图。'
- en: 'Continuing to inspect the contents of the tests folder, the `tests/elm-stuff`
    folder contains the downloaded packages and the list of exact versions of our
    dependencies, as listed in `exact-dependencies.json`. Next, the `Example.elm`
    file has all the necessary setup for us to run our first test. This is the code
    that our `Example.elm` file contains:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 继续检查测试文件夹的内容，`tests/elm-stuff` 文件夹包含下载的包以及我们依赖的确切版本列表，如 `exact-dependencies.json`
    文件中所示。接下来，`Example.elm` 文件包含了我们运行第一个测试所需的所有设置。这是 `Example.elm` 文件包含的代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code in this file follows the same rules as any other Elm code. On the first
    line, we are exposing the `Example` module. We follow it up with importing `Expect`,
    `Fuzz`, and `Test`, which are all needed for our tests to work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的代码遵循与其他 Elm 代码相同的规则。在第一行，我们暴露了 `Example` 模块。随后我们导入 `Expect`、`Fuzz` 和 `Test`，这些都是测试正常工作所必需的。
- en: It is helpful to be familiar with some of the jargon of software testing, as
    it will give some more context to our test writing. Tests are grouped into test
    suites. A test suite holds test cases. A test case is the smallest test unit.
    Therefore, appropriately, we start our testing in `Example.elm` by specifying
    a `suite` function, which will hold our tests. As we can see, the `suite` function
    is of type `Test`. The official documentation on `Test` can be found at [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉一些软件测试的术语会有所帮助，因为它将为我们编写测试提供更多上下文。测试被分组为测试套件。测试套件包含测试用例。测试用例是最小的测试单元。因此，适当地，我们在
    `Example.elm` 中通过指定一个 `suite` 函数开始我们的测试，该函数将包含我们的测试。正如我们所看到的，`suite` 函数的类型是 `Test`。有关
    `Test` 的官方文档可以在 [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test)
    找到。
- en: As the official documentation reads, a `Test` will produce at least one `Expectation`.
    Let's look at some other functions we'll use in our tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方文档所述，一个 `Test` 至少会产生一个 `Expectation`。让我们看看我们测试中还将使用的一些其他函数。
- en: The describe function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述函数
- en: Our tests are grouped inside a `List`. To describe what this `List` of tests
    is doing, we use the `describe` function. The signature of the `describe` function
    can be found at this link [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试被分组在一个`List`中。为了描述这个测试`List`的作用，我们使用`describe`函数。`describe`函数的签名可以在以下链接中找到[http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe)。
- en: 'As we can see from the URL provided, the `describe` function takes a `String`
    and a `List` of `Tests`, and returns a `Test`. In other words, it follows this
    kind of structure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从提供的URL中看到的那样，`describe`函数接受一个`String`和一个`Tests`的`List`，并返回一个`Test`。换句话说，它遵循以下结构：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this is not the actual Elm code, but rather an Elm-like pseudocode,
    written as an intermediate step to better understand tests in Elm.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是实际的Elm代码，而是一种类似于Elm的伪代码，作为理解Elm中测试的中间步骤来编写的。
- en: The test and Expect functions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和Expect函数
- en: The `test` function is used to write the actual unit test. The `test` function
    can have only one `Expectation`, and returns a `Test`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数用于编写实际的单元测试。`test`函数只能有一个`Expectation`，并返回一个`Test`。'
- en: '`Expectation` is a type alias. It can be one of the two: a `pass` or a `fail`.
    `Expect` has several functions, such as `Expect.equal`, `Expect.notEqual`, `Expect.lessThan`,
    and so on. For the full list of `Expect` functions, refer to the official documentation
    at [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expectation`是一个类型别名。它可以有两种：`pass`或`fail`。`Expect`有几个函数，例如`Expect.equal`、`Expect.notEqual`、`Expect.lessThan`等等。有关`Expect`函数的完整列表，请参阅官方文档[http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect)。'
- en: Now that we have covered some of the concepts and described the functions we
    will use, it's time to write our first unit test inside `Example.elm`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些概念并描述了我们将要使用的函数，是时候在`Example.elm`中编写我们的第一个单元测试了。
- en: Writing unit tests in Elm
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Elm中编写单元测试
- en: 'Let''s update the code of our `suite` function, so that it looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`suite`函数的代码，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s now run this test from the console, by pointing the console to the root
    of our project (one level up from the `test` folder), and typing the following
    command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从控制台运行这个测试，将控制台指向我们项目的根目录（在`test`文件夹之上的一级），并输入以下命令：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The console will log the following message:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将记录以下消息：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look at a single test case from the code that we have just tested:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚测试的代码中的一个单个测试用例：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s start with `<|` pipe operator.  What it does is evaluate the expression
    that can be found on its right-hand side, and passes it as an argument to the
    function on its left-hand side. In other words, to write the exact same text function
    without using the `<|` operator, we could have written it like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`<|`管道操作符开始。它所做的就是评估其右侧的表达式，并将其作为参数传递给左侧的函数。换句话说，如果不使用`<|`操作符，我们可以这样编写完全相同的文本函数：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let''s look inside the parentheses and describe what is happening there. The
    code inside the parentheses is the second argument of the `test` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看括号内部，并描述那里发生了什么。括号内的代码是`test`函数的第二个参数：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This second argument is an anonymous function which ignores its parameter,
    which is signified by this bit of code: `\_`. Earlier in the book, we discussed
    how every function in Elm is curried, and how, using partial application, we can
    conclude that each function in Elm can be made to take only one argument. With
    `\_`, that one argument is ignored.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个忽略其参数的匿名函数，这由以下代码表示：`_`。在本书早期，我们讨论了Elm中每个函数都是柯里化的，以及如何通过部分应用，我们可以得出结论，Elm中的每个函数都可以被设计成只接受一个参数。使用`_`，这个参数就被忽略了。
- en: The arrow (`->`) in anonymous functions is the same as the equals sign (`=`)
    in regular functions. The `Expect.equal` will, as mentioned, return either a `pass`
    or a `fail`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数中的箭头（`->`）与常规函数中的等号（`=`）相同。`Expect.equal`将如之前所述，返回一个`pass`或`fail`。
- en: '`Expect.equal` takes two arguments: the first one is the expected value, and
    the second one is the expression that will be tested and that will either be the
    same as the expected value (so a `pass` gets returned), or not (so a `fail` gets
    returned).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expect.equal` 接受两个参数：第一个是期望值，第二个是要测试的表达式，该表达式要么与期望值相同（因此返回一个 `pass`），要么不同（因此返回一个
    `fail`）。'
- en: Since zero is indeed equal to one minus one, we got a `pass`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于零确实等于一减一，所以我们得到了一个 `pass`。
- en: 'Going back to using the `<|` pipe operator, we could have written this anonymous
    function as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到使用 `<|` 管道操作符，我们可以这样编写这个匿名函数：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Thus, we could, if we wanted to, rewrite the entire `suite` function without
    any parentheses, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想的话，可以没有任何括号地重写整个 `suite` 函数，如下所示：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Everything will still work as expected, and our tests, if we ran them again,
    would still pass.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一切仍然会按预期工作，如果我们再次运行测试，我们的测试仍然会通过。
- en: 'Let''s now divert our attention to the other test file in the `tests` folder,
    called `Tests.elm`. The `Tests.elm` file has the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向 `tests` 文件夹中的另一个测试文件，名为 `Tests.elm`。`Tests.elm` 文件有以下代码：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s run the test in our console by simply running the `elm-test` command
    from the root of our app''s folder:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制台中运行测试，只需从我们的应用程序文件夹的根目录运行 `elm-test` 命令：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following information will be logged to the console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息将被记录到控制台：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This test failed,  but as the console output reads, that was expected. As can
    be seen in the code of the `Tests.elm` file, when we need to write a failing test,
    we simply use the `Expect.fail` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败了，但正如控制台输出所示，这是预期的。正如在 `Tests.elm` 文件的代码中可以看到的，当我们需要编写一个失败的测试时，我们只需简单地使用
    `Expect.fail` 函数。
- en: As we will continue working with the `Tests.elm` file in the following sections
    of this chapter, a useful command that we can use is `elm-test --watch`. If you
    are familiar with a number of different utilities that can be run in the console,
    the `--watch` flag watches for changes in our code and reruns the command that
    the `--watch` flag is appended to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续使用 `Tests.elm` 文件，一个有用的命令是我们可以使用 `elm-test --watch`。如果你熟悉可以在控制台中运行的许多不同的实用工具，那么
    `--watch` 标志会监视我们代码中的更改，并重新运行附加了 `--watch` 标志的命令。
- en: This means that we'll only need to run the `elm-test --watch` command once,
    and every time we save the `Tests.elm` file, it will run our test suite again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只需要运行一次 `elm-test --watch` 命令，每次我们保存 `Tests.elm` 文件时，它都会再次运行我们的测试套件。
- en: Using let-in expressions in our tests
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的测试中使用 let-in 表达式
- en: 'Let''s add a let-in expression to our `Example.elm` file. To do that, we''ll
    specify another test suite by using another `describe` function, and then we''ll
    wrap all our tests in yet another `describe` function. This outermost `describe`
    function will contain all the other describe functions, which will, in turn, hold
    all the `Lists` of `test` functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 `Example.elm` 文件中添加一个 let-in 表达式。为了做到这一点，我们将使用另一个 `describe` 函数来指定另一个测试套件，然后我们将用另一个
    `describe` 函数包裹所有的测试。最外层的 `describe` 函数将包含所有的其他 `describe` 函数，而这些函数反过来将包含所有的 `test`
    函数的 `Lists`：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running this `Example.elm` file with `elm-test tests/Example.elm` will produce
    the following output to the console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `elm-test tests/Example.elm` 运行此 `Example.elm` 文件将在控制台产生以下输出：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, this example is trivial, but it is helpful to see a very simple implementation
    that you can build from.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子很简单，但看到一个非常简单的实现，你可以从中构建出来，是有帮助的。
- en: Decoding JSON in our tests
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的测试中解码 JSON
- en: Decoding JSON in our tests is simple.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中解码 JSON 是简单的。
- en: To begin, let's add a new file inside our `tests` folder. We'll call this new
    file `DecoderTests.elm.`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的 `tests` 文件夹中添加一个新的文件。我们将把这个新文件命名为 `DecoderTests.elm`。
- en: 'Next, let''s add the following code to `DecoderTests.elm`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将以下代码添加到 `DecoderTests.elm`：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can run our tests:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The console will log the following information:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将记录以下信息：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code we wrote to test this JSON has a total of three tests. The first test
    is written so that it doesn't fail. The other two are written to fail, but they
    are commented out. Feel free to un-comment the other two tests and see the result
    in the console.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的测试此 JSON 的代码总共有三个测试。第一个测试编写得不会失败。其他两个测试编写得会失败，但它们被注释掉了。你可以随意取消注释其他两个测试，并在控制台中查看结果。
- en: 'In order to be able to parse JSON properly, we need to escape double quotes
    in the JSON string. That''s why the `jsonInput` variable looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够正确解析 JSON，我们需要在 JSON 字符串中转义双引号。这就是为什么 `jsonInput` 变量看起来是这样的：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An alternative approach would be to enclose the entire JSON string inside the
    opening and closing multiline quotes, which, as mentioned earlier in the book,
    are groupings of three double quotes, like this: `"""`. We will see an example
    of this approach in the next section, when we build some custom expectations.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Building custom expectations while decoding JSON
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build custom expectations, we can refer to the previously-mentioned `pass`
    and `fail` functions. The `pass` function will always pass, and the `fail` function
    will fail with a message. To produce a custom message, you can use the `onFail`
    function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example by creating a new file inside the `tests` folder. We''ll
    call this new file `CustomExpectations.elm` and add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we ran this test with the command `elm-test tests/CustomExpectations.elm`,
    we would get the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the code, we are setting the type alias `Player` in the global scope so that
    we can access it in our tests when needed. The `Person` type alias is a record
    that has the `name` field, which is a `String`, and the `language` field, with
    is also a `String`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We use the `describe` function to describe our suite of tests, and then we describe
    the first `List` of tests, which actually holds only one test right now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `playerDecoder` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we learned in [Chapter 6](651ea5bb-9106-4053-b8b4-6481508a775b.xhtml), *Exploring
    Elm in Greater Detail*, `string` is a decoder with the following signature:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, `string` is a decoder of `Strings`, meaning it translates JSON `strings`
    into Elm `Strings`, and this process of parsing JSON `strings` into Elm `Strings`
    is called *decoding*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The expression `field "name" string` is also a decoder of `Strings`, and the
    entire `playerDecoder` is a complex decoder that is composed of the `field "name"
    string` decoder and the `field "age" string` decoder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Inside the anonymous function, we provide the `let-in` expression. Inside the
    `let` portion of the `let-in` expression, we define our `json` string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Finally, inside the `in` portion of the `let-in` expression, we evaluate a `case-of`
    expression, and with the help of the `pass` and `fail` functions, we write our
    custom expectations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at fuzz testing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Writing fuzz tests in Elm
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz tests allow us to take our unit tests to a new level by enabling us to
    run an arbitrary number of combinations of values in our tests, by virtue of randomizing
    some of the inputs in our tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In order to see how fuzz tests work, let's compare unit tests with fuzz tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the regular unit test that we have already worked with earlier
    in this chapter. To refresh our memory of this test, let''s add it as the contents
    of `Example.elm`, and then run the actual test:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that, in this code, the Fuzz import is commented out, since the compiler
    would give us a warning about this import not being used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If we ran this test, it would log a successful test message to the console,
    with the information that two tests have passed and zero have failed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个测试，它将在控制台输出一个成功的测试消息，显示两个测试通过，零个失败。
- en: Although the example is very simplistic, it will help us compare unit tests
    and fuzz tests in Elm. The very fact that we are listing two tests hints at the
    usefulness of fuzz tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子非常简单，但它将帮助我们比较 Elm 中的单元测试和模糊测试。我们列出两个测试的事实本身就暗示了模糊测试的有用性。
- en: If we wanted to make sure that `Expect.equal` will return zero for any number
    subtracted by itself, we could possibly write a number of tests to confirm this
    behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确保 `Expect.equal` 对于任何减去自身的数字都会返回零，我们可能需要编写多个测试来确认这种行为。
- en: 'However, writing a fuzz test would be a much better solution. Let''s look at
    the updated code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写模糊测试将是一个更好的解决方案。让我们看看更新后的代码：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, let's rewrite this unit test in the form of a fuzz test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个单元测试重写为模糊测试的形式。
- en: 'We''ll uncomment the Fuzz import, and we''ll randomize some of the inputs in
    our test, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取消注释 Fuzz 导入，并在我们的测试中随机化一些输入，如下所示：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This test will run 100 times. This makes us draw conclusions about our passing
    tests with a lot more confidence than we would writing just plain old unit tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将运行 100 次。这使得我们比编写普通的单元测试更有信心地得出通过测试的结论。
- en: 'Looking at the anatomy of our fuzz test syntax, we can see that the fuzz function
    takes three parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的模糊测试语法的结构，我们可以看到模糊函数接受三个参数：
- en: a `fuzzer`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `fuzzer`
- en: a `String` to describe the fuzz test
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于描述模糊测试的 `String`
- en: an anonymous function (which takes an actual argument, contrary to a unit test,
    which takes a `Unit` as its parameter)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匿名函数（与单元测试不同，它接受一个实际参数）
- en: Thus, this fuzz test's fuzzer is used to generate `int` values. The `int` fuzzer
    generates random `Ints`. The `String` used to describe the fuzz test is straightforward.
    We are using the `String` that reads *Zero is equal to random number minus itself*.
    Finally, our anonymous function `\` takes the parameter we named `randomNumber`.
    Since we are using `randomNumber` in our actual `Expect.equal` assertion, it makes
    perfect sense to pass this argument to the anonymous function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个模糊测试的模糊器用于生成 `int` 值。`int` 模糊器生成随机的 `Ints`。用于描述模糊测试的 `String` 是直接的。我们使用的是读取为“零等于随机数减去自身”的
    `String`。最后，我们的匿名函数 `\` 接收我们命名为 `randomNumber` 的参数。由于我们在实际的 `Expect.equal` 断言中使用
    `randomNumber`，将此参数传递给匿名函数是完美的。
- en: Working with more than one fuzzer
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个模糊器一起工作
- en: 'Similarly to how we can use `map2`, `map3`, `map4`, and so on, depending on
    how many fields we are decoding from JSON values to Elm values, we also have at
    our disposal the following functions: `fuzz2,` `fuzz3`, `fuzz4`, and `fuzz5`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们可以使用 `map2`、`map3`、`map4` 等等，根据我们从 JSON 值解码到 Elm 值的字段数量，我们还有以下函数可供使用：`fuzz2`、`fuzz3`、`fuzz4`
    和 `fuzz5`。
- en: 'Let''s update our `Example.elm` test so that it uses the `fuzz2` function.
    To make things simple, we''ll test commutation in number addition. This is the
    rule in mathematics that says that if we flip the order of numbers that we are
    adding, the result will be the same:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的 `Example.elm` 测试，使其使用 `fuzz2` 函数。为了简化，我们将测试数字加法的交换律。这是数学中的规则，即如果我们交换相加的数字的顺序，结果将相同：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All 100 tests pass as expected. It is important to note that the console output
    will list these 100 tests as only one test passing, since in effect that is what
    is happening. There is indeed only one test being run, albeit with 100 different
    combinations of values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 100 个测试都如预期通过。重要的是要注意，控制台输出将只列出通过的一个测试，因为实际上就是这样。确实只有一个测试在运行，尽管有 100 种不同的值组合。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned the basics of unit testing and fuzz testing in
    Elm. We learned about the structure and syntax of tests in Elm:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Elm 中单元测试和模糊测试的基础。我们了解了 Elm 测试的结构和语法：
- en: We learned about `describe`, `Expect.equals`, and `test`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了 `describe`、`Expect.equals` 和 `test`
- en: We discussed how and why to use `\_` and `<|` in Elm tests
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何在 Elm 测试中使用 `\_` 和 `<|`
- en: We wrote tests to decode JSON strings to Elm values
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写了将 JSON 字符串解码为 Elm 值的测试
- en: We looked at the difference between unit tests and fuzz tests
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了单元测试和模糊测试之间的区别
- en: We wrote fuzz tests that take more than one argument
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写了接受多个参数的模糊测试
- en: However, the material covered in this chapter is only the beginning. TDD (test-driven
    development) is an approach to building software that embraces testing throughout
    our application's life cycle; actually, as its name suggests, it is an approach
    in which testing drives the complete development process. With the topics covered
    in this course, you should be able to start implementing tests routinely in your
    Elm development.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章所涵盖的内容仅仅是开始。TDD（测试驱动开发）是一种构建软件的方法，它在整个应用程序的生命周期中拥抱测试；实际上，正如其名称所暗示的，它是一种测试驱动整个开发过程的方法。通过本课程所涵盖的主题，你应该能够开始在
    Elm 开发中例行实施测试。
- en: In the next chapter, we will look at authentication in our Elm apps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Elm 应用程序中的身份验证。
