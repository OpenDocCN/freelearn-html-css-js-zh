- en: Testing in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to test our Elm apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Elm apps with `elm-test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure and the role of the `elm-package.json` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure and functionality of the `tests` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `describe`, `test`, and `Expect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing easier-to-understand tests with the `left pipe operator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `let-in` and `case-of` expressions in our tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzz testing in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a general idea of how unit testing works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how unit testing and fuzz testing works in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand different ways in which you can test your Elm apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to successfully deploy a variety of tests in your Elm apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Elm testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the compiler catches all errors at compilation, the highly-touted zero
    runtime exceptions is the expected outcome for Elm apps that compile successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Since that is the case, one might ask whether we need to test our Elm apps at
    all. The answer is a resounding yes, primarily because the compiler will not test
    the *behavior* of the app. While the Elm compiler's error-checking is indeed a
    wonderful tool, it will only test for logical inconsistencies, and that is pretty
    much it.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for this chapter, we'll start with the code from the previous chapter.
    Simply copy the entire folder titled `improved-weather-app-ch8` and paste it in
    another location.
  prefs: []
  type: TYPE_NORMAL
- en: The code files that come with this book have this pasted folder inside `chapter9`,
    and the copy-pasted folder that can be found *inside* the `chapter9` folder has
    been renamed to `weather-app-with-tests-ch9`.
  prefs: []
  type: TYPE_NORMAL
- en: It's sometimes helpful to simply copy and paste an existing Elm project into
    a new folder and then change it, rather than create it from scratch with, for
    example, the `create-elm-app` package.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how testing works in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin working with testing in Elm by pointing our console to the `weather-app-with-tests-ch9`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our terminal pointed to the proper directory, we will need to install
    `elm-test` as an npm package. There are a number of utilities used in the Elm
    community that have their npm versions, and `elm-test` is just one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to install `elm-test`, let''s run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's it! The `elm-test` npm package is now available globally, because we
    passed the `-g` flag to the command. What this means is we can use elm-test in
    any folder, not just the one we are currently in.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the installation of the elm-test npm package will take some time,
    so feel free to take a break while it is being installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation gets going, a number of messages will be logged to the
    console. These messages will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the last line of the preceding code, which reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the installation took a bit over 10 minutes, which is a perfect
    opportunity to make yourself a nice beverage while waiting for the installation
    to complete. Once the installation of `elm-test` is complete, we can add the tests
    folder to our existing elm app simply by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command gets run in the console, the console will record
    the progress by logging the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `dir` command to see the structure of our project, from its
    root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change to the `tests` folder by running `cd tests`. Next, let''s
    inspect the structure of the `tests` folder by running the `dir` command again.
    What we get back is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first file in the list, `elm-package.json`, lists all the dependencies
    that are needed for our tests. Here is the content of the `elm-package.json` file
    that''s located inside the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines from the preceding code are used for the semantic versioning
    of our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines are only relevant if you are going to publish a package on the
    Elm package page. Source directories lists the folders where our source files
    are located. In the case of our `tests` folder, it needs to have access to itself,
    signified by the `.`, and it needs to have access to its parent folder''s `src`
    folder, signified by `..\\src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Exposed modules list all the modules that you want to expose to the public.
    This is only used when publishing a package and it does not need to be specified
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies lists all the packages that our tests depend on. It is interesting
    to compare the list of dependencies from the root of our weather app''s folder
    with the list of dependencies that our tests are using. To compare the two, let''s
    begin by listing the dependencies from the weather app''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s list the dependencies inside the `test` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `tests` folder includes all the dependencies used by our
    weather app, plus some additional dependencies. Since we already know what the
    packages inside the weather app''s `src` folder do, let''s focus on those that
    are specific to our tests folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are two packages that are specifically used in our `tests`
    folder. Before looking into what each of them does, let's briefly discuss package
    naming conventions, as well as our dependencies' versions as they were listed
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: The way that Elm package naming works is simple. The part of the package name
    before the slash is the name of the GitHub account associated with the package.
    In other words, it's the GitHub username of the package author. The part of the
    package name after the slash should be as descriptive as possible. So, rather
    than enforcing unique naming for each package, Elm's philosophy is to have as
    descriptive a name as possible for a package, which will allow its potential users
    to discern the purpose of the package just by looking at its name. Thus, it's
    entirely possible that there is more than one `elm-html-test` package, and the
    uniqueness of the name is determined by the username of the package author.
  prefs: []
  type: TYPE_NORMAL
- en: The versions required for our `eeue56/elm-html-test` dependency are in a range
    between 5.1.3 and 6.0.0, meaning, that the lowest acceptable version is 5.1.3
    and the highest acceptable version is 6.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what these two packages do, we can refer to their official documentation,
    which is available at [http://package.elm-lang.org/packages/elm-community/elm-test/latest](http://package.elm-lang.org/packages/elm-community/elm-test/latest)
    and [http://package.elm-lang.org/packages/eeue56/elm-html-test/latest](http://package.elm-lang.org/packages/eeue56/elm-html-test/latest).
  prefs: []
  type: TYPE_NORMAL
- en: The `elm-community/elm-test` package allows us to write unit tests and fuzz
    tests. `eeue56/elm-html-test` allows us to test views by specifying the HTML values
    that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing to inspect the contents of the tests folder, the `tests/elm-stuff`
    folder contains the downloaded packages and the list of exact versions of our
    dependencies, as listed in `exact-dependencies.json`. Next, the `Example.elm`
    file has all the necessary setup for us to run our first test. This is the code
    that our `Example.elm` file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code in this file follows the same rules as any other Elm code. On the first
    line, we are exposing the `Example` module. We follow it up with importing `Expect`,
    `Fuzz`, and `Test`, which are all needed for our tests to work.
  prefs: []
  type: TYPE_NORMAL
- en: It is helpful to be familiar with some of the jargon of software testing, as
    it will give some more context to our test writing. Tests are grouped into test
    suites. A test suite holds test cases. A test case is the smallest test unit.
    Therefore, appropriately, we start our testing in `Example.elm` by specifying
    a `suite` function, which will hold our tests. As we can see, the `suite` function
    is of type `Test`. The official documentation on `Test` can be found at [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test).
  prefs: []
  type: TYPE_NORMAL
- en: As the official documentation reads, a `Test` will produce at least one `Expectation`.
    Let's look at some other functions we'll use in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: The describe function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our tests are grouped inside a `List`. To describe what this `List` of tests
    is doing, we use the `describe` function. The signature of the `describe` function
    can be found at this link [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe)
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the URL provided, the `describe` function takes a `String`
    and a `List` of `Tests`, and returns a `Test`. In other words, it follows this
    kind of structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is not the actual Elm code, but rather an Elm-like pseudocode,
    written as an intermediate step to better understand tests in Elm.
  prefs: []
  type: TYPE_NORMAL
- en: The test and Expect functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `test` function is used to write the actual unit test. The `test` function
    can have only one `Expectation`, and returns a `Test`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Expectation` is a type alias. It can be one of the two: a `pass` or a `fail`.
    `Expect` has several functions, such as `Expect.equal`, `Expect.notEqual`, `Expect.lessThan`,
    and so on. For the full list of `Expect` functions, refer to the official documentation
    at [http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect](http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some of the concepts and described the functions we
    will use, it's time to write our first unit test inside `Example.elm`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update the code of our `suite` function, so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run this test from the console, by pointing the console to the root
    of our project (one level up from the `test` folder), and typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The console will log the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a single test case from the code that we have just tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with `<|` pipe operator.  What it does is evaluate the expression
    that can be found on its right-hand side, and passes it as an argument to the
    function on its left-hand side. In other words, to write the exact same text function
    without using the `<|` operator, we could have written it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look inside the parentheses and describe what is happening there. The
    code inside the parentheses is the second argument of the `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This second argument is an anonymous function which ignores its parameter,
    which is signified by this bit of code: `\_`. Earlier in the book, we discussed
    how every function in Elm is curried, and how, using partial application, we can
    conclude that each function in Elm can be made to take only one argument. With
    `\_`, that one argument is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: The arrow (`->`) in anonymous functions is the same as the equals sign (`=`)
    in regular functions. The `Expect.equal` will, as mentioned, return either a `pass`
    or a `fail`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Expect.equal` takes two arguments: the first one is the expected value, and
    the second one is the expression that will be tested and that will either be the
    same as the expected value (so a `pass` gets returned), or not (so a `fail` gets
    returned).'
  prefs: []
  type: TYPE_NORMAL
- en: Since zero is indeed equal to one minus one, we got a `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to using the `<|` pipe operator, we could have written this anonymous
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we could, if we wanted to, rewrite the entire `suite` function without
    any parentheses, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Everything will still work as expected, and our tests, if we ran them again,
    would still pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now divert our attention to the other test file in the `tests` folder,
    called `Tests.elm`. The `Tests.elm` file has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the test in our console by simply running the `elm-test` command
    from the root of our app''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following information will be logged to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This test failed,  but as the console output reads, that was expected. As can
    be seen in the code of the `Tests.elm` file, when we need to write a failing test,
    we simply use the `Expect.fail` function.
  prefs: []
  type: TYPE_NORMAL
- en: As we will continue working with the `Tests.elm` file in the following sections
    of this chapter, a useful command that we can use is `elm-test --watch`. If you
    are familiar with a number of different utilities that can be run in the console,
    the `--watch` flag watches for changes in our code and reruns the command that
    the `--watch` flag is appended to.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we'll only need to run the `elm-test --watch` command once,
    and every time we save the `Tests.elm` file, it will run our test suite again.
  prefs: []
  type: TYPE_NORMAL
- en: Using let-in expressions in our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a let-in expression to our `Example.elm` file. To do that, we''ll
    specify another test suite by using another `describe` function, and then we''ll
    wrap all our tests in yet another `describe` function. This outermost `describe`
    function will contain all the other describe functions, which will, in turn, hold
    all the `Lists` of `test` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this `Example.elm` file with `elm-test tests/Example.elm` will produce
    the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this example is trivial, but it is helpful to see a very simple implementation
    that you can build from.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding JSON in our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decoding JSON in our tests is simple.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let's add a new file inside our `tests` folder. We'll call this new
    file `DecoderTests.elm.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the following code to `DecoderTests.elm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The console will log the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code we wrote to test this JSON has a total of three tests. The first test
    is written so that it doesn't fail. The other two are written to fail, but they
    are commented out. Feel free to un-comment the other two tests and see the result
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to parse JSON properly, we need to escape double quotes
    in the JSON string. That''s why the `jsonInput` variable looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative approach would be to enclose the entire JSON string inside the
    opening and closing multiline quotes, which, as mentioned earlier in the book,
    are groupings of three double quotes, like this: `"""`. We will see an example
    of this approach in the next section, when we build some custom expectations.'
  prefs: []
  type: TYPE_NORMAL
- en: Building custom expectations while decoding JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build custom expectations, we can refer to the previously-mentioned `pass`
    and `fail` functions. The `pass` function will always pass, and the `fail` function
    will fail with a message. To produce a custom message, you can use the `onFail`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example by creating a new file inside the `tests` folder. We''ll
    call this new file `CustomExpectations.elm` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran this test with the command `elm-test tests/CustomExpectations.elm`,
    we would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we are setting the type alias `Player` in the global scope so that
    we can access it in our tests when needed. The `Person` type alias is a record
    that has the `name` field, which is a `String`, and the `language` field, with
    is also a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `describe` function to describe our suite of tests, and then we describe
    the first `List` of tests, which actually holds only one test right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `playerDecoder` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in [Chapter 6](651ea5bb-9106-4053-b8b4-6481508a775b.xhtml), *Exploring
    Elm in Greater Detail*, `string` is a decoder with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, `string` is a decoder of `Strings`, meaning it translates JSON `strings`
    into Elm `Strings`, and this process of parsing JSON `strings` into Elm `Strings`
    is called *decoding*.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `field "name" string` is also a decoder of `Strings`, and the
    entire `playerDecoder` is a complex decoder that is composed of the `field "name"
    string` decoder and the `field "age" string` decoder.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the anonymous function, we provide the `let-in` expression. Inside the
    `let` portion of the `let-in` expression, we define our `json` string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, inside the `in` portion of the `let-in` expression, we evaluate a `case-of`
    expression, and with the help of the `pass` and `fail` functions, we write our
    custom expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at fuzz testing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing fuzz tests in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz tests allow us to take our unit tests to a new level by enabling us to
    run an arbitrary number of combinations of values in our tests, by virtue of randomizing
    some of the inputs in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see how fuzz tests work, let's compare unit tests with fuzz tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the regular unit test that we have already worked with earlier
    in this chapter. To refresh our memory of this test, let''s add it as the contents
    of `Example.elm`, and then run the actual test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this code, the Fuzz import is commented out, since the compiler
    would give us a warning about this import not being used.
  prefs: []
  type: TYPE_NORMAL
- en: If we ran this test, it would log a successful test message to the console,
    with the information that two tests have passed and zero have failed.
  prefs: []
  type: TYPE_NORMAL
- en: Although the example is very simplistic, it will help us compare unit tests
    and fuzz tests in Elm. The very fact that we are listing two tests hints at the
    usefulness of fuzz tests.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to make sure that `Expect.equal` will return zero for any number
    subtracted by itself, we could possibly write a number of tests to confirm this
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, writing a fuzz test would be a much better solution. Let''s look at
    the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's rewrite this unit test in the form of a fuzz test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll uncomment the Fuzz import, and we''ll randomize some of the inputs in
    our test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This test will run 100 times. This makes us draw conclusions about our passing
    tests with a lot more confidence than we would writing just plain old unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the anatomy of our fuzz test syntax, we can see that the fuzz function
    takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: a `fuzzer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `String` to describe the fuzz test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an anonymous function (which takes an actual argument, contrary to a unit test,
    which takes a `Unit` as its parameter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, this fuzz test's fuzzer is used to generate `int` values. The `int` fuzzer
    generates random `Ints`. The `String` used to describe the fuzz test is straightforward.
    We are using the `String` that reads *Zero is equal to random number minus itself*.
    Finally, our anonymous function `\` takes the parameter we named `randomNumber`.
    Since we are using `randomNumber` in our actual `Expect.equal` assertion, it makes
    perfect sense to pass this argument to the anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with more than one fuzzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly to how we can use `map2`, `map3`, `map4`, and so on, depending on
    how many fields we are decoding from JSON values to Elm values, we also have at
    our disposal the following functions: `fuzz2,` `fuzz3`, `fuzz4`, and `fuzz5`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Example.elm` test so that it uses the `fuzz2` function.
    To make things simple, we''ll test commutation in number addition. This is the
    rule in mathematics that says that if we flip the order of numbers that we are
    adding, the result will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All 100 tests pass as expected. It is important to note that the console output
    will list these 100 tests as only one test passing, since in effect that is what
    is happening. There is indeed only one test being run, albeit with 100 different
    combinations of values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned the basics of unit testing and fuzz testing in
    Elm. We learned about the structure and syntax of tests in Elm:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned about `describe`, `Expect.equals`, and `test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed how and why to use `\_` and `<|` in Elm tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We wrote tests to decode JSON strings to Elm values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at the difference between unit tests and fuzz tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We wrote fuzz tests that take more than one argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the material covered in this chapter is only the beginning. TDD (test-driven
    development) is an approach to building software that embraces testing throughout
    our application's life cycle; actually, as its name suggests, it is an approach
    in which testing drives the complete development process. With the topics covered
    in this course, you should be able to start implementing tests routinely in your
    Elm development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at authentication in our Elm apps.
  prefs: []
  type: TYPE_NORMAL
