- en: Service Worker Caching Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作线程缓存模式
- en: The internet is great, until you are offline or have poor connectivity. Then
    it becomes an act of futility as you wait for a page to load that never seems
    to materialize. Eventually, the request times out and the browser displays a message
    letting you know you're offline—Chrome is known for its cute offline dinosaur.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网很棒，直到你离线或连接不良。然后，当你等待一个似乎永远不会出现的页面加载时，它变成了一种徒劳的行为。最终，请求超时，浏览器显示一条消息告诉你你已离线——Chrome以其可爱的离线恐龙而闻名。
- en: Most web traffic comes from smartphones, and many of those connections are made
    over a cellular connection (GPRS). Cellular networks are great when they work,
    but often a clean connection to the internet is not guaranteed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络流量来自智能手机，其中许多连接是通过蜂窝连接（GPRS）完成的。当蜂窝网络工作良好时，它们很棒，但通常无法保证有一个干净的网络连接。
- en: Even in the United States, reliable LTE networks are not ubiquitous. There are
    several locations near my house where I have no cell coverage. Imagine what it
    might be like in a less developed area.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在美国，可靠的LTE网络也不是无处不在。在我家附近有几个地方我没有任何蜂窝信号。想象一下在欠发达地区可能会是什么样子。
- en: This is where service workers and the Cache API can help you out. The combination
    of these two features enables you to make the network optional. A service worker
    has several events that you can leverage to craft a web server in the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务工作线程和缓存API能帮到你的时候。这两个功能的组合使你可以使网络成为可选的。服务工作线程有几个事件，你可以利用这些事件在浏览器中构建一个网络服务器。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the service worker cache works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作线程缓存的工作原理
- en: Common service worker caching strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的服务工作线程缓存策略
- en: How the service worker cache works
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作线程缓存的工作原理
- en: 'The service worker sits between the browser and the network. By adding a `fetch`
    event handler, you can determine how the request is handled. All network requests
    pass through the service worker''s fetch event handler:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作线程位于浏览器和网络之间。通过添加一个`fetch`事件处理器，你可以确定如何处理请求。所有网络请求都通过服务工作线程的`fetch`事件处理器：
- en: '![](img/00071.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: This gives you a hook, or way to inject logic into the workflow, to intercept
    requests and determine how and where the response is returned.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个钩子，或者说是将逻辑注入工作流程的方法，以拦截请求并确定响应如何以及在哪里返回。
- en: 'With the service worker, you can do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务工作线程（Service Worker），你可以做以下事情：
- en: Pass the request to the network, the traditional method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求传递给网络，传统方法
- en: Return a cached response, bypassing the network altogether
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回缓存响应，完全绕过网络
- en: Create a custom response
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义响应
- en: 'When the network fails, you can program the service worker to return a response
    from the cache, even if it is a *fallback* response. Because the service worker
    can return responses from the cache, your pages can load instantly if they are
    cached:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络失败时，你可以编程服务工作线程从缓存返回一个响应，即使它是一个*回退*响应。因为服务工作线程可以从缓存返回响应，如果你的页面被缓存，它们可以立即加载：
- en: '![](img/00072.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: In the preceding diagram, the service worker is programmed to intercept all
    network requests, and can return a response from either the cache or the network.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，服务工作线程被编程为拦截所有网络请求，并可以从缓存或网络返回响应。
- en: Because the service worker runs locally, it is always available. It can decide
    the best way to return a response based on the conditions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务工作线程在本地运行，它始终可用。它可以根据条件决定返回响应的最佳方式。
- en: 'The following diagram illustrates the service worker living within the context
    of the browser, providing a proxy to handle requests, even when the network is
    unavailable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了服务工作线程在浏览器上下文中运行，提供代理来处理请求，即使网络不可用：
- en: '![](img/00073.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: When utilizing a service worker and the network is unavailable, your website
    can still function if you have valid cached responses. Even if a page is not cached,
    you can create a response so that the customer has something relevant to interact
    with. Later in the book, I will go over how you can queue the user's actions and
    update the server when the network is available.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用服务工作线程且网络不可用时，如果你的网站有有效的缓存响应，它仍然可以正常工作。即使页面没有缓存，你也可以创建一个响应，让客户有相关的内容可以与之互动。在本书的后面部分，我将介绍如何在网络可用时排队用户的操作并更新服务器。
- en: 'The following diagram shows how the service worker can use cached resources
    when the network is unavailable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了服务工作线程在网络不可用时如何使用缓存资源：
- en: '![](img/00074.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: Service worker events
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Service Worker 事件
- en: A service worker has several events. You can use these to manage your application's
    cache. We have already looked at using the *install* and *activate* events to
    precache responses in Chapter 5,  *The Service Worker Life Cycle*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Service Worker 有几个事件。你可以使用这些事件来管理你的应用缓存。我们已经在第 5 章，“Service Worker 生命周期”中探讨了如何使用
    `install` 和 `activate` 事件来预缓存响应。
- en: 'The all-star service worker event is `fetch`. This event fires each time a
    network-addressable asset (URL) is requested. By adding a `fetch` event handler
    to your service worker, you can intercept all network requests, triggering a workflow
    to determine how to respond:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 全明星 Service Worker 事件是 `fetch`。每次请求网络地址资产（URL）时，都会触发此事件。通过向你的 Service Worker
    添加 `fetch` 事件处理器，你可以拦截所有网络请求，触发一个工作流程来确定如何响应：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you learned [Chapter 6](part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d), *Mastering
    the Cache API – Managing Web Assets in a Podcast Application*, you can use the
    Fetch API's custom `request` and `response` objects to inspect requests and create
    or clone network responses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学 [第 6 章](part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d)，“掌握 Cache
    API – 在播客应用程序中管理 Web 资产”，你可以使用 Fetch API 的自定义 `request` 和 `response` 对象来检查请求和创建或克隆网络响应。
- en: The event variable supplied by the `fetch` event handler has a request property.
    This property is a `request` object. You can use the `request` object to determine
    how you will return the response. In this chapter, you will learn several caching
    strategies that you can apply to make your progressive web application work faster, and offline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 事件处理器提供的事件变量有一个请求属性。这个属性是一个 `request` 对象。你可以使用 `request` 对象来确定你将如何返回响应。在本章中，你将学习到几个可以应用来使你的渐进式
    Web 应用工作更快、离线的缓存策略。'
- en: Knowing how to use the `fetch` event to maximize performance using the application's
    cache is the key to providing the best user experience possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用 `fetch` 事件来最大化应用缓存的使用性能，是提供最佳用户体验的关键。
- en: Caching patterns and strategies
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存模式和策略
- en: Service worker events give you gateways to the service worker life cycle in
    order to apply your caching strategy. But there is more to this than just checking
    whether a valid response has been cached or is passing the request to the network.
    You should have a plan of how your application will use the service worker cache,
    events, and the network to deliver the best experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Service Worker 事件为你提供了通往 Service Worker 生命周期的门户，以便应用你的缓存策略。但这不仅仅是检查是否已缓存有效的响应或将请求传递给网络。你应该有一个计划，说明你的应用将如何使用
    Service Worker 缓存、事件和网络来提供最佳体验。
- en: This means that you need to have a collection of common patterns and strategies
    to build your application logic upon. The rest of the chapter will review common
    caching patterns that you can use to build your applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要有一系列常见的模式和策略来构建你的应用程序逻辑。本章的其余部分将回顾你可以用来构建应用程序的常见缓存模式。
- en: Strategies are the combination of guidelines and example code that you can use
    to build your applications. As you continue through this book, you will see these
    strategies used in the PodStr and PWA Tickets applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是指导原则和示例代码的组合，你可以使用它们来构建你的应用程序。随着你继续阅读本书，你将看到这些策略在 PodStr 和 PWA Tickets 应用程序中的应用。
- en: Precaching
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预缓存
- en: One of the key aspects of the PRPL pattern, which we will learn more about in
    a later chapter, is to store application assets when the application is installed.
    When a user accesses an initial entry point to a web application, a background
    process is triggered that will automatically load additional assets that will
    later be needed as different aspects of the site are rendered. This is known as
    precaching, or priming your application's cache for better performance in the
    future.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL 模式的一个关键方面，我们将在后面的章节中了解更多，就是在应用安装时存储应用资产。当用户访问一个 Web 应用的初始入口点时，会触发一个后台进程，该进程将自动加载后续渲染网站不同方面所需的额外资产。这被称为预缓存，或者为应用缓存进行预优化，以获得未来的更好性能。
- en: 'Service workers make this practice easy to manage. You can take advantage of
    the `install` and `activate` events, as well as when a service worker is initially
    triggered. The common practice is to use the `install` event when a new service
    worker is registered to precache a list of well-known assets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Service Workers 使得这种做法易于管理。你可以利用 `install` 和 `activate` 事件，以及当 Service Worker
    首次触发时。常见的做法是在注册新的 Service Worker 时使用 `install` 事件来预缓存一系列已知的资产：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two types of precache strategies you need to understand: precaching
    as a dependency and not as a dependency.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解两种预缓存策略：作为依赖项的预缓存和不作为依赖项的预缓存。
- en: Installing as a dependency
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为依赖项安装
- en: 'When precaching application assets, there are certain assets you know will
    be used rather quickly or frequently. You can consider these mission-critical.
    And while the initial page load or app shell load may trigger network requests
    for these assets, causing them to be cached, there will probably be other assets
    that you want to ensure are cached early in the application-loading process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当预缓存应用程序资源时，有些资源你知道它们会被很快或频繁地使用。你可以将这些视为关键任务。尽管初始页面加载或应用外壳加载可能会触发对这些资源的网络请求，导致它们被缓存，但可能还有其他你希望确保在应用程序加载早期过程中被缓存的资源：
- en: '![](img/00075.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00075.jpeg)'
- en: 'These assets should be precached as a dependency of the `install` event completing.
    In other words, these assets must complete caching before the `install` event
    closes, which means you should use the `event.waitUntil` method to hold the process
    open. By doing so, you delay any active events from triggering until these assets
    are completely cached:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源应该作为`install`事件完成的依赖项进行预缓存。换句话说，这些资源必须在`install`事件关闭之前完成缓存，这意味着你应该使用`event.waitUntil`方法保持过程开启。通过这样做，你延迟了任何活动事件的触发，直到这些资源完全被缓存：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing not as a dependency
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不作为依赖项安装
- en: Precaching is not limited to mission-critical assets. You can most likely identify
    many assets that will be commonly used, but are not mission-critical to your application's
    success. You can still use the service worker `install` event to cache this set
    of assets, but choose not to make them dependent on the event completing. This
    is known as precaching assets without dependency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 预缓存不仅限于关键任务资源。你很可能会识别出许多将被常用但不是你应用程序成功关键的任务资源。你仍然可以使用服务工作者的`install`事件来缓存这组资源，但选择不使它们依赖于事件完成。这被称为无依赖项的预缓存资源。
- en: In this scenario, you will also trigger the precaching of these network assets,
    but you will not return the `cache.addAll` method in the `event.wait` `until`
    call. The assets will still be added to the cache, but will not hold the `install`
    event open until all of the assets are cached.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你也会触发这些网络资源的预缓存，但你不会在`event.wait` `until`调用中返回`cache.addAll`方法。这些资源仍然会被添加到缓存中，但不会保持`install`事件开启直到所有资源都被缓存。
- en: 'This technique gives you the ability to minimize the latency of precaching
    assets that might hold the service worker installation up. One of your goals when
    registering a new service worker is to make it available as quickly as possible.
    Requesting assets that may take a little while can hold that process up. This
    means that your service worker cannot take control of any clients until all this
    caching, including the `activate` event, is done, as shown in the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术让你能够最小化可能延迟服务工作者安装的预缓存资源的延迟。当你注册新的服务工作者时，你的一个目标就是尽可能快地使其可用。请求可能需要一些时间的资源可能会延迟这个过程。这意味着你的服务工作者不能在所有这些缓存（包括`activate`事件）完成之前控制任何客户端，如图所示：
- en: '![](img/00076.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00076.jpeg)'
- en: 'While you trigger this request in the `install` event, the event is not delayed.
    The request will still be cached, but outside of the `event` loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`install`事件中触发这个请求时，事件不会被延迟。请求仍然会被缓存，但它在`event`循环之外：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On activate
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在激活时
- en: The `activate` event is the next part of the service worker life cycle chain
    that you can leverage to manage cached assets. It can also be used to cache assets,
    but is more commonly used to perform cache model cleanup.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`activate`事件是服务工作者生命周期链中的下一个部分，你可以利用它来管理缓存资源。它也可以用来缓存资源，但更常用于执行缓存模型清理。'
- en: 'Instead of focusing on caching assets, the `activate` event is better suited
    to clean up legacy caches. This can eliminate version mismatch issues that can
    break your application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与关注缓存资源相比，`activate`事件更适合清理旧缓存。这可以消除可能导致你的应用程序崩溃的版本不匹配问题：
- en: '![](img/00077.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00077.jpeg)'
- en: 'To implement this strategy, you need to have a discernible version cache-naming
    convention. I recommend adding a version number to all of your named caches. This
    gives you a simple pattern that you can match to determine whether a named cache
    should be removed. Just be aware that any assets that are cached in those named
    caches will also be removed. This is okay, as the new version of the service worker
    typically caches updated versions of these assets:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个策略，你需要有一个可识别的版本缓存命名约定。我建议将版本号添加到所有命名的缓存中。这给你一个简单的模式，你可以匹配它来确定是否应该删除命名的缓存。只是要注意，那些命名的缓存中缓存的任何资源也将被删除。这是可以接受的，因为新的服务工作者版本通常缓存这些资源的更新版本：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example code loops through all the named caches and checks whether
    the cache belongs to the current service worker. The version variable has the
    version number pattern we are looking for. My personal preference is to declare
    a `const` value at the beginning of the service worker:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码遍历所有命名的缓存，并检查缓存是否属于当前的服务工作者。版本变量具有我们正在寻找的版本号模式。我个人的偏好是在服务工作者开始时声明一个 `const`
    值：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I add a `v` to the value to further indicate that it is a version number, but
    that is more of a mental tool to appeal to my personal preferences. Feel free
    to use any sort of versioning pattern you like. Semantic versioning or even a
    random hash or GUID would also work well here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我在值中添加了一个 `v` 来进一步表明它是一个版本号，但这更多的是一种心理工具，以迎合我个人的偏好。请随意使用你喜欢的任何版本控制模式。语义版本控制甚至随机的哈希或
    GUID 也可以在这里很好地工作。
- en: The main point is to have a unique pattern that you can identify in your cache
    names. Creating a variable is useful because it can be appended to the cache name
    to make cleanup easier to manage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目的是在你的缓存名称中有一个独特的模式，你可以识别出来。创建一个变量是有用的，因为它可以被附加到缓存名称上，使清理更容易管理。
- en: Real-time caching
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时缓存
- en: Caching does not need to be limited to the service worker installation events.
    While you should precache your common assets, there are probably many resources
    that are dynamic in nature. Some example in podcast applications are the individual
    podcasts and podcast episode pages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存不需要仅限于服务工作者安装事件。虽然你应该预缓存你的常用资源，但可能有许多资源本质上是动态的。在播客应用中的例子包括单个播客和播客剧集页面。
- en: Each podcast contains unique properties, such as a title, description, and logo.
    Each episode also has a unique title, description, possibly an image, and, of
    course, the audio file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个播客都包含独特的属性，如标题、描述和标志。每个剧集也有一个独特的标题、描述、可能还有图片，当然还有音频文件。
- en: These are very dynamic and fluid pieces of data that create many opportunities
    for new pages and page assets, as well as updates to these same pages and assets.
    The service worker `fetch` event handler gives you the hook to intercept all requests
    to the network so you can determine whether those assets are properly locally cached
    before hitting the internet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据非常动态且流动，为创建新页面和页面资源以及更新这些页面和资源提供了许多机会。服务工作者 `fetch` 事件处理器为你提供了拦截所有网络请求的钩子，这样你可以在连接互联网之前确定这些资源是否已经正确地本地缓存。
- en: This basic pattern gives you the ability to instantly load assets that were
    previously cached without worrying about network connectivity. There are many
    variations of this pattern, as you will see in the following sections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本模式让你能够立即加载之前缓存的资源，而无需担心网络连接。正如你将在以下章节中看到的，这个模式有许多变体。
- en: On user interaction
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用户交互时
- en: 'The first dynamic caching strategy is in response to a user interaction, such
    as clicking a button. Instead of this being explicitly caught by the service worker
    `fetch` event, it can be managed from the client JavaScript. This takes advantage
    of the client''s (browser) access to the Client API:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首个动态缓存策略是对用户交互的响应，例如点击按钮。这不需要由服务工作者 `fetch` 事件显式捕获，它可以由客户端 JavaScript 来管理。这利用了客户端（浏览器）对客户端
    API 的访问：
- en: '![](img/00078.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: The podcast application episode page has a button that the user can select to
    cause the episode's MP3 file to be stored offline. This is part of the listen-later
    functionality, something I love to use in the Stitcher app!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 播客应用的剧集页面有一个按钮，用户可以选择它来将剧集的 MP3 文件存储在离线状态。这是“稍后听”功能的一部分，这是我在 Stitcher 应用中非常喜欢使用的功能！
- en: 'The following example code is a function that is executed when the user clicks
    the Listen Later button on an episode page. A `fetch` is made to the API and the
    response is cached in the `LISTEN_LATER` cache:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码是一个在用户点击单集页面上的“稍后收听”按钮时执行的函数。它向 API 发起一个 `fetch` 请求，并将响应缓存到 `LISTEN_LATER`
    缓存中：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make this feature complete, a similar method would be used to cache the episode's
    MP3 file. You would also want to persist something you can use to visually indicate
    that the episode is saved for later if the user opens the episode page later.
    You would also want to maintain a local list of saved episodes. This can be done
    using `IndexedDB`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此功能完整，可以使用类似的方法来缓存单集的 MP3 文件。你还希望持久化一些可以用来视觉上指示单集已保存以供以后使用的属性。如果用户稍后打开单集页面，你还希望维护一个已保存单集的本地列表。这可以使用
    `IndexedDB` 实现。
- en: On network response
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络响应
- en: When a request returns from the network, you can intercept this part of the
    `fetch` process and handle it based on your application's logic. The most common
    thing to do is to cache the response while returning a copy to the client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求从网络返回时，你可以拦截 `fetch` 过程的这一部分，并根据你的应用程序逻辑进行处理。最常见的事情是在返回副本的同时缓存响应。
- en: 'This also extends the core pattern of on-demand asset caching. It''s important
    to note that when you intercept a request from the network, you should clone the
    response before caching it. A response can only be used once:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这也扩展了按需资产缓存的核心理念。需要注意的是，当你从网络拦截一个请求时，你应该在缓存之前克隆响应。响应只能使用一次：
- en: '![](img/00079.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: 'The `clone` method creates a deep copy of the response, allowing you to do
    something else with the response. The most common use of the `clone` method is
    to create a copy so that one can be cached and the other returned to the client,
    as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone` 方法创建响应的深拷贝，允许你对响应进行其他操作。`clone` 方法最常见的使用是创建一个副本，以便一个可以缓存，另一个可以返回给客户端，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Stale while revalidating
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过期时重新验证
- en: The next phase of our basic network-caching strategy is to return a previously
    cached version to the client while making a network request for the latest version.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本网络缓存策略的下一阶段是在发起网络请求获取最新版本的同时，向客户端返回之前缓存的版本。
- en: 'This strategy is very helpful when you need to return a response quickly, but
    the freshness of the data is not the biggest requirement. For example, a podcast
    episode does not change its details much, if at all. Returning a cached version
    of the page and its images would not mean that the user is missing out on fresh
    data. The following diagram shows the interactions involved in this process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速返回响应，但数据的最新性不是最重要的要求时，这种策略非常有用。例如，播客单集的详细信息变化不大，如果有的话。返回缓存的页面及其图像不会意味着用户错过了新鲜数据。以下图显示了此过程中的交互：
- en: '![](img/00080.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00080.jpeg)'
- en: 'But maybe you want to make sure that the user has the latest content. You can
    return the cached response instantly, while making a new request to the network
    and caching that response. This will replace any previously cached data for the
    next time the page is requested, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你想要确保用户拥有最新的内容。你可以立即返回缓存的响应，同时向网络发起新的请求并缓存该响应。这将替换任何之前缓存的页面数据，以便下次请求页面时使用，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On push notification
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在推送通知
- en: 'User activity and network requests are not the only times you can cache a network
    resource:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户活动和网络请求并不是唯一可以缓存网络资源的时候：
- en: '![](img/00081.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00081.jpeg)'
- en: 'You can also use a `push` message to initiate caching responses, as shown in
    the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `push` 消息来启动缓存响应，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this strategy, the `push` event handler determines the type of message action.
    If it is a notice to update the application, it initiates the process. The preceding
    code example is a bit of an oversimplification, but it shows the important parts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个策略中，`push` 事件处理程序确定消息操作的类型。如果是更新应用程序的通知，它将启动该过程。前面的代码示例有点过于简化，但它显示了重要的部分。
- en: The `push` message body should have some sort of property indicating the action
    that should be taken. In this case, it triggers an update workflow. Included in
    the message is a property, `urls`, which is an array of all the URLs that should
    be updated or cached.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 消息体应该包含某种属性，指示应采取的操作。在这种情况下，它触发一个更新工作流程。消息中包含一个属性，`urls`，它是一个应更新或缓存的全部
    URL 的数组。'
- en: The `cache.addAll` method makes the code simple, since it will perform all the
    `fetch` requests and cache the responses for you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache.addAll`方法使代码变得简单，因为它将执行所有的`fetch`请求并为你缓存响应。'
- en: You should always notify the user that a `push` notification has been received
    and the application is being updated. In this situation, you may also want to
    prompt the user to reload the app if they are currently using it. You can check
    to see whether there are any active clients while you are updating the cache,
    and notify them of the updating process. You will learn more about `push` notifications
    in a future chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终通知用户已经收到`push`通知并且应用程序正在更新。在这种情况下，你可能还希望提示用户重新加载应用程序，如果他们目前正在使用它。你可以在更新缓存时检查是否有任何活动客户端，并通知他们更新过程。你将在未来的章节中了解更多关于`push`通知的内容。
- en: On background sync
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台同步
- en: A more advanced caching pattern would be to use the Background Sync API. We'll
    talk about this in more detail in a later chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的缓存模式将是使用后台同步API。我们将在后面的章节中更详细地讨论这个问题。
- en: The core idea is to wrap all of your network request in a background sync wrapper.
    Here, you would create a request tag and cue it up to be processed as soon as
    the network is available.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是将所有的网络请求都包裹在一个后台同步包装器中。在这里，你会创建一个请求标签，并使其在网络可用时立即处理。
- en: This adds a new layer of complexity to using the service worker fetch, but can
    be very valuable if you need to maintain an asynchronous dataset with the server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这为使用服务工作者fetch添加了一个新的复杂层，但如果需要维护与服务器异步数据集，它可能非常有价值。
- en: 'If you are connected to the network, any request passed to the Background Sync
    API will immediately be executed as normal. If you are not connected, it''s added
    to a queue and executed when the device regains connectivity. The following image
    shows the interactions involved in this process:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接到网络，任何传递给后台同步API的请求将立即按正常方式执行。如果你没有连接，它将被添加到队列中，并在设备恢复连接时执行。以下图像显示了此过程中的交互：
- en: '![](img/00082.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: 'At that point, a `sync` event triggers, which could be used to initiate a cache
    update, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，一个`sync`事件被触发，这可以用来启动缓存更新，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, a `background sync` tag has been created for a specific podcast.
    If that tag triggers the `sync` event, the corresponding podcast details page
    is added to the dynamic cache.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为特定的播客创建了一个`后台同步`标签。如果该标签触发了`同步`事件，相应的播客详情页面将被添加到动态缓存中。
- en: Cache only
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅缓存
- en: When a network resource is precached, you can choose to implement a policy of
    only using a cached version of the asset. This is known as the cache-only strategy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络资源被预缓存时，你可以选择仅使用资产的缓存版本来实现策略。这被称为仅缓存策略。
- en: When you know a resource can be safely cached long term, you can reduce more
    overhead in your application by eliminating unnecessary network chatter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道一个资源可以被安全地长期缓存时，你可以通过消除不必要的网络通信来减少应用程序中的更多开销。
- en: Retrieving these resources from the cache also means that the application can
    load faster and, of course, load offline. Just make sure they don't become too
    stale.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中检索这些资源也意味着应用程序可以更快地加载，当然，也可以离线加载。只需确保它们不要变得过于陈旧。
- en: Here, any request for a network resource will be retrieved only from the cache
    and no network response will be used. This can be very valuable for long-term
    static resources, such as application core JavaScript and CSS files. You could
    also apply it to images such as your site's logo and font files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对网络资源的任何请求都只从缓存中检索，不会使用任何网络响应。这对于长期静态资源，如应用程序的核心JavaScript和CSS文件，非常有价值。你也可以将其应用于像网站标志和字体文件这样的图像。
- en: If you are employing the cache-only strategy, I advise having a routine automatically
    triggered when your service worker is executed. This routine should periodically check
    for new response versions to ensure that you have the most up-to-date data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用仅缓存策略，我建议在服务工作者执行时自动触发一个常规程序。这个程序应该定期检查新的响应版本，以确保你拥有最新的数据。
- en: 'Also, make sure that these resources are static or they could potentially break
    your application. If you choose to make them static, I advise adding these resources
    to a service worker version change before deploying them to your server. The following
    image shows the the interactions involved in this process:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保这些资源是静态的，否则可能会破坏您的应用程序。如果您选择使它们成为静态资源，我建议在将它们部署到服务器之前，将这些资源添加到服务工作者版本更改中。以下图像显示了此过程中的交互：
- en: '![](img/00083.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: 'The cache-only strategy pairs well with either of the precache strategies discussed
    earlier in the chapter. Precaching cache-only resources should ensure that they
    are available from the cache, as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仅缓存策略与本章前面讨论的任何预缓存策略搭配良好。预缓存仅缓存资源应确保它们可以从缓存中获取，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code example, the `fetch` event handler only responds with a match from
    the cache. If one does not exist, the client will receive a `not found` (404 status
    code) response.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，`fetch`事件处理程序仅对缓存中的匹配项做出响应。如果不存在，客户端将收到一个“未找到”（404状态码）响应。
- en: Network only
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅网络
- en: The complete opposite of cache-only is to only request a resource from the network.
    In this scenario, you will identify network resources that should always be requested
    from the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 仅缓存与仅从网络请求资源的完全相反。在这种情况下，您将确定始终应从服务器请求的网络资源。
- en: 'The strategy should be employed on data that changes very frequently. For example,
    a stock ticker application would want to make sure that the request to update
    stock prices is made immediately and not from a local cache. Stale data in this
    scenario can cost you a fortune. The following image shows the interactions involved
    in this process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在变化非常频繁的数据上应用此策略。例如，股票行情应用希望确保立即而不是从本地缓存更新股票价格请求。在这种情况下，过时的数据可能会让您损失一大笔钱。以下图像显示了此过程中的交互：
- en: '![](img/00084.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: 'You should identify the nature of any file or network resources you might need
    to access, and ensure that the data is constantly being updated. You can intercept
    these requests and apply the proper strategy based on routes and patterns. To
    do so, I would advise you to have some unique identifier in these assets'' URLs,
    as shown in the following code example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该确定您可能需要访问的任何文件或网络资源的性质，并确保数据始终在更新。您可以拦截这些请求并根据路由和模式应用适当的策略。为此，我建议您在这些资产的URL中包含一些唯一标识符，如下面的代码示例所示：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Cache falling back to network
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存回退到网络
- en: The most common pattern I see employed in service workers is the cache falling
    back to the network. It's very popular because checking for an asset's presence
    in your cache means that it can return immediately. If it does not, you still
    have the network fallback retrieving it as fast as possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到在服务工作者中最常见的模式是缓存回退到网络。它非常受欢迎，因为检查资产是否存在于您的缓存中意味着它可以立即返回。如果没有，您仍然可以通过网络回退以尽可能快的速度检索它。
- en: 'Any asset that is not precached or previously cached from the same pattern
    would be accessible, assuming you are online. The following image shows the interactions
    involved:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未预缓存或之前从同一模式缓存的资产都将可访问，前提是您已在线。以下图像显示了此过程中的交互：
- en: '![](img/00085.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: I say that this is probably the most common pattern used because any asset that
    is not precached could comfortably fit into this pattern. The podcast application
    uses this pattern for all the individual podcast and episode pages. This makes
    them accessible as soon as possible, but we don't want to precache every single
    file and image ahead of time, only on-demand.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这可能是最常用的模式，因为任何未预缓存的资产都可以轻松地适应此模式。播客应用程序使用此模式为所有个人播客和剧集页面。这使得它们可以尽快访问，但我们不希望在事先预缓存每个文件和图像，而仅在需要时。
- en: 'The following is an example of this pattern being executed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个执行此模式的示例：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It seems pointless to execute this pattern without caching the network response.
    The following code shows how I recommend you apply this strategy; I call it "cache
    falling back to the network", caching the result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有缓存网络响应的情况下执行此模式似乎毫无意义。以下代码显示了您应该如何应用此策略；我称之为“缓存回退到网络”，即缓存结果：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the more complete version of this pattern. Now, the next time the resource
    is requested, it will come from the cache. But if it was not previously cached,
    it can be retrieved from the network.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此模式的更完整版本。现在，下次请求资源时，它将来自缓存。但如果之前没有缓存，它可以从网络中检索。
- en: Cache and network race
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存和网络竞速
- en: 'Another interesting caching pattern, of the variation of the cache falling
    back to the network pattern, is a cache and network race pattern. This is where
    you will simultaneously request the resource from the cache and the network. The
    fastest response wins. While the cache should be the winner, it may not always
    win. This pattern also gives you the opportunity to retrieve the network version
    a little bit faster if there is no cached version. The following image shows the
    interactions involved in this process:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的缓存模式，即缓存回退到网络模式的变体，是缓存和网络竞速模式。这是您将同时从缓存和网络请求资源的地方。最快的响应获胜。虽然缓存应该是赢家，但它可能并不总是能赢。此模式还给您提供了在无缓存版本的情况下更快地检索网络版本的机会。以下图片展示了此过程中的交互：
- en: '![](img/00086.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00086.jpeg)'
- en: 'The drawback to this pattern is that you will always make a network request
    even if it''s not needed. This will increase your network traffic. But you could
    also look at it as a way to ensure you''ve got at least some of the freshest content
    cached every single time. It can also be viewed as a variation of the stale while
    revalidating strategy. The following code shows how to implement the cache and
    network race pattern:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点是，即使不需要，您也总是会发起网络请求。这将增加您的网络流量。但您也可以将其视为确保每次至少有一些最新内容缓存的途径。它也可以被视为“陈旧但正在验证”策略的一种变体。以下代码展示了如何实现缓存和网络竞速模式：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that there is a custom `promiseAny` function. This is because of a limitation
    of the `Promise.race` method. When a `Promise.race` method is used and any of
    the supplied promises throws an exception, the entire process fails.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个自定义的 `promiseAny` 函数。这是由于 `Promise.race` 方法的限制。当使用 `Promise.race` 方法且提供的任何承诺抛出异常时，整个过程将失败。
- en: This pattern depends on at least one promise resolving a response. The `promiseAny` function
    is a modification to the `Promise.race` method, except it will not fail if a supplied
    promise fails. It assumes that one of the promises will succeed and return the
    winner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式依赖于至少有一个承诺解析响应。`promiseAny` 函数是对 `Promise.race` 方法的修改，除了它不会在提供的承诺失败时失败。它假设其中一个承诺将成功并返回赢家。
- en: Network falling back to cache
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络回退到缓存
- en: If you have a time-sensitive network resource that you always want to hit the
    network, you should also consider using the network falling back to cache strategy.
    Here, you will always try to access the network, but if the network is inaccessible,
    then you have the built-in option to retrieve the most recently cached version
    of the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个时间敏感的网络资源，您总是希望访问网络，那么您也应该考虑使用网络回退到缓存策略。在这里，您将始终尝试访问网络，但如果网络不可访问，那么您就有内置的选项来检索最近缓存的文件版本。
- en: 'If it is critical that the resource is fresh, I advise that you visually alert
    the customer of the time that is associated with that response. The following
    image shows the interactions involved in this process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源的新鲜度至关重要，我建议您通过视觉方式提醒客户与该响应相关的时间。以下图片展示了此过程中的交互：
- en: '![](img/00087.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00087.jpeg)'
- en: 'This pattern can also be to provide a fallback for any asset that is inaccessible
    over the network, which we will see in the next pattern. The following code shows
    how to implement the network falling back to cache pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式还可以为任何通过网络无法访问的资产提供回退，我们将在下一个模式中看到。以下代码展示了如何实现网络回退到缓存模式：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Generic fallback
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用回退
- en: The next step from the network falling back to the cache is to have a generic
    fallback for all requests. You should use this when no response was available
    either in the cache or from the network.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络回退到缓存的下一步是为所有请求提供一个通用回退。当缓存和网络都没有可用响应时，您应该使用此策略。
- en: You can see this pattern employed across the Podstr application for podcast
    episodes and their associated images.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Podstr 应用程序中看到这种模式被用于播客剧集及其相关图片。
- en: The trick here is to precache a fallback response for these particular network
    assets. I also advise that you apply this strategy by matching route variations
    and not individual URLs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是为这些特定的网络资产预缓存一个回退响应。我还建议你通过匹配路由变体而不是单个URL来应用这种策略。
- en: In the Podstr podcast application, there are generic fallbacks for the podcast
    pages, episode pages, and podcast logos. I identified each of these as dynamic
    resources that cannot be precached.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Podstr播客应用程序中，播客页面、剧集页面和播客标志都有通用的回退。我识别出这些都是无法预缓存的动态资源。
- en: Typically, if you can't access the resource, that means that it is not found
    or the device is offline. I think it's important that you have some logic in place
    to determine the difference. If the application is offline, you want to visually
    indicate that somehow, but if the resource is truly not found, you may want to
    return a slightly different response.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你无法访问资源，这意味着资源未找到或设备离线。我认为设置一些逻辑来区分这两种情况很重要。如果应用离线，你希望以某种方式在视觉上指示这一点，但如果资源确实未找到，你可能希望返回一个略有不同的响应。
- en: 'I think Flipkart does a fantastic job of this. When the application is offline,
    they greyscale the entire UI. This is a very clear indication to the end user
    that the device is offline, which means that they may not necessarily be able
    to access the information, and that any information they receive may not be current.
    The following screenshot shows an example of this greyscaling:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为Flipkart在这方面做得非常出色。当应用离线时，他们会将整个UI以灰度显示。这对最终用户来说是一个非常清晰的指示，表明设备处于离线状态，这意味着他们可能无法访问信息，并且他们收到的任何信息可能不是最新的。以下截图展示了这种灰度显示的例子：
- en: '![](img/00088.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: 'If you receive an error `404` message, then you can return a Not Found page
    and use that to your advantage as well. The following image shows the interactions
    involved in this pattern:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个`404`错误消息，那么你可以返回一个“未找到”页面，并利用这一点。以下图片展示了这种模式涉及到的交互：
- en: '![](img/00089.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: 'Maybe you will choose to direct them to a related resource, or provide a sitemap,
    as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你会选择将他们引导到相关资源，或者提供网站地图，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Service worker templating
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者模板
- en: A concept you should embrace about service workers is that they can act like
    a web server in the browser. Traditionally, web servers have used runtime rendering
    platforms, such as ASP.NET, PHP, Ruby on Rails, and content management systems
    such as WordPress, Drupal, and Joomla!. These systems are rendering engines more
    than anything else. You can perform HTML rendering inside of a service worker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关于服务工作者，你应该接受的一个概念是它们可以在浏览器中充当一个网络服务器。传统上，网络服务器使用运行时渲染平台，如ASP.NET、PHP、Ruby on
    Rails，以及内容管理系统，如WordPress、Drupal和Joomla！。这些系统更多的是渲染引擎。你可以在服务工作者内部执行HTML渲染。
- en: Single-page applications have become very popular this decade. They effectively
    take ownership of this rendering process from the server. Today, it is popular
    to preload application templates, whether you're using mustache, handlebars, or
    larger frameworks such as Angular and React. All of these are essentially just
    HTML rendering systems. The difference between the server side and the client
    side is where the rendering takes place. Because you can intercept network requests
    in a service worker, the rendering process can be moved from the client UI or
    the server to the service worker.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序在本十年变得非常流行。它们有效地从服务器接管了渲染过程。如今，预加载应用程序模板很流行，无论你使用mustache、handlebars还是更大的框架，如Angular和React。所有这些本质上都是HTML渲染系统。服务器端和客户端之间的区别在于渲染发生的位置。由于你可以在服务工作者中拦截网络请求，渲染过程可以从客户端UI或服务器移动到服务工作者。
- en: 'In this pattern, you will most likely precache the page or component templates
    ahead of time and make network requests to an API to return data, typically formatted
    in JSON. When you retrieve the new JSON, you will then render the markup in the
    service worker and return the HTML to the client. The following image shows the
    interactions involved in this pattern:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，你很可能会提前预缓存页面或组件模板，并向API发起网络请求以获取数据，通常以JSON格式返回。当你检索到新的JSON后，你将在服务工作者中渲染标记，并将HTML返回给客户端。以下图片展示了这种模式涉及到的交互：
- en: '![](img/00090.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: My personal technique is to use mustache because it is simple and fast. The
    overall technique is a little bit advanced, but once you have a working pattern,
    I think you'll see that it's easier to implement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的技术是使用mustache，因为它简单快捷。整体技术稍微复杂一些，但一旦你有一个工作模式，我认为你会发现它更容易实现。
- en: In this example, the `fetch` event handler looks for any request to the podcast
    episode routes. When an episode request is made, it is intercepted and a new custom
    request created. Instead of requesting the HTML from the server, the service worker
    will create a request to an API to retrieve the JSON.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`fetch`事件处理程序会寻找对播客剧集路由的任何请求。当发起剧集请求时，它会被拦截并创建一个新的自定义请求。服务工作者不会从服务器请求HTML，而是创建一个请求到API以检索JSON。
- en: In theory, the request for the JSON should be smaller than a request for the
    HTML. The smaller packet should be loaded slightly faster. The real question is
    can the small request be retrieved and rendered faster than a request for prerendered
    HTML? This is an answer I cannot give you. It will require some experimentation
    with your application's pages and API to determine which one is the best solution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，对JSON的请求应该比HTML的请求小。较小的数据包应该加载得更快。真正的问题是，这个小请求能否比预渲染HTML的请求更快地检索和渲染？这是我无法给出的答案。这将需要您对应用程序页面和API进行一些实验，以确定哪种解决方案最好。
- en: 'For small pieces of data, such as the episode page, chances are that the service
    worker rendering will be slightly slower. But if your page contains a lot of information
    that is repeatable—such as the kind of information that you often see in line-of-business
    applications—this technique could improve your overall performance. The following
    code shows how you can implement this pattern:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小块数据，例如剧集页面，服务工作者渲染可能会稍微慢一些。但如果您的页面包含大量可重复的信息——例如在业务线应用程序中经常看到的那种信息——这种技术可以提高您的整体性能。以下代码展示了您如何实现这种模式：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the API request returns the service worker logic, it then loads the content
    template and renders it to HTML. This HTML is then returned to the client in a
    custom `response` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API请求返回服务工作者逻辑，它随后加载内容模板并将其渲染为HTML。然后，这个HTML通过一个自定义的`response`对象返回给客户端。
- en: An even more advanced way to use the strategy is to use it in concert with caching
    a response. This way, you render the response once, cache it, and check to see
    whether it's cached the next time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略的更高级方法是将其与缓存响应结合使用。这样，你只需渲染一次响应，然后缓存它，并在下次检查它是否已缓存。
- en: This pattern may not be optimal for every scenario, but it should be considered
    if you have pages with large, repeating datasets and wish to take advantage of
    any speed gains.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可能并不适用于所有场景，但如果您有包含大量重复数据集的页面，并且希望利用任何速度提升，那么它应该被考虑。
- en: The scenario I believe this pattern offers the most benefit for is dynamically
    rendered markup where data changes frequently. Progressive web apps, such as the
    Podstr application, may not realize performance gains, but a line-of-business
    application can.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这种模式最能带来好处的是动态渲染的标记，其中数据频繁变化。例如Podstr应用程序这样的渐进式Web应用程序可能不会实现性能提升，但业务线应用程序可以。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: These strategies should serve as your service worker fetching and caching workflow.
    The reason there are so many strategies is that there are many scenarios for application
    assets. How you apply these strategies is up to you, and they may require some
    experimentation to determine the best strategy for each asset type.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略应该作为您的服务工作者获取和缓存工作流程。之所以有这么多策略，是因为应用程序资产有众多场景。如何应用这些策略取决于您，并且可能需要一些实验来确定每种资产类型最佳策略。
- en: These strategies may not be the exact patterns you need for your application,
    but they will serve as the foundation for all your caching needs. You can use
    these as starting points that you can extend, mix, and match to create the best
    strategies for your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略可能不是您应用程序所需的精确模式，但它们将为您所有的缓存需求提供基础。您可以使用这些作为起点，扩展、混合和匹配以创建最适合您应用程序的最佳策略。
