- en: Implementing a Full Fledged RESTful Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a second version of our RESTful service, and we had
    the two versions exposed by different URLs, ensuring backward compatibility. We
    implemented unit tests for its database layer and discussed how to use HTTP status
    codes appropriately. In this chapter, we will extend that implementation—by providing
    handling of non-document—binary data to the second version of the service and
    linking it accordingly to the documents it relates to.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at a convenient way of presenting large result sets to consumers.
    For that purpose, we will introduce pagination as well as further filtering capabilities
    to our API.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases when caching data responses should be considered as an option.
    We will look at its benefits and drawbacks and also decide to enable caching when
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will dive into the discovery and exploration of REST services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here''s what should be further implemented to turn the catalog data
    service into a full-fledged RESTful service:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with arbitrary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Linked data in the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging and filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovery and exploration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arbitrary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB utilizes BSON (Binary JSON) as the primary data format. It is a binary
    format that stores key/value pairs in a single entity called **document.** For
    example, a sample JSON, `{"hello":"world"}`, becomes `\x16\x00\x00\x00\x02hello\x00\x06\x00\x00\x00world\x00\x00`
    when encoded in BSON.
  prefs: []
  type: TYPE_NORMAL
- en: BSON stores data rather than literals. For instance, if an image is to be part
    of the document, it will not have to be converted to a base64-encoded string;
    instead, it will be directly stored as binary data, unlike plain JSON, which will
    usually represent such data as base64-encoded bytes, but that is obviously not
    the most efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose schemas enable storing binary content in the BSON format via the schema
    type—**buffer**. It stores binary content (image, ZIP archive, and so on) up to
    16 MB. The reason behind the relatively small storage capacity is to prevent excessive
    usage of memory and bandwidth during transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The **GridFS** specification addresses this limitation of BSON and enables you
    to work with data larger than 16 MB. GridFS divides data into chunks stored as
    separate document entries. Each chunk, by default, has a size of up to 255 KB.
    When data is requested from the data store, the GridFS driver retrieves all the
    required chunks and returns them in an assembled order, as if they had never been
    divided. Not only does this mechanism allow storage of data larger than 16 MB,
    it also enables consumers to retrieve data in portions so that it doesn't have
    to be loaded completely into the memory. Thus, the specification implicitly enables
    streaming support.
  prefs: []
  type: TYPE_NORMAL
- en: 'GridFS actually offers more—it supports storing metadata for the given binary
    data, for example, its format, a filename, size, and so on. The metadata is stored
    in a separate file and is available for more complex queries. There is a very
    usable Node.js module called `gridfs-stream`. It enables easy streaming of data
    in and out of MongoDB, as on all other modules it is installed as an `npm` package.
    So, let''s install it globally and see how it is used; we will also use the `-s`
    option to ensure that the dependencies in the project''s `package.json` are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `Grid` instance, you are required to have a connection opened to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing into the stream is done through the `createReadStream()`
    and `createWriteStream()` functions. Each piece of data streamed into the database
    must have an `ObjectId` attribute set. The `ObjectId` identifies binary data entry
    uniquely, just as it would have identified any other document in MongoDB; using
    this `ObjectId`, we can find or delete it from the MongoDB collection by this
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the catalog service with functions for fetching, adding, and
    deleting an image assigned to an item. For simplicity, the service will support
    a single image per item, so there will be a single function responsible for adding
    an image. It will overwrite an existing image each time it is invoked, so an appropriate
    name for it is `saveImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all we need to do to flush the data in MongoDB is to create
    a GridFS write stream instance. It requires some options that provide the `ObjectId`
    of the MongoDB entry and some additional metadata, such as a title as well as
    the writing mode. Then, we simply call the pipe function of the request. Piping
    will result in flushing the data from the request to the write stream, and, in
    this way, it will be safely stored in MongoDB. Once stored, the `close`event associated
    with the `writeStream` will occur, and this is when our function reads back whatever
    it has stored in the database and returns that image in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving an image is done the other way around—a `readStream` is created
    with options, and the value of the `_id` parameter should be the `ObjectId` of
    the arbitrary data, optional file name, and read mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before piping the read stream to the response, the appropriate `Content-Type`
    header has to be set so that the arbitrary data can be presented to the client 
    with an appropriate image media type, `image/jpeg`, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we export from our module a function for fetching the image back from
    MongoDB. We will use that function to bind it to the express route that reads
    the image from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting arbitrary data from MongoDB is also straightforward. You have to delete
    the entry from two internal MongoDB collections, the `fs.files`, where all the
    files are kept, and from the `fs.files.chunks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bind the new functionality to the appropriate item route and test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since, at the time of writing, Version 2 is the latest version of our API,
    any new functionality exposed by it should be available at both locations: `/catalog`
    and `/v2/catalog`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start Postman and post an image to an existing item, assuming that we
    have an item with ID 14 `/catalog/v2/item/14/image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc9c935-9db2-4a52-949b-f7c35b277648.png)'
  prefs: []
  type: TYPE_IMG
- en: Post request assigning an image to an item using Postman. This is a screenshot
    for Postman. The individual settings are not important here. The purpose of the
    image is just to show how the window looks.
  prefs: []
  type: TYPE_NORMAL
- en: After the request is processed, the binary data is stored in the grid datastore
    and the image is returned in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Linked data section of the previous chapter, we defined that if an item
    in the catalog has an image assigned to it, this will be indicated with an HTTP
    header named Image-URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `findItemById` function in the V2 of the catalog. We will
    use the GridFS''s existing function to check whether there is an image bound to
    the selected item; in case there is an image assigned to the item, its URL will
    be available to the response with the Image-Url header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we linked an item to its image; however, that leaves our data partially
    linked, as there is a link from an item to its image but not the other way around.
    Let''s change that and supply a header Item-Url to the image response by modifying
    the `readImage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now requesting the item at `http://localhost:3000/catalog/v2/item/3/` will
    return the item encoded in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Looking into the response headers, we find the `Image-Url` header its value, `http://localhost:3000/catalog/v2/item/3/image`
    provides the URL of the image linked to the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requesting that image results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, the response provides the payload of the image linked to the item
    and a special header **Item-Url**. Its value—`http://localhost:3000/catalog/v2/item/3`—is
    the address where the item resource is available. Now if the item image appears,
    for instance, in image search results, the URL of the item linked with the image
    will also be part of the result. In this way, we linked the two data semantically
    without modifying or compromising their payload.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing paging and filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once deployed to the web, each service becomes available to an enormous number
    of consumers. They will not only use it to get data but also to insert new data.
    At some point of time, this will inevitably lead to a large amount of data being
    available in the database. To keep the service user-friendly and maintain a reasonable
    response time, we need to take care of providing big data in reasonable portions,
    assuring that it does not need to return a few hundred thousand items when the
    `/catalog` URI is requested.
  prefs: []
  type: TYPE_NORMAL
- en: Web data consumers are used to having various pagination and filtering capabilities.
    Earlier in this chapter, we implemented the `findIfindItemsByAttribute()` function,
    which enabled filtering by any of the attributes of an item Now, it's time to
    introduce pagination capabilities to enable navigation within the `resultset`
    with the help of a URI parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mongoose.js` models can make use of different plugin modules to provide
    additional functionality on top of them. Such a plugin module is `mongoose-paginate`.
    The Express framework also provides a piece of pagination middleware named `express-paginate`.
    It provides out-of-the-box linking and navigation with Mongoose''s result pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to develop the pagination mechanism, we should install these
    two useful modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will to be to create instances of the  `express-paginate` middleware
    in our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the pagination middleware in the application by calling its `middleware()`
    function. Its parameters specify a default limit and a maximum limit of results
    per page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, provide the `mongoose-pagination` instance as a plugin to the `CatalogItem`
    schema before creating a model. Here''s how the `item.js` module will export that
    along with the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the `paginate()` function of the model to fetch the requested
    entries in a paginated manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the filter that Mongoose should use for its query. The
    second parameter is an object specifying which page is requested and the entries
    per page. The third parameter is a callback-handler function, providing the result
    and any available error information via its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error`: This specifies whether the query was executed successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result`: This is the retrieved data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `express-paginate` middleware enables seamless integration of the `mongoose-paginate`
    module in the web environment by enriching the `request` and `response` objects
    of an Express handler function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `request` objects get two new attributes: `query.limit`, which tells the
    middleware the number of entries on the page, and `query.page`, which specifies
    the requested page. Note that the middleware will ignore values of `query.limit`
    that are larger than the `maxLimit` value specified at the middleware''s initialization.
    This prevents the consumer from overriding the maximum limit and gives you total
    control over your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation of the `paginate` function in the second version
    of the catalog module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the response from querying a dataset containing 11 items with
    a limit of five items per page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `docs` attribute contains all the items that are part of the results. Its
    size is the same as the selected limit value. The `pages` attribute provides the
    total number of pages; in the example here, its value is 3, as 11 items are accommodated
    in three pages, each containing five items. The `Total` attribute gives us the
    total number of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step to enable pagination is to modify the `/v2/` route to start
    making use of the newly created function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the HTTP `302 Found` status for the default route, `/catalog`.
    In this way, all incoming requests will be redirected to `/v2/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using an appropriate status code for redirection here is vital to the life cycle
    of any RESTful web service. Returning `302 Found`, followed by a redirection,
    ensures that the consumer of the API will always have its latest version available
    at that location. Furthermore, it is also a good practice from the development
    point of view to use redirection instead of code duplication here.
  prefs: []
  type: TYPE_NORMAL
- en: When you are between two versions, you should always consider using the HTTP
    `301 Moved Permanently` status to show where the previous version has been moved
    and the HTTP `302 Found` status to show the actual URI of the current version.
  prefs: []
  type: TYPE_NORMAL
- en: Now, getting back to pagination, as the requested page and the limit number
    are provided as `GET` parameters and we don't want to mix that up with the filtering
    capabilities, there is an explicit check for them. Pagination will be used only
    when either the page or the limit `GET` parameters, are available in the request.
    Otherwise, searching will be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we set the maximum limit of 100 results and a default limit of 10,
    so, before trying the new pagination functionality, ensure that you insert more
    items than the default limit into the database. This will make the test results
    more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give it a try. Requesting `/catalog?limit=3` will result in returning
    a list containing only two items, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a92193f-e58d-4bfa-9f7f-f8378b41de4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Pagination enabled results. This is a screenshot for Postman. The individual
    settings are not important here. The purpose of the image is just to show how
    the window looks.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the example, the total number of pages is four. The total
    number of items is stored in the database 11\. Since we didn't specify a page
    parameter in the request, the pagination implicitly returned the first page. To
    navigate to the next page, simply add `&page=2` to the URI.
  prefs: []
  type: TYPE_NORMAL
- en: Also, try changing the `limit` attribute, requesting `/catalog/v2?limit=4`.
    This will return the first four items, and the response will show that the total
    number of pages is three.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discussed the REST principles defined by Roy Fielding, we mentioned
    that caching was a rather sensitive topic. In the end, our consumers will expect
    up-to-date results when executing a query. However, from a statistical point of
    view, data exposed in the web is more likely to be read rather than updated or
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: So, it is reasonable that some resources exposed by a public URL become a subject
    of millions of requests, considering taking off part of the load from the server
    to a cache. The HTTP protocol allows us to cache some responses for a given period
    of time. For instance, when multiple requests are received in a short period of
    time, querying for all items in the catalog of a given group, such as `/catalog/v2`,
    our service can utilize special HTTP headers that would force the HTTP server
    to cache the response for a defined time period. This would prevent redundant
    requests to the underlying database server.
  prefs: []
  type: TYPE_NORMAL
- en: Caching at the HTTP server level is achieved via special response headers. The
    HTTP server uses a `Cache-Control` header to specify how long a given response
    should be cached for. The period before the cache needs invalidation is set via
    its `max-age` attribute, and its value is provided in seconds. Of course, there
    is a nice Node.js module that provides a middleware function for caching, called
    `express-cache-control`.
  prefs: []
  type: TYPE_NORMAL
- en: Supplying the Cache-Control header in Express applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install it with the NPM package manager; once again, we will install
    it globally and make use of the `-s` option, which will update the `package.json`
    file with the new `express-cache-control` dependency automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Enabling caching with the `express-cache-control` middleware requires three
    straightforward steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `CacheControl` middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind the middleware instance to the routes you want to enable caching for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Usually, common URIs that provide many result entries should be the subject
    of caching, rather than URIs providing data for a concrete entry. In our application,
    only the `/catalog` URI will make use of caching. The `max-age` attribute must
    be selected according to the load of your application to minimize inaccurate responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test our changes by requesting `/catalog/v2` in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a4c8d45-2367-4283-9aa8-47a2644b1af9.png)'
  prefs: []
  type: TYPE_IMG
- en: Cache-control header indicating that caching is enabled. This is a screenshot
    for Postman. The individual settings are not important here. The purpose of the
    image is just to show how the window looks.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the `express-cache-control` middleware has done its job—the `Cache-Control`
    header is now included in the response. The `must-revalidate` option ensures that
    the cache content is invalidated after the `max-age` interval expires. Now, if
    you make another request for a specific item, you will see that the response does
    not make use of the `express-cache-control` middleware, which is because it needs
    to be explicitly provided in each individual route. It will not be used in URIs
    deriving from one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responses from `GET` requests against any route `/v1/` will not contain the
    `Cache-Control` header, as it is supported only in Version 2 of our API, and the
    `Cache-Control` middleware is used only in the main catalog routes: `/catalog/v2/`
    or `/catalog`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! In this chapter, you succeeded in transforming a sample REST-enabled
    endpoint into a full-fledged RESTful web service that supports filtering for usability
    and paging for easy navigation. The service delivers both arbitrary and JSON data,
    and it is ready for high-load scenarios, as it enables caching in its critical
    parts. One thing that should draw your attention is the appropriate usage of the
    HTTP status codes when it comes to redirection between new and obsolete versions
    of any public API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing appropriate HTTP status is really important for the REST application,
    so we made use of rather exotic statuses, such as `301 Moved Permanently` and
    `302 Found`.
  prefs: []
  type: TYPE_NORMAL
