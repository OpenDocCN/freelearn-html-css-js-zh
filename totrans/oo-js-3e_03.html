<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Functions</h1></div></div></div><p>Mastering functions is an important skill when you learn any programming language, and even more so when it comes to JavaScript. This is because JavaScript has many uses for functions, and much of the language's flexibility and expressiveness comes from them. Where most programming languages have a special syntax for some object-oriented features, JavaScript just uses functions. This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to define and use a function</li><li class="listitem" style="list-style-type: disc">Passing arguments to a function</li><li class="listitem" style="list-style-type: disc">Predefined functions that are available to you for free</li><li class="listitem" style="list-style-type: disc">The scope of variables in JavaScript</li><li class="listitem" style="list-style-type: disc">The concept that functions are just data, albeit a special type of data</li></ul></div><p>Understanding these topics will provide a solid base that will allow you to dive into the second part of the chapter, which shows some interesting applications of functions, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using anonymous functions</li><li class="listitem" style="list-style-type: disc">Callbacks</li><li class="listitem" style="list-style-type: disc">Immediate (self-invoking) functions</li><li class="listitem" style="list-style-type: disc">Inner functions (functions defined inside other functions)</li><li class="listitem" style="list-style-type: disc">Functions that return functions</li><li class="listitem" style="list-style-type: disc">Functions that redefine themselves</li><li class="listitem" style="list-style-type: disc">Closures</li></ul></div><div class="section" title="What is a function?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>What is a function?</h1></div></div></div><p>Functions allow you to group together a code, give it a name, and reuse it later, addressing it by the name you gave it. Let's consider the following code as an example:</p><pre class="programlisting">    function sum(a, b) { &#13;
      var c = a + b; &#13;
      return c; &#13;
    } &#13;
</pre><p>The parts that make up a function are shown as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">function</code> keyword.</li><li class="listitem" style="list-style-type: disc">The name of the function; in this case, <code class="literal">sum</code>.</li><li class="listitem" style="list-style-type: disc">The function parameters; in this case, <code class="literal">a</code> and <code class="literal">b</code>. A function can take any number of parameters, or no parameters, separated by commas.</li><li class="listitem" style="list-style-type: disc">A code block, also called the body of the function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">return</code> statement. A function always returns a value. If it doesn't return a value explicitly, it implicitly returns the value <code class="literal">undefined</code>.</li></ul></div><p>Note that a function can only return a single value. If you need to return more values, you can simply return an array that contains all of the values you need as elements of this array.</p><p>The preceding syntax is called a function declaration. It's just one of the ways to create a function in JavaScript, and more ways are coming up.</p><div class="section" title="Calling a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Calling a function</h2></div></div></div><p>In order to make use of a function, you will need to call it. You can call a function simply using its name, optionally, followed by any number of values in parentheses. To invoke a function is another way of saying to call.</p><p>Let's call the <code class="literal">sum()</code>function, passing two arguments and assigning the value that the function returns to the variable <code class="literal">result</code>:</p><pre class="programlisting">    &gt; var result = sum(1, 2); &#13;
    &gt; result; &#13;
    3 &#13;
</pre></div><div class="section" title="Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Parameters</h2></div></div></div><p>When defining a function, you can specify what parameters the function expects to receive when it's called. A function may not require any parameters, but if it does, and you forget to pass them, JavaScript will assign the <code class="literal">undefined</code> value to the ones you skipped. In the next example, the function call returns <code class="literal">NaN</code> because it tries to sum <code class="literal">1</code> and <code class="literal">undefined</code>:</p><pre class="programlisting">    &gt; sum(1); &#13;
    NaN &#13;
</pre><p>Technically speaking, there is a difference between parameters and arguments, although the two are often used interchangeably. Parameters are defined together with the function, while arguments are passed to the function when it's called. Consider the following example:</p><pre class="programlisting">    &gt; function sum(a, b) { &#13;
        return a + b; &#13;
      } &#13;
    &gt; sum(1, 2); &#13;
</pre><p>Here, <code class="literal">a</code> and <code class="literal">b</code> are parameters, while <code class="literal">1</code> and <code class="literal">2</code> are arguments.</p><p>JavaScript is not picky at all when it comes to accepting arguments. If you pass more than the function expects, the extra ones will be silently ignored, as shown in the following example:</p><pre class="programlisting">    &gt; sum(1, 2, 3, 4, 5); &#13;
    3 &#13;
</pre><p>What's more, you can create functions that are flexible about the number of parameters they accept. This is possible thanks to the special value <code class="literal">arguments</code> that are created automatically inside each function. Here's a function that simply returns whatever arguments are passed to it:</p><pre class="programlisting">    &gt; function args() { &#13;
        return arguments; &#13;
      } &#13;
    &gt; args(); &#13;
    [] &#13;
    &gt; args( 1, 2, 3, 4, true, 'ninja'); &#13;
    [1, 2, 3, 4, true, "ninja"] &#13;
</pre><p>Using <code class="literal">arguments</code>, you can improve the <code class="literal">sum()</code> function to accept any number of arguments and add them all up, as shown in the following example:</p><pre class="programlisting">    function sumOnSteroids() { &#13;
      var i, &#13;
          res = 0, &#13;
          number_of_params = arguments.length; &#13;
      for (i = 0; i &lt; number_of_params; i++) { &#13;
        res += arguments[i]; &#13;
      } &#13;
      return res; &#13;
    } &#13;
</pre><p>If you test this function by calling it with a different number of arguments, or even none at all, you can verify that it works as expected, as you can see in the following example:</p><pre class="programlisting">    &gt; sumOnSteroids(1, 1, 1); &#13;
    3 &#13;
    &gt; sumOnSteroids(1, 2, 3, 4); &#13;
    10 &#13;
    &gt; sumOnSteroids(1, 2, 3, 4, 4, 3, 2, 1); &#13;
    20 &#13;
    &gt; sumOnSteroids(5); &#13;
    5 &#13;
    &gt; sumOnSteroids(); &#13;
    0 &#13;
</pre><p>The <code class="literal">arguments.length</code> expression returns the number of arguments passed when the function was called. Don't worry if the syntax is unfamiliar, we'll examine it in detail in the next chapter. You'll also see that <code class="literal">arguments</code> is not an array (although it sure looks like one), but an array-like object.</p><p>ES6 introduces several important improvements around function parameters. ES6 function parameters can now have default values, rest parameters, and allows destructuring. The next section discusses each of these concepts in detail.</p></div></div></div>
<div class="section" title="Default parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Default parameters</h1></div></div></div><p>Function parameters can be assigned default values. While calling the function, if a parameter is omitted, the default value assigned to the parameter is used:</p><pre class="programlisting">    function render(fog_level=0, spark_level=100){ &#13;
      console.log(`Fog Level: ${fog_level} and spark_level:&#13;
       ${spark_level}`) &#13;
    } &#13;
    render(10); //Fog Level: 10 and spark_level: 100 &#13;
</pre><p>In this example, we are omitting the <code class="literal">spark_level</code> parameter, and hence the default value assigned to the parameter is used. It is important to note that <code class="literal">undefined</code> is considered as an absence of parameter value; consider the following line of code, for example:</p><pre class="programlisting">    render(undefined,10); //Fog Level: 0 and spark_level: 10 &#13;
</pre><p>While providing default values of parameters, it is possible to refer to other parameters as well:</p><pre class="programlisting">    function t(fog_level=1, spark_level=fog_level){&#13;
      console.log(`Fog Level: ${fog_level} and spark_level: &#13;
       ${spark_level}`) &#13;
      //Fog Level: 10 and spark_level: 10 &#13;
    } &#13;
    function s(fog_level=10, spark_level = fog_level*10){ &#13;
      console.log(`Fog Level: ${fog_level} and spark_level:&#13;
       ${spark_level}`) &#13;
      //Fog Level: 10 and spark_level: 100 &#13;
    } &#13;
    t(10); &#13;
    s(10); &#13;
</pre><p>Default parameters have their own scope; this scope is sandwiched between the outer function scope and the inner scope of the function. If the parameter is shadowed by a variable in inner scope, surprisingly, the inner variable is not available. The following example will help explain this:</p><pre class="programlisting">    var scope="outer_scope"; &#13;
    function scoper(val=scope){ &#13;
      var scope="inner_scope"; &#13;
      console.log(val); //outer_scope &#13;
    } &#13;
    scoper(); &#13;
</pre><p>You may expect <code class="literal">val</code> to get shadowed by the inner definition of the <code class="literal">scope</code> variable, but as the default parameters have their own scope, the value assigned to <code class="literal">val</code> is unaffected by the inner scope.</p></div>
<div class="section" title="Rest parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Rest parameters</h1></div></div></div><p>ES6 introduces rest parameters. Rest parameters allow us to send an arbitrary number of parameters to a function in the form of an array. Rest parameter can only be the last one in the list of parameters, and there can only be one rest parameter. Putting a rest operator(<code class="literal">...</code>) before the last formal parameter indicates that parameter is a rest parameter. The following example shows adding a rest operator before the last formal parameter:</p><pre class="programlisting">    function sayThings(tone, ...quotes){ &#13;
      console.log(Array.isArray(quotes)); //true &#13;
      console.log(`In ${tone} voice, I say ${quotes}`) &#13;
    } &#13;
    sayThings("Morgan Freeman","Something serious"," &#13;
     Imploding Universe"," Amen"); &#13;
    //In Morgan Freeman voice, I say Something serious,&#13;
     Imploding Universe,Amen &#13;
</pre><p>The first parameter passed to the function is received in <code class="literal">tone</code>, while the rest of the parameters are received as an array. Variable arguments (var-args) have been part of several other languages and a welcome edition to ES6. Rest parameters can replace the slightly controversial <code class="literal">arguments</code> variable. The major difference between rest parameters and the <code class="literal">arguments</code> variable is that the rest parameters are real arrays. All array methods are available to rest parameters.</p></div>
<div class="section" title="Spread operators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Spread operators</h1></div></div></div><p>A spread operator looks exactly like a rest operator but performs the exact opposite function. Spread operators are used while providing arguments while calling a function or defining an array. The spread operator takes an array and splits its element into individual variables. The following example illustrates how the spread operator provides a much clearer syntax while calling functions that take an array as an argument:</p><pre class="programlisting">    function sumAll(a,b,c){ &#13;
      return a+b+c &#13;
    } &#13;
    var numbers = [6,7,8] &#13;
    //ES5 way of passing array as an argument of a function &#13;
    console.log(sumAll.apply(null,numbers)); //21 &#13;
    //ES6 Spread operator &#13;
    console.log(sumAll(...numbers))//21 &#13;
</pre><p>In ES5, it is common to use the <code class="literal">apply()</code> function when passing an array as an argument to a function. In the preceding example, we have an array we need to pass to a function where the function accepts three variables. The ES5 method of passing an array to this function uses the <code class="literal">apply()</code> function, where the second argument allows an array to be passed to the function being called. ES6 spread operators give a much cleaner and precise way to deal with this situation. While calling <code class="literal">sumAll()</code>, we use the spread operator(<code class="literal">...</code>) and pass the <code class="literal">numbers</code> array to the function call. The array is then split into individual variables-<code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>.</p><p>Spread operators improve the capabilities of arrays in JavaScript. If you want to create an array that is made up of another array, the existing array syntax does not support this. You have to use <code class="literal">push</code>, <code class="literal">splice</code>, and <code class="literal">concat</code> to achieve this. However, using spread operators, this becomes trivial:</p><pre class="programlisting">    var midweek = ['Wed', 'Thu']; &#13;
    var weekend = ['Sat', 'Sun']; &#13;
    var week = ['Mon','Tue', ...midweek, 'Fri', ...weekend]; &#13;
     //["Mon","Tue","Wed","Thu","Fri","Sat","Sun"] &#13;
    console.log(week); &#13;
</pre><p>In the preceding example, we are constructing a <code class="literal">week</code> array using two arrays, <code class="literal">midweek</code> and <code class="literal">weekend</code>, using the spread operator.</p><div class="section" title="Predefined functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Predefined functions</h2></div></div></div><p>There are a number of functions that are built into the JavaScript engine and are available for you to use. Let's take a look at them. While doing so, you'll have a chance to experiment with functions, their arguments and return values, and become comfortable working with functions. The following is a list of the built-in functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">parseInt()</li><li class="listitem" style="list-style-type: disc">parseFloat()</li><li class="listitem" style="list-style-type: disc">isNaN()</li><li class="listitem" style="list-style-type: disc">isFinite()</li><li class="listitem" style="list-style-type: disc">encodeURI()</li><li class="listitem" style="list-style-type: disc">decodeURI()</li><li class="listitem" style="list-style-type: disc">encodeURIComponent()</li><li class="listitem" style="list-style-type: disc">decodeURIComponent()</li><li class="listitem" style="list-style-type: disc">eval()</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>
<span class="strong"><strong>The black box function</strong></span></p><p>Often, when you invoke functions, your program doesn't need to know how these functions work internally. You can think of a function as a black box, give it some values (as input arguments), and then take the output result it returns. This is true for any function-one that's built into the JavaScript engine, one that you create, or one that a co-worker or someone else created.</p></div></div><div class="section" title="parseInt()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec21"/>parseInt()</h3></div></div></div><p>The <code class="literal">parseInt()</code> function takes any type of input (most often a string) and tries to make an integer out of it. If it fails, it returns <code class="literal">NaN</code>, as shown in the following code:</p><pre class="programlisting">    &gt; parseInt('123'); &#13;
    123 &#13;
    &gt; parseInt('abc123'); &#13;
    NaN &#13;
    &gt; parseInt('1abc23'); &#13;
    1 &#13;
    &gt; parseInt('123abc'); &#13;
    123 &#13;
</pre><p>The function accepts an optional second parameter, which is the radix, telling the function what type of number to expect-decimal, hexadecimal, binary, and so on. For example, trying to extract a decimal number out of the <code class="literal">FF</code> string makes no sense, so the result is <code class="literal">NaN</code>, but if you try <code class="literal">FF</code> as a hexadecimal, then you get <code class="literal">255</code>, as shown in the following piece of code:</p><pre class="programlisting">    &gt; parseInt('FF', 10); &#13;
    NaN &#13;
    &gt; parseInt('FF', 16); &#13;
    255 &#13;
</pre><p>Another example would be parsing a string with a base <code class="literal">10</code> (decimal) and base <code class="literal">8</code> (octal):</p><pre class="programlisting">    &gt; parseInt('0377', 10); &#13;
    377 &#13;
    &gt; parseInt('0377', 8); &#13;
    255 &#13;
</pre><p>If you omit the second argument when calling <code class="literal">parseInt()</code>, the function will assume <code class="literal">10</code> (a decimal), with the following exceptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you pass a string beginning with <code class="literal">0x</code>, then the radix is assumed to be <code class="literal">16</code> (a hexadecimal number is assumed).</li><li class="listitem" style="list-style-type: disc">If the string you pass starts with <code class="literal">0</code>, the function assumes radix <code class="literal">8</code> (an octal number is assumed). Consider the following examples:<pre class="programlisting">        &gt; parseInt('377'); &#13;
        377 &#13;
        &gt; console.log(0o377); &#13;
        255 &#13;
        &gt; parseInt('0x377'); &#13;
        887 &#13;
</pre></li></ul></div><p>The safest thing to do is to always specify the radix. If you omit the radix, your code will probably still work in 99 percent of cases (because most often you parse decimals); however, every once in a while, it might cause you a bit of hair loss while debugging some edge cases. For example, imagine you have a form field that accepts calendar days or months and the user types <code class="literal">06</code> or <code class="literal">08</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>ECMAScript 5 removes the octal literal values and avoids the confusion with <code class="literal">parseInt()</code> and unspecified radix.</p></div></div></div><div class="section" title="parseFloat()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec22"/>parseFloat()</h3></div></div></div><p>The <code class="literal">parseFloat()</code> function is similar to the <code class="literal">parseInt()</code> function, but it also looks for decimals when trying to figure out a number from your input. This function takes only one parameter, which is as follows:</p><pre class="programlisting">    &gt; parseFloat('123'); &#13;
    123 &#13;
    &gt; parseFloat('1.23'); &#13;
    1.23 &#13;
    &gt; parseFloat('1.23abc.00'); &#13;
    1.23 &#13;
    &gt; parseFloat('a.bc1.23'); &#13;
    NaN &#13;
</pre><p>As with <code class="literal">parseInt()</code>, <code class="literal">parseFloat()</code> gives up at the first occurrence of an unexpected character, even though the rest of the string might have usable numbers in it:</p><pre class="programlisting">    &gt; parseFloat('a123.34'); &#13;
    NaN &#13;
    &gt; parseFloat('12a3.34'); &#13;
    12 &#13;
</pre><p>The <code class="literal">parseFloat()</code> function understands exponents in the input (unlike <code class="literal">parseInt()</code>):</p><pre class="programlisting">    &gt; parseFloat('123e-2'); &#13;
    1.23 &#13;
    &gt; parseFloat('1e10'); &#13;
    10000000000 &#13;
    &gt; parseInt('1e10'); &#13;
    1 &#13;
</pre></div><div class="section" title="isNaN()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec23"/>isNaN()</h3></div></div></div><p>Using <code class="literal">isNaN()</code>, you can check if an input value is a valid number that can safely be used in arithmetic operations. This function is also a convenient way to check whether <code class="literal">parseInt()</code>, <code class="literal">parseFloat()</code>, or any arithmetic operation succeeded:</p><pre class="programlisting">    &gt; isNaN(NaN); &#13;
    true &#13;
    &gt; isNaN(123); &#13;
    false &#13;
    &gt; isNaN(1.23); &#13;
    false &#13;
    &gt; isNaN(parseInt('abc123')); &#13;
    true &#13;
</pre><p>The function will also try to convert the input to a number:</p><pre class="programlisting">    &gt; isNaN('1.23'); &#13;
    false &#13;
    &gt; isNaN('a1.23'); &#13;
    true &#13;
</pre><p>The <code class="literal">isNaN()</code> function is useful because the special value <code class="literal">NaN</code> is not equal to anything, including itself. In other words, <code class="literal">NaN === NaN</code> is <code class="literal">false</code>. So, <code class="literal">NaN</code> cannot be used to check if a value is a valid number.</p></div><div class="section" title="isFinite()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>isFinite()</h3></div></div></div><p>The <code class="literal">isFinite()</code> function checks whether the input is a number that is neither <code class="literal">Infinity</code> nor <code class="literal">NaN</code>:</p><pre class="programlisting">    &gt; isFinite(Infinity); &#13;
    false &#13;
    &gt; isFinite(-Infinity); &#13;
    false &#13;
    &gt; isFinite(12); &#13;
    true &#13;
    &gt; isFinite(1e308); &#13;
    true &#13;
    &gt; isFinite(1e309); &#13;
    false &#13;
</pre><p>If you are wondering about the results returned by the last two calls, remember from the previous chapter that the biggest number in JavaScript is <code class="literal">1.7976931348623157e+308</code>, so <code class="literal">1e309</code> is effectively infinity.</p></div><div class="section" title="Encode/decode URIs"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Encode/decode URIs</h3></div></div></div><p>In a <span class="strong"><strong>Uniform Resource Locator</strong></span> (<span class="strong"><strong>URL</strong></span>) or a <span class="strong"><strong>Uniform Resource Identifier</strong></span> (<span class="strong"><strong>URI</strong></span>), some characters have special meanings. If you want to escape those characters, you can use the <code class="literal">encodeURI()</code> or <code class="literal">encodeURIComponent()</code>functions. The first one will return a usable URL, while the second one assumes you're only passing a part of the URL, such as a query string for example, and will encode all applicable characters, as follows:</p><pre class="programlisting">    &gt; var url = 'http://www.packtpub.com/script.php?q=this and that'; &#13;
    &gt; encodeURI(url); &#13;
    "http://www.packtpub.com<a class="ulink" href="http://www.packtpub.com/">/</a>script.php?q=this%20and%20that" &#13;
    &gt; encodeURIComponent(url); &#13;
    "http%3A%2F%2Fwww.packtpub.com%2Fscript.php%3Fq%3Dthis%20and%20that" &#13;
</pre><p>The opposites of <code class="literal">encodeURI()</code> and <code class="literal">encodeURIComponent()</code> are <code class="literal">decodeURI()</code> and <code class="literal">decodeURIComponent()</code>, respectively.</p><p>Sometimes, in legacy code, you might see the functions <code class="literal">escape()</code> and <code class="literal">unescape()</code> used to encode and decode URLs, but these functions have been deprecated; they encode differently and should not be used.</p></div><div class="section" title="eval()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>eval()</h3></div></div></div><p>The <code class="literal">eval()</code> function takes a string input and executes it as a JavaScript code, as follows:</p><pre class="programlisting">    &gt; eval('var ii = 2;'); &#13;
    &gt; ii; &#13;
    2 &#13;
</pre><p>So, <code class="literal">eval('var ii = 2;')</code> is the same as <code class="literal">var ii = 2;</code>
</p><p>The <code class="literal">eval()</code> function can be useful sometimes, but it should be avoided if there are other options. Most of the time, there are alternatives, and in most cases, the alternatives are more elegant and easier to write and maintain. <span class="emphasis"><em>Eval is evil</em></span> is a mantra you can often hear from seasoned JavaScript programmers. The drawbacks of using <code class="literal">eval()</code> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Security</strong></span>: JavaScript is powerful, which also means it can cause damage. If you don't trust the source of the input you pass to <code class="literal">eval()</code>, just don't use it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Performance</strong></span>: It's slower to evaluate live code than to have the code directly in the script.</li></ul></div><div class="section" title="A bonus - the alert() function"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec3"/>A bonus - the alert() function</h4></div></div></div><p>Let's take a look at another common function-<code class="literal">alert()</code>. It's not part of the core JavaScript (it's nowhere to be found in the ECMA specification), but it's provided by the host environment-the browser. It shows a string of text in a message box. It can also be used as a primitive debugging tool, although the debuggers in modern browsers are much better suited for this purpose.</p><p>Here's a screenshot showing the result of executing the <code class="literal">alert("Hi There")</code> code:</p><p>
</p><div class="mediaobject"><img src="graphics/alert-e1483529706612.jpg" alt="A bonus - the alert() function"/></div><p>
</p><p>Before using this function, bear in mind that it blocks the browser thread, meaning that no other code will be executed until the user closes the alert. If you have a busy Ajax-type application, it's generally not a good idea to use <code class="literal">alert()</code>.</p></div></div></div></div>
<div class="section" title="Scope of variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Scope of variables</h1></div></div></div><p>It's important to note, especially if you have come to JavaScript from another language, that variables in JavaScript are not defined in a block scope, but in a function scope. This means that if a variable is defined inside a function, it's not visible outside of the function. However, if it's defined inside an <code class="literal">if</code> or a <code class="literal">for</code> code block, it's visible outside the block. The term global variables describes variables you define outside of any function (in the global program code), as opposed to local variables, which are defined inside a function. The code inside a function has access to all global variables as well as to its own local ones.</p><p>In the next example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">f()</code>function has access to the <code class="literal">global</code> variable</li><li class="listitem" style="list-style-type: disc">Outside the <code class="literal">f()</code>function, the <code class="literal">local</code> variable doesn't exist<pre class="programlisting">        var global = 1; &#13;
        function f() { &#13;
          var local = 2; &#13;
          global++; &#13;
          return global; &#13;
        } &#13;
</pre></li></ul></div><p>Let's test this:</p><pre class="programlisting">    &gt; f(); &#13;
    2 &#13;
    &gt; f(); &#13;
    3 &#13;
    &gt; local; &#13;
    ReferenceError: local is not defined &#13;
</pre><p>It's also important to note that if you don't use <code class="literal">var</code> to declare a variable, this variable is automatically assigned a global scope. Let's see an example:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001-e1482742379131.jpg" alt="Scope of variables"/></div><p>
</p><p>What happened? The <code class="literal">f()</code>function contains the <code class="literal">local</code> variable. Before calling the function, the variable doesn't exist. When you call the function for the first time, the <code class="literal">local</code> variable is created with a global scope. Then, if you access the <code class="literal">local</code> variable outside the function, it will be available.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>Best practice tips</strong></span></p><p>Minimize the number of global variables in order to avoid naming collisions. Imagine two people working on two different functions in the same script, and they both decide to use the same name for their global variable. This could easily lead to unexpected results and hard-to-find bugs. Always declare your variables with the <code class="literal">var</code> statement. Consider a single <code class="literal">var</code> pattern. Define all variables needed in your function at the very top of the function so you have a single place to look for variables and, hopefully, prevent accidental globals.</p></div></div><div class="section" title="Variable hoisting"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Variable hoisting</h2></div></div></div><p>Here's an interesting example that shows an important aspect of local versus global scoping:</p><pre class="programlisting">    var a = 123; &#13;
 &#13;
    function f() { &#13;
      alert(a); &#13;
      var a = 1; &#13;
      alert(a); &#13;
    } &#13;
 &#13;
    f(); &#13;
</pre><p>You might expect that the first <code class="literal">alert()</code> function will display <code class="literal">123</code> (the value of the global variable <code class="literal">a</code>) and the second will display <code class="literal">1</code> (the local variable <code class="literal">a</code>). But, this is not the case. The first alert will show <code class="literal">undefined</code>. This is because, inside the function, the local scope is more important than the global scope. So, a local variable overwrites any global variable with the same name. At the time of the first <code class="literal">alert()</code>, the <code class="literal">a</code> variable was not yet defined (hence the <code class="literal">undefined</code> value), but it still existed in the local space due to the special behavior called <span class="strong"><strong>hoisting</strong></span>.
</p><p>When your JavaScript program execution enters a new function, all the variables declared anywhere in the function are moved, elevated, or hoisted to the top of the function. This is an important concept to keep in mind. Further, only the declaration is hoisted, meaning only the presence of the variable is moved to the top. Any assignments stay where they are. In the preceding example, the declaration of the local variable <code class="literal">a</code> was hoisted to the top. Only the declaration was hoisted, but not the assignment to <code class="literal">1</code>. It's as if the function was written in the following way:</p><pre class="programlisting">    var a = 123; &#13;
 &#13;
    function f() { &#13;
      var a; // same as: var a = undefined; &#13;
      alert(a); // undefined &#13;
      a = 1; &#13;
      alert(a); // 1 &#13;
    } &#13;
</pre><p>You can also adopt the single var pattern mentioned previously in the best practice section. In this case, you'll be doing a sort of manual variable hoisting to prevent confusion with the JavaScript hoisting behavior.</p></div></div>
<div class="section" title="Block scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Block scope</h1></div></div></div><p>ES6 provides additional scope while declaring variables. We looked at function scope and how it affects variables declared with the <code class="literal">var</code> keyword. If you are coding in ES6, block scope will mostly replace your need to use variables declared using <code class="literal">var</code>. Although, if you are still with ES5, we want you to make sure that you look at hoisting behavior carefully.</p><p>ES6 introduces the <code class="literal">let</code> and <code class="literal">const</code> keywords that allow us to declare variables.</p><p>Variables declared with <code class="literal">let</code> are block-scoped. They exist only within the current block. Variables declared with <code class="literal">var</code> are function scoped, as we saw earlier. The following example illustrates the block scope:</p><pre class="programlisting">    var a = 1; &#13;
    { &#13;
        let a = 2; &#13;
        console.log( a );   // 2 &#13;
    } &#13;
    console.log( a );       // 1 &#13;
</pre><p>The scope between an opening brace<code class="literal">'{'</code> and a closing brace <code class="literal">'}'</code> is a block. If you are coming from a background in Java or C/C++, the concept of a block scope will be very familiar to you. In those languages, programmers introduced blocks just to define a scope. In JavaScript, however, there was a need to idiomatically introduce blocks as they didn't have a scope associated to it. However, ES6 allows you to create block-scoped variables using the <code class="literal">let</code> keyword. As you can see in the preceding example, variable <code class="literal">a</code> created inside the block is available within the block. While declaring block-scoped variables, it is generally recommended to add the <code class="literal">let</code> declaration at the top of the block. Let's look at another example to clearly distinguish function and block scope:</p><pre class="programlisting">    function swap(a,b){ // &lt;--function scope starts here &#13;
      if(a&gt;0 &amp;&amp; b&gt;0){   // &lt;--block scope starts here &#13;
        let tmp=a; &#13;
        a=b; &#13;
        b=tmp; &#13;
      }                // &lt;--block scope ends here &#13;
      console.log(a,b); &#13;
      console.log(tmp); // tmp is not defined as it is available&#13;
       only in the block scope &#13;
      return [a,b]; &#13;
    } &#13;
    swap(1,2); &#13;
</pre><p>As you can see, <code class="literal">tmp</code> is declared with <code class="literal">let</code> and is available only in the block in which it was defined. For all practical purposes, you should maximize your use of block-scoped variables. Unless there is something very specific you are trying to do that makes it necessary for you to use <code class="literal">var</code> declarations, make sure you prefer block scoped variables. However, incorrectly using the <code class="literal">let</code> keyword can cause a couple of problems. First, you cannot redeclare the same variable within the same function or block scope using the <code class="literal">let</code> keyword:</p><pre class="programlisting">    function blocker(x){ &#13;
      if(x){ &#13;
        let f; &#13;
        let f; //duplicate declaration "f" &#13;
      } &#13;
    } &#13;
</pre><p>In ES6, variables declared by the <code class="literal">let</code> keyword are hoisted to block scope. However, referencing the variable before its declaration is an error.
</p><p>Another keyword introduced in ES6 is <code class="literal">const</code>. A variable declared with the <code class="literal">const</code> keyword creates a read-only reference to a value. This does not mean that the value held by the reference is immutable. However, the variable identifier cannot be reassigned. Constants are block-scoped just like variables created using the <code class="literal">let</code> keyword. Also, you have to assign a value to the variable while declaring them.</p><p>Although it sounds like it does, <code class="literal">const</code> has nothing to do with immutable values. Constants create immutable binding. This is an important distinction and needs to be understood correctly. Let's consider the following example:</p><pre class="programlisting">    const car = {} &#13;
    car.tyres = 4 &#13;
</pre><p>This is a valid code; here we are assigning value <code class="literal">{}</code> to a constant <code class="literal">car</code>. Once assigned, this reference cannot be changed. In ES6, you should do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use <code class="literal">const</code> where possible. Use them for all variables whose values don't change:<pre class="programlisting">        Use let &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Avoid <code class="literal">var</code>.</li></ul></div></div>
<div class="section" title="Functions are data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Functions are data</h1></div></div></div><p>Functions in JavaScript are actually data. This is an important concept that we'll need later on. This means that you can create a function and assign it to a variable, as follows:</p><pre class="programlisting">    var f = function () { &#13;
      return 1; &#13;
    }; &#13;
</pre><p>This way of defining a function is sometimes referred to as <span class="strong"><strong>function literal notation</strong></span>.</p><p>The <code class="literal">function () { return 1;}</code> part is a <span class="strong"><strong>function expression</strong></span>. A function expression can optionally have a name, in which case it becomes a <span class="strong"><strong>named function expression</strong></span> (<span class="strong"><strong>NFE</strong></span>). So, this is also allowed, although rarely seen in practice (and causes IE to mistakenly create two variables in the enclosing scope-<code class="literal">f</code> and <code class="literal">myFunc</code>):</p><pre class="programlisting">    var f = function myFunc() { &#13;
      return 1; &#13;
    }; &#13;
</pre><p>As you can see, there's no difference between a named function expression and a function declaration. But they are, in fact, different. The only way to distinguish between the two is to look at the context in which they are used. Function declarations may only appear in program code (in a body of another function or in the main program). You'll see many more examples of functions later on in the book that will clarify these concepts.</p><p>When you use the <code class="literal">typeof</code> operator on a variable that holds a function value, it returns the string <code class="literal">"function"</code> as shown in the following example:</p><pre class="programlisting">    &gt; function define() { &#13;
        return 1;  &#13;
      } &#13;
 &#13;
    &gt; var express = function () {  &#13;
        return 1;  &#13;
      }; &#13;
 &#13;
    &gt; typeof define; &#13;
    "function" &#13;
 &#13;
    &gt; typeof express; &#13;
    "function" &#13;
</pre><p>So, JavaScript functions are data, but a special kind of data with the following two important features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They contain code</li><li class="listitem" style="list-style-type: disc">They are executable (they can be invoked)</li></ul></div><p>As you have seen before, the way to execute a function is by adding parentheses after its name. As the next example demonstrates, this works regardless of how the function was defined. In the example, you can also see how a function is treated as a regular value; it can be copied to a different variable, as follows:</p><pre class="programlisting">    &gt; var sum = function (a, b) { &#13;
        return a + b; &#13;
      }; &#13;
 &#13;
    &gt; var add = sum; &#13;
    &gt; typeof add; &#13;
    function &#13;
    &gt; add(1, 2); &#13;
    3 &#13;
</pre><p>As functions are data assigned to variables, the same rules for naming functions apply as for naming variables-a function name cannot start with a number and it can contain any combination of letters, numbers, the underscore character, and the dollar sign.</p><div class="section" title="Anonymous functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Anonymous functions</h2></div></div></div><p>As you now know, there exists a function expression syntax where you can have a function defined like the following:</p><pre class="programlisting">    var f = function (a) { &#13;
      return a; &#13;
    }; &#13;
</pre><p>This is also often called an <span class="strong"><strong>anonymous function</strong></span> (as it doesn't have a name), especially when such a function expression is used even without assigning it to a variable. In this case, there can be two elegant uses for such anonymous functions, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can pass an anonymous function as a parameter to another function. The receiving function can do something useful with the function that you pass.</li><li class="listitem" style="list-style-type: disc">You can define an anonymous function and execute it right away.</li></ul></div><p>Let's see these two applications of anonymous functions in more detail.</p></div><div class="section" title="Callback functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Callback functions</h2></div></div></div><p>As a function is just like any other data assigned to a variable, it can be defined, copied, and also passed as an argument to other functions.</p><p>Here's an example of a function that accepts two functions as parameters, executes them, and returns the sum of what each of them returns:</p><pre class="programlisting">    function invokeAdd(a, b) { &#13;
      return a() + b(); &#13;
    } &#13;
</pre><p>Now, let's define two simple additional functions using a function declaration pattern that only returns hardcoded values:</p><pre class="programlisting">    function one() { &#13;
      return 1; &#13;
    } &#13;
   &#13;
    function two() { &#13;
      return 2; &#13;
    } &#13;
</pre><p>Now you can pass those functions to the original function, <code class="literal">invokeAdd()</code>, and get the following result:</p><pre class="programlisting">    &gt; invokeAdd(one, two); &#13;
    3 &#13;
</pre><p>Another example of passing a function as a parameter is to use anonymous functions (function expressions). Instead of defining <code class="literal">one()</code> and <code class="literal">two()</code>, you can simply do the following:</p><pre class="programlisting">    &gt; invokeAdd(function () {return 1; }, function () {return 2; }); &#13;
    3 &#13;
</pre><p>Or, you can make it more readable, as shown in the following code:</p><pre class="programlisting">    &gt; invokeAdd( &#13;
        function () { return 1; },  &#13;
        function () { return 2; } &#13;
      ); &#13;
    3 &#13;
</pre><p>Or, you can do the following:</p><pre class="programlisting">    &gt; invokeAdd( &#13;
        function () { &#13;
          return 1; &#13;
        },  &#13;
        function () { &#13;
          return 2; &#13;
        } &#13;
      ); &#13;
    3 &#13;
</pre><p>When you pass a function, A, to another function, B, and then B executes A, it's often said that A is a <span class="strong"><strong>callback</strong></span> function. If A doesn't have a name, then you can say that it's an anonymous callback function.</p><p>When are callback functions useful? Let's see some examples that demonstrate the benefits of callback functions, namely:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They let you pass functions without the need to name them, which means there are fewer variables floating around</li><li class="listitem" style="list-style-type: disc">You can delegate the responsibility of calling a function to another function, which means there is less code to write</li><li class="listitem" style="list-style-type: disc">They can help with performance by deferring the execution or by unblocking calls</li></ul></div><div class="section" title="Callback examples"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Callback examples</h3></div></div></div><p>Take a look at this common scenario-you have a function that returns a value, which you then pass to another function. In our example, the first function, <code class="literal">multiplyByTwo()</code>, accepts three parameters, loops through them, multiplies them by two, and returns an array containing the result. The second function, <code class="literal">addOne()</code>, takes a value, adds one to it, and returns it, as follows:</p><pre class="programlisting">    function multiplyByTwo(a, b, c) { &#13;
      var i, ar = []; &#13;
      for (i = 0; i &lt; 3; i++) { &#13;
        ar[i] = arguments[i] * 2; &#13;
      } &#13;
      return ar; &#13;
    } &#13;
 &#13;
    function addOne(a) { &#13;
      return a + 1; &#13;
    } &#13;
</pre><p>Let's test these functions:</p><pre class="programlisting">    &gt; multiplyByTwo(1, 2, 3); &#13;
    [2, 4, 6] &#13;
    &gt; addOne(100); &#13;
    101 &#13;
</pre><p>Now, let's say you want to have an array, <code class="literal">myarr</code>, that contains three elements, and each of the elements is to be passed through both functions. First, let's start with a call to <code class="literal">multiplyByTwo()</code>:</p><pre class="programlisting">    &gt; var myarr = []; &#13;
    &gt; myarr = multiplyByTwo(10, 20, 30); &#13;
    [20, 40, 60] &#13;
</pre><p>Now, loop through each element, passing it to <code class="literal">addOne()</code>:</p><pre class="programlisting">    &gt; for (var i = 0; i &lt; 3; i++) { &#13;
        myarr[i] = addOne(myarr[i]); &#13;
      } &#13;
    &gt; myarr; &#13;
    [21, 41, 61] &#13;
</pre><p>As you can see, everything works fine, but there's room for improvement. For example, there were two loops. Loops can be expensive if they go through a lot of repetitions. You can achieve the same result with only one loop. Here's how to modify <code class="literal">multiplyByTwo()</code> so that it accepts a callback function and invokes that callback on every iteration:</p><pre class="programlisting">    function multiplyByTwo(a, b, c, callback) { &#13;
      var i, ar = []; &#13;
      for (i = 0; i &lt; 3; i++) { &#13;
        ar[i] = callback(arguments[i] * 2); &#13;
      } &#13;
      return ar; &#13;
    } &#13;
</pre><p>Using the modified function, all the work is done with just one function call, which passes the start values and the <code class="literal">callback</code> function, as follows:</p><pre class="programlisting">    &gt; myarr = multiplyByTwo(1, 2, 3, addOne); &#13;
    [3, 5, 7] &#13;
</pre><p>Instead of defining <code class="literal">addOne()</code>, you can use an anonymous function, therefore saving an extra global variable:</p><pre class="programlisting">    &gt; multiplyByTwo(1, 2, 3, function (a) { &#13;
        return a + 1; &#13;
      }); &#13;
    [3, 5, 7] &#13;
</pre><p>Anonymous functions are easy to change should the need arise:</p><pre class="programlisting">    &gt; multiplyByTwo(1, 2, 3, function (a) { &#13;
        return a + 2; &#13;
      }); &#13;
    [4, 6, 8] &#13;
</pre></div></div><div class="section" title="Immediate functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Immediate functions</h2></div></div></div><p>So far, we have discussed using anonymous functions as callbacks. Let's see another application of an anonymous function-calling a function immediately after it's defined. Here's an example:</p><pre class="programlisting">    ( &#13;
      function () { &#13;
        alert('boo'); &#13;
      } &#13;
    )(); &#13;
</pre><p>The syntax may look a little scary at first, but all you do is simply place a function expression inside parentheses followed by another set of parentheses. The second set says execute now and is also the place to put any arguments that your anonymous function might accept, for example:</p><pre class="programlisting">    ( &#13;
      function (name) { &#13;
        alert('Hello ' + name + '!'); &#13;
      } &#13;
    )('dude'); &#13;
</pre><p>Alternatively, you can move the closing of the first set of parentheses to the end. Both of these work:</p><pre class="programlisting">    (function () { &#13;
      // ... &#13;
    }()); &#13;
 &#13;
    // vs.  &#13;
 &#13;
    (function () { &#13;
      // ... &#13;
    })(); &#13;
</pre><p>One good application of immediate (self-invoking) anonymous functions is when you want to have some work done without creating extra global variables. A drawback, of course, is that you cannot execute the same function twice. This makes immediate functions best suited for one-off or initialization tasks.</p><p>An immediate function can also optionally return a value if you need one. It's not uncommon to see code that looks like the following:</p><pre class="programlisting">    var result = (function () { &#13;
      // something complex with &#13;
      // temporary local variables... &#13;
      // ... &#13;
  &#13;
      // return something; &#13;
    }()); &#13;
</pre><p>In this case, you don't need to wrap the function expression in parentheses; you only need the parentheses that invoke the function. So, the following piece of code also works:</p><pre class="programlisting">    var result = function () { &#13;
      // something complex with &#13;
      // temporary local variables &#13;
      // return something; &#13;
    }(); &#13;
</pre><p>This syntax works, but may look slightly confusing; without reading the end of the function, you don't know if <code class="literal">result</code> is a function or the return value of the immediate function.</p></div><div class="section" title="Inner (private) functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Inner (private) functions</h2></div></div></div><p>Bearing in mind that a function is just like any other value, there's nothing that stops you from defining a function inside another function, here's the example:</p><pre class="programlisting">    function outer(param) { &#13;
      function inner(theinput) { &#13;
        return theinput * 2; &#13;
      } &#13;
      return 'The result is ' + inner(param); &#13;
    } &#13;
</pre><p>Using a function expression, this can also be written as follows:</p><pre class="programlisting">    var outer = function (param) { &#13;
      var inner = function (theinput) { &#13;
        return theinput * 2; &#13;
      }; &#13;
      return 'The result is ' + inner(param); &#13;
    }; &#13;
</pre><p>When you call the global <code class="literal">outer()</code>function, it will internally call the local <code class="literal">inner()</code>function. As <code class="literal">inner()</code> is local, it's not accessible outside <code class="literal">outer()</code>, so you can say it's a private function:</p><pre class="programlisting">    &gt; outer(2); &#13;
    "The result is 4" &#13;
    &gt; outer(8); &#13;
    "The result is 16" &#13;
    &gt; inner(2); &#13;
    ReferenceError: inner is not defined &#13;
</pre><p>The benefits of using private functions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can keep the global namespace clean, which is less likely to cause naming collisions</li><li class="listitem" style="list-style-type: disc">Privacy-you can expose only those functions to the outside world that you decide, and keep the functionality that is not meant to be consumed by the rest of the application to yourself</li></ul></div></div><div class="section" title="Functions that return functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Functions that return functions</h2></div></div></div><p>As mentioned earlier, a function always returns a value, and if it doesn't do it explicitly with <code class="literal">return</code>, then it does so implicitly by returning <code class="literal">undefined</code>. A function can return only one value, and this value can just as easily be another function, for example:</p><pre class="programlisting">    function a() { &#13;
      alert('A!'); &#13;
      return function () { &#13;
        alert('B!'); &#13;
      }; &#13;
    } &#13;
</pre><p>In this example, the <code class="literal">a()</code>function does its job (says <code class="literal">A!</code>) and returns another function that does something else (says <code class="literal">B!</code>). You can assign the return value to a variable and then use this variable as a normal function, as follows:</p><pre class="programlisting">    &gt; var newFunc = a(); &#13;
    &gt; newFunc(); &#13;
</pre><p>Here, the first line will alert <code class="literal">A!</code> and the second will alert <code class="literal">B!</code>.</p><p>If you want to execute the returned function immediately without assigning it to a new variable, you can simply use another set of parentheses. The end result will be the same:</p><pre class="programlisting">    &gt; a()(); &#13;
</pre></div><div class="section" title="Function, rewrite thyself!"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Function, rewrite thyself!</h2></div></div></div><p>As a function can return a function, you can use the new function to replace the old one. Continuing with the previous example, you can take the value returned by the call to <code class="literal">a()</code> to overwrite the actual <code class="literal">a()</code> function:</p><pre class="programlisting">    &gt; a = a(); &#13;
</pre><p>The preceding line of code alerts <code class="literal">A!</code>, but the next time you call <code class="literal">a()</code> it alerts <code class="literal">B!</code>. This is useful when a function has some initial one-off work to do. The function overwrites itself after the first call in order to avoid doing unnecessary repetitive work every time it's called.</p><p>In the preceding example, the function was redefined from the outside and the returned value was assigned back to the function. But, the function can actually rewrite itself from the inside, as shown in the following example:</p><pre class="programlisting">    function a() { &#13;
      alert('A!'); &#13;
      a = function () { &#13;
        alert('B!'); &#13;
      }; &#13;
    } &#13;
</pre><p>If you call this function for the first time, it will do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Alert <code class="literal">A!</code> (consider this as being the one-off preparatory work)</li><li class="listitem" style="list-style-type: disc">Redefine the global variable <code class="literal">a</code> and assigning a new function to it</li></ul></div><p>Every subsequent time that the function is called, it will alert <code class="literal">B!</code>.</p><p>Here's another example that combines several of the techniques discussed in the last few sections of this chapter:</p><pre class="programlisting">    var a = (function () { &#13;
 &#13;
      function someSetup() { &#13;
        var setup = 'done'; &#13;
      } &#13;
 &#13;
      function actualWork() { &#13;
        alert('Worky-worky'); &#13;
      } &#13;
 &#13;
      someSetup(); &#13;
      return actualWork; &#13;
 &#13;
    }()); &#13;
</pre><p>From this example, you can note the following things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You have private functions; <code class="literal">someSetup()</code> and <code class="literal">actualWork()</code>.</li><li class="listitem" style="list-style-type: disc">You have an immediate function: an anonymous function that calls itself using the parentheses following its definition.</li><li class="listitem" style="list-style-type: disc">The function executes for the first time, calls <code class="literal">someSetup()</code>, and then returns a reference to the <code class="literal">actualWork</code> variable, which is a function. Notice that there are no parentheses in the <code class="literal">return</code> statement because you're returning a function reference, not the result of invoking this function.</li><li class="listitem" style="list-style-type: disc">As the whole thing starts with <code class="literal">var a =</code>, the value returned by the self-invoked function is assigned to <code class="literal">a</code>.</li></ul></div><p>If you want to test your understanding of the topics just discussed, answer the following questions. What will the preceding code alert be in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is initially loaded?</li><li class="listitem" style="list-style-type: disc">You call <code class="literal">a()</code> afterwards?</li></ul></div><p>These techniques could be really useful when working in the browser environment. Different browsers can have different ways of achieving the same result. If you know that the browser features won't change between function calls, you can have a function determine the best way to do the work in the current browser, then redefine itself so that the browser capability detection is done only once. You'll see concrete examples of this scenario later in this book.</p></div></div>
<div class="section" title="Closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Closures</h1></div></div></div><p>The rest of the chapter is about closures (what better way to close a chapter?). Closures can be a little hard to grasp initially, so don't feel discouraged if you don't get it during the first read. You should go through the rest of the chapter and experiment with the examples on your own, but if you feel you don't fully understand the concept, you can come back to it later when the topics discussed previously in this chapter have had a chance to sink in.</p><p>Before moving on to closures, let's first review and expand on the concept of scope in JavaScript.</p><div class="section" title="Scope chain"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Scope chain</h2></div></div></div><p>As you know, in JavaScript, there is no curly braces scope, but there is a function scope. A variable defined in a function is not visible outside the function, but a variable defined in a code block (for example an <code class="literal">if</code> or a <code class="literal">for</code> loop) is visible outside the block, for example:</p><pre class="programlisting">    &gt; var a = 1;  &#13;
    &gt; function f() { &#13;
        var b = 1;  &#13;
        return a; &#13;
      } &#13;
    &gt; f(); &#13;
    1 &#13;
    &gt; b; &#13;
    ReferenceError: b is not defined &#13;
</pre><p>The <code class="literal">a</code> variable is in the global space, while <code class="literal">b</code> is in the scope of the function <code class="literal">f()</code>. So, we have the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inside <code class="literal">f()</code>, both <code class="literal">a</code> and <code class="literal">b</code> are visible</li><li class="listitem" style="list-style-type: disc">Outside <code class="literal">f()</code>, <code class="literal">a</code> is visible, but <code class="literal">b</code> is not</li></ul></div><p>If you define an <code class="literal">inner()</code>function nested inside <code class="literal">outer()</code>, it will have access to variables in its own scope, plus the scope of its parents. This is known as a scope chain, and the chain can be as long (deep) as you need it to be:</p><pre class="programlisting">    var global = 1; &#13;
    function outer() { &#13;
      var outer_local = 2; &#13;
      function inner() { &#13;
        var inner_local = 3; &#13;
        return inner_local + outer_local + global; &#13;
      } &#13;
      return inner(); &#13;
    } &#13;
</pre><p>Let's test if the <code class="literal">inner()</code> function has access to all variables:</p><pre class="programlisting">    &gt; outer(); &#13;
    6 &#13;
</pre></div><div class="section" title="Breaking the chain with a closure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Breaking the chain with a closure</h2></div></div></div><p>Let's introduce closures with an illustration and look at the following code and see what's happening there:</p><pre class="programlisting">    var a = "global variable"; &#13;
    var F = function () { &#13;
      var b = "local variable"; &#13;
      var N = function () { &#13;
        var c = "inner local"; &#13;
      }; &#13;
    }; &#13;
</pre><p>First, there is the global scope <span class="strong"><strong>G</strong></span>. Think of it as the universe, as if it contains everything:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="Breaking the chain with a closure"/></div><p>
</p><p>It can contain global variables such as <span class="strong"><strong>a1</strong></span> and <span class="strong"><strong>a2</strong></span> and global functions such as <span class="strong"><strong>F</strong></span>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="Breaking the chain with a closure"/></div><p>
</p><p>Functions have their own private space and can use it to store other variables, such as <span class="strong"><strong>b</strong></span>, and inner functions, such as <span class="strong"><strong>N</strong></span> (for inner). At some point, you will end up with a picture like the following:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" alt="Breaking the chain with a closure"/></div><p>
</p><p>If you're at point a, you're inside the global space. If you're at point <span class="strong"><strong>b</strong></span>, which is inside the space of the <span class="strong"><strong>F</strong></span> function, then you have access to the global space and to the <span class="strong"><strong>F</strong></span> space. If you're at point <span class="strong"><strong>c</strong></span>, which is inside the <span class="strong"><strong>N</strong></span> function, then you can access the global space, the <span class="strong"><strong>F</strong></span> space, and the <span class="strong"><strong>N</strong></span> space. You cannot reach from <span class="strong"><strong>a</strong></span> to <span class="strong"><strong>b</strong></span>, because <span class="strong"><strong>b</strong></span> is invisible outside <span class="strong"><strong>F</strong></span>. But, you can get from <span class="strong"><strong>c</strong></span> to <span class="strong"><strong>b</strong></span> if you want or from <span class="strong"><strong>N</strong></span> to <span class="strong"><strong>b</strong></span>. The interesting part is that the closure effect happens when somehow <span class="strong"><strong>N</strong></span> breaks out of <span class="strong"><strong>F</strong></span> and ends up in the global space.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" alt="Breaking the chain with a closure"/></div><p>
</p><p>What happens then? <span class="strong"><strong>N</strong></span> is in the same global space as <span class="strong"><strong>a</strong></span>. And, as functions remember the environment in which they were defined, <span class="strong"><strong>N</strong></span> will still have access to the <span class="strong"><strong>F</strong></span> space, and hence, can access <span class="strong"><strong>b</strong></span>. This is interesting, because <span class="strong"><strong>N</strong></span> is where <span class="strong"><strong>a</strong></span> is and yet <span class="strong"><strong>N</strong></span> does have access to <span class="strong"><strong>b</strong></span>, but <span class="strong"><strong>a</strong></span> doesn't.</p><p>Additionally, how does <span class="strong"><strong>N</strong></span> break the chain? By making itself global (omitting <code class="literal">var</code>) or by having <span class="strong"><strong>F</strong></span> deliver (or <code class="literal">return</code>) it to the global space. Let's see how this is done in practice.</p><div class="section" title="Closure #1"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Closure #1</h3></div></div></div><p>Take a look at the following function, which is the same as before, only <code class="literal">F</code> returns <code class="literal">N</code> and also <code class="literal">N</code> returns <code class="literal">b</code>, to which it has access via the scope chain:</p><pre class="programlisting">    var a = "global variable"; &#13;
    var F = function () { &#13;
      var b = "local variable"; &#13;
      var N = function () { &#13;
        var c = "inner local"; &#13;
        return b; &#13;
      }; &#13;
      return N; &#13;
    }; &#13;
</pre><p>The <code class="literal">F</code> function contains the <code class="literal">b</code> variable, which is local, and therefore inaccessible from the global space:</p><pre class="programlisting">    &gt; b; &#13;
    ReferenceError: b is not defined &#13;
</pre><p>The <code class="literal">N</code> function has access to its private space, to the <code class="literal">F()</code> function's space, and to the global space. So, it can see <code class="literal">b</code>. As <code class="literal">F()</code> is callable from the global space (it's a global function), you can call it and assign the returned value to another global variable. The result - a new global function that has access to the <code class="literal">F()</code> function's private space:</p><pre class="programlisting">    &gt; var inner = F(); &#13;
    &gt; inner(); &#13;
    "local variable" &#13;
</pre></div><div class="section" title="Closure #2"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Closure #2</h3></div></div></div><p>The final result of the next example will be the same as the previous example, but the way to achieve it is a little different. <code class="literal">F()</code> doesn't return a function, but instead it creates a new global function, <code class="literal">inner()</code>, inside its body.</p><p>Let's start by declaring a placeholder for the global function-to-be. This is optional, but it's always good to declare your variables. Then, you can define the <code class="literal">F()</code>function as follows:</p><pre class="programlisting">    var inner; // placeholder &#13;
    var F = function () { &#13;
      var b = "local variable"; &#13;
      var N = function () { &#13;
        return b; &#13;
      }; &#13;
      inner = N; &#13;
    }; &#13;
</pre><p>Now, let's see what happens if you invoke <code class="literal">F()</code>:</p><pre class="programlisting">    &gt; F(); &#13;
</pre><p>A new function, <code class="literal">N()</code>,is defined inside <code class="literal">F()</code> and assigned to the global <code class="literal">inner</code> function. During definition time, <code class="literal">N()</code> was inside <code class="literal">F()</code>, so it had access to the <code class="literal">F()</code> function's scope. The <code class="literal">inner()</code> function will keep its access to the <code class="literal">F()</code> function's scope, even though it's part of the global space, for example:</p><pre class="programlisting">    &gt; inner(); &#13;
    "local variable". &#13;
</pre></div><div class="section" title="A definition and closure #3"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>A definition and closure #3</h3></div></div></div><p>Every function can be considered a closure. This is because every function maintains a secret link to the environment (the scope) in which it was created. But, most of the time, this scope is destroyed unless something interesting happens (as shown in the preceding code) that causes it to be maintained.</p><p>Based on what you've seen so far, you can say that a closure is created when a function keeps a link to its parent scope even after the parent has returned. And, every function is a closure because, at the very least, every function maintains access to the global scope, which is never destroyed.</p><p>Let's see one more example of a closure, this time using the function parameters. Function parameters behave like local variables to this function, but they are implicitly created; you don't need to use <code class="literal">var</code> for them. You can create a function that returns another function, which in turn returns its parent's parameter, as follows:</p><pre class="programlisting">    function F(param) { &#13;
      var N = function () { &#13;
        return param; &#13;
      }; &#13;
      param++; &#13;
      return N; &#13;
    } &#13;
</pre><p>You can use the function as follows:</p><pre class="programlisting">    &gt; var inner = F(123); &#13;
    &gt; inner(); &#13;
    124 &#13;
</pre><p>Notice how <code class="literal">param++</code> was incremented after the function was defined and yet, when called, <code class="literal">inner()</code> returned the updated value. This demonstrates that the function maintains a reference to the scope where it was defined, and not to the variables and their values found in the scope during the function execution.</p></div></div><div class="section" title="Closures in a loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Closures in a loop</h2></div></div></div><p>Let's take a look at a canonical rookie mistake when it comes to closures. It can easily lead to hard-to-spot bugs, because on the surface, everything looks normal.</p><p>Let's loop three times, each time creating a new function that returns the loop sequence number. The new functions will be added to an array and the array is returned at the end. Here's the function:</p><pre class="programlisting">    function F() { &#13;
      var arr = [], i; &#13;
      for (i = 0; i &lt; 3; i++) { &#13;
        arr[i] = function () { &#13;
          return i; &#13;
        }; &#13;
      } &#13;
      return arr; &#13;
    } &#13;
</pre><p>Let's run the function, assigning the result to the <code class="literal">arr</code> array:</p><pre class="programlisting">    &gt; var arr = F(); &#13;
</pre><p>Now you have an array of three functions. Let's invoke them by adding parentheses after each array element. The expected behavior is to see the loop sequence printed out as <code class="literal">0</code>, <code class="literal">1</code>, and <code class="literal">2</code>. Let's try:</p><pre class="programlisting">    &gt; arr[0](); &#13;
    3 &#13;
    &gt; arr[1](); &#13;
    3 &#13;
    &gt; arr[2](); &#13;
    3 &#13;
</pre><p>Hmm, not quite as expected. What happened here? All three functions point to the same local variable: <code class="literal">i</code>. Why? The functions don't remember values, they only keep a link (reference) to the environment where they were created. In this case, the <code class="literal">i</code> variable happens to live in the environment where the three functions were defined. So, all functions, when they need to access the value, reach back to the environment and find the most current value of <code class="literal">i</code>. After the loop, the <code class="literal">i</code> variable's value is <code class="literal">3</code>. So, all three functions point to the same value.</p><p>Why three and not two is another good question to think about for better understanding the <code class="literal">for</code> loop.</p><p>So, how do you implement the correct behavior? The answer is to use another closure, as shown in the following piece of code:</p><pre class="programlisting">    function F() { &#13;
      var arr = [], i; &#13;
      for (i = 0; i &lt; 3; i++) { &#13;
        arr[i] = (function (x) { &#13;
          return function () { &#13;
            return x; &#13;
          }; &#13;
        }(i)); &#13;
      } &#13;
      return arr; &#13;
    } &#13;
</pre><p>This gives you the expected result as follows:</p><pre class="programlisting">    &gt; var arr = F(); &#13;
    &gt; arr[0](); &#13;
    0 &#13;
    &gt; arr[1](); &#13;
    1 &#13;
    &gt; arr[2](); &#13;
    2 &#13;
</pre><p>Here, instead of just creating a function that returns <code class="literal">i</code>, you pass the <code class="literal">i</code> variable's current value to another immediate function. In this function, <code class="literal">i</code> becomes the local value <code class="literal">x</code>, and <code class="literal">x</code> has a different value every time.</p><p>Alternatively, you can use a normal (as opposed to an immediate) inner function to achieve the same result. The key is to use the middle function to localize the value of <code class="literal">i</code> at every iteration, as follows:</p><pre class="programlisting">    function F() { &#13;
   &#13;
      function binder(x) { &#13;
        return function () { &#13;
          return x; &#13;
        }; &#13;
      } &#13;
 &#13;
      var arr = [], i; &#13;
      for (i = 0; i &lt; 3; i++) { &#13;
        arr[i] = binder(i); &#13;
      } &#13;
      return arr; &#13;
    } &#13;
</pre></div><div class="section" title="Getter and setter"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Getter and setter</h2></div></div></div><p>Let's see two more examples of using closures. The first one involves the creation of the getter and setter functions. Imagine that you have a variable that should contain a specific type of value or a specific range of values. You don't want to expose this variable because you don't want just any part of the code to be able to alter its value. You can protect this variable inside a function and provide two additional functions-one to get the value and one to set it. The one that sets it could contain some logic to validate a value before assigning it to the protected variable. Let's make the validation part simple (for the sake of keeping the example short) and only accept number values.</p><p>You can place both the getter and the setter functions inside the same function that contains the <code class="literal">secret</code> variable so that they share the same scope:</p><pre class="programlisting">    var getValue, setValue; &#13;
 &#13;
    (function () { &#13;
 &#13;
      var secret = 0; &#13;
 &#13;
      getValue = function () { &#13;
        return secret; &#13;
      }; &#13;
 &#13;
      setValue = function (v) { &#13;
        if (typeof v === "number") { &#13;
          secret = v; &#13;
        } &#13;
      }; &#13;
 &#13;
    }()); &#13;
</pre><p>In this case, the function that contains everything is an immediate function. It defines <code class="literal">setValue()</code> and <code class="literal">getValue()</code> as global functions, while the <code class="literal">secret</code> variable remains local and inaccessible directly, as shown in the following example:</p><pre class="programlisting">    &gt; getValue(); &#13;
    0 &#13;
    &gt; setValue(123); &#13;
    &gt; getValue(); &#13;
    123 &#13;
    &gt; setValue(false); &#13;
    &gt; getValue(); &#13;
    123 &#13;
</pre></div><div class="section" title="Iterator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Iterator</h2></div></div></div><p>The last closure example (also the last example in this chapter) shows the use of a closure to accomplish an iterator functionality.</p><p>You already know how to loop through a simple array, but there might be cases where you have a more complicated data structure with different rules as to what the sequence of values has. You can wrap the complicated who's next logic into an easy-to-use <code class="literal">next()</code> function. Then, you can simply call <code class="literal">next()</code> every time you need the consecutive value.</p><p>For this example, let's just use a simple array and not a complex data structure. Here's an initialization function that takes an input array and also defines a secret pointer, <code class="literal">i</code>, that will always point to the next element in the array:</p><pre class="programlisting">    function setup(x) { &#13;
      var i = 0; &#13;
      return function () { &#13;
        return x[i++]; &#13;
      }; &#13;
    } &#13;
</pre><p>Calling the <code class="literal">setup()</code> function with a data array will create the <code class="literal">next()</code> function for you, as follows:</p><pre class="programlisting">    &gt; var next = setup(['a', 'b', 'c']); &#13;
</pre><p>From there it's easy and fun; calling the same function over and over again gives you the next element, which is as follows:</p><pre class="programlisting">    &gt; next(); &#13;
    "a" &#13;
    &gt; next(); &#13;
    "b" &#13;
    &gt; next(); &#13;
    "c" &#13;
</pre></div></div>
<div class="section" title="IIFE versus blocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>IIFE versus blocks</h1></div></div></div><p>As ES5 did not provide block scope, a popular pattern to achieve block scope was to use <span class="strong"><strong>immediately invoked function expressions</strong></span> (<span class="strong"><strong>IIFE</strong></span>), for example:</p><pre class="programlisting">    (function () { &#13;
      var block_scoped=0; &#13;
    }()); &#13;
    console.log(block_scoped); //reference error &#13;
</pre><p>With ES6's support for block scopes, you can simply use a <code class="literal">let</code> or <code class="literal">const</code> declaration.</p></div>
<div class="section" title="Arrow functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Arrow functions</h1></div></div></div><p>JavaScript uses almost all variations of arrows. With ES6, it introduces a new syntax for writing functions. We have always written function expressions in JavaScript. It is idiomatic to write code like this in JavaScript (this example is in jQuery):</p><pre class="programlisting">    $("#submit-btn").click(function (event) { &#13;
      validateForm(); &#13;
      submitMessage(); &#13;
    }); &#13;
</pre><p>This is a typical jQuery event handler. The event handler <code class="literal">click()</code> function accepts a function as a parameter and we will simply create an inline anonymous function expression and pass it to the click function. This style of writing anonymous function expressions is known as <span class="strong"><strong>Lambda functions</strong></span>. Several other languages support this feature. Though lambdas are more or less standard in new languages, JavaScript was responsible for popularizing their usage. However, the lambda syntax in JavaScript has not been very concise. ES6 arrow functions fill that gap and provide a concise syntax to write functions.</p><p>Arrow function provide a more concise syntax than the traditional function expressions; for example, consider the following piece of code:</p><pre class="programlisting">    const num = [1,2,3] &#13;
    const squares = num.map(function(n){ &#13;
      return n*n; &#13;
    }); &#13;
    console.log(squares); //[1,4,9] &#13;
</pre><p>Arrow functions syntax can simplify the function to the following line of code:</p><pre class="programlisting">    const squares_6 =num.map( n=&gt; n*n) &#13;
</pre><p>As you can see, there is no <code class="literal">function</code> or <code class="literal">return</code> keyword anywhere. If your function has only one argument, you will end up writing the function as <code class="literal">identifer =&gt; expression</code>.</p><p>When you need multiple arguments, you need to wrap the argument list in braces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>No parameters</strong></span>: <code class="literal">() =&gt; {...}</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One parameter</strong></span>: <code class="literal">a =&gt; {...}</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>More than one parameters</strong></span>: <code class="literal">(a,b) =&gt; {...}</code></li></ul></div><p>Arrow functions can have both the statement block bodies as well as expression bodies:</p><pre class="programlisting">    n =&gt; { return n+n}  //statement block &#13;
    n =&gt;n+n            //expression &#13;
</pre><p>Both are equivalent but the second variation is concise and preferred. Arrow functions are always anonymous. One important aspect of arrow functions that we will discuss a little later is that arrow functions do not bind their own values of the <code class="literal">this</code> keyword-the value is lexically derived from the surrounding scope. As we have not yet looked at the <code class="literal">this</code> keyword in detail, we will defer the discussion to a later part of this book.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a function that converts a hexadecimal color, for example blue (<code class="literal">#0000FF</code>), into its RGB representation, <code class="literal">rgb(0, 0, 255)</code>. Name your function <code class="literal">getRGB()</code> and test it with the following code (hint: treat the string as an array of characters):<pre class="programlisting">        &gt; var a = getRGB("#00FF00"); &#13;
        &gt; a; &#13;
        "rgb(0, 255, 0)" &#13;
</pre></li><li class="listitem">What do each of these following lines print in the console?<pre class="programlisting">        &gt; parseInt(1e1); &#13;
        &gt; parseInt('1e1'); &#13;
        &gt; parseFloat('1e1'); &#13;
        &gt; isFinite(0/10); &#13;
        &gt; isFinite(20/0); &#13;
        &gt; isNaN(parseInt(NaN)); &#13;
</pre></li><li class="listitem">What does this following code alert?<pre class="programlisting">        var a = 1; &#13;
 &#13;
        function f() { &#13;
         function n() { &#13;
            alert(a); &#13;
          } &#13;
          var a = 2; &#13;
          n(); &#13;
        } &#13;
 &#13;
        f(); &#13;
</pre></li><li class="listitem">All these following examples alert <code class="literal">"Boo!"</code>. Can you explain why?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Example 1:<pre class="programlisting">        var f = alert; &#13;
        eval('f("Boo!")'); &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Example 2:<pre class="programlisting">        var e; &#13;
        var f = alert; &#13;
        eval('e=f')('Boo!'); &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Example 3:<pre class="programlisting">        (function(){ &#13;
          return alert;} &#13;
        )()('Boo!'); &#13;
</pre></li></ul></div></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Summary</h1></div></div></div><p>You have now completed the introduction to the fundamental concepts related to functions in JavaScript. This has laid the groundwork that will allow you to quickly grasp the concepts of object-oriented JavaScript and the patterns used in modern JavaScript programming. So far, we've been avoiding the OO features, but as you have reached this point in the book, it's only going to get more interesting from here on in. Let's take a moment to review the topics discussed in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics of how to define and invoke (call) a function using either a function declaration syntax or a function expression</li><li class="listitem" style="list-style-type: disc">Function parameters and their flexibility</li><li class="listitem" style="list-style-type: disc">Built-in functions-<code class="literal">parseInt()</code>, <code class="literal">parseFloat()</code>, <code class="literal">isNaN()</code>, <code class="literal">isFinite()</code>, and <code class="literal">eval()</code>-and the four functions to encode/decode a URL</li><li class="listitem" style="list-style-type: disc">The scope of variables in JavaScript-no curly braces scope, variables have only function scope and the scope chain</li><li class="listitem" style="list-style-type: disc">Functions as data-a function is like any other piece of data that you assign to a variable and a lot of interesting applications follow from this, such as:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Private functions and private variables</li><li class="listitem" style="list-style-type: disc">Anonymous functions</li><li class="listitem" style="list-style-type: disc">Callbacks</li><li class="listitem" style="list-style-type: disc">Immediate functions</li><li class="listitem" style="list-style-type: disc">Functions overwriting themselves</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Closures</li><li class="listitem" style="list-style-type: disc">Arrow functions</li></ul></div></div></body></html>