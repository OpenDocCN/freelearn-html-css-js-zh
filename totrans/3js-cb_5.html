<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Lights and Custom Shaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Lights and Custom Shaders</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating shadows with THREE.SpotLight</li><li class="listitem" style="list-style-type: disc">Creating shadows with THREE.DirectionalLight</li><li class="listitem" style="list-style-type: disc">Softening lights by adding ambient lighting</li><li class="listitem" style="list-style-type: disc">Using THREE.HemisphereLight for natural lighting</li><li class="listitem" style="list-style-type: disc">Adding a moving all-directional light</li><li class="listitem" style="list-style-type: disc">Moving a light source along a path</li><li class="listitem" style="list-style-type: disc">Making a light source follow an object</li><li class="listitem" style="list-style-type: disc">Creating a custom vertex shader</li><li class="listitem" style="list-style-type: disc">Creating a custom fragment shader</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Introduction</h1></div></div></div><p>Three.js provides a large number of light sources out of the box. In this chapter, we'll show you a number of recipes that work on lights and also show you how to get the most out of the lighting options provided by Three.js. We'll also show you two advanced recipes that explain how you can access the raw features of WebGL by creating your own custom vertex and fragment shaders.</p></div></div>
<div class="section" title="Creating shadows with THREE.SpotLight"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec68"/>Creating shadows with THREE.SpotLight</h1></div></div></div><p>Three.js <a id="id391" class="indexterm"/>offers many different types of lights<a id="id392" class="indexterm"/> you can use in your scenes. A couple of these lights also allow you to add shadows to the scene. When you use <code class="literal">THREE.SpotLight</code> or a <code class="literal">THREE.DirectionalLight</code> object, you can let Three.js add shadows based on the position of the lights. In this recipe, we'll show you how to do this with <code class="literal">THREE.SpotLight</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec222"/>Getting ready</h2></div></div></div><p>For this recipe, you don't need any external dependencies. Three.js includes all the available lights directly in the main Three.js JavaScript library. We've created a simple example <a id="id393" class="indexterm"/>that you can use to see how shadows<a id="id394" class="indexterm"/> work in combination with <code class="literal">THREE.SpotLight</code> in Three.js. You can view this example by opening <code class="literal">05.01-using-shadows-with-a-spotLight.html</code> in your browser. You will see something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_01.jpg" alt="Getting ready"/></div><p>In this scene, you can see that we've added two meshes to the scene, both of which cast a shadow on the floor. From this example, you can also directly see the distinct light shape provided by <code class="literal">THREE.SpotLight</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec223"/>How to do it...</h2></div></div></div><p>To create a shadow with <code class="literal">THREE.SpotLight</code>, we need to set a couple of properties, which define the area where shadows are created:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Before we look at <code class="literal">THREE.SpotLight</code>, the first thing we need to do is tell the renderer that we want to enable shadows. To do this, set the following property on <code class="literal">THREE.WebGLRenderer</code>:<div class="informalexample"><pre class="programlisting">  renderer.shadowMapEnabled = true;</pre></div></li><li class="listitem">The next step is to inform Three.js which objects cast shadows and which objects receive shadows. If you look back at the screenshot in the <span class="emphasis"><em>Getting ready</em></span> section, you can see that the monkey and the cube both cast a shadow and <a id="id395" class="indexterm"/>the floor receives the shadow. To do this, you have to set the following properties on the <code class="literal">THREE.Mesh</code> objects that should cast shadows:<div class="informalexample"><pre class="programlisting">..monkey.castShadow = true;
  cubeMesh.castShadow = true;</pre></div><p>For objects that receive shadows, you have to set the following on the <code class="literal">THREE.Mesh</code> object:</p><div class="informalexample"><pre class="programlisting">  floorMesh.receiveShadow = true;</pre></div></li><li class="listitem">At this <a id="id396" class="indexterm"/>point, we're ready to create <code class="literal">THREE.SpotLight</code>:<div class="informalexample"><pre class="programlisting">  var spotLight = new THREE.SpotLight();
  spotLight.angle = Math.PI/8; // in radians
  spotLight.exponent = 30;
  spotLight.position = new THREE.Vector3(40,60,-50);</pre></div><p>These are the standard properties that define how <code class="literal">THREE.SpotLight</code> adds light to a scene.</p></li><li class="listitem">The next step is to set up the shadow-related properties:<div class="informalexample"><pre class="programlisting">  spotLight.castShadow = true;
  spotLight.shadowCameraNear = 50;
  spotLight.shadowCameraFar = 200;
  spotLight.shadowCameraFov = 35;</pre></div><p>The first property, <code class="literal">castShadow</code>, tells Three.js that this light casts shadows. As casting shadows is an expensive operation, we need to define the area where shadows can appear. This is done with the <code class="literal">shadowCameraNear</code>, <code class="literal">shadowCameraFar</code>, and <code class="literal">shadowCameraFov</code> properties.</p></li><li class="listitem">Three.js uses something called a shadow map to render the shadows. If your shadow looks a bit blocky around its edges, it means the shadow map is too small. To increase the shadow map size, set the following properties:<div class="informalexample"><pre class="programlisting">  spotLight.shadowMapHeight = 2048;
  spotLight.shadowMapWidth = 2048;</pre></div><p>Alternatively, you can also try to change the <code class="literal">shadowMapType</code> property of <code class="literal">THREE.WebGLRenderer</code>. You can set this to <code class="literal">THREE.BasicShadowMap</code>, <code class="literal">THREE.PCFShadowMap</code>, or <code class="literal">THREE.PCSSoftShadowMap</code>.</p></li><li class="listitem">The last step is to add <code class="literal">THREE.SpotLight</code> to the scene:<div class="informalexample"><pre class="programlisting">  scene.add(spotLight);</pre></div></li></ol></div><p>Determining the correct properties for the various <code class="literal">THREE.SpotLight</code> properties can be difficult. In the following section, we'll explain a bit more how the various properties affect the area where shadows are rendered.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec224"/>How it works...</h2></div></div></div><p>When<a id="id397" class="indexterm"/> you want to use <code class="literal">THREE.SpotLight</code> as a light source that can cast shadows, Three.js needs to know the area<a id="id398" class="indexterm"/> that will be affected by these shadows. You can compare this with the arguments you use to configure <code class="literal">THREE.PerspectiveCamera</code>. So, what you do with the <code class="literal">shadowCameraNear</code>, <code class="literal">shadowCameraFar</code>, and <code class="literal">shadowCameraFov</code> properties is define where Three.js should render shadows. Determining the correct values for these properties can be a bit difficult, but luckily, Three.js can visualize this area. If you set the <code class="literal">shadowCameraVisible</code> property of <code class="literal">THREE.SpotLight</code> to <code class="literal">true</code>, Three.js will show you the affected area, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_02.jpg" alt="How it works..."/></div><p>In this screenshot, the size of the area is visualized with orange and red lines. By enabling this <code class="literal">shadowCameraVisible</code> property and experimenting with the other values, you can quickly determine the correct values.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec225"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In <a id="id399" class="indexterm"/>Three.js, there are two light<a id="id400" class="indexterm"/> sources that can cast shadows: <code class="literal">THREE.SpotLight</code> and <code class="literal">THREE.DirectionalLight</code>. In the <span class="emphasis"><em>Creating shadows with a THREE.DirectionalLight</em></span> recipe, we explain how to cast shadows using <code class="literal">THREE.DirectionalLight</code>. A more performant but static way to create shadows is explained in the <span class="emphasis"><em>Using a shadow map for fixed shadows</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <span class="emphasis"><em>Materials and Textures</em></span>.</li></ul></div></div></div>
<div class="section" title="Creating shadows with THREE.DirectionalLight"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec69"/>Creating shadows with THREE.DirectionalLight</h1></div></div></div><p>With <code class="literal">THREE.DirectionalLight</code>, you <a id="id401" class="indexterm"/>can <a id="id402" class="indexterm"/>simulate a light source from far away whose rays run parallel to each other. A good example of this is light received from the sun. In this recipe, we'll show you how to create <code class="literal">THREE.DirectionalLight</code> and use it to create shadows.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec226"/>Getting ready</h2></div></div></div><p>For this recipe, we've <a id="id403" class="indexterm"/>created an<a id="id404" class="indexterm"/> example that shows you what the shadows cast by a <code class="literal">THREE.DirectionalLight</code> object look like. Open up the <code class="literal">05.02-using-shadows-with-a-directionalLight.html</code> example in your browser, and you'll see something like what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_03.jpg" alt="Getting ready"/></div><p>In this screenshot, a single <code class="literal">THREE.DirectionalLight</code> object provides the shadows and lighting.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec227"/>How to do it...</h2></div></div></div><p>Using <code class="literal">THREE.DirectionLight</code> as a shadow only takes a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do to enable any kind of shadow is set <code class="literal">shadowMapEnabled</code> on <code class="literal">THREE.WebGLRenderer</code> to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">  renderer.shadowMapEnabled = true;</pre></div></li><li class="listitem">Next, we inform Three.js which of our objects should receive shadows and which should cast shadows. So, for the objects that should cast a shadow, set the <code class="literal">castShadow</code> property on <code class="literal">THREE.Mesh</code> to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">  monkey.castShadow = true;
  cubeMesh.castShadow = true;</pre></div><p>For the objects that should receive a shadow, the floor in this case, set the following property on <code class="literal">THREE.Mesh</code> to <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">  floorMesh.receiveShadow = true;</pre></div></li><li class="listitem">Now, we <a id="id405" class="indexterm"/>can create <code class="literal">THREE.DirectionalLight</code> and configure this light source. Add the following<a id="id406" class="indexterm"/> code to create <code class="literal">THREE.DirectionalLight</code>:<div class="informalexample"><pre class="programlisting">  var directionalLight = new THREE.DirectionalLight();
  directionalLight.position = new THREE.Vector3(70,40,-50);
  directionalLight.castShadow = true;</pre></div></li><li class="listitem">This will create and position <code class="literal">THREE.DirectionalLight</code> and together with the <code class="literal">castShadow</code> property, this light source will be used by Three.js to render shadows.</li><li class="listitem">The next step is to configure the area where shadows should be rendered:<div class="informalexample"><pre class="programlisting">  directionalLight.shadowCameraNear = 25;
  directionalLight.shadowCameraFar = 200;
  directionalLight.shadowCameraLeft = -50;
  directionalLight.shadowCameraRight = 50;
  directionalLight.shadowCameraTop = 50;
  directionalLight.shadowCameraBottom = -50;</pre></div><p>With these properties, we create a box-like area where Three.js will render shadows.</p></li><li class="listitem">Three.js uses two additional properties to determine the detail of the rendered shadow: <code class="literal">shadowMapWidth</code> and <code class="literal">shadowMapHeight</code>. If your shadows look a bit rough or blocky, you should increase the values like this:<div class="informalexample"><pre class="programlisting">  directionalLight.shadowMapWidth = 2048;
  directionalLight.shadowMapHeight = 2048;</pre></div></li><li class="listitem">After all these properties have been set, you can add the light source to the scene:<div class="informalexample"><pre class="programlisting">  scene.add(directionalLight);</pre></div></li></ol></div><p>As you can see from these steps it is a little complicated to correctly configure <code class="literal">THREE.DirectionalLight</code>. Determining the correct values can be difficult. In the next section, we'll explain a bit more what these properties do and how you can determine their optimal values for your scene.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec228"/>How it works...</h2></div></div></div><p>If <a id="id407" class="indexterm"/>you look back to the <span class="emphasis"><em>Using an orthographic camera</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Working with the Camera">Chapter 3</a>, <span class="emphasis"><em>Working with the Camera</em></span>, you'll notice that the <a id="id408" class="indexterm"/>camera uses the same properties as <code class="literal">THREE.DirectionalLight</code>. Both these objects define a bounding box that is rendered in the case of <code class="literal">THREE.OrthographicCamera</code> and is used to determine where to render shadows in the case of <code class="literal">THREE.DirectionalLight</code>. With <code class="literal">shadowCameraNear</code>, <code class="literal">shadowCameraFar</code>, <code class="literal">shadowCameraLeft</code>, <code class="literal">shadowCameraRight</code>, <code class="literal">shadowCameraTop</code>, and <code class="literal">shadowCameraBottom</code>, you define this area. You can set an additional property on <code class="literal">THREE.DirectionalLight</code> to visualize the affected area. If you set <code class="literal">directionalLight.shadowCameraVisible</code> to <code class="literal">true</code>, Three.js will draw the box defined by the <code class="literal">shadowCameraXXX</code> properties. The following screenshot shows you the result of enabling the <code class="literal">shadowCameraVisible</code> property:</p><div class="mediaobject"><img src="graphics/1182OS_05_04.jpg" alt="How it works..."/></div><p>Shadows will only be rendered in the area contained by the orange box.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec229"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In Three.js, there are two<a id="id409" class="indexterm"/> light sources that<a id="id410" class="indexterm"/> can cast shadows: <code class="literal">THREE.SpotLight</code> and <code class="literal">THREE.DirectionalLight</code>. In the <span class="emphasis"><em>Creating shadows with THREE.SpotLight</em></span> recipe, we explain how to cast shadows using <code class="literal">THREE.SpotLight</code>. An alternative way to create shadows is explained in the <span class="emphasis"><em>Using a shadow map for fixed shadows</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <span class="emphasis"><em>Materials and Textures</em></span>.</li></ul></div></div></div>
<div class="section" title="Softening lights by adding ambient lighting"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Softening lights by adding ambient lighting</h1></div></div></div><p>When<a id="id411" class="indexterm"/> you add lights to a scene, the result<a id="id412" class="indexterm"/> might look a bit harsh. You can see a strong contrast between the areas that receive lights and those that don't. When you look at real-life lighting, everything is a bit softer and almost every surface will receive some light, most often reflected from other surfaces. In this recipe, we'll show you how you can soften the light usage in your scene using <code class="literal">THREE.AmbientLight</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec230"/>Getting ready</h2></div></div></div><p>There are no steps required to get ready for this recipe. To see the final result in action, we provided an example, which you can see by opening the <code class="literal">05.03-soften-lights.html</code> example in your browser. You will find something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_05.jpg" alt="Getting ready"/></div><p>With<a id="id413" class="indexterm"/> the menu in the top-right section, you<a id="id414" class="indexterm"/> can enable or disable <code class="literal">THREE.AmbientLight</code> to see the effect <code class="literal">THREE.AmbientLight</code> object has.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec231"/>How to do it...</h2></div></div></div><p>
<code class="literal">THREE.AmbientLight</code> is the simplest of lights to use. As it applies light to the complete scene, there is no need to position the light source. All you have to do is create an instance of <code class="literal">THREE.AmbientLight</code> and add it to the scene:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create the instance of <code class="literal">THREE.AmbientLight</code>:<div class="informalexample"><pre class="programlisting">  var ambientLight = new THREE.AmbientLight(0x332222);</pre></div><p>This will create the light source. When you create the ambient light, you can specify its color as a hex value. Don't specify it too high; if you do, your whole scene will be very bright.</p></li><li class="listitem">The only thing left to do is add this light to the scene:<div class="informalexample"><pre class="programlisting">  scene.add(ambientLight);</pre></div></li></ol></div><p>With these two very simple steps, you've created <code class="literal">THREE.AmbientLight</code>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec232"/>How it works...</h2></div></div></div><p>
<code class="literal">THREE.AmbientLight</code> works in a very simple way. When you create <code class="literal">THREE.AmbientLight</code>, you pass in a color (in hex) into its constructor. When the scene is rendered, Three.js just blends<a id="id415" class="indexterm"/> in the specified color to the color of any of your meshes.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec233"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Even<a id="id416" class="indexterm"/> though <code class="literal">THREE.AmbientLight</code> can be used to soften the lighting in a scene, it's hard to create natural-looking lighting. In the <span class="emphasis"><em>Using THREE.HemisphereLight for natural lighting</em></span> recipe, we show you how to use a different light source for natural outside lighting.</li></ul></div></div></div>
<div class="section" title="Using THREE.HemisphereLight for natural lighting"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec71"/>Using THREE.HemisphereLight for natural lighting</h1></div></div></div><p>If <a id="id417" class="indexterm"/>you look at the lighting outside, you'll see that the lights don't really come from a single direction. Part of the sunlight <a id="id418" class="indexterm"/>is reflected by Earth, and other parts are scattered by the atmosphere. The result is a very soft light coming from lots of directions. In Three.js, we can create something similar using <code class="literal">THREE.HemisphereLight</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec234"/>Getting ready</h2></div></div></div><p>Just like the other lights provided by Three.js, there is no need to include any additional JavaScript file to work with <code class="literal">THREE.HemisphereLight</code>. All you need is a scene with some objects, and you can add this light. To see the effect <code class="literal">THREE.HemisphereLight</code> object has, we've provided a simple example. Open up <code class="literal">05.04-create-a-sun-like-light.html</code> in your browser. You will see something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_06.jpg" alt="Getting ready"/></div><p>With <a id="id419" class="indexterm"/>the controls in the top-right <a id="id420" class="indexterm"/>section, you can enable and disable <code class="literal">THREE.HemisphereLight</code> and <code class="literal">THREE.DirectionalLight</code>, which are used in this scene.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec235"/>How to do it...</h2></div></div></div><p>Creating <code class="literal">THREE.HemisphereLight</code> works in pretty much the same way as creating the other lights:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You first need to instantiate a <code class="literal">THREE.HemisphereLight</code> instance:<div class="informalexample"><pre class="programlisting">  var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6 );</pre></div><p>The first parameter sets the color of the sky, and the second color sets the color reflected from the floor. In both these cases, we just set a white light. With the last property, you can control the intensity of <code class="literal">THREE.HemisphereLight</code> object. In this case, we dampen the light by setting it to <code class="literal">0.6</code>.</p></li><li class="listitem">Next, we need to position the light:<div class="informalexample"><pre class="programlisting">  hemiLight.position.set( 0, 500, 0 );</pre></div><p>When you position <code class="literal">THREE.HemisphereLight</code>, it's best to position it directly above the scene for the best effect.</p></li><li class="listitem">Finally, with the position set, the last step is to add the light to the scene:<div class="informalexample"><pre class="programlisting">  scene.add( hemiLight );</pre></div></li></ol></div><p>You <a id="id421" class="indexterm"/>could use <code class="literal">THREE.HemisphereLight</code> as the main light source of your scene, but most often, this light <a id="id422" class="indexterm"/>source is used together with a different light source. For the best outdoor effect, use it with <code class="literal">THREE.DirectionalLight</code>, which can cast shadows.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec236"/>How it works...</h2></div></div></div><p>
<code class="literal">THREE.HemisphereLight</code> pretty much acts as two <code class="literal">THREE.DirectionalLight</code> objects: one positioned at the specified position and another one in exactly the opposite position. So, when a scene is rendered, <code class="literal">THREE.HemisphereLight</code> lights an object from the top and from the opposite direction to create a natural-looking effect.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec237"/>There's more…</h2></div></div></div><p>You can, of course, also use two <code class="literal">THREE.DirectionalLight</code> objects instead of <code class="literal">THREE.HemisphereLight</code>. With careful tuning, you can reach the exact same effect as you would get with <code class="literal">THREE.HemisphereLight</code>. The added advantage is that you could also make very faint shadows with this approach, as <code class="literal">THREE.DirectionalLight</code> supports casting shadows whereas <code class="literal">THREE.HemisphereLight</code> does not.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec238"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <span class="emphasis"><em>Softening lights by adding ambient lighting</em></span> recipe, we showed you a more simple approach of supporting the main light sources in your scene. We showed you how you can use <code class="literal">THREE.AmbientLight</code> as an extra light source to soften the lights and the shadows.</li></ul></div></div></div>
<div class="section" title="Adding a moving all-directional light"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec72"/>Adding a moving all-directional light</h1></div></div></div><p>In a <a id="id423" class="indexterm"/>lot of cases, you don't need a light source that casts shadows but just a light source that illuminates your scene. In the <span class="emphasis"><em>Creating shadows with THREE.SpotLight</em></span> and <span class="emphasis"><em>Creating shadows with THREE.DirectionalLight</em></span> recipes, we already showed you how you can use <code class="literal">THREE.SpotLight</code> and <code class="literal">THREE.DirectionalLight</code>. In this recipe, we'll show you a third kind of light, which is <code class="literal">THREE.PointLight</code>; this kind of light emits light to all directions and in this recipe, we will show you how to create one and move it through the scene.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec239"/>Getting ready</h2></div></div></div><p>As the <a id="id424" class="indexterm"/>Three.js standard comes with the <code class="literal">THREE.PointLight</code> object, there is no need to include any additional JavaScript. The same is the case with all the recipes where we've included an example where you can see the result of this recipe in action. For this recipe, open the <code class="literal">05.05-use-a-point-light.html</code> example in your browser, and you'll see the following result:</p><div class="mediaobject"><img src="graphics/1182OS_05_07.jpg" alt="Getting ready"/></div><p>In this example, there are four <code class="literal">THREE.PointLight</code> objects that move from the top to the bottom in between three models of a shark. You can use your mouse to move around this scene and see how <code class="literal">THREE.PointLight</code> illuminates the models.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec240"/>How to do it...</h2></div></div></div><p>Creating a moving <code class="literal">THREE.PointLight</code> object is very easy and only takes a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing to do is create a <code class="literal">THREE.PointLight</code> instance:<div class="informalexample"><pre class="programlisting">  var pointLight = new THREE.PointLight();
  pointLight.color = new THREE.Color(0xff0000);
  pointLight.intensity = 3;
  pointLight.distance = 60;
  pointLight.name = 'pointLight';</pre></div><p>With the <code class="literal">color</code> property, we set the color <code class="literal">THREE.PointLight</code> object emits, and<a id="id425" class="indexterm"/> the intensity allows us to set how much light is emitted. Finally, the <code class="literal">distance</code> property is used to calculate how much<a id="id426" class="indexterm"/> the intensity decreases the farther away the lit object is from the light. In this case, the intensity will be <code class="literal">0</code> when the distance to the light is <code class="literal">60</code>.</p></li><li class="listitem"><code class="literal">THREE.PointLight</code> emits lights in all directions, so we need to set the <code class="literal">position</code> property and then we can add the light to the scene:<div class="informalexample"><pre class="programlisting">  pointLight.position = new THREE.Vector3(-30,0,0);
  scene.add(pointLight);</pre></div></li><li class="listitem">The <a id="id427" class="indexterm"/>last thing we need to do for this recipe is move <code class="literal">THREE.PointLight</code> through the scene. Like all animations, we do this in the render loop by adding the following to the <code class="literal">render</code> function:<div class="informalexample"><pre class="programlisting">  var light = scene.getObjectByName('pointLight');
  light.position.y = 15 * Math.sin(count+=0.005);</pre></div><p>In this small code snippet, we first get a reference to our <code class="literal">THREE.PointLight</code> object and then update its <code class="literal">position.y</code> property. For this to work, we also need to define a global <code class="literal">count</code> property at the top of our JavaScript like this:</p><div class="informalexample"><pre class="programlisting">  var count = 0;</pre></div></li></ol></div><p>With these simple steps, you've created <code class="literal">THREE.PointLight</code>, which moves up and down through the scene.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec241"/>How it works...</h2></div></div></div><p>
<code class="literal">THREE.PointLight</code> emits light in all directions; you can compare this a bit with <code class="literal">THREE.SpotLight</code> but with a 360 degree field of view in all directions. This is also the main reason that <code class="literal">THREE.PointLight</code> can't be used to cast shadows. As there is so much light being emitted by <code class="literal">THREE.PointLight</code>, it is very difficult and resource-intensive to calculate the resulting shadows.</p><p>So, if you want shadows and also use <code class="literal">THREE.PointLight</code>, you could use a shadow map if you have a static <code class="literal">THREE.PointLight</code> object or an extra <code class="literal">THREE.SpotLight</code> object and set it to only cast shadows with the <code class="literal">onlyShadow</code> property.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec242"/>See also</h2></div></div></div><p>There<a id="id428" class="indexterm"/> are a couple of recipes that you can look at in relation to this recipe:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <span class="emphasis"><em>Creating shadows with a THREE.SpotLight</em></span> recipe, we showed you how you can use <code class="literal">THREE.SpotLight</code> to create shadows. You can use this together with <code class="literal">THREE.PointLight</code>.</li><li class="listitem" style="list-style-type: disc">In the <span class="emphasis"><em>Creating shadows with a THREE.DirectionalLight</em></span> recipe, we show you how to set up and configure <code class="literal">THREE.DirectionalLight</code>. This light casts shadows and can be used together with <code class="literal">THREE.PointLight</code>.</li><li class="listitem" style="list-style-type: disc">In <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <span class="emphasis"><em>Materials and Textures</em></span>, we showed you the <span class="emphasis"><em>Using a shadow map for fixed shadows</em></span> recipe. This recipe explained how to use shadow maps to fake shadows. If you use that recipe together with this one, you can use it to fake the shadows cast by <code class="literal">THREE.PointLight</code>.</li></ul></div></div></div>
<div class="section" title="Moving a light source along a path"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec73"/>Moving a light source along a path</h1></div></div></div><p>In the <span class="emphasis"><em>Add an moving all-directional light</em></span> recipe, we moved a light source up and down. While <a id="id429" class="indexterm"/>these simple kinds of paths are often enough, there are cases where you want more control over how your light source moves through a scene. In this recipe, we'll show you how you can move a light source along a predefined path.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec243"/>Getting ready</h2></div></div></div><p>To create this recipe, we'll use a <code class="literal">THREE.SplineCurve3D</code> and <code class="literal">THREE.SpotLight</code> object. As both of these objects are included with Three.js, we don't need to take any steps to get ready. A good thing to do, however, is look at the provided example for this recipe, which will show you what you'll get when you execute the steps from this recipe when you run the <code class="literal">05.06-move-a-light-through-the-scene.html</code> example:</p><div class="mediaobject"><img src="graphics/1182OS_05_08.jpg" alt="Getting ready"/></div><p>In<a id="id430" class="indexterm"/> the screenshot, you can see a light that moves slowly along the purple line. In the next section, we'll show you how you can create this yourself.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec244"/>How to do it...</h2></div></div></div><p>For this recipe, we first need to create the path that we'll follow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For this path, we'll create <code class="literal">THREE.SplineCurve3</code>:<div class="informalexample"><pre class="programlisting">  var spline = new THREE.SplineCurve3([
    new THREE.Vector3(-100, 20, 100),
    new THREE.Vector3(-40, 20, 20),
    new THREE.Vector3(0, 20, -100),
    new THREE.Vector3(20, 20, -100),
    new THREE.Vector3(40, 20, 100),
    new THREE.Vector3(70, 20, 10),
    new THREE.Vector3(100, 20, 30),
    new THREE.Vector3(-100, 20, 100)]);</pre></div><p>This will result in a curved path that moves through the points added in the constructor of the <code class="literal">THREE.SplineCurve3</code> object.</p></li><li class="listitem">Before we position our light on the path of this <code class="literal">THREE.SplineCurve3</code> object, let's create the light:<div class="informalexample"><pre class="programlisting">  var pointLight = new THREE.PointLight();
  pointLight.color = new THREE.Color(0xff0000);
  pointLight.intensity = 3;
  pointLight.distance = 60;
  pointlight.name = 'pointLight';</pre></div></li><li class="listitem">Now, we<a id="id431" class="indexterm"/> can use this <code class="literal">SplineCurve3</code> object to determine the position of our light. For this, we create a helper function called <code class="literal">positionLight</code>:<div class="informalexample"><pre class="programlisting">  var pos = 0;
  function positionLight() {
    light = scene.getObjectByName('pointLight');
    if (pos &lt;= 1) {
      light.position = spline.getPointAt(pos);
      pos += 0.001
    } else {
      pos = 0;
    }
  }</pre></div><p>In this function, we use <code class="literal">spline.getPointAt(pos)</code> to determine where on the <code class="literal">THREE.SplineCurve3</code> path we need to position our light. With <code class="literal">pos</code> at <code class="literal">0</code>, we're at the beginning of spline and with <code class="literal">pos</code> at <code class="literal">1</code>, we're at the end. This way, we slowly (in steps of <code class="literal">0.001</code>) move the light along the spline.</p></li><li class="listitem">All that is left to do is call the <code class="literal">positionLight</code> function from the render function:<div class="informalexample"><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    positionLight();
    orbit.update();
    requestAnimationFrame(render);
  }</pre></div></li></ol></div><p>As the render function is called approximately 60 times per second and we take 1000 steps for our complete path, the light will move along the complete path in about 17 seconds.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec245"/>How it works...</h2></div></div></div><p>When you instantiate a <code class="literal">THREE.SplineCurve3</code> object, you pass in an array of <code class="literal">THREE.Vector3</code> objects. Three.js internally interpolates these points to create a fluid curve that moves through all these points. Once the curve is created, you have two ways to get <a id="id432" class="indexterm"/>positions. You can use the <code class="literal">getPointAt</code> function, as we did in this recipe, to get a relative position based on the provided parameter, from <code class="literal">0</code> to <code class="literal">1</code>, and the length of the curve. Alternatively, you can also use the <code class="literal">getPoints</code> function, where you specify, as the parameter, in how many points the line should be divided.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec246"/>There's more…</h2></div></div></div><p>In the <span class="emphasis"><em>Getting ready</em></span> part of this recipe, we showed you an example where a light moved through a scene. What you could see was that we also showed the path along which the light moved. To do this for yourself, you can use the <code class="literal">getPoints</code> function from the created <code class="literal">THREE.SplineCurve3</code> object to create a <code class="literal">THREE.Line</code> object:</p><div class="informalexample"><pre class="programlisting">  var geometry = new THREE.Geometry();
  var splinePoints = spline.getPoints(50);
  var material = new THREE.LineBasicMaterial({
    color: 0xff00f0
  });
  geometry.vertices = splinePoints;
  var line = new THREE.Line(geometry, material);
  scene.add(line);</pre></div><p>In this recipe, we moved a light along a specific path. However, as a light is also just an object with a specific position, we can apply this same principle to all the other objects in the scene, such as <code class="literal">THREE.Mesh</code>, <code class="literal">THREE.PerspectiveCamera</code>, or <code class="literal">THREE.OrthographicCamera</code>.</p></div></div>
<div class="section" title="Making a light source follow an object"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec74"/>Making a light source follow an object</h1></div></div></div><p>If you've <a id="id433" class="indexterm"/>got a moving object in the scene that you want to highlight with a spotlight, you need to be able to change the direction a light is pointed at. In this recipe, we will show you how to do just that. We will show you how you can keep <code class="literal">THREE.SpotLight</code> pointed at a moving object in the scene.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec247"/>Getting ready</h2></div></div></div><p>There are no steps that you need to take to run this recipe. You can see the final result of this recipe by opening up the <code class="literal">05.07-make-a-light-follow-object.html</code> example in your browser. You will see something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_05_09.jpg" alt="Getting ready"/></div><p>In <a id="id434" class="indexterm"/>this example, you can see a sphere that moves from left to right and back again. <code class="literal">THREE.SpotLight</code> in this scene follows the position of this sphere so that it is always pointed directly at the center of that object.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec248"/>How to do it...</h2></div></div></div><p>Following an object in Three.js is very easy and only takes a couple of easy steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The fist thing we need to do is create the object that we want to follow. For this recipe, this is <code class="literal">THREE.SpotLight</code>:<div class="informalexample"><pre class="programlisting">  var sphereGeometry = new THREE.SphereGeometry(1.5, 20,20);
  var matProps = {
    specular: 0xa9fcff,
    color: 0x00abb1,
    emissive: 0x006063,
    shininess: 10
  }
  var sphereMaterial = new THREE.MeshPhongMaterial(matProps);
  var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);sphereMesh.name = 'sphere'; scene.add(sphereMesh);</pre></div></li><li class="listitem">Next, we<a id="id435" class="indexterm"/> create and add <code class="literal">THREE.SpotLight</code> to the scene:<div class="informalexample"><pre class="programlisting">  spotLight = new THREE.SpotLight();
  spotLight.position.set(20, 80, 30);
  spotLight.castShadow = true;
  spotLight.angle = 0.15;
  spotLight.distance = 160;
  scene.add(spotLight);</pre></div><p>Note that at this step, we don't point the created light to the sphere. We'll do this in the next step in the render loop.</p></li><li class="listitem">To keep the light pointed at the sphere, we need to set the <code class="literal">target</code> property to the correct value. We do this in the <code class="literal">render</code> function of the scene:<div class="informalexample"><pre class="programlisting">  var step = 0;
  function render() {
    step += 0.02;
    renderer.render(scene, camera);
    var sphere = scene.getObjectByName('sphere');
    sphere.position.x = 0 + (10 * (Math.cos(step)));
    sphere.position.y = 0.75 * Math.PI / 2 + (6 * Math.abs(Math.sin(step)));
    spotLight.target = sphere;
    requestAnimationFrame(render);
  }</pre></div><p>One thing to notice in the last step is that we set the target property of <code class="literal">spotLight</code> to the <code class="literal">THREE.Mesh</code> object and not to the position property of <code class="literal">THREE.Mesh</code>.</p></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec249"/>There's more…</h2></div></div></div><p>To point <code class="literal">THREE.SpotLight</code> at a certain position, we set its <code class="literal">target</code> property. As you've seen in the recipe steps, we target <code class="literal">THREE.Object3D</code>, from which <code class="literal">THREE.Mesh</code> extends, instead of a position. If we want to point <code class="literal">THREE.SpotLight</code> to an arbitrary position, we need to first create an empty <code class="literal">THREE.Object3D</code> object:</p><div class="informalexample"><pre class="programlisting">  var target = new THREE.Object3D();
  target.position = new THREE.Vector3(20,10,-10);
  scene.add(target);
  spotLight.target = target;</pre></div><p>This way, you can point <code class="literal">THREE.SpotLight</code> not just to an existing object in the scene but to any<a id="id436" class="indexterm"/> position you want.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec250"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this recipe, we pointed a light at a specific target, and we can also make a camera follow an object around the scene, as we showed in the <span class="emphasis"><em>Making the camera follow an object</em></span> recipe from <a class="link" href="ch03.html" title="Chapter 3. Working with the Camera">Chapter 3</a>, <span class="emphasis"><em>working with the Camera</em></span> and point one object to another, as shown in the <span class="emphasis"><em>Pointing an object to another object</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>.</li></ul></div></div></div>
<div class="section" title="Creating a custom vertex shader"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec75"/>Creating a custom vertex shader</h1></div></div></div><p>When<a id="id437" class="indexterm"/> you want to create advanced 3D effects with great performance, you can choose to write your own shaders. <span class="strong"><strong>Shaders</strong></span> are programs<a id="id438" class="indexterm"/> that directly affect what your results look like and which colors are used to represent them. A shader always comes as a pair. A vertex shader determines what a geometry will look like, and a fragment shader will determine the resulting color. In this recipe, we'll show you how you can use your own custom vertex shader in Three.js.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec251"/>Getting ready</h2></div></div></div><p>WebGL and GLSL, which is the language in which you write shaders, are supported by most modern browsers. So, for this recipe, there aren't any additional steps you need to take before<a id="id439" class="indexterm"/> you can walk through this recipe. A good resource on GLSL is always the khronos website (<a class="ulink" href="http://www.khronos.org">http://www.khronos.org</a>); they have a great tutorial (<a class="ulink" href="http://www.khronos.org/webgl/wiki/Tutorial">http://www.khronos.org/webgl/wiki/Tutorial</a>) on WebGL that can help you better understand what we're doing in this recipe. For this specific recipe, we've provided two examples. The first one is the one we'll use in this recipe, and you can view this one by opening <code class="literal">05.09-custom-vertex-shader.html</code> in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_05_10.jpg" alt="Getting ready"/></div><p>This <a id="id440" class="indexterm"/>example, as you can see in the previous screenshot, shows you <code class="literal">THREE.BoxGeometry</code>, where the position of its individual vertices have been replaced using a vertex shader. A more advanced example can be found in <code class="literal">05.09-custom-vertex-shader-2.html</code>.</p><div class="mediaobject"><img src="graphics/1182OS_05_11.jpg" alt="Getting ready"/></div><p>In this<a id="id441" class="indexterm"/> example, we once again change the position of individual vertices, but this time, we use <code class="literal">THREE.SphereGeometry</code> as the source and combine it with a perlin noise generator.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec252"/>How to do it...</h2></div></div></div><p>To create a custom vertex shader, you need to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As we just want to write a vertex shader, we'll use a standard fragment shader, which is the one also used by <code class="literal">THREE.MeshBasicMaterial</code> from Three.js. You can get a reference to this shader by selecting the correct one from <code class="literal">THREE.ShaderLib</code>:<div class="informalexample"><pre class="programlisting">  var basicShader = THREE.ShaderLib['basic'];</pre></div></li><li class="listitem">The next step is to define the <code class="literal">Uniforms</code> object. <code class="literal">Uniforms</code> are parameters that are passed into the shaders as arguments:<div class="informalexample"><pre class="programlisting">  Var uniforms = {}
  uniforms = THREE.UniformsUtils.merge([basicShader.uniforms]);
  var texture = THREE.ImageUtils.loadTexture('../assets/textures/debug.png');
  uniforms['map'].value = texture;
  uniforms.delta = {type: 'f', value: 0.0};
  uniforms.scale = {type: 'f', value: 1.0};</pre></div><p>In this code snippet, we first <code class="literal">merge</code> the standard uniforms that are by the fragment shader we reuse, we set a texture, and the last two uniforms are the ones we access in our own custom vertex shader, as we'll see later on.</p></li><li class="listitem">Now, we<a id="id442" class="indexterm"/> can define <code class="literal">THREE.ShaderMaterial</code> and tell Three.js the shaders that we want to use:<div class="informalexample"><pre class="programlisting">  var defines = {};
  defines[ "USE_MAP" ] = "";
  var material = new THREE.ShaderMaterial({
    defines: defines,
    uniforms: uniforms,
    vertexShader: document getElementById('sinusVertexShader').text,
    fragmentShader: basicShader.fragmentShader
  });</pre></div><p>In this code snippet, you can see that we reference the <code class="literal">uniform</code> value we saw in step 2, as <code class="literal">fragmentShader</code> we use <code class="literal">basicShader</code> from step 1, and for the <code class="literal">vertexShader</code> parameter, we reference our custom shader, which we'll define in the next step. Note that we also provide a <code class="literal">defines</code> element; this is needed to make sure Three.js shows our texture.</p></li><li class="listitem">At this point, we can define our own custom vertex shader. We do this directly in the HTML as follows:<div class="informalexample"><pre class="programlisting">  &lt;script id="sinusVertexShader" type="x-shader/x-vertex"&gt;
    varying vec2 vUv;
    uniform float delta;
    uniform float scale;
    void main() {
      vUv = uv;
      vec3 p = position;
      p.z += sin(2.0 * p.y + delta) * 5.0;
      p.z += cos(2.0 * p.z + delta / 2.0) * 5.0;
      p.z += cos(2.0 * p.x + delta) * 5.0;
      p.x += sin(p.y + delta / 2.0) * 10.0;
      vec4 mvPosition = modelViewMatrix * vec4(scale * p, 1.0 );
      gl_Position = projectionMatrix * mvPosition;
    }
  &lt;/script&gt;</pre></div><p>With this shader, we change the location of the vertices by changing the <code class="literal">p.z</code> and the <code class="literal">p.x</code> part of its position.</p></li><li class="listitem">At <a id="id443" class="indexterm"/>this point, we can just create a geometry and use the material we created in step 3:<div class="informalexample"><pre class="programlisting">  var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);
  var cube = new THREE.Mesh(cubeGeometry, material);
  scene.add(cube);</pre></div></li><li class="listitem">If you look in the shader code in step 4, you can see that the position is influenced by <a id="id444" class="indexterm"/>the delta uniform value. We use the <code class="literal">render</code> function to pass in a new value for this uniform:<div class="informalexample"><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    uniforms.delta.value += 0.01;
    requestAnimationFrame(render);
  }</pre></div></li></ol></div><p>These are all the steps you need to take to create and use a custom vertex shader combined with a simple fragment shader from Three.js.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec253"/>How it works...</h2></div></div></div><p>Let's look a bit closer at what is happening in the vertex shader used in this recipe. Before we start, we'll give you a very short introduction to the types of qualifiers that you can use with the variables in your shader code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">uniform</code> qualifier: This is a global variable that can be passed in from JavaScript<a id="id445" class="indexterm"/> to the shaders. You can change this value in each rendering loop but can't change the value in the shader itself.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">attribute</code> qualifier: This is a value that can be specified for each individual <a id="id446" class="indexterm"/>vertex. The <code class="literal">attributes</code> qualifier are passed on into the vertex shader.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">varying</code> qualifier: This is used to pass data between the vertex shader and the<a id="id447" class="indexterm"/> fragment shader. It can be written into the vertex shader but can only be read in the fragment shader.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">const</code> qualifier: This is a constant value and is defined directly in your shader code. This <a id="id448" class="indexterm"/>value can't change during the execution of your shaders.</li></ul></div><p>The first thing we do is define some parameters:</p><div class="informalexample"><pre class="programlisting">  varying vec2 vUv;
  uniform float delta;
  uniform float scale;</pre></div><p>The <code class="literal">vUv</code> vector is a varying variable and is a value that is passed into the fragment shader and is required for the basic shader to work in Three.js. The other two parameters are passed in as uniforms<a id="id449" class="indexterm"/> from the JavaScript you saw in the previous <a id="id450" class="indexterm"/>section. Let's look at the main function, which is the function that is exectured for each vertex:</p><div class="informalexample"><pre class="programlisting">  void main() {
    vUv = uv;
    vec3 p = position;
    p.z += sin(2.0 * p.y + delta) * 5.0;
    p.z += cos(2.0 * p.z + delta / 2.0) * 5.0;
    p.z += cos(2.0 * p.x + delta) * 5.0;
    p.x += sin(p.y + delta / 2.0) * 10.0;
    vec4 mvPosition = modelViewMatrix * vec4(scale * p, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
  }</pre></div><p>The main thing that happens here is that we change the position of the vertex based on the passed-in delta and some <code class="literal">sin</code> and <code class="literal">cos</code> functions. The result is that each vertex of our model is displaced in some manner. Finally, we need to set the <code class="literal">gl_Position</code> variable with the new position of our vertex.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec254"/>There's more…</h2></div></div></div><p>When you look for information on custom shaders, you'll most often see examples of fragment shaders. In many use cases, a vertex shader doesn't need to change the positions of the vertices. When it does, it is often for effects such as smoke or fire. There aren't that many good vertex shaders examples out there. The following two sites, however, provide a good starting point if you want to learn more about vertex shaders:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A<a id="id451" class="indexterm"/> good resource to learn more about vertex shaders is the shader tutorial from lighthouse3d at <a class="ulink" href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/">http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/</a></li><li class="listitem" style="list-style-type: disc">There is <a id="id452" class="indexterm"/>also an online vertex shader editor available at kickjs.org, which you can find at <a class="ulink" href="http://www.kickjs.org/example/shader_editor/shader_editor.html">http://www.kickjs.org/example/shader_editor/shader_editor.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec255"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a vertex shader is always accompanied with a fragment shader, it is good to also understand how they work. In the <span class="emphasis"><em>Creating a custom fragment shader</em></span> recipe, we explain the steps you need to take to set up a custom fragment shader.</li></ul></div></div></div>
<div class="section" title="Creating a custom fragment shader"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec76"/>Creating a custom fragment shader</h1></div></div></div><p>A WebGL<a id="id453" class="indexterm"/> shader always consists of two parts: the vertex shader that can be used to reposition the individual vertices of the model and a fragment shader that can be used to add color to the model. In this recipe, we'll show you the steps you need to take to use a custom fragment shader.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec256"/>Getting ready</h2></div></div></div><p>Before we start with the fragment shader, there is one thing you need to know. Just like with a vertex shader, you don't write the fragment shader code in JavaScript. These shaders are written in the GLSL language. So, if you want to learn more about the functions and<a id="id454" class="indexterm"/> notations used in this example, look at the WebGL specification, which can be found at <a class="ulink" href="https://www.khronos.org/registry/webgl/specs/1.0/">https://www.khronos.org/registry/webgl/specs/1.0/</a>. If you want to experiment with the provided shader code, you can just open up <code class="literal">05.10-custom-fragment-shader.html</code> in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_05_12.jpg" alt="Getting ready"/></div><p>This shader colors an object based on the normal vector and on the distance from the camera. In the following sections, we will explain how you can do this.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec257"/>How to do it...</h2></div></div></div><p>Let's<a id="id455" class="indexterm"/> start with the JavaScript part of this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A shader always consists of a vertex shader and a fragment shader. In this recipe, we'll use the standard vertex shader provided by Three.js and provide our own custom fragment shader. Three.js keeps all its shaders in <code class="literal">THREE.ShaderLib</code>:<div class="informalexample"><pre class="programlisting">  var basicShader = THREE.ShaderLib['normal'];</pre></div><p>In step 3, we'll reference this <code class="literal">basicShader</code> object to get the standard vertex shader.</p></li><li class="listitem">For our custom shader, we have some configuration options. These options are passed into a shader using uniforms:<div class="informalexample"><pre class="programlisting">  var uniforms = {};
  uniforms.delta = {type: 'f', value: 0.0};
  uniforms.mNear = { type: "f", value: 1.0 };
  uniforms.mFar = { type: "f", value: 60.0 };</pre></div><p>This means that in our shader code, we can access the <code class="literal">delta</code>, <code class="literal">mNear</code>, and <code class="literal">mFar</code> values, all of which are floating point values, and we can use them to calculate the colors we want to render.</p></li><li class="listitem">Next, we can create the shader material:<div class="informalexample"><pre class="programlisting">  var material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: basicShader.vertexShader,
    fragmentShader: document getElementById('simple-fragment').text,
  });</pre></div><p>In the configuration of <code class="literal">THREE.ShaderMaterial</code>, we reference our <code class="literal">uniform</code> variable, the standard vertex shader, <code class="literal">basicShader.vertexShader</code> provided by Three.js, and our own custom fragment shader. We'll show you the definition of our custom shader in step 5.</p></li><li class="listitem">The last thing we need to do is create <code class="literal">THREE.BoxGeometry</code> and add it to the scene using the material created in the previous step:<div class="informalexample"><pre class="programlisting">  var boxGeometry = new THREE.BoxGeometry(5, 15, 5);
  var box = new THREE.Mesh(boxGeometry, material);
  scene.add(box);</pre></div></li><li class="listitem">In<a id="id456" class="indexterm"/> step 3, we referenced a DOM element with the simple-fragment name. In your HTML page, you should define it like this:<div class="informalexample"><pre class="programlisting">  &lt;script id="simple-fragment" type="x-shader/x-fragment"&gt;
    varying vec3 vNormal;
    uniform float delta;
    uniform float mNear;
    uniform float mFar;
    const float PI = 3.14159265358979323846264;
    void main()
    {
      float depth = gl_FragCoord.z / gl_FragCoord.w;
      float depthColor = smoothstep( mNear, mFar, depth );
      gl_FragColor = vec4(abs(sin(delta + 0.7*PI) + cos(normalize(vNormal).x)/2.0) - depthColor,abs(sin(delta + 1.0*PI) + cos(normalize(vNormal).y)/2.0) - depthColor,abs(sin(delta + 1.2*PI) + cos(normalize(vNormal).z)/2.0) – depthColor, 1.0);
    }
  &lt;/script&gt;</pre></div><p>If you want to know more about how this fragment shader works, look at the explanation in the <span class="emphasis"><em>How it works...</em></span> section of this recipe.</p></li><li class="listitem">If you've looked at the example from the <span class="emphasis"><em>Getting ready</em></span> section, you can see that the colors change constantly. This happens because we update the delta property, which is passed into our custom shader, in the <code class="literal">render</code> loop of this page:<div class="informalexample"><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
<span class="strong"><strong>    uniforms.delta.value += 0.005;</strong></span>
    requestAnimationFrame(render);
  }</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec258"/>How it works...</h2></div></div></div><p>To understand how this shader works, let's look through the code step by step. Let's start by looking at the variables used in this shader:</p><div class="informalexample"><pre class="programlisting">  varying vec3 vNormal;
  uniform float delta;
  uniform float mNear;
  uniform float mFar;
  float PI = 3.14159265358979323846264;</pre></div><p>The <code class="literal">vNormal</code> object is a variable that is passed in from the standard Three.js vertex shader and contains<a id="id457" class="indexterm"/> the value of the normal vector applicable to <a id="id458" class="indexterm"/>this fragment. The three uniform values are passed in from the JavaScript, as we've seen in the previous section. The PI variable is a constant that doesn't change over time. Each fragment shader should set the <code class="literal">gl_fragColor</code> vector, which determines the color and opacity of each fragment. For this shader, we set the vector as follows:</p><div class="informalexample"><pre class="programlisting">    void main()
    {
      float depth = gl_FragCoord.z / gl_FragCoord.w;
      float depthColor = smoothstep( mNear, mFar, depth );
      gl_FragColor = vec4(
        abs(sin(delta + 0.7*PI) + cos(normalize(vNormal).x)/2.0) – depthColor ,abs(sin(delta + 1.0*PI) + cos(normalize(vNormal).y)/2.0) – depthColor, abs(sin(delta + 1.2*PI) + cos(normalize(vNormal).z)/2.0) – depthColor, 1.0);
    }</pre></div><p>Without going into too many GLSL details, roughly the following steps are taken:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we determine the depth of this fragment. You can see this as the distance of this fragment from the camera.</li><li class="listitem">As depth is an absolute value, we convert it to a scale of <code class="literal">0</code> to <code class="literal">1</code> using the <code class="literal">smoothstep</code> function. As this function also takes the <code class="literal">mNear</code> and <code class="literal">mFar</code> uniforms<a id="id459" class="indexterm"/> as its parameters, we can control how much the depth affects the color of a fragment from JavaScript.</li><li class="listitem">Finally, we define the color of the fragment by setting <code class="literal">gl_FragColor</code>. The <code class="literal">gl_FragColor</code> variable is of type <code class="literal">vec4</code>, where the first three values determine the RGB value of the color and the last one defines the opacity. This is all on a scale of <code class="literal">0</code> to <code class="literal">1</code>. For each part of the color, we use a function that includes the <code class="literal">vNormal</code> vector and calculated <code class="literal">depthColor</code> variable to generate a color.</li></ol></div><p>This is just the tip of the iceberg of what you can do with custom fragment shaders. In the upcoming section, you can find some resources to learn more about this.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec259"/>There's more…</h2></div></div></div><p>Creating custom fragment shaders is rather difficult. It'll take a lot of experimenting, a good grasp of math, and a lot of patience. There are, however, a number of resources available <a id="id460" class="indexterm"/>that can help you understand fragment shaders and learn from the work of others:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lots <a id="id461" class="indexterm"/>of fragment shaders can be found at <a class="ulink" href="http://glslsandbox.com/">http://glslsandbox.com/</a></li><li class="listitem" style="list-style-type: disc">On the<a id="id462" class="indexterm"/> Shadertoy site, you can experiment fragment shaders using different kinds of input: <a class="ulink" href="https://www.shadertoy.com/">https://www.shadertoy.com/</a></li><li class="listitem" style="list-style-type: disc">A <a id="id463" class="indexterm"/>simple online shader editor can be found at <a class="ulink" href="http://shdr.bkcore.com/">http://shdr.bkcore.com/</a></li></ul></div><p>Another great help can be the latest version of Firefox Dev Tools. This is a special version of Firefox, which provides great debugging support and even includes a shader editor that you can use to edit a shader program and directly see the results. You can download this<a id="id464" class="indexterm"/> version from <a class="ulink" href="https://www.mozilla.org/en-US/firefox/developer/">https://www.mozilla.org/en-US/firefox/developer/</a>.</p><p>There is, of course, the<a id="id465" class="indexterm"/> khronos website (<a class="ulink" href="http://www.khronos.org">http://www.khronos.org</a>), which is a great resource to find out what a specific function actually does.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec260"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a fragment shader is always accompanied with a vertex shader, it is good to also understand how they work. In the <span class="emphasis"><em>Creating a custom vertex shader</em></span> recipe, we explained the steps you need to take to set up a custom vertex shader.</li></ul></div></div></div></body></html>