- en: Building a Typical Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建典型的Web API
- en: Our first draft API will be a read-only version and will not support creating
    or updating items in the catalog as real-world applications do. Instead, we will
    concentrate on the API definition itself, and will worry about data storage later
    on. Of course, using file storage for data exposed to millions of users is anything
    but an option, so a database layer will be provided to our application further
    in the book, after we have looked into modern NoSQL database solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一版API将是一个只读版本，并且不会支持创建或更新目录中的项目，就像现实世界的应用那样。相反，我们将专注于API定义本身，并在稍后考虑数据存储。当然，使用文件存储向数百万用户公开的数据绝对不是一种选择，因此本书稍后将为我们的应用程序提供一个数据库层，在研究了现代NoSQL数据库解决方案之后。
- en: We will also cover the topic of content negotiation, a mechanism that allows
    consumers to specify the expected format of requested data. Finally, we will take
    a look at several ways to expose different versions of a service, in case it evolves
    in a backward-incompatible way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖内容协商这一主题，这是一种机制，允许消费者指定请求数据的预期格式。最后，我们将探讨几种公开服务不同版本的方法，以防服务以不向后兼容的方式发展。
- en: 'To sum up, in this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，你将学习以下内容：
- en: How to specify a web API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何指定Web API
- en: How to implement routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现路由
- en: How to query your API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询API
- en: Content negotiation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商
- en: API versioning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: After this chapter, you should be able to completely specify a RESTful API and
    will be almost ready to start implementing real-life Node.js RESTful services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你应该能够完全指定一个RESTful API，并将几乎准备好开始实现实际的Node.js RESTful服务。
- en: Specifying the API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定API
- en: 'The very first thing a project usually starts with is a definition of the operations
    the API will expose. According to the REST principles, an operation is exposed
    by an HTTP method and a URI. The action performed by each operation should not
    contradict the natural meaning of its HTTP method. The following table specifies
    the operations of our API in detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目通常从定义API将要公开的操作开始。根据REST原则，操作通过HTTP方法和URI来暴露。每个操作执行的动作不应与其HTTP方法的自然含义相矛盾。以下表格详细说明了我们API的操作：
- en: '| **Method** | **URI** | **Description** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URI** | **描述** |'
- en: '| `GET` | `/category` | Retrieves all available categories in the catalog.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/category` | 获取目录中所有可用的类别。|'
- en: '| `GET` | `/category/{category-id}/` | Retrieves all the items available under
    a specific category. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/category/{category-id}/` | 获取特定类别下所有可用的项目。|'
- en: '| `GET`  |  `/category/{category-id}/{item-id}`  | Retrieves an item by its
    ID under a specific category. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `GET`  |  `/category/{category-id}/{item-id}`  | 通过其ID检索特定类别中的项目。|'
- en: '| `POST` | `/category` | Creates a new category; if it exists, it will update
    it. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/category` | 创建一个新的类别；如果它存在，则更新它。|'
- en: '| `POST`  | `/category/{category-id}/`  | Creates a new item in a specified
    category. If the item exists, it will update it. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `POST`  | `/category/{category-id}/`  | 在指定的类别中创建一个新的项目。如果项目存在，则更新它。|'
- en: '| `PUT`  |  `/category/{category-id}`  | Updates a category. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `PUT`  |  `/category/{category-id}`  | 更新类别。|'
- en: '| `PUT` | `/category/{category-id}/{item-id}` | Updates an item in a specified
    category. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/category/{category-id}/{item-id}` | 更新指定类别中的项目。|'
- en: '| `DELETE` | `/category/{category-id}` | Deletes an existing category. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/category/{category-id}` | 删除现有的类别。|'
- en: '| `DELETE` | `/category/{category-id}/{item-id}` | Deletes an item in a specified
    category. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/category/{category-id}/{item-id}` | 删除指定类别中的项目。|'
- en: 'The second step is to choose an appropriate format for our catalog application''s
    data. JSON objects are natively supported by JavaScript. They are easy to extend
    during the evolution of an application and are consumable by almost any platform
    available. Thus, the JSON format seems to be our logical choice for us. Here is
    the JSON representation of an item, and category objects that will be used throughout
    this book:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是选择适合我们的目录应用程序数据的适当格式。JSON对象是JavaScript的原生支持。它们在应用程序的演变过程中易于扩展，并且几乎可以被任何平台消费。因此，JSON格式似乎是我们逻辑上的选择。以下是本书中将使用的项目对象和类别对象的JSON表示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far, our API has defined a set of operations and the data format to be used.
    The next step is to implement a  module that will export functions serving each
    of the operations in the route.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的API已经定义了一组操作和要使用的数据格式。下一步是实现一个模块，该模块将导出函数，为路由中的每个操作提供服务。
- en: To begin with, let's create a new Node.js Express project. Select a directory
    where your projects will be stored and from your shell Terminal, execute `express
    chapter3`. If you are using Windows, you will need to install the `express-generator`
    module before generating the project. The `express-generator` will create your
    an initial express project layout in the selected directory. This layout provides
    the default project structure for you, ensuring that your Express project follows
    the standard project structure. It makes your project easier to navigate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的Node.js Express项目。选择一个存储你项目的目录，然后在你的shell终端中执行`express chapter3`。如果你使用的是Windows，在生成项目之前你需要安装`express-generator`模块。`express-generator`将在所选目录中创建一个初始的Express项目布局。这个布局为你提供了默认的项目结构，确保你的Express项目遵循标准的项目结构。这使得你的项目更容易导航。
- en: The next step is to import the project into the Atom IDE. Right-click anywhere
    in the Projects tab and select Add project folder then select the directory Express
    generated for you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将项目导入到Atom IDE中。在项目标签页的任何位置右键单击，然后选择“添加项目文件夹”，然后选择Express为你生成的目录。
- en: 'As you can see, Express has done some background work for us and has created
    a starting point for our application: `app.js`. It has also created the `package.json`
    file for us. Let''s take a look at each of these files, starting with `package.json`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Express已经为我们做了一些后台工作，并为我们的应用程序创建了一个起点：`app.js`。它还为我们创建了一个`package.json`文件。让我们看看这些文件中的每一个，从`package.json`开始：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we created a blank Node.js Express project, we initially have dependencies
    only to the Express framework, some middleware modules such as `morgan`, `body-parser`,
    and `cookie-parser`, and the Jade template language. Jade is a straightforward
    template language used to produce HTML code inside templates. If you are interested
    in it, you can find out more about it at [http://www.jade-lang.com](http://www.jade-lang.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了一个空的Node.js Express项目，我们最初只依赖Express框架，一些中间件模块如`morgan`、`body-parser`和`cookie-parser`，以及Jade模板语言。Jade是一种简单的模板语言，用于在模板中生成HTML代码。如果你对此感兴趣，你可以在[http://www.jade-lang.com](http://www.jade-lang.com/)了解更多信息。
- en: The current version of the Express framework at the time of writing is 4.16.1;
    to update it, execute `npm install express@4.16.1 --save` from the `chapter3`
    directory. This command will update the dependency of the application to the desired
    version. The `--save` option will update and save the new version of the dependency
    in the project's `package.json` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时Express框架的当前版本是4.16.1；要更新它，请在`chapter3`目录中执行`npm install express@4.16.1 --save`命令。此命令将更新应用程序的依赖项到所需版本。`--save`选项将更新并保存依赖项的新版本到项目的`package.json`文件中。
- en: When you introduce new module dependencies, it is up to you to keep the `package.json`
    file up to date in order to maintain an accurate state of the modules your application
    depends on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引入新的模块依赖项时，你需要自己确保`package.json`文件保持最新，以维护应用程序依赖的模块的准确状态。
- en: We will come to what middleware modules are a bit later in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论中间件模块是什么。
- en: For now, we will ignore the content of the `public` and `view` directories as
    it is not relevant to our RESTful service. They contain the auto-generated stylesheets
    and template files that might be helpful, if we decide to develop a web-based
    consumer of the services at a later stage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将忽略`public`和`view`目录的内容，因为它们与我们当前的RESTful服务无关。这些目录包含可能在我们决定稍后开发基于Web的服务消费者时有所帮助的自动生成的样式表和模板文件。
- en: 'We''ve already mentioned that the Express project created a starting point
    for our web application in `app.js`. Let''s take a deeper look at it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，Express项目在`app.js`中为我们的Web应用程序创建了一个起点。让我们更深入地看看它：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Obviously, the Express generator has done a lot for us as it has instantiated
    the Express framework and has assigned a complete development environment around
    it. It has done the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Express生成器为我们做了很多工作，因为它实例化了Express框架，并围绕它分配了一个完整的发展环境。它做了以下几件事：
- en: Configured the middleware to be used in our application, `body-parser`, the
    default router, as well as error handler middleware for our development environment
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了要在我们的应用程序中使用的中间件，`body-parser`、默认的路由器以及开发环境中的错误处理中间件
- en: Injected a logger instance of the morgan middleware module
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入了一个morgan中间件模块的日志实例
- en: Configured the Jade template, as it has been selected as the default template
    for our application
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了Jade模板，因为它已被选为我们的应用程序的默认模板
- en: Configured the default URI that our Express application will be listening to, `/`
    and `/users`, and created dummy handle functions for them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了我们的Express应用程序将监听的默认URI，`/`和`/users`，并为它们创建了虚拟处理函数。
- en: You will have to install all the modules used in `app.js` in order to start
    the generated application successfully. Also, make sure you update the dependencies
    of your `package.json` file using the `--save` option after installing them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功启动生成的应用程序，您必须安装`app.js`中使用的所有模块。此外，在安装它们后，请确保使用`--save`选项更新您的`package.json`文件的依赖项。
- en: 'The Express generator also created a starting script for the application. It
    is under the  `bin/www`directory of your project and looks like the following
    snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Express生成器还为您创建了一个启动脚本。它位于项目的`bin/www`目录下，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To start the application, execute `node bin/www`; this will execute the script
    above and will start the Node.js application. So requesting `http://localhost:3000`
    in your browser will result in calling the default `GET` handler, which gives
    a warm welcome response:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请执行`node bin/www`；这将执行上面的脚本并启动Node.js应用程序。因此，在浏览器中请求`http://localhost:3000`将导致调用默认的`GET`处理程序，它将返回一个欢迎响应：
- en: '![](img/24aad7c8-9bf3-4b2e-8b01-6d47d0b6e8ba.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24aad7c8-9bf3-4b2e-8b01-6d47d0b6e8ba.png)'
- en: Default welcome message from an Express application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Express应用程序的默认欢迎消息
- en: 'The generator created a dummy `routes/users.js`; it exposes a route linked
    to a dummy module available at the `/users` location. Requesting it will result
    in calling the `list` function of the user''s route, which outputs a static response:
    `respond with a resource`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器创建了一个虚拟的`routes/users.js`；它暴露了一个与位于`/users`位置的虚拟模块相关联的路由。请求它将导致调用用户路由的`list`函数，该函数输出一个静态响应：“响应资源”。
- en: 'Our application will not be using a template language and style sheets, so
    let''s get rid of the lines that set the views and view engine properties in the
    application configuration. In addition, we will be implementing our own routes.
    Thus, we don''t need the binding of the `/` and `/users` URIs for our app, neither
    do we need the `user` module; instead, we will utilize a `catalog` module and
    from a route:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将不会使用模板语言和样式表，因此让我们删除设置应用程序配置中视图和视图引擎属性的行。此外，我们将实现自己的路由。因此，我们不需要为我们的应用程序绑定`/`和`/users`
    URI，也不需要`user`模块；相反，我们将利用一个`catalog`模块，并从路由：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So after this cleanup, our application looks a lot cleaner and we are ready
    to move forward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过这次清理后，我们的应用程序看起来干净多了，我们准备继续前进。
- en: 'Before doing that, though, there is one term that needs further explanation:
    middleware. It is a subset of chained functions called by the `Еxpress.js` routing
    layer before а user-defined handler is invoked. Middleware functions have full
    access to the `request` and `response` objects and can modify either of them.
    The middleware chain is always called in the exact order in which it has been
    defined, so it is vital for you to know exactly what a specific piece of middleware
    is doing. Once a middleware function finishes, it calls the next function in the
    chain by invoking its next argument as a function. After the complete chain gets
    executed, the user-defined request handler is called.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在做那之前，尽管如此，有一个术语需要进一步解释：中间件。它是在调用用户定义的处理程序之前，由`Express.js`路由层调用的链式函数的子集。中间件函数可以完全访问`request`和`response`对象，并且可以修改它们中的任何一个。中间件链总是按照定义的顺序调用，因此了解特定中间件的具体操作至关重要。一旦中间件函数完成，它将通过将其下一个参数作为函数调用，来调用链中的下一个函数。在执行完整个链之后，将调用用户定义的请求处理程序。
- en: 'Here are the basic rules that apply to the middleware chain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是适用于中间件链的基本规则：
- en: 'A middleware function has the following signature: `function (request, response, next)`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件函数具有以下签名：`function (request, response, next)`。
- en: Middleware functions are executed in the exact order in which they have been
    added to the application chain. This means that if you want your middleware function
    to be called before a specific route, you need to add it before declaring the
    route.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件函数是按照它们添加到应用程序链中的顺序执行的。这意味着，如果您希望您的中间件函数在特定路由之前被调用，您需要在其声明路由之前添加它。
- en: Middleware functions use their third parameter, `next`, as a function to indicate
    that they have completed their work and to exit. When the `next()` parameter of
    the last function in the chain has been called, the chained execution is completed
    and the `request` and the `response` objects reach the defined handlers, in the
    state set by the middleware.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件函数使用它们的第三个参数`next`作为一个函数来指示它们已完成工作并退出。当链中最后一个函数的`next()`参数被调用时，链式执行完成，`request`和`response`对象达到由中间件设置的状态，并传递给定义的处理程序。
- en: Now that we know what a middleware function is, let's clarify what the currently
    used middleware functions provide our application with. The `body-parser` middleware
    is the Express framework built in a parser. It parses the `request` body and populates
    the `request` object after the middleware execution finishes, that is, it provides
    JSON payload handling.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了中间件函数是什么，让我们明确一下当前使用的中间件函数为我们应用提供了什么。`body-parser`中间件是Express框架内置的解析器。它在中间件执行完成后解析`request`体，并填充`request`对象，即它提供了JSON有效负载处理。
- en: 'Now it is time to move on and implement our user module that will be mapped
    to our URIs. The module will be named `modules/catalog.js`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候继续前进并实现我们的用户模块，该模块将被映射到我们的URI上。该模块将被命名为`modules/catalog.js`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The catalog module is built around the `catalog.json` file, stored in the `data`
    directory. The content of the source file is read synchronously using the File
    System module, `fs`, within the `readCatalogSync` function. The File System module
    provides multiple useful filesystem operations such as functions for creating,
    renaming, or deleting files or directories; truncating; linking; `chmod` functions;
    as well as synchronous and asynchronous file access for reading and writing data.
    In our sample application, we aim to use the most straightforward approach, so
    we implement functions that read the `catalog.json` file by utilizing the `readFileSync`
    function of the File System module. It returns the content of a file as a string,
    within a synchronous call. All other functions of the module are exported and
    can be used to query the content of the source file, based on different criteria.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目录模块是围绕存储在`data`目录中的`catalog.json`文件构建的。源文件的内容是通过`readCatalogSync`函数中的文件系统模块`fs`同步读取的。文件系统模块提供了多种有用的文件系统操作，例如创建、重命名或删除文件或目录的函数；截断；链接；`chmod`函数；以及同步和异步文件访问以读取和写入数据。在我们的示例应用中，我们旨在使用最直接的方法，因此我们实现了利用文件系统模块的`readFileSync`函数读取`catalog.json`文件的函数。它在一个同步调用中返回文件的内容，作为字符串。模块中的所有其他函数都导出，可以根据不同的标准查询源文件的内容。
- en: 'The catalog module exports the following functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目录模块导出以下函数：
- en: '`findCategories`: This returns an array of JSON objects containing all the
    categories in the `catalog.json` file'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findCategories`: 这个函数返回一个包含`catalog.json`文件中所有类别的JSON对象数组'
- en: '`findItems (categoryId)`: This returns an array JSON objects representing all
    the items in a given category'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findItems (categoryId)`: 这个函数返回一个表示给定类别中所有项目的JSON对象数组'
- en: '`findItem(categoryId, itemId)`: This returns a JSON object representing a single
    item in a given category'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findItem(categoryId, itemId)`: 这个函数返回一个表示给定类别中单个项目的JSON对象'
- en: Now that we have three complete functions, let's see how to bind them to our
    Express application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了三个完整的函数，让我们看看如何将它们绑定到我们的Express应用中。
- en: Implementing routes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现路由
- en: 'In Node.js terms, a route is a binding between a URI and function. The Express
    framework provides built-in support for routing. An `express` object instance
    contains functions named after each HTTP verb: `get`, `post`, `put`, and `delete`.
    They have the following syntax: `function(uri, handler);`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js术语中，路由是一个URI和函数之间的绑定。Express框架提供了内置的路由支持。一个`express`对象实例包含以每个HTTP动词命名的函数：`get`、`post`、`put`和`delete`。它们的语法如下：`function(uri,
    handler);`。
- en: 'They are used to bind a handler function to a specific HTTP action executed
    over a URI. The handler function usually takes two arguments: `request` and `response`.
    Let''s see it with a simple `Hello route` application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于将处理函数绑定到在URI上执行的具体HTTP操作。处理函数通常接受两个参数：`request`和`response`。让我们通过一个简单的`Hello
    route`应用来看看它：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this sample at localhost and accessing `http://localhost:3000/hello`
    will result in calling your handler function and it will respond saying `Hello
    route`, but routing can give you much more. It allows you to define a URI with
    parameters; for example, let''s use `/hello/:name` as a routing string. It tells
    the framework that the URI used consists of two parts: a static part (`hello`)
    and a variable part (the `name` parameter).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地主机上运行此示例并访问 `http://localhost:3000/hello` 将导致调用您的处理函数，并响应说 `Hello route`，但路由可以为您提供更多功能。它允许您定义带有参数的
    URI；例如，让我们使用 `/hello/:name` 作为路由字符串。它告诉框架所使用的 URI 由两部分组成：一个静态部分（`hello`）和一个变量部分（`name`
    参数）。
- en: 'Furthermore, when the routing string and the handler function are defined in
    line with the `get` function of an Express instance, a parameter collection is
    made available directly in the `request` argument of the handler function. To
    demonstrate this, let''s modify our previous example a bit:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当路由字符串和处理函数与 Express 实例的 `get` 函数定义一致时，参数集合将直接在处理函数的 `request` 参数中可用。为了演示这一点，让我们稍微修改一下之前的示例：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code snippet, we used a colon (`:`) to separate
    the parameter part of the URI from the static part. You can have multiple parameters
    in an Express route; for example, `/category/:category-id/items/:item-id`defines
    a route for displaying an item that belongs to a category, where the `category-id`
    and `item-id` are parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们使用冒号 (`:`) 来分隔 URI 的参数部分和静态部分。在 Express 路由中可以有多个参数；例如，`/category/:category-id/items/:item-id`
    定义了一个用于显示属于某个类别的项目的路由，其中 `category-id` 和 `item-id` 是参数。
- en: 'Now let''s try it out. Requesting `http://localhost:3000/hello/friend` will
    result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试试。请求 `http://localhost:3000/hello/friend` 将导致以下输出：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is how we can provide parameterized URIs with Express. It is a nice feature,
    but it is often not enough. In web applications, we are used to providing additional
    parameters with `GET` parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以如何使用 Express 提供参数化 URI 的方法。这是一个很好的功能，但通常还不够。在 Web 应用程序中，我们习惯于使用 `GET`
    参数提供额外的参数。
- en: 'Unfortunately, the Express framework is not so good with `GET` parameters.
    Thus, we have to utilize the `url` module. It is built into Node.js to provide
    an easy way of using URL parsing. Let''s use our `hello` result with other parameters
    in the application again, but extend it in a way that it outputs `hello all` when
    `/hello` is requested and `hello friend` when the requested URI is `/hello?name=friend`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Express 框架在处理 `GET` 参数方面并不出色。因此，我们必须利用 `url` 模块。它是 Node.js 内置的，提供了一种使用
    URL 解析的简单方法。让我们再次使用我们的 `hello` 结果，并在应用程序中用其他参数扩展它，使其在请求 `/hello` 时输出 `hello all`，当请求的
    URI 是 `/hello?name=friend` 时输出 `hello friend`：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a few things worth mentioning here. We used the `url` module's function
    `parse`. It takes a URL as its first argument and a Boolean as an optional second
    argument, which specifies whether the query string should be parsed or not. The
    `url.parse` function returns an associative object. We used `Object.keys` with
    it to transform the keys in these associative objects into an array so that we
    can check its length. This will help us check whether our URI has been called
    with `GET` parameters or not. In addition to the routing functions named after
    each HTTP verb, there is also a function named `all`. When used, it routes all
    the HTTP actions to the specified URI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得注意的事情。我们使用了 `url` 模块的 `parse` 函数。它接受一个 URL 作为其第一个参数，并接受一个布尔值作为可选的第二个参数，该参数指定是否应该解析查询字符串。`url.parse`
    函数返回一个关联对象。我们使用 `Object.keys` 与它一起使用，将关联对象中的键转换为数组，以便我们可以检查其长度。这将帮助我们检查我们的 URI
    是否带有 `GET` 参数。除了以每个 HTTP 动词命名的路由函数外，还有一个名为 `all` 的函数。当使用时，它将所有 HTTP 动作路由到指定的 URI。
- en: Now that we know how routing and the `GET` parameters work within Node.js and
    the Express environment, we are ready to define a route for the `catalog` module
    and bind it in our application. The following is the route as defined in `routes/catalog.js`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在 Node.js 和 Express 环境中路由和 `GET` 参数是如何工作的，我们准备为 `catalog` 模块定义一个路由并将其绑定到我们的应用程序中。以下是在
    `routes/catalog.js` 中定义的路由。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, a `Router` instance is created from the Express module. Here is a table
    that nicely describes the routing we just implemented. This will be helpful later
    when we test our API:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 Express 模块创建一个 `Router` 实例。以下是一个很好地描述了我们刚刚实现的路由的表格。这将在我们稍后测试我们的 API 时很有帮助：
- en: '| **HTTP method** | **Route** | **Catalog''s module function** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 方法** | **路由** | **目录模块函数** |'
- en: '| `GET` | `/catalog` | `findCategories()` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/catalog` | `findCategories()` |'
- en: '| `GET` | `/catalog/:categoryId` | `findItems(categoryId)`  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/catalog/:categoryId` | `findItems(categoryId)`  |'
- en: '| `GET` | `/catalog/:categoryId/:itemId` | `findItem(categoryId, itemId)`  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/catalog/:categoryId/:itemId` | `findItem(categoryId, itemId)`  |'
- en: Querying the API using test data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试数据查询 API
- en: We need some test data in order to test our service, so let's use the `catalog.json`
    file in the `data` directory of our project. This data will allow us to test all
    our three functions, but to do that, we would need a client that can send REST
    requests against an endpoint. If you still haven't created a Postman project for
    testing your application, now is an appropriate time to create it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些测试数据来测试我们的服务，因此让我们使用项目 `data` 目录下的 `catalog.json` 文件。这些数据将允许我们测试所有三个功能，但为了做到这一点，我们需要一个能够向端点发送
    REST 请求的客户端。如果你还没有为测试应用程序创建 Postman 项目，现在是创建它的合适时机。
- en: 'Requesting `/catalog` should return all the categories in the `test` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 `/catalog` 应返回 `test` 文件中的所有类别：
- en: '![](img/beefd605-bf6b-4ab7-aa35-58d6c3f95993.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beefd605-bf6b-4ab7-aa35-58d6c3f95993.png)'
- en: 'Thus, requesting `/catalog/1` should result in returning a list with all the
    items under the `Watches` category:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请求 `/catalog/1` 应该返回包含 `Watches` 类别下所有项目的列表：
- en: '![](img/c351f2a1-0fc3-4b5e-94a8-ffe16d6c93d6.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c351f2a1-0fc3-4b5e-94a8-ffe16d6c93d6.png)'
- en: 'Finally, requesting `http://localhost:3000/catalog/1/item-identifier-1` would
    display only the item identified by `item-identifier-1`, and requesting a nonexistent
    item would result in response with status code `404`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请求 `http://localhost:3000/catalog/1/item-identifier-1` 将仅显示由 `item-identifier-1`
    标识的项目，请求不存在的项目将导致状态码为 `404` 的响应：
- en: '![](img/001e4cab-3ebc-4c40-a1b3-00552b89ac3a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/001e4cab-3ebc-4c40-a1b3-00552b89ac3a.png)'
- en: Content negotiation
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容协商
- en: So far, the catalog service supports only the JSON format, and thus works only
    with the media type `application/json`. Let's assume our service has to offer
    data in different formats, for example, both JSON and XML. Then, the consumer
    needs to explicitly define the data format they need. The best way to carry out
    content negotiation in REST has been a very debatable subject for a long time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，目录服务只支持 JSON 格式，因此只能与媒体类型 `application/json` 一起工作。假设我们的服务必须以不同的格式提供数据，例如，JSON
    和 XML。那么，消费者需要明确定义他们需要的数据格式。在 REST 中执行内容协商的最佳方式长期以来一直是一个非常有争议的话题。
- en: 'In his famous discussion on implementing content negotiation correctly, Roy
    Fielding states the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于正确实现内容协商的著名讨论中，Roy Fielding 提出了以下观点：
- en: All important resources must have URIs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有重要的资源都必须有 URI。
- en: 'However, that leaves a gap on how to expose the same resource in a different
    data format, so Roy continues with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这留下了一个如何以不同数据格式公开相同资源的空白，因此 Roy 继续以下观点：
- en: Agent-driven negotiation is far more effective, but there was a huge disagreement
    between myself and the chair of the HTTP working group and my original agent-driven
    design for HTTP/1.1 was effectively buried in committee. To do negotiation right,
    the client needs to be aware of all the alternatives and what it should use as
    a bookmark.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代理驱动协商更为有效，但我在 HTTP 工作组主席和我最初为 HTTP/1.1 设计的代理驱动协商之间有很大的分歧，我的原始代理驱动设计实际上被委员会埋没了。为了正确进行协商，客户端需要了解所有替代方案以及它应该用作书签的内容。
- en: While one can still choose to stick with a URI-driven negotiation by providing
    the desired format with custom `GET` parameters, the REST community has chosen
    to stick to Roy's suggestion for agent-driven negotiation. Now that it has been
    almost a decade since this argument was initiated, it has been proven that they
    took the right decision. Agent-driven negotiation makes use of the `Accept` HTTP
    header.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然人们仍然可以选择通过提供自定义 `GET` 参数来保持 URI 驱动的协商，但 REST 社区已经选择了坚持 Roy 的代理驱动协商建议。现在，自从这个论点被提出以来已经近十年，已经证明他们做出了正确的决定。代理驱动协商利用了
    `Accept` HTTP 头部。
- en: The `Accept` HTTP header specifies the media type of the resource that the consumer
    is willing to process. In addition to the `Accept` header, the consumer may also
    make use of the `Accept-Language` and `Accept-Encoding` headers to specify what
    language and encoding the results should be provided in. If the server fails to
    provide the results in the expected format, it can either return a default value
    or make use of `HTTP 406 Not acceptable` in order not to cause data confusion
    errors on the client side.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Accept` HTTP头指定了消费者愿意处理的资源的媒体类型。除了`Accept`头之外，消费者还可以使用`Accept-Language`和`Accept-Encoding`头指定结果应提供什么语言和编码。如果服务器无法以预期的格式提供结果，它可以选择返回默认值或使用`HTTP
    406 Not acceptable`，以避免在客户端引起数据混淆错误。'
- en: 'The Node.js HTTP `response` object contains a method, `format`, that performs
    content negotiation based on the `Accept` HTTP header if set in the `request`
    object. It uses the built-in `request.accepts()` to select an appropriate handler
    for the request. If that is not found, the server invokes the default handler,
    which responds with `HTTP 406 Not acceptable`. Let''s create a demo on how to
    use the `format` method within one of our routes. For that purpose, let''s assume
    we have implemented a function within our `catalog` module, named `list_groups_in_xml`,
    that provides the group data in XML format:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js HTTP `response`对象包含一个名为`format`的方法，该方法根据在`request`对象中设置的`Accept` HTTP头执行内容协商。它使用内置的`request.accepts()`来选择适当的请求处理器。如果没有找到，服务器将调用默认处理器，并以`HTTP
    406 Not acceptable`响应。让我们创建一个演示，说明如何在我们的路由之一中使用`format`方法。为此，让我们假设我们在`catalog`模块中实现了一个名为`list_groups_in_xml`的函数，该函数以XML格式提供组数据：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is how you can implement content negotiation in a clear and straightforward
    way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何以清晰直接的方式实现内容协商。
- en: API versioning
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本化
- en: It is an inevitable fact that all application APIs evolve. However, the evolution
    of public APIs with an unknown number of consumers, such as RESTful services,
    is a sensitive topic. As consumers may not be able to handle the modified data
    appropriately and there is no way of notifying all of them, we need to keep our
    APIs as backward-compatible as possible. One way to do so is to use different
    URIs for different versions of our application. Currently, our catalog API is
    available at `/catalog`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序API的演变是一个不可避免的事实。然而，具有未知数量消费者的公共API（如RESTful服务）的演变是一个敏感话题。因为消费者可能无法适当地处理修改后的数据，而且无法通知他们所有人，所以我们需要尽可能保持我们的API向后兼容。这样做的一种方法是为我们应用程序的不同版本使用不同的URI。目前，我们的目录API可在`/catalog`处访问。
- en: When the time is right for a new version, for example, Version 2, we may need
    to keep the previous version available at another URI for backward-compatibility.
    Best practice is to encode the version number in the URI, such as `/v1/catalog`,
    and keep `/catalog` mapped to the latest version. Thus, requesting `/catalog`
    will cause a redirect to `/v2/catalog` and will make use of the HTTP `3xx` status
    codes to indicate the redirection to the latest version.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当推出新版本（例如，版本2）的时机成熟时，我们可能需要将旧版本保留在另一个URI上以保持向后兼容。最佳实践是将版本号编码在URI中，例如`/v1/catalog`，并将`/catalog`映射到最新版本。因此，请求`/catalog`将导致重定向到`/v2/catalog`，并使用HTTP
    `3xx`状态码来指示重定向到最新版本。
- en: Another option for versioning would be to keep the URI of your API stable and
    rely on custom HTTP headers that will specify the version. But that's not very
    stable approach concerning backward-compatibility as it is much more natural to
    modify a URL of a request in an application rather than modify the headers that
    are sent within the request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种版本化的选择是保持API的URI稳定，并依赖于指定版本的定制HTTP头。但这种方法在向后兼容性方面并不稳定，因为修改应用程序中请求的URL比修改请求中发送的头部更自然。
- en: Self-test questions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'To get additional confidence, go through this set of statements and state whether
    they are true or false:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得额外的信心，请通过这一系列陈述并声明它们是正确还是错误：
- en: A REST-enabled endpoint must support all HTTP methods relevant to the REST principles
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个启用了REST的端点必须支持与REST原则相关的所有HTTP方法
- en: When content negotiation fails, due to an unsupported media type passed as a
    value of the accepts header, 301 is the appropriate status code.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当内容协商失败时，由于传递给`Accept`头部的值中包含不支持的媒体类型，301是适当的响应状态码。
- en: When using parameterized routes, the developer can specify the type of the parameter,
    for example, whether it is a numeric or a literal type.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用参数化路由时，开发者可以指定参数的类型，例如，它是一个数字类型还是一个字面量类型。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into some more complex topics. Let's sum up what we
    covered. We started by specifying the operations of our web API and defined that
    an operation is a combination of a URI and HTTP action. Next, we implemented routes
    and bound them to an operation. Then, we requested each operation using the Postman
    REST client to request the URIs that we routed. In the content negotiation section,
    we handled the `Accept` HTTP header to provide the results in the format requested
    by consumers.  Finally, we covered the topic of API versions, which allow us to
    develop backward-compatible APIs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了一些更复杂的话题。让我们总结一下我们覆盖的内容。我们首先指定了我们的Web API的操作，并定义操作是一个URI和HTTP动作的组合。接下来，我们实现了路由并将它们绑定到一个操作上。然后，我们使用Postman
    REST客户端请求我们路由的URI来请求每个操作。在内容协商部分，我们处理了`Accept` HTTP头，以提供消费者请求的格式。最后，我们讨论了API版本的话题，这允许我们开发向后兼容的API。
- en: We used old-fashioned filesystem storage for our data in this chapter. This
    is not suitable for a web application. Thus, we will look into modern, scalable,
    and reliable NoSQL storage in the next chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用传统的文件系统存储来存储我们的数据。这不适合Web应用程序。因此，在下一章中，我们将探讨现代、可扩展和可靠的NoSQL存储。
