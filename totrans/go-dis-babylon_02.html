<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor030"/>2</h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Ramping up on Babylon.js</h1>
<p>At the risk of sounding hyperbolic, <strong class="bold">Babylon.js</strong> (<strong class="bold">BJS</strong>) is nothing short of incredible in how fast effortless, and <strong class="bold">fun</strong> it can be to work with 3D graphics and games. Most game and graphics engines come with sizable footprints in terms of size and computing resource requirements, but BJS is different because it can run in a web browser. The BJS team has created a rich web-based tooling ecosystem that covers a wide range of development workflows and use cases to support developers and designers from many different angles. After establishing some shared vocabulary and reviewing some basics, we will begin our journey with the <strong class="bold">Babylon.js Playground</strong> (<strong class="bold">PG</strong>). After this chapter, we’ll have laid the foundations for Space-Truckers by creating and rendering a basic animated scene that uses the PG along with content from the asset library.</p>
<p>In order to get from where we are to where we want to be, we’ll divide the work into these sections:</p>
<ul>
<li>Catching up or Refreshing on Babylon.js</li>
<li>Building Our Scene in the Playground</li>
<li>Animating Orbits</li>
<li>Extended Topics</li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Technical Requirements</h1>
<p><a id="_idTextAnchor033"/>Like most things in software, you’ll get the best results with Babylon.js. PG snippets requires only a web browser supporting <strong class="bold">WebGL</strong>, but a desktop-based browser is required for some BJS web-based toolsets such as the <strong class="bold">Node Material Editor</strong> (<strong class="bold">NME</strong>). A keyboard is highly recommended for typing code into the PG. With regards to browser support, while there are some exceptions around specific devices and platforms the latest versions of Edge, Chrome, and Firefox all support WebGL2, with ever-growing support for the newer WebGPU functionality. See <a href="https://caniuse.com/webgl2">https://caniuse.com/webgl2</a> for the most up-to-date list of browser vendors supporting WebGL2.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Catching up or Refreshing on Babylon.js</h1>
<p>When starting <a id="_idIndexMarker026"/>a new project, it’s easy to get overwhelmed by the sheer number of different things that need to be done. Throw unfamiliar technologies or domains into the mix, and even the most seasoned software veteran might blanch a bit at the challenge. That’s an okay feeling to have! The key to overcoming and moving past it is both difficult and simple at the same time: you just need to find an atomic, well-defined task and then just do that task. After tackling a few of these tasks, you can take a step back to reassess things in light of what you now know. Most likely, you will find that the work you originally thought was needed isn’t. </p>
<p>Whether you’re a veteran game developer exploring the possibilities of BJS or someone who has never programmed a game before, a strategy of starting simple and building iteratively can be the best way to get usable, immediate results. Let’s start with the basics. The following screenshot is part of the BJS 4.2 release content that demonstrates simply how BJS can render scenes with high visual fidelity.</p>
<div><div><img alt="Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent shadows, reflections, and refraction are clearly visible along (and inside) the bottle and table, just as different substances cast different shadows in the real world. (https://playground.babylonjs.com/#P1RZV0)" height="1003" src="img/Figure_2.01_B17266.jpg" width="1519"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent shadows, reflections, and refraction are clearly visible along (and inside) the bottle and table, just as different substances cast different shadows in the real world. (<a href="https://playground.babylonjs.com/#P1RZV0">https://playground.babylonjs.com/#P1RZV0</a>) </p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>The Basics of BJS</h2>
<p>BJS is a <a id="_idIndexMarker027"/>WebGL-based, full-featured 3D rendering engine written in TypeScript and compiled to JavaScript. Although commonly accessed via a web browser, current versions do not require an HTML DOM or Canvas elements, meaning that it can run “headless” on a server. The BJS team has a very clear vision and mandate, as illustrated from the BJS <a id="_idIndexMarker028"/>home page (<a href="https://www.BJS.com">https://www.BJS.com</a>):</p>
<p class="author-quote">“Our mission is to create one of the most powerful, beautiful, and simple Web rendering engines in the world. Our passion is to make it completely open and free for everyone. We are artists, developers, creators, and dreamers and we want to make it as simple as possible to enable everyone to bring their ideas to life.”</p>
<p>BJS supports a wide range of both input and output scenarios, from game pads and accelerometer-based input to single- or multiple-viewport output (e.g., VR/AR). A full list of the engine’s <a id="_idIndexMarker029"/>specifications is available at <a href="https://www.babylonjs.com/specifications">https://www.babylonjs.com/specifications</a>. Something that’s less obvious from the specifications is that support for WebGPU is limited only by the implementation of the standard by browser vendors, so if you read news about WebGPU support being released for a browser, you can be confident that BJS will be able to take full advantage of it without needing you to do anything at all!</p>
<p class="callout-heading">Tip</p>
<p class="callout">Something I always forget to apply to when I’m working with imported assets being from other 3D/image editing tools such as Blender is coordinate conventions. The 3D coordinate system used by BJS is “left-handed,” meaning that the positive <em class="italic">y</em>-axis will (by default) point in the “up” direction, the positive <em class="italic">x</em>-axis to the “right,” and the positive <em class="italic">z</em>-axis “toward” the camera. </p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Get Started with Getting Started</h2>
<p>Something that <a id="_idIndexMarker030"/>will quickly become apparent to anyone browsing the documentation for BJS is how thorough and comprehensive that documentation is. Given the high quality of the Getting Started content there, it would be a pointless waste of precious space in this book to attempt to recreate the basic<a id="_idIndexMarker031"/> tutorial at <a href="https://doc.babylonjs.com/start">https://doc.babylonjs.com/start</a>. If this is your first time adventuring with game development, BJS, or JavaScript, it is <em class="italic">highly</em> recommended that you take the time to at least browse through the Getting Started tutorial linked earlier. Don’t worry about leaving – everything will still be here right as you left it when you get back!</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Tools for the Toolbox</h2>
<p>One of the <a id="_idIndexMarker032"/>advantages of being JavaScript-based is that it is very easy to make <a id="_idIndexMarker033"/>web-based tooling available that allows users to code and render in real time in a tight iteration loop. The BJS <strong class="bold">Playground</strong> (<strong class="bold">PG</strong>) is probably the most prominent member of the BJS<a id="_idIndexMarker034"/> toolchain, but that should not diminish the utility and importance of the other tools that we’re going to cover. The following table summarizes the various tools available and their purposes:</p>
<div><div><img alt="" height="897" src="img/Table_2.01_B17266.jpg" width="1650"/>
</div>
</div>
<p>Throughout<a id="_idIndexMarker035"/> this book, we’ll be making heavy use of the PG; we’ll<a id="_idIndexMarker036"/> use it to quickly put together a piece of code or test a concept before integrating it into our application code. Not to <a id="_idIndexMarker037"/>be left out, the <strong class="bold">Inspector</strong> (and its accompanying tools) is also going to see heavy usage for its powerful scene-debugging capabilities. Finally, the NME will be covered later in this book as we dive into the making of Space-Truckers.</p>
<p class="callout-heading">Note</p>
<p class="callout">The typical usage of the word <strong class="bold">Game</strong> in this book denotes the portion of the overall <strong class="bold">Application</strong> that is devoted to the game mechanics, logic, and loops. </p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>The Asset Types of BJS</h2>
<p>Many <a id="_idIndexMarker038"/>different types of files and formats are supported by BJS, either directly or <a id="_idIndexMarker039"/>indirectly (via exporter plugins). When selecting and/or creating assets for your game, it’s important to put together a production workflow that minimizes the amount of friction without sacrificing quality – something we’ll learn more about in the next chapter. Here are a few of the most commonly encountered third-party tools and file types that BJS supports:</p>
<ul>
<li>Textures/Images:<ul><li>DDS (DXT1, 4bpp, and RGBA)</li><li>PNG/JPEG/BMP</li><li>TGA</li><li>HDR</li></ul></li>
<li>3D Models:<ul><li>GLTF (preferred)</li><li>OBJ</li><li>STL</li><li>BLENDER/3DS Max/Maya (exporter plugins)</li></ul></li>
<li>Sounds:<ul><li>WAV</li><li>MP3</li><li>MP4</li><li>M4A</li></ul></li>
<li>Fonts:<ul><li>TrueType</li><li>OTT</li></ul></li>
</ul>
<p>More relevant to our immediate purposes, however, is <a id="_idIndexMarker040"/>the BJS <strong class="bold">Asset Library</strong>. You can see the asset <a id="_idIndexMarker041"/>categories and browse entries by category at <a href="https://doc.babylonjs.com/toolsAndResources/assetLibraries">https://doc.babylonjs.com/toolsAndResources/assetLibraries</a>, but the true power of the Asset Library comes from being able to reference and load them from the PG! Let’s start off our scene creation by doing just that. Open up your browser of choice and head to the<a id="_idIndexMarker042"/> BJS PG: <a href="https://playground.babylonjs.com">https://playground.babylonjs.com</a>.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Building the Playground Scene</h1>
<p>The <strong class="bold">Babylon.js Playground</strong> is designed<a id="_idIndexMarker043"/> around providing users with the easiest, shortest possible path to rendering content in the scene. Open your web browser of<a id="_idIndexMarker044"/> choice and navigate to <a href="https://playground.babylonjs.com/">https://playground.babylonjs.com/</a> and you’ll see the basic outline of a snippet. This basic template snippet simply creates a new <strong class="bold">scene</strong> and a <strong class="bold">camera</strong> that renders it, but it’s as <a id="_idIndexMarker045"/>good a starting place as any!</p>
<p>On the left of the playground is the code editor and on the right the render canvas. The important thing to know about the playground is that each snippet is unique in two ways, both contained within the URL to the snippet. The characters after the first hash (#) symbol are the snippet’s ID, the number after the second hash the revision. Every time a snippet is created it is assigned a unique identifier, and every time that snippet is saved a new revision is created. For example, <strong class="bold">#L92PHY#36</strong> points to a sample showing multiple viewports in an FPS camera, with the current revision being 36. Thus, it’s possible to step incrementally through a particular snippet’s revision history simply by changing the URL. </p>
<p class="callout-heading">Note</p>
<pre>#0UYAPE#42</strong>. That is, snippet <strong class="bold">0UYAPE</strong> at revision <strong class="bold">42</strong>.  </pre>
<p>Because we are going to be using snippets from the PG in our game though, we’re going to want to do a little bit of preparatory structuring so that we can easily and reliably transfer code between our PG snippets and the source repos (more on this in <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a><em class="italic">,  Establishing the Development Workflow</em>). Throughout the book and in snippets, we will be using <strong class="bold">ES6 </strong>syntax where possible. This gives us access to some important language features that we’ll be leveraging to help keep our code readable and maintainable.</p>
<p class="callout-heading">Tip</p>
<p class="callout">ES6 recommendation: choose <code>let</code> over <code>var</code>.</p>
<p class="callout">It’s all about hoisting and closures. Variables declared using the <code>var</code> keyword are valid in their declaring scopes, but also potentially in a/their containing scope (known as “hoisting”). Additionally, you can reference a <code>var</code> prior to its usage without throwing a runtime error. When a variable is declared with the <code>let</code> statement, it is only available in the declared scope, and it must be declared prior to usage; otherwise, an error will be thrown. Generally, you should prefer the use of <code>let</code> over <code>var</code> because it will more easily prevent and expose all-too-common-but-potentially-quite-subtle defects. Of course, if you aren’t going to be changing the value, you should use <code>const</code> over <code>let</code>.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Establishing the AppStartScene</h2>
<p>A new<a id="_idIndexMarker046"/> PG snippet starts with a<a id="_idIndexMarker047"/> single block of code – the <code>createScene</code> function. As the code comments also indicate, the <code>engine</code> and <code>canvas</code> global variables are available in the window’s context. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">The HTML Canvas element has been removed as a dependency in BJS 4.2+, but for backward compatibility reasons, methods involving the HTML Canvas element will still function as expected. </p>
<h3>Modifying the createScene function</h3>
<p>To make the reuse <a id="_idIndexMarker048"/>of code easier, we will make a small change to the initial function template. Instead of putting all of the scene’s logic into the same <code>createScene</code> function, we’re going to subdivide the logic into atomic functions as much as possible. The initialization routine will be done in a new function, which will return an object containing the populated scene objects:</p>
<pre class="source-code">&#13;
let createScene = function () {&#13;
    let eng = engine;&#13;
    let startScene = createStartScene(eng);&#13;
    return startScene.scene;&#13;
}; </pre>
<p>A sharp<a id="_idIndexMarker049"/> observer will notice that we have not as yet implemented the <code>createStartScene</code> function, which is of course the next step. Its purpose is to create and initialize the scene and its elements – see the following list. Low-friction change is critically important, so to make it easier to change them later we’re going to place each piece of functionality into its own function (pun intended):</p>
<ul>
<li>ArcRotateCamera</li>
<li>Point light</li>
<li>Star (sun)</li>
<li>Skybox for background</li>
<li>Planets – four rocky and one gas giant</li>
</ul>
<p>It’s time to fill out our add and populate this new function, <code>createStartScene</code>. First, we are creating the scene and camera, specifying some specifics before making calls to soon-to-be-written functions (in bold) that create their respective elements:</p>
<pre class="source-code">&#13;
function createStartScene(engine) {&#13;
    let that = {};&#13;
    let scene = that.scene = new BABYLON.Scene(engine);&#13;
    let camAlpha = 0,&#13;
        camBeta = -Math.PI / 4,&#13;
        camDist = 350,&#13;
        camTarget = new BABYLON.Vector3(0, 0, 0);&#13;
    let camera = that.camera = new BABYLON.ArcRotateCamera("camera1", camAlpha, camBeta, camDist, camTarget, scene);    &#13;
    let env = <strong class="bold">setupEnvironment(scene);</strong>&#13;
    let star = that.star = <strong class="bold">createStar(scene);</strong>    &#13;
    let planets = that.planets = <strong class="bold">populatePlanetarySystem(scene);</strong>&#13;
    camera.attachControl(true);    &#13;
    return that;&#13;
}</pre>
<p>To save<a id="_idIndexMarker050"/> you the effort of doing the math in your head, the <code>camBeta</code> (or, the latitudinal position in radians of the camera from the target) value comes out to around 0.785 rad - 45 degrees, between the equator and the pole of an imaginary circle around the target of <code>camDist</code> radius. Of course, this code won’t compile or run yet because we haven’t yet defined <code>setupEnvironment</code>, <code>createStar</code>, or <code>populatePlanetarySystem</code>. Add stub implementations for these functions to make sure that the code runs as expected. The resulting scene is empty, but it’s a good checkpoint in our progress. It’s time to fill in the stubs and make our scene come to life! Don’t forget to save (<em class="italic">Ctrl</em> + <em class="italic">S</em>) your snippet before continuing.</p>
<h3>Setting up the Environment</h3>
<p>The default<a id="_idIndexMarker051"/> environment is pretty bland and dark. The primary source of lighting for the scene is going to <a id="_idIndexMarker052"/>be a <strong class="bold">Point Light</strong> positioned at the center of the star system, while a skybox gives the scene perspective. The texturing of the skybox is of particular interest, because an attractive-looking skybox tends to be quite large in terms of file size. We care about this because we are going to use this scene as a loading graphic, meaning that it needs to load and begin rendering as quickly as possible. Loading a large texture over an internet connection is unlikely to help us with that goal, so instead we will create the texture on the fly using the <strong class="bold">Starfield Procedural Texture</strong> from<a id="_idIndexMarker053"/> the Babylon.js <strong class="bold">Procedural Textures Library</strong> (see <a href="https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary">https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary</a> for the full<a id="_idIndexMarker054"/> list of available procedural textures).</p>
<p class="callout-heading">Tip</p>
<p class="callout">Every <code>darkmatter</code>, which controls the lacunae (voids), and <code>distfading</code>, which governs the sharpness or blurriness of the rendered texture. The values in the code listed in the following code were arrived at after trial-and-error, so experiment to see what you like the best!</p>
<p><code>PointLight</code> is, as<a id="_idIndexMarker057"/> the name implies, a source of light that radiates in a spherical shell from a single point in space. Because of the darkness of the scene and its large-ish size, the intensity of the light gets a bump before setting some sun-like colors for the diffuse and specular color channels. We use the <code>createDefaultEnvironment</code> method along with some previously defined options to create the skybox and accompanying background material. That method returns an <code>EnvironmentHelper</code> instance, which we will kindly return to the original caller of <code>setupEnvironment</code>:</p>
<pre class="source-code">&#13;
function setupEnvironment(scene) {&#13;
    let starfieldPT = new BABYLON.StarfieldProceduralTexture("starfieldPT", 512, scene);&#13;
    starfieldPT.coordinatesMode = BABYLON.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE;&#13;
    starfieldPT.darkmatter = 1.5;&#13;
    starfieldPT.distfading = 0.75;&#13;
    let envOptions = {&#13;
        skyboxSize: 512,&#13;
        createGround: false,&#13;
        skyboxTexture: starfieldPT,&#13;
        environmentTexture: starfieldPT&#13;
    };&#13;
    let light = new BABYLON.PointLight("starLight", BABYLON.Vector3.Zero(), scene);&#13;
    light.intensity = 2;&#13;
    light.diffuse = new BABYLON.Color3(.98, .9, 1);&#13;
    light.specular = new BABYLON.Color3(1, 0.9, 0.5);&#13;
    let env = scene.createDefaultEnvironment(envOptions);&#13;
    return env;&#13;
}</pre>
<p>Clicking <strong class="bold">Run</strong> should<a id="_idIndexMarker058"/> now show a nifty-looking starfield in a skybox you can pan around. If everything is working correctly, now is a good time to save your work.</p>
<div><div><img alt="Figure 2.2 – Starfield skybox environment&#13;&#10;" height="860" src="img/Figure_2.02_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Starfield skybox environment</p>
<h3>Birthing a Star</h3>
<p>The mesh for our <a id="_idIndexMarker059"/>star is a simple sphere, but when we add the standard material and some color channels, the result is a single-toned, flat-appearing circle – not very “star-like.” We can get a more nuanced look with very little effort by combining an <code>BABYLON.Texture</code>:</p>
<pre class="source-code">&#13;
function createStar(scene) {&#13;
    let starDiam = 16;&#13;
    let star = BABYLON.MeshBuilder.CreateSphere("star", &#13;
        { diameter: starDiam, segments: 128 }, scene);&#13;
    let mat = new BABYLON.StandardMaterial("starMat",&#13;
        scene);&#13;
    star.material = mat;&#13;
    mat.emissiveColor = new BABYLON.Color3(0.37, 0.333,&#13;
        0.11);&#13;
    mat.diffuseTexture = new BABYLON.Texture&#13;
        ("textures/distortion.png", scene);&#13;
    mat.diffuseTexture.level = 1.8;&#13;
    return star;&#13;
}</pre>
<p>Without changing the <code>diffuseTexture.level</code> value, the <code>emissiveColor</code> tends to either wash out the distortion or be extinguished entirely by the diffuse texture’s pixel values. The level, 1.8, was a product of trial-and-error (as is the case with many of these “magic numbers” that tend to show up during app design/game development). This is a good checkpoint for <strong class="bold">saving</strong> your progress if you haven’t recently.</p>
<div><div><img alt="Figure 2.3 – Emissive color combined with a diffuse distortion texture&#13;&#10;" height="1095" src="img/Figure_2.03_B17266.jpg" width="1643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Emissive color combined with a diffuse distortion texture</p>
<h3>Producing Planets</h3>
<p>There’s <a id="_idIndexMarker061"/>only one remaining top-level scene element that we still need to create, and that’s the <code>populatePlanetarySystem</code> function. The implementation for this is a classic example of the power of compositional software patterns – a topic we will be returning to later. There’s what you might think of as a central control logic in the form of <code>populatePlanetarySystems</code>, which is responsible for defining the number and unique properties of the various planetary bodies. It then asks another function, the new <code>createPlanet</code> method, to take care of how the actual object is constructed. Finally, it collects the planets into an array that it returns to the caller. </p>
<p>We want to be able to create different types of planets with different properties, so in our <code>populatePlanetarySystems</code> method, we create an array of objects that define each planet. For the full listing of planetary data, see <a href="https://playground.babylonjs.com/%230UYAPE%2326">https://playground.babylonjs.com/#0UYAPE#26</a>:</p>
<pre class="source-code">&#13;
let hg = {&#13;
    name: "hg",&#13;
    posRadians: BABYLON.Scalar.RandomRange(0, 2 * Math.PI),&#13;
    posRadius: 14,&#13;
    scale: 2,&#13;
    color: new BABYLON.Color3(0.45, 0.33, 0.18),&#13;
    rocky: true&#13;
}; //...</pre>
<p>The <code>posRadians</code> property generates a random value between 0 and 360 degrees (in radians), whereas the <code>posRadius</code> property specifies the distance from the origin the planet should<a id="_idIndexMarker062"/> reside – how far away it is from the sun. The overall size of the planet is determined by its <code>scale</code> factor, while the <code>color</code> property. We’ll cover the final property in a moment. Scaling of a scene can be tricky, but you can use relative scale guides to help come up with appropriate ranges of numbers. </p>
<p>You don’t have to stick to realistic numbers – have you ever been told that “Space is Big. Really Big”? It is, in fact, quite too big to fit in our tiny viewport, so when choosing <code>posRadius</code> for the planet, it might be easier to approach coming up with a figure from a different direction. By looking at the orbital radius in terms of the relative steps between planets, we can come up with a decent-looking (but probably not realistically stable) system of planets. Our <code>starDiameter</code> is 16, giving us a radius of 8 units. Our inner-most planet, <code>“hg”</code>, needs to be at least 8 + 2 = 10 units to avoid intersecting the star; putting it at 14 units seems about right. Moving to subsequent planets, by placing each planet around 1.5–1.8x, the orbital radius of the previous planet will give nice-looking results that aren’t too far from the ratios found in our own Solar System – that’s how you know it will be interesting! </p>
<p>This leaves us with the <code>rocky</code> property. This flag will signal our logic that it needs to apply a different set of textures to the <code>createPlanet</code> into the <code>planets</code> array before returning the populated array:</p>
<pre class="source-code">&#13;
planets.push(createPlanet(hg, scene));&#13;
planets.push(createPlanet(aphro, scene));&#13;
planets.push(createPlanet(tellus, scene));&#13;
planets.push(createPlanet(ares, scene));&#13;
planets.push(createPlanet(zeus, scene));&#13;
return planets;</pre>
<p>The final sub-task needed to display our planetary system is to implement the <code>createPlanet</code> function. In this method, we do the following:</p>
<ol>
<li>Create a<a id="_idIndexMarker063"/> new Sphere <strong class="bold">Mesh</strong> using the <strong class="bold">MeshBuilder</strong>.</li>
<li>Create a new <code>diffuseColor</code> and <code>specularColor</code> to the passed-in <code>Color3</code> value.</li>
<li>Assign textures based on the value of the <code>rocky</code> flag.</li>
<li>Assign the material to the mesh.</li>
<li>Scale and position <code>planet</code> according to the passed-in <code>scale</code>, <code>posRadians</code>, and <code>posRadius</code> values.</li>
</ol>
<p>It may not be immediately obvious, but we are also setting the material’s <code>specularPower</code> to zero. This is because we will otherwise get very shiny spots on our planets, making them look more like billiard balls than rocky or gaseous spheres. For rocky planets, we are pulling in both <code>bumpTexture</code> (a.k.a. a <code>diffuseTexture</code> from the BJS <strong class="bold">Textures Library</strong>. For planets with no visible surface, we use the distortion texture to add the appearance of cloud bands in the atmosphere:</p>
<pre class="source-code">&#13;
function createPlanet(opts, scene) {&#13;
    let planet = BABYLON.MeshBuilder.&#13;
        CreateSphere(opts.name, { diameter: 1 }, scene);&#13;
    let mat = new BABYLON.StandardMaterial(planet.&#13;
        name + "-mat", scene);&#13;
    mat.diffuseColor = mat.specularColor = opts.color;&#13;
    mat.specularPower = 0;&#13;
    if (opts.rocky === true) {&#13;
        mat.bumpTexture = new&#13;
            BABYLON.Texture("textures/rockn.png", scene);&#13;
        mat.diffuseTexture = new&#13;
            BABYLON.Texture("textures/rock.png", scene);&#13;
    }&#13;
    else {&#13;
        mat.diffuseTexture = new BABYLON.Texture&#13;
            ("textures/distortion.png", scene);&#13;
    }&#13;
    planet.material = mat;&#13;
    planet.scaling.setAll(opts.scale);&#13;
    planet.position.x = opts.posRadius *&#13;
        Math.sin(opts.posRadians);&#13;
    planet.position.z = opts.posRadius *&#13;
        Math.cos(opts.posRadians);&#13;
    return planet;&#13;
}</pre>
<p>With that<a id="_idIndexMarker064"/> code in place, you should be able to <strong class="bold">Run</strong> the scene and get a most excellent result, showing our central star with four various-sized and colored planets at varying distances from the star. </p>
<div><div><img alt="Figure 2.4 – Star system with planets and a skybox&#13;&#10;" height="973" src="img/Figure_2.04_B17266.jpg" width="1441"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Star system with planets and a skybox</p>
<p><strong class="bold">Save</strong> the <a id="_idIndexMarker065"/>snippet and strap in, because next, we’re going to learn two different ways and styles of making our planets move.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Animating the Orbits</h1>
<p>BJS has many different<a id="_idIndexMarker066"/> ways of accomplishing any given task; animating objects in a scene is no different. Some of the different ways to animate in BJS include the following:</p>
<ul>
<li>Define a <a id="_idIndexMarker067"/>reusable <code>BABYLON.Animation</code> object that will interpolate specified properties between an array of <strong class="bold">keyframes</strong>.</li>
<li>Import pre-built Animations from a file – <code>BABYLON</code>, <code>GLTF</code>, <code>GLB</code>, <code>OBJ</code>, and so on.</li>
<li>Use <code>OnPreRenderObservable</code> to update object properties (e.g., position, rotation, color, and so on) before <a id="_idIndexMarker068"/>each frame is rendered.</li>
</ul>
<p>For our title screen animations, we will be using the first and third methods to animate the rotations and circular orbits of our little solar system, respectively. In later chapters, we will see more of the second. </p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Putting Spin on the Star and Planets</h2>
<p>The rotation<a id="_idIndexMarker069"/> of stars and planets is pretty simple, but it can serve as a good review of the principle and practice of keyframe animation. Since animations can be looped or cycled, it’s often unnecessary to need a large number of frames for a given animation. We’ll follow a few easy steps to add a <code>createSpinAnimation</code> function that returns a new <strong class="bold">Animation</strong> instance. </p>
<p>First, we figure out what/which properties of the animation’s target will be changing. In this case, it is just the target node’s <code>rotation.y</code> value. We can say that our animation should complete a full circle (360 degrees or 2 * Pi radians) in 2 seconds. Next, determine how many frames the animation should comprise in total, the number of <code>Scalar.TwoPi</code>. This is all we need to implement the code to create and set the animation properties:</p>
<pre class="source-code">&#13;
function createSpinAnimation() {&#13;
    let orbitAnim = new BABYLON.Animation("planetspin",&#13;
        "rotation.y", 30,&#13;
        BABYLON.Animation.ANIMATIONTYPE_FLOAT,&#13;
        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);&#13;
    const keyFrames = [];&#13;
    keyFrames.push({&#13;
        frame: 0,&#13;
        value: 0&#13;
    });&#13;
    keyFrames.push({&#13;
        frame: 60,&#13;
        value: BABYLON.Scalar.TwoPi&#13;
    });&#13;
    orbitAnim.setKeys(keyFrames);&#13;
    return orbitAnim;&#13;
}</pre>
<p>The <code>createSpinAnimation</code> method is called from <code>createStartScene</code> to make the <code>spinAnim</code> variable available to the rest of the scene’s controlling code.</p>
<p>Once the <a id="_idIndexMarker070"/>animation has been created, it can then be added to one or more different <code>mesh.animations</code> arrays. This attaches the animation to that particular <code>Animation</code> object has no <code>start</code> function or equivalent. That is because the Animation itself is agnostic of its target, allowing it to be used across any arbitrary number of different meshes. Starting with <code>star</code> and then looping through our <code>planets</code> array, we add <code>spinAnim</code> to each mesh: </p>
<pre class="source-code">&#13;
let spinAnim = createSpinAnimation();&#13;
star.animations.push(spinAnim);&#13;
scene.beginAnimation(star, 0, 60, true);</pre>
<p>To start an animation, you call the <code>scene.beginAnimation</code> function, passing the start frame, the end frame, and the speed parameters along with the animation object. We want it to loop, so we pass <code>true</code> as our final parameter to the method:</p>
<pre class="source-code">&#13;
planets.forEach(p =&gt; {&#13;
    p.animations.push(spinAnim);&#13;
      scene.beginAnimation(p, 0, 60, true,&#13;
          BABYLON.Scalar.RandomRange(0.1, 3));&#13;
});</pre>
<p>When the <a id="_idIndexMarker071"/>scene is run, the animation automatically starts and you can observe the rotation of all the bodies. </p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>Making Orbital Motion</h2>
<p>Unlike the <code>scene.onBeforeRenderObservable</code>. In the context of the game engine loop, this is where the update logic happens. At the end of <code>createPlanet</code>, we will add code to attach the event listener along with additional data that tracks the planet’s orbital parameters:</p>
<pre class="source-code">&#13;
planet.orbitOptions = opts;&#13;
planet.orbitAnimationObserver = &#13;
    createAndStartOrbitAnimation(planet, scene);</pre>
<p>Our <code>createAndStartOrbitAnimation</code> method needs to derive a number of values. Two of these, the orbital radius (<code>posRadius</code>) and the angular position (<code>posRadians</code>) are added to <code>planet</code> as the <code>orbitOptions</code> property. </p>
<p>The <code>period</code> orbital is the amount of time it takes for the planet to make one complete revolution (360 degrees or 2 * Pi radians) and is measured in seconds. We want each planet to have a different period, with distant bodies taking longer than closer ones to complete an orbit, but we don’t want to laboriously tweak values until they look good. Physics – or, more specifically, Newtonian mechanics – gives us the equations to compute a planet’s orbital speed given its distance (radius) from a given massive body. Knowing the rate of position change over time, it’s possible to calculate the angular velocity: </p>
<pre class="source-code">&#13;
function createAndStartOrbitAnimation(planet, scene) {&#13;
    const Gm = 6672.59 * 0.07;&#13;
    const opts = planet.orbitOptions;&#13;
    const rCubed = Math.pow(opts.posRadius, 3);&#13;
    const period = BABYLON.Scalar.TwoPi * Math.sqrt&#13;
        (rCubed / Gm);&#13;
    const v = Math.sqrt(Gm / opts.posRadius);&#13;
    const w = v / period;&#13;
    const circum = Scalar.TwoPi * opts.posRadius;&#13;
    let angPos = opts.posRadians;</pre>
<p>The <code>Gm</code> constant is more or less arbitrarily chosen to ensure a smooth distribution of orbital velocities as the radius changes. The state variable needed is <code>angPos</code>, which is incremented by <code>w</code> every frame and kept within a valid range by wrapping the statement in a call to <code>Scalar.Repeat</code>. In general, it’s useful to think of the angular components of these kinematics as being counters or watch dials; incrementing the angular position by the angular velocity over time and computing position components completes the logic:</p>
<pre class="source-code">&#13;
let preRenderObsv = scene.onBeforeRenderObservable.add(sc =&gt; {&#13;
    planet.position.x = opts.posRadius * Math.sin(angPos);&#13;
    planet.position.z = opts.posRadius * Math.cos(angPos);&#13;
    angPos = BABYLON.Scalar.Repeat(angPos + w,&#13;
        BABYLON.Scalar.TwoPi);&#13;
});&#13;
return preRenderObsv;</pre>
<p>Returning<a id="_idIndexMarker073"/> the <code>preRenderObsv</code> object isn’t needed to make this work, but it’s a good practice so that we can later on cleanly dispose of the observer when it’s no longer needed. Now, when the scene is run, the planets all circle around the sun in a unique fashion. This is all looking great, but there’s one last thing we can do to really spice things up before we move on. Mash <strong class="bold">Save</strong> and let’s move on to the finale.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Orbit Lines</h2>
<p>To cap off this animation, we’re <a id="_idIndexMarker074"/>going to add lines to each planet’s orbit using a <code>createAndStartOrbitAnimation</code> method is a good place to do this. We declare our <code>TrailMesh</code> and pass it <code>planet</code> to attach to along with the <code>circum</code> orbital (length) of the trail ribbon, also specifying that we want the trail to start immediately. At the same time, we also create a new material and associate it with the Trail Mesh:</p>
<pre class="source-code">&#13;
planet.computeWorldMatrix(true);&#13;
let planetTrail = new BABYLON.TrailMesh(planet.name + &#13;
    "-trail", <strong class="bold">planet</strong>, scene, .1, <strong class="bold">circum</strong>, true);&#13;
let trailMat = new BABYLON.StandardMaterial&#13;
    (planetTrail.name + "-mat", scene);&#13;
trailMat.emissiveColor = trailMat.specularColor =&#13;
    trailMat.diffuseColor = opts.color;&#13;
planetTrail.material = trailMat;</pre>
<p>Before adding the<a id="_idIndexMarker076"/> trail mesh, we need to force recomputation of the planet’s <strong class="bold">World Matrix</strong>; otherwise, the trail will have artifacts from the origin to the planet’s location. That’s it! The orbits trace out nice circles as they move, but it still feels as if the scene were a bit dark and washed out. </p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Shining up with GlowLayer</h2>
<p>By default, BJS<a id="_idIndexMarker077"/> does not add the emissive color channel of a material to the lighting computations – emissive textures and colors don’t brighten up a scene. Making objects glow is easy; just add this line to the <code>createStartScene</code> method:</p>
<pre class="source-code">&#13;
let glowLayer = new BABYLON.GlowLayer("glowLayer", scene);</pre>
<p>Unless otherwise specified, the GlowLayer will impact every mesh in the scene. We don’t want the planets to glow, so while we’re looping through the planets to animate their rotation, add the planet to the mesh exclusion list of the GlowLayer:</p>
<pre class="source-code">&#13;
planets.forEach(p =&gt; {&#13;
        <strong class="bold">glowLayer.addExcludedMesh(p);</strong>&#13;
        p.animations.push(spinAnim);&#13;
        scene.beginAnimation(p, 0, 60, true,&#13;
            BABYLON.Scalar.RandomRange(0.1, 3));&#13;
    });</pre>
<p>Click <strong class="bold">Run</strong> to view the <a id="_idIndexMarker078"/>results. If you’re not satisfied with how things look, you can tweak the camera altitude and angle (<strong class="bold">beta</strong> and <strong class="bold">alpha</strong> respectively), distance, and so on. Make sure to save the snippet in any case and enjoy the fruits of your labor. Once you’re done admiring your work, post your snippets on the boards at <a href="https://github.com/jelster/space-truckers/discussions/21">https://github.com/jelster/space-truckers/discussions/21</a>, where you can look at other folks’ creations, share, and discuss – but don’t forget to come back here, there’s still more work to be done!</p>
<div><div><img alt="Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes &#13;&#10;" height="920" src="img/Figure_2.05_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes </p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Extended Topics</h1>
<p>The completed snippet meets the immediate needs of our application, but that doesn’t mean that there aren’t ways to improve it! The following are a few ideas you might pursue on your own that could enhance the scene. Join the BJS and the Space-Truckers community by posting and sharing your snippets over at the Space-Truckers Discussions board (<a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a>) or over on<a id="_idIndexMarker079"/> the BJS forums (<a href="https://forum.babylonjs.com/">https://forum.babylonjs.com/</a>). The discussion boards and forum aren’t just there to share your accomplishments, however. They’re a place where you can post questions or issues you’re encountering, with a thriving community that loves to help.</p>
<p>You could do the following:</p>
<ul>
<li>Remove the helix-like appearance of the planet trails. The spin animation and the trail mesh are both parented to the planet. As the planet rotates, the trail mesh gets twisted around. One approach to fixing this could be to add a <strong class="bold">TransformNode</strong> to the<a id="_idIndexMarker080"/> scene and parent the planet to it. Keep the spin animation on the planet, but associate and point the <strong class="bold">TrailMesh </strong>and the <a id="_idIndexMarker081"/>orbital animation at the <strong class="bold">TransformNode</strong>.</li>
<li>Replace the star’s current texture with a particle <a id="_idIndexMarker082"/>system. The <strong class="bold">ParticleHelper</strong> has a <strong class="bold">sun</strong> effect<a id="_idIndexMarker083"/> that can bring a cool effect to the scene. The docs on this are at <a href="https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper">https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper</a>, where there’s also useful information on how to create your own custom <strong class="bold">ParticleSets</strong>. The <a id="_idIndexMarker084"/>easiest (and perhaps the best) option for creating custom particle systems is to use the NME (<a href="https://nme.babylonjs.com/">https://nme.babylonjs.com/</a>) in <strong class="bold">Particle</strong> mode. The NME is to <a id="_idIndexMarker085"/>shaders as the PG is to scenes, meaning that just as you can save and share PG snippets, you can also save and share NME snippets. The difference between them in this context is that you can use NME snippets in the PG but not vice versa.</li>
<li>Add a comet on an <strong class="bold">inclined</strong> orbit that brightens and shows a tail as it gets closer to the star on its elliptical path through the scene. An inclination simply means that the object includes the y axis as it “bobs” up and down through the orbital plane. An elliptical orbit has the same period as a circular orbit, with an orbital radius that’s the same as the ellipse’s <strong class="bold">semi-major axis</strong> (the length of the line dividing the ellipse along its long side), but the difference is that rather than having a constant velocity along its path, objects moving in an elliptical orbit travel fastest at their closest approach (<strong class="bold">apopse</strong>).</li>
<li>Give the outer-most gas giant planet a ring system. One way to approach this would be to create a flat torus mesh using the MeshBuilder, and then use BJS <strong class="bold">Parenting</strong> to attach the rings to a planet. Another approach that builds on the prior would be to use <a id="_idIndexMarker086"/>the <strong class="bold">Solid Particle System</strong> (<strong class="bold">SPS</strong>) to generate tens or even hundreds of small rocks to comprise the rings. Consider it a preview of what’s coming up: in the next chapter, we’ll be using the SPS to create an asteroid belt.</li>
<li>Add clouds specular, terrain bump (normal) map to a rocky planet to make it look like real-world planets. The BJS <strong class="bold">Asset Library</strong> has a height map of the earth’s terrain along with various textures for cloud and ground effects. The <strong class="bold">Materials Library</strong> also <a id="_idIndexMarker087"/>has some interesting options to explore for making the planets unique and attractive – have fun!</li>
<li>Make the camera pan and zoom around the system cinematically. Choose one of the animation methods we discussed previously, targeting the scene’s <code>camera</code>. Depending on your methods and plan, you may want to unset or change the camera’s target to be a <strong class="bold">TransformNode</strong>. This new, non-rendered node acts as a sort of “mark” that can be moved around to change the camera’s view as the position changes. Another option is to explore a different type of camera than the<a id="_idIndexMarker088"/> current <strong class="bold">ArcRotateCamera</strong>. </li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Summary</h1>
<p>Over the course of this chapter, we’ve refreshed and ramped ourselves up on BJS by creating a simple scene in the PG. We learned about different ways of animating a scene along with how to load textures and other assets from the BJS Asset Library. Hopefully, we’ve had a little bit of fun along the way, but this is just the tip of the iceberg when it comes to what’s in store in later chapters. If you needed a little bit of a refresher on BJS, hopefully this has gotten you warmed up and ready to go. If you’re new to BJS, then I hope this has empowered you to push onward to the next chapter. Coming up in the next chapter, we will begin Space-Truckers in earnest by setting up a local development environment along with source control and debugging. </p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Further Reading</h1>
<p>The BJS documentation site contains an enormous wealth of knowledge and content. Here are some relevant pages from the docs that go into more detail on the topics covered in this chapter:</p>
<ul>
<li>Once you’ve gotten how to do individual Animations, read about Animation sequencing, grouping, and combining, starting at <a href="https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations">https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations</a>. </li>
<li>Learn about importing different files types of assets into a scene and how loaders work at <a href="https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes">https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes</a>.</li>
<li>The Diving Deeper: The Mesh section has details on how the GlowLayer works at <a href="https://doc.babylonjs.com/divingDeeper/mesh/glowLayer">https://doc.babylonjs.com/divingDeeper/mesh/glowLayer</a>.</li>
<li>For details on the different types of cameras and their properties, see <a href="https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction">https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction</a>. Something that is worth mentioning is that whenever you see the docs mention <code>FreeCamera</code>, <code>TouchCamera</code>, or <code>GamepadCamera</code>, you should instead substitute or use <code>UniversalCamera</code>, as it supersedes those three, which are retained for backward compatibility reasons.</li>
</ul>
</div>
<div><div></div>
</div>
</div></body></html>