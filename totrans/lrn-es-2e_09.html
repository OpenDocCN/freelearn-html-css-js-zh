<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">JavaScript on the Web</h1>
                </header>
            
            <article>
                
<p class="mce-root">Hello there! So far, we've learned and created a solid understanding of JavaScript, how it works under the hood, and what it contains. But how do we actually use it today? How do we start building something? This is the chapter that deals with this.</p>
<p>In this chapter, we'll learn about:</p>
<ul>
<li>HTML5 and the rise of modern JavaScript</li>
<li>What is <strong>Document Object Model </strong>(<strong>DOM</strong>)?</li>
<li>DOM m<span>ethods/properties</span></li>
<li>Modern JavaScript browser APIs</li>
<li>Page Visibility API</li>
<li>Navigator API</li>
<li>Clipboard API</li>
<li>Canvas API - the web's drawing board</li>
<li>Fetch API</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML5 and the rise of modern JavaScript</h1>
                </header>
            
            <article>
                
<p>The HTML5 specification arrived in 2008. HTML5, however, was so technologically advanced in 2008 that it was predicted that it would not be ready till at least 2022! However, that turned out to be incorrect, and here we are, with fully supported HTML5 and ES6/ES7/ES8-supported browsers.</p>
<p>A lot of APIs used by HTML5 go hand in hand with JavaScript. Before looking at those APIs, let us understand a little about how JavaScript sees the web. This'll eventually put us in a strong position to understand various interesting, JavaScript-related things such as the Web Workers API, which deserves its own chapter (spoiler alert: It is included in this book!)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTML DOM</h1>
                </header>
            
            <article>
                
<p>The HTML DOM is a tree version of how the document looks. Here is a very simple example of an HTML document:</p>
<pre>&lt;!doctype HTML&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Cool Stuff!&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;p&gt;Awesome!&lt;/p&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Here's how its tree version will look:</p>
<div class="CDPAlignCenter CDPAlign"><img height="91" src="assets/44939779-ea75-4738-8a37-afa1e574cefc.png" width="104"/></div>
<p>The previous diagram is just a rough representation of the DOM tree. HTML tags consist of <strong>head</strong> and <strong>body</strong>; furthermore, the <kbd>&lt;body&gt;</kbd> tag consists of a <kbd>&lt;p&gt;</kbd> tag, whereas the <kbd>&lt;head&gt;</kbd> tag consists of the <kbd>&lt;title&gt;</kbd> tag. Simple!</p>
<p>JavaScript has access to the DOM directly, and can modify the connections between these nodes, add nodes, remove nodes, change contents, attach event listeners, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is the Document Object Model (DOM)?</h1>
                </header>
            
            <article>
                
<p>Simply put, the DOM is a way to represent HTML or XML documents as nodes. This makes it easier for other programming languages to connect to a DOM-following page and modify it accordingly. </p>
<p>To be clear, DOM is not a programming language. DOM provides JavaScript with a way to interact with web pages. You can think of it as a standard. Every element is part of the DOM tree, which can be accessed and modified with APIs exposed to JavaScript.</p>
<p>DOM is not restricted to being accessed only by JavaScript. It is language-independent and there are several modules available in various languages to parse DOM (just like JavaScript) including PHP, Python, Java, and so on.</p>
<p>As said previously, DOM provides JavaScript with a way to interact with it. How? Well, accessing DOM is as easy as accessing predefined objects in JavaScript: <kbd>document</kbd>. The DOM API specifies what you'll find inside the <kbd>document</kbd> object. The <kbd>document</kbd> object essentially gives JavaScript access to the DOM tree formed by your HTML document. If you notice, you cannot access any element at all without actually accessing the <kbd>document</kbd> object first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DOM methods/properties</h1>
                </header>
            
            <article>
                
<p>All HTML elements are objects in JavaScript. The most commonly used object is the <kbd>document</kbd> object. It has the whole DOM tree attached to it. You can query for elements on that. Let's look at some very common examples of these methods:</p>
<ul>
<li><kbd>getElementById</kbd> method</li>
<li><kbd>getElementsByTagName</kbd> method</li>
<li><kbd>getElementsByClassName</kbd> method</li>
<li><kbd>querySelector</kbd> method</li>
<li><kbd>querySelectorAll</kbd> method</li>
</ul>
<div class="packt_infobox">By no means is this an exhaustive list of all methods available. However, this list should at least get you started with DOM manipulation. Use MDN as your reference for various other methods. Here's the link: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods">https://developer.mozilla.org/en-US/docs/Web/API/Document#Methods</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the getElementById method</h1>
                </header>
            
            <article>
                
<p>In HTML, you can assign an element an <kbd>ID</kbd> and then retrieve it back in JavaScript for manipulation. Here's how:</p>
<pre>&lt;div id="myID"&gt;My Content Here&lt;/div&gt;<br/>&lt;script&gt;<br/>const myID = document.getElementById('myID'); // myID now contains reference to the div above<br/>&lt;/script&gt;</pre>
<p>Once you have that, you can access the properties of this object, which in turn actually modifies the element on the screen accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the getElementsByTagName method</h1>
                </header>
            
            <article>
                
<p>Similar to the <kbd>ID</kbd> method, <kbd>getElementsByTagName(&lt;Name Of Tag&gt;)</kbd> gets us elements with a couple of differences:</p>
<ul>
<li>It gives you a collection of elements instead of a single element (array)</li>
<li>It queries for elements on the basis of their tag names and not <kbd>ID</kbd> values</li>
</ul>
<p>Here's an example:</p>
<pre>&lt;div&gt;My Content Here&lt;/div&gt;<br/>&lt;script&gt;<br/>const div = document.getElementsByTagName('div')[0];<br/>div.innerHTML = "Cool"; // above div's text is replaced with "Cool"<br/>&lt;/script&gt;</pre>
<p>Notice the word <kbd>getElements</kbd>.<strong> </strong>It returns us a bunch of elements. Therefore, we pick up the first element from the <kbd>NodeList</kbd> and set its contents to <kbd>Cool</kbd>.</p>
<p><kbd>innerHTML</kbd> is used to change the HTML content inside the element you're working on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the getElementsByClassName method</h1>
                </header>
            
            <article>
                
<p>The <kbd>getElementsByClassName</kbd> method will return elements of the same class as a <kbd>NodeList</kbd> and not an <kbd>Array</kbd>! <kbd>NodeList</kbd> is not exactly an <kbd>Array</kbd>; however, it is iterable, and easily convertible into <kbd>Array</kbd> as well:</p>
<pre>&lt;span class="tag"&gt;Hello&lt;/span&gt;<br/>&lt;span class="tag"&gt;Hi&lt;/span&gt;<br/>&lt;span class="tag"&gt;Wohoo!&lt;/span&gt;<br/><br/>&lt;script&gt;<br/>const tags = document.getElementsByClassName('tag'); // This is a NodeList (not Array)<br/>try {<br/>  tags.map(tag =&gt; console.log(tag)); // ERROR! map is not a function<br/>} catch(e) {<br/>  console.log('Error ', e);<br/>}<br/><br/>[...tags].map(tag =&gt; console.log(tag)); // No error<br/>&lt;/script&gt;</pre>
<p>As said previously, <kbd>tags</kbd> is actually a <kbd>NodeList</kbd>. First, we use a <span>destructuring</span> operator and surround it with square brackets to actually convert it into an <kbd>Array</kbd>. Then we use <kbd>map</kbd> (which we can on <kbd>Array</kbd>, but cannot on <kbd>NodeList</kbd>) to iterate over every tag, that is, the <kbd>&lt;span&gt;</kbd> element, and we just console-log the element.</p>
<p>The takeaway from this code is how we used a destructuring operator in it. You'll often find yourself regularly using those important concepts we learned earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the querySelector method</h1>
                </header>
            
            <article>
                
<p>The <kbd>querySelector</kbd> method returns an element in the same way as when selecting an element through its CSS selector. However, <kbd>document.querySelector</kbd> returns only one element. Therefore, we can operate on it directly once we query for that element:</p>
<pre>&lt;div data-attr="coolDIV"&gt;Make me red!&lt;/div&gt;<br/>&lt;script&gt;<br/>document.querySelector('div[data-attr]').style.color = 'red'; // div becomes red<br/>&lt;/script&gt;</pre>
<p>It is equivalent to doing <kbd>document.querySelector('div').style.color = 'red';</kbd> if we have only one <kbd>&lt;div&gt;</kbd> tag in the body.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the querySelectorAll method</h1>
                </header>
            
            <article>
                
<p>Just like you can get any element with <kbd>querySelector</kbd>, you can get a bunch of elements matching the criteria with <kbd>querySelectorAll</kbd>. You've seen how to work with <kbd>NodeList</kbd> in the <kbd>getElementsByClass</kbd> method. Try to understand the code as follows:</p>
<pre>&lt;div data-attr="red"&gt;Make me red!&lt;/div&gt;<br/>&lt;div data-attr="blue"&gt;Make me blue!&lt;/div&gt;<br/><br/>&lt;script&gt;<br/>[...document.querySelectorAll('div[data-attr]')].map(div =&gt; {<br/>    div.style.color = div.attributes['data-attr'].value;<br/>});<br/>&lt;/script&gt;</pre>
<p>First, we're converting <kbd>NodeList</kbd> to <kbd>Array</kbd> using destructuring. Then we're mapping over the array and changing the style of each <kbd>&lt;div&gt;</kbd> according to the value of its data-attr.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modern JavaScript browser APIs</h1>
                </header>
            
            <article>
                
<p>HTML5 brought a lot of support <span>for some awesome and cool APIs</span> in JavaScript, right from the start. Although some APIs were released with HTML5 itself (such as the Canvas API), some were added later (such as the Fetch API).</p>
<p>Let's see some of these APIs and how to use them with some code examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Page Visibility API - is the user still on the page?</h1>
                </header>
            
            <article>
                
<p>The <strong>Page Visibility API</strong> allows developers to run specific code whenever the page user is on goes in focus or out of foucs. Imagine you run a game-hosting site and want to pause the game whenever the user loses focus on your tab. This is the way to go!</p>
<pre>function pageChanged() {<br/>  if (document.hidden) {<br/>    console.log('User is on some other tab/out of focus') // line #1<br/>  } else {<br/>    console.log('Hurray! User returned') // line #2<br/>  }<br/>}<br/><br/>document.addEventListener("visibilitychange", pageChanged);</pre>
<p>We're adding an event listener to the document; it fires whenever the page is changed. Sure, the <kbd>pageChanged</kbd> function gets an event object as well in the argument, but we can simply use the <kbd>document.hidden</kbd> property, which returns a Boolean value depending on the page's visibility at the time the code was called.</p>
<p>You'll add your <em>pause game</em> code at <kbd>line #1</kbd> and your <em>resume game</em> code at <kbd>line #2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">navigator.onLine API – the user's network status</h1>
                </header>
            
            <article>
                
<p>The <kbd>navigator.onLine</kbd> API tells you if the user is online or not. Imagine building a multiplayer game and you want the game to automatically pause if the user loses their internet connection. This is the way to go here!</p>
<pre>function state(e) {<br/>    if(navigator.onLine) {<br/>        console.log('Cool we\'re up');<br/>    } else {<br/>        console.log('Uh! we\'re down!');<br/>    }<br/>}<br/><br/>window.addEventListener('offline', state);<br/>window.addEventListener('online', state);</pre>
<p>Here, we're attaching two event listeners to window global. We want to call the <kbd>state</kbd> function whenever the user goes <kbd>offline</kbd> or <kbd>online</kbd>.</p>
<p>The browser will call the <kbd>state</kbd> function every time the user goes <kbd>offline</kbd> or <kbd>online</kbd>. We can access it if the user is <kbd>offline</kbd> or <kbd>online</kbd> with <kbd>navigator.onLine</kbd>, which returns a Boolean value of <kbd>true</kbd> if there's an internet connection, and <kbd>false</kbd> if there's not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clipboard API - programmatically manipulating the clipboard</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <strong>Clipboard API</strong> finally allows developers to copy to a user's clipboard without those nasty Adobe Flash plugin hacks that were not cross-browser/cross-device-friendly. Here's how you'll copy a selection to a user's clipboard:</p>
<pre>&lt;script&gt;<br/>function copy2Clipboard(text) {<br/>  const textarea = document.createElement('textarea');<br/>  textarea.value = text;<br/>  document.body.appendChild(textarea);<br/>  textarea.focus();<br/>  textarea.setSelectionRange(0, text.length);<br/>  document.execCommand('copy');<br/>  document.body.removeChild(textarea);<br/>}<br/>&lt;/script&gt;<br/><br/>&lt;button onclick="copy2Clipboard('Something good!')"&gt;Click me!&lt;/button&gt;</pre>
<p>First of all, we need the user to actually click the button. Once the user clicks the button, we call a function that creates a <kbd>textarea</kbd> in the background using the <kbd>document.createElement</kbd> method. The script then sets the value of the <kbd>textarea</kbd> to the passed text (this is pretty good!) We then focus on that <kbd>textarea</kbd> and select all the contents inside it.</p>
<p>Once the contents are selected, we execute a copy with <kbd>document.execCommand('copy')</kbd>; this copies the current selection in the document to the clipboard. Since, right now, the value inside the <kbd>textarea</kbd> is selected, it gets copied to the clipboard. Finally, we remove the <kbd>textarea</kbd> from the document so that it doesn't disrupt the document layout.</p>
<div class="packt_infobox"> You cannot trigger <kbd>copy2Clipboard</kbd> without user interaction. I mean, obviously you can, but <kbd>document.execCommand('copy')</kbd> will not work if the event does not come from the user (click, double-click, and so on). This is a security implementation so that a user's clipboard is not messed around with by every website that they visit.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Canvas API - the web's drawing board</h1>
                </header>
            
            <article>
                
<p>HTML5 finally brought in support for <kbd>&lt;canvas&gt;</kbd>, a standard way to draw graphics on the web! Canvas can be used pretty much for everything related to graphics you can think of; from digitally signing with a pen, to creating 3D games on the web (3D games require WebGL knowledge, interested? - visit <a href="http://bit.ly/webgl-101">http://bit.ly/webgl-101</a>).</p>
<p>Let's look at the basics of the Canvas API with a simple example:</p>
<pre><span>&lt;canvas id="canvas" width="100" height="100"&gt;</span><span>&lt;/canvas&gt;<br/><br/>&lt;script&gt;<br/>  const canvas = document.getElementById("canvas");<br/>  const ctx = canvas.getContext("2d");<br/>  ctx.moveTo(0,0);<br/>  ctx.lineTo(100, 100);<br/>  ctx.stroke();<br/>&lt;/script&gt;</span></pre>
<p>This renders the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/460f0d05-4c59-49c0-b610-4edf05c27ec2.png"/></div>
<p>How does it do this?</p>
<ol>
<li>Firstly, <kbd>document.getElementById('canvas')</kbd> gives us the reference to the canvas on the document.</li>
<li>Then we get the <strong>context </strong>of the canvas. This is a way to say what I want to do with the canvas. You could put a 3D value there, of course! That is indeed the case when you're doing 3D rendering with WebGL and canvas.</li>
<li>Once we have a reference to our context, we can do a bunch of things and add methods provided by the API out-of-the-box. Here we moved the cursor to the (0, 0) coordinates.</li>
<li>Then we drew a line till (100,100) (which is basically a diagonal on the square canvas).</li>
<li>Then we called stroke to actually draw that on our canvas. Easy!</li>
</ol>
<div class="packt_tip packt_infobox">Canvas is a wide topic and deserves a book of its own! If you're interested in developing awesome games and apps with Canvas, I recommend you start off with MDN docs: <a href="http://bit.ly/canvas-html5">http://bit.ly/canvas-html5.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Fetch API - promise-based HTTP requests</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the coolest async APIs introduced in browsers is the Fetch API, which is the modern replacement for the <kbd>XMLHttpRequest</kbd> API. Have you ever found yourself using jQuery just for simplifying AJAX requests with $.ajax? If you have, then this is surely a golden API for you, as it is <strong>natively</strong> easier to code and read!</p>
<p>If you remember, we created a promised version of <kbd>XMLHttpRequest</kbd> ourselves in <span><a href="d37a4519-f5c0-4f5b-a3b4-df5e0091949e.xhtml">Chapter 4</a>,</span> <em>Asynchronous Programming</em>. However, <kbd>fetch</kbd> comes natively, hence, there are performance benefits. Let's see how it works:</p>
<pre>fetch(link) <br/>.then(data =&gt; {<br/>    // do something with data<br/>})<br/>.catch(err =&gt; {<br/>    // do something with error<br/>});</pre>
<p>Awesome! So <kbd>fetch</kbd> uses promises! If that's the case, we can combine it with async/await to make it look completely synchronous and easy to read!</p>
<pre>&lt;img id="img1" alt="Mozilla logo" /&gt;<br/>&lt;img id="img2" alt="Google logo" /&gt;<br/><br/>const get2Images = async () =&gt; {<br/>    const image1 = await fetch('https://cdn.mdn.mozilla.net/static/img/web-docs-sprite.22a6a085cf14.svg');<br/>    const image2 = await fetch('https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png');<br/>    console.log(image1); // gives us response as an object<br/>    const blob1 = await image1.blob();<br/>    const blob2 = await image2.blob();<br/>    <br/>    const url1 = URL.createObjectURL(blob1);<br/>    const url2 = URL.createObjectURL(blob2);<br/><br/>    document.getElementById('img1').src = url1;<br/>    document.getElementById('img2').src = url2;<br/><br/>    return 'complete';<br/>}<br/><br/>get2Images().then(status =&gt; console.log(status));</pre>
<p>The line <kbd>console.log(image1)</kbd> will print the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f355a7bf-0469-4cf0-a82b-578d2138be98.png"/></div>
<p>You can see the <kbd>image1</kbd> response provides tons of information about the request. It has an interesting field body, which is actually a <kbd>ReadableStream</kbd>, and a byte stream of data that can be cast to a  <strong>Binary Large Object</strong> (<strong>BLOB</strong>) in our case.</p>
<div class="packt_infobox">A <kbd><span>blob</span></kbd> object represents a file-like object of immutable and raw data.</div>
<p>After getting the <kbd>Response</kbd>, we convert it into a <kbd>blob</kbd> object so that we can actually use it as an image. Here, fetch is actually fetching us the image directly so we can serve it to the user as a <kbd>blob</kbd> (without hot-linking it to the main website).</p>
<p>Thus, this could be done on the server side, and <kbd>blob</kbd> data could be passed down a WebSocket or something similar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch API customization</h1>
                </header>
            
            <article>
                
<p>The Fetch API is highly customizable. You can even include your own headers in the request. Suppose you've got a site where only authenticated users with a valid token can access an image. Here's how you'll add a custom header to your request:</p>
<pre>const headers = new Headers();<br/>headers.append("Allow-Secret-Access", "yeah-because-my-token-is-1337");<br/><br/>const config = { method: 'POST', headers };<br/><br/>const req = new Request('http://myawesomewebsite.awesometld/secretimage.jpg', config);<br/><br/>fetch(req)<br/>.then(img =&gt; img.blob())<br/>.then(blob =&gt; myImageTag.src = URL.createObjectURL(blob));</pre>
<p>Here, we added a custom header to our <kbd>Request</kbd> and then created something called a <kbd>Request</kbd> object (an object that has information about our <kbd>Request</kbd>). The first parameter, that is, <kbd>http://myawesomewebsite.awesometld/secretimage.jpg</kbd>, is the URL and the second is the configuration. Here are some other configuration options:</p>
<ul>
<li><strong>Credentials</strong>: Used to pass cookies in a <span><strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong></span><span>)</span>-enabled server on cross-domain requests.</li>
<li><strong>Method</strong>: Specifies request methods (GET, POST, HEAD, and so on).</li>
<li><strong>Headers</strong>:<strong> </strong>Headers associated with the request.</li>
<li><strong>Integrity</strong>: A security feature that consists of a (possibly) SHA-256 representation of the file you're requesting, in order to verify whether the request has been tampered with (data is modified) or not. Probably not a lot to worry about unless you're building something on a very large scale and not on HTTPS.</li>
<li><strong>Redirect</strong>: Redirect can have three values:<br/>
<ul>
<li><span>Follow: Will follow the URL </span>redirects</li>
<li>Error:<span> Will throw an error if the URL </span>redirects</li>
<li>Manual:<span> Doesn't follow redirect but returns a filtered response that wraps the redirect response</span></li>
</ul>
</li>
<li><strong>Referrer</strong>: the URL that appears as a referrer header in the HTTP request.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing and modifying history with the history API</h1>
                </header>
            
            <article>
                
<p>You can access a user's history to some level and modify it according to your needs using the <kbd>history</kbd> API. It consists of the length and state properties:</p>
<pre>console.log(history, history.length, history.state);</pre>
<p>The output is as follows:</p>
<pre><strong>{length: 4, scrollRestoration: "auto", state: null}</strong><br/><strong>4</strong><br/><strong>null</strong></pre>
<p>In your case, the <kbd>length</kbd> could obviously be different depending on how many pages you've visited from that particular tab.</p>
<p><kbd>history.state</kbd> can contain anything you like (we'll come to its use case soon). Before looking at some handy history methods, let us take a look at the <kbd>window.onpopstate</kbd> event.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling window.onpopstate events</h1>
                </header>
            
            <article>
                
<p>The<strong> </strong><span><kbd>window.onpopstate</kbd> event</span> <span>is fired automatically by the browser when a user navigates between history states that a developer has set. This event is important to handle when you push to history object and then later retrieve information whenever the user presses the <span class="packt_screen">back</span>/<span class="packt_screen">forward</span> button of the browser.</span></p>
<p>Here's how we'll program a simple <kbd>popstate</kbd> event:</p>
<pre>window.addEventListener('popstate', e =&gt; {<br/>    console.log(e.state); // state data of history (remember history.state ?)<br/>})</pre>
<p>Now we'll discuss some methods associated with the <kbd>history</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying history - the history.go(distance) method</h1>
                </header>
            
            <article>
                
<p><span><kbd>history.go(x)</kbd> i</span>s equivalent to the user clicking his forward button <kbd>x</kbd> times in the browser. However, you can specify the distance to move, that is <kbd>history.go(5);</kbd> . This equivalent to the user hitting the <span class="packt_screen">forward</span> button in the browser five times.</p>
<p>Similarly, you can specify negative values as well to make it move backward. Specifying 0 or no value will simply refresh the page:</p>
<pre>history.go(5); // forwards the browser 5 times<br/>history.go(-1); // similar effect of clicking back button<br/>history.go(0); // refreshes page<br/>history.go(); // refreshes page</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jumping ahead - the history.forward() method</h1>
                </header>
            
            <article>
                
<p>This method is simply the equivalent of <kbd>history.go(1)</kbd>. </p>
<p>This is handy when you want to just push the user to the page he/she is coming from. One use case of this is when you can create a full-screen immersive web application and on your screen there are some minimal controls that play with the history behind the scenes:</p>
<pre>if(awesomeButtonClicked &amp;&amp; userWantsToMoveForward()) {<br/>    history.forward()<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going back - the history.back() method</h1>
                </header>
            
            <article>
                
<p>This method is simply the equivalent of <kbd>history.go(-1)</kbd>.</p>
<p>A negative number, makes the history go backwards. Again, this is just a simple (and numberless) way to go back to a page the user came from. Its application could be similar to a <span class="packt_screen">forward</span> button, that is, creating a full-screen web app and providing the user with an interface to navigate by.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing on the history - history.pushState()</h1>
                </header>
            
            <article>
                
<p>This is really fun. You can change the browser URL without hitting the server with an HTTP request. If you run the following JS in your browser, your browser will change the path from whatever it is (<kbd>domain.com/abc/egh</kbd>) to  <kbd>/i_am_awesome</kbd> (<kbd>domain.com/i_am_awesome</kbd>) without actually navigating to any page:</p>
<pre>history.pushState({myName: "Mehul"}, "This is title of page", "/i_am_awesome");<br/>history.pushState({page2: "Packt"}, "This is page2", "/page2_packt"); // &lt;-- state is currently here</pre>
<p>The History API doesn't care whether the page actually exists on the server or not. It'll just replace the URL as it is instructed.</p>
<p>The  <kbd>popstate</kbd> event when triggered with the browser's back/forward button, will fire the function below and we can program it like this:</p>
<pre>window.onpopstate = e =&gt; { // when this is called, state is already updated.<br/>    // e.state is the new state. It is null if it is the root state.<br/>    if(e.state !== null) {<br/>        console.log(e.state);<br/>    } else {<br/>        console.log("Root state");<br/>    }<br/>}</pre>
<p>To run this code, run the <kbd>onpopstate</kbd> event first, then the two lines of <kbd>history.pushState</kbd> previously. Then press your browser's back button. You should see something like:</p>
<pre><strong>{myName: "Mehul"}</strong></pre>
<p>which is the information related to the parent state. Press back button one more time and you'll see the message <kbd>Root State</kbd>.</p>
<p class="mce-root"/>
<div class="packt_infobox"><kbd>pushState</kbd> does not fire <kbd>onpopstate</kbd> event. Only browsers' back/forward buttons do. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing on the history stack - history.replaceState()</h1>
                </header>
            
            <article>
                
<p> The <kbd>history.replaceState()</kbd> method is exactly like <kbd>history.pushState()</kbd>, the only difference is that it replaces the current page with another, that is, if you use <kbd>history.pushState()</kbd> and press the <span class="packt_screen">back</span> button, you'll be directed to the page you came from.</p>
<p>However, when you use <kbd>history.replaceState()</kbd> and you press the <span class="packt_screen">back</span> button, you are not directed to the page you came from because it is replaced with the new one on the stack. Here's an example of working with the <kbd>replaceState</kbd> method:</p>
<pre>history.replaceState({myName: "Mehul"}, "This is title of page", "/i_am_awesome");</pre>
<p>This replaces (instead of pushing) the current state with the new state.</p>
<div class="packt_tip packt_infobox">Although using the History API directly in your code may not be beneficial to you right now, many frameworks and libraries such as React, under the hood, use the History API to create a seamless, reload-less, smooth experience for the end user.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered some of the best APIs introduced by HTML5 and modern JavaScript together, and how they are shaping the way people browse and interact with websites.</p>
<p>In the next chapter, we'll take a brief overview of the HTTP protocol and some storage APIs available in JavaScript that can be used to store data locally and communicate with the server. Let's go!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>