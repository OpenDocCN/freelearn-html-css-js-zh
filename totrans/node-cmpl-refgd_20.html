<html><head></head><body><div><h1 class="header-title">Modules and Toolkits</h1>
                
            
            
                
<p>Now that we have reviewed what Node.js's new features are, and now that we know what a microservice is, it's time to see what tools or modules we can we to create one. We'll review a couple of options and build a more or less simple microservice so that we can point out advantages and disadvantages for each approach.</p>
<p>We'll look at different modules:</p>
<ul>
<li><strong>Seneca</strong>: A microservice toolkit based on property matching</li>
<li><strong>Hydra</strong>: A package that bundles a couple of modules to help you resolve many microservices concerns, such as distribution and monitoring</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Seneca</h1>
                
            
            
                
<p>Let's look at framework called Seneca which was designed to help you develop message-based microservices. It has two distinct characteristics:</p>
<ul>
<li><strong>T</strong><strong>ransport agnostic</strong>: Communication and message transport is separated from your service logic and it's easy to swap transports</li>
<li><strong>Pattern matching</strong>: Messages are JSON objects and each function exposes what sort of messages they can handle based on object properties</li>
</ul>
<p class="mce-root">What is really interesting about Seneca is its ability to expose functions based on object patterns. Let's start by installing Seneca:</p>
<pre><strong>npm install seneca</strong></pre>
<p class="mce-root">For now, let's forget the transport and create a producer and consumer in the same file. Let's look at an example:</p>
<pre>const seneca  = require("seneca");<br/>const service = seneca();<br/><br/>service.add({ math: "sum" }, (msg, next) =&gt; {<br/>    next(null, {<br/>        sum : msg.values.reduce((total, value) =&gt; (total + value), 0)<br/>    });<br/>});<br/><br/>service.act({ math: "sum", values: [ 1, 2, 3 ] }, (err, msg) =&gt; {<br/>    if (err) return console.error(err);<br/><br/>    console.log("sum = %s", msg.sum);<br/>});</pre>
<p>We first include the <kbd>seneca</kbd> module and create a new service. We then expose a producer function that matches an object that has <kbd>math</kbd> equal to <kbd>sum</kbd>. This means that any request object to the service that has the property <kbd>math</kbd> and that is equal to <kbd>sum</kbd> will be passed to this function. This function accepts two arguments. The first, which we called <kbd>msg</kbd>, is the request object. The second argument, <kbd>next</kbd>, is the callback that the function should invoke when finished or in case of an error. In this particular case, we're expecting an object that also has a <kbd>values</kbd> list and we're returning the sum of all values by using the <kbd>reduce</kbd> method that's available in arrays. Finally, we invoke <kbd>act</kbd>, expecting it to consume our producer. We pass an object with the <kbd>math</kbd> equal to <kbd>sum</kbd> and a list of <kbd>values</kbd>. Our producer should be invoked and should return the sum.</p>
<p>Assuming you have this code in <kbd>app.js</kbd>, if you run this in the command line, you should see something like this:</p>
<pre style="line-height: 24.0pt"><strong>$ node app<br/>sum = 6</strong></pre>
<p>Let's try and replicate our previous stack example. This time, instead of having the consumer and producer in the code, we'll use <kbd>curl</kbd> as the consumer, just like we did previously.</p>
<p>First, we need to create our <kbd>service</kbd>. We do that, as we've seen before, by loading Seneca and creating an instance:</p>
<pre>const seneca  = require("seneca");<br/>const service = seneca({ log: "silent" });</pre>
<p>We explicitly tell it that we don't care about logging for now. Now, let's create a variable to hold our stack:</p>
<pre>const stack = [];</pre>
<p>We then create our producers. We'll create three of them: one for adding an element to the stack, called push; one to remove the last element from the stack, called pop; and one to see the stack, called get. Both push and pop will return the final stack result. The third producer is just a helper function so that we can see the stack without performing any operations.</p>
<p>To add elements to the stack, we define:</p>
<pre>service.add("stack:push,value:*", (msg, next) =&gt; {<br/>    stack.push(msg.value);<br/><br/>    next(null, stack);<br/>});</pre>
<p>There are a few new things to see here:</p>
<ul>
<li>We defined our pattern as a string instead of an object. This action string is a shortcut to the extended object definition.</li>
<li>We explicitly indicate that we need a value.</li>
<li>We also indicate that we don't care what the value is (remember, this is pattern matching).</li>
</ul>
<p>We now define a simpler function to remove the last element of the <kbd>stack</kbd>:</p>
<pre>service.add("stack:pop", (msg, next) =&gt; {<br/>    stack.pop();<br/><br/>    next(null, stack);<br/>});</pre>
<p>This one is simpler as we don't need a value, we're just removing the last one. We're not addressing the case where the stack is empty already. An empty array won't throw an exception, but perhaps, in a real scenario, you would want another response.</p>
<p>Our third function is even simpler as we just return the <kbd>stack</kbd>:</p>
<pre>service.add("stack:get", (msg, next) =&gt; {<br/>    next(null, stack);<br/>});</pre>
<p>Finally, we need to tell our <kbd>service</kbd> to listen for messages. The default transport is HTTP and we just indicate port <kbd>3000</kbd> as we did in our previous examples:</p>
<pre>service.listen(3000);</pre>
<p>Wrap all this code in a file and try it out. You can use curl or just try it in your browser. Seneca won't differentiate between HTTP verbs in this case. Let's begin by checking our <kbd>stack</kbd>. The URL describes an action (<kbd>/act</kbd>) we want to perform and the query parameter gets converted to our pattern:</p>
<div><img src="img/5f272cfa-7bc7-445b-b506-7494b9365918.png" width="1151" height="532"/></div>
<p>We can then try adding the value <kbd>one</kbd> to our <kbd>stack</kbd> and see the final <kbd>stack</kbd>:</p>
<div><img src="img/2fd2bb60-ddae-48aa-a36f-8150eb30f4f6.png" width="1328" height="637"/></div>
<p>We can continue and add the value <kbd>two</kbd> and see how the <kbd>stack</kbd> grows:</p>
<div><img src="img/9765d76f-b004-469f-9582-fbeebe6a33df.png" width="1304" height="481"/></div>
<p>If we then try to remove the last element, we'll see the <kbd>stack</kbd> shrinking:</p>
<div><img src="img/5d18267f-0b27-4d44-acc9-af7b2ef87ed1.png" width="1230" height="499"/></div>
<p>As in Express, Seneca also has middleware that you can install and use. In this case, the middleware is called plugins. By default, Seneca includes a number of core plugins for transport, and both HTTP and TCP transports are supported. There are more transports available, such as <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>) and Redis.</p>
<p>There are also storage plugins for persistent data and there's support for several database servers, both relational and non-relational. Seneca exposes an <strong>o</strong><strong>bject-relational mapping</strong> (<strong>ORM</strong>)-like interface to manage data entities. You can manipulate entities and use a simple storage in development and then move to production storage later on. Let's see a more complex example of this:</p>
<pre>const async   = require("async");<br/>const seneca  = require("seneca");<br/>const service = seneca();<br/><br/>service.use("basic");<br/>service.use("entity");<br/>service.use("jsonfile-store", { folder : "data" });<br/><br/>const stack = service.make$("stack");<br/><br/>stack.load$((err) =&gt; {<br/>    if (err) throw err;<br/><br/>    service.add("stack:push,value:*", (msg, next) =&gt; {<br/>        stack.make$().save$({ value: msg.value }, (err) =&gt; {<br/>            return next(err, { value: msg.value });<br/>        });<br/>    });<br/><br/>    service.add("stack:pop,value:*", (msg, next) =&gt; {<br/>        stack.list$({ value: msg.value }, (err, items) =&gt; {<br/>            async.each(items, (item, next) =&gt; {<br/>                item.remove$(next);<br/>            }, (err) =&gt; {<br/>                if (err) return next(err);<br/><br/>                return next(err, { remove: items.length });<br/>            });<br/>        });<br/>    });<br/><br/>    service.add("stack:get", (msg, next) =&gt; {<br/>        stack.list$((err, items) =&gt; {<br/>            if (err) return next(err);<br/><br/>            return next(null, items.map((item) =&gt; (item.value)));<br/>        });<br/>    });<br/><br/>    service.listen(3000);<br/>});</pre>
<p>Just run this new code and we'll see how this code behaves by making some requests to test it. First, let's see how our <kbd>stack</kbd> is by requesting it:</p>
<div><img src="img/8562bd7e-ce15-4e5f-ab0e-afd983610ba2.png" width="1260" height="568"/></div>
<p>Nothing different. Now, let's add the value <kbd>one</kbd> to the <kbd>stack</kbd>:</p>
<div><img src="img/5e8c79dc-6ed3-4ccd-a429-7bc3cdcf5621.png" width="1408" height="597"/></div>
<p>Well, we haven't received the final <kbd>stack</kbd>. We could, but instead we changed the service to return the exact item that was added. It's actually a good way to confirm what we just did. Let's add another one:</p>
<div><img src="img/d0a0b98b-9518-4224-8496-916a3097902b.png" width="1379" height="530"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Again, it returns the value we just added. Now, let's see how our stack is:</p>
<div><img src="img/c5189716-9284-48e2-b6bc-a82ebaa670cc.png" width="1288" height="506"/></div>
<p>Our <kbd>stack</kbd> now has our two values. Now comes one big difference compared with the previous code. We're using <em>entities</em>, an API exposed by Seneca, which helps you store and manipulate data objects using a simple abstraction layer similar to an ORM, or to people who are familiar with Ruby, an <kbd>ActiveRecord</kbd>.</p>
<p>Our new code, instead of just popping out the last value, removes a value we indicate. So, let's remove the value <kbd>one</kbd> instead of <kbd>two</kbd>:</p>
<div><img src="img/bf96bdff-3fd7-4ba4-b597-8a39a1e10cf1.png" width="1381" height="518"/></div>
<p>Success! We removed exactly one item. Our code will remove all items from the <kbd>stack</kbd> that match the value (it has no duplication check so you can have repeated items). Let's try to remove the same item again:</p>
<div><img src="img/98a3dabd-f496-4b1a-a365-6e95ee918e80.png" width="1335" height="472"/></div>
<p>No more items match <kbd>one</kbd>, so it didn't remove anything. We can now check our <kbd>stack</kbd> and confirm that we still have the value <kbd>two</kbd>:</p>
<div><img src="img/8ddfe232-1446-4940-9a93-75ed0c3d7690.png" width="1243" height="453"/></div>
<p>Correct! And, as a bonus, you can stop and restart the code and your stack will still have the value <kbd>two</kbd>. That's because we're using the JSON file store plugin.</p>
<p>When testing using Chrome or any other browser, be aware that sometimes, browsers make requests in advance while you're typing. Because we already tested our first code, which had the same URL addresses, the browser might duplicate requests and you might get a stack with duplicated values without knowing why. This is why.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hydra</h1>
                
            
            
                
<p>Let's get back to Express. As you've seen before, it's a rock-solid layer on top of the <kbd>http</kbd> module. Although it adds an important base layer in the somewhat raw module, it still lacks many features you need to make a good microservice.</p>
<p>As there are lots of plugins out there to extend Express, it can be hard to pick a useful list for us to use.</p>
<p>After picking the right list, you'll still need to make other decisions:</p>
<ul>
<li>How can I distribute my service with multiple instances?</li>
<li>How can the service be discovered?</li>
<li>How can I monitor whether my service is running properly?</li>
</ul>
<p>Enter Hydra, a framework that facilitates building distributed microservices. Hydra leverages the power of Express and helps you create microservices or communicate with microservices.</p>
<p>It will, out of the box, enable you to:</p>
<ul>
<li>Do service registration and service discovery, allowing your microservices to discover and be discoverable</li>
<li>Communicate with microservices and load balance communication between multiple instances, taking care of failed instances and automatically rerouting requests to other running instances</li>
<li>Monitor instances, checking whether the microservice is available and operating normally</li>
</ul>
<p>Unlike the other modules we've reviewed so far, Hydra has a dependency that is not installable directly using the NPM. Hydra uses Redis to accomplish its goal. Look for information on the Redis website at <a href="https://redis.io/">https://redis.io/</a> to install it on your operating system before continuing. If you have macOS and use Homebrew, type the following to install <kbd>redis</kbd>:</p>
<div><img src="img/dfdb0104-7906-4919-ad18-48f4839b8d5d.png" width="1461" height="386"/></div>
<p>Now, let's make sure <kbd>redis</kbd> has successfully started:</p>
<div><img src="img/df9525cb-5e2b-44ca-9948-288dff2a4572.png" width="1007" height="284"/></div>
<p>After that, we need to install Hydra command-line tools:</p>
<pre><strong>sudo npm install -g yo generator-fwsp-hydra hydra-cli</strong></pre>
<p>We now need to configure the connection to Redis. We do this by creating a configuration. Type in the command and follow the instructions. If you installed it locally (or used the preceding instructions), you should answer something similar to the following screenshot:</p>
<div><img src="img/130a1c25-01fb-4389-8c74-a56a66fd5fcc.png" style="width:28.75em;height:11.25em;" width="773" height="302"/></div>
<p>Now, let's create a very simple microservice, just to see what the workflow is like. Hydra has a scaffolding tool using <kbd>yeoman</kbd>. To create a service, type the following command and follow the instructions:</p>
<div><img src="img/3d00ff9e-fda1-423a-a9bc-edda341e9ba6.png" style="width:41.33em;height:37.00em;" width="1117" height="999"/></div>
<p>On the name of the service, just type hello. Just hit <em>Enter</em> to the rest of the questions to use the defaults. In the end, enter the folder that was created and install the dependencies:</p>
<div><img src="img/11d89f4f-7424-42a5-8cdd-01f69cc1d427.png" width="1045" height="332"/></div>
<p>The service is now ready to start. You might have already seen the instructions when scaffolding the service. Let's start the service:</p>
<div><img src="img/b745a179-c4e5-461a-abbc-4a6bf684b7f6.png" width="1136" height="485"/></div>
<p>As we can see from the preceding screenshot, the service has started and has been attached to a local IP (192.168.1.108) and port (45394). Open up the folder in your code editor:</p>
<div><img src="img/774328d2-8714-43d2-8db1-85995dce6e95.png" width="1778" height="1157"/></div>
<p>You'll see a file in the base folder called <kbd>hello-service.js</kbd>, which has the service routes inside it. You'll find the <kbd>/v1/hello</kbd> route, which points to another file in <kbd>routes/hello-v1-routes.js</kbd>:</p>
<div><img src="img/ebd2d928-eeac-4e32-a563-343dbc72f82f.png" width="1871" height="1163"/></div>
<p>Inside that file, you'll see the response to that route. Now, let's jump to a web browser and see if it's up and running:</p>
<div><img src="img/8b40b263-ed17-48dd-bcab-979f1083384d.png" width="1453" height="606"/></div>
<p>What we saw in the file is inside the result property of the JSON response. We just deployed our first Hydra microservice without writing a single line of code!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>We've just covered a range of different modules and toolkits to help develop microservices. From patterns in Seneca, to the Hydra bundle, many approaches are available.</p>
<p>They all target different audiences and fill different needs. I would advise you to experiment with some of them to help you make a better choice instead of just picking one.</p>
<p>Let's dig into some of these tools and start creating a more complete microservice. In the next chapter, we'll be making a useful microservice, covering different use cases, while we develop a fully functional and distributed microservice.</p>


            

            
        
    </div>



  </body></html>