<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design Patterns</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we successfully deployed our service to a cloud provider without having to fundamentally change our code. We used a database to store our data, and the only thing we needed to do was to point to the new location.</p>
<p>It's common, during the specification and development process, to have challenging problems with one or more ways of solving them. The ways, or paths, you choose throughout the development are called design patterns, as they're part of your design.</p>
<p>Some design patterns are more common than others. Some are well-known, others, not so much. Some are good design patterns and you should follow them. Others are bad because of the disadvantages they bring in the short or long term.</p>
<p>In this chapter, we're going to take a look at the importance of choosing good patterns; we will look at some common architectural patterns and review the continuous integration we followed through the entire book until we successfully deployed to the cloud.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Choosing patterns</h1>
                </header>
            
            <article>
                
<p>Patterns are not libraries or classes, they're concepts, reusable solutions to common programming problems, tested and optimized for specific use cases. As they're just concepts to solve specific problems, they have to be implemented in every language.</p>
<p>Every pattern has its advantages and disadvantages, and choosing a wrong pattern for a problem can cause you a big headache.</p>
<p class="mce-root"/>
<p>Patterns can speed up the development process because they provide well-tested and well-proven development paradigms. Reusing patterns helps prevent issues and improves code readability between developers that are familiar with the patterns.</p>
<p>Patterns have major importance in high-performance applications. Sometimes, in order to achieve some flexibility, patterns introduce a new level of indirection in the code, which may reduce performance. You should choose when to introduce a pattern or when that introduction will hurt the performance metric you're targeting.</p>
<p>Knowing good patterns is essential for avoiding the opposite: anti-patterns. An anti-pattern is something that looks good in the beginning but later on turns out to look like the worst decision you ever made. Anti-patterns are not specific patterns but are more like common errors, seen by the majority as strategies you shouldn't use. Some of the most common and frequent anti-patterns seen out there are:</p>
<ul>
<li><strong>Repeating yourself</strong>: Don't repeat excessive parts of the code. Lean back, look at the big picture and refactor it. Some developers tend to look at this refactoring as a complexity of the application, but it can actually turn your application simpler. If you think you won't be able to understand the simplicity of your refactoring, don't forget to add a couple of introductory comments to the code.</li>
<li><strong>Golden hammer or silver bullet</strong>: Don't think your favorite language or framework is universally applicable. Most of the languages can actually do practically anything, at least the mature ones, and with a huge community. That doesn't mean a language performs some tasks well. If your goal is performance, try to have a couple of hammers in your belt.</li>
<li><strong>Coding by exception</strong>: Don't add new code to handle new cases as they appear. By new cases, I don't mean new features; I mean behavior your code was not expecting. For example, when you're making a file upload feature of some kind, remember an error might happen during transfer, the file can be empty, have weird content, be huge, and so on.</li>
<li><strong>Programming by accident</strong>: Don't program by trial and error until you succeed. This is something you should really avoid. Programming by accident can sometimes make your code work in some cases (by accident) and produce erroneous behaviors in others.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Architectural patterns</h1>
                </header>
            
            <article>
                
<p>When developing microservices and, more specifically, an ecosystem of microservices, some patterns become very obvious, and you'll use them without knowing. Just looking at the architectural patterns, here are some that you might find interesting. Perhaps you have already used them before.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Front Controller</h1>
                </header>
            
            <article>
                
<p>The <strong>Front Controller</strong> pattern is when all requests go for a single point in your architecture, called the handler, which then processes and dispatches the requests to other handlers. This is the pattern used by, for example, load balancers and reverses proxies:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9d6b169f-e015-4e4b-a9fb-6f19784bcdb9.png" style="width:26.17em;height:15.17em;" width="381" height="221"/></div>
<p>It's useful to scale horizontally, especially when the <strong>Front Controller</strong> is just routing requests, so it can handle a lot more requests than each separate controller, which need, some time to actually process each request.</p>
<p>This pattern is also very useful in helping other services not having to know where the controllers are and choosing the one with the lowest load that should handle the request faster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layered</h1>
                </header>
            
            <article>
                
<p>The layered pattern is common in filesystems and operative systems (and virtual machines for that matter). This pattern consists of creating different layers that go from the raw data through to the data seen by a user:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b9108de4-0f45-4c97-b35e-1a5fae26a05f.png" style="width:9.75em;height:22.17em;" width="141" height="321"/></div>
<p>The idea is to separate the complexity of the different layers, each one not having to know how the others do their tasks:</p>
<ul>
<li>Handling the data structures and storing them in a fast and secure way</li>
<li>Manipulating the data structures and adding business logic to them</li>
<li>Handling user requests and showing the data in a localised format</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Service Locator</h1>
                </header>
            
            <article>
                
<p>The <strong>Service Locator</strong> pattern is actually an anti-pattern. It's not considered a good practice because it adds much more complexity to an ecosystem. The pattern consists of a central registry, called a <strong>Service Locator</strong>, where services register their abilities, and other services can consult the registry and know where the services they need are located:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8726196c-a92f-4b0c-a0f2-aed006649424.png" style="width:25.17em;height:14.58em;" width="381" height="221"/></div>
<p>The <strong>Service Locator</strong> is similar to the Front Controller, but with added complexity, as you need to contact the Service Locator and the service you need, instead of just making a simple request to a Front Controller.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Observer</h1>
                </header>
            
            <article>
                
<p>The Observer pattern is used every day in Node.js. It consists of a <strong>Subject</strong>, which maintains a list of dependents, called Observers, which get notified of any state change happening on the <strong>Subject</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0035ea4e-a748-478e-81cc-246dfedcf072.png" style="width:24.42em;height:17.25em;" width="341" height="241"/></div>
<p>You can see this happening every time in your web browser when some code (<strong>Observer</strong>) attaches an event listener to an object or interface element (<strong>Subject</strong>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Publish-Subscribe</h1>
                </header>
            
            <article>
                
<p>Another very similar pattern is the Publish-Subscribe pattern, usually abbreviated as <strong>Pub-Sub</strong>. This pattern is almost exactly the same as the previous one. You have Subscribers that, as the name implies, subscribe to a specific event, or topic, or whatever you want to call it, and then you have Publishers that emit those events or send information to those topics:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d76f8596-5cfc-4d66-97ae-7bf57f0051ae.png" style="width:29.42em;height:12.83em;" width="461" height="201"/></div>
<p>The difference to the previous pattern may look very thin but is actually very important. The <strong>Pub-Sub</strong> pattern involves a third-party service and, unlike the Observer pattern, the Publishers have no knowledge of the Subscribers. This removes the need to handle and directly notify the Subscribers, thereby simplifying your code.</p>
<p>This pattern is quite useful for microservice communication. It involves a third party that abstracts the state change notification. Also, Publishers and Subscribers have no knowledge of each other.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using patterns</h1>
                </header>
            
            <article>
                
<p>Choosing good design patterns is essentially choosing best practices. Not all design patterns fit every purpose, but for many scenarios, they'll make your life easier. Perhaps you may not notice any difference in the beginning, but you should in the long-term.</p>
<p>Good design patterns also have indirect advantages. You'll find more documentation and examples online, as well as a broader set of options to choose from, for example, when using the Publish-Subscribe pattern, where you'll find many types of implementations to integrate with your services.</p>
<p>Choosing the pattern that fits your needs also involves planning and knowing what you need and what you'll need in the future. Think of the edge cases and see if the pattern is capable of handling them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Planning your microservice</h1>
                </header>
            
            <article>
                
<p>Developing a microservice may look like a simple task. As the name implies, it is a micro service. But that is not necessarily true, as sometimes we tend to complexify something that should be simple.</p>
<p>This does not mean a service should be simple, it can be quite complex. What should be simple is the goal and the properties of the service. There shouldn't be any doubt regarding what it does and what it shouldn't do.</p>
<p>Before writing any line of code, you should start by knowing a couple of what I call characteristics of the service, such as:</p>
<ul>
<li>What is it for? What tasks will it do?</li>
<li>What other services will use it? What protocol will it speak?</li>
<li>Will it replace another service? Will it cover the same tasks?</li>
</ul>
<p>This can be summed in one word—purpose. If you don't clearly define its purpose and just start developing tasks it can handle, you'll end up having a mixed service that deviates from the main goal of a microservice.</p>
<p>After having a proper purpose, you can then choose the best pattern and plan the individual tasks. The first task will probably take longer to develop, as you're creating the base layout for the service.</p>
<p>Don't forget to add tests, coverage, and documentation as soon as possible. I know this is something most developers tend to ignore, but it will bite you later. It's easier to add a simple test for a first simple task. Code coverage is easier at this point. Adding documentation should also be easier if you're planning the individual tasks.</p>
<p>After having your first task, with a proper test, you should set your first deploy. This will end your first development cycle and bring you back to planning. If you keep this loop going, with small tasks, you'll develop faster, and deploy faster:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f8b06c25-bf65-4bf1-be50-7ba83cd2977f.png" style="width:23.08em;height:15.83em;" width="381" height="261"/></div>
<p>This type of simple loop with small tasks will allow you to do what is called <strong>continuous integration</strong> and <strong>continuous deployment</strong>, where you're able to develop and deploy to a testing cluster. The change can be automatically tested and deployed if everything passes the tests.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Obstacles when developing</h1>
                </header>
            
            <article>
                
<p>As we saw previously, a microservice architecture has many advantages, such as splitting code into smaller isolated projects, where it becomes easier to develop or even delegate responsibility.</p>
<p>These advantages come at a cost, which is the build of a more complex system or application. Because of how microservices are supposed to work, an information barrier is intrinsic. A microservice responsible for a type of information should be the only one manipulating it, forcing any other service to communicate with it to have access to information.</p>
<p>This gives you a finer control over the information because you know the service responsible for it, and you can force service or user authentication, with authorization or even rate-access limits. But, this means that a complex application will tend to penalize the network as there will be significant inter-service messaging.</p>
<p>Inter-service messaging means network traffic and latency. If the services are not on the same local network, this will eventually create noticeable latency. Adding some kind of cache service to accelerate access will also add more complexity.</p>
<p>Although testing and development for each microservice should be easier than a monolith application, looking at the microservice test frameworks all together, and having two or more services test together, is more complicated.</p>
<p>Finally, avoid something called a nanoservice. This is considered an anti-pattern, and it's when you exaggerate on fine-graining your architecture and create overly  small services, complexifying your development to the extreme.</p>
<p>Find a good balance between the number of microservices and what each will do. Think of them as a person that will handle a specific task. Is the task too simple to have one person allocated to do just that? Shouldn't the person have a broader set of tasks from the same context?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Today's applications have space for microservices. Applications are no longer monolith and left the traditional computer architecture long ago. Users constantly demand integrations and interoperability between applications.</p>
<p>Microservices help developers to reduce the complexity of applications by separating different contexts, such as frontend, backend, mobile, or a simple API. They're a concept, or a pattern, that, when used well, can give you great power, and split complexity and responsibility.</p>
<p>But, microservices are more than that. Microservices help you scale horizontally by just replicating the services you need and not a complete monolith application, saving resources and, ultimately, money.</p>
<p>There's a lot to explore out there; we have just scratched the surface. There are plenty of cloud providers and tools for you to experiment with and choose what fits you best. Remember, practice makes perfect, so head to your work desk, and good luck!</p>


            </article>

            
        </section>
    </div>



  </body></html>