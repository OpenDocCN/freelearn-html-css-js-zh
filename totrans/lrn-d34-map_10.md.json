["```js\nvar width = 960,\n    height = 600,\n    projectionScale = height / 2.1,\n    translation = [width / 2, height / 2];\n```", "```js\nvar canvas = d3.select('#canvas-container').append('canvas')\n    .attr('id', 'canvas-globe')\n    .attr('width', width)\n    .attr('height', height);\nvar context = canvas.node().getContext('2d');\n```", "```js\nvar bufferCanvas = document.createElement('canvas');\nvar bufferContext = bufferCanvas.getContext('2d');\n\nbufferContext.canvas.width = width;\nbufferContext.canvas.height = height;\n```", "```js\nvar projection = d3.geoOrthographic()\n    .scale(projectionScale)\n    .translate(translation)\n    .clipAngle(90);\n```", "```js\nvar bufferPath = d3.geoPath()\n    .projection(projection)\n    .context(bufferContext);\n```", "```js\nvar sphere = { type: 'Sphere' };\nvar grid = d3.geoGraticule()();\n```", "```js\nd3.json('../../data/world/world-110.json', function(error, data) {\n  if(error) throw error;\n  ready(data);\n});\n```", "```js\nfunction ready(world) {\n  var countries = topojson.feature(world,\n  world.objects.ne_110m_admin_0_countries); \n  renderScene(countries);\n}\n```", "```js\nfunction renderScene(world){\n  drawScene(world);\n  context.clearRect(0, 0, width, height);\n  context.drawImage(bufferCanvas, 0, 0, bufferCanvas.width,\n  bufferCanvas.height);\n}\n```", "```js\nfunction drawScene(countries) {\n\n  bufferContext.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);\n  // Sphere fill\n  bufferContext.beginPath(); \n  bufferPath(sphere);\n  bufferContext.fillStyle = '#D9EAEF';\n  bufferContext.fill();\n\n  // Grid\n  bufferContext.beginPath();\n  bufferPath(grid);\n  bufferContext.lineWidth = 0.5;\n  bufferContext.strokeStyle = '#BDDAE3';\n  bufferContext.stroke();\n\n  // Country fill\n  bufferContext.beginPath();\n  bufferPath(countries);\n  bufferContext.fillStyle = '#FFFAFA';\n  bufferContext.fill();\n\n  // Country stroke\n  bufferContext.beginPath();\n  bufferPath(countries);\n  bufferContext.lineWidth = 0.5;\n  bufferContext.strokeStyle = '#D2D3CE';\n  bufferContext.stroke();\n\n}\n```", "```js\nfunction ready(world) {\n  var countries = topojson.feature(world, \n  world.objects.ne_110m_admin_0_countries);\n  requestAnimationFrame(function() {\n    renderScene(countries);\n  });\n\n  /* Interactivity goes here */\n}\n```", "```js\nvar zoom = d3.zoom()\n   .scaleExtent([0.5, 4])\n   .on(\"zoom\", zoomed);\n\ncanvas.call(zoom);\n\nfunction zoomed() { // our handler code goes here }\n```", "```js\nvar width = 960,\n    height = 600,\n    projectionScale = origProjectionScale = height / 2.1,\n    translation = [width / 2, height / 2],\n    projectionScaleChange,\n    prevTransformScale = 1,\n    rotation;\n```", "```js\nfunction zoomed() {\n  var event = d3.event.sourceEvent.type;     \n\n  if (event === 'wheel') {\n    var transformScale = d3.event.transform.k;\n    projectionScaleChange = (transformScale – prevTransformScale) *\n    origProjectionScale;\n    projectionScale = projectionScale + projectionScaleChange;\n    projection.scale(projectionScale);\n    prevTransformScale = transformScale;\n  } else if (event === 'mousemove'){\n    // Here goes the rotation logic as this will be triggered upon dragging\n  }\n\n  requestAnimationFrame(function() {\n    renderScene(countries);\n  });\n}\n```", "```js\nfunction zoomed(\n  var dx = d3.event.sourceEvent.movementX;\n  var dy = d3.event.sourceEvent.movementY;\n\n  // all the rest\n```", "```js\nif (event === ‘wheel’) {\n  // here goes the zoom logic described previously \n} else if (event === ‘mousemove’) {\n var r = projection.rotate();\n rotation = [r[0] + dx * 0.4, r[1] - dy * 0.5, r[2]];\n projection.rotate(rotation);\n} else { \n  console.warn('unknown mouse event in zoomed()'); // alerting issues\n}\n```", "```js\nvar hiddenCanvas = d3.select('#canvas-container').append('canvas')\n    .attr('id', 'canvas-hidden')\n    .attr('width', width)\n    .attr('height', height);\n\nvar hiddenContext = hiddenCanvas.node().getContext('2d');\n```", "```js\nvar hiddenProjection = d3.geoEquirectangular()\n    .translate([width / 2, height / 2])\n    .scale(width / 7);\n\nvar hiddenPath = d3.geoPath()\n    .projection(hiddenProjection)\n    .context(hiddenContext);\n```", "```js\nfunction drawHiddenCanvas(world) {\n  var countries = world.features;\n  countries.forEach(function(el, i) {\n    hiddenContext.beginPath();\n    hiddenPath(el);\n    hiddenContext.fillStyle = 'rgb(' + i + ',0,0)';\n    hiddenContext.fill();\n  });\n}\n```", "```js\n  requestAnimationFrame(function() {\n    renderScene(countries);\n    drawHiddenCanvas(countries);\n  });\n```", "```js\ncanvas.on('mousemove', highlightPicking);\n```", "```js\nfunction highlightPicking() {\n  var pos = d3.mouse(this);\n  var longlat = projection.invert(pos);\n  var hiddenPos = hiddenProjection(longlat);\n```", "```js\nvar pickedColor = hiddenContext.getImageData(hiddenPos[0], hiddenPos[1], 1, 1).data;\n```", "```js\nvar inGlobe =\n    Math.abs(pos[0] - projection(projection.invert(pos))[0]) < 0.5 &&\n    Math.abs(pos[1] - projection(projection.invert(pos))[1]) < 0.5;\n```", "```js\nselected = inGlobe && pickedColor[3] === 255 ? pickedColor[0] : false;\n```", "```js\n  // ...\n  selected = inGlobe && pickedColor[3] === 255 ? pickedColor[0] : false;\n\n  requestAnimationFrame(function() {\n    renderScene(countries, selected);\n  });\n\n} // highlightPicking()\n```", "```js\nfunction drawScene(countries, countryIndex) {\n  // Clear …\n  // Sphere fill …\n  // Grid …\n  // Country fill …\n  // Country stroke - each country ….\n\n  // Country stroke - hovered country\n  if (countryIndex >= 0) {\n    bufferContext.beginPath();\n    bufferContext.setLineDash([4,2]);\n    bufferPath(countries.features[countryIndex]);\n    bufferContext.lineWidth = 1;\n    bufferContext.strokeStyle = '#777';\n    bufferContext.stroke();\n    bufferContext.setLineDash([]);\n  }\n}\n```", "```js\nd3.queue()\n  .defer(d3.json, 'data/world-110.json')\n  .defer(d3.csv, 'data/forests.csv')\n  .await(ready);\n```", "```js\nfunction ready(error, world, forests) {\n  if (error) throw error;\n```", "```js\nfunction insertForestDataBinary() {\n  var bisectName = d3.bisector(function(d) { return d.properties.admin;\n  }).right;\n  for (var i = 0; i < forests.length; i++) {\n    var indexBisect = bisectName(countries.features, forests[i].country);\n    var indexMatch = indexBisect - 1;\n    countries.features[indexMatch].properties.forest_area = +forests[i].area;\n    countries.features[indexMatch].properties.forest_percent = \n    +forests[i].percent;\n    countries.features[indexMatch].properties.forest_color =\n    colorScale(+forests[i].percent);\n  }\n }\n```", "```js\nvar colorScale = d3.scaleSequential(d3.interpolateYlGn).domain([0,1]);\n```", "```js\nfunction drawScene(countries, countryIndex) {\n  // Clear the rect, draw the sphere and the graticule\n  // Country fill - individual\n\n  countries.features.forEach(function(el) {\n    bufferContext.beginPath();\n    bufferPath(el);\n    bufferContext.fillStyle = el.properties.forest_color;\n    bufferContext.fill();\n  });\n\n  // Draw the country stroke…\n}\n```", "```js\n<div id=\"tooltip\">\n  <div id=\"tip-header\">\n    <h1></h1>\n    <div></div>\n  </div>\n  <div id=\"tip-body\">\n    <svg id=\"tip-visual\"></svg>\n  </div>\n</div>\n```", "```js\nfunction buildTooltip(data) {\n  var forestsByPercent = data\n    .slice()\n    .sort(function(a, b) {\n      return d3.descending(+a.percent, +b.percent);\n    })\n    .map(function(el) {\n      return {\n        country: el.country,\n        percent: +el.percent,\n        color: colorScale(+el.percent)\n      };\n    });\n\n  var countryList = forestsByPercent.map(function(el) {\n    return el.country;\n  });  \n```", "```js\n    var tipWidth = 200,\n        tipHeight = 200;\n\n    var xScale = d3.scaleLinear()\n        .domain([0, 1])\n        .range([0, tipWidth]);\n\n    var yScale = d3.scaleBand()\n        .domain(countryList)\n        .rangeRound([0, tipHeight]);\n\n    svg = d3.select('svg#tip-visual')\n        .attr('width', tipWidth)\n        .attr('height', tipHeight);\n\n    svg.selectAll('.bar')\n        .data(forestsByPercent)\n      .enter().append('rect')\n        .attr('class', 'bar')\n        .attr('id', function(d) { return stripString(d.country); })\n        .attr('x', xScale(0))\n        .attr('y', function(d) { return yScale(d.country); })\n        .attr('width', function(d) { return xScale(d.percent); })\n        .attr('height', yScale.bandwidth())\n        .attr('fill', function(d) { return d.color; });\n\n  } // buildTooltip()\n```", "```js\nvar svg;\nbuildTooltip(forests);\n```", "```js\nfunction highlightPicking() {\n\n  // Here, you find the country index and store it in pickedColor\n  // and you check if the user’s mouse is in the globe or not with inGlobe\n\n  selected = inGlobe && pickedColor[3] === 255 ? pickedColor[0] : false;\n  requestAnimationFrame(function() {\n    renderScene(countries, selected);\n  });\n\n  var country = countries.features[selected];\n  if (selected !== false) showTooltip(pos, country); // build tooltip\n  if (selected === false) hideTooltip(); // remove tooltip\n}\n```", "```js\nvar countryQueue = [undefined, undefined];\n```", "```js\nfunction showTooltip(mouse, element) {\n  var countryProps = element.properties;\n  countryQueue.unshift(countryProps.admin);\n  countryQueue.pop();\n```", "```js\n  if (countryQueue[0] !== countryQueue[1]) {\n    var headHtml =\n      'Forest cover: ' + formatPer(countryProps.forest_percent) + '' +\n      '<br>Forested area: ' + formatNum(countryProps.forest_area) + '\n       km<sup>2</sup>';\n\n    d3.select('#tip-header h1').html(countryProps.admin);\n    d3.select('#tip-header div').html(headHtml);\n\n    svg.selectAll('.bar').attr('fill', function(d) { return d.color; });\n    d3.select('#' + stripString(countryProps.admin)).attr('fill', 'orange');\n\n    d3.select('#tooltip')\n      .style('left', (mouse[0] + 20) + 'px')\n      .style('top', (mouse[1] + 20) + 'px')\n      .transition().duration(100)\n      .style('opacity', 0.98);\n```", "```js\nIf the queue values are the same, you just move the tip:\n  } else {\n    d3.select('#tooltip')\n      .style('left', (mouse[0] + 20) + 'px')\n      .style('top', (mouse[1] + 20) + 'px');\n  }\n}\n```", "```js\nfunction hideTooltip() {\n  countryQueue.unshift(undefined);\n  countryQueue.pop();\n  d3.select('#tooltip')\n    .transition().duration(100)\n    .style('opacity', 0);\n}\n```"]