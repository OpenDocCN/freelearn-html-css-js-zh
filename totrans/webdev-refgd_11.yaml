- en: Chapter 11. Extending JavaScript and ECMAScript 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 扩展 JavaScript 和 ECMAScript 6
- en: ECMA 262 is a standard that defines the core features of the JavaScript language.
    The language that is defined by this standard is called **ECMAScript**. JavaScript
    is an implementation of ECMAScript. It runs in web browsers at the client end,
    while Node.js runs at the server end. ECMAScript 6 was released in June 2015\.
    ES6 is a major update from ES5, which was released in 2009.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA 262 是一个定义 JavaScript 语言核心特性的标准。由该标准定义的语言称为 **ECMAScript**。JavaScript 是
    ECMAScript 的一个实现。它在客户端的网页浏览器中运行，而 Node.js 在服务器端运行。ECMAScript 6 于 2015 年 6 月发布。ES6
    是从 2009 年发布的 ES5 的一次重大更新。
- en: A complete language specifications draft of ES6 language specifications can
    be obtained from [https://people.mozilla.org/~jorendorff/es6-draft.html](https://people.mozilla.org/~jorendorff/es6-draft.html).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 [https://people.mozilla.org/~jorendorff/es6-draft.html](https://people.mozilla.org/~jorendorff/es6-draft.html)
    获取 ES6 语言规范的完整语言规范草案。
- en: Compatibility and goals
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容性和目标
- en: The ES6 compatibility chart shows which features of ES6 are supported in the
    current browsers. It also links all listed features to their specification guides.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 兼容性图表显示了当前浏览器支持 ES6 的哪些功能。它还链接了所有列出的功能到它们的规范指南。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that some of the features might not be under compliance with
    their exact specifications. While working in Chrome, don't forget to enable the
    Experimental JavaScript flags.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，一些功能可能不符合其确切规范。在 Chrome 中工作时要记得启用实验性 JavaScript 标志。
- en: '![Compatibility and goals](img/B03289_10_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![兼容性和目标](img/B03289_10_01.jpg)'
- en: 'Reference: Use ECMAScript 6 Today'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：使用 ECMAScript 6 今天
- en: 'ECMA6 script has the following major goals:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA6 脚本有以下主要目标：
- en: Default exports
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导出
- en: Static structure of modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的静态结构
- en: Support for asynchronous and synchronous loading
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异步和同步加载
- en: Used for dependencies between modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于模块之间的依赖关系
- en: JavaScript subset and extensions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 子集和扩展
- en: Subsets are mostly defined for security purposes; scripts written using secure
    language subsets can be executed safely even if its source is untrusted, for instance,
    an ad server. Some of these subsets will be described later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 子集主要为了安全目的而定义；使用安全语言子集编写的脚本即使其源代码不可信，例如广告服务器，也可以安全执行。其中一些子集将在后面进行描述。
- en: As JavaScript continued to evolve and allowed explicit extensions, newer versions
    were released. Many of the features were standardized. These extensions are compatible
    with modern browsers such as Firefox and Chrome. However, the implementation of
    non-standard extensions may require an external compiler because these features
    are being updated in major JavaScript engines now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JavaScript 的持续发展和允许显式扩展，发布了新版本。许多功能被标准化。这些扩展与现代浏览器（如 Firefox 和 Chrome）兼容。然而，非标准扩展的实现可能需要一个外部编译器，因为这些功能目前正在主要的
    JavaScript 引擎中更新。
- en: JavaScript subsets
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 子集
- en: As stated earlier, for execution security of untrusted code, we use subsets
    in JavaScript. For example, when we have a credit card checking script in which
    a credit card number is sent to a remote server, then for this type of information
    security, we use subset. By defining a subset, we check the behavior of a program
    that we have strictly not allowed. So, it means that we use subsets for a certain
    amount of code, and the other part of the code is omitted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了执行不可信代码的安全性，我们在 JavaScript 中使用子集。例如，当我们有一个信用卡检查脚本，其中信用卡号被发送到远程服务器时，为了这种类型的信息安全，我们使用子集。通过定义子集，我们检查了一个我们严格不允许的程序的行为。这意味着我们为一定量的代码使用子集，而代码的其他部分被省略。
- en: 'There are two goals of a JavaScript subset:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 子集有两个目标：
- en: The subset construct should be added to maximize coverage use of JavaScript
    constructs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将子集构造添加以最大化 JavaScript 构造的使用范围
- en: It is used to extend analysis to accommodate changes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于扩展分析以适应变化
- en: These subset are defined for every reason.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子集的定义出于各种原因。
- en: '**The good parts**: This is a subset that is part of the language used for
    the best and the worthy part of the script. The main goal of this subset is it
    purifies and simplifies code, and makes the script easier and more understandable.
    The good parts subset does not have an `eval()` function. It also eliminates the
    `continue` and `with` statements. It does not include function definition statements,
    and only defines function using the function definition expression. Using a function
    definition statement, it defines a function, and then, after defining the function,
    it does not use the function definition statement.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：这是一个子集，它是用于脚本最佳和值得部分的语言的一部分。这个子集的主要目标是净化和简化代码，使脚本更容易理解。优点子集没有 `eval()`
    函数。它还消除了 `continue` 和 `with` 语句。它不包括函数定义语句，只使用函数定义表达式来定义函数。使用函数定义语句定义函数后，它不再使用函数定义语句。'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In subset curly brackets, we have a body of loops and conditional statements.
    If there is a single statement in the body, then it would not allow the brackets
    to be omitted.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集的花括号中，我们有一个循环和条件语句的主体。如果主体中只有一个语句，那么它不会允许省略括号。
- en: Secure subsets
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全子集
- en: There are various implementations of secure subsets. Some of them are briefly
    described here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种安全子集的实现。其中一些在这里简要描述。
- en: ADsafe
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ADsafe
- en: '**ADsafe** ([http://www.adsafe.org/](http://www.adsafe.org/)) was one of the
    first presented security subjects. It was proposed and created by Douglas Crockford.
    ADsafe uses tools such **asJSLint** ([http://www.jslint.com/](http://www.jslint.com/))
    to verify the unsafe code. It enforces good programming practices, so the likelihood
    of unsecure code executing correctly is much higher. It blocks the script from
    accessing the global variables or accessing the DOM directly. Instead, it allows
    the script to access the ADsafe object, which provides access to a secure API
    and indirect access to the DOM elements. ADsafe does not alter scripts and has
    no impact on its functionality. It enables us to determine quickly whether the
    script is safe to be placed on a page. It also works as a base that helps in the
    development of other secure subsets.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**ADsafe** ([http://www.adsafe.org/](http://www.adsafe.org/)) 是最早提出的安全主题之一。它由
    Douglas Crockford 提出并创建。ADsafe 使用工具，如 **JSLint** ([http://www.jslint.com/](http://www.jslint.com/))
    来验证不安全的代码。它强制执行良好的编程实践，因此不安全代码正确执行的可能性要高得多。它阻止脚本访问全局变量或直接访问 DOM。相反，它允许脚本访问 ADsafe
    对象，该对象提供对安全 API 的访问和间接访问 DOM 元素。ADsafe 不更改脚本，不会影响其功能。它使我们能够快速确定脚本是否可以放置在页面上。它还作为一个基础，有助于开发其他安全子集。'
- en: Dojox
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dojox
- en: 'The **dojox.secure** tool ([https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html](https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html))
    is a security subset inspired from ADsafe. It is an extension of the **Dojo**
    toolkit ([http://dojotoolkit.org](http://dojotoolkit.org)) and was developed by
    Kris Zyp. It is fully packed with components that ensure safe execution and loading
    of untrusted code, content, ads, and widgets from a different domain. It provides
    a sandbox environment and limited DOM elements for interaction:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**dojox.secure** 工具 ([https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html](https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html))
    是一个受 ADsafe 启发的安全子集。它是 **Dojo** 工具包 ([http://dojotoolkit.org](http://dojotoolkit.org))
    的扩展，由 Kris Zyp 开发。它完全集成了确保不受信任的代码、内容、广告和来自不同域的小部件安全执行和加载的组件。它提供了一个沙盒环境，并限制了用于交互的
    DOM 元素：'
- en: '![Dojox](img/B03289_10_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Dojox](img/B03289_10_02.jpg)'
- en: Caja
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Caja
- en: '**Caja** ([https://developers.google.com/caja/](https://developers.google.com/caja/))
    is an open source secure subset powered by Google. Caja (which means "**box**"
    in Spanish) further defines two subsets:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caja** ([https://developers.google.com/caja/](https://developers.google.com/caja/))
    是由 Google 提供动力的开源安全子集。Caja（在西班牙语中意为“**盒子**”）进一步定义了两个子集：'
- en: '**Cajita** (which means "**small box**" in Spanish) is a narrow subset just
    like ADsafe and dojox.secure'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cajita**（在西班牙语中意为“**小盒子**”）是一个狭窄的子集，就像 ADsafe 和 dojox.secure 一样。'
- en: '**Valija** (which means "**suitcase**" in Spanish) is a broader subset and
    is much more similar to ECMAScript in strict mode (with the `eval()` method removed)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Valija**（在西班牙语中意为“**手提箱**”）是一个更广泛的子集，并且与严格模式的 ECMAScript（移除了 `eval()` 方法）非常相似。'
- en: Caja is a compiler tool that transforms third-party content such as HTML, CSS,
    and JS into secure code, which is then easy to embed in a website.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Caja 是一个编译工具，它将 HTML、CSS 和 JS 等第三方内容转换为安全代码，这使得代码更容易嵌入到网站中。
- en: FBJS
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FBJS
- en: '**FBJS** ([https://github.com/facebook/fbjs](https://github.com/facebook/fbjs))
    is a JavaScript secure subset used by Facebook. It allows untrusted code to be
    executed in a secure environment. It transforms code to ensure security. During
    the transformation, all top-level identifiers are renamed by adding the module-specific
    prefix. Adding module specific prefix prevents querying any global identifiers.
    For example, you are developing an app having the `xyz123` ID, and there is a
    `foo()` function in the code. It will eventually become `xyz123_foo()`. Even function
    calls to `eval()` are redirected to a non-existent function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**FBJS**([https://github.com/facebook/fbjs](https://github.com/facebook/fbjs))是Facebook使用的JavaScript安全子集。它允许在安全环境中执行不受信任的代码。它通过转换代码来确保安全性。在转换过程中，所有顶级标识符都被添加了模块特定的前缀。添加模块特定前缀可以防止查询任何全局标识符。例如，你正在开发一个具有`xyz123`
    ID的应用程序，代码中有一个`foo()`函数。它最终会变成`xyz123_foo()`。甚至对`eval()`的函数调用也会被重定向到一个不存在的函数。'
- en: Microsoft's web sandbox
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 微软的web sandbox
- en: 'Microsoft''s **Web Sandbox** ([http://www.websandbox.org/](http://www.websandbox.org/))
    defines a broad secure subset of JavaScript, HTML, and CSS. Sandbox implements
    host virtualization to provide security and extensibility. The untrusted code
    is executed in a virtual machine instead of running directly in a browser. A virtual
    machine quarantines the untrusted code, which prevents it from interacting with
    the elements outside the virtual machine. Let''s take a look at the following
    block diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的**Web Sandbox**([http://www.websandbox.org/](http://www.websandbox.org/))定义了一个广泛的、安全的JavaScript、HTML和CSS子集。沙盒通过实现宿主虚拟化来提供安全性和可扩展性。不受信任的代码在虚拟机中执行，而不是直接在浏览器中运行。虚拟机将不受信任的代码隔离，防止它与虚拟机外的元素交互。让我们看一下以下块图：
- en: '![Microsoft''s web sandbox](img/B03289_10_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![微软的web sandbox](img/B03289_10_03.jpg)'
- en: Microsoft's Web Sandbox
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的Web Sandbox
- en: JavaScript extensions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript扩展
- en: Lots of new and useful features have been coded. They will be standardized with
    the release of ES6\. ES6 was set to be officially released in June 2015\. However,
    many of the features and extensions are already available on Firefox and Chrome
    (Experimental JavaScript flag has to be turned *on* in order to access some of
    the ES6 features). We will discuss the major features in the rest of the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 已经编码了许多新的和有用的功能。它们将在ES6的发布中得到标准化。ES6计划于2015年6月正式发布。然而，许多功能和扩展已经在Firefox和Chrome上可用（为了访问一些ES6功能，必须将实验性JavaScript标志打开）。我们将在本章的其余部分讨论主要功能。
- en: Const
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Const
- en: It works like variable keyword `var`. For declaring a constant, we use the word
    `const`. In order to use assignment we must declare constant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式类似于`var`变量关键字。为了声明一个常量，我们使用`const`这个词。为了使用赋值，我们必须声明常量。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Values declared with the const can not be redeclared, redefined or reinitialized.
    JavaScript provide 8 constants through math object. One of them is PI. we can
    not reinitialize PI using const.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用const声明的值不能被重新声明、重新定义或重新初始化。JavaScript通过math对象提供了8个常量。其中之一是PI。我们无法使用const重新初始化PI。
- en: Let
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Let
- en: 'The `Let` keyword is used for the block scoping of variables. The variables
    are declared at the start of the code instead of at the start of functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Let`关键字用于变量的块作用域。变量在代码的开始处声明，而不是在函数的开始处：'
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the name `john` is the value of name logged in console.
    The declarations in JavaScript are moved to the top. The position of the variables
    declared or initialized in the scope of the function does not matter, and they
    will be hoisted to the top by default. JavaScript's default conduct is to move
    variable declarations to the top.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`john`这个名字是控制台中记录的名字的值。JavaScript中的声明被移动到顶部。在函数作用域中声明的或初始化的变量的位置并不重要，它们将默认提升到顶部。JavaScript的默认行为是将变量声明移动到顶部。
- en: Hoisting is JavaScript's default behavior to move variable declarations to the
    top.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提升是JavaScript的默认行为，将变量声明移动到顶部。
- en: 'Variables in JavaScript are function scoped. This means, variables are available
    throughout the function, even if they are declared in a nested code block. Here
    is a short example in which we will log the output in the console of our client,
    that is, Chrome, Firefox, and so on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的变量是函数作用域的。这意味着，变量在整个函数中都是可用的，即使它们是在嵌套的代码块中声明的。以下是一个简短的例子，我们将记录客户端（即Chrome、Firefox等）控制台中的输出：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding example, the value of name used to log-in into the console
    is `jane`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，用于在控制台中登录的名字的值是`jane`。
- en: 'ES6 handles this issue with let. Let is very much like `var`. The only difference
    is that `let` is block scoped, and `var` is function scoped. We can rewrite the
    previous example using let, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 使用 `let` 来处理这个问题。`let` 和 `var` 非常相似。唯一的区别是 `let` 是块作用域的，而 `var` 是函数作用域的。我们可以使用
    `let` 重新编写之前的例子，如下所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that although the value of name is `jane` inside the function, using
    the `let` keyword sets its scope to global and the value of name defaults to `john`.
    Hence, `john` is logged in the client's console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在函数内部 `name` 的值是 `jane`，但使用 `let` 关键字将其作用域设置为全局，并且 `name` 的默认值是 `john`。因此，`john`
    被记录在客户端控制台中。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we declare a variable as a constant, assign it some value, use the same constant
    somewhere else that changes its value, then its new value will be ignored. Like
    variables, we can add constants anywhere in our script without breaking our code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个变量声明为常量，给它赋一些值，然后在其他地方使用相同的常量改变它的值，那么它的新值将被忽略。像变量一样，我们可以在脚本中的任何地方添加常量而不会破坏代码。
- en: Destructuring assignment
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构赋值
- en: We can assign multiple values to the variables in a function using one command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一条命令将多个值赋给函数中的变量。
- en: For each
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: For each
- en: The iteration of property value is done using this loop. The iteration of property
    name is done.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值的迭代是通过这个循环完成的。属性名的迭代也已经完成。
- en: Iterator
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: The object for the next method is returned. The object that is returned has
    `_iterator_` property. The iterator is used for `iteratable` objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法的对象被返回。返回的对象具有 `_iterator_` 属性。迭代器用于 `iteratable` 对象。
- en: Generators
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: The generation of object is done here. A generated object is returned whenever
    a function invokes the `this` method. The `yield` keyword is used. The current
    execution of the function is specified by the generated object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生成在这里完成。每当函数调用 `this` 方法时，都会返回一个生成对象。使用 `yield` 关键字指定函数的当前执行。
- en: Array
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: The `iteratable` objects with the same values in the array are shorthanded by
    the use of array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中有相同值的 `iteratable` 对象可以通过使用数组来简写。
- en: Generator expression
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: The functions are shorthanded for multiple `try-catch` expressions. The thing
    that is returned is the generated object wrapped in `{}` and not in `[]`. We use
    this for multiple values to variables in the function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被简写为多个 `try-catch` 表达式。返回的是用 `{}` 包裹的生成对象，而不是用 `[]`。我们用这个来将多个值赋给函数中的变量。
- en: Scoped variables and constants
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域变量和常量
- en: 'When we declare a variable, then it has a local scope and a global scope. We
    can define a variable anywhere in our script. When we declare a variable in JavaScript,
    we can assign a value to it at the time of declaration or later. Here is an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个变量时，它就具有局部作用域和全局作用域。我们可以在脚本中的任何地方定义一个变量。当我们用 JavaScript 声明一个变量时，我们可以在声明时或之后给它赋值。以下是一个示例：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In JavaScript, a variable is defined by a dollar sign the same as in query.
    In JavaScript, we create variables dynamically using the `var` keyword. Every
    variable has a name and a value associated with it. These values can be of any
    type, such as `number`, `array`, `string`, and so on. A variable name could be
    a combination of characters and numbers. Here is an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，变量是通过查询中的美元符号定义的。在 JavaScript 中，我们使用 `var` 关键字动态创建变量。每个变量都有一个与之关联的名称和值。这些值可以是任何类型，例如
    `number`、`array`、`string` 等。变量名可以是字符和数字的组合。以下是一个示例：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A variable that is declared outside a function is a **global variable** having
    a global scope. This means that it can be accessed from anywhere within a script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数外部声明的变量是一个**全局变量**，具有全局作用域。这意味着它可以从脚本中的任何地方访问。
- en: We can also declare a variable constant with the `const` keyword. A constant
    variable value is constant.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `const` 关键字声明一个变量为常量。常量变量的值是恒定的。
- en: 'Constants can be defined using the `const` keyword as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `const` 关键字定义常量，如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `const` and `let` keywords work in a similar way that they both are block
    scoped. However, in the case of `const`, values cannot be redeclared, redefined,
    or reinitialized. In short, const values are read-only.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 和 `let` 关键字以类似的方式工作，因为它们都是块作用域的。然而，在 `const` 的情况下，值不能被重新声明、重新定义或重新初始化。简而言之，`const`
    值是只读的。'
- en: 'Here is a working example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个工作示例：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `class` variables are declared in the class but not within methods of any
    class, whereas the local variable exits within the methods of any class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量在类中声明，而不是在任何类的任何方法中声明，而局部变量存在于任何类的任何方法中。
- en: Shorthand functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简短函数
- en: Shorthand function, also known as **expression closure**, is a technique to
    use simple functions in JavaScript. It is used to omit a function's curly brackets
    in the event; it returns a `true` or `false` statement. Similarly, if you omit
    the `return` keyword, it would also send you the exact same result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 简短函数，也称为**表达式闭包**，是 JavaScript 中使用简单函数的技术。它用于在事件中省略函数的花括号；它返回一个 `true` 或 `false`
    语句。同样，如果你省略 `return` 关键字，它也会发送完全相同的结果。
- en: The expression will be evaluated quickly after the argument list in your script
    by omitting the curly brackets and the `return` keyword.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式将在你的脚本中的参数列表之后快速评估，通过省略花括号和 `return` 关键字。
- en: 'Here is an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This behaves similarly like functions. They are defined with curly brackets
    and a `return` statement. This is very useful when we want to pass a function
    as an argument to a function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它的行为类似于函数。它们通过花括号和 `return` 语句定义。当我们要将函数作为参数传递给另一个函数时，这非常有用。
- en: Multiple catch clauses
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重捕获子句
- en: In JavaScript, `try/catch` statements are use to handle exceptions present in
    the `try` code blocks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`try/catch` 语句用于处理 `try` 代码块中存在的异常。
- en: The try clause
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try 子句
- en: In the `try` block, the statements to be evaluated are executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try` 块中，执行要评估的语句。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to deliberately throw an exception, we would use the `throw` statement.
    This will abort the execution of the remaining statements, and the control will
    move to the `catch` block.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想故意抛出异常，我们将使用 `throw` 语句。这将中止剩余语句的执行，并将控制权转移到 `catch` 块。
- en: The catch clause
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catch 子句
- en: After checking and encountering an error in the statements in the `try` block,
    the exception block is called. If the exception encountered is the same as the
    exception handled in the `catch` block, then the control immediately shifts to
    the `catch` block, and the statements within the `catch` block are executed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 `try` 块中的语句并遇到错误后，将调用异常块。如果遇到的异常与 `catch` 块中处理的异常相同，则控制立即转移到 `catch` 块，并执行
    `catch` 块内的语句。
- en: The statements presented after the erroneous statement will *not* be executed,
    unless there is a `return` statement in the `finally` block.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误语句之后呈现的语句将**不会**执行，除非 `finally` 块中有 `return` 语句。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A good practice is to use a conditional catch clause first if we anticipate
    that any exception will occur. An unconditional catch clause is placed last to
    handle all the remaining exceptions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是，如果我们预计可能会发生任何异常，首先使用条件 `catch` 子句。无条件 `catch` 子句放在最后，以处理所有剩余的异常：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The finally clause
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally 子句
- en: 'This block will execute statements present within at end, whether an exception
    has occurred or not. The statements in a `finally` block execute irrespective
    of whether an error occurred. The `finally` block generally contains code that
    must be executed regardless of anything. Hence, we generally release resources
    and close connection inside a `finally` block. The syntax for writing a simple
    `try-catch-finally` block is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否发生异常，此块都将执行末尾存在的语句。`finally` 块中的语句无论是否发生错误都会执行。`finally` 块通常包含必须执行的代码。因此，我们通常在
    `finally` 块中释放资源并关闭连接。编写简单的 `try-catch-finally` 块的语法如下：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also write this with a nested `catch` blocks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用嵌套的 `catch` 块来写，如下所示：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is an example showing the working of multiple `catch` clauses:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了多重 `catch` 子句的工作原理：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s pass 14 as the argument to the function, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们传递 14 作为函数的参数，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In `try-catch` statements, we must have at least one `finally` or `try-catch`
    block. `Try` doesn't necessarily need a `catch` clause. If a `try` statement does
    not contain at least one `catch` block, it must contain a `finally` block. The
    possible exception handling clauses with `try-catch-finally` are the `try-catch`,
    `try-finally`, or `try-catch-finally` clauses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try-catch` 语句中，我们必须至少有一个 `finally` 或 `try-catch` 块。`try` 不一定需要一个 `catch`
    子句。如果一个 `try` 语句不包含至少一个 `catch` 块，它必须包含一个 `finally` 块。与 `try-catch-finally` 一起的可能异常处理子句是
    `try-catch`、`try-finally` 或 `try-catch-finally` 子句。
- en: E4X – ECMAScript for XML
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: E4X – ECMAScript for XML
- en: It is an extension in JavaScript for support of XML extension with JavaScript.
    By using E4x, it provides easy access for XML document by the DOM interface. It
    is a server-side technology used in **Rhino** and **SpiderMonkey** because these
    are powerful extensions by all browsers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它是JavaScript对XML扩展的支持的扩展。通过使用E4x，它通过DOM接口提供了对XML文档的便捷访问。它是一种在**Rhino**和**SpiderMonkey**中使用的服务器端技术，因为这些是所有浏览器都提供的强大扩展。
- en: Before E4X, it was very difficult and time consuming for reading and writing
    in XML. In JavaScript, E$X provides XML document as a XML object, which represents
    XML fragments as a `xmlList`. E4X supports special kinds of XML objects. This
    technique is used in client-side programming.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在E4X之前，读取和写入XML非常困难且耗时。在JavaScript中，E$X提供XML文档作为XML对象，它将XML片段表示为`xmlList`。E4X支持特殊的XML对象。这种技术在客户端编程中得到了应用。
- en: 'Here is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we enter this XML into our JavaScript code, the E4X interpreter will handle
    it as an XML object in your script.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此XML输入到我们的JavaScript代码中，E4X解释器将将其作为脚本中的XML对象处理。
- en: ECMAScript 6 features
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 6特性
- en: ECMAScript 6, otherwise called **ECMAScript 2015**, is the most recent form
    of the ECMAScript standard. ES6 is an important upgrade to the language, and the
    first update to language since the release of ES5.1 in June 2011
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6，也称为**ECMAScript 2015**，是ECMAScript标准的最新形式。ES6是对语言的重大升级，也是自2011年6月发布ES5.1以来的第一次语言更新。
- en: 'A few of the new features of ES6 are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ES6的一些新特性包括：
- en: Arrow functions
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Classes
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Enhanced object literals
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强对象字面量
- en: Destructuring assignment
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构赋值
- en: Extended parameter handling
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展参数处理
- en: Generator
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Modules
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Proxy
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: We will look at all these functions in the upcoming sections.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中查看所有这些函数。
- en: Arrow functions
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Arrow functions are also known as **fat arrow functions**. It is a function
    and is similar to what we use in C#, Java, and Coffee Script. Statements and expression
    bodies are supported by arrows. The lexical of arrows is similar to its surrounding
    code. This is not the case in functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也称为**肥箭头函数**。它是一个函数，类似于我们在C#、Java和Coffee Script中使用的函数。箭头支持语句和表达式体。箭头的词法与其周围的代码相似。这在函数中是不一样的。
- en: As the name suggests, arrow functions use a shorter syntax, an arrow (`=>`),
    for definition and in syntax.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，箭头函数使用更短的语法，即箭头（`=>`），用于定义和语法。
- en: 'For example, look at the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看下面的示例：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An arrow function expression or a fat arrow function are shorter in syntax when
    compared with function expressions. Arrow function is used to bind the value of
    this. (It does not binds its own `arguments`, `super`, `this` or `new.target`).
    Arrow functions are anonymous.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数表达式相比，箭头函数表达式或肥箭头函数在语法上更短。箭头函数用于绑定this的值。（它不绑定自己的`arguments`、`super`、`this`或`new.target`）。箭头函数是无名的。
- en: The `yield` keyword is used to `pause` and `resume` a generator function (`function*`
    function keyword with an asterisk defines a `generator` function that returns
    a `Generator` object).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`关键字用于`暂停`和`恢复`生成器函数（使用带星号的`function*`关键字定义的返回`Generator`对象的生成器函数）。'
- en: Classes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: ES6 classes' syntax is simpler and easier than that of area syntactical sugar
    over the prototype-based object-oriented pattern. It is a syntactical sugar. One-time
    declaration makes class patterns easier to use and simplifies the use of class
    patterns. Classes support constructors, instance, prototype-based inheritance,
    static methods, and super calls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ES6类的语法比基于原型的面向对象模式的区域语法糖更简单、更容易使用。这是一种语法糖。一次性声明使类模式更容易使用，并简化了类模式的使用。类支持构造函数、实例、基于原型的继承、静态方法和超类调用。
- en: 'Here is an example of writing a class in ES6 and ES5:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在ES6和ES5中编写类的示例：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enhanced object literals
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强对象字面量
- en: Object literals is one of the most popular patterns of JavaScript. JSON is based
    on object literals. The reason for its popularity is that it provides a very quick,
    short, and neat way to do `key:value` assignments, define methods, evaluate expressions,
    and make super calls. ES6 has extended the object literal syntax in various ways.
    This makes them more useful. Two types of extensions for object literals are explained
    here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量是JavaScript中最流行的模式之一。JSON基于对象字面量。其受欢迎的原因在于它提供了一种非常快速、简洁、整洁的方式来执行`key:value`赋值、定义方法、评估表达式和进行超类调用。ES6以各种方式扩展了对象字面量语法。这使得它们更有用。这里解释了对象字面量的两种扩展类型。
- en: Property initializer shorthand
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性初始化简写
- en: Earlier in ECMAScript 5, object literals were a comma-separated collection of
    `name:value` pairs. There was a likelihood of duplication while property values
    were being initialized.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 5 中，对象字面量是一组以逗号分隔的 `name:value` 对。在初始化属性值时，存在重复的可能性。
- en: 'Here is an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, the `createStudent()` function creates a `student`
    object whose `name` and `class` properties are similar to the function parameters.
    This results in duplication of `name` and `class` properties, even though both
    behave differently.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`createStudent()` 函数创建了一个 `student` 对象，其 `name` 和 `class` 属性与函数参数相似。这导致了
    `name` 和 `class` 属性的重复，尽管它们的行为不同。
- en: To correct this, the initializer shorthand property was introduced in ECMAScript
    6\. This removed all the likelihood of duplication between property names and
    local variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这一点，ECMAScript 6 中引入了初始化器简写属性。这消除了属性名和局部变量之间重复的所有可能性。
- en: 'For instance, `createStudent()` can be revised as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`createStudent()` 可以修改如下：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the event that property name will be the same as property estimation, you
    can simply incorporate property name without colon and value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性名将与属性值相同，则可以简单地包含属性名而不加冒号和值。
- en: If the property of an object literal has no value, the JavaScript engine searches
    for a variable with a similar name in the surrounding. If the search procedure
    is successful, the value is assigned to the same party name in object literals.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象字面量的属性没有值，JavaScript 引擎会在周围搜索具有相同名称的变量。如果搜索过程成功，则将值分配给对象字面量中的相同属性名。
- en: Method initializer shorthand
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法初始化器简写
- en: With the advent of ECMAScript 6, many things improved, making the work of a
    web developer simpler. The syntax of writing methods in object literals improved
    to a great extent. Earlier, in ECMAScript 5, we needed to specify a name and write
    the complete function definition then and there.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ECMAScript 6 的出现，许多事情得到了改进，使得网页开发者的工作变得更加简单。对象字面量中编写方法的语法得到了极大的改善。在 ECMAScript
    5 中，我们需要指定一个名称并立即编写完整的函数定义。
- en: 'Here is an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With ECMAScript 6, the syntax became easier to code. Colon and function keywords
    have been removed. The same example can be rewritten as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 中，语法变得更容易编写。冒号和函数关键字已被移除。相同的示例可以重写如下：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Template strings
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Template strings amplify ECMAScript with syntactic sugar to build string. This
    component is like string introduction highlights in Perl, Python, and so on. You
    can likewise add a tag to permit redid string development, staying away from and
    counteracting infusion assaults or building complex information structures from
    string substance. They also enable us to create **domain-specific** **languages**
    (**DSLs**) to deal with content in a safe way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串通过语法糖增强了 ECMAScript，用于构建字符串。这个组件类似于 Perl、Python 等语言中的字符串插入高亮。你同样可以添加一个标签来允许重用字符串开发，避免和防止注入攻击或从字符串内容构建复杂的数据结构。它们还使我们能够创建**领域特定语言**（**DSLs**）以安全的方式处理内容。
- en: Instead of adding more extending functionality to JavaScript strings, template
    strings provide a total new approach for string interpolation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与向 JavaScript 字符串添加更多扩展功能不同，模板字符串提供了一种全新的字符串插值方法。
- en: Basics
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'The simplest format of a template string is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串的最简单格式如下：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the most basic form of template strings which performs substitutions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模板字符串的最基本形式，它执行替换操作。
- en: 'Template strings are enclosed within backticks (`` ` ``) instead of single
    or double quotes. Here is an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串用反引号（`` ` ``）而不是单引号或双引号括起来。这里有一个例子：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, a `basic_string` variable contains a simple JavaScript string.
    The template string syntax is only used to create the string value, which is then
    assigned to `basic_string`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`basic_string` 变量包含一个简单的 JavaScript 字符串。模板字符串语法仅用于创建字符串值，然后将其分配给 `basic_string`。
- en: 'If there is a need to use a backtick in string, then you can escape it using
    a backslash (`\`):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在字符串中使用反引号，则可以使用反斜杠（`\`）进行转义：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Multiline strings
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多行字符串
- en: 'In this type of string, we can add multiple lines in a single line of code.
    To insert a new line in a string, we have to include `\n` within the string manually,
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的字符串中，我们可以在单行代码中添加多行。要在字符串中插入新行，我们必须在字符串中手动包含 `\n`，如下所示：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of this is:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果是：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need to be careful regarding the whitespaces, as whitespaces within backticks
    are considered to be part of the string. All whitespaces before the second line
    are considered to be part of the string.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心空格，因为反引号内的空格被认为是字符串的一部分。所有在第二行之前的空格都被认为是字符串的一部分。
- en: Destructuring assignment
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构赋值
- en: In JavaScript, *destructuring* means pattern matching. In ES6, we can do efficient
    pattern matching in objects and arrays. Earlier, this was a long and complicated
    task. Here are some working examples written in a client console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，*解构*意味着模式匹配。在ES6中，我们可以在对象和数组中进行高效的模式匹配。以前，这是一个漫长且复杂的过程。以下是一些在客户端控制台编写的有效示例。
- en: 'Fetching data from objects and arrays is very common in JavaScript. Object
    properties are usually stored in local variables for instant access. Let''s take
    a look at the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象和数组中获取数据在JavaScript中非常常见。对象属性通常存储在局部变量中以实现即时访问。让我们看看以下代码片段：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ES6 made this easier by introducing destructuring assignments, which goes through
    an object or an array and stores specified values in the local variables. It allows
    binding using pattern matching for objects and arrays.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ES6通过引入解构赋值使这变得更加容易，它遍历一个对象或数组，并将指定的值存储在局部变量中。它允许使用模式匹配来绑定对象和数组。
- en: Array destructuring
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组解构
- en: 'All variables can be initialized and swapped at once instead of the conventional
    way of creating a temporary variable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量可以一次性初始化和交换，而不是传统的创建临时变量的方式：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Multiple values from a function are returned with ease using array destructuring.
    We don''t have to wrap around an object. To skip variables, you can leave the
    position of the array element blank:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组解构可以轻松地从函数返回多个值。我们不必围绕一个对象进行包装。要跳过变量，可以留空数组元素的位子：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Object destructuring
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象解构
- en: Due to destructuring, variables can also be initialized from an object that
    is returned from a function even with deeply nested objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解构，变量也可以从函数返回的对象中初始化，即使对象嵌套很深。
- en: 'Destructuring enables variables to be initialized from an object that is returned
    by a function having deeply nested objects. Just like Array destructuring, we
    can skip the ones not needed. Here''s the working snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 解构允许变量从具有深层嵌套对象的函数返回的对象中初始化。就像数组解构一样，我们可以跳过不需要的变量。以下是有效代码片段：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Extended parameter handling
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展参数处理
- en: Functions are an important and fundamental part of any language. ES6 has introduced
    a number of incremental improvements in functions. This makes them less error
    prone and more powerful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何语言的一个重要和基本的部分。ES6在函数方面引入了许多增量改进。这使得它们更不容易出错，并且更强大。
- en: 'Functions allow any number of parameters to be passed irrespective of the number
    of parameters in the function definition. There are three types of these parameters
    that could be passed to functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许传递任意数量的参数，无论函数定义中参数的数量是多少。这些参数可以传递给函数的三种类型如下：
- en: Default
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值
- en: Rest
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数
- en: Spread
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开运算符
- en: Default parameter
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'ES6 lets us set default parameters. A parameter with a default value is considered
    optional. It binds trailing parameters to an array:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ES6允许我们设置默认参数。具有默认值的参数被认为是可选的。它将尾随参数绑定到一个数组上：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rest parameter
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余参数
- en: Rest parameters replace the need for arguments and addresses common cases more
    directly. Rest parameters are indicated by three dots (`…`) preceding a parameter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数取代了`arguments`的需要，并更直接地解决了常见情况。剩余参数由三个点（`…`）在参数之前表示。
- en: 'Here is an example showing the rest parameter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示剩余参数的例子：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The named parameter becomes an array containing the rest of the parameters.
    Adding more than one named argument may cause syntax error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数变成一个包含剩余参数的数组。添加多个命名参数可能会导致语法错误。
- en: Spread operator
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开运算符
- en: Spread operator is very similar to the rest parameter, but it allows us to split
    the array to individual arguments, which are then passed to the function as separate
    arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符与剩余参数非常相似，但它允许我们将数组拆分为单独的参数，然后作为单独的参数传递给函数。
- en: 'Here is an example showing the spread operator:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示展开运算符的例子：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is an example showing the usage of default, rest, and spread parameters:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个展示默认、剩余和展开参数使用的例子：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Bindings
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'The `let` keyword is a new `var`. The declaration syntax for the `let` keyword
    is the same as for `var`. You can basically replace `var` with `let` to declare
    a variable but keep its scope to the current code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字是一个新的 `var`。`let` 关键字的声明语法与 `var` 相同。您基本上可以用 `let` 替换 `var` 来声明一个变量，但保持其作用域在当前代码中：'
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Variables defined using `const` are considered to be constants, so the value
    cannot be changed once set. For this reason, every `const` variable has to be
    initialized:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const` 定义的变量被认为是常量，因此一旦设置值后就不能更改。因此，每个 `const` 变量都必须进行初始化：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Iterators and the for...of operator
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器和 for...of 操作符
- en: We use iterators to allow customization of an object's iteration method/behavior,
    such as CLRIE numerable or Java Iterable. Generalize the `for..in` operator to
    custom iterator-based iteration with `for..of`. Iterators are an important feature
    of ECMAScript 6\. When used in combination with new array methods and new types
    of collections (for example, sets and maps), iterators become even more important
    for the efficient processing of data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用迭代器来允许自定义对象的迭代方法/行为，例如 CLRIE 可数或 Java Iterable。将 `for..in` 操作符泛化到基于自定义迭代器的迭代，使用
    `for..of`。迭代器是 ECMAScript 6 的一个重要特性。当与新的数组方法和新的集合类型（例如集合和映射）结合使用时，迭代器对于数据的高效处理变得更加重要。
- en: 'Fibonacci numbers, or the Fibonacci arrangement, are the numbers in the accompanying
    whole number succession:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数，或斐波那契排列，是伴随的整数序列中的数：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generators
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: Custom iterators are a useful tool but it requires careful programming so that
    it can maintain its internal state explicitly. ES6 introduced generators which
    provide a powerful alternative. Generator allows us to create an iteration algorithm
    by writing a single function. This single function is able to maintain its own
    state.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义迭代器是一个有用的工具，但它需要仔细编程，以便可以显式地维护其内部状态。ES6 引入了生成器，它提供了一个强大的替代方案。生成器允许我们通过编写单个函数来创建迭代算法。这个单函数能够维护其自己的状态。
- en: A `generator` is a function that returns an iterator. The `generator` functions
    are denoted by embedding an asterisk (`*`) after the function keyword. A normal
    function becomes a generator if it contains a yield expression and uses `function*`
    syntax.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`生成器` 是一个返回迭代器的函数。`生成器` 函数通过在函数关键字后嵌入一个星号 (`*`) 来表示。如果一个普通函数包含一个 `yield` 表达式并使用
    `function*` 语法，它就变成了一个生成器。'
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It doesn't matter whether there is space between the `function` keyword and
    the asterisk.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `function` 关键字和星号之间是否有空格无关紧要。
- en: 'The `yield` keyword is utilized within the generators function to indicate
    the qualities that the iterator must return when the `next()` method is called.
    So, in the event that you need to return unique values for each progressive call
    to `next()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器函数中使用 `yield` 关键字来指示在调用 `next()` 方法时迭代器必须返回的特性。因此，如果您需要为 `next()` 的每次递进调用返回唯一值：
- en: 'We can convert the previous iterator example to use a generator, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前的迭代器示例转换为使用生成器，如下所示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Better Unicode support
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的 Unicode 支持
- en: ES6 supports Unicode, including new Unicode literal form in strings, new `RegExp
    u` mode to handle code points, as well as new APIs to process strings at the 21-bit
    code points level. These updates enable us to create global apps in JavaScript.
    ECMAScript 6 enforces encoding of strings in UTF.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 支持 Unicode，包括字符串中的新 Unicode 字面量形式，新的 `RegExp u` 模式来处理代码点，以及新的 API 来处理 21
    位代码点级别的字符串。这些更新使我们能够在 JavaScript 中创建全局应用程序。ECMAScript 6 强制字符串使用 UTF 编码。
- en: 'The supported Unicode examples are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的 Unicode 示例如下：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Modules
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'ECMAScript 6 enables us to export and import symbols to and from modules without
    polluting the global namespace. It provides added support for modules for component
    definition. Runtime behavior is defined by a host-defined default loader. It is
    an implicitly asynchronous model; no code is executed until the necessary modules
    are available and processed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 允许我们在模块之间导出和导入符号，而不会污染全局命名空间。它为组件定义提供了额外的模块支持。运行时行为由宿主定义的默认加载器定义。它是一个隐式异步模型；除非必要的模块可用并处理，否则不会执行任何代码：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some additional features include export default and export `*`, as shown in
    the following code snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的功能包括 `export default` 和 `export *`，如下代码片段所示：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Module loaders
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块加载器
- en: Module loaders are used primarily to resolve module specifiers, loading modules,
    and so on. They are responsible for downloading the required modules and binding
    them asynchronously. This brings to light the dependencies of a client script.
    The constructor is `Reflect.Loader`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器主要用于解析模块指定符、加载模块等。它们负责下载所需的模块并异步绑定它们。这揭示了客户端脚本的依赖关系。构造函数是`Reflect.Loader`。
- en: 'Module loaders support:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器支持：
- en: Compilation hooks
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译钩子
- en: Nested virtualization
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套虚拟化
- en: Dynamic loading
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载
- en: Global namespace isolation
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间隔离
- en: State isolation
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态隔离
- en: Loader methods
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载器方法
- en: '`System.module(source, options?)`: This is used to assess the JavaScript code
    in source to a module (which is delivered and returned non-concurrently by means
    of a guarantee)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.module(source, options?)`：这个方法用于评估源中的JavaScript代码到一个模块（通过保证非并发地交付和返回）'
- en: '`System.set(name, module)`: This is used for the registration of the module
    created by System.module()'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.set(name, module)`：这个方法用于注册由`System.module()`创建的模块'
- en: '`System.define(name, source, options?)`: This is used to assess the module
    code in source and registers the outcome'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.define(name, source, options?)`：这个方法用于评估源中的模块代码并注册结果'
- en: 'We can configure the default module loader, and new loaders can be constructed
    to evaluate and load code in isolated or constrained contexts:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置默认模块加载器，并构建新的加载器来评估和加载隔离或受限上下文中的代码：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Collections
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: '**Collections** are used to create unique values collections of any type in
    JavaScript. In a collection of values, you can also add and remove values. There
    is no direct access to values in collection, and these are of array type.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**在JavaScript中用于创建任何类型的唯一值集合。在值集合中，你也可以添加和移除值。集合中没有直接访问值的方式，它们是数组类型。'
- en: 'In ECMAscript 6, collections are a new efficient way to store data. JavaScript
    arrays are similar to other programming language arrays with index. By use of
    these arrays, you can pull double and triple data and also stack data. There are
    many new types of collections in JavaScript. Here are some examples:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 6中，集合是存储数据的一种新的高效方式。JavaScript数组与其他编程语言的数组类似，具有索引。通过使用这些数组，你可以提取双倍和三倍数据，也可以堆叠数据。JavaScript中有许多新的集合类型。以下是一些示例：
- en: Sets
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Maps
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: WeakMap
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakMap
- en: WeakSet
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakSet
- en: Sets
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A `set` has a unique collection of values. The unique values of a set are also
    of object reference types. Values in sets cannot be duplicated. Before you access
    values from a `set`, you need to check whether the values are present or not.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`set`有一个唯一的值集合。集合的唯一值也是对象引用类型。集合中的值不能重复。在从`set`访问值之前，你需要检查这些值是否存在。
- en: 'We can add values in a `set` and also check the size of values in a set. Here
    is an example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`set`中添加值，也可以检查`set`中值的数量。以下是一个示例：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Maps
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: 'A `map` object is a `key/value` map. Any value in `map` may be used as a key
    or a value. Elements can iterate in a `map` in an insertion order, and it returns
    an array of a value or a key. There are two properties of `map`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`对象是一个`键/值`映射。`map`中的任何值都可以用作键或值。元素可以在`map`中以插入顺序迭代，并返回一个包含值或键的数组。`map`有两个属性：'
- en: '`Map.length`: Returns the number of elements in a `map`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.length`：返回`map`中元素的数量'
- en: '`Map.prototype`: The `Map.prototype` property represents the prototype for
    the `map` constructor'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype`：`Map.prototype`属性代表`map`构造函数的原型'
- en: Here are some of the methods of the `map` object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`map`对象的一些方法。
- en: Map.prototype.clear()
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Map.prototype.clear()
- en: The `clear()` method removes all elements from a `map` object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear()`方法用于从`map`对象中移除所有元素。'
- en: Returns
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns nothing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它不返回任何内容。
- en: Parameter
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: There is no input parameter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输入参数。
- en: Description
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: After using this function, everything that we have initialized on map will be
    erased. The function has no parameter and returns nothing as it wipes out everything.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数后，我们在map上初始化的所有内容都将被清除。该函数没有参数，也不返回任何内容，因为它会清除所有内容。
- en: 'Here is an example of this method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个方法的示例：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Map.prototype.delete()
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Map.prototype.delete()
- en: The `delete()` method removes the specified element from a `Map` object.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法用于从`Map`对象中移除指定的元素。'
- en: Returns
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns `true` if a component in the map object existed and has been evacuated.
    It returns false if the component does not exist.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果map对象中的组件存在并且已被移除，则返回`true`。如果组件不存在，则返回`false`。
- en: Parameter
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: A key is required. The key here is basically the element to be removed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个键。这里的键基本上是要移除的元素。
- en: Description
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This is different from `map.prototype.clear()` as it clearly removes a specific
    element instead of deleting every element on the map. We pass a key (the element
    to be deleted), and the function returns `true` or `false`, depending on the key.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `map.prototype.clear()` 不同，因为它明确地删除了特定的元素，而不是删除映射上的每个元素。我们传递一个键（要删除的元素），函数根据键返回
    `true` 或 `false`。
- en: 'Here is an example of this method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Map.prototype.entries()
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.entries()`'
- en: This function is used to tell us about the key and value of elements on map.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于告诉我们映射上元素的键和值。
- en: Returns
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns a new `iterator` object that contains a key and a value for every
    element on the map.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含映射上每个元素键和值的新的 `iterator` 对象。
- en: Parameter
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: There are no input parameters.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输入参数。
- en: Description
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This function is utilized for letting us know about the key and value of components
    on map.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于让我们了解映射上组件的键和值。
- en: 'Here is an example of this method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Map.prototype.forEach()
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.forEach()`'
- en: The `forEach` method executes the given callback once to every key/value pair
    in the map object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 方法在映射对象中的每个键/值对上执行给定的回调一次。'
- en: Returns
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns nothing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 它不返回任何内容。
- en: Parameter
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: 'There are three parameters: the element `value`, element `key`, and the `map`
    object being traversed.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个参数：元素 `value`、元素 `key` 和正在遍历的 `map` 对象。
- en: Description
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `forEach` strategy executes the given callback once to every key of the
    guide that really exists. It is not conjured for keys that have been erased. Nonetheless,
    it is executed for values that are available; however, they have the value defined.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 策略对指南中实际存在的每个键执行给定的回调一次。它不针对已删除的键进行构造。不过，它会对可用的值执行；然而，它们具有定义的值。'
- en: 'Here is an example of this method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Map.prototype.get()
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.get()`'
- en: A specific element from the map is returned using the `get()` method.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `get()` 方法返回映射中的特定元素。
- en: Returns
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the key that is used as a parameter (only if it is found in map);
    or else, it returns an error message.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回用作参数的键（仅在映射中找到时）；否则，它返回错误信息。
- en: Parameter
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: It requires a key that is to be returned from the map.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个从映射中返回的键。
- en: Description
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: We input a key that we want to find in the map, and the function returns it.
    It is used when we want to get the value of an element.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入一个想要在映射中找到的键，函数返回它。当我们要获取元素的值时使用。
- en: 'Here is an example of this method:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Map.prototype.has()
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.has()`'
- en: The function returns `true` (Boolean value) if the element exists and `false`
    if it does not.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素存在，则函数返回 `true`（布尔值），如果不存在，则返回 `false`。
- en: Returns
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns `true` if a component with the specified key exists in the `map`
    object. If not found, it returns `false`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `map` 对象中存在具有指定键的组件，则返回 `true`。如果没有找到，则返回 `false`。
- en: Parameter
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: A key is required.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个键。
- en: Description
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: We pass a key in the function to check whether a certain element exists in the
    map or not. If the element exists, `true` is returned; otherwise, `false` is returned.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中传递一个键来检查某个元素是否存在于映射中。如果元素存在，则返回 `true`；否则，返回 `false`。
- en: 'An example of this method is shown here:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Map.prototype.keys()
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.keys()`'
- en: It returns keys for every element in the map.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回映射中每个元素的键。
- en: Returns
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns a new object that contains the keys of all elements on the map.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个新对象，该对象包含映射上所有元素的键。
- en: Parameter
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: There is no input parameter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输入参数。
- en: Description
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `keys()` strategy gives back another `iterator` object that contains the
    keys for every component in the `map` object in the insertion order.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()` 策略返回另一个 `iterator` 对象，该对象包含 `map` 对象中每个组件的键，按插入顺序排列。'
- en: 'An example of this method is shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Map.prototype.set()
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.set()`'
- en: This is the procedure to add a new element on map.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向映射中添加新元素的程序。
- en: Returns
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the `map` object.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回 `map` 对象。
- en: Parameter
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: This is the key of the element to be added on map.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将要添加到映射中的元素的键。
- en: Description
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `set()` strategy includes another component with a predetermined key and
    value to a `map` object.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 策略将具有预定键和值的另一个组件包含到 `map` 对象中。'
- en: 'An example of this method is shown here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Map.prototype.values()
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Map.prototype.values()`'
- en: This is the method to get a new object containing values of each element.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取包含每个元素值的新的对象的方法。
- en: Returns
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns an object that has values of all components on map.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个对象，该对象包含映射上所有组件的值。
- en: Parameter
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: There is no input parameter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输入参数。
- en: Description
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `values()` technique gives back another `iterator` object that contains
    the values for every component in the `map` object in the insertion manner.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`values()` 技术返回另一个 `iterator` 对象，该对象包含 `map` 对象中每个组件的值，以插入顺序返回。'
- en: 'Here is an example of this method:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个方法的例子：
- en: '[PRE51]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: WeakMap
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WeakMap
- en: It is the same as map, but there is some difference in it. It only accepts objects
    as keys. Primitive data types are not allowed in `WeakMap`. There is no garbage
    collection in a `WeakMap` because it doesn't reference to an object acting like
    a key. As a result of these differences, there is no method to access keys in
    `WeakMap`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 map 相同，但有一些区别。它只接受对象作为键。不允许在 `WeakMap` 中使用原始数据类型。由于 `WeakMap` 不引用像键一样的对象，因此没有垃圾回收。由于这些差异，没有方法可以访问
    `WeakMap` 中的键。
- en: Note
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keys in `WeakMap` are not enumerable, which means that there is no method to
    give you a list of keys. There is size property available in `WeakMap`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap` 中的键不可枚举，这意味着没有方法可以给你一个键的列表。`WeakMap` 中有大小属性可用。'
- en: 'Here is an example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: WeakMap.prototype.clear()
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakMap.prototype.clear()
- en: This is used to remove all elements from the `WeakMap`. This is obsolete now,
    but is, however, still used in a few browsers.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于从 `WeakMap` 中移除所有元素。现在已过时，但仍然在一些浏览器中使用。
- en: Returns
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the key of the element to be removed from the `WeakMap` object.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回要从中删除的 `WeakMap` 对象的键。
- en: Parameters
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: This is t key of the element to be removed from the `WeakMap` object.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要从 `WeakMap` 对象中删除的元素的键。
- en: Description
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: 'Here is an example:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: WeakMap.prototype.delete()
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakMap.prototype.delete()
- en: This method is used to remove a specific object from `WeakMap`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于从 `WeakMap` 中删除特定对象。
- en: Returns
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns `true` if an element in the `WeakMap` object has been removed successfully.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `WeakMap` 对象中的元素已成功删除，则返回 `true`。
- en: Parameters
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: This is the key of the element to remove from the `WeakMap` object.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要从 `WeakMap` 对象中删除的元素的键。
- en: Description
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `delete()` method removes the specified element from a `WeakMap` object.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()` 方法从 `WeakMap` 对象中删除指定的元素。'
- en: 'Here is an example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE54]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: WeakMap.prototype.get()
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakMap.prototype.get()
- en: This method is used to retrieve a specific object from `WeakMap`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于从 `WeakMap` 中检索特定对象。
- en: Returns
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the element associated with the specified key or is undefined if
    the key can't be found in the `WeakMap` object.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回与指定键关联的元素，如果键在 `WeakMap` 对象中找不到，则返回 `undefined`。
- en: Parameters
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: This is the key of the element to return from the `WeakMap` object.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回自 `WeakMap` 对象的元素的键。
- en: Description
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The key of the element to return from the `WeakMap` object.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `WeakMap` 对象中元素的键。
- en: 'Here is an example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE55]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: WeakMap.prototype.has()
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakMap.prototype.has()
- en: This method is used to check whether the specified object exists in `WeakMap`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于检查指定对象是否存在于 `WeakMap` 中。
- en: Returns
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns `true` if an element with the specified key exists in the `WeakMap`
    object; otherwise it returns `false`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `WeakMap` 对象中存在具有指定键的元素，则返回 `true`；否则返回 `false`。
- en: Parameters
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: It is the key of the element to test for presence in the `WeakMap` object.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 它是要在 `WeakMap` 对象中测试是否存在的关键的键。
- en: Description
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `has()` method returns a Boolean indicating whether an element with the
    specified key exists in the `WeakMap` object or not.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`has()` 方法返回一个布尔值，指示具有指定键的元素是否存在于 `WeakMap` 对象中。'
- en: 'Here is an example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: WeakMap.prototype.set()
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakMap.prototype.set()
- en: This method is used to add an object to a specific location.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将对象添加到特定位置。
- en: Returns
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: The `WeakMap` object.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap` 对象。'
- en: Parameters
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: '`Key`: The key of the element to add to the `WeakMap` object'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key`：要添加到 `WeakMap` 对象中的元素的键'
- en: '`Value`: The value of the element to add to the `WeakMap` object'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`：要添加到 `WeakMap` 对象中的元素的值'
- en: Description
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `set()` method adds a new element with a specified key and value to a `WeakMap`
    object.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 方法向 `WeakMap` 对象添加具有指定键和值的新元素。'
- en: 'Here is an example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE57]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Weakset
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Weakset
- en: This is a collection of objects that don't stop its elements from being garbage
    collected. There is no looping, iteration, and learning in `WeakSet`. It has three
    methods.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不阻止其元素被垃圾回收的对象集合。在 `WeakSet` 中没有循环、迭代和学习。它有三个方法。
- en: WeakSet.prototype.add(someValue)
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakSet.prototype.add(someValue)
- en: This method appends a new object at the end of the `WeakSet`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将新对象追加到 `WeakSet` 的末尾。
- en: Returns
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回
- en: The `WeakSet.prototype.add(someValue)` method returns Nothing
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet.prototype.add(someValue)` 方法返回 `Nothing`'
- en: Parameter
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: The object to add to the `WeakSet` collection.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加到 `WeakSet` 集合中的对象。
- en: Description
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `add()` method appends a new object to the end of a `WeakSet` object.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()` 方法将新对象追加到 `WeakSet` 对象的末尾。'
- en: 'An example of this method is as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个方法的示例：
- en: '[PRE58]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: WeakSet.prototype.delete(someValue)
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakSet.prototype.delete(someValue)
- en: This method removes the specified object from `WeakSet`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从 `WeakSet` 中删除指定的对象。
- en: Returns
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回
- en: Returns `true` if the value is found in `WeakSet` and is deleted. Returns `false`
    if the value is not found.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `WeakSet` 中找到值并将其删除，则返回 `true`。如果找不到值，则返回 `false`。
- en: Parameter
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: The value to be deleted is sent as a parameter.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除的值作为参数发送。
- en: Description
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `delete()` strategy expels the predefined element from a `WeakSet` object.
    It is used while we need to delete some element from `WeakSet`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()` 策略从 `WeakSet` 对象中移除预定义的元素。在我们需要从 `WeakSet` 中删除某些元素时使用。'
- en: 'An example of this method is as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE59]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: WeakSet.prototype.has(someValue)
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeakSet.prototype.has(someValue)
- en: This method will return `true` if the object exists in `WeakSet`; otherwise,
    `false` is returned.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象存在于 `WeakSet` 中，则此方法将返回 `true`；否则返回 `false`。
- en: Returns
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回
- en: It returns `true` if a component with the predefined value exists in the `WeakSet`
    object; otherwise, it returns `false`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `WeakSet` 对象中存在具有预定义值的组件，则返回 `true`；否则返回 `false`。
- en: Parameter
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: Requires a value that is to be searched.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个要搜索的值。
- en: Description
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The `has()` technique gives back a Boolean demonstrating whether an item exists
    in `WeakSet` or not.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`has()` 技术返回一个布尔值，表明项目是否存在于 `WeakSet` 中。'
- en: 'An example of this method is shown here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个方法的示例：
- en: '[PRE60]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It has only arbitrary values. References of objects are held in a weak manner
    in a `WeakSet` object. They can also be garbage collectors. In `WeakSet`, there
    is no list of current objects because of the garbage collector. These objects
    are not enumerable.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有任意值。在 `WeakSet` 对象中以弱引用方式持有对象的引用。它们也可以是垃圾收集器。由于垃圾收集器，`WeakSet` 中没有当前对象的列表。这些对象是不可枚举的。
- en: 'Here is an example:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE61]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Proxies
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: Proxies enable object creation with a wide range of behaviors available to host
    objects. They can be used for object virtualization, interception, logging/profiling,
    and so on. Proxies provide developers with an unprecedented control over objects
    and unlimited possibilities to define new interaction patterns.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许以广泛的行为创建对象，这些行为可用于宿主对象。它们可用于对象虚拟化、拦截、日志/分析等。代理为开发者提供了前所未有的对象控制能力，以及定义新交互模式的无限可能性。
- en: 'Here is an example:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE62]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Symbols
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: A symbol is a unique type which can be used as an identifier for object properties.
    The symbol object is an implicit object wrapper for the symbol primitive data
    type.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是一种独特类型，可以用作对象属性的标识符。符号对象是对符号原始数据类型的隐式对象包装。
- en: 'Here is how you can create a new primitive symbol:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何创建一个新的原始符号：
- en: '[PRE63]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: OR
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE64]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding code creates two new symbols. `Symbol('abc')` does not force converts
    `abc` into an object but creates a new separate object.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了两个新的符号。`Symbol('abc')` 并不强制将 `abc` 转换为对象，而是创建了一个新的独立对象。
- en: '[PRE65]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using `Symbol()` with new keyword will throw a type error.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol()` 与 `new` 关键字会抛出类型错误。
- en: '[PRE66]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This prevents creation of an explicit Symbol wrapper object instead of a new
    symbol value. Creating an explicit wrapper object around primitive data types
    were only supported until ES5\. However, existing primitive wrapper objects like
    new Boolean, new `String` and new `Number` can still be created for legacy reasons.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了创建显式的符号包装对象而不是新的符号值。在 ES5 之前，仅支持在原始数据类型周围创建显式包装对象。然而，出于历史原因，仍然可以创建新的原始包装对象，如
    new Boolean、new `String` 和 new `Number`。
- en: 'And if it is necessary to create Symbol wrapper object, you can use the `Object()`
    function:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要创建符号包装对象，可以使用 `Object()` 函数：
- en: '[PRE67]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Object.getOwnPropertySymbols()` method returns an array of symbols and
    lets you find symbol properties on a given object.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()` 方法返回一个符号数组，并允许您在给定的对象上找到符号属性。'
- en: 'Here is an example:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE68]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ECMAScript 6 standard uses a special notation to indicate symbols, prefixing
    the identifier with `@@`, such as `@@create`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 标准使用特殊的符号表示法来表示符号，例如在标识符前加上 `@@`，如 `@@create`。
- en: Subclassable built-ins
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可继承的内置对象
- en: 'In ECMAScript 6, built-ins such as Date, Array, and DOM elements can be subclassed.
    Object construction for a function named `Ctor` now uses two phases:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 中，Date、Array 和 DOM 元素等内置对象可以被继承。名为 `Ctor` 的对象构造现在使用两个阶段：
- en: Call `Ctor[@@create]` to allocate the object and install any special behavior
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `Ctor[@@create]` 以分配对象并安装任何特殊行为
- en: Invoke constructor on new instance to initialize it
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新实例上调用构造函数以初始化它
- en: The known `@@create` symbol is available via `Symbol.create`. Built-ins now
    expose their `@@create` syntax explicitly.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 已知的 `@@create` 符号可通过 `Symbol.create` 获取。内置对象现在明确公开它们的 `@@create` 语法。
- en: 'Here is an example:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE69]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Promises
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Promises`'
- en: ECMAScript 6 introduced promises. It is a library used for asynchronous programming.
    It is a first-class representation of a value that may be made available in the
    future. Many existing JavaScript libraries already use promises.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 引入了 `promise`。这是一个用于异步编程的库。它是对未来可能可用值的顶级表示。许多现有的 JavaScript 库已经使用了
    `promise`。
- en: Some of the methods for promises in ES6 are mentioned here.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中提到的关于 `promise` 的某些方法。
- en: Promise.All()
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.All()
- en: This method returns a promise that is resolved once all the promises in the
    iterable argument have been resolved. In the case of a rejection, it returns with
    the reason of the first-passed promise that was rejected.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `promise`，一旦可迭代参数中的所有 `promise` 都已解决，它就会解决。在拒绝的情况下，它返回第一个被拒绝的 `promise`
    的原因。
- en: Returns
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The `Promise.All()` method returns nothing.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.All()` 方法返回空值。'
- en: Parameter
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: An `iterable` object, such as an array.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `iterable` 对象，例如一个数组。
- en: Description
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Promises returns result as an array of values. If any value in the array is
    not a promise, then it is converted using Promise.resolve. If any of the passed
    in promises rejects, then all promise are rejected and the reason of rejection
    of a promise is returned. It discards all other promise whether they have been
    resolved or not. If an empty array is passed, then this method resolves immediately.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promises` 返回一个值数组的结果。如果数组中的任何值不是 `promise`，则使用 `Promise.resolve` 转换它。如果传递的任何
    `promise` 被拒绝，则所有 `promise` 都会被拒绝，并返回一个 `promise` 拒绝的原因。它丢弃所有其他 `promise`，无论它们是否已解决。如果传递一个空数组，则此方法立即解决。'
- en: 'An example of this method is shown here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此方法的示例：
- en: '[PRE70]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Promise.prototype.catch()
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.prototype.catch()
- en: This method is used only in cases where objects are rejected. It works the same
    as `promise.prototype.then()`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅在对象被拒绝的情况下使用。它的工作方式与 `promise.prototype.then()` 相同。
- en: Returns
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The `promise.prototype.catch()` method returns nothing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise.prototype.catch()` 方法返回空值。'
- en: Parameter
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: '**One rejected**: A function called when the `promise` is rejected. This function
    has one argument, the rejection reason.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个拒绝的**: 当 `promise` 被拒绝时调用的 `function`。此函数有一个参数，即拒绝的原因。'
- en: Description
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `catch()` technique gives back a `promise` and manages rejected cases. It
    behave similar as calling `Promise.prototype.then(undefined, onRejected)`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch()` 方法返回一个 `promise` 并处理拒绝的情况。它的行为类似于调用 `Promise.prototype.then(undefined,
    onRejected)`。'
- en: 'An example of this method is as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此方法的示例：
- en: '[PRE71]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Promise.resolve(value)
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Promise.resolve(value)`'
- en: This method returns a `promise` object that is resolved by the specified value.
    If the value is associated to a then method, the returned promise will move to
    the then method, adopting its final state. Otherwise, the returned promise will
    be fulfilled with the specified value.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `promise` 对象，该对象由指定的值解决。如果该值关联到一个 `then` 方法，则返回的 `promise` 将移动到 `then`
    方法，采用其最终状态。否则，返回的 `promise` 将以指定的值实现。
- en: Returns
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The `promise` object that is resolved with the given value.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定值的 `promise` 对象。
- en: Parameter
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: 'Let''s take a look at the following parameters and their use:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下参数及其用法：
- en: '`onFulfilled`: A `function` called when the `Promise` is fulfilled'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onFulfilled`: 当 `Promise` 被实现时调用的 `function`'
- en: '`onRejected`: A `function` called when the `promise` is rejected'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRejected`: 当 `promise` 被拒绝时调用的 `function`'
- en: Description
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Promise.resolve(value)` system gives back a `Promise` question that is
    determined with the given quality. On the off chance that the quality is a then
    able (that is, has a then technique), the returned promise will *follow* that
    then able, adopting its possible state.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.resolve(value)` 系统返回一个 `Promise` 对象，该对象根据给定的质量确定。如果质量是一个可 `then` 的（即，有一个
    `then` 方法），则返回的 `promise` 将会 *跟随* 那个可 `then` 的，采用其可能的状态。'
- en: 'The `then()` technique gives back a `Promise`. It takes two contentions: callback
    capacities for the achievement and disappointment instances of the `Promise`.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()` 技术返回一个 `Promise`。它接受两个参数：成功和失败实例的回调能力。'
- en: Using the then method
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 then 方法
- en: 'An example of this method is as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE72]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Chaining
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链式调用
- en: 'As the `then()` method returns a `Promise`, you can easily chain `then` calls:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `then()` 方法返回一个 `Promise`，您可以轻松地链式调用 `then`：
- en: '[PRE73]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also use chaining to implement one function with a Promise-based API
    on top of another such function:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用链式调用在另一个函数之上实现一个基于承诺的API的函数：
- en: '[PRE74]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Promise.reject(value)
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.reject(value)
- en: This function returns a promise object that is rejected because of the passed
    value/reason.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个承诺对象，该对象因传递的值/原因而被拒绝。
- en: Returns
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Promise.reject()` method returns a simple output telling the reason for
    rejection.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.reject()` 方法返回一个简单的输出，说明拒绝的原因。'
- en: Parameter
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Reason why this promise is rejected.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这个承诺被拒绝的原因。
- en: Description
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Promise.reject()` function capacity gives back a `Promise` that
    is rejected. For troubleshooting purposes and specific mistake finding, it is
    helpful to make the reason an instance of error.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Promise.reject()` 函数能力返回一个被拒绝的 `Promise`。为了故障排除和特定错误查找，将原因设置为错误实例很有帮助。
- en: 'An example of this method is shown here:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE75]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Promise.race(value)
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.race(value)
- en: This function returns a promise that is resolved or rejected the same way as
    the promises passed in iterable, with the value or reason from that promise.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个承诺，其解决或拒绝的方式与可迭代中传递的承诺相同，使用该承诺的值或原因。
- en: Returns
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Promise.race()` function returns a promise.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race()` 函数返回一个承诺。'
- en: Parameter
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: An `iterable` object, such as an array.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代的对象，例如一个数组。
- en: Description
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `race` function gives back a `Promise` that is settled the same route as
    the initially passed `Promise` to settle. It determines or rejects, whichever
    happens first.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`race` 函数返回一个 `Promise`，其解决的方式与最初传递的 `Promise` 相同。它确定或拒绝，哪个先发生。'
- en: 'An example of this method is as follows:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE76]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Core math library APIs
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心数学库API
- en: ECMAScript 6 has made several new extensions to the prebuilt libraries, including
    core `Math` libraries, `arrays`, `string` `helpers`, and `Object.assign` for copying.
    These new methods help in speeding up the execution process, hence resulting in
    enhancing the performance of applications that may perform calculations and string
    manipulation. It also improves the speed of applications that must perform many
    calculations and string manipulations.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 对预构建库进行了几个新的扩展，包括核心 `Math` 库、`数组`、`字符串` 辅助工具和用于复制的 `Object.assign`。这些新方法有助于加快执行过程，从而提高可能执行计算和字符串操作的应用程序的性能。它还提高了必须执行许多计算和字符串操作的应用程序的速度。
- en: 'Numerous new library increases, including core Math libraries, array conversion
    helpers, string helpers, and `Object.assign` for copying. An example of using
    the Core Math Library APIs is as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 包括核心数学库、数组转换辅助工具、字符串辅助工具和用于复制的 `Object.assign` 在内的许多新库增加。以下是一个使用核心数学库API的示例：
- en: '[PRE77]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Binary and octal literals
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制和八进制字面量
- en: ECMAScript 6 introduced binary and octal literal notations, for binary (b) and
    octal (o). Both these notations are a little similar to hexadecimal literal notation
    for prepending 0x or 0X to a value.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 引入了二进制和八进制字面量表示法，用于二进制（b）和八进制（o）。这两种表示法与十六进制字面量表示法类似，需要在值前添加 `0x`
    或 `0X`。
- en: 'The new octal literal format begins with `0o` or `0O`, while the new binary
    literal format begins with `0b` or `0B`. Each literal type must be followed by
    one or more digits; 0-7 for octal and 0-1 for binary. Here''s an example:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 新的八进制字面量格式以 `0o` 或 `0O` 开头，而新的二进制字面量格式以 `0b` 或 `0B` 开头。每种字面量类型必须后跟一个或多个数字；八进制为0-7，二进制为0-1。以下是一个示例：
- en: '[PRE78]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Reflect API
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射API
- en: The `reflect` object is a single object that contains functions related to the
    reflection API. As the name suggests, it is merely a reflection of the objects
    so that one can observe them closely, regardless of who the object was created
    by. The `reflect` object is not a `function` object. It does not have a `constructor`
    method. It cannot be invoked as a function, because it does not have a `call`
    method.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect` 对象是一个包含与反射API相关的函数的单个对象。正如其名所示，它仅仅是对象的反射，以便可以密切观察它们，无论对象是由谁创建的。`reflect`
    对象不是一个 `function` 对象。它没有 `constructor` 方法。它不能作为一个函数调用，因为它没有 `call` 方法。'
- en: Reflect API is known to be the inverse of Proxy API.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Reflect API 被认为是 Proxy API 的逆操作。
- en: Here is a list of methods a `reflect` object has.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `reflect` 对象具有的方法列表。
- en: Reflect.get(target, prop, [receiver])
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.get(target, prop, [receiver])
- en: This method allows you to get the property of an object. This method is similar
    to property accessors syntax (`object[propertyKey]`).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许您获取对象的属性。此方法也与属性访问器语法类似。
- en: Returns
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `reflect` object returns the value of property.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect` 对象返回属性的值。'
- en: Parameter
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The parameters are target objects on which to get property, the name of property,
    and the value.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是获取属性的 target 对象、属性名称和值。
- en: Description
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.get()` method works like getting a property from an object
    (`target[propertyKey]`) as a function.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.get()` 方法的工作方式类似于从对象中获取属性（`target[propertyKey]`）作为一个函数。
- en: 'An example of the get method is as follows:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 获取方法的示例如下：
- en: '[PRE79]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Reflect.set(target, prop, value, [receiver])
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.set(target, prop, value, [receiver])
- en: This method allows you to set a property of an object. This method is also similar
    to property accessor syntax.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许您设置对象的属性。此方法也与属性访问器语法类似。
- en: Returns
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.set(target, prop, value, [receiver]` returns a Boolean value indicating
    whether property was successful or not.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.set(target, prop, value, [receiver]` 返回一个布尔值，指示属性设置是否成功。'
- en: Parameter
  id: totrans-573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Parameters are target objects, name of the property, the value to set, and the
    receiver.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是目标对象、属性名称、要设置的值和接收者。
- en: Description
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.set()` strategy works like setting a property on an item.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.set()` 策略的工作方式类似于在项上设置属性。
- en: 'An example of this method is shown here:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下所示：
- en: '[PRE80]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Reflect.has(target, prop)
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.has(target, prop)
- en: This method allows you to check whether an object holds a specific property.
    This method is similar to the in operator.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许您检查一个对象是否具有特定的属性。此方法与 in 操作符类似。
- en: Returns
  id: totrans-581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.has(target, prop)` returns a Boolean value indicating whether the
    target has a property or not.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.has(target, prop)` 返回一个布尔值，指示目标是否具有属性。'
- en: Parameter
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object and the property key (name of property to check) is passed.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标对象和属性键（要检查的属性名称）传递。
- en: Description
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.has()` technique works like the in operator as a function.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.has()` 技术作为函数类似于 in 操作符。
- en: 'An example of this method is shown here:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下所示：
- en: '[PRE81]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Reflect.apply(target, receiver, args)
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.apply(target, receiver, args)
- en: This method is used to call a target function with a specified set of arguments.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于使用指定的一组参数调用目标函数。
- en: Returns
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.apply(target, receiver, args)` method returns nothing.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.apply(target, receiver, args)` 方法不返回任何内容。'
- en: Parameter
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Target function to call. `thisArgument` and `ArgumentList` is passed as parameters.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用的目标函数。`thisArgument` 和 `ArgumentList` 作为参数传递。
- en: Description
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.apply()` technique calls an objective function with specified
    arguments.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.apply()` 技术使用指定的参数调用目标函数。
- en: 'An example of this method is shown here:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下所示：
- en: '[PRE82]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Reflect.construct(target, args)
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.construct(target, args)
- en: This method allows you to call a `constructor` function with multiple arguments.
    It is just like calling new function (…args).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许您使用多个参数调用 `constructor` 函数。它就像调用 new 函数（…args）一样。
- en: Returns
  id: totrans-601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.construct(target, args)` returns nothing.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.construct(target, args)` 不返回任何内容。'
- en: Parameter
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target function to be called, an argument list, and the new target (constructor
    to be used) are parameters.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用的目标函数、参数列表和新目标（要使用的构造函数）是参数。
- en: Description
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.construct` method permits you to conjure a constructor with a variable
    number of contentions (which would likewise be conceivable utilizing the spread
    operator consolidated with the new operator).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.construct` 方法允许您使用可变数量的内容（这也可以使用与 new 操作符结合的展开运算符来实现）来构造构造函数。'
- en: 'An example of this method is shown here:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下所示：
- en: 'Using `Reflect.construct()`:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `Reflect.construct()`:'
- en: '[PRE83]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using `newTarget`:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `newTarget`:'
- en: '[PRE84]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Reflect.getOwnPropertyDescriptor(target, prop)
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.getOwnPropertyDescriptor(target, prop)
- en: This method is just like `Object.getOwnPropertyDescriptor()`. This method returns
    a property descriptor of a specific property if it exists on an object; otherwise,
    undefined is returned. The only difference between these two is the way non-object
    targets are handled.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于 `Object.getOwnPropertyDescriptor()`。如果该属性存在于对象上，此方法将返回该属性的属性描述符；否则，返回
    undefined。这两个方法之间的唯一区别是处理非对象目标的方式。
- en: Returns
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.getOwnPropertyDescriptor(target, prop)` method returns a property
    descriptor object.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.getOwnPropertyDescriptor(target, prop)` 方法返回一个属性描述符对象。'
- en: Parameter
  id: totrans-616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object in which to look for property, and property key (name of the
    property to be applied) are the parameters.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找属性的目标对象和属性键（要应用的属性名称）是参数。
- en: Description
  id: totrans-618
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.getOwnPropertyDescriptor` system gives back a property descriptor
    of the given property in the event that it exists on the object, indistinct something
    else undefined is returned if property does not exists. The main contrast to `Object.getOwnPropertyDescriptor()`
    is the manner by which non-object targets are taken care of.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.getOwnPropertyDescriptor` 系统在属性存在于对象的情况下返回给定属性的属性描述符，如果属性不存在，则返回 undefined。与
    `Object.getOwnPropertyDescriptor()` 的主要区别是处理非对象目标的方式。'
- en: 'An example of this method is shown here:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: 'Using `Reflect.getOwnPropertyDescriptor()`:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Reflect.getOwnPropertyDescriptor()`：
- en: '[PRE85]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Difference to `Object.getOwnPropertyDescriptor()`:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Object.getOwnPropertyDescriptor()` 的区别：
- en: 'If the first argument to this method is not an object (a primitive), then it
    will cause a `TypeError`. With `Object.getOwnPropertyDescriptor`, a non-object
    first argument will be coerced to an object at first:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此方法的第一个参数不是对象（原始类型），则会导致 `TypeError`。在 `Object.getOwnPropertyDescriptor` 中，非对象第一个参数最初会被强制转换为对象：
- en: '[PRE86]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Reflect.defineProperty(target, prop, desc)
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.defineProperty(target, prop, desc)
- en: This method is similar `toObject.defineProperty()`. This method allows us to
    modify the property of an object. The `Object.defineProperty()` method returns
    an object or returns a type error if the property is not defined successfully.
    The `Reflect.defineProperty()` method returns `true` if the property was defined
    successfully. Otherwise, it returns `false`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于 `Object.defineProperty()`。此方法允许我们修改对象的属性。`Object.defineProperty()` 方法在属性成功定义后返回一个对象，如果属性定义不成功则返回类型错误。`Reflect.defineProperty()`
    方法如果属性成功定义则返回 `true`，否则返回 `false`。
- en: Returns
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.defineProperty(target, prop, desc)` method returns a Boolean demonstrating
    regardless of whether the property was effectively characterized.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.defineProperty(target, prop, desc)` 方法返回一个布尔值，表明属性是否被有效定义。'
- en: Parameter
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Target object, property key, and attributes are the parameters.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象、属性键和属性是参数。
- en: Description
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.defineProperty` technique permits the exact expansion to or change
    of a property on an object. For more subtle elements, see the `Object.defineProperty`,
    which is comparative. `Object.defineProperty` gives back the objects or tosses
    `TypeError` if the property has not been effectively characterized. `Reflect.defineProperty`,
    then again, essentially gives back a Boolean demonstrating regardless of whether
    the property was effectively characterized.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.defineProperty` 技巧允许精确地扩展或更改对象上的属性。对于更微妙的部分，请参阅比较的 `Object.defineProperty`。`Object.defineProperty`
    在属性成功定义后返回对象，如果属性定义不成功则抛出 `TypeError`。`Reflect.defineProperty` 再次，基本上返回一个布尔值，表明属性是否被有效定义。'
- en: 'An example of this method is shown here:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: 'Using `Reflect.defineProperty()`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Reflect.defineProperty()`：
- en: '[PRE87]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Checking if property definition has been successful:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 检查属性定义是否成功：
- en: 'With `Object.defineProperty`, which returns an object if successful or throws
    a `TypeError` otherwise, you would use a `try...catch` block to catch any error
    that occurred while defining a property. As `Reflect.defineProperty` returns a
    Boolean success status, you can just use an `if...else` block here:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Object.defineProperty` 中，如果成功则返回对象，否则抛出 `TypeError`，您会使用 `try...catch` 块来捕获定义属性时发生的任何错误。由于
    `Reflect.defineProperty` 返回一个布尔成功状态，您在这里可以使用 `if...else` 块：
- en: '[PRE88]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Reflect.getPrototypeOf(target)
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.getPrototypeOf(target)
- en: This method returns a prototype of the specified object. It is similar to the
    `Object.getPrototypeOf()` method.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回指定对象的原型。它与 `Object.getPrototypeOf()` 方法类似。
- en: Returns
  id: totrans-642
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.getPrototypeOf(target)` method returns the prototype of object
    or null.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.getPrototypeOf(target)` 方法返回对象的原型或 null。'
- en: Parameter
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object for which we need the prototype is passed as a parameter.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要原型目标对象作为参数传入。
- en: Description
  id: totrans-646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.getPrototypeOf()` method is the same technique as `Object.getPrototypeOf()`.
    It gives back the model (that is, the estimation of the inside `[[Prototype]]`
    property) of the predetermined item.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 静态`Reflect.getPrototypeOf()`方法与`Object.getPrototypeOf()`相同的技术。它返回预定项的模型（即内部`[[Prototype]]`属性的估计）。
- en: 'An example of this method is shown here:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE89]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Reflect.setPrototypeOf(target, newProto)
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.setPrototypeOf(target, newProto)
- en: This method sets the prototype of object to another object or to null. This
    method is the same as the `Object.setPrototypeOf()` method.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将对象的原型设置为另一个对象或null。此方法与`Object.setPrototypeOf()`方法相同。
- en: Returns
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.setPrototypeOf(target, newProto)` method returns a Boolean showing
    regardless of whether the model was effectively set.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.setPrototypeOf(target, newProto)`方法返回一个布尔值，表明模型是否被有效设置。'
- en: Parameter
  id: totrans-654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object and prototype are parameters.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象和原型是参数。
- en: Description
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.setPrototypeOf` method changes the prototype (that is, the value
    of the internal `[[Prototype]]` property) of the specified object.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.setPrototypeOf`方法更改指定对象的原型（即内部`[[Prototype]]`属性的值）。'
- en: 'An example of this method is shown here:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE90]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Reflect.deleteProperty(target, prop)
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.deleteProperty(target, prop)
- en: This method is used to delete properties from an object. This method is similar
    to the delete operator as a function.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于从对象中删除属性。此方法类似于delete操作符作为函数。
- en: Returns
  id: totrans-662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.deleteProperty(target, prop)` method returns a Boolean value telling
    us whether the property is deleted or not.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.deleteProperty(target, prop)`方法返回一个布尔值，告诉我们属性是否被删除。'
- en: Parameter
  id: totrans-664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object and the name of the property to be deleted are parameters.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象和要删除的属性名称是参数。
- en: Description
  id: totrans-666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.deleteProperty` method permits you to erase a property on an object.
    It returns boolean value indicating if the property was successfully removed or
    not, regardless of whether the property was effectively characterized. It is almost
    similar to the non-strict delete operator.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.deleteProperty`方法允许你在对象上删除属性。它返回一个布尔值，表示属性是否成功移除，无论该属性是否被有效定义。它与非严格delete操作符几乎相同。'
- en: 'An example of this method is shown here:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE91]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Reflect.enumerate(target)
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.enumerate(target)
- en: This method returns an iterator with enumerable own and inherited properties
    of the target object.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个包含目标对象枚举自有和继承属性的迭代器。
- en: Returns
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: Returns an iterator with the enumerable own and acquired properties of the objective
    object.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含目标对象枚举自有和获取属性的迭代器。
- en: Parameter
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Target object on which to get property is passed in the function.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中传入的目标对象用于获取属性。
- en: Description
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Reflect.enumerate()` method returns an iterator with the enumerable own
    and inherited properties of the target object.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.enumerate()`方法返回一个包含目标对象的枚举自有和继承属性的迭代器。'
- en: 'An example of this method is shown here:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE92]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Reflect.preventExtensions(target)
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.preventExtensions(target)
- en: This is the same method as `Object.preventExtensions()`. It prevents us from
    adding more properties (extensions) to an object.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Object.preventExtensions()`相同方法。它阻止我们向对象添加更多属性（扩展）。
- en: Returns
  id: totrans-682
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: Returns a Boolean demonstrating regardless of whether the objective was effectively
    set to forestall expansions.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个布尔值，表明目标是否被有效设置为防止扩展。
- en: Parameter
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Target object on which we have to prevent extensions.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要防止扩展的目标对象。
- en: Description
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.preventExtensions()` method keeps new properties from always
    being added to an object (that is, counteracts future augmentations to the item).
    It is like `Object.preventExtensions()`, yet with a few contrasts.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 静态`Reflect.preventExtensions()`方法阻止新属性始终被添加到对象中（即，抵消对项目的未来增强）。它类似于`Object.preventExtensions()`，但有一些区别。
- en: 'An example of this method is as follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE93]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Reflect.isExtensible(target)
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Reflect.isExtensible(target)
- en: This method allows us to check whether new properties can be added to an object
    or whether the object is extensible or not. This method is similar to the `Object.isExtensible()`
    method.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们检查是否可以向对象添加新属性，或者对象是否可扩展。此方法类似于`Object.isExtensible()`方法。
- en: Returns
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A Boolean value indicating whether the target is extensible or not.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 一个布尔值，指示目标是否可扩展。
- en: Parameter
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The target object that has to be checked for its extensibility.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 需要检查其可扩展性的目标对象。
- en: Description
  id: totrans-696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.isExtensible()` technique figures out whether an item is
    extensible (whether it can have new properties added to it). It is like `Object.isExtensible()`,
    yet with a few contrasts.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.isExtensible()` 技术确定一个项是否可扩展（是否可以向它添加新属性）。它类似于 `Object.isExtensible()`，但有一些区别。
- en: 'An example of this method is shown here:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的示例如下：
- en: '[PRE94]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The preceding function will return `true`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将返回 `true`。
- en: Reflect.ownKeys(target)
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys(target)`'
- en: This method returns the object's own property keys.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回对象的自身属性键。
- en: Returns
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `Reflect.ownKeys(target)` method returns an array of target objects.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys(target)` 方法返回目标对象的一个数组。'
- en: Parameter
  id: totrans-705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: Target object from where to get keys.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 从中获取键的目标对象。
- en: Description
  id: totrans-707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The static `Reflect.set()` strategy works like setting a property on an object.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Reflect.set()` 策略的工作方式类似于在对象上设置属性。
- en: 'Here is an example of this method:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此方法的示例：
- en: '[PRE95]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Tail calls
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾调用
- en: Calls in tail position won't be able to grow the stack without any limits. It
    helps in making recursive algorithms safe and secure in the safe of unbounded
    inputs.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用位置中的调用不会在没有限制的情况下增长堆栈。这有助于在无界输入的情况下使递归算法安全且可靠。
- en: Example
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: The following function produces a factorial of any number passed to it. There
    is a tail call in the end of the function which recalls the function. Previously,
    we used to get a stackoverflow error, but ES6 is safe for handling arbitrary inputs.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数生成传递给它的任何数字的阶乘。函数末尾有一个尾调用，它调用了函数本身。以前，我们可能会得到堆栈溢出错误，但 ES6 对处理任意输入是安全的。
- en: 'If the output is out of range, it will simply display infinity:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出超出范围，它将简单地显示无穷大：
- en: '[PRE96]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
