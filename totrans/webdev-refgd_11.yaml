- en: Chapter 11. Extending JavaScript and ECMAScript 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMA 262 is a standard that defines the core features of the JavaScript language.
    The language that is defined by this standard is called **ECMAScript**. JavaScript
    is an implementation of ECMAScript. It runs in web browsers at the client end,
    while Node.js runs at the server end. ECMAScript 6 was released in June 2015\.
    ES6 is a major update from ES5, which was released in 2009.
  prefs: []
  type: TYPE_NORMAL
- en: A complete language specifications draft of ES6 language specifications can
    be obtained from [https://people.mozilla.org/~jorendorff/es6-draft.html](https://people.mozilla.org/~jorendorff/es6-draft.html).
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility and goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ES6 compatibility chart shows which features of ES6 are supported in the
    current browsers. It also links all listed features to their specification guides.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be noted that some of the features might not be under compliance with
    their exact specifications. While working in Chrome, don't forget to enable the
    Experimental JavaScript flags.
  prefs: []
  type: TYPE_NORMAL
- en: '![Compatibility and goals](img/B03289_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reference: Use ECMAScript 6 Today'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMA6 script has the following major goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Default exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static structure of modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for asynchronous and synchronous loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used for dependencies between modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript subset and extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subsets are mostly defined for security purposes; scripts written using secure
    language subsets can be executed safely even if its source is untrusted, for instance,
    an ad server. Some of these subsets will be described later.
  prefs: []
  type: TYPE_NORMAL
- en: As JavaScript continued to evolve and allowed explicit extensions, newer versions
    were released. Many of the features were standardized. These extensions are compatible
    with modern browsers such as Firefox and Chrome. However, the implementation of
    non-standard extensions may require an external compiler because these features
    are being updated in major JavaScript engines now.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript subsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, for execution security of untrusted code, we use subsets
    in JavaScript. For example, when we have a credit card checking script in which
    a credit card number is sent to a remote server, then for this type of information
    security, we use subset. By defining a subset, we check the behavior of a program
    that we have strictly not allowed. So, it means that we use subsets for a certain
    amount of code, and the other part of the code is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two goals of a JavaScript subset:'
  prefs: []
  type: TYPE_NORMAL
- en: The subset construct should be added to maximize coverage use of JavaScript
    constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used to extend analysis to accommodate changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These subset are defined for every reason.
  prefs: []
  type: TYPE_NORMAL
- en: '**The good parts**: This is a subset that is part of the language used for
    the best and the worthy part of the script. The main goal of this subset is it
    purifies and simplifies code, and makes the script easier and more understandable.
    The good parts subset does not have an `eval()` function. It also eliminates the
    `continue` and `with` statements. It does not include function definition statements,
    and only defines function using the function definition expression. Using a function
    definition statement, it defines a function, and then, after defining the function,
    it does not use the function definition statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In subset curly brackets, we have a body of loops and conditional statements.
    If there is a single statement in the body, then it would not allow the brackets
    to be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Secure subsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various implementations of secure subsets. Some of them are briefly
    described here.
  prefs: []
  type: TYPE_NORMAL
- en: ADsafe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**ADsafe** ([http://www.adsafe.org/](http://www.adsafe.org/)) was one of the
    first presented security subjects. It was proposed and created by Douglas Crockford.
    ADsafe uses tools such **asJSLint** ([http://www.jslint.com/](http://www.jslint.com/))
    to verify the unsafe code. It enforces good programming practices, so the likelihood
    of unsecure code executing correctly is much higher. It blocks the script from
    accessing the global variables or accessing the DOM directly. Instead, it allows
    the script to access the ADsafe object, which provides access to a secure API
    and indirect access to the DOM elements. ADsafe does not alter scripts and has
    no impact on its functionality. It enables us to determine quickly whether the
    script is safe to be placed on a page. It also works as a base that helps in the
    development of other secure subsets.'
  prefs: []
  type: TYPE_NORMAL
- en: Dojox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **dojox.secure** tool ([https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html](https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html))
    is a security subset inspired from ADsafe. It is an extension of the **Dojo**
    toolkit ([http://dojotoolkit.org](http://dojotoolkit.org)) and was developed by
    Kris Zyp. It is fully packed with components that ensure safe execution and loading
    of untrusted code, content, ads, and widgets from a different domain. It provides
    a sandbox environment and limited DOM elements for interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dojox](img/B03289_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Caja
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Caja** ([https://developers.google.com/caja/](https://developers.google.com/caja/))
    is an open source secure subset powered by Google. Caja (which means "**box**"
    in Spanish) further defines two subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cajita** (which means "**small box**" in Spanish) is a narrow subset just
    like ADsafe and dojox.secure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valija** (which means "**suitcase**" in Spanish) is a broader subset and
    is much more similar to ECMAScript in strict mode (with the `eval()` method removed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caja is a compiler tool that transforms third-party content such as HTML, CSS,
    and JS into secure code, which is then easy to embed in a website.
  prefs: []
  type: TYPE_NORMAL
- en: FBJS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**FBJS** ([https://github.com/facebook/fbjs](https://github.com/facebook/fbjs))
    is a JavaScript secure subset used by Facebook. It allows untrusted code to be
    executed in a secure environment. It transforms code to ensure security. During
    the transformation, all top-level identifiers are renamed by adding the module-specific
    prefix. Adding module specific prefix prevents querying any global identifiers.
    For example, you are developing an app having the `xyz123` ID, and there is a
    `foo()` function in the code. It will eventually become `xyz123_foo()`. Even function
    calls to `eval()` are redirected to a non-existent function.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's web sandbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Microsoft''s **Web Sandbox** ([http://www.websandbox.org/](http://www.websandbox.org/))
    defines a broad secure subset of JavaScript, HTML, and CSS. Sandbox implements
    host virtualization to provide security and extensibility. The untrusted code
    is executed in a virtual machine instead of running directly in a browser. A virtual
    machine quarantines the untrusted code, which prevents it from interacting with
    the elements outside the virtual machine. Let''s take a look at the following
    block diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft''s web sandbox](img/B03289_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft's Web Sandbox
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of new and useful features have been coded. They will be standardized with
    the release of ES6\. ES6 was set to be officially released in June 2015\. However,
    many of the features and extensions are already available on Firefox and Chrome
    (Experimental JavaScript flag has to be turned *on* in order to access some of
    the ES6 features). We will discuss the major features in the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works like variable keyword `var`. For declaring a constant, we use the word
    `const`. In order to use assignment we must declare constant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Values declared with the const can not be redeclared, redefined or reinitialized.
    JavaScript provide 8 constants through math object. One of them is PI. we can
    not reinitialize PI using const.
  prefs: []
  type: TYPE_NORMAL
- en: Let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Let` keyword is used for the block scoping of variables. The variables
    are declared at the start of the code instead of at the start of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the name `john` is the value of name logged in console.
    The declarations in JavaScript are moved to the top. The position of the variables
    declared or initialized in the scope of the function does not matter, and they
    will be hoisted to the top by default. JavaScript's default conduct is to move
    variable declarations to the top.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting is JavaScript's default behavior to move variable declarations to the
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in JavaScript are function scoped. This means, variables are available
    throughout the function, even if they are declared in a nested code block. Here
    is a short example in which we will log the output in the console of our client,
    that is, Chrome, Firefox, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, the value of name used to log-in into the console
    is `jane`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 handles this issue with let. Let is very much like `var`. The only difference
    is that `let` is block scoped, and `var` is function scoped. We can rewrite the
    previous example using let, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that although the value of name is `jane` inside the function, using
    the `let` keyword sets its scope to global and the value of name defaults to `john`.
    Hence, `john` is logged in the client's console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we declare a variable as a constant, assign it some value, use the same constant
    somewhere else that changes its value, then its new value will be ignored. Like
    variables, we can add constants anywhere in our script without breaking our code.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can assign multiple values to the variables in a function using one command.
  prefs: []
  type: TYPE_NORMAL
- en: For each
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iteration of property value is done using this loop. The iteration of property
    name is done.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object for the next method is returned. The object that is returned has
    `_iterator_` property. The iterator is used for `iteratable` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generation of object is done here. A generated object is returned whenever
    a function invokes the `this` method. The `yield` keyword is used. The current
    execution of the function is specified by the generated object.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `iteratable` objects with the same values in the array are shorthanded by
    the use of array.
  prefs: []
  type: TYPE_NORMAL
- en: Generator expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions are shorthanded for multiple `try-catch` expressions. The thing
    that is returned is the generated object wrapped in `{}` and not in `[]`. We use
    this for multiple values to variables in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped variables and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we declare a variable, then it has a local scope and a global scope. We
    can define a variable anywhere in our script. When we declare a variable in JavaScript,
    we can assign a value to it at the time of declaration or later. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, a variable is defined by a dollar sign the same as in query.
    In JavaScript, we create variables dynamically using the `var` keyword. Every
    variable has a name and a value associated with it. These values can be of any
    type, such as `number`, `array`, `string`, and so on. A variable name could be
    a combination of characters and numbers. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A variable that is declared outside a function is a **global variable** having
    a global scope. This means that it can be accessed from anywhere within a script.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare a variable constant with the `const` keyword. A constant
    variable value is constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants can be defined using the `const` keyword as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `const` and `let` keywords work in a similar way that they both are block
    scoped. However, in the case of `const`, values cannot be redeclared, redefined,
    or reinitialized. In short, const values are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a working example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `class` variables are declared in the class but not within methods of any
    class, whereas the local variable exits within the methods of any class.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shorthand function, also known as **expression closure**, is a technique to
    use simple functions in JavaScript. It is used to omit a function's curly brackets
    in the event; it returns a `true` or `false` statement. Similarly, if you omit
    the `return` keyword, it would also send you the exact same result.
  prefs: []
  type: TYPE_NORMAL
- en: The expression will be evaluated quickly after the argument list in your script
    by omitting the curly brackets and the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This behaves similarly like functions. They are defined with curly brackets
    and a `return` statement. This is very useful when we want to pass a function
    as an argument to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple catch clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, `try/catch` statements are use to handle exceptions present in
    the `try` code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The try clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `try` block, the statements to be evaluated are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to deliberately throw an exception, we would use the `throw` statement.
    This will abort the execution of the remaining statements, and the control will
    move to the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: The catch clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After checking and encountering an error in the statements in the `try` block,
    the exception block is called. If the exception encountered is the same as the
    exception handled in the `catch` block, then the control immediately shifts to
    the `catch` block, and the statements within the `catch` block are executed.
  prefs: []
  type: TYPE_NORMAL
- en: The statements presented after the erroneous statement will *not* be executed,
    unless there is a `return` statement in the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good practice is to use a conditional catch clause first if we anticipate
    that any exception will occur. An unconditional catch clause is placed last to
    handle all the remaining exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The finally clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This block will execute statements present within at end, whether an exception
    has occurred or not. The statements in a `finally` block execute irrespective
    of whether an error occurred. The `finally` block generally contains code that
    must be executed regardless of anything. Hence, we generally release resources
    and close connection inside a `finally` block. The syntax for writing a simple
    `try-catch-finally` block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write this with a nested `catch` blocks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example showing the working of multiple `catch` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pass 14 as the argument to the function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `try-catch` statements, we must have at least one `finally` or `try-catch`
    block. `Try` doesn't necessarily need a `catch` clause. If a `try` statement does
    not contain at least one `catch` block, it must contain a `finally` block. The
    possible exception handling clauses with `try-catch-finally` are the `try-catch`,
    `try-finally`, or `try-catch-finally` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: E4X – ECMAScript for XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is an extension in JavaScript for support of XML extension with JavaScript.
    By using E4x, it provides easy access for XML document by the DOM interface. It
    is a server-side technology used in **Rhino** and **SpiderMonkey** because these
    are powerful extensions by all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Before E4X, it was very difficult and time consuming for reading and writing
    in XML. In JavaScript, E$X provides XML document as a XML object, which represents
    XML fragments as a `xmlList`. E4X supports special kinds of XML objects. This
    technique is used in client-side programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we enter this XML into our JavaScript code, the E4X interpreter will handle
    it as an XML object in your script.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 6, otherwise called **ECMAScript 2015**, is the most recent form
    of the ECMAScript standard. ES6 is an important upgrade to the language, and the
    first update to language since the release of ES5.1 in June 2011
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the new features of ES6 are:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced object literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended parameter handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at all these functions in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrow functions are also known as **fat arrow functions**. It is a function
    and is similar to what we use in C#, Java, and Coffee Script. Statements and expression
    bodies are supported by arrows. The lexical of arrows is similar to its surrounding
    code. This is not the case in functions.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, arrow functions use a shorter syntax, an arrow (`=>`),
    for definition and in syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: An arrow function expression or a fat arrow function are shorter in syntax when
    compared with function expressions. Arrow function is used to bind the value of
    this. (It does not binds its own `arguments`, `super`, `this` or `new.target`).
    Arrow functions are anonymous.
  prefs: []
  type: TYPE_NORMAL
- en: The `yield` keyword is used to `pause` and `resume` a generator function (`function*`
    function keyword with an asterisk defines a `generator` function that returns
    a `Generator` object).
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 classes' syntax is simpler and easier than that of area syntactical sugar
    over the prototype-based object-oriented pattern. It is a syntactical sugar. One-time
    declaration makes class patterns easier to use and simplifies the use of class
    patterns. Classes support constructors, instance, prototype-based inheritance,
    static methods, and super calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of writing a class in ES6 and ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enhanced object literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object literals is one of the most popular patterns of JavaScript. JSON is based
    on object literals. The reason for its popularity is that it provides a very quick,
    short, and neat way to do `key:value` assignments, define methods, evaluate expressions,
    and make super calls. ES6 has extended the object literal syntax in various ways.
    This makes them more useful. Two types of extensions for object literals are explained
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Property initializer shorthand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in ECMAScript 5, object literals were a comma-separated collection of
    `name:value` pairs. There was a likelihood of duplication while property values
    were being initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `createStudent()` function creates a `student`
    object whose `name` and `class` properties are similar to the function parameters.
    This results in duplication of `name` and `class` properties, even though both
    behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: To correct this, the initializer shorthand property was introduced in ECMAScript
    6\. This removed all the likelihood of duplication between property names and
    local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `createStudent()` can be revised as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the event that property name will be the same as property estimation, you
    can simply incorporate property name without colon and value.
  prefs: []
  type: TYPE_NORMAL
- en: If the property of an object literal has no value, the JavaScript engine searches
    for a variable with a similar name in the surrounding. If the search procedure
    is successful, the value is assigned to the same party name in object literals.
  prefs: []
  type: TYPE_NORMAL
- en: Method initializer shorthand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the advent of ECMAScript 6, many things improved, making the work of a
    web developer simpler. The syntax of writing methods in object literals improved
    to a great extent. Earlier, in ECMAScript 5, we needed to specify a name and write
    the complete function definition then and there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With ECMAScript 6, the syntax became easier to code. Colon and function keywords
    have been removed. The same example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Template strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template strings amplify ECMAScript with syntactic sugar to build string. This
    component is like string introduction highlights in Perl, Python, and so on. You
    can likewise add a tag to permit redid string development, staying away from and
    counteracting infusion assaults or building complex information structures from
    string substance. They also enable us to create **domain-specific** **languages**
    (**DSLs**) to deal with content in a safe way.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding more extending functionality to JavaScript strings, template
    strings provide a total new approach for string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest format of a template string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the most basic form of template strings which performs substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings are enclosed within backticks (`` ` ``) instead of single
    or double quotes. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a `basic_string` variable contains a simple JavaScript string.
    The template string syntax is only used to create the string value, which is then
    assigned to `basic_string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a need to use a backtick in string, then you can escape it using
    a backslash (`\`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Multiline strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this type of string, we can add multiple lines in a single line of code.
    To insert a new line in a string, we have to include `\n` within the string manually,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We need to be careful regarding the whitespaces, as whitespaces within backticks
    are considered to be part of the string. All whitespaces before the second line
    are considered to be part of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, *destructuring* means pattern matching. In ES6, we can do efficient
    pattern matching in objects and arrays. Earlier, this was a long and complicated
    task. Here are some working examples written in a client console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching data from objects and arrays is very common in JavaScript. Object
    properties are usually stored in local variables for instant access. Let''s take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ES6 made this easier by introducing destructuring assignments, which goes through
    an object or an array and stores specified values in the local variables. It allows
    binding using pattern matching for objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Array destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All variables can be initialized and swapped at once instead of the conventional
    way of creating a temporary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple values from a function are returned with ease using array destructuring.
    We don''t have to wrap around an object. To skip variables, you can leave the
    position of the array element blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Object destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to destructuring, variables can also be initialized from an object that
    is returned from a function even with deeply nested objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring enables variables to be initialized from an object that is returned
    by a function having deeply nested objects. Just like Array destructuring, we
    can skip the ones not needed. Here''s the working snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Extended parameter handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are an important and fundamental part of any language. ES6 has introduced
    a number of incremental improvements in functions. This makes them less error
    prone and more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions allow any number of parameters to be passed irrespective of the number
    of parameters in the function definition. There are three types of these parameters
    that could be passed to functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 lets us set default parameters. A parameter with a default value is considered
    optional. It binds trailing parameters to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Rest parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rest parameters replace the need for arguments and addresses common cases more
    directly. Rest parameters are indicated by three dots (`…`) preceding a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example showing the rest parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The named parameter becomes an array containing the rest of the parameters.
    Adding more than one named argument may cause syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: Spread operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spread operator is very similar to the rest parameter, but it allows us to split
    the array to individual arguments, which are then passed to the function as separate
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example showing the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example showing the usage of default, rest, and spread parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `let` keyword is a new `var`. The declaration syntax for the `let` keyword
    is the same as for `var`. You can basically replace `var` with `let` to declare
    a variable but keep its scope to the current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables defined using `const` are considered to be constants, so the value
    cannot be changed once set. For this reason, every `const` variable has to be
    initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Iterators and the for...of operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use iterators to allow customization of an object's iteration method/behavior,
    such as CLRIE numerable or Java Iterable. Generalize the `for..in` operator to
    custom iterator-based iteration with `for..of`. Iterators are an important feature
    of ECMAScript 6\. When used in combination with new array methods and new types
    of collections (for example, sets and maps), iterators become even more important
    for the efficient processing of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fibonacci numbers, or the Fibonacci arrangement, are the numbers in the accompanying
    whole number succession:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom iterators are a useful tool but it requires careful programming so that
    it can maintain its internal state explicitly. ES6 introduced generators which
    provide a powerful alternative. Generator allows us to create an iteration algorithm
    by writing a single function. This single function is able to maintain its own
    state.
  prefs: []
  type: TYPE_NORMAL
- en: A `generator` is a function that returns an iterator. The `generator` functions
    are denoted by embedding an asterisk (`*`) after the function keyword. A normal
    function becomes a generator if it contains a yield expression and uses `function*`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It doesn't matter whether there is space between the `function` keyword and
    the asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `yield` keyword is utilized within the generators function to indicate
    the qualities that the iterator must return when the `next()` method is called.
    So, in the event that you need to return unique values for each progressive call
    to `next()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert the previous iterator example to use a generator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Better Unicode support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 supports Unicode, including new Unicode literal form in strings, new `RegExp
    u` mode to handle code points, as well as new APIs to process strings at the 21-bit
    code points level. These updates enable us to create global apps in JavaScript.
    ECMAScript 6 enforces encoding of strings in UTF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported Unicode examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ECMAScript 6 enables us to export and import symbols to and from modules without
    polluting the global namespace. It provides added support for modules for component
    definition. Runtime behavior is defined by a host-defined default loader. It is
    an implicitly asynchronous model; no code is executed until the necessary modules
    are available and processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Some additional features include export default and export `*`, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Module loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Module loaders are used primarily to resolve module specifiers, loading modules,
    and so on. They are responsible for downloading the required modules and binding
    them asynchronously. This brings to light the dependencies of a client script.
    The constructor is `Reflect.Loader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module loaders support:'
  prefs: []
  type: TYPE_NORMAL
- en: Compilation hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global namespace isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`System.module(source, options?)`: This is used to assess the JavaScript code
    in source to a module (which is delivered and returned non-concurrently by means
    of a guarantee)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.set(name, module)`: This is used for the registration of the module
    created by System.module()'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.define(name, source, options?)`: This is used to assess the module
    code in source and registers the outcome'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can configure the default module loader, and new loaders can be constructed
    to evaluate and load code in isolated or constrained contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Collections** are used to create unique values collections of any type in
    JavaScript. In a collection of values, you can also add and remove values. There
    is no direct access to values in collection, and these are of array type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In ECMAscript 6, collections are a new efficient way to store data. JavaScript
    arrays are similar to other programming language arrays with index. By use of
    these arrays, you can pull double and triple data and also stack data. There are
    many new types of collections in JavaScript. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WeakMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WeakSet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `set` has a unique collection of values. The unique values of a set are also
    of object reference types. Values in sets cannot be duplicated. Before you access
    values from a `set`, you need to check whether the values are present or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add values in a `set` and also check the size of values in a set. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `map` object is a `key/value` map. Any value in `map` may be used as a key
    or a value. Elements can iterate in a `map` in an insertion order, and it returns
    an array of a value or a key. There are two properties of `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map.length`: Returns the number of elements in a `map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype`: The `Map.prototype` property represents the prototype for
    the `map` constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are some of the methods of the `map` object.
  prefs: []
  type: TYPE_NORMAL
- en: Map.prototype.clear()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `clear()` method removes all elements from a `map` object.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After using this function, everything that we have initialized on map will be
    erased. The function has no parameter and returns nothing as it wipes out everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.delete()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `delete()` method removes the specified element from a `Map` object.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns `true` if a component in the map object existed and has been evacuated.
    It returns false if the component does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A key is required. The key here is basically the element to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is different from `map.prototype.clear()` as it clearly removes a specific
    element instead of deleting every element on the map. We pass a key (the element
    to be deleted), and the function returns `true` or `false`, depending on the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.entries()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to tell us about the key and value of elements on map.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns a new `iterator` object that contains a key and a value for every
    element on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are no input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This function is utilized for letting us know about the key and value of components
    on map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.forEach()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `forEach` method executes the given callback once to every key/value pair
    in the map object.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are three parameters: the element `value`, element `key`, and the `map`
    object being traversed.'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `forEach` strategy executes the given callback once to every key of the
    guide that really exists. It is not conjured for keys that have been erased. Nonetheless,
    it is executed for values that are available; however, they have the value defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.get()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A specific element from the map is returned using the `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns the key that is used as a parameter (only if it is found in map);
    or else, it returns an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It requires a key that is to be returned from the map.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We input a key that we want to find in the map, and the function returns it.
    It is used when we want to get the value of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.has()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function returns `true` (Boolean value) if the element exists and `false`
    if it does not.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns `true` if a component with the specified key exists in the `map`
    object. If not found, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A key is required.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We pass a key in the function to check whether a certain element exists in the
    map or not. If the element exists, `true` is returned; otherwise, `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.keys()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It returns keys for every element in the map.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns a new object that contains the keys of all elements on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `keys()` strategy gives back another `iterator` object that contains the
    keys for every component in the `map` object in the insertion order.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.set()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the procedure to add a new element on map.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns the `map` object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the key of the element to be added on map.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `set()` strategy includes another component with a predetermined key and
    value to a `map` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Map.prototype.values()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the method to get a new object containing values of each element.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns an object that has values of all components on map.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `values()` technique gives back another `iterator` object that contains
    the values for every component in the `map` object in the insertion manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the same as map, but there is some difference in it. It only accepts objects
    as keys. Primitive data types are not allowed in `WeakMap`. There is no garbage
    collection in a `WeakMap` because it doesn't reference to an object acting like
    a key. As a result of these differences, there is no method to access keys in
    `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keys in `WeakMap` are not enumerable, which means that there is no method to
    give you a list of keys. There is size property available in `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap.prototype.clear()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is used to remove all elements from the `WeakMap`. This is obsolete now,
    but is, however, still used in a few browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns the key of the element to be removed from the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is t key of the element to be removed from the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap.prototype.delete()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to remove a specific object from `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns `true` if an element in the `WeakMap` object has been removed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the key of the element to remove from the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `delete()` method removes the specified element from a `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap.prototype.get()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to retrieve a specific object from `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns the element associated with the specified key or is undefined if
    the key can't be found in the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the key of the element to return from the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The key of the element to return from the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap.prototype.has()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to check whether the specified object exists in `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns `true` if an element with the specified key exists in the `WeakMap`
    object; otherwise it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is the key of the element to test for presence in the `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `has()` method returns a Boolean indicating whether an element with the
    specified key exists in the `WeakMap` object or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: WeakMap.prototype.set()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to add an object to a specific location.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `WeakMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Key`: The key of the element to add to the `WeakMap` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Value`: The value of the element to add to the `WeakMap` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `set()` method adds a new element with a specified key and value to a `WeakMap`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Weakset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a collection of objects that don't stop its elements from being garbage
    collected. There is no looping, iteration, and learning in `WeakSet`. It has three
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet.prototype.add(someValue)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method appends a new object at the end of the `WeakSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `WeakSet.prototype.add(someValue)` method returns Nothing
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The object to add to the `WeakSet` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `add()` method appends a new object to the end of a `WeakSet` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: WeakSet.prototype.delete(someValue)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method removes the specified object from `WeakSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Returns `true` if the value is found in `WeakSet` and is deleted. Returns `false`
    if the value is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The value to be deleted is sent as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `delete()` strategy expels the predefined element from a `WeakSet` object.
    It is used while we need to delete some element from `WeakSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: WeakSet.prototype.has(someValue)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method will return `true` if the object exists in `WeakSet`; otherwise,
    `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It returns `true` if a component with the predefined value exists in the `WeakSet`
    object; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requires a value that is to be searched.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `has()` technique gives back a Boolean demonstrating whether an item exists
    in `WeakSet` or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It has only arbitrary values. References of objects are held in a weak manner
    in a `WeakSet` object. They can also be garbage collectors. In `WeakSet`, there
    is no list of current objects because of the garbage collector. These objects
    are not enumerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proxies enable object creation with a wide range of behaviors available to host
    objects. They can be used for object virtualization, interception, logging/profiling,
    and so on. Proxies provide developers with an unprecedented control over objects
    and unlimited possibilities to define new interaction patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A symbol is a unique type which can be used as an identifier for object properties.
    The symbol object is an implicit object wrapper for the symbol primitive data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a new primitive symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two new symbols. `Symbol('abc')` does not force converts
    `abc` into an object but creates a new separate object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using `Symbol()` with new keyword will throw a type error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This prevents creation of an explicit Symbol wrapper object instead of a new
    symbol value. Creating an explicit wrapper object around primitive data types
    were only supported until ES5\. However, existing primitive wrapper objects like
    new Boolean, new `String` and new `Number` can still be created for legacy reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if it is necessary to create Symbol wrapper object, you can use the `Object()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `Object.getOwnPropertySymbols()` method returns an array of symbols and
    lets you find symbol properties on a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ECMAScript 6 standard uses a special notation to indicate symbols, prefixing
    the identifier with `@@`, such as `@@create`.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassable built-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ECMAScript 6, built-ins such as Date, Array, and DOM elements can be subclassed.
    Object construction for a function named `Ctor` now uses two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `Ctor[@@create]` to allocate the object and install any special behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke constructor on new instance to initialize it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The known `@@create` symbol is available via `Symbol.create`. Built-ins now
    expose their `@@create` syntax explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 6 introduced promises. It is a library used for asynchronous programming.
    It is a first-class representation of a value that may be made available in the
    future. Many existing JavaScript libraries already use promises.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the methods for promises in ES6 are mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.All()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns a promise that is resolved once all the promises in the
    iterable argument have been resolved. In the case of a rejection, it returns with
    the reason of the first-passed promise that was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Promise.All()` method returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `iterable` object, such as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Promises returns result as an array of values. If any value in the array is
    not a promise, then it is converted using Promise.resolve. If any of the passed
    in promises rejects, then all promise are rejected and the reason of rejection
    of a promise is returned. It discards all other promise whether they have been
    resolved or not. If an empty array is passed, then this method resolves immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Promise.prototype.catch()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used only in cases where objects are rejected. It works the same
    as `promise.prototype.then()`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `promise.prototype.catch()` method returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**One rejected**: A function called when the `promise` is rejected. This function
    has one argument, the rejection reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `catch()` technique gives back a `promise` and manages rejected cases. It
    behave similar as calling `Promise.prototype.then(undefined, onRejected)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Promise.resolve(value)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns a `promise` object that is resolved by the specified value.
    If the value is associated to a then method, the returned promise will move to
    the then method, adopting its final state. Otherwise, the returned promise will
    be fulfilled with the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `promise` object that is resolved with the given value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following parameters and their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onFulfilled`: A `function` called when the `Promise` is fulfilled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRejected`: A `function` called when the `promise` is rejected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Promise.resolve(value)` system gives back a `Promise` question that is
    determined with the given quality. On the off chance that the quality is a then
    able (that is, has a then technique), the returned promise will *follow* that
    then able, adopting its possible state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `then()` technique gives back a `Promise`. It takes two contentions: callback
    capacities for the achievement and disappointment instances of the `Promise`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the then method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Chaining
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the `then()` method returns a `Promise`, you can easily chain `then` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use chaining to implement one function with a Promise-based API
    on top of another such function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Promise.reject(value)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns a promise object that is rejected because of the passed
    value/reason.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Promise.reject()` method returns a simple output telling the reason for
    rejection.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reason why this promise is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Promise.reject()` function capacity gives back a `Promise` that
    is rejected. For troubleshooting purposes and specific mistake finding, it is
    helpful to make the reason an instance of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Promise.race(value)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns a promise that is resolved or rejected the same way as
    the promises passed in iterable, with the value or reason from that promise.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Promise.race()` function returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `iterable` object, such as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `race` function gives back a `Promise` that is settled the same route as
    the initially passed `Promise` to settle. It determines or rejects, whichever
    happens first.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Core math library APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 6 has made several new extensions to the prebuilt libraries, including
    core `Math` libraries, `arrays`, `string` `helpers`, and `Object.assign` for copying.
    These new methods help in speeding up the execution process, hence resulting in
    enhancing the performance of applications that may perform calculations and string
    manipulation. It also improves the speed of applications that must perform many
    calculations and string manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerous new library increases, including core Math libraries, array conversion
    helpers, string helpers, and `Object.assign` for copying. An example of using
    the Core Math Library APIs is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Binary and octal literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 6 introduced binary and octal literal notations, for binary (b) and
    octal (o). Both these notations are a little similar to hexadecimal literal notation
    for prepending 0x or 0X to a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new octal literal format begins with `0o` or `0O`, while the new binary
    literal format begins with `0b` or `0B`. Each literal type must be followed by
    one or more digits; 0-7 for octal and 0-1 for binary. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Reflect API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reflect` object is a single object that contains functions related to the
    reflection API. As the name suggests, it is merely a reflection of the objects
    so that one can observe them closely, regardless of who the object was created
    by. The `reflect` object is not a `function` object. It does not have a `constructor`
    method. It cannot be invoked as a function, because it does not have a `call`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Reflect API is known to be the inverse of Proxy API.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a list of methods a `reflect` object has.
  prefs: []
  type: TYPE_NORMAL
- en: Reflect.get(target, prop, [receiver])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows you to get the property of an object. This method is similar
    to property accessors syntax (`object[propertyKey]`).
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `reflect` object returns the value of property.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The parameters are target objects on which to get property, the name of property,
    and the value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.get()` method works like getting a property from an object
    (`target[propertyKey]`) as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the get method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.set(target, prop, value, [receiver])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows you to set a property of an object. This method is also similar
    to property accessor syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.set(target, prop, value, [receiver]` returns a Boolean value indicating
    whether property was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Parameters are target objects, name of the property, the value to set, and the
    receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.set()` strategy works like setting a property on an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.has(target, prop)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows you to check whether an object holds a specific property.
    This method is similar to the in operator.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.has(target, prop)` returns a Boolean value indicating whether the
    target has a property or not.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object and the property key (name of property to check) is passed.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.has()` technique works like the in operator as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.apply(target, receiver, args)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to call a target function with a specified set of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.apply(target, receiver, args)` method returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Target function to call. `thisArgument` and `ArgumentList` is passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.apply()` technique calls an objective function with specified
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.construct(target, args)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows you to call a `constructor` function with multiple arguments.
    It is just like calling new function (…args).
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.construct(target, args)` returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target function to be called, an argument list, and the new target (constructor
    to be used) are parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.construct` method permits you to conjure a constructor with a variable
    number of contentions (which would likewise be conceivable utilizing the spread
    operator consolidated with the new operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `Reflect.construct()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `newTarget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.getOwnPropertyDescriptor(target, prop)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is just like `Object.getOwnPropertyDescriptor()`. This method returns
    a property descriptor of a specific property if it exists on an object; otherwise,
    undefined is returned. The only difference between these two is the way non-object
    targets are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.getOwnPropertyDescriptor(target, prop)` method returns a property
    descriptor object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object in which to look for property, and property key (name of the
    property to be applied) are the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.getOwnPropertyDescriptor` system gives back a property descriptor
    of the given property in the event that it exists on the object, indistinct something
    else undefined is returned if property does not exists. The main contrast to `Object.getOwnPropertyDescriptor()`
    is the manner by which non-object targets are taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `Reflect.getOwnPropertyDescriptor()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Difference to `Object.getOwnPropertyDescriptor()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first argument to this method is not an object (a primitive), then it
    will cause a `TypeError`. With `Object.getOwnPropertyDescriptor`, a non-object
    first argument will be coerced to an object at first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.defineProperty(target, prop, desc)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is similar `toObject.defineProperty()`. This method allows us to
    modify the property of an object. The `Object.defineProperty()` method returns
    an object or returns a type error if the property is not defined successfully.
    The `Reflect.defineProperty()` method returns `true` if the property was defined
    successfully. Otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.defineProperty(target, prop, desc)` method returns a Boolean demonstrating
    regardless of whether the property was effectively characterized.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Target object, property key, and attributes are the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.defineProperty` technique permits the exact expansion to or change
    of a property on an object. For more subtle elements, see the `Object.defineProperty`,
    which is comparative. `Object.defineProperty` gives back the objects or tosses
    `TypeError` if the property has not been effectively characterized. `Reflect.defineProperty`,
    then again, essentially gives back a Boolean demonstrating regardless of whether
    the property was effectively characterized.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `Reflect.defineProperty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking if property definition has been successful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Object.defineProperty`, which returns an object if successful or throws
    a `TypeError` otherwise, you would use a `try...catch` block to catch any error
    that occurred while defining a property. As `Reflect.defineProperty` returns a
    Boolean success status, you can just use an `if...else` block here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.getPrototypeOf(target)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns a prototype of the specified object. It is similar to the
    `Object.getPrototypeOf()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.getPrototypeOf(target)` method returns the prototype of object
    or null.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object for which we need the prototype is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.getPrototypeOf()` method is the same technique as `Object.getPrototypeOf()`.
    It gives back the model (that is, the estimation of the inside `[[Prototype]]`
    property) of the predetermined item.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.setPrototypeOf(target, newProto)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method sets the prototype of object to another object or to null. This
    method is the same as the `Object.setPrototypeOf()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.setPrototypeOf(target, newProto)` method returns a Boolean showing
    regardless of whether the model was effectively set.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object and prototype are parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.setPrototypeOf` method changes the prototype (that is, the value
    of the internal `[[Prototype]]` property) of the specified object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.deleteProperty(target, prop)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to delete properties from an object. This method is similar
    to the delete operator as a function.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.deleteProperty(target, prop)` method returns a Boolean value telling
    us whether the property is deleted or not.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object and the name of the property to be deleted are parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.deleteProperty` method permits you to erase a property on an object.
    It returns boolean value indicating if the property was successfully removed or
    not, regardless of whether the property was effectively characterized. It is almost
    similar to the non-strict delete operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.enumerate(target)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns an iterator with enumerable own and inherited properties
    of the target object.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Returns an iterator with the enumerable own and acquired properties of the objective
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Target object on which to get property is passed in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.enumerate()` method returns an iterator with the enumerable own
    and inherited properties of the target object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.preventExtensions(target)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the same method as `Object.preventExtensions()`. It prevents us from
    adding more properties (extensions) to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Returns a Boolean demonstrating regardless of whether the objective was effectively
    set to forestall expansions.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Target object on which we have to prevent extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.preventExtensions()` method keeps new properties from always
    being added to an object (that is, counteracts future augmentations to the item).
    It is like `Object.preventExtensions()`, yet with a few contrasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Reflect.isExtensible(target)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows us to check whether new properties can be added to an object
    or whether the object is extensible or not. This method is similar to the `Object.isExtensible()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Boolean value indicating whether the target is extensible or not.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The target object that has to be checked for its extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.isExtensible()` technique figures out whether an item is
    extensible (whether it can have new properties added to it). It is like `Object.isExtensible()`,
    yet with a few contrasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Reflect.ownKeys(target)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method returns the object's own property keys.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Reflect.ownKeys(target)` method returns an array of target objects.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Target object from where to get keys.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The static `Reflect.set()` strategy works like setting a property on an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Tail calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calls in tail position won't be able to grow the stack without any limits. It
    helps in making recursive algorithms safe and secure in the safe of unbounded
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following function produces a factorial of any number passed to it. There
    is a tail call in the end of the function which recalls the function. Previously,
    we used to get a stackoverflow error, but ES6 is safe for handling arbitrary inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the output is out of range, it will simply display infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
