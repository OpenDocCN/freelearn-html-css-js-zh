<html><head></head><body>
		<div><h1 id="_idParaDest-241" class="chapter-number"><a id="_idTextAnchor240"/>14</h1>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>Three.js Together with React, TypeScript, and Web-XR</h1>
			<p>In this final chapter, we’ll dive into two additional topics. First, we’ll look at how you can combine Three.js with TypeScript and React. The second part of this chapter will show some examples of how you can integrate your 3D scenes with Web-XR. With Web-XR, you can enhance your scenes to work with VR and AR technologies.</p>
			<p>More specifically, we’ll show you the following examples:</p>
			<ul>
				<li><strong class="bold">Using Three.js with TypeScript</strong>: For the first example, we’ll show you how you can create a simple project that combines Three.js and TypeScript. We’ll create a very simple application, much like the samples we’ve already seen in the previous chapters, and show you how you can use TypeScript with Three.js to create your scenes.</li>
				<li><strong class="bold">Using Three.js and React with TypeScript</strong>: React is a very popular framework for web development and is often used together with TypeScript. For this section, we’ll create a simple Three.js project, which uses React.js together with TypeScript.</li>
				<li><code>React-three-fiber</code>. With this library, we can configure Three.js declaratively using a set of React components. This library provides great integration between React and Three.js and makes working with Three.js in a React application straightforward.</li>
				<li><strong class="bold">Three.js and VR</strong>: This section will show you how you can view your 3D scene in VR.</li>
				<li><strong class="bold">Three.js and AR</strong>: This section will explain how you can create a simple 3D scene where you can add Three.js meshes.</li>
			</ul>
			<p>Let’s start with the first example of this chapter and integrate Three.js with TypeScript.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Using Three.js with TypeScript</h1>
			<p>TypeScript provides a typed <a id="_idIndexMarker1356"/>language that transpiles to JavaScript. This means <a id="_idIndexMarker1357"/>that you can use it to create your site, and it’ll run just like <a id="_idIndexMarker1358"/>normal JavaScript in the browser. There are many different ways of setting up <a id="_idIndexMarker1359"/>a TypeScript project, but the easiest one is provided by Vite (<a href="https://vitejs.dev/">https://vitejs.dev/</a>). Vite provides an integrated build environment and can be seen a bit as an alternative to webpack (which we use for the normal chapter samples).</p>
			<p>The first thing we need to do is create a new Vite project. You can do these steps yourself, or you can look in the <code>three-ts</code> folder and just run <code>yarn install</code> there to skip this setup. To get an empty TypeScript project with Vite, all we have to do is run the following code in the console:</p>
			<pre class="source-code">
$ yarn create vite three-ts --template vanilla-ts
yarn create v1.22.17
warning package.json: No license field
[1/4] <img src="img/01.png" alt=""/>  Resolving packages...
[2/4] <img src="img/02.png" alt=""/>  Fetching packages...
[3/4] <img src="img/03.png" alt=""/>  Linking dependencies...
[4/4] <img src="img/04.png" alt=""/>  Building fresh packages...
warning Your current version of Yarn is out of date. The latest version is "1.22.19", while you're on "1.22.17".
info To upgrade, run the following command:
$ curl --compressed -o- -L https://yarnpkg.com/install.sh | bash
success Installed "create-vite@3.2.1" with binaries:
      - create-vite
      - cva
[######################################################################] 70/70
Scaffolding project in /Users/jos/dev/git/personal/ltjs4-all/three-ts...</pre>
			<p>Next change into the directory (<code>three-ts</code>) and run <code>yarn install</code>.</p>
			<pre class="source-code">
$ yarn install
yarn install v1.22.17
warning ../package.json: No license field
info No lockfile found.
[1/4] <img src="img/01.png" alt=""/>  Resolving packages...
[2/4] <img src="img/02.png" alt=""/>  Fetching packages...
[3/4] <img src="img/03.png" alt=""/>  Linking dependencies...
[4/4] <img src="img/04.png" alt=""/>  Building fresh packages...
success Saved lockfile.
<img src="img/05.png" alt=""/>  Done in 3.31s.</pre>
			<p>At this point, we’ve <a id="_idIndexMarker1360"/>got an empty Vite project, which you <a id="_idIndexMarker1361"/>can start by running <code>yarn vite</code>.</p>
			<pre class="source-code">
$  three-ts git:(main) <img src="img/06.png" alt=""/> yarn vite
yarn run v1.22.17
warning ../package.json: No license field
$ /Users/jos/dev/git/personal/ltjs4-all/three-ts/node_modules/.bin/vite
  VITE v3.2.3  ready in 193 ms
  <img src="img/07.png" alt=""/>  Local:   http://127.0.0.1:5173/
  <img src="img/07.png" alt=""/>  Network: use --host to expose</pre>
			<p>If you point <a id="_idIndexMarker1362"/>your browser to <code>http://127.0.0.1:5173/</code>, you’ll see the start page of Vite, and you’ll have a configured <a id="_idIndexMarker1363"/>TypeScript project in place:</p>
			<div><div><img src="img/Figure_14.1_B18726.jpg" alt="Figure 14.1 – Empty TypeScript project with Vite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Empty TypeScript project with Vite</p>
			<p>Next, we must add the Three.js libraries, after which we can add some TypeScript to initialize Three.js. To add Three.js, we need to add the following two node modules:</p>
			<pre class="source-code">
$ yarn add three
$ yarn add -D @types/three</pre>
			<p>The first one adds the Three.js library, while the second one adds the <code>types</code> descriptions for the Three.js library. These <code>types</code> are used in the editor to get some nice code completion when working with Three.js and TypeScript in your IDE (for example, in Visual Studio Code). At this point, we’re ready to add Three.js to this project and start <a id="_idIndexMarker1364"/>developing Three.js applications using TypeScript. To <a id="_idIndexMarker1365"/>add TypeScript, the first thing we need to do is take a quick look at how the application is initialized. For this, you can look at the <code>public.html</code> file, which looks like this:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0" /&gt;
    &lt;title&gt;Vite + TS&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script type="module" src="img/main.ts"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>In the preceding code, as you can see in the last <code>script</code> line, this HTML page loads the <code>src/main/ts</code> file. Open this file and change its content to this:</p>
			<pre class="source-code">
import './style.css'
import { initThreeJsScene } from './threeCanvas'
const mainElement = document.querySelector
  &lt;HTMLDivElement&gt;('#app')
if (mainElement) {
  initThreeJsScene(mainElement)
}</pre>
			<p>The code here will try to find the main <code>#app</code> node. And if it finds the node, it’ll pass that node <a id="_idIndexMarker1366"/>to the <code>initThreeJsScene</code> function, which is <a id="_idIndexMarker1367"/>defined in the <code>threeCanvas.ts</code> file. This file contains the code to initialize the Three.js scene:</p>
			<pre class="source-code">
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/
  controls/OrbitControls'
export const width = 500
export const height = 500
export const initThreeJsScene = (node: HTMLDivElement) =&gt; {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, height /
    width, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer()
  renderer.setClearColor(0xffffff)
  renderer.setSize(height, width)
  node.appendChild(renderer.domElement)
  camera.position.z = 5
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshNormalMaterial()
  const cube = new THREE.Mesh(geometry, material)
  const controls = new OrbitControls(camera, node)
  scene.add(cube)
  const animate = () =&gt; {
    controls.update()
    requestAnimationFrame(animate)
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    renderer.render(scene, camera)
  }
  animate()
}</pre>
			<p>This will look familiar to the code from the first couple of chapters where we created an initial simple <a id="_idIndexMarker1368"/>scene. The main change is that, here, we can use <a id="_idIndexMarker1369"/>all the features provided by TypeScript. Vite will handle the transpiling to JavaScript, so you don’t need to do anything else to see the results of this in your browser:</p>
			<div><div><img src="img/Figure_14.2_B18726.jpg" alt="Figure 14.2 – Simple TypeScript project with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Simple TypeScript project with Three.js</p>
			<p>Now that we’ve <a id="_idIndexMarker1370"/>introduced Three.js and TypeScript, let’s <a id="_idIndexMarker1371"/>go a step further and see how we can integrate this with React as well.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/>Using Three.js and React with TypeScript</h1>
			<p>There are <a id="_idIndexMarker1372"/>different ways of creating a React application <a id="_idIndexMarker1373"/>from scratch (Vite, for instance, also supports this), but the most common way is to use the <code>yarn create react-app lts-tf --template TypeScript</code> command from the command line. Just like with Vite, this will create a new project. For this example, we’ve created this project in the <code>lts-tf</code> directory. Once created, we have to add the Three.js libraries just like we did for Vite:</p>
			<pre class="source-code">
$ yarn create react-app lts-tf --template TypeScript
...
$ cd lts-tf
$ yarn add three
$ yarn add -D @types/three
$ yarn install</pre>
			<p>This should set up a simple react TypeScript application, add the correct Three.js libraries, and install all the other required modules. The next step is to quickly check if all this works. Run the <code>yarn </code><code>start</code> command:</p>
			<pre class="source-code">
$ yarn start
Compiled successfully!
You can now view lts-tf in the browser.
  Local:            http://localhost:3000
  On Your Network:  http://192.168.68.112:3000
Note that the development build is not optimized.
To create a production build, use yarn build.
webpack compiled successfully
Files successfully emitted, waiting for typecheck results...
Issues checking in progress...
No issues found.</pre>
			<p>Open <a id="_idIndexMarker1374"/>your browser to <code>http://localhost:3000</code> and <a id="_idIndexMarker1375"/>you’ll see a simple React startup screen:</p>
			<div><div><img src="img/Figure_14.3_B18726.jpg" alt="Figure 14.3 – Simple TypeScript project with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Simple TypeScript project with Three.js</p>
			<p>On this screen, we can see that we need to edit the <code>app.tsx</code> file, so we’ll update this similar to the plain TypeScript example we saw in the <em class="italic">Using Three.js with TypeScript</em> section, but this time as a React component:</p>
			<pre class="source-code">
import './App.css'
import { ThreeCanvas } from './ThreeCanvas'
function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ThreeCanvas&gt;&lt;/ThreeCanvas&gt;
    &lt;/div&gt;
  )
}
export default App</pre>
			<p>As you <a id="_idIndexMarker1376"/>can see, here, we defined a custom <a id="_idIndexMarker1377"/>component named <code>ThreeCanvas</code>, which is now loaded as soon as the application starts. The Three.js initialization code is provided by the <code>ThreeCanvas</code> element, which you can find in the <code>ThreeCanvas.tsx</code> file. This file, for the most part, is similar to the <code>initThreeJsScene</code> function we described in the <em class="italic">Using Three.js with TypeScript</em> section, but we’ll include the whole file here for completeness:</p>
			<pre class="source-code">
import { useCallback, useState } from 'react'
import * as THREE from 'three'
const initThreeJsScene = (node: HTMLDivElement) =&gt; {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, 500 / 500,
    0.1, 1000)
  const renderer = new THREE.WebGLRenderer()
  renderer.setClearColor(0xffffff)
  renderer.setSize(500, 500)
  node.appendChild(renderer.domElement)
  camera.position.z = 5
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshNormalMaterial()
  const cube = new THREE.Mesh(geometry, material)
  scene.add(cube)
  const animate = () =&gt; {
    requestAnimationFrame(animate)
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    renderer.render(scene, camera)
  }
  animate()
}
export const ThreeCanvas = () =&gt; {
  const [initialized, setInitialized] = useState(false)
  const threeDivRef = useCallback(
    (node: HTMLDivElement | null) =&gt; {
      if (node !== null &amp;&amp; !initialized) {
        initThreeJsScene(node)
        setInitialized(true)
      }
    },
    [initialized]
  )
  return (
    &lt;div
      style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh'
      }}
      ref={threeDivRef}
    &gt;&lt;/div&gt;
  )
}</pre>
			<p>In <code>initThreeJsScene</code>, you can find the standard code to initialize a simple Three.js scene using TypeScript. To connect this Three.js scene to React, we can use the code from the <code>ThreeCanvas</code> functional React component. What we want to do here is initialize the Three.js scene at the moment the <code>div</code> element gets attached to its parent node. To do <a id="_idIndexMarker1378"/>this, we can use the <code>useCallback</code> function. This <a id="_idIndexMarker1379"/>function will be called once when this node gets attached to its parent, and won’t rerun even if one of the parent properties changes. In our case, we will also add another <code>isInitialized</code> state to make sure that even if we have the development server reload parts of the application, we only initialize our Three.js scene once.</p>
			<p class="callout-heading">useRef or useCallback</p>
			<p class="callout">You might be <a id="_idIndexMarker1380"/>tempted to use <code>useRef</code> here. There is a good explanation at https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node regarding why, in this <a id="_idIndexMarker1381"/>case, you should use <code>useCallback</code> instead of <code>useRef</code> to avoid unnecessary rerenderings.</p>
			<p>With the preceding setup in place, we can now see the result:</p>
			<div><div><img src="img/Figure_14.4_B18726.jpg" alt="Figure 14.4 – Three.js with TypeScript and React"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Three.js with TypeScript and React</p>
			<p>In the previous example, we created a simple integration between React and Three.js. While <a id="_idIndexMarker1382"/>this works, it feels a bit strange to programmatically <a id="_idIndexMarker1383"/>describe a Three.js scene, since normally, in React, applications are declared declaratively using components. We can wrap the existing Three.js components as we did with the <code>ThreeCanvas</code> component, but this will quickly get complex. Luckily, though, all the hard work for this <a id="_idIndexMarker1384"/>has already been done by <a id="_idIndexMarker1385"/>the Three.js fibers project: <code>https://docs.pmnd.rs/react-three-fiber/getting-started/introduction</code>. In the next section, we’ll look at how easily Three.js and React can be integrated with the help of this project.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor244"/>Using Three.js and React with React Three Fiber</h1>
			<p>In the previous <a id="_idIndexMarker1386"/>examples, we set up the integration between React and Three.js ourselves. While it works, that approach doesn’t tightly integrate with how React works. For a good integration between these frameworks, we can use React Three Fiber. We’ll start again by setting up a project.</p>
			<p>For this, run the following commands:</p>
			<pre class="source-code">
$ yarn create react-app lts-r3f
$ cd lts-3rf
$ yarn install
$ yarn add three
$ yarn add @react-three/fiber</pre>
			<p>This will install all the dependencies we need and set up a new React project. To start this project in the <code>lts-r3f</code> directory, run <code>yarn start</code>, which will start a server. Open the URL you see on the screen (<code>http://localhost:3000</code>); you’ll see the following screen, which we’ve seen before and shows an empty React project:</p>
			<div><div><img src="img/Figure_14.5_B18726.jpg" alt="Figure 14.5 – Starting up a simple JavaScript React application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Starting up a simple JavaScript React application</p>
			<p>As the screen <a id="_idIndexMarker1387"/>starts to extend this example, we need to edit the <code>app.jsx</code> file. We’ll create a new component that will contain our Three.js scene:</p>
			<pre class="source-code">
import './App.css'
import { Canvas } from '@react-three/fiber'
import { Scene } from './Scene'
function App() {
  return (
    &lt;Canvas&gt;
      &lt;Scene /&gt;
    &lt;/Canvas&gt;
  )
}
export default App</pre>
			<p>Here, we can already see the first of the Three Fiber components – the <code>Canvas</code> element. The <code>Canvas</code> element creates a <code>Canvas</code> div and is the parent container for all the other Three.js <a id="_idIndexMarker1388"/>components provided by this library. Since we added <code>Scene</code> as a child to this <code>Canvas</code> component, we can define our complete Three.js scene in our custom component. Next, we’ll create this <code>Scene</code> component:</p>
			<pre class="source-code">
import React from 'react'
export const Scene = () =&gt; {
  return (
    &lt;&gt;
      &lt;ambientLight intensity={0.1} /&gt;
      &lt;directionalLight color="white" intensity={0.2}
       position={[0, 0, 5]} /&gt;
      &lt;mesh
        rotation={[0.3, 0.6, 0.3]}&gt;
        &lt;boxGeometry args={[2, 5, 1]} /&gt;
        &lt;meshStandardMaterial color={color}
          opacity={opacity} transparent={true} /&gt;
      &lt;/mesh&gt;
    &lt;/&gt;
  )
}</pre>
			<p>What we’ve got here is a very simple Three.js scene, which looks similar to the ones we saw earlier in this book. This scene contains the following objects:</p>
			<ul>
				<li><code>&lt;ambientLight&gt;</code>: An instance of a <code>Three.AmbientLight</code> object.</li>
				<li><code>&lt;directionalLight&gt;</code>: An instance of a <code>Three.DirectionalLight</code> object.</li>
				<li><code>&lt;mesh&gt;</code>: This represents a <code>Three.Mesh</code>. As we know, a <code>Three.Mesh</code> contains <a id="_idIndexMarker1389"/>a geometry and a material, which are defined as children of this element. In this example, we’ve set the rotation on this mesh as well.</li>
				<li><code>&lt;boxGeometry&gt;</code>: This is similar to <code>Three.BoxGeometry</code>, where we pass in the constructor arguments through the <code>args</code> property.</li>
				<li><code>&lt;meshStandardMaterial&gt;</code>: This creates an instance of a <code>THREE.MeshStandardMaterial</code>, and configures some properties on this material.</li>
			</ul>
			<p>Now, when you open your browser to <code>localhost:3000</code>, you’ll see a Three.js scene:</p>
			<div><div><img src="img/Figure_14.6_B18726.jpg" alt="Figure 14.6 – Three.js scene rendered using React Three Fiber"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Three.js scene rendered using React Three Fiber</p>
			<p>In this example, we’ve only shown a couple of small elements provided by React Three Fiber. All <a id="_idIndexMarker1390"/>objects provided by Three.js can be configured in the way we just showed. Just add them as elements, configure them, and they will be shown on the screen. Besides easily showing these elements, all these elements behave like normal React components. So, whenever the properties of a parent element change, all the elements are rerendered (or updated) as well.</p>
			<p>Besides the elements provided by React Three Fiber, there are a whole set of additional components provided by <code>@react-three/drei</code>. You can find those components and their descriptions at <a href="https://github.com/pmndrs/drei">https://github.com/pmndrs/drei</a>:</p>
			<div><div><img src="img/Figure_14.7_B18726.jpg" alt="Figure 14.7 – Additional components from @react-three/drei"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Additional components from @react-three/drei</p>
			<p>For the <a id="_idIndexMarker1391"/>next example, we’re going to use a couple of the components provided by this library, so we need to add this to our project:</p>
			<pre class="console">
$ yarn add @react-three/drei</pre>
			<p>Now, we’ll extend our example to this:</p>
			<pre class="source-code">
import React, { useState } from 'react'
import './App.css'
import { OrbitControls, Sky } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
export const Scene = () =&gt; {
  // run on each render of react
  // const size = useThree((state) =&gt; state.size)
  const mesh = React.useRef()
  const [color, setColor] = useState('red')
  const [opacity, setOpacity] = useState(1)
  const [isRotating, setIsRotating] = useState(false)
  // run on each rerender of
  useFrame(({ clock }, delta, xrFrame) =&gt; {
    if (isRotating) mesh.current.rotation.x += 0.01
  })
  return (
    &lt;&gt;
      &lt;Sky distance={450000} sunPosition={[0, 1, 0]}
        inclination={0} azimuth={0.25} /&gt;
      &lt;ambientLight intensity={0.1} /&gt;
      &lt;directionalLight color="white" intensity={0.2}
        position={[0, 0, 5]} /&gt;
      &lt;OrbitControls&gt;&lt;/OrbitControls&gt;
      &lt;mesh
        ref={mesh}
        rotation={[0.3, 0.6, 0.3]}
        onClick={() =&gt; setColor('yellow')}
        onPointerEnter={() =&gt; {
          setOpacity(0.5)
          setIsRotating(true)
        }}
        onPointerLeave={() =&gt; {
          setOpacity(1)
          setIsRotating(false)
        }}
      &gt;
        &lt;boxGeometry args={[2, 5, 1]} /&gt;
        &lt;meshStandardMaterial color={color}
          opacity={opacity} transparent={true} /&gt;
      &lt;/mesh&gt;
    &lt;/&gt;
  )
}</pre>
			<p>Let’s <a id="_idIndexMarker1392"/>explore the code a bit before looking at the result in the browser. First, we’ll look at the new elements we added to the component:</p>
			<ul>
				<li><code>&lt;OrbitControls&gt;</code>: This is provided by the <code>drei</code> library. This adds an <code>THREE.OrbitControls</code> element to the scene. This is the same as <code>OrbitControls</code>, which we used in the earlier chapters. As you can see here, just adding the element is enough; no additional configuration is needed.</li>
				<li><code>&lt;Sky&gt;</code>: This element provides a nice sky background to the scene.</li>
			</ul>
			<p>We’ve also added several standard React Hooks:</p>
			<pre class="source-code">
  const mesh = React.useRef()
  const [color, setColor] = useState('red')
  const [opacity, setOpacity] = useState(1)
  const [isRotating, setIsRotating] = useState(false)</pre>
			<p>Here, we define a <code>Ref</code>, which we connect to the mesh (<code>&lt;mesh ref={mesh}) ..&gt;</code>). We use this so that we can access the Three.js component later on in the render loop. We also use <code>useState</code> three times to keep track of the <code>color</code> and <code>opacity</code> state values <a id="_idIndexMarker1393"/>of the material, as well as to see whether the <code>mesh</code> property is rotating or not. The first of these two Hooks is used in the events we defined on the mesh:</p>
			<pre class="source-code">
      &lt;mesh
        onClick={() =&gt; setColor('yellow')}
        onPointerEnter={() =&gt; {
          setOpacity(0.5)
          setIsRotating(true)
        }}
        onPointerLeave={() =&gt; {
          setOpacity(1)
          setIsRotating(false)
        }}&gt;</pre>
			<p>With these event handlers, we can very easily integrate the mouse with the mesh. There’s no need for <code>RayCaster</code> objects – just add the event listener and you’re done. In this case, when the mouse pointer enters our mesh, we change the <code>opacity</code> state value and the <code>isRotation</code> flag. When the mouse leaves our mesh, we set the <code>opacity</code> state value back and set the <code>isRotation</code> flag to <code>false</code> again. Finally, when we click on the mesh, we change the color to <code>yellow</code>.</p>
			<p>The <code>color</code> and <code>opacity</code> state values can be directly used in <code>meshStandardMaterial</code> like this:</p>
			<pre class="source-code">
&lt;meshStandardMaterial color={color} opacity={opacity}
  transparent={true} /&gt;</pre>
			<p>Now, the opacity and color will automatically update whenever we fire the relevant events. For <a id="_idIndexMarker1394"/>the rotation, we want to use the Three.js render loop. For this, React Three Fiber provides an additional hook:</p>
			<pre class="source-code">
  useFrame(({ clock }, delta, xrFrame) =&gt; {
    if (isRotating) mesh.current.rotation.x += 0.01
  })</pre>
			<p><code>useFrame</code> is called whenever we have a render loop in Three.js. In this case, we check the <code>isRotating</code> state, and if we should be rotating, we use the previously defined <code>useRef</code> reference to get access to the underlying Three.js component and simply increase its rotation. This is all very easy and convenient. The result in the browser looks like this:</p>
			<div><div><img src="img/Figure_14.8_B18726.jpg" alt="Figure 14.8 – A scene using React and React Three Fiber effects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – A scene using React and React Three Fiber effects</p>
			<p>React Three Fiber and the <code>drei</code> library provide pretty much all the functionality you also have in the normal Three.js library (and some features that aren’t available as well). If you’re working with React and need Three.js integrated, this is a great way to use Three.js. Even <a id="_idIndexMarker1395"/>when you are not necessarily building a React application, the declarative way of defining your scene, the components, and the interactions offered by React Three Fiber is very intuitive. React Three Fiber provides a great alternative for any Three.js visualization you want to create.</p>
			<p>In the next two sections, we’ll look at how you can extend your 3D scenes with AR and VR capabilities. We’ll start by looking at how to enable VR in your scenes.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/>Three.js and VR</h1>
			<p>Before we look <a id="_idIndexMarker1396"/>at the required code changes, we’ll add an extension to the browser with which we can simulate a VR headset and VR controls. That way, you can test your scenes without the need for a physical headset and physical controllers. For this, we’ll install the WebXR API simulator This plugin is available for both Firefox and Chrome:</p>
			<ul>
				<li><strong class="bold">Firefox plugin</strong>: Download <a id="_idIndexMarker1397"/>and install it from here: <a href="https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/&#13;">https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/</a></li>
				<li><strong class="bold">Chrome plugin</strong>: Download <a id="_idIndexMarker1398"/>and install it from here: <a href="https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje&#13;">https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje</a></li>
			</ul>
			<p>Follow the instructions for your specific browser. After you’ve installed it, we can test it with this example: <a href="https://immersive-web.github.io/webxr-samples/immersive-vr-session.html">https://immersive-web.github.io/webxr-samples/immersive-vr-session.html</a>.</p>
			<p>Open this example, open your developer console, and click on the <strong class="bold">WebXR</strong> tab. Now, you’ll see something like this:</p>
			<div><div><img src="img/Figure_14.9_B18726.jpg" alt="Figure 14.9 – Firefox browser with the WebXR API extension"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Firefox browser with the WebXR API extension</p>
			<p>In the extension, you’ll see a <a id="_idIndexMarker1399"/>virtual headset and some virtual VR controls. By clicking on the headset, you can simulate the movement of a real VR headset; the same applies to the controls. If you click the <strong class="bold">Enter VR</strong> button, you can now simply test your VR scenes, without an actual VR headset:</p>
			<div><div><img src="img/Figure_14.10_B18726.jpg" alt="Figure 14.10 – Simulating a VR headset"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Simulating a VR headset</p>
			<p>Now that we’ve got a (virtual) headset <a id="_idIndexMarker1400"/>to play around with, let’s convert one of our previous scenes into a VR scene, where we can track head movement <a id="_idIndexMarker1401"/>and add functionality to some dummy VR controls. For this, we’ve created a copy of the “First Person Controls” example from <a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>. You can open this example by opening up the <code>vr.html</code> example from the <code>chapter-14</code> sources:</p>
			<div><div><img src="img/Figure_14.11_B18726.jpg" alt="Figure 14.11 – Empty VR scene based on example from Chapter 9"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Empty VR scene based on example from <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a></p>
			<p>To get your scene VR ready, we need to take a couple of steps. The first thing we need to do is tell Three.js that we’ll be enabling the Web-XR functionality. This can be done like this:</p>
			<pre class="source-code">
renderer.xr.enabled = true</pre>
			<p>The next step is to <a id="_idIndexMarker1402"/>add a simple button that we can click to enter VR mode. Three.js provides a component out of the box for this, which we can use like this:</p>
			<pre class="source-code">
import { VRButton } from 'three/examples/jsm/webxr/VRButton'
document.body.appendChild(VRButton.createButton(renderer))</pre>
			<p>This will create the button you can see at the bottom of the screen in <em class="italic">Figure 14</em><em class="italic">.11</em>.</p>
			<p>Finally, we need to update our render loop. As you may recall from <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene With Three.js</em>, we use <code>requestAnimationFrame</code> to control our render loop. When working with VR, we need to change this slightly, like so:</p>
			<pre class="source-code">
animate()
function animate() {
  renderer.setAnimationLoop(animate)
  renderer.render(scene, camera)
  if (onRender) onRender(clock, controls, camera, scene)
}</pre>
			<p>Here, we <a id="_idIndexMarker1403"/>used <code>renderer.setAnimationLoop</code> instead of <code>requestAnimationFrame</code>. At this point, our scene has been converted into VR, and once we click the button, we enter VR mode and can look around our scene:</p>
			<div><div><img src="img/Figure_14.12_B18726.jpg" alt="Figure 14.12 – Entering VR mode and rotating the camera using the browser extension"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – Entering VR mode and rotating the camera using the browser extension</p>
			<p>The previous screenshot is shown when you enter VR. You can now easily move the camera around by clicking on the VR device in the Web-XR extension and move it around. These steps are pretty much all you need to do to convert any Three.js scene into a VR scene.</p>
			<p>If you look closely at  <em class="italic">Figure 14</em><em class="italic">.12</em>, you might notice that we also show some handheld VR devices. We <a id="_idIndexMarker1404"/>haven’t shown how you can add these yet. For this, Three.js also comes with some nice helper components:</p>
			<pre class="source-code">
import { XRControllerModelFactory } from
  'three/examples/jsm/webxr/XRControllerModelFactory'
const controllerModelFactory = new
  XRControllerModelFactory()
const controllerGrip1 = renderer.xr.getControllerGrip(0)
controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1))
scene.add(controllerGrip1)
const controllerGrip2 = renderer.xr.getControllerGrip(1)
controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2))
scene.add(controllerGrip2)</pre>
			<p>With the preceding code, we ask Three.js to get information about the attached controllers, create a model, and add them to the scene. If you use the WebXR API emulator, you can move the controls around and they’ll move around on the scene as well.</p>
			<p>Three.js provides lots of examples of how you can use these controls to drag objects around, select objects in the scene, and otherwise add interactivity with the controls. For this simple example, we’ve added the option to add a cube at the position of the first control (the one on the right) whenever you click the <code>select</code> button:</p>
			<div><div><img src="img/Figure_14.13_B18726.jpg" alt="Figure 14.13 – Adding cubes to the scene in VR"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – Adding cubes to the scene in VR</p>
			<p>We can do this by <a id="_idIndexMarker1405"/>simply adding event listeners to the controller, like this:</p>
			<pre class="source-code">
const controller = renderer.xr.getController(0)
controller.addEventListener('selectstart', () =&gt; {
  console.log('start', controller)
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,
    0.1, 0.1), new THREE.MeshNormalMaterial())
  mesh.position.copy(controller.position)
  scene.add(mesh)
})
controller.addEventListener('selectend', () =&gt; {
  console.log('end', controller)
})</pre>
			<p>In this simple piece of code, you can see that we’ve added two event listeners to the controller. When the <code>selectstart</code> event is triggered, we add a new cube to the location of this controller. And when the <code>selectend</code> event is triggered, we just log some information <a id="_idIndexMarker1406"/>to the console. Several other events can be accessed through JavaScript. For more information about the APIs that are available when you are in a VR session, you can look at the following documentation: <a href="https://developer.mozilla.org/en-US/docs/Web/API/XRSession&#13;">https://developer.mozilla.org/en-US/docs/Web/API/XRSession</a></p>
			<p>For the last section, we’ll have a quick look at how you can combine Three.js with AR.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Three.js and AR</h1>
			<p>While VR using <a id="_idIndexMarker1407"/>Three.js is well supported on a large range of devices and browsers, this isn’t the case for Web-AR. On Android, the support is pretty good, but on iOS devices, it doesn’t work that well. Apple is currently working on adding this to Safari, so once that’s in, native AR should also work on iOS. A good way to check which browsers support this functionality is to check <a href="https://caniuse.com/webxr">https://caniuse.com/webxr</a>, which provides <a id="_idIndexMarker1408"/>an up-to-date overview of all major browser support.</p>
			<p>So, to test the native AR example, you either need to view it on an Android device, or use the same simulator we used in the <em class="italic">Three.js and </em><em class="italic">VR</em> section.</p>
			<p>Let’s create a standard scene you can use as a starting point for your AR experiments. The first thing we need to do is tell Three.js we want to use XR:</p>
			<pre class="source-code">
const renderer = new THREE.WebGLRenderer({ antialias: true,
  alpha: true })
renderer.xr.enabled = true</pre>
			<p>Note that we need to set the <code>alpha</code> property to <code>true</code>; otherwise, we won’t see any passthrough from the camera. Next, just like we did for VR, we need to enable AR/VR on the renderer, by calling <code>rendered.xr.enabled</code>.</p>
			<p>To enter AR mode, Three.js also provides a button we can use:</p>
			<pre class="source-code">
Import { ARButton } from 'three/examples/jsm/
  webxr/ARButton'
document.body.appendChild(ARButton.createButton(renderer))</pre>
			<p>Finally, we just need to change <code>requestAnimationFrame</code> to <code>setAnimationLoop</code>:</p>
			<pre class="source-code">
animate()
function animate() {
  renderer.setAnimationLoop(animate)
  renderer.render(scene, camera)
}</pre>
			<p>And that’s all <a id="_idIndexMarker1409"/>there is to it. If you open the <code>ar.html</code> example and view this example through the WebXR plugin (where you need to select the <code>Samsung Galaxy S8+ (AR)</code> device), you’ll see something like this:</p>
			<div><div><img src="img/Figure_14.14_B18726.jpg" alt="Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality</p>
			<p>In this screenshot, you <a id="_idIndexMarker1410"/>can see a simulated AR environment, where we can see the two objects that we’ve rendered. If you move the simulated phone around, you’ll notice that the rendered objects are fixed in their location relative to the position of the camera of the phone.</p>
			<p>The example here is very simple but it shows the basics of how to set up a minimal AR scene. Web-XR offers a lot <a id="_idIndexMarker1411"/>of other functionality related to AR, such as detecting planes and hit testing. However, covering that falls a bit outside of the scope of this book. For more information on Web-XR and the native AR functionality exposed by this API, you can look at the specifications here: <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals">https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals</a>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/>Summary</h1>
			<p>In this chapter, we looked at a couple of technologies related to Three.js. We showed you different ways of integrating Three.js with TypeScript and React, and we also showed you how to create some basic AR and VR scenes.</p>
			<p>By using the Three.js TypeScript bindings, you can easily access all the Three.js functionality from your TypeScript project. And integrating Three.js with React is made easy through the React Three Fiber library.</p>
			<p>Using VR and AR in Three.js is also very straightforward. By just adding a couple of properties to the main renderer, you can quickly convert any scene into a VR or AR scene. Remember to use the browser plugin to easily test your scenes without needing actual VR and AR devices.</p>
			<p>With that, we’ve come to the end of this book. I hope you’ve enjoyed reading it and playing around with the examples. Happy experimenting!</p>
		</div>
	</body></html>