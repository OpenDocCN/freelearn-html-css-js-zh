<html><head></head><body>
		<div id="_idContainer349">
			<h1 id="_idParaDest-241" class="chapter-number"><a id="_idTextAnchor240"/>14</h1>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>Three.js Together with React, TypeScript, and Web-XR</h1>
			<p>In this final chapter, we’ll dive into two additional topics. First, we’ll look at how you can combine Three.js with TypeScript and React. The second part of this chapter will show some examples of how you can integrate your 3D scenes with Web-XR. With Web-XR, you can enhance your scenes to work with VR and <span class="No-Break">AR technologies.</span></p>
			<p>More specifically, we’ll show you the <span class="No-Break">following examples:</span></p>
			<ul>
				<li><strong class="bold">Using Three.js with TypeScript</strong>: For the first example, we’ll show you how you can create a simple project that combines Three.js and TypeScript. We’ll create a very simple application, much like the samples we’ve already seen in the previous chapters, and show you how you can use TypeScript with Three.js to create <span class="No-Break">your scenes.</span></li>
				<li><strong class="bold">Using Three.js and React with TypeScript</strong>: React is a very popular framework for web development and is often used together with TypeScript. For this section, we’ll create a simple Three.js project, which uses React.js together <span class="No-Break">with TypeScript.</span></li>
				<li><strong class="bold">Using Three.js and React with Three.js fibers</strong>: Finally, we’ll look at <strong class="source-inline">React-three-fiber</strong>. With this library, we can configure Three.js declaratively using a set of React components. This library provides great integration between React and Three.js and makes working with Three.js in a React <span class="No-Break">application straightforward.</span></li>
				<li><strong class="bold">Three.js and VR</strong>: This section will show you how you can view your 3D scene <span class="No-Break">in VR.</span></li>
				<li><strong class="bold">Three.js and AR</strong>: This section will explain how you can create a simple 3D scene where you can add <span class="No-Break">Three.js meshes.</span></li>
			</ul>
			<p>Let’s start with the first example of this chapter and integrate Three.js <span class="No-Break">with TypeScript.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Using Three.js with TypeScript</h1>
			<p>TypeScript provides a typed <a id="_idIndexMarker1356"/>language that transpiles to JavaScript. This means <a id="_idIndexMarker1357"/>that you can use it to create your site, and it’ll run just like <a id="_idIndexMarker1358"/>normal JavaScript in the browser. There are many different ways of setting up <a id="_idIndexMarker1359"/>a TypeScript project, but the easiest one is provided by Vite (<a href="https://vitejs.dev/">https://vitejs.dev/</a>). Vite provides an integrated build environment and can be seen a bit as an alternative to webpack (which we use for the normal <span class="No-Break">chapter samples).</span></p>
			<p>The first thing we need to do is create a new Vite project. You can do these steps yourself, or you can look in the <strong class="source-inline">three-ts</strong> folder and just run <strong class="source-inline">yarn install</strong> there to skip this setup. To get an empty TypeScript project with Vite, all we have to do is run the following code in <span class="No-Break">the console:</span></p>
			<pre class="source-code">
$ yarn create vite three-ts --template vanilla-ts
yarn create v1.22.17
warning package.json: No license field
[1/4] <img src="image/01.png" alt=""/>  Resolving packages...
[2/4] <img src="image/02.png" alt=""/>  Fetching packages...
[3/4] <img src="image/03.png" alt=""/>  Linking dependencies...
[4/4] <img src="image/04.png" alt=""/>  Building fresh packages...
warning Your current version of Yarn is out of date. The latest version is "1.22.19", while you're on "1.22.17".
info To upgrade, run the following command:
$ curl --compressed -o- -L https://yarnpkg.com/install.sh | bash
success Installed "create-vite@3.2.1" with binaries:
      - create-vite
      - cva
[######################################################################] 70/70
Scaffolding project in /Users/jos/dev/git/personal/ltjs4-all/three-ts...</pre>
			<p>Next change into the directory (<strong class="source-inline">three-ts</strong>) and run <span class="No-Break"><strong class="source-inline">yarn install</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
$ yarn install
yarn install v1.22.17
warning ../package.json: No license field
info No lockfile found.
[1/4] <img src="image/01.png" alt=""/>  Resolving packages...
[2/4] <img src="image/02.png" alt=""/>  Fetching packages...
[3/4] <img src="image/03.png" alt=""/>  Linking dependencies...
[4/4] <img src="image/04.png" alt=""/>  Building fresh packages...
success Saved lockfile.
<img src="image/05.png" alt=""/>  Done in 3.31s.</pre>
			<p>At this point, we’ve <a id="_idIndexMarker1360"/>got an empty Vite project, which you <a id="_idIndexMarker1361"/>can start by running <span class="No-Break"><strong class="source-inline">yarn vite</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
$  three-ts git:(main) <img src="image/06.png" alt=""/> yarn vite
yarn run v1.22.17
warning ../package.json: No license field
$ /Users/jos/dev/git/personal/ltjs4-all/three-ts/node_modules/.bin/vite
  VITE v3.2.3  ready in 193 ms
  <img src="image/07.png" alt=""/>  Local:   http://127.0.0.1:5173/
  <img src="image/07.png" alt=""/>  Network: use --host to expose</pre>
			<p>If you point <a id="_idIndexMarker1362"/>your browser to <strong class="source-inline">http://127.0.0.1:5173/</strong>, you’ll see the start page of Vite, and you’ll have a configured <a id="_idIndexMarker1363"/>TypeScript project <span class="No-Break">in place:</span></p>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/Figure_14.1_B18726.jpg" alt="Figure 14.1 – Empty TypeScript project with Vite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Empty TypeScript project with Vite</p>
			<p>Next, we must add the Three.js libraries, after which we can add some TypeScript to initialize Three.js. To add Three.js, we need to add the following two <span class="No-Break">node modules:</span></p>
			<pre class="source-code">
$ yarn add three
$ yarn add -D @types/three</pre>
			<p>The first one adds the Three.js library, while the second one adds the <strong class="source-inline">types</strong> descriptions for the Three.js library. These <strong class="source-inline">types</strong> are used in the editor to get some nice code completion when working with Three.js and TypeScript in your IDE (for example, in Visual Studio Code). At this point, we’re ready to add Three.js to this project and start <a id="_idIndexMarker1364"/>developing Three.js applications using TypeScript. To <a id="_idIndexMarker1365"/>add TypeScript, the first thing we need to do is take a quick look at how the application is initialized. For this, you can look at the <strong class="source-inline">public.html</strong> file, which looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0" /&gt;
    &lt;title&gt;Vite + TS&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script type="module" src="/src/main.ts"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>In the preceding code, as you can see in the last <strong class="source-inline">script</strong> line, this HTML page loads the <strong class="source-inline">src/main/ts</strong> file. Open this file and change its content <span class="No-Break">to this:</span></p>
			<pre class="source-code">
import './style.css'
import { initThreeJsScene } from './threeCanvas'
const mainElement = document.querySelector
  &lt;HTMLDivElement&gt;('#app')
if (mainElement) {
  initThreeJsScene(mainElement)
}</pre>
			<p>The code here will try to find the main <strong class="source-inline">#app</strong> node. And if it finds the node, it’ll pass that node <a id="_idIndexMarker1366"/>to the <strong class="source-inline">initThreeJsScene</strong> function, which is <a id="_idIndexMarker1367"/>defined in the <strong class="source-inline">threeCanvas.ts</strong> file. This file contains the code to initialize the <span class="No-Break">Three.js scene:</span></p>
			<pre class="source-code">
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/
  controls/OrbitControls'
export const width = 500
export const height = 500
export const initThreeJsScene = (node: HTMLDivElement) =&gt; {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, height /
    width, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer()
  renderer.setClearColor(0xffffff)
  renderer.setSize(height, width)
  node.appendChild(renderer.domElement)
  camera.position.z = 5
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshNormalMaterial()
  const cube = new THREE.Mesh(geometry, material)
  const controls = new OrbitControls(camera, node)
  scene.add(cube)
  const animate = () =&gt; {
    controls.update()
    requestAnimationFrame(animate)
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    renderer.render(scene, camera)
  }
  animate()
}</pre>
			<p>This will look familiar to the code from the first couple of chapters where we created an initial simple <a id="_idIndexMarker1368"/>scene. The main change is that, here, we can use <a id="_idIndexMarker1369"/>all the features provided by TypeScript. Vite will handle the transpiling to JavaScript, so you don’t need to do anything else to see the results of this in <span class="No-Break">your browser:</span></p>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/Figure_14.2_B18726.jpg" alt="Figure 14.2 – Simple TypeScript project with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Simple TypeScript project with Three.js</p>
			<p>Now that we’ve <a id="_idIndexMarker1370"/>introduced Three.js and TypeScript, let’s <a id="_idIndexMarker1371"/>go a step further and see how we can integrate this with React <span class="No-Break">as well.</span></p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/>Using Three.js and React with TypeScript</h1>
			<p>There are <a id="_idIndexMarker1372"/>different ways of creating a React application <a id="_idIndexMarker1373"/>from scratch (Vite, for instance, also supports this), but the most common way is to use the <strong class="source-inline">yarn create react-app lts-tf --template TypeScript</strong> command from the command line. Just like with Vite, this will create a new project. For this example, we’ve created this project in the <strong class="source-inline">lts-tf</strong> directory. Once created, we have to add the Three.js libraries just like we did <span class="No-Break">for Vite:</span></p>
			<pre class="source-code">
$ yarn create react-app lts-tf --template TypeScript
...
$ cd lts-tf
$ yarn add three
$ yarn add -D @types/three
$ yarn install</pre>
			<p>This should set up a simple react TypeScript application, add the correct Three.js libraries, and install all the other required modules. The next step is to quickly check if all this works. Run the <strong class="source-inline">yarn </strong><span class="No-Break"><strong class="source-inline">start</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
$ yarn start
Compiled successfully!
You can now view lts-tf in the browser.
  Local:            http://localhost:3000
  On Your Network:  http://192.168.68.112:3000
Note that the development build is not optimized.
To create a production build, use yarn build.
webpack compiled successfully
Files successfully emitted, waiting for typecheck results...
Issues checking in progress...
No issues found.</pre>
			<p>Open <a id="_idIndexMarker1374"/>your browser to <strong class="source-inline">http://localhost:3000</strong> and <a id="_idIndexMarker1375"/>you’ll see a simple React <span class="No-Break">startup screen:</span></p>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/Figure_14.3_B18726.jpg" alt="Figure 14.3 – Simple TypeScript project with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Simple TypeScript project with Three.js</p>
			<p>On this screen, we can see that we need to edit the <strong class="source-inline">app.tsx</strong> file, so we’ll update this similar to the plain TypeScript example we saw in the <em class="italic">Using Three.js with TypeScript</em> section, but this time as a <span class="No-Break">React component:</span></p>
			<pre class="source-code">
import './App.css'
import { ThreeCanvas } from './ThreeCanvas'
function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ThreeCanvas&gt;&lt;/ThreeCanvas&gt;
    &lt;/div&gt;
  )
}
export default App</pre>
			<p>As you <a id="_idIndexMarker1376"/>can see, here, we defined a custom <a id="_idIndexMarker1377"/>component named <strong class="source-inline">ThreeCanvas</strong>, which is now loaded as soon as the application starts. The Three.js initialization code is provided by the <strong class="source-inline">ThreeCanvas</strong> element, which you can find in the <strong class="source-inline">ThreeCanvas.tsx</strong> file. This file, for the most part, is similar to the <strong class="source-inline">initThreeJsScene</strong> function we described in the <em class="italic">Using Three.js with TypeScript</em> section, but we’ll include the whole file here <span class="No-Break">for completeness:</span></p>
			<pre class="source-code">
import { useCallback, useState } from 'react'
import * as THREE from 'three'
const initThreeJsScene = (node: HTMLDivElement) =&gt; {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, 500 / 500,
    0.1, 1000)
  const renderer = new THREE.WebGLRenderer()
  renderer.setClearColor(0xffffff)
  renderer.setSize(500, 500)
  node.appendChild(renderer.domElement)
  camera.position.z = 5
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshNormalMaterial()
  const cube = new THREE.Mesh(geometry, material)
  scene.add(cube)
  const animate = () =&gt; {
    requestAnimationFrame(animate)
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
    renderer.render(scene, camera)
  }
  animate()
}
export const ThreeCanvas = () =&gt; {
  const [initialized, setInitialized] = useState(false)
  const threeDivRef = useCallback(
    (node: HTMLDivElement | null) =&gt; {
      if (node !== null &amp;&amp; !initialized) {
        initThreeJsScene(node)
        setInitialized(true)
      }
    },
    [initialized]
  )
  return (
    &lt;div
      style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh'
      }}
      ref={threeDivRef}
    &gt;&lt;/div&gt;
  )
}</pre>
			<p>In <strong class="source-inline">initThreeJsScene</strong>, you can find the standard code to initialize a simple Three.js scene using TypeScript. To connect this Three.js scene to React, we can use the code from the <strong class="source-inline">ThreeCanvas</strong> functional React component. What we want to do here is initialize the Three.js scene at the moment the <strong class="source-inline">div</strong> element gets attached to its parent node. To do <a id="_idIndexMarker1378"/>this, we can use the <strong class="source-inline">useCallback</strong> function. This <a id="_idIndexMarker1379"/>function will be called once when this node gets attached to its parent, and won’t rerun even if one of the parent properties changes. In our case, we will also add another <strong class="source-inline">isInitialized</strong> state to make sure that even if we have the development server reload parts of the application, we only initialize our Three.js <span class="No-Break">scene once.</span></p>
			<p class="callout-heading">useRef or useCallback</p>
			<p class="callout">You might be <a id="_idIndexMarker1380"/>tempted to use <strong class="source-inline">useRef</strong> here. There is a good explanation at https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node regarding why, in this <a id="_idIndexMarker1381"/>case, you should use <strong class="source-inline">useCallback</strong> instead of <strong class="source-inline">useRef</strong> to avoid <span class="No-Break">unnecessary rerenderings.</span></p>
			<p>With the preceding setup in place, we can now see <span class="No-Break">the result:</span></p>
			<div>
				<div id="_idContainer338" class="IMG---Figure">
					<img src="image/Figure_14.4_B18726.jpg" alt="Figure 14.4 – Three.js with TypeScript and React"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Three.js with TypeScript and React</p>
			<p>In the previous example, we created a simple integration between React and Three.js. While <a id="_idIndexMarker1382"/>this works, it feels a bit strange to programmatically <a id="_idIndexMarker1383"/>describe a Three.js scene, since normally, in React, applications are declared declaratively using components. We can wrap the existing Three.js components as we did with the <strong class="source-inline">ThreeCanvas</strong> component, but this will quickly get complex. Luckily, though, all the hard work for this <a id="_idIndexMarker1384"/>has already been done by <a id="_idIndexMarker1385"/>the Three.js fibers project: <strong class="source-inline">https://docs.pmnd.rs/react-three-fiber/getting-started/introduction</strong>. In the next section, we’ll look at how easily Three.js and React can be integrated with the help of <span class="No-Break">this project.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor244"/>Using Three.js and React with React Three Fiber</h1>
			<p>In the previous <a id="_idIndexMarker1386"/>examples, we set up the integration between React and Three.js ourselves. While it works, that approach doesn’t tightly integrate with how React works. For a good integration between these frameworks, we can use React Three Fiber. We’ll start again by setting up <span class="No-Break">a project.</span></p>
			<p>For this, run the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
$ yarn create react-app lts-r3f
$ cd lts-3rf
$ yarn install
$ yarn add three
$ yarn add @react-three/fiber</pre>
			<p>This will install all the dependencies we need and set up a new React project. To start this project in the <strong class="source-inline">lts-r3f</strong> directory, run <strong class="source-inline">yarn start</strong>, which will start a server. Open the URL you see on the screen (<strong class="source-inline">http://localhost:3000</strong>); you’ll see the following screen, which we’ve seen before and shows an empty <span class="No-Break">React project:</span></p>
			<div>
				<div id="_idContainer339" class="IMG---Figure">
					<img src="image/Figure_14.5_B18726.jpg" alt="Figure 14.5 – Starting up a simple JavaScript React application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Starting up a simple JavaScript React application</p>
			<p>As the screen <a id="_idIndexMarker1387"/>starts to extend this example, we need to edit the <strong class="source-inline">app.jsx</strong> file. We’ll create a new component that will contain our <span class="No-Break">Three.js scene:</span></p>
			<pre class="source-code">
import './App.css'
import { Canvas } from '@react-three/fiber'
import { Scene } from './Scene'
function App() {
  return (
    &lt;Canvas&gt;
      &lt;Scene /&gt;
    &lt;/Canvas&gt;
  )
}
export default App</pre>
			<p>Here, we can already see the first of the Three Fiber components – the <strong class="source-inline">Canvas</strong> element. The <strong class="source-inline">Canvas</strong> element creates a <strong class="source-inline">Canvas</strong> div and is the parent container for all the other Three.js <a id="_idIndexMarker1388"/>components provided by this library. Since we added <strong class="source-inline">Scene</strong> as a child to this <strong class="source-inline">Canvas</strong> component, we can define our complete Three.js scene in our custom component. Next, we’ll create this <span class="No-Break"><strong class="source-inline">Scene</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
import React from 'react'
export const Scene = () =&gt; {
  return (
    &lt;&gt;
      &lt;ambientLight intensity={0.1} /&gt;
      &lt;directionalLight color="white" intensity={0.2}
       position={[0, 0, 5]} /&gt;
      &lt;mesh
        rotation={[0.3, 0.6, 0.3]}&gt;
        &lt;boxGeometry args={[2, 5, 1]} /&gt;
        &lt;meshStandardMaterial color={color}
          opacity={opacity} transparent={true} /&gt;
      &lt;/mesh&gt;
    &lt;/&gt;
  )
}</pre>
			<p>What we’ve got here is a very simple Three.js scene, which looks similar to the ones we saw earlier in this book. This scene contains the <span class="No-Break">following objects:</span></p>
			<ul>
				<li><strong class="source-inline">&lt;ambientLight&gt;</strong>: An instance of a <span class="No-Break"><strong class="source-inline">Three.AmbientLight</strong></span><span class="No-Break"> object.</span></li>
				<li><strong class="source-inline">&lt;directionalLight&gt;</strong>: An instance of a <span class="No-Break"><strong class="source-inline">Three.DirectionalLight</strong></span><span class="No-Break"> object.</span></li>
				<li><strong class="source-inline">&lt;mesh&gt;</strong>: This represents a <strong class="source-inline">Three.Mesh</strong>. As we know, a <strong class="source-inline">Three.Mesh</strong> contains <a id="_idIndexMarker1389"/>a geometry and a material, which are defined as children of this element. In this example, we’ve set the rotation on this mesh <span class="No-Break">as well.</span></li>
				<li><strong class="source-inline">&lt;boxGeometry&gt;</strong>: This is similar to <strong class="source-inline">Three.BoxGeometry</strong>, where we pass in the constructor arguments through the <span class="No-Break"><strong class="source-inline">args</strong></span><span class="No-Break"> property.</span></li>
				<li><strong class="source-inline">&lt;meshStandardMaterial&gt;</strong>: This creates an instance of a <strong class="source-inline">THREE.MeshStandardMaterial</strong>, and configures some properties on <span class="No-Break">this material.</span></li>
			</ul>
			<p>Now, when you open your browser to <strong class="source-inline">localhost:3000</strong>, you’ll see a <span class="No-Break">Three.js scene:</span></p>
			<div>
				<div id="_idContainer340" class="IMG---Figure">
					<img src="image/Figure_14.6_B18726.jpg" alt="Figure 14.6 – Three.js scene rendered using React Three Fiber"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Three.js scene rendered using React Three Fiber</p>
			<p>In this example, we’ve only shown a couple of small elements provided by React Three Fiber. All <a id="_idIndexMarker1390"/>objects provided by Three.js can be configured in the way we just showed. Just add them as elements, configure them, and they will be shown on the screen. Besides easily showing these elements, all these elements behave like normal React components. So, whenever the properties of a parent element change, all the elements are rerendered (or updated) <span class="No-Break">as well.</span></p>
			<p>Besides the elements provided by React Three Fiber, there are a whole set of additional components provided by <strong class="source-inline">@react-three/drei</strong>. You can find those components and their descriptions <span class="No-Break">at </span><a href="https://github.com/pmndrs/drei"><span class="No-Break">https://github.com/pmndrs/drei</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer341" class="IMG---Figure">
					<img src="image/Figure_14.7_B18726.jpg" alt="Figure 14.7 – Additional components from @react-three/drei"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Additional components from @react-three/drei</p>
			<p>For the <a id="_idIndexMarker1391"/>next example, we’re going to use a couple of the components provided by this library, so we need to add this to <span class="No-Break">our project:</span></p>
			<pre class="console">
$ yarn add @react-three/drei</pre>
			<p>Now, we’ll extend our example <span class="No-Break">to this:</span></p>
			<pre class="source-code">
import React, { useState } from 'react'
import './App.css'
import { OrbitControls, Sky } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
export const Scene = () =&gt; {
  // run on each render of react
  // const size = useThree((state) =&gt; state.size)
  const mesh = React.useRef()
  const [color, setColor] = useState('red')
  const [opacity, setOpacity] = useState(1)
  const [isRotating, setIsRotating] = useState(false)
  // run on each rerender of
  useFrame(({ clock }, delta, xrFrame) =&gt; {
    if (isRotating) mesh.current.rotation.x += 0.01
  })
  return (
    &lt;&gt;
      &lt;Sky distance={450000} sunPosition={[0, 1, 0]}
        inclination={0} azimuth={0.25} /&gt;
      &lt;ambientLight intensity={0.1} /&gt;
      &lt;directionalLight color="white" intensity={0.2}
        position={[0, 0, 5]} /&gt;
      &lt;OrbitControls&gt;&lt;/OrbitControls&gt;
      &lt;mesh
        ref={mesh}
        rotation={[0.3, 0.6, 0.3]}
        onClick={() =&gt; setColor('yellow')}
        onPointerEnter={() =&gt; {
          setOpacity(0.5)
          setIsRotating(true)
        }}
        onPointerLeave={() =&gt; {
          setOpacity(1)
          setIsRotating(false)
        }}
      &gt;
        &lt;boxGeometry args={[2, 5, 1]} /&gt;
        &lt;meshStandardMaterial color={color}
          opacity={opacity} transparent={true} /&gt;
      &lt;/mesh&gt;
    &lt;/&gt;
  )
}</pre>
			<p>Let’s <a id="_idIndexMarker1392"/>explore the code a bit before looking at the result in the browser. First, we’ll look at the new elements we added to <span class="No-Break">the component:</span></p>
			<ul>
				<li><strong class="source-inline">&lt;OrbitControls&gt;</strong>: This is provided by the <strong class="source-inline">drei</strong> library. This adds an <strong class="source-inline">THREE.OrbitControls</strong> element to the scene. This is the same as <strong class="source-inline">OrbitControls</strong>, which we used in the earlier chapters. As you can see here, just adding the element is enough; no additional configuration <span class="No-Break">is needed.</span></li>
				<li><strong class="source-inline">&lt;Sky&gt;</strong>: This element provides a nice sky background to <span class="No-Break">the scene.</span></li>
			</ul>
			<p>We’ve also added several standard <span class="No-Break">React Hooks:</span></p>
			<pre class="source-code">
  const mesh = React.useRef()
  const [color, setColor] = useState('red')
  const [opacity, setOpacity] = useState(1)
  const [isRotating, setIsRotating] = useState(false)</pre>
			<p>Here, we define a <strong class="source-inline">Ref</strong>, which we connect to the mesh (<strong class="source-inline">&lt;mesh ref={mesh}) ..&gt;</strong>). We use this so that we can access the Three.js component later on in the render loop. We also use <strong class="source-inline">useState</strong> three times to keep track of the <strong class="source-inline">color</strong> and <strong class="source-inline">opacity</strong> state values <a id="_idIndexMarker1393"/>of the material, as well as to see whether the <strong class="source-inline">mesh</strong> property is rotating or not. The first of these two Hooks is used in the events we defined on <span class="No-Break">the mesh:</span></p>
			<pre class="source-code">
      &lt;mesh
        onClick={() =&gt; setColor('yellow')}
        onPointerEnter={() =&gt; {
          setOpacity(0.5)
          setIsRotating(true)
        }}
        onPointerLeave={() =&gt; {
          setOpacity(1)
          setIsRotating(false)
        }}&gt;</pre>
			<p>With these event handlers, we can very easily integrate the mouse with the mesh. There’s no need for <strong class="source-inline">RayCaster</strong> objects – just add the event listener and you’re done. In this case, when the mouse pointer enters our mesh, we change the <strong class="source-inline">opacity</strong> state value and the <strong class="source-inline">isRotation</strong> flag. When the mouse leaves our mesh, we set the <strong class="source-inline">opacity</strong> state value back and set the <strong class="source-inline">isRotation</strong> flag to <strong class="source-inline">false</strong> again. Finally, when we click on the mesh, we change the color <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">yellow</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">color</strong> and <strong class="source-inline">opacity</strong> state values can be directly used in <strong class="source-inline">meshStandardMaterial</strong> <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;meshStandardMaterial color={color} opacity={opacity}
  transparent={true} /&gt;</pre>
			<p>Now, the opacity and color will automatically update whenever we fire the relevant events. For <a id="_idIndexMarker1394"/>the rotation, we want to use the Three.js render loop. For this, React Three Fiber provides an <span class="No-Break">additional hook:</span></p>
			<pre class="source-code">
  useFrame(({ clock }, delta, xrFrame) =&gt; {
    if (isRotating) mesh.current.rotation.x += 0.01
  })</pre>
			<p><strong class="source-inline">useFrame</strong> is called whenever we have a render loop in Three.js. In this case, we check the <strong class="source-inline">isRotating</strong> state, and if we should be rotating, we use the previously defined <strong class="source-inline">useRef</strong> reference to get access to the underlying Three.js component and simply increase its rotation. This is all very easy and convenient. The result in the browser looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer342" class="IMG---Figure">
					<img src="image/Figure_14.8_B18726.jpg" alt="Figure 14.8 – A scene using React and React Three Fiber effects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – A scene using React and React Three Fiber effects</p>
			<p>React Three Fiber and the <strong class="source-inline">drei</strong> library provide pretty much all the functionality you also have in the normal Three.js library (and some features that aren’t available as well). If you’re working with React and need Three.js integrated, this is a great way to use Three.js. Even <a id="_idIndexMarker1395"/>when you are not necessarily building a React application, the declarative way of defining your scene, the components, and the interactions offered by React Three Fiber is very intuitive. React Three Fiber provides a great alternative for any Three.js visualization you want <span class="No-Break">to create.</span></p>
			<p>In the next two sections, we’ll look at how you can extend your 3D scenes with AR and VR capabilities. We’ll start by looking at how to enable VR in <span class="No-Break">your scenes.</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/>Three.js and VR</h1>
			<p>Before we look <a id="_idIndexMarker1396"/>at the required code changes, we’ll add an extension to the browser with which we can simulate a VR headset and VR controls. That way, you can test your scenes without the need for a physical headset and physical controllers. For this, we’ll install the WebXR API simulator This plugin is available for both Firefox <span class="No-Break">and Chrome:</span></p>
			<ul>
				<li><strong class="bold">Firefox plugin</strong>: Download <a id="_idIndexMarker1397"/>and install it from <span class="No-Break">here: </span><a href="https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/&#13;"><span class="No-Break">https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/</span></a></li>
				<li><strong class="bold">Chrome plugin</strong>: Download <a id="_idIndexMarker1398"/>and install it from <span class="No-Break">here: </span><a href="https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje&#13;"><span class="No-Break">https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje</span></a></li>
			</ul>
			<p>Follow the instructions for your specific browser. After you’ve installed it, we can test it with this <span class="No-Break">example: </span><a href="https://immersive-web.github.io/webxr-samples/immersive-vr-session.html"><span class="No-Break">https://immersive-web.github.io/webxr-samples/immersive-vr-session.html</span></a><span class="No-Break">.</span></p>
			<p>Open this example, open your developer console, and click on the <strong class="bold">WebXR</strong> tab. Now, you’ll see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer343" class="IMG---Figure">
					<img src="image/Figure_14.9_B18726.jpg" alt="Figure 14.9 – Firefox browser with the WebXR API extension"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Firefox browser with the WebXR API extension</p>
			<p>In the extension, you’ll see a <a id="_idIndexMarker1399"/>virtual headset and some virtual VR controls. By clicking on the headset, you can simulate the movement of a real VR headset; the same applies to the controls. If you click the <strong class="bold">Enter VR</strong> button, you can now simply test your VR scenes, without an actual <span class="No-Break">VR headset:</span></p>
			<div>
				<div id="_idContainer344" class="IMG---Figure">
					<img src="image/Figure_14.10_B18726.jpg" alt="Figure 14.10 – Simulating a VR headset"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Simulating a VR headset</p>
			<p>Now that we’ve got a (virtual) headset <a id="_idIndexMarker1400"/>to play around with, let’s convert one of our previous scenes into a VR scene, where we can track head movement <a id="_idIndexMarker1401"/>and add functionality to some dummy VR controls. For this, we’ve created a copy of the “First Person Controls” example from <a href="B18726_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>. You can open this example by opening up the <strong class="source-inline">vr.html</strong> example from the <span class="No-Break"><strong class="source-inline">chapter-14</strong></span><span class="No-Break"> sources:</span></p>
			<div>
				<div id="_idContainer345" class="IMG---Figure">
					<img src="image/Figure_14.11_B18726.jpg" alt="Figure 14.11 – Empty VR scene based on example from Chapter 9"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Empty VR scene based on example from <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a></p>
			<p>To get your scene VR ready, we need to take a couple of steps. The first thing we need to do is tell Three.js that we’ll be enabling the Web-XR functionality. This can be done <span class="No-Break">like this:</span></p>
			<pre class="source-code">
renderer.xr.enabled = true</pre>
			<p>The next step is to <a id="_idIndexMarker1402"/>add a simple button that we can click to enter VR mode. Three.js provides a component out of the box for this, which we can use <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import { VRButton } from 'three/examples/jsm/webxr/VRButton'
document.body.appendChild(VRButton.createButton(renderer))</pre>
			<p>This will create the button you can see at the bottom of the screen in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">.</span></p>
			<p>Finally, we need to update our render loop. As you may recall from <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene With Three.js</em>, we use <strong class="source-inline">requestAnimationFrame</strong> to control our render loop. When working with VR, we need to change this slightly, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
animate()
function animate() {
  renderer.setAnimationLoop(animate)
  renderer.render(scene, camera)
  if (onRender) onRender(clock, controls, camera, scene)
}</pre>
			<p>Here, we <a id="_idIndexMarker1403"/>used <strong class="source-inline">renderer.setAnimationLoop</strong> instead of <strong class="source-inline">requestAnimationFrame</strong>. At this point, our scene has been converted into VR, and once we click the button, we enter VR mode and can look around <span class="No-Break">our scene:</span></p>
			<div>
				<div id="_idContainer346" class="IMG---Figure">
					<img src="image/Figure_14.12_B18726.jpg" alt="Figure 14.12 – Entering VR mode and rotating the camera using the browser extension"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – Entering VR mode and rotating the camera using the browser extension</p>
			<p>The previous screenshot is shown when you enter VR. You can now easily move the camera around by clicking on the VR device in the Web-XR extension and move it around. These steps are pretty much all you need to do to convert any Three.js scene into a <span class="No-Break">VR scene.</span></p>
			<p>If you look closely at  <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.12</em>, you might notice that we also show some handheld VR devices. We <a id="_idIndexMarker1404"/>haven’t shown how you can add these yet. For this, Three.js also comes with some nice <span class="No-Break">helper components:</span></p>
			<pre class="source-code">
import { XRControllerModelFactory } from
  'three/examples/jsm/webxr/XRControllerModelFactory'
const controllerModelFactory = new
  XRControllerModelFactory()
const controllerGrip1 = renderer.xr.getControllerGrip(0)
controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1))
scene.add(controllerGrip1)
const controllerGrip2 = renderer.xr.getControllerGrip(1)
controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2))
scene.add(controllerGrip2)</pre>
			<p>With the preceding code, we ask Three.js to get information about the attached controllers, create a model, and add them to the scene. If you use the WebXR API emulator, you can move the controls around and they’ll move around on the scene <span class="No-Break">as well.</span></p>
			<p>Three.js provides lots of examples of how you can use these controls to drag objects around, select objects in the scene, and otherwise add interactivity with the controls. For this simple example, we’ve added the option to add a cube at the position of the first control (the one on the right) whenever you click the <span class="No-Break"><strong class="source-inline">select</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer347" class="IMG---Figure">
					<img src="image/Figure_14.13_B18726.jpg" alt="Figure 14.13 – Adding cubes to the scene in VR"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – Adding cubes to the scene in VR</p>
			<p>We can do this by <a id="_idIndexMarker1405"/>simply adding event listeners to the controller, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const controller = renderer.xr.getController(0)
controller.addEventListener('selectstart', () =&gt; {
  console.log('start', controller)
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,
    0.1, 0.1), new THREE.MeshNormalMaterial())
  mesh.position.copy(controller.position)
  scene.add(mesh)
})
controller.addEventListener('selectend', () =&gt; {
  console.log('end', controller)
})</pre>
			<p>In this simple piece of code, you can see that we’ve added two event listeners to the controller. When the <strong class="source-inline">selectstart</strong> event is triggered, we add a new cube to the location of this controller. And when the <strong class="source-inline">selectend</strong> event is triggered, we just log some information <a id="_idIndexMarker1406"/>to the console. Several other events can be accessed through JavaScript. For more information about the APIs that are available when you are in a VR session, you can look at the following <span class="No-Break">documentation: </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/XRSession&#13;"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/XRSession</span></a></p>
			<p>For the last section, we’ll have a quick look at how you can combine Three.js <span class="No-Break">with AR.</span></p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Three.js and AR</h1>
			<p>While VR using <a id="_idIndexMarker1407"/>Three.js is well supported on a large range of devices and browsers, this isn’t the case for Web-AR. On Android, the support is pretty good, but on iOS devices, it doesn’t work that well. Apple is currently working on adding this to Safari, so once that’s in, native AR should also work on iOS. A good way to check which browsers support this functionality is to check <a href="https://caniuse.com/webxr">https://caniuse.com/webxr</a>, which provides <a id="_idIndexMarker1408"/>an up-to-date overview of all major <span class="No-Break">browser support.</span></p>
			<p>So, to test the native AR example, you either need to view it on an Android device, or use the same simulator we used in the <em class="italic">Three.js and </em><span class="No-Break"><em class="italic">VR</em></span><span class="No-Break"> section.</span></p>
			<p>Let’s create a standard scene you can use as a starting point for your AR experiments. The first thing we need to do is tell Three.js we want to <span class="No-Break">use XR:</span></p>
			<pre class="source-code">
const renderer = new THREE.WebGLRenderer({ antialias: true,
  alpha: true })
renderer.xr.enabled = true</pre>
			<p>Note that we need to set the <strong class="source-inline">alpha</strong> property to <strong class="source-inline">true</strong>; otherwise, we won’t see any passthrough from the camera. Next, just like we did for VR, we need to enable AR/VR on the renderer, by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">rendered.xr.enabled</strong></span><span class="No-Break">.</span></p>
			<p>To enter AR mode, Three.js also provides a button we <span class="No-Break">can use:</span></p>
			<pre class="source-code">
Import { ARButton } from 'three/examples/jsm/
  webxr/ARButton'
document.body.appendChild(ARButton.createButton(renderer))</pre>
			<p>Finally, we just need to change <strong class="source-inline">requestAnimationFrame</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">setAnimationLoop</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
animate()
function animate() {
  renderer.setAnimationLoop(animate)
  renderer.render(scene, camera)
}</pre>
			<p>And that’s all <a id="_idIndexMarker1409"/>there is to it. If you open the <strong class="source-inline">ar.html</strong> example and view this example through the WebXR plugin (where you need to select the <strong class="source-inline">Samsung Galaxy S8+ (AR)</strong> device), you’ll see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer348" class="IMG---Figure">
					<img src="image/Figure_14.14_B18726.jpg" alt="Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality</p>
			<p>In this screenshot, you <a id="_idIndexMarker1410"/>can see a simulated AR environment, where we can see the two objects that we’ve rendered. If you move the simulated phone around, you’ll notice that the rendered objects are fixed in their location relative to the position of the camera of <span class="No-Break">the phone.</span></p>
			<p>The example here is very simple but it shows the basics of how to set up a minimal AR scene. Web-XR offers a lot <a id="_idIndexMarker1411"/>of other functionality related to AR, such as detecting planes and hit testing. However, covering that falls a bit outside of the scope of this book. For more information on Web-XR and the native AR functionality exposed by this API, you can look at the specifications <span class="No-Break">here: </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/>Summary</h1>
			<p>In this chapter, we looked at a couple of technologies related to Three.js. We showed you different ways of integrating Three.js with TypeScript and React, and we also showed you how to create some basic AR and <span class="No-Break">VR scenes.</span></p>
			<p>By using the Three.js TypeScript bindings, you can easily access all the Three.js functionality from your TypeScript project. And integrating Three.js with React is made easy through the React Three <span class="No-Break">Fiber library.</span></p>
			<p>Using VR and AR in Three.js is also very straightforward. By just adding a couple of properties to the main renderer, you can quickly convert any scene into a VR or AR scene. Remember to use the browser plugin to easily test your scenes without needing actual VR and <span class="No-Break">AR devices.</span></p>
			<p>With that, we’ve come to the end of this book. I hope you’ve enjoyed reading it and playing around with the examples. <span class="No-Break">Happy experimenting!</span></p>
		</div>
	</body></html>