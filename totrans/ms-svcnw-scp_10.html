<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Best Practices</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will be looking at best practices when scripting in ServiceNow. Best practices are important when scripting to make the most use of resources and present the best user experience. We will explore best practices in general scripting, server-side and client-side code, and debugging. We will also delve into best practices involving logs, queues, and system performance.</p>
<p>The following topics will be looked at in this chapter:</p>
<ul>
<li>Coding best practices</li>
<li>Business rule best practices</li>
<li>Client script best practices</li>
<li>Debugging tools best practices</li>
<li>Logs and queues best practices</li>
<li>System performance best practices</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding best practices</h1>
                </header>
            
            <article>
                
<p>When scripting, there are many ways to achieve the same goal, but keeping code efficient can make it much easier to maintain and work on in the future. Using a few system resources is usually encouraged too, as this decreases loading times and the load on the data center in the cloud.</p>
<p>You will often find that older instances suffer from poor performance because best practices were not adhered to during development. I have been part of minor projects simply to make code more efficient before, and because these are often associated with slow loading times, it can be a great improvement for the user base.</p>
<p>In this section, we will look at how to make sure your script adhers to best practices and how to avoid common mistakes.</p>
<p>First, one type of scripting that is quite common is nested <kbd>if</kbd> statements. This is an <kbd>if</kbd> statement after an <kbd>if</kbd> statement and is often used to catch several potential values for the same variable. We can see a server-side example of what this looks like:</p>
<pre>var state = current.state;<br/>if (state == '1') {<br/>  gs.log('State is New'); <br/>} else if (state == '2') {<br/>  gs.log('State is In Progress');<br/>} else if (state == '6') {<br/>  gs.log('State is Resolved');<br/>}</pre>
<p>We can also see what this looks like in a script field in <em>Figure 10.1</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-484 image-border" src="assets/9b0da519-1776-4e5e-932e-333a32ed5b1e.png" style="width:96.08em;height:21.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.1: Nested if statement script example</div>
<p>Instead of using these nested if statements, it is better to use a <kbd>switch</kbd> statement. We can see how the previous script can be a more efficient <kbd>switch</kbd> statement instead:</p>
<pre>switch(state.getDisplayValue()) {<br/>    case 'New':<br/>    gs.log('State is New');<br/>    break;<br/>    case 'In Progress':<br/>    gs.log('State is In Progress');<br/>    break;<br/>    case 'Resolved':<br/>    gs.log('State is Resolved');<br/>    break;<br/>    default:<br/>    gs.log('Not Found');<br/>  }</pre>
<p>The <kbd>switch</kbd> statement is easier to read as well for developers who may need to maintain the ServiceNow instance.</p>
<p>We can see the <kbd>switch</kbd> statement inside a script field in <em>Figure 10.2</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-485 image-border" src="assets/5ac4131c-bdb6-4b33-8530-32cdc872631f.png" style="width:95.17em;height:26.92em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.2: Switch statement script example</div>
<p>Ensure that you use a break at the end of each case to ensure that the <kbd>switch</kbd> statement works correctly, as sometimes this can be omitted by mistake.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business rule best practices</h1>
                </header>
            
            <article>
                
<p>Business rule best practices are, to a large extent, about running business rules at the correct time. As we have already discovered, a business rule can be run at different times based on when the form is saved or the action is taken to the record. </p>
<p>This means that it is important to make sure that a business rule that is created is running in the most efficient way. Using business rules correctly, we can avoid problems such as updating the same record twice and running script when it is not required.</p>
<p>We'll start with looking at the check boxes on a business rule, as shown in <em>Figure 10.3</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3fdd372f-ae82-46c1-be9d-400360e4aaf9.png" style="width:10.58em;height:13.17em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.3: Business rule check boxes</div>
<p><span class="packt_screen">Insert</span> and <span class="packt_screen">Update</span> are the most frequently used, and they are often used together. However, it is a best practice to ensure that you make your business rule only run when necessary. Do not tick both boxes just to cover all possibilities; if your business rule is not needed when a record is inserted or updated then leave that tick box unchecked.</p>
<p>Usually, <span class="packt_screen">Delete</span> and <span class="packt_screen">Query</span> are selected individually, as these operations do not tend to align themselves with any other operations.</p>
<p><span>As business rules run on the server side, a good practice in business rule script also applies to other areas of ServiceNow where server-side scripting is used.</span></p>
<p>The <span class="packt_screen">When</span> field is the next field we will look at. This is an important field to get right, and avoid bad practices by doing so. There are four options here; let's have a look at each.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Before</h1>
                </header>
            
            <article>
                
<p>Running a business rule before a record is saved is a great way to change values before the save action takes place. The before option should be selected when making changes to the record being saved. This means that if you are changing values using current, then before is most likely the best option.</p>
<p>Remember that when running a script in a before business rule, the record has not been saved yet. This means that you only need to set the values in the current record as the record will be saved afterward. This also means that you need to ensure that you avoid using <kbd>current.update()</kbd> as this will end up saving the record twice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">After</h1>
                </header>
            
            <article>
                
<p>If the business rule is run with the after option selected, the script runs immediately after the record is saved. We should use the after option if we are updating values not on the current record we are saving, but want the script to be run immediately.</p>
<p>This option is useful to update records associated with the record being saved, for example, to change tasks when updating a change. This is also a good option if we are scripting any sort of approval changes for the record being saved, as these will be displayed on the record after it is reloaded, after being saved.</p>
<p>If we are looking to update the current record, then it is better to use the before option. If you are thinking of using <kbd>current.update()</kbd> in your script, then think about using the before option instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Async</h1>
                </header>
            
            <article>
                
<p>The async option will send the script to the system scheduler, and it will be run shortly after the record is saved. This option is good for when the script you have written does not need to be run immediately after the record is saved.</p>
<p>Good uses for the async option are for sending messages between integrations and sending tasks to the ECC queue. Remember that the async option can have a more significant delay if the ServiceNow instance-scheduled job queue is long, so be mindful of the average wait time for your instance when setting an async business rule. If you would like a more instant running of your script, consider the after option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Display</h1>
                </header>
            
            <article>
                
<p>A display business rule runs when a record is loaded before any client-side scripts are run. This type of business rule is useful for providing values to the client side so that there is no need to call the server from a client script. We can avoid AJAX calls using this type of business rule.</p>
<p>Display business rules were not always available in ServiceNow, so you may find instances where using them in old instances can reduce server calls in client scripts and therefore reduce record-loading times. </p>
<p>If you are considering using an AJAX call in an onLoad client script, then you should instead, where possible, use a display business rule to fetch the server-side values you require and set them in a scratchpad for client-side scripts to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client script best practices</h1>
                </header>
            
            <article>
                
<p>As we have seen, client scripts run on the client side and so only have access to data that has been sent to the client from the server. The main goal we have when writing client-side scripts is to minimize the amount of script we write and the calls to the server we make.</p>
<p>The reason we keep client scripting to a minimum is that these scripts run in front of the user and therefore directly effect loading times. We want to keep loading times to a minimum and, therefore, client scripting to a minimum also.</p>
<p>When writing a new client script, it is worth considering whether the script could be run on the server side instead, and if so, then this is usually considered a best practice.</p>
<p>Let's have a look at one of the most common bad practices in client scripting. Take the following script, for example:</p>
<pre>function onLoad() {<br/>  var user = new GlideRecord('sys_user');<br/>  user.get(g_form.getValue('caller_id'));<br/>  g_form.showFieldMsg('caller_id', 'Active: ' + user.active);<br/>  <br/>}</pre>
<p>This script is calling the server side to get the details about the current caller for an incident, and whether that caller is active now in the system. This is a bad practice as we can already tell whether this user is active before we load the record, rather than loading it, then going back to the database again, increasing load times.</p>
<p>We can see what this code would look like in the following client script:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-486 image-border" src="assets/84110aec-6a8c-4713-beb8-416985f4c191.png" style="width:105.33em;height:57.67em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.4: Client script showing bad practise by making an unnecessary server call</div>
<p>To keep this functionality, but improve the code, we can use a display business rule. By doing this, we bring the data we want from the server before we get to the client using a scratchpad.</p>
<p>First, we create the display business rule with the following code:</p>
<pre>(function executeRule(current, previous /*null when async*/) {<br/><br/>  g_scratchpad.caller_active = current.caller_id.active;<br/><br/>})(current, previous);</pre>
<p>This code sets the active field value to the <kbd>caller_active</kbd> scratchpad so that it can be used by the client code. </p>
<p>Let's see what this looks like as a display business rule:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-487 image-border" src="assets/33caf409-5655-4b44-96f7-e387f1389de3.png" style="width:117.92em;height:49.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.5: Display business rule setting a scratchpad variable</div>
<p>In our business rule, we would set the <span class="packt_screen">When</span> field on the <span class="packt_screen">When to run</span> tab to be displayed so that this rule runs as the form is loaded. For our example, we have set the incident form as the table to run this business rule on.</p>
<p>Now, we have the display business rule set up, so we just need to amend our client script:</p>
<pre>function onLoad() {<br/>  <br/>  g_form.showFieldMsg('caller_id', 'Active: ' + g_scratchpad.caller_active);<br/><br/>}</pre>
<p>In the earlier code, we set the field message text using the scratchpad value we set in the display business rule. This now means that we are not making a round trip to the server for this detail anymore as it is sent initially.</p>
<p>Let's see what this will look like in a defined client script:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-488 image-border" src="assets/6b113e83-e523-48c3-9e8c-066bbff49ac5.png" style="width:105.50em;height:57.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.6: Client script setting a field message based on a scratchpad value</div>
<p>In our example, we are using the script when the incident form loads. This will show the active state of the caller currently selected on the incident form. We would also want to bear in mind changing this value if the caller changes.</p>
<p>Using this method, we can display any of the other caller attributes as well, including helpful fields like phone number or email address to contact a caller about progress on an incident. We could also display the line manager and use dot walking to display some of the manager's information.</p>
<p>Here, we can see what the output would look like for our example for a caller on the incident form:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e88c6d9c-bd36-49a4-8928-ada8e91557ce.png" style="width:37.25em;height:13.58em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Figure 10.7: Incident form showing a custom field message for the Caller field</div>
<p>We have opened one of the baseline incidents that is present in ServiceNow, and we can see that the current caller is active in ServiceNow.</p>
<div class="packt_tip">It is highly recommended to review the client scripts in your ServiceNow instance to ensure that no unnecessary server calls are made by them. Remember to use display business rules where possible.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging tools best practices</h1>
                </header>
            
            <article>
                
<p>As we have discovered in previous chapters, there are many ways to debug in ServiceNow. Each developer will have their own favorite methods, and also, there are better ways to debug different scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>One of my favorite ways of debugging is using logging techniques such as <kbd>gs.log</kbd>. In earlier chapters, we saw that these logs can be added to a script, and when the script runs, we see these logs in the system log for the ServiceNow instance. </p>
<p>However, we must ensure that this debugging is never seen in a production instance. It is a good practice to check each script that you write to ensure that no debugging is left in the final version. It can be a good idea to check the system log before your newly created script is executed and then again once you have finished. If there are any logging messages that are sent, then these should be removed before the new functionality is sent to a production instance.</p>
<p>It is also important to make sure that you make your logging messages relevant to the functionality you are trying to achieve. This is especially important if you aim to leave in some logging functionality for your new code. Building some logging functionality can be helpful in a larger application or customization.</p>
<p>Consider, for example, the following code and logging:</p>
<pre>var caller = current.caller_id;<br/>gs.log('log');</pre>
<p>This example will create a log when the value of the caller has been successfully put into the caller variable, but it does not offer much information.</p>
<p>We can see the log this creates here:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-489 image-border" src="assets/1af01dba-3064-4ceb-ab33-82a1126d309a.png" style="width:67.67em;height:7.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.8: Sample basic log</div>
<p>To improve our log, let's look at another example:</p>
<pre>var caller = current.caller_id;<br/>gs.log('caller id obtained from the caller field');</pre>
<p>This second example is better because we now have some information about what is happening at this point in the code, and where the code was successful. </p>
<p>The output of this log looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-490 image-border" src="assets/8cf92da7-bd2e-4149-ad80-cdd63246976d.png" style="width:70.92em;height:8.33em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.9: Sample improved log</div>
<p>We can still improve this further though by adding more information at this point.</p>
<p>Let's look at a further example on logging in this way:</p>
<pre>var caller = current.caller_id;<br/>gs.log('caller id obtained from the caller field with value ' + caller);</pre>
<p>Looking at the example, we now have added code in our logging to log the value of the caller field, as well as the details of what has occurred in the script. This will log the <kbd>sys_id</kbd> of the user in the system log, so we can check the value of the caller variable is correct at this point in the code.</p>
<p>We can see this improved log in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-491 image-border" src="assets/6b5b4b7c-9459-4dfc-ab5d-d5c3a9ff4498.png" style="width:96.50em;height:8.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.10: Sample log with data added</div>
<p>Now, we will look at one final example:</p>
<pre>var caller = current.caller_id;<br/>gs.log('caller id obtained from the caller field with value ' + caller.getDisplayValue());</pre>
<p>With this final example, we are now logging the display value to the log, so we can see the actual name of the user rather than just the <kbd>sys_id</kbd> of the user. This makes the result clearer for a developer reading through the log statements.</p>
<p>Let's look at how the final example looks in the system log:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-492 image-border" src="assets/e8dba677-3bae-4ccc-ba7b-c43c818ecc20.png" style="width:89.08em;height:7.75em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.11:  Sample log with useful data included</div>
<p>We have seen how it is easy to add logging to ServiceNow script, but it is best practice to ensure that the logs you create would be helpful to developers other than yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Session debug</h1>
                </header>
            
            <article>
                
<p>Session debug can be a powerful tool, but it can also create an overload of logs making debugging a long and arduous process. When using session debugging, it is important to think about the type of logs you need to debug the situation.</p>
<p>While it can seem easiest to simply enable all session debugging, it is best to enable the areas you are interested in only. This ensures there are less logs to go through and means you can access the information that you are interested in faster.</p>
<p>In general, I do not find session debug to be used by many developers except for scopes and security rules. This is because other methods are preferred for the other debugging options session debugging provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logs and queues best practices</h1>
                </header>
            
            <article>
                
<p>Logs and queues are an important part of a ServiceNow instance. Logs are used throughout ServiceNow to record events occurring in an instance. These are used in debugging, as we have seen, and these logs should be well-defined when included.</p>
<p>Queues are seen in ServiceNow in a number of areas, from the ECC queue to the system scheduler. These queues build up jobs or actions to be performed when the time is right.</p>
<p>When using logs and queues, it is important to make logs clear and only create jobs or event in queues where necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logs</h1>
                </header>
            
            <article>
                
<p>Logs need to be created with clear information given for each log, and to be sent to the right logging location to ensure that the information can be easily read. We covered some logging techniques in the debugging section or how to write good logs, but we also need to make sure that we send logs to the correct log itself.</p>
<p>When using <kbd>gs.log</kbd>, we can specify a source to send the logs to. If no source is specified, then <span class="packt_screen">*** Script</span> will be the default source used. This will show the log in the <span class="packt_screen">Script Log Statements</span> module.</p>
<p>Here, we can see a sample log with the <span class="packt_screen">*** Script</span> source displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-493 image-border" src="assets/118bac73-6537-4fab-af5b-bc38a969c51b.png" style="width:78.83em;height:7.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.12: Sample script log</div>
<p>If you are creating a larger piece of functionality or a custom application, it is advised that you create your own logging source. By adding your own source, you can keep all of your logging separate and easy to maintain. It is also often the case that a developer will create a module as part of their new application to be directed to logs with the custom source of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queues</h1>
                </header>
            
            <article>
                
<p>There are many queues in ServiceNow that you can send jobs and events to. Queuing up a task or event allows them to be combined together and processed in a batch rather than individually.</p>
<p>Each queue will be processed after a given time, and the timing that each queue is processed is often set in the system properties. Changing the frequency that a queue is processed will mean that tasks or events are dealt with quicker, but it will have a draining effect on system resources. It is always important to carefully consider this when setting queue processing times at a different value to the defaults that are provided in the baseline system. </p>
<p>Now, let's take a look at some of the most important queues in a ServiceNow instance and the best practice for each queue type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event queue</h1>
                </header>
            
            <article>
                
<p>The event queue triggers events that are then picked up by notifications and script actions. Triggering an event does not use many system resources, so volume is not usually a problem. There are many events that are provided and triggered in the baseline system, so this queue will always contain activity.</p>
<p>The more important aspect of setting up scripts to send events to the event queue is making sure that the event is well-defined and only fires when it is supposed to. </p>
<p>Well-explained events are much easier to use for other developers, so try to demonstrate what the event is triggered by in the name of the event itself, and certainly in the definition.</p>
<p>We can see a sample event log here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/27c3e01e-f7b1-42b5-95a5-c7a97ad60ffb.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.13: Event log sample</div>
<p>In an event log, we can see when events were processed, and the processing duration of events. It is worth considering the impact of events taking a long time to process and, if necessary, investigate why this is the case.</p>
<p>In our example, we can see some regular events in the log including a successful login and established session, as well as a heartbeat event and text indexing.</p>
<p>When creating an event, ensure that you test edge-case scenarios so that the definition of the event truly reflects when it will fire.</p>
<div class="packt_tip">When sending an event to the event queue for the more distant future, be careful that the event will not be lost as part of table rotation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">System scheduler</h1>
                </header>
            
            <article>
                
<p>One of the most common ways that you can add a job to the system scheduler is to use an async business rule. Once an async business rule is triggered, it sends a job to the scheduler queue to run the script contained within it.</p>
<p>It is also possible to add your own jobs to the system scheduler. It is best to only do this where necessary, as too many jobs in the scheduler can be a detriment to instance performance. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ECC queue</h1>
                </header>
            
            <article>
                
<p>The ECC queue is where input and output messages from MID servers are held. This is usually for integrations between instances and other systems. Here, we can send jobs using scripts for the MID servers to perform. There is normally not a lot of scripted messages to the ECC queue as it normally triggers an integration in one line.</p>
<p>The ECC Queue is accessed from the application navigator by navigating to <span class="packt_screen">ECC</span> | <span class="packt_screen">Queue</span>. We can see this module here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7fecccce-53ba-4615-a4da-1d56a8f7e2b3.png" style="width:30.25em;height:8.17em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Figure 10.14:  ECC queue module</div>
<p>The queue will often contain heartbeat probes sent out to MID servers to check that they are responding. This is done every 5 minutes, and if a response is received, the MID server is marked as up, and if no response is received, the MID server is marked as down.</p>
<p>When sending jobs to the ECC queue, just make sure that each job is relevant and do not send more jobs than are necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">System performance best practices</h1>
                </header>
            
            <article>
                
<p>There are a number of attributes that make up the perceived performance of an instance. These can be greatly effected by badly coded scripts or a large number of them that are not required.</p>
<p>One of the most common ways scripting can cause perceived performance delays is when an excess of client scripts are used when a form opens. This causes a big delay in browser rendering and parsing, which is very apparent to the user. As we have mentioned before, a best practice in this scenario is to limit the amount of client scripts created only to those essential, and to ensure that server calls are kept to a minimum.</p>
<p>If information is needed for an <kbd>onLoad</kbd> client script, then consider a display business rule instead of calling the server from a client script. </p>
<p>Using this method, we can obtain the information we need from the server from the display business rule before displaying a form. Then, we run client-side code in a client script that will be able to use the information we provided from the display business rule.</p>
<p>It is possible to clear the cache of an instance by navigating to your instance name and suffixing it with <kbd>/cache.do</kbd>. This clears the cache for you and can help when you want to ensure that your new script is being run, and cached data is not being used.</p>
<p>We can see the screen a user is shown when navigating to the page that clears the cache, here in <em>Figure 10.15</em>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61ee7e84-2e2a-410b-879b-9aa670c02095.png" style="width:16.08em;height:33.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.15: Information provided on cache clearance</div>
<p>Clearing the cache for an instance, however, can cause performance degradation, so it is important to know when to do this. On non-production instances, this should not be a problem, as the performance decrease should not dramatically affect other developers. For a production instance though, this should be avoided during business hours where possible.</p>
<p>When considering system performance, it is also worth checking the performance of the instance being used. This can be done using the ServiceNow performance home page that ServiceNow provides.</p>
<p>Let's have a look at some of the graphs that this home page provides:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png" style="width:49.67em;height:49.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.16: System overview graphs sample</div>
<p>In the previously shown graphs, we can see an overview, transaction, response time, and active session graph. These can be helpful in finding out the current load on the instance and whether the response times are providing a good level of service.</p>
<p>The ServiceNow performance home page also displays many other graphs than the ones shown, which you can use. I tend to find the response times the most useful of the ones provided, but each graph can have its uses.</p>
<p>By keeping an eye on instance performance, you can be proactive in resolving potential system performance issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at best practices in ServiceNow. We looked at some of the best ways to use scripting in ServiceNow, and some bad practices to avoid. Our best practices included the areas of coding, business rules, and client scripts, as well as debugging, logs, queues, and system performance. We saw how these best practices work together to build a streamlined ServiceNow instance.</p>
<p>In the next chapter, we will look at using update sets. Update sets are a big part of moving functionality between instances of ServiceNow, and are widely used. We will look at when and how to use update sets and how they work in relation to scope. We discover how to move update sets between instances and the pitfalls to avoid when doing so. Finally, we take a look at best practices with update sets, so you can make the most of the ServiceNow application.</p>


            </article>

            
        </section>
    </body></html>