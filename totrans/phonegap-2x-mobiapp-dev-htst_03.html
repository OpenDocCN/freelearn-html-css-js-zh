<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Being Productive</h1></div></div></div><p>PhoneGap can be used for more than simple games and social media apps; it can also be used to create productivity apps that can be very useful. To do that, however, we need to learn about how to store persistent data using PhoneGap's File APIs. In this project, we'll do just that. We'll build a simple note-taking app named Filer that uses the File API to manage the available notes.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>What do we build?</h1></div></div></div><p>At its core, Filer<a id="id251" class="indexterm"/> is more about file management than it is about taking notes, <a id="id252" class="indexterm"/>but it is absolutely critical that you get file management right. Users don't take it kindly when an app corrupts or loses their data, so you must make sure to manage it correctly. Once that is accomplished, you can move on to making the app more complex. Thankfully, the concepts you learn in this project can be applied to all your future apps.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>What does it do?</h2></div></div></div><p>As the <a id="id253" class="indexterm"/>name implies, the app permits the user to <em>file</em> away notes for later retrieval. Doing this requires the use of the<a id="id254" class="indexterm"/> File APIs provided by PhoneGap. Not only do we need to be able to save and load notes, but we need to manage them as well. This includes removing notes at the user's request, renaming them, and duplicating them as well.</p><p>Once a note is created or opened, the app itself becomes very simple, essentially a large <code class="literal">TEXTAREA</code> element<a id="id255" class="indexterm"/> that will accept any kind of text you want to put in it. We'll also take a look at good ways to save and retrieve the data you enter.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Why is it great?</h2></div></div></div><p>This <a id="id256" class="indexterm"/>app is a great way to learn the File APIs present in PhoneGap to manage files that your App needs in order to save and retrieve data. We'll also consider how to present this to the user in a form they can easily understand.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>How are we going to do it?</h2></div></div></div><p>We'll be going <a id="id257" class="indexterm"/>about creating this app much like we have the past apps, using the following pointers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the user interface</li><li class="listitem" style="list-style-type: disc">Designing the data model</li><li class="listitem" style="list-style-type: disc">Implementing the data models</li><li class="listitem" style="list-style-type: disc">Implementing the documents view</li><li class="listitem" style="list-style-type: disc">Implementing the file view</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>What do I need to get started?</h2></div></div></div><p>You should <a id="id258" class="indexterm"/>be able to create your project and set it up much the same way as the prior apps. Call this project <code class="literal">Filer</code>.</p><p>Note that, if you want, you can include the sharing libraries from the second project. We'll not use them directly, but there is a challenge at the end of the project that asks you to add sharing. If you intend to do this, you might as well add everything now.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Designing the user interface</h1></div></div></div><p>First, get your<a id="id259" class="indexterm"/> paper and pencil out or use your favorite image editor.<a id="id260" class="indexterm"/> Like in previous projects, we'll design our views using sketches and wireframes first, then flesh them out a bit more to design the graphical assets.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Getting on with it</h2></div></div></div><p>As in previous<a id="id261" class="indexterm"/> projects, the first view is the start view<a id="id262" class="indexterm"/>, but since it<a id="id263" class="indexterm"/> is the same as all the prior apps, we won't go into detail about it here (refer to the <em>Designing the UI/interactions</em> section of <a class="link" href="ch01.html" title="Chapter 1. Let's Get Local!">Project 1</a>, <em>Let's Get Local!</em>). Instead, let's go to the documents view<a id="id264" class="indexterm"/>, shown in the following screenshot:</p><div><img src="img/9403_03_01.jpg" alt="Getting on with it"/></div><p>In this view we've actually got two looks; the left is for the iPhone, while the right is for Android. The reason for the two different looks is simply how a lot of apps do things on each platform. You typically see large, horizontal scrolling interfaces on iOS, and on Android you typically see vertical lists representing files.</p><p>Let's go over how <a id="id265" class="indexterm"/>this view works. <a id="id266" class="indexterm"/>The button in the navigation bar, named <strong>Create</strong>, allows the user to create a new note. Below the navigation bar is the list of files that are available. On the first run, of course, this will be empty, but as files are created, they are added here. This view will scroll as needed in order to show the entire list.</p><p>Each item in<a id="id267" class="indexterm"/> the list will have the same contents, even though they are arranged and sized differently. The first is the icon that represents the item; many apps will render a version of the content as this icon. To avoid complexity, we won't do that here; we'll use a static image instead. Tapping on the icon will open the note. The next is the icon's label, this shows the name of the file. When pressed, however, it will allow the user to rename the file.</p><p>Below the file name are the following three icons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For duplicating (copying) the note</li><li class="listitem" style="list-style-type: disc">For sharing the note</li><li class="listitem" style="list-style-type: disc">For destroying (deleting) the note</li></ul></div><p>At first, none of this is terribly difficult, and really, it isn't. But the way the File APIs are implemented, it does take a bit of work to get right.</p><p>Let's move on to the file view<a id="id268" class="indexterm"/>, seen in the following screenshot:</p><div><img src="img/9403_03_02.jpg" alt="Getting on with it"/></div><p>This view is pretty simple: it displays the contents of the note and allows the user to edit it. Notice that <a id="id269" class="indexterm"/>there's no <strong>Save</strong> button; the idea is that the notes will save themselves automatically.</p><p>When the view first appears, the keyboard won't be visible. This allows the user to see the note fill the screen. Once the note is tapped, however, the keyboard will appear, and the user will be able to change the note to their desire.</p><p>Now that we've created the wireframes, let's go into our graphics program and create our resources. <a id="id270" class="indexterm"/>Here's what we came up with:</p><div><img src="img/9403_03_03.jpg" alt="Getting on with it"/></div><p>We'll take most of the interface here as images<a id="id271" class="indexterm"/>, the icons<a id="id272" class="indexterm"/>, the large paper image<a id="id273" class="indexterm"/>, and the navigation bar<a id="id274" class="indexterm"/> and view background itself as well. For Android, only the icons and the paper image matter; the latter two are for iOS only.</p><p>The icons themselves are obtainable from App-Bits<a id="id275" class="indexterm"/> for free (<a class="ulink" href="http://app-bits.com/free-icons.html">http://app-bits.com/free-icons.html</a>), and the background texture is from Subtle Patterns<a id="id276" class="indexterm"/>, again for free (<a class="ulink" href="http://subtlepatterns.com">http://subtlepatterns.com</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>What did we do?</h2></div></div></div><p>In this task, we created the desired look and feel, and generated the necessary resources for our app.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Designing the data model</h1></div></div></div><p>Go ahead<a id="id277" class="indexterm"/> and get your paper and pencil out again. We need to design <a id="id278" class="indexterm"/>the data model for the app. We'll have two portions: one to manage the list of available documents, and another to manage a single document.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>Getting on with it</h2></div></div></div><p>Here's what our model looks like:</p><div><img src="img/9403_03_04.jpg" alt="Getting on with it"/></div><p>The first model, named <strong>FilerDocuments,</strong>
<a id="id279" class="indexterm"/> is responsible for managing all the files available to the app, while the one on the right, named <strong>FilerDocument</strong>, is responsible only for a single note. The latter is responsible for loading a note and saving a note, while the former is responsible for reading an entire directory of notes and then managing them via renames, copies, and deletes.</p><p>A few notes of interest before<a id="id280" class="indexterm"/> we wrap this task up. Notice all methods that end with <code class="literal">…Success</code>. This is simply due to the way the File API is structured; everything is done asynchronously so you have to write each call to it with callbacks to both a <code class="literal">success</code> and a <code class="literal">failure</code> function. The <code class="literal">success</code> function points at the corresponding <code class="literal">Success</code> method<a id="id281" class="indexterm"/>, while the <code class="literal">failure</code> function<a id="id282" class="indexterm"/> points at the generic <code class="literal">dispatchFailure</code> method<a id="id283" class="indexterm"/>. (Failures are pretty generic; we want to log the failure, whereas successes may require additional steps to complete an operation.)</p><p>The <code class="literal">fileSystem</code>
<a id="id284" class="indexterm"/> and <code class="literal">fileEntry</code> properties<a id="id285" class="indexterm"/> are also related to the File API. The <code class="literal">fileEntry</code> property is a pointer to a specific file, while the <code class="literal">fileSystem</code> property is a pointer to a specific directory on the device. (PhoneGap lets you specify if the directory should be a persistent one or a temporary one; we're using persistent.)</p><p>On the second model, note the title and text properties as well as the associated <code class="literal">get</code>/<code class="literal">set</code> methods. This is the actual data of a single note; everything else was simply to manage it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>What did we do?</h2></div></div></div><p>We created our data model for the document manager and a single note. In the next task, we'll implement both.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Implementing the data models</h1></div></div></div><p>At this <a id="id286" class="indexterm"/>point you <a id="id287" class="indexterm"/>should have your project already created. We're going to be creating two models under the <code class="literal">www/models</code> directory, named <code class="literal">filerDocuments.js</code> and <code class="literal">filerDocument.js</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>Getting on with it</h2></div></div></div><p>Let's get started by working on the <a id="id288" class="indexterm"/>Documents model that manages all the available documents:</p><div><pre class="programlisting">var DOCS = DOCS || {};

DOCS.Filers = function ( completion, failure )
{
    var self = this;</pre></div><p>This is the beginning of our constructor for the <code class="literal">Filers</code> object. The <code class="literal">completion</code>
<a id="id289" class="indexterm"/> and <code class="literal">failure</code> variables<a id="id290" class="indexterm"/> are passed in because at the end of the constructor we will kick off a directory read operation and we want to alert the application when we're finished (or we get an error).</p><div><pre class="programlisting">    self.state = "";</pre></div><p>The <code class="literal">state</code> property<a id="id291" class="indexterm"/> will store the current progress of an operation, which should make it easier to debug if an operation fails.</p><div><pre class="programlisting">    self.completion = completion;</pre></div><p>The <code class="literal">completion</code> function<a id="id292" class="indexterm"/> here initially receives the completion but it also stores the <code class="literal">completion</code> function used by other functions within the object. This is because an operation may take several steps, each requiring an interim <code class="literal">completion</code> method. This just happens to be one from the app, not from within our object.</p><div><pre class="programlisting">    self.documents = [];</pre></div><p>The <code class="literal">documents</code> property<a id="id293" class="indexterm"/> stores the information received from the filesystem on each file we can read. It's not the actual document.</p><div><pre class="programlisting">    self.fileSystem = {};</pre></div><p>The <code class="literal">fileSystem</code> property<a id="id294" class="indexterm"/> points at the persistent storage on the device. Most operations begin by asking for a filesystem, and we can speed it up by saving it the first time we ask. Then other operations can use our cached value.</p><div><pre class="programlisting">    self.failure = failure;</pre></div><p>Just like <code class="literal">completion</code>, this is the <code class="literal">failure</code> function. <code class="literal">dispatchFailure()</code>
<a id="id295" class="indexterm"/> will be called first, which then calls this one, if it is non-null.</p><div><pre class="programlisting">    self.fileEntry = {};</pre></div><p>For some of our operations, we have to store the information about a specific file; we do that using the <code class="literal">fileEntry</code> property<a id="id296" class="indexterm"/>.</p><div><pre class="programlisting">    self.loadFileSystem = function ( completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.getFileSystem();
    }</pre></div><p>The <code class="literal">loadFileSystem()</code> function<a id="id297" class="indexterm"/> can be called by the app at any time, but it is usually called when the app suspects that the documents available to us have changed. Say there may be a new one <a id="id298" class="indexterm"/>out there, and we want to be sure to display it to the user. Most of the operations in this class will try to re-read the directory after an operation (like renaming a file), but not every operation supports this, and this doesn't stop documents from appearing that we didn't explicitly create (say, from an iTunes import).</p><div><pre class="programlisting">    self.getFileSystem = function()
    {
        self.state = "Requesting File System";
        window.requestFileSystem ( LocalFileSystem.PERSISTENT, 0, self.getFileSystemSuccess, self.dispatchFailure );
    }</pre></div><p>The <code class="literal">getFilesystem()</code> function<a id="id299" class="indexterm"/> does the first thing we have to do when asking to see what files we have available to us: requests the filesystem. In this case, we're asking for the persistent filesystem so that the data is stored permanently.</p><div><pre class="programlisting">    self.dispatchFailure = function ( e )
    {
        console.log ("While " + self.State + ", encountered error: " + JSON.stringify(e));
        if (self.failure)
        {
            self.failure ( e );
        }
    }</pre></div><p>Generally, I like to keep <code class="literal">success</code>/<code class="literal">failure</code> methods<a id="id300" class="indexterm"/> close to the invoking method, but failures can be handled pretty generically (in our case), and so I just have one <code class="literal">failure</code> function that all our operations can call. It records a nice log message for us, and then checks to see if the app has registered a failure callback, and if it has, we'll call it too.</p><div><pre class="programlisting">    self.getFileSystemSuccess = function ( fileSystem )
    {
        self.state = "Received File System";
        self.fileSystem = fileSystem;
        self.getDocuments ( fileSystem.root );
    }</pre></div><p>When we're in the preceding function, we've got a valid filesystem. We save it for later use, and then we also call <code class="literal">getDocuments()</code>
<a id="id301" class="indexterm"/> to start the process of getting every document our app can access.</p><div><pre class="programlisting">    self.getDocuments = function ( directoryEntry )
    {
        self.state = "Requesting Reader";
        var directoryReader = directoryEntry.createReader();
        
        self.state = "Requesting Entries from Reader";
        directoryReader.readEntries ( 
          self.getDocumentsSuccess, self.dispatchFailure );
    }</pre></div><p>In order to go over every entry in the directory of the filesystem we've got, we have to create a directory<a id="id302" class="indexterm"/> reader. We can do this by using the <code class="literal">directoryEntry</code> function<a id="id303" class="indexterm"/> passed to us (which is pointing to the filesystem we requested). Once we have that, we ask it to read all the entries and call <code class="literal">getDocumentsSuccess()</code>
<a id="id304" class="indexterm"/> when it is finished.</p><div><pre class="programlisting">    self.getDocumentsSuccess = function ( entries )
    {
        var theDocuments = [];
        for (var i=0; i&lt;entries.length; i++)
        {
            // is the entry a file? (we won't iterate subdirs)
            if (entries[i].isFile)
            {
                var theFileName = entries[i].name;
                var theFileType = 
                  theFileName.substr(theFileName.length-4,4);
                if (theFileType === ".fln")
                {
                    // a file we know we can process
                    theDocuments.push ( entries[i] );
            }
            }
        }
        self.documents = theDocuments;
        self.state = "";
        if (self.completion)
        {
            self.completion ( self );
        }
    }</pre></div><p>In the preceding function, we read through all the entries given to us. One should never assume that all the entries in a directory are something that our app can handle, so we screen for subdirectories (which we won't be creating, so it won't be anything we can deal with), and then we also check for the file extension. If it is <code class="literal">.fln</code>, we assume the file is one of ours and add it to the list. If it has anything else, we ignore it.</p><p>Once we're done iterating over the list, we call the <code class="literal">completion</code> method<a id="id305" class="indexterm"/> (if it exists) so that the app can do what it wants with the list.</p><div><pre class="programlisting">    self.getDocumentCount = function ()
    {
        return self.documents.length;
    }
    
    self.getDocumentAtIndex = function ( idx )
    {
        return self.documents[ idx ];
    }</pre></div><p>The prior two methods are pretty self-explanatory. The first returns the number of documents we<a id="id306" class="indexterm"/> were able to get from the directory, and the second returns the information obtained for a specific document.</p><div><pre class="programlisting">    self.deleteDocumentAtIndex = function ( idx, completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Removing a Document";
        self.documents [ idx ].remove ( 
             self.deleteDocumentAtIndexSuccess, 
             self.dispatchFailure);
    }</pre></div><p>This method isn't playing games; it'll physically remove the document at the specified index. Our app will ask the user first if they'd like to remove the document, so that it can't be accidentally called, but this function won't ask anyone if it is okay on its own. So be careful when calling it.</p><div><pre class="programlisting">    self.deleteDocumentAtIndexSuccess = function ()
    {
        self.state = "";
        self.getFileSystem();
    }</pre></div><p>After a successful delete, we need to re-read the filesystem so that our <code class="literal">documents</code> array is up-to-date. We do this by calling <code class="literal">getFileSystem()</code>. You may wonder how the <code class="literal">completion</code> method defined in <code class="literal">deleteDocumentAtIndex</code>
<a id="id307" class="indexterm"/> gets called, though. It gets called at the end of <code class="literal">getFileSystem()</code>. It checks to see if the <code class="literal">completion</code> property has been set (which we do at the beginning of <code class="literal">deleteDocumentAtIndex</code>), and if it has, it calls it. This is a pattern a lot of our operations will follow.</p><div><pre class="programlisting">    self.renameDocumentAtIndexTo = function ( idx, newName, 
       completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Renaming a Document";
        self.documents [ idx ].moveTo ( 
             self.fileSystem.root, newName, 
             self.renameDocumentAtIndexToSuccess, 
             self.dispatchFailure);
    }
    
    self.renameDocumentAtIndexToSuccess = function ()
    {
        self.state = "";
        self.getFileSystem();
    }</pre></div><p>Renaming a<a id="id308" class="indexterm"/> document is simply a <code class="literal">moveTo</code> operation to the same directory. It follows the same pattern of operation as the preceding <code class="literal">delete</code> operation. Note that there is no check here for the new name of the file for if it isn't already being used by an existing file. If there is a name conflict, the new file will overwrite the old file, not likely something you want to occur. Since the preceding <code class="literal">deletion</code> method doesn't ask, we won't ask here either, but it is something you should do in the app itself.</p><div><pre class="programlisting">    self.copyDocumentAtIndexTo = function ( idx, newName, 
      completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Duplicating a Document";
        self.documents [ idx ].copyTo ( self.fileSystem.root, 
          newName, self.copyDocumentAtIndexToSuccess, 
          self.dispatchFailure);
    }
    self.copyDocumentAtIndexToSuccess = function ()
    {
        self.state = "";
        self.getFileSystem();
    }</pre></div><p>Copying is again remarkably similar to renaming, as seen in the prior code; the difference is that we use <code class="literal">copyTo</code> instead of <code class="literal">moveTo</code>. The operation is also a bit different; if you were to try to copy over an existing document, the attempt fails, unlike moving over an existing document.</p><div><pre class="programlisting">    self.createDocument = function ( theDocumentName, 
      completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Creating a Document";
        self.fileSystem.root.getFile ( theDocumentName, 
          {create: true, exclusive: false},
                function ( theFileEntry )
                    {
                        self.fileEntry = theFileEntry;
                        self.state = "";
                        self.getFileSystem();
                     }, self.dispatchFailure );
    }</pre></div><p>The <code class="literal">createDocument()</code> method<a id="id309" class="indexterm"/> creates a new file in the directory and after it does so, it re-reads the filesystem. <a id="id310" class="indexterm"/>This demonstrates an alternative to using <code class="literal">…Success()</code> methods. It works just the same, though. Just like renaming, this can be dangerous if a file with the same name already exists, so be sure to check before calling this method.</p><div><pre class="programlisting">    self.openDocumentAtIndex = function ( idx, completion, 
      failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Opening a Document";
        self.fileSystem.root.getFile ( 
           self.documents[idx].name, {create: false, 
             exclusive: false},
          function ( theFileEntry )
          {
            self.fileEntry = theFileEntry;
            self.state = "";
            self.getFileSystem();
            }, self.dispatchFailure );
    }</pre></div><p>As seen in the prior code, opening a document is very similar to creating a document, except we don't ask the filesystem to create it if it doesn't exist.</p><div><pre class="programlisting">    self.getFileEntry = function ()
    {
        return self.fileEntry;
    }</pre></div><p>Some operations, such as creating and opening a document, also set the <code class="literal">fileEntry</code> property to the newly opened document. This is handy for use when asking a note to open itself. It can read in contents of the file in this property.</p><div><pre class="programlisting">    self.getFileSystem ();
}</pre></div><p>As we mentioned prior to looking at the code for our model, we said that we'd initiate a directory read upon creation, and this is what we're doing at the end of the model. That way, when we create an object, it will instantly go to work reading the entries in the directory.</p><p>Now, let's look at the code for a single document:</p><div><pre class="programlisting">var DOC = DOC || {};

DOC.Filer = function ( theFileEntry, completion, failure )
{
    var self = this;
    
    // file and state
    self.fileEntry = theFileEntry;
    self.fileName = self.fileEntry.name;
    self.completion = completion;
    self.failure = failure;
    self.state = "";
    // file-specific
    self.title = "My Filer";
    self.text = "";

    self.getTitle = function ()
    {
        return self.title;
    }
    
    self.setTitle = function ( theTitle )
    {
        self.title = theTitle;
    }
    
    self.getText = function ()
    
        return self.text;
    }
    
    self.setText = function ( theText )
    {
        self.text = theText;
    }</pre></div><p>The preceding code <a id="id311" class="indexterm"/>should be self-explanatory now. Next up, in the following code, we see how to read the contents of a file:</p><div><pre class="programlisting">    self.readFileContents = function()
    {
        self.state = "Reading a File";
        self.fileEntry.file ( self.gotFile, self.dispatchFailure );
    }
    
    self.dispatchFailure = function( e )
    {
        console.log ("While " + self.State + ", encountered 
           error: " + e.target.error.code);
        if (self.failure)
        {
            self.failure ( e );
        }
    }</pre></div><p>When requesting <a id="id312" class="indexterm"/>to read a file, we have to call the <code class="literal">file()</code> method<a id="id313" class="indexterm"/> of the file's corresponding <code class="literal">fileEntry</code>. If it finds the file, it'll call <code class="literal">gotFile()</code>
<a id="id314" class="indexterm"/>, but if it can't read it, for some reason, it'll call <code class="literal">dispatchFailure()</code>.<a id="id315" class="indexterm"/>
</p><div><pre class="programlisting">    self.gotFile = function ( theFile )
    {
        var reader = new FileReader ();
        reader.onloadend = self.finishedReadingFile;
        reader.onloaderror = self.dispatchFailure;
        reader.readAsText ( theFile );
    }</pre></div><p>Once we've got the file, we have to create a <code class="literal">FileReader</code> variable<a id="id316" class="indexterm"/> for it. Unlike other API calls, we have to set up some event handlers, but they mean the same thing here as <code class="literal">completion</code> and <code class="literal">failure</code>. Then we ask the reader to read the file.</p><div><pre class="programlisting">    self.finishedReadingFile = function ( e )
    {
        var theFileContents = e.target.result;</pre></div><p>Once we are here, <code class="literal">e.target.result</code> has the contents of the entire file. Now we can try to load it in.</p><div><pre class="programlisting">        if (!theFileContents)
        {
            theFileContents = '{"title":"New 
              File","text":""}';
        }</pre></div><p>If there's nothing in the file, we set up some reasonable defaults. Notice that we're using <code class="literal">JSON</code> here. This is because we'll be storing our file in the <code class="literal">JSON</code> file format.</p><p>Next, we try to parse the contents of the file as <code class="literal">JSON</code>. This is where the <code class="literal">try/catch</code> block comes in. If we<a id="id317" class="indexterm"/> can't parse the contents of the file, we'll get an error and we can call the <code class="literal">failure</code> function. But if we do parse it correctly, we can set our own <code class="literal">title</code> and <code class="literal">text</code> to the file's <code class="literal">title</code> and <code class="literal">text</code>, and we'll have successfully loaded the file's contents.</p><div><pre class="programlisting">    self.saveFileContents = function ( completion , failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.fileEntry.createWriter ( self.gotFileWriter, 
            self.dispatchFailure );
    }
    self.gotFileWriter = function ( writer )
    {
        writer.onerror = self.failure;
        writer.onwriteend = function ( e )
            {
                if (self.completion)
                    {
                        self.completion();
                    }
            };
        writer.write ( JSON.stringify ( self.serialize() ) );
    }</pre></div><p>Saving a file isn't terribly different than loading a file, except that we can create the file writer directly from the <code class="literal">fileEntry</code> property rather than calling <code class="literal">file()</code> first. In <code class="literal">gotFileWriter</code>
<a id="id318" class="indexterm"/>, though, we have to set similar events before calling <code class="literal">write()</code> with the file contents. We <code class="literal">stringify</code> the results of <code class="literal">serialize()</code>
<a id="id319" class="indexterm"/> so that it is in a proper <code class="literal">JSON</code> format.</p><div><pre class="programlisting">    self.serialize = function ()
    {
        return { "title": self.title, "text": self.text };
    }</pre></div><p>Speaking of serialization, here's the method that does it. Not hard, but you may be asking why we didn't just stringify <code class="literal">self</code>. And that's a great question. Turns out you can't stringify objects<a id="id320" class="indexterm"/> that contain methods, because it will lose those methods; so that's one reason. Another reason is that we really don't need to save the entire object, just the title and the text; so instead of saving a lot of stuff we don't need, we'll just return an object that has exactly what we need.</p><div><pre class="programlisting">    self.readFileContents();
}</pre></div><p>Like our first model, we ask the document here to load its file contents immediately upon creation.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>What did we do?</h2></div></div></div><p>In this section, we created two data models, one for the list of available documents in a directory, and the second for the actual note itself.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec72"/>What else do I need to know?</h2></div></div></div><p>The File API is notoriously hard to get used to, especially for programmers who assume that the order of processing is always the next statement after this one. The File API, however, does things differently, by requiring each operation to have a <code class="literal">success</code> and <code class="literal">failure</code> callback. Furthermore, there are several operations when reading or saving a file (or when reading a directory), and as such the callback chain can start to get pretty confusing. This is generally why I try to make separate functions instead of inline callbacks, but there are times when inline callbacks make the most sense.</p><p>The File API<a id="id321" class="indexterm"/> can do more than what we've covered here, so you'd do well to go take a look at it at <a class="ulink" href="http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File">http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File</a>. Just remember how the callbacks work and you'll be fine, even if your code will feel a bit spaghetti-ish.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Implementing documents view</h1></div></div></div><p>The documents view <a id="id322" class="indexterm"/>will be used to display the list of available documents to the end user. It will also permit the user to create a document, <a id="id323" class="indexterm"/>rename a document, copy a document, and delete a document.</p><p>Let's take a quick look at the finished product, on iOS first:</p><div><img src="img/9403_03_05.jpg" alt="Implementing documents view"/></div><p>For Android, the view will be as follows:</p><p> </p><div><img src="img/9403_03_06.jpg" alt="Implementing documents view"/></div><p>
</p><p>Notice that the <a id="id324" class="indexterm"/>screenshot for the iPhone has a totally different look and feel than the Android screenshot. <a id="id325" class="indexterm"/>While many apps for the iPhone use the alternative method used for Android, the method of scrolling horizontally through large document representations is more common on the iPhone, and is what we use here. Thankfully, it only takes a small code change and some CSS to render the two disparate looks. Otherwise, they function identically.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec73"/>Getting on with it</h2></div></div></div><p>As always, we're going to start with the HTML portion of the view. The boilerplate portion is virtually identical to our previous apps, so we'll start with the template instead:</p><div><pre class="programlisting">&lt;div id="documentsView_documentTemplate" class="hidden"&gt;
    &lt;div class="documentContainer"&gt;
        &lt;div class="documentImage"&gt;
            &lt;img src="img/DocumentImage.png" border=0 onclick="documentsView.openDocument(%INDEX%)"/&gt;
        &lt;/div&gt;
        &lt;div class="documentTitle" onclick="documentsView.renameDocument(%INDEX%)"&gt;
            &lt;span &gt;%TITLE%&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="documentActions"&gt;
            &lt;img src="img/Copy.png" width=28 height=28 border=0 onclick="documentsView.copyDocument(%INDEX%)" /&gt;
            &lt;img src="img/Share.png" width=27 height=28  border=0 onclick="documentsView.shareDocument(%INDEX%)" /&gt;
            &lt;img src="img/Trash.png" width=28 height=28  border=0 onclick="documentsView.deleteDocument(%INDEX%)" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This <a id="id326" class="indexterm"/>template defines the HTML for each document we display. It's not terribly complicated. <a id="id327" class="indexterm"/>Note that we have <code class="literal">onClick</code> handlers for each portion of the template that can respond to touch, but beyond that the style is controlled in <code class="literal">style.css</code>.</p><p>Let's take a look at the code that powers this view:</p><div><pre class="programlisting">  var documentsView = $ge("documentsView") || {};
  documentsView.lastScrollLeft = 0;
  documentsView.myScroll = {};
  documentsView.availableDocuments = {};</pre></div><p>First up, our properties. <code class="literal">lastScrollLeft</code> is for maintaining our scroll position when we switch between views. <code class="literal">myScroll</code> will hold our scroller (for iOS and Android), and <code class="literal">availableDocuments</code> will hold all the documents the filesystem has for our app.</p><p>The <code class="literal">initializeView()</code> method<a id="id328" class="indexterm"/> is so similar to our previous projects (refer to the <em>Implementing the start view</em> section of <a class="link" href="ch01.html" title="Chapter 1. Let's Get Local!">Project 1</a>, <em>Let's Get Local!</em>), I'll go ahead and skip it and jump to <code class="literal">displayAvailableDocuments()</code>
<a id="id329" class="indexterm"/> (which the <code class="literal">initializeView()</code> method does call).</p><div><pre class="programlisting">  documentsView.displayAvailableDocuments = function ()
  {
    
    documentsView.availableDocuments = new DOCS.Filers (
        documentsView.documentIterator
        ,
        function () // failure function
        {
            var anAlert = new PKUI.MESSAGE.Alert 
              (__T("Oops!"),
                __T("I couldn't read your persistent 
                      storage!"));
            anAlert.show();
        }
    );
    
  }</pre></div><p>First, we create a new <code class="literal">DOCS.Filers</code> object. Remember that this will immediately send a request to the filesystem for all the files it contains that we can use. When it successfully completes that request, it will call <code class="literal">documentsView.documentIterator()</code>,<a id="id330" class="indexterm"/> a method that will go over each item in the list and render the preceding template. If it fails, however, it calls the <code class="literal">failure</code> function defined earlier and displays an alert message.</p><p>This is big; we're <a id="id331" class="indexterm"/>no longer using the in-built <code class="literal">alert()</code> method! Instead, we're creating a new <code class="literal">Alert</code> object with the title of <code class="literal">Oops!</code> and <code class="literal">I couldn't read your persistent storage!</code> Granted, not the best error message in the world, but if<a id="id332" class="indexterm"/> this does occur, we're essentially toast anyway. The bigger issue is that this object, which we'll cover in more detail as we progress through this task, provides us with platform-specific non-native alerts. This means we can customize them to our needs; in this case that isn't much, we're displaying an error message, but the <code class="literal">PKUI.MESSAGE</code> namespace provides options for prompts as well. The <code class="literal">Alert</code> object also gives us the ability to specify a callback when a button is pressed, very useful if we need to ask a Yes/No question.</p><p>The next method, <code class="literal">reloadAvailableDocuments()</code>,<a id="id333" class="indexterm"/> is so similar to the earlier method that I'll also skip it. It's only used when the file view is being popped off the view stack.</p><div><pre class="programlisting">  documentsView.documentIterator = function ( o )
    {
        var theHTML = "";
        var theNumberOfDocuments = 0;
        for (var i=0; i&lt;o.getDocumentCount(); i++)
        {
            var theDocumentEntry = o.getDocumentAtIndex ( i );
            
            theHTML += PKUTIL.instanceOfTemplate ( 
                       $ge("documentsView_documentTemplate"),
                        { "title": 
                         theDocumentEntry.name.substr(0, 
                         theDocumentEntry.name.length-4),
                         "index": i
                       }
                       );
          theNumberOfDocuments++;
        }
        if (PKDEVICE.platform()=="ios")
        {
            $ge("documentsView_contentArea").style.width = 
                (((theNumberOfDocuments) * 246)) + "px";
        }
        
        $ge("documentsView_contentArea").innerHTML = theHTML;
    }</pre></div><p>This is a pretty simple function: all we do is iterate through the documents that are returned from the filesystem and create a new instance of the <code class="literal">documentsView_documentTemplate</code> template<a id="id334" class="indexterm"/>. We're using a new convenience method called <code class="literal">PKUTIL.instanceOfTemplate()</code>
<a id="id335" class="indexterm"/> to make this easier. It will take a DOM element and an object containing the properties that should be replaced, in this case, <code class="literal">title</code> and <code class="literal">index</code>, along with their corresponding values. (The <code class="literal">substr()</code> method<a id="id336" class="indexterm"/> is used to chop off the file extension.)</p><p>This method is<a id="id337" class="indexterm"/> doing the same thing we were doing manually before, using <code class="literal">replace()</code>, but it does it better. If you hadn't noticed, we were <a id="id338" class="indexterm"/>cleverly avoiding using the same substitution variable in our templates more than once. This is because <code class="literal">replace()</code> only replaces one instance at a time. Our convenience method keeps calling <code class="literal">replace()</code> until all instances are replaced, which means we can now use <code class="literal">%TITLE%</code> and <code class="literal">%INDEX%</code> all we want.</p><p>The portion of code specific to iOS simply determines the width of the content area for scrolling purposes. For Android, this code isn't executed.</p><div><pre class="programlisting">  documentsView.openDocument = function ( idx )
  {
        documentsView.availableDocuments.openDocumentAtIndex
            ( idx,
              function ()
              {
                fileView.setFileEntry ( documentsView.
                    availableDocuments.getFileEntry() );
                PKUI.CORE.pushView ( fileView );
              },
              function (e) { console.log (JSON.stringify(e)) 
                         }
            );
  }</pre></div><p>Opening a document occurs when a user taps on the document's icon. (For Android, this is something you should think about changing, but for the purposes of this app, we'll keep consistent).</p><p>We call <code class="literal">openDocumentAtIndex()</code>
<a id="id339" class="indexterm"/> and pass along the <code class="literal">completion</code> and <code class="literal">failure</code> functions that are called when the document is opened. The <code class="literal">success</code> method will set the <code class="literal">fileEntry</code> property of the <code class="literal">fileView</code> method<a id="id340" class="indexterm"/> and then push it on to the screen. This act will trigger loading the contents as well. Failure will log the error to the console, though you probably should add a meaningful error alert as well.</p><div><pre class="programlisting">  documentsView.createNewDocument = function ()
  {
    {
        var anAlert = new PKUI.MESSAGE.Prompt 
                    (__T("Create Document"),
                        __T("This will create a new document 
                             with the name below:"),
                        "text",
                         "New Filer " + __D(new Date(),
                             "yyyy-MM-dd-HH-mm-ss"),
                        __T("Don't Create&lt;|Create&gt;"),
                        function (i)
                        {
                          if (i===1)
                          {
                           documentsView.availableDocuments.
                           createDocument ( "" +
                            anAlert.inputElement.value+".fln",
                            function ()
                            {
                            fileView.setFileEntry ( 
                              documentsView.
                               availableDocuments.
                                getFileEntry() );
                            PKUI.CORE.pushView ( fileView );
                            },
                            function (e)
                            {
                            var anAlert = new 
                              PKUI.MESSAGE.Alert (
                               __T("Oops!"),
                                __T("Couldn't create the 
                                    file.") );
                             anAlert.show();
                            }
                          );
                        }
                      }
                    );
        anAlert.show();
    }
  }</pre></div><p>Welcome to the wonderful world of chaining callbacks! We have two steps to create a document. <a id="id341" class="indexterm"/>First, we ask the user what they want to name the document (using an admittedly obtuse default). Then we create the document, <a id="id342" class="indexterm"/>which means we have to have another success/failure callback. If we fail to create the document, we create another alert to further confuse matters.</p><p>The big deal, though, is that our initial request of the user is actually giving them a chance to type something in to our alert message! We've not done this yet in any of our apps, and this is monumental. Furthermore, we have custom buttons—a <code class="literal">Don't Create</code> button and a <code class="literal">Create</code> button.</p><p>If you're wondering what the <code class="literal">&lt;</code> and <code class="literal">&gt;</code> are in the preceding code attached to the buttons – great catch! <a id="id343" class="indexterm"/>These are used primarily for iOS, though you could extend these to the other platforms as well. iOS has the concept of a destructive <a id="id344" class="indexterm"/>action; these buttons should always be colored red. (Or, if the locale that you are targeting uses a different color, use that color instead.) It also has the concept of <strong>Cancel</strong> button colors (typically a darker gray). To add to it, we decided to color buttons that would go to the next step in the process green.</p><p>Each of these gets a special character at the end of the button's name. For example, <code class="literal">Cancel&lt;</code> would color the button a darker color and use the text of <code class="literal">Cancel</code> for the button. <code class="literal">Go&gt;</code> would use <code class="literal">Go</code> as the text, and color the button green. <code class="literal">Delete*</code>, on the other hand, would use <code class="literal">Delete</code> as the text, but color the button red.</p><p>Just so you have a good idea of what an alert/prompt will look like on each system, here's an example for iOS:</p><div><img src="img/9403_03_11.jpg" alt="Getting on with it"/></div><p>For Android, the view will be as follows:</p><div><img src="img/9403_03_12.jpg" alt="Getting on with it"/></div><p>Renaming a <a id="id345" class="indexterm"/>document is somewhat similar to creating a new document, except that we won't display <a id="id346" class="indexterm"/>the document at the end. We will ask the user what the new name should be, and if they choose to continue, we'll try to perform the function. The following code snippet can be used for this action:</p><div><pre class="programlisting">  documentsView.renameDocument = function ( idx )
  {
    var theFileName = documentsView.availableDocuments.
                    getDocumentAtIndex(idx).name;
    theFileName = theFileName.substr(0,theFileName.length-4);
    
    var anAlert = new PKUI.MESSAGE.Prompt (
                     __T("Rename Document"),
                        __T("Rename your document to the 
                             following:"),
                        "text",
                        theFileName,
                        __T("Cancel&lt;|Rename&gt;"),
                        function (i)
                        { 
                         if (i==1)
                         {
                          var theNewFileName = 
                         ""+anAlert.inputElement.value+".fln";
                          try {
                           documentsView.availableDocuments.
                           renameDocumentAtIndexTo
                           ( idx, theNewFileName,  
                             documentsView.documentIterator,
                             function ( e )
                            {
                             var anAlert = new 
                                  PKUI.MESSAGE.Alert 
                                  (__T("Oops!"),
                                    __T("Couldn't rename the 
                                        file.") );
                                    anAlert.show();
                            }
                           );
                          }
                        catch (e)
                          {
                           var anotherAlert = new 
                           PKUI.MESSAGE.Alert (
                               __T("Oops!"),
                               __T("Couldn't rename the 
                                    file.") );
                            anotherAlert.show();
                            }
                         }
                        }
                       );
    anAlert.show();
  }</pre></div><p>If there is a failure of some sort, we'll indicate this by displaying an error, once as a <code class="literal">failure</code> function, and second in the <code class="literal">catch</code> portion of the <code class="literal">try</code>/<code class="literal">catch</code> block.</p><p>Note that,<a id="id347" class="indexterm"/> as written, we make no check here to see if the new name would conflict with another file. Therefore, if the user renamed one file<a id="id348" class="indexterm"/> to the name of another, the previous file would be overwritten. You should add an additional check in your code to make sure that the new file name doesn't already exist.</p><p>The <code class="literal">copyDocument()</code> method<a id="id349" class="indexterm"/> is nearly identical, so we'll skip it and move on to the <code class="literal">deleteDocument()</code> method<a id="id350" class="indexterm"/> shown in the following code snippet:</p><div><pre class="programlisting">  documentsView.deleteDocument = function ( idx )
  {
    var anAlert = new PKUI.MESSAGE.Confirm (
                __T("Remove Document"),
                __T("This will remove the document. This 
                       action is unrecoverable."),
                  __T("Don't Remove&lt;|Remove*"),
                  function (i)
                  {
                  if (i==1)
                   {
                    documentsView.availableDocuments.
                    deleteDocumentAtIndex
                     ( idx, documentsView.documentIterator,
                      function (e)
                      {
                       var anAlert = new PKUI.MESSAGE.Alert 
                      (__T("Oops!"),
                          __T("Couldn't delete the file.") );
                      anAlert.show();
                      }
                    );
                  }
    );
    anAlert.show();
  }</pre></div><p>Deleting a document is much more simple than copying or renaming one, so we're not delving as deep <a id="id351" class="indexterm"/>in a callback chain here. The primary thing I wanted to point out was the use of the <code class="literal">*</code> to indicate that the <code class="literal">Remove</code> button would<a id="id352" class="indexterm"/> display as a red button to warn the user that it was a destructive action on iOS. Android silently ignores this flag, though you could modify the framework to display similar colors as well on Android</p><p>The remaining methods are similar to those in the previous views, so we'll go ahead and skip them.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec74"/>What did we do?</h2></div></div></div><p>Though there is a lot of room to improve, we've created a pretty good document manager for our app. We've permitted the user to rename their files, delete them, copy them, open them, and create them, all things a good file manager should do. The only thing we didn't do was permit the user to share them, though the intent is there with the pleasant <strong>Share</strong> icon. This was only in the interest of space, and because it is a subject that we've covered before.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec75"/>What else do I need to know?</h2></div></div></div><p>There are plenty of things we <em>haven't</em> covered in this file manager of ours, and they're big ones and definitely things you need to think about implementing on your own. The code itself would be self-explanatory, so we won't go into great detail, but here are the primary issues<a id="id353" class="indexterm"/>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Filenames can't contain certain characters: Everyone handles this somewhat differently; you could display an error to the user indicating that they need to pick different characters or you could silently change them to something else (typical for iOS). Either way, you should check for them prior to creating a new file or renaming/copying a document.</li><li class="listitem" style="list-style-type: disc">Create/Rename<a id="id354" class="indexterm"/> operations can overwrite existing data: You'd think that since a copy operation will fail if the destination file exists, that rename/create would also. Unfortunately, no. They'll just overwrite the file. You must iterate over the entire directory structure in order to determine if you're about to overwrite an existing file! Users don't like losing data, even if they themselves were the cause.</li><li class="listitem" style="list-style-type: disc">Opening a document for non-iOS users: Android users shouldn't need to know that tapping the icon will open the document; they'll assume the entire area is tappable (minus the icons). So it would be a good idea to give them another icon for renaming a file and allow the filename itself (as well as the document icon) to open the file instead of renaming the file.</li><li class="listitem" style="list-style-type: disc">iOS document images should reflect the contents of the file: This one's harder to implement, granted, but typically the document icon would contain some portion of the actual contents of the file. There are various ways of doing this, from reading the actual contents in and displaying them over the DOM (and clipping them after some portion) to rendering them to an HTML <code class="literal">canvas</code> tag and saving the result as a thumbnail. Either way, it's something the user will expect.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Implementing the file view</h1></div></div></div><p>This view is <a id="id355" class="indexterm"/>pretty easy; actually it's essentially a big <code class="literal">TEXTAREA</code> element with some <a id="id356" class="indexterm"/>code to automatically save the contents every few seconds. Let's take a look at how it will render on each platform, first for iOS:</p><div><img src="img/9403_03_08.jpg" alt="Implementing the file view"/></div><p>For Android<a id="id357" class="indexterm"/>, the view will be as follows:</p><div><img src="img/9403_03_09.jpg" alt="Implementing the file view"/></div><p>All of these look<a id="id358" class="indexterm"/> pretty similar and reflect the simplicity of the view.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>Getting on with it</h2></div></div></div><p>The HTML portion <a id="id359" class="indexterm"/>of the view is much like prior views, so we'll skip that for now. Just know that there is a <code class="literal">TEXTAREA</code> element named <code class="literal">fileView_text</code>
<a id="id360" class="indexterm"/> that <a id="id361" class="indexterm"/>our code will reference. There is also an <code class="literal">onClick</code> handler<a id="id362" class="indexterm"/> on the title bar to enable changing the title of the note. These are seen in the following code snippet:</p><div><pre class="programlisting">  var fileView = $ge("fileView") || {};
  
  fileView.theFileEntry = {};
  fileView.theFilerDocument = {};
  fileView.theSaveTimer = -1;</pre></div><p>As always, we have several properties. The first is intended to store information about the file we're currently working on, while the second is the actual document contents. The last property will store a value returned by <a id="id363" class="indexterm"/>
<code class="literal">setInterval()</code>, this is used to call our auto-save functionality every few seconds.</p><div><pre class="programlisting">  fileView.setFileEntry = function ( theNewFileEntry )
  {
      fileView.theFileEntry = theNewFileEntry;
      fileView.theFilerDocument = {};
  }</pre></div><p>Here we just provide a way for the <code class="literal">documentView</code> method<a id="id364" class="indexterm"/> to tell us which file to work with.</p><p>The next method, <code class="literal">initializeView()</code>,<a id="id365" class="indexterm"/> is similar enough to the other views that we'll skip over it. Next up is <code class="literal">entitleDocument()</code>
<a id="id366" class="indexterm"/> shown in the following code snippet:</p><div><pre class="programlisting">  fileView.entitleDocument = function ()
  {
    var anAlert = new PKUI.MESSAGE.Prompt (
                        __T("Entitle"),
                      __T("What's the title of this document?"),
                      "text",
                    fileView.theFilerDocument.getTitle(),
                    __T("Cancel&lt;|Entitle&gt;"),
                    function (i)
                    { 
                     if (i==1)
                     {
                      fileView.theFilerDocument.setTitle (
                        anAlert.inputElement.value );
                      fileView.viewTitle.innerHTML = 
                      fileView.theFilerDocument.getTitle();
                     }
                    }
                   );
    anAlert.show();
  }</pre></div><p>When the title is tapped, we'll display a prompt to the user that enables them to change the title of the note.</p><div><pre class="programlisting">  fileView.loadDocument = function ()
  {
    fileView.viewTitle = $ge("fileView_title");
    fileView.viewTitle.innerHTML = fileView.theFileEntry.name.substr(0,fileView.theFileEntry.name.length-4);
    fileView.theTextElement = $ge("fileView_text");
    fileView.theTextElement.value = "";
    
    fileView.theFilerDocument = new DOC.Filer (fileView.theFileEntry,function ()
            {
                 fileView.viewTitle.innerHTML = fileView.theFilerDocument.getTitle();
                 fileView.theTextElement.value = fileView.theFilerDocument.getText();
                 fileView.theSaveTimer = setInterval ( 
                 fileView.saveDocument, 5000 );
             },
                 function (e)
                 {
                 PKUI.CORE.popView();
                 var anAlert = new PKUI.MESSAGE.Alert 
                 (__T("Oops!"),
                 __T("Couldn't open the file.") );
                 anAlert.show();
                 }
                 );
  }</pre></div><p>Loading the contents <a id="id367" class="indexterm"/>of a specific document is accomplished by <a id="id368" class="indexterm"/>creating a new <code class="literal">DOC.Filer() </code>object using the contents of our <code class="literal">fileEntry</code> property. This is assumed to have been set by <code class="literal">documentView</code> prior to pushing us onto the view stack.</p><p>Upon successfully parsing the document, we set the navigation bar's title to the document's title, and the <code class="literal">TEXTAREA</code> element's contents to the note's text. Then we set up the auto-save at an interval of five seconds.</p><p>If, for some reason, we can't open the file, we'll display an error, but we'll also pop ourselves off the view stack. No sense in displaying an editor if we can't even open the file.</p><div><pre class="programlisting">  fileView.saveDocument = function ()
  {
      fileView.theFilerDocument.setText ( fileView.theTextElement.value );
      fileView.theFilerDocument.saveFileContents (
      function ()
      {
       console.log ("Auto save successful.");
       },
       function (e)
       {
       PKUI.CORE.popView();
       var anAlert = new PKUI.MESSAGE.Alert (
                             __T("Oops!"),
                        __T("Couldn't save to the file.") );
        anAlert.show();
       }
      );
  }</pre></div><p>Saving the contents is a simple affair. We copy the text from the <code class="literal">TEXTAREA</code> element and put in the <code class="literal">Filer</code> object. <a id="id369" class="indexterm"/>Then we ask it to save the contents of the file. If it is successful, we just log a <a id="id370" class="indexterm"/>message to the console (something you'd remove in a production app), and if it isn't, we display an error and pop the view. (Whether popping the view is a good idea or not is debatable.)</p><div><pre class="programlisting">  fileView.viewWillAppear = function ()
  {
    
    fileView.loadDocument();
  }</pre></div><p>Our <code class="literal">viewWillAppear()</code> method<a id="id371" class="indexterm"/> is pretty simple: we kick off a load of our note. This means that by setting <code class="literal">fileEntry</code> and pushing us on the view stack, we'll automatically load the contents of the note.</p><div><pre class="programlisting">  fileView.viewWillHide = function ()
  {
    if (fileView.theSaveTimer!==-1)
    {
        clearInterval (fileView.theSaveTimer);
        fileView.theSaveTimer = -1;
    }
    fileView.saveDocument();
    documentsView.reloadAvailableDocuments();
  }</pre></div><p>Our <code class="literal">viewWillHide()</code> method<a id="id372" class="indexterm"/> is a little more complex. Here we disable our auto-save. After all, we don't want to be saving a document that is no longer open. Then we force-save the document. Perhaps the user is navigating back in between an auto-save interval; they wouldn't want to lose any data, right?</p><p>After we save the contents, we also force the <code class="literal">documentsView</code> method<a id="id373" class="indexterm"/> to reload the list of documents. This<a id="id374" class="indexterm"/> isn't a big deal when we're-editing existing documents, but it is a big deal when we're creating new documents, as we want the file manager to be able to display our newly created note.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>What did we do?</h2></div></div></div><p>We created a simple text editor view that can open file contents and save them back again. It implements a simple auto-save function as well.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>What else do I need to know?</h2></div></div></div><p>Most of the devices that you will be targeting use soft keyboards for input. This means that some portion of the screen will be covered by the onscreen keyboard.</p><p>How each device <a id="id375" class="indexterm"/>does this differs by platform and type of keyboard. For example, Android permits many different keyboards to be installed, and not every keyboard does things the same way.</p><p>Essentially, though, what happens is the available real-estate is moved or resized to permit the onscreen keyboard. This means our user interface also moves along with the keyboard. Whether or not this is done fluidly depends on the platform (and on Android, the keyboard itself, to some extent). iOS does this the best; there's a minimum of fuss involved, and the display scrolls neatly to ensure the text remains on the screen.</p><p>Android has a tendency to flicker a bit while they do this, unfortunately, and there's very little we can do to control how the keyboard itself appears.</p><p>One interesting option would be to implement the soft keyboard ourselves in pure HTML, CSS, and JavaScript. Technically this can work, but it remains a pretty large hack, and your soft keyboard won't really ever act like the legitimate keyboard on the platform. (And on Android, fans of a particular keyboard configuration will instantly hate it.) You'd also have to take into account the case when a user has connected a Bluetooth keyboard. This typically prevents the soft keyboard from appearing, which means the full real-estate of the screen is used for our display. Since there's no way (short of developing our own plugin) to determine if a hard keyboard is attached, we highly advise against using this option.</p><p>Some Android distributions also add an interesting quirk. It appears that <code class="literal">input</code> and <code class="literal">textarea</code> elements actually display another editable region above themselves when being edited. On my phone, this was visible by having a portion of the flashing cursor visible just underneath the current editor, almost as if the DOM element was just a mirror of a native input element. It wouldn't have been noticeable except for the fact that they were slightly misaligned. Odd, anyway, and I thought I would mention it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Game Over..... Wrapping it up</h1></div></div></div><p>We've accomplished <a id="id376" class="indexterm"/>quite a lot in this task and while none if it is particularly glorious, it is absolutely necessary for what's ahead. Our apps must be able to store data permanently and they must also be able to retrieve that same data. Likewise, they need to provide methods for managing that data, including renaming, duplicating, and deleting it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>There are several ways you can<a id="id377" class="indexterm"/> improve upon this app:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our app only asks the user if they really want to delete a file, but other operations are equally dangerous. Add in confirmations if the action the user is about to perform would overwrite data (for example, renaming a document to an existing document's name or creating a document with the same name as an existing document).</li><li class="listitem" style="list-style-type: disc">Add functionality to check if the filename a user is supplying is valid. Then, either indicate this to the user or silently change the invalid characters to valid characters.</li><li class="listitem" style="list-style-type: disc">We don't provide subdirectory functionality, but there's no reason why you couldn't. In fact, we explicitly ignore subdirectories in our code, as they add a lot of complexity to the file management system. Why don't you add subdirectory management to the app?</li><li class="listitem" style="list-style-type: disc">Instead of storing notes, perhaps you could store some forms instead. Perhaps simple addresses or reminders—really, just about anything.</li></ul></div></div></body></html>