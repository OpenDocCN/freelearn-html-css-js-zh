<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Application Implementation &#x2013; Putting It All Together"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Application Implementation – Putting It All Together</h1></div></div></div><p>After discussing the architectural concepts of our modular design in the previous chapter, it is time for us to look at the actual implementation.</p><p>The goal of this chapter is to examine the code and see how all the pieces fit and work together in a real application.</p><p>While we will not discuss every aspect of the code, each main piece will be broken down into smaller pieces, and most of the details will be explained.</p><p>I highly recommend that you download the project code related to this chapter from the site accompanying this book and follow along as we go through the finer points of the code. I am using different techniques at different parts of the code, which at first glance, might look inconsistent. However, this is done intentionally so that you can see how different techniques can be applied as needed, in different contexts.</p><p>Also, keep in mind that many aspects of the application can be improved upon as the focus has been on creating<a id="id369" class="indexterm"/> a <span class="strong"><strong>Proof Of Concept</strong></span> (<span class="strong"><strong>POC</strong></span>) application as opposed to production quality code. You will see how our modular approach allows us to create an easily maintainable, extensible, and robust application.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Look at the main modules in the application</li><li class="listitem" style="list-style-type: disc">Examine how components in the application have been constructed</li><li class="listitem" style="list-style-type: disc">Discuss the overall architecture of the application</li><li class="listitem" style="list-style-type: disc">Look at our publish-subscribe implementation, which provides loose coupling among our modules and components</li><li class="listitem" style="list-style-type: disc">Implement a simple client-side router</li></ul></div><p>But before examining the implementation, let's have a look at the final view of our application.</p><div class="section" title="The user's view of our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>The user's view of our application</h1></div></div></div><p>If you load <code class="literal">index.html</code> file of<a id="id370" class="indexterm"/> our project using an IDE which has a built-in web server, you will see the following main page in the browser. This file resides at the root of the application folder.</p><div class="mediaobject"><img src="graphics/B04910_08_01.jpg" alt="The user's view of our application"/></div><p>As you may have noticed, I have made improvements to the look and feel of the application, in comparison to what we had in the previous chapters. I have also done some re-factoring of the code in the project.</p><p>I mentioned previously that our application is somewhat responsive based on the browser's view-port. The following screenshot shows the application's <code class="literal">index.html</code> page in the Chrome Developer Tools emulator (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>M</em></span> in Windows), simulating its rendering in an Apple iPad:</p><div class="mediaobject"><img src="graphics/B04910_08_02.jpg" alt="The user's view of our application"/></div></div></div>
<div class="section" title="Application functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Application functionality</h1></div></div></div><p>As you may recall, our application<a id="id371" class="indexterm"/> was intended to be an image gallery-type application which displays a list of images. Users are able to interact with the application in a<a id="id372" class="indexterm"/> variety of different ways. While the application might seem very simple from a user's point of view, it is designed from the ground up, to be easily extensible, so more functionality can be added to it as needed.</p><p>Let's consider the various aspects of our application's functionality.</p><div class="section" title="Index page"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Index page</h2></div></div></div><p>The main page of the application (<code class="literal">index.html</code>) consists of three main components: <code class="literal">header</code>, <code class="literal">footer</code>, and <code class="literal">content</code>.</p><p>These components build the header, footer, and content sections (page fragments) of the main page respectively, as <a id="id373" class="indexterm"/>shown in the previous screenshot.</p><p>Since we designed our application as a <a id="id374" class="indexterm"/>
<span class="strong"><strong>Single Page Application</strong></span> (<span class="strong"><strong>SPA</strong></span>), navigation to different pages of the application only updates the view of the content area.</p><p>The footer and header sections of the application are rendered only once, and that is at the initial load time of <code class="literal">index.html</code>. The main advantage of our SPA design is that there is no need to fully re-render the page every time different pages are viewed. Therefore, there is no flickering of the page in the browser.</p><p>In the main page, users are able to see the full catalog of all the images available. By clicking on an image, the user can see its full-size. Images can also be added to, or removed from, the list of favorite images when the user clicks on the related link below each image.</p><p>Users are able to interact with the header and footer of the application too, even though, for our POC, not all the links in the footer and header are activated.</p></div><div class="section" title="Image page"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Image page</h2></div></div></div><p>When a user clicks on an<a id="id375" class="indexterm"/> image, the view of the content area of the application is changed to show the image in full view, as shown:</p><div class="mediaobject"><img src="graphics/B04910_08_03.jpg" alt="Image page"/></div><p>If you look at the<a id="id376" class="indexterm"/> address bar of the browser, the URL of the page changes when an image is clicked to reflect the ID of the image. For the preceding image, the URL of the page will be similar to:</p><p>
<code class="literal">http://127.0.0.1:49202/Image_9.jpg</code>
</p><p>This is the URL of your local server along with the image ID.</p></div><div class="section" title="Favorites page"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Favorites page</h2></div></div></div><p>In the main page of <a id="id377" class="indexterm"/>our application, a user can click on the link at the bottom of each image to add the image to the list of his/her favorite images, as shown:</p><div class="mediaobject"><img src="graphics/B04910_08_04.jpg" alt="Favorites page"/></div><p>Once <span class="strong"><strong>Add to Favorites</strong></span> link has been clicked, the text of the link changes to <span class="strong"><strong>Remove from Favorites</strong></span>, which enables the user to remove the image from the list of favorite images.</p><p>Users can also view<a id="id378" class="indexterm"/> all of their favorite images by clicking the <span class="strong"><strong>Favorites</strong></span> link in the header section of the page; which takes the user to the <span class="strong"><strong>Favorites</strong></span> page of the application, as displayed:</p><div class="mediaobject"><img src="graphics/B04910_08_05.jpg" alt="Favorites page"/></div></div><div class="section" title="Support widget"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Support widget</h2></div></div></div><p>When a user clicks on the <span class="strong"><strong>Support</strong></span> link in the footer section of the application, a dialog box will be displayed with information regarding the site's catalog.</p><p>This widget (the dialogue box) has been designed to be dynamically loaded, and rendered on the page, but only when<a id="id379" class="indexterm"/> the <span class="strong"><strong>Support</strong></span> link is clicked. This is an example of how components can be loaded and rendered dynamically in the application, as needed. This allows us to keep the weight of the application in the browser light and minimize its footprint.</p><p>The design of this widget also demonstrates the concept of plug-and-play in respect to dynamic components in the application.</p><p>The following screenshot shows how this widget is displayed in the browser:</p><div class="mediaobject"><img src="graphics/B04910_08_06.jpg" alt="Support widget"/></div><p>Now that we have had a look at the appearance of the application, it is time to examine the mechanics of its implementation and see how things are done under-the-hood.</p></div></div>
<div class="section" title="Application implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Application implementation</h1></div></div></div><p>From the beginning, our intent in<a id="id380" class="indexterm"/> the design of our application was to create <a id="id381" class="indexterm"/>a modularized ecosystem in which different pieces of the code (modules) would be joined together to create a fully functional application. To that end, our code has been structured as displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04910_08_07.jpg" alt="Application implementation"/></div><p>As you can see, our application has been organized into three main folders: <code class="literal">css</code> which hosts all of our styling files, <code class="literal">Images</code> which stores all the images in the application's catalog; and <code class="literal">js</code>, which<a id="id382" class="indexterm"/> contains all the JavaScript code for our application. As this structure is only one approach to organizing the application's code, you may decide to organize the code differently.</p><p>Under <code class="literal">js</code> folder, we have organized our JavaScript files further into three main sub-folders; <code class="literal">Components</code> which contains the files related to modules that have views associated with them, <code class="literal">Modules</code> which contains our modules for the controller and Model of the application, and <code class="literal">Widgets</code> which hosts files related to components that are loaded and rendered dynamically in our application.</p><p>Our <code class="literal">Modules</code> folder is further broken down into five sub-folders; <code class="literal">Base</code> which contains our third-party dependencies and the base module, <code class="literal">Core</code> which hosts the controller's code (modules) for our application, and <code class="literal">GlobalData</code> which holds our application's model files.</p><p>The other two sub-folders, <code class="literal">SandBox</code> and <code class="literal">PageDefinitions</code> contain the sandbox module and object definitions file for our dynamically loading components, respectively.</p><p>We will examine the code in most of the files of our sub-folders in the following sections.</p><div class="section" title="Loading our module files in index.html"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Loading our module files in index.html</h2></div></div></div><p>Before we start looking at our JavaScript code and modules, let's have a closer look at <code class="literal">index.html</code> file and see <a id="id383" class="indexterm"/>how the application modules are loaded in the browser.</p><p>Our <code class="literal">index.html</code> page is designed in such a way that it only provides the bare minimum skeleton for our application's main page, and all the other pieces (header, footer, and content) are built dynamically when the page is loaded.</p><p>Generally speaking, there are instances when it makes more sense to build some of the pieces of the application's pages on the server before sending them to the client, since this implementation could provide better performance at times.</p><p>In our approach here, we are building all the pieces of our application's pages on the client. This is so we can examine and apply different concepts of our application's design a little easier.</p><p>The skeleton of our <code class="literal">index.html</code> file consists of three main containers, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;header id="headerContainer" role="banner" itemscope itemtype="https://schema.org/WPHeader" class="headerContainerClass"&gt;
&lt;/header&gt;

&lt;main id="mainPageContainer" role="main" class="clearfix mainPageContainerClass"&gt;
&lt;/main&gt;

&lt;div id="footerParentContainer" class="footerContainerClass" &gt;
    &lt;div id="footerContainer" class="footerlinksContainerClass"&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p>As you can see, we have our header container, which hosts the <code class="literal">header</code> component of our application, the main container, which hosts the <code class="literal">content</code> component of our application and a <code class="literal">div</code>, which is the container for our <code class="literal">footer</code> component.</p><p>These are the pieces (containers) in our <code class="literal">index.html</code> page which are passed to our components so they can render themselves inside of them.</p><p>Just before the closing tag for the page's body element, we have included the <code class="literal">&lt;script&gt;</code> tags which load the scripts for our application. Let's have a look:</p><div class="mediaobject"><img src="graphics/B04910_08_08.jpg" alt="Loading our module files in index.html"/></div><p>As you can see, quite a few script files need to be loaded. We can improve on this by combining (and minifying) some of the files together, as <a id="id384" class="indexterm"/>well as using formats such as <span class="strong"><strong>Asynchronous Module Definition</strong></span> (<span class="strong"><strong>AMD</strong></span>) in conjunction with libraries like <code class="literal">Require.js</code> to load our files. For now however, for the sake of clarity, we leave things as they are.</p><p>In <a class="link" href="ch10.html" title="Chapter 10. Enterprise Grade Modular Design, AMD, CommonJS, and ES6 Modules">Chapter 10</a>, <span class="emphasis"><em>Enterprise Grade Modular Design, AMD, CommonJS, and ES6 Modules</em></span> of this book, we will discuss how we can use AMD format to combine and load our application's required files in a more optimized way.</p><p>The following script has also been implemented in our <code class="literal">index.html</code> file, which is responsible for starting up the application.</p><div class="mediaobject"><img src="graphics/B04910_08_09.jpg" alt="Loading our module files in index.html"/></div><p>We will discuss how the start-up of the application takes place shortly. Notice that we initialize all the modules first, then the components, and at the end, we pass the URL of the page to <code class="literal">handlePageChange</code> method of <code class="literal">ImagesInc_Core</code> module. This is done, so we can use the URL of the page in our application's router, which will be examined in depth shortly.</p><p>I emphasize the<a id="id385" class="indexterm"/> point that as you are reading this chapter, you should probably load the related code into your IDE so you can easily follow along.</p></div><div class="section" title="Base module implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Base module implementation</h2></div></div></div><p>Let's start the exploration of our application's modules with the base module. Our <code class="literal">Base</code> folder hosts two JavaScript files; <code class="literal">Base.js</code> and <code class="literal">jquery-1.10.2.min.js</code>.</p><p>
<code class="literal">Base.js</code> file implements<a id="id386" class="indexterm"/> <code class="literal">ImagesInc_Base</code> module which is responsible for importing all of our third-party libraries into the application, as we discussed in the previous chapter. Currently, the only third-party library that we are importing is jQuery.</p><p>The following code snippet shows how this is implemented:</p><div class="informalexample"><pre class="programlisting">var ImagesInc_Base = (function(){
    function getBaseModule(){
        if(typeof  jQuery !== 'undefined'){
            return jQuery;
        }else{
            return null;
        }
    }
    return {        
      getBaseModule: getBaseModule  
    };    
})();</pre></div><p>As you can see, we are using an IIFE to return an object to the global variable <code class="literal">ImagesInc_Base</code>.</p><p>In this function, we first check to see if a jQuery object has been defined in the global scope; if so, we return it. Otherwise, <code class="literal">null</code> is returned.</p><p>Our core module will be using this object to leverage the jQuery library's functionality.</p><p>This is done in <code class="literal">MainCore</code> module as follows:</p><div class="informalexample"><pre class="programlisting">(function Core_initialize(){        
        mainCore.debug = true;        
        try{
            // get jQuery from the base module loader
            mainCore.jQuery = $ = ImagesInc_Base.getBaseModule();   
        }catch(e){            
            if(mainCore.debug){
                console.error('Base Module has not been defined!!!' );    
            }
        }        
        if(mainCore.debug){
            console.log("%c Core Module has been initialized...", "color:blue");
        }
        
})();</pre></div><p>As our <code class="literal">MainCore</code> module is initializing itself (using an IIFE), it asks the base module for its base library and then <a id="id387" class="indexterm"/>assigns a reference of the returned object in both the <code class="literal">$</code> and <code class="literal">mainCore.jQuery</code> properties of <code class="literal">MainCore</code> module.</p><p>Note that in the current implementation, we are only able to import one base library. This is to keep the implementation simple, as we only need jQuery in our application. However, we could also import and use a collection of libraries with some modification to this code.</p></div><div class="section" title="Core module implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Core module implementation</h2></div></div></div><p>The Core module is the heavy-lifter module in our application, and is constructed using a few sub-modules. This<a id="id388" class="indexterm"/> module's functionality has also been enhanced and augmented using the techniques that we discussed in the <a id="id389" class="indexterm"/>previous chapters, such as tight and loose augmentation.</p><p>Here is a list of all the sub-modules that make up the Core module:</p><div class="mediaobject"><img src="graphics/B04910_08_10.jpg" alt="Core module implementation"/></div><p>We will not cover all<a id="id390" class="indexterm"/> the related code for this module but we will have a look at the important parts of it in this section. Note that the Core module is also the controller of our application.</p><div class="section" title="MainCore module implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec28"/>MainCore module implementation</h3></div></div></div><p>This module provides the main functionality of the Core module and all the related Core's sub-modules are <a id="id391" class="indexterm"/>attached to this module, hence the name <code class="literal">MainCore.js</code>.</p><p>I'll be referring to this<a id="id392" class="indexterm"/> module as <span class="strong"><strong>MainCore</strong></span> from this point forward.</p><p>This module has been defined as follows:</p><div class="informalexample"><pre class="programlisting">var ImagesInc_Core = (function(mainCore){
var $ = null, registeredModules = [], registeredComponents = []....
...
...

})(ImagesInc_Core || {}); // using loose augmentation</pre></div><p>As you can see, we have used the loose augmentation technique in this module to enhance its functionality.</p><p>This module also uses an inner IIFE to initialize itself and to import our application's base library. When the application is in debug mode, MainCore will announce that it has been initialized as soon <a id="id393" class="indexterm"/>as it is loaded.</p><p>This is shown in the<a id="id394" class="indexterm"/> following code snippet:</p><div class="informalexample"><pre class="programlisting">(function Core_initialize(){
        mainCore.debug = true;        
        try{
            // get jQuery from the base module loader
            mainCore.jQuery = $ = ImagesInc_Base.getBaseModule();
            
        }catch(e){            
            if(mainCore.debug){
                console.error('Base Module has not been defined!!!' );    
            }
        }        
        if(mainCore.debug){
            console.log("%c Core Module has beeninitialized...", "color:blue");
        } 
})();</pre></div><p>To turn the debug mode on or off in the application, we have implemented the following method which can be called by the external code:</p><div class="informalexample"><pre class="programlisting">mainCore.toggleDebug = function(){        
         mainCore.debug = !mainCore.debug;
         if(mainCore.debug){
            mainCore.log(1, "Application debug has been turned on...", "blue");
         }else{
             console.log("%c Application debug has been turned off...", "color:orange");
        }
};</pre></div><p>Notice that we are returning a reference to MainCore module as a global variable, <code class="literal">ImagesInc_Core</code>, which allows the external code to interact with this module, through the interface that this module provides.</p><div class="section" title="Augmenting MainCore module"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec12"/>Augmenting MainCore module</h4></div></div></div><p>In designing MainCore module, I have purposely used various augmentation techniques. This is<a id="id395" class="indexterm"/> done to demonstrate the practical aspects of such techniques in enchaining modules.</p><div class="section" title="Augmenting MainCore using tight augmentation"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec01"/>Augmenting MainCore using tight augmentation</h5></div></div></div><p>Consider the<a id="id396" class="indexterm"/> following augmentation:</p><div class="informalexample"><pre class="programlisting">// event related functionality augmentation
var ImagesInc_Core = (function(Core){
    var $ = Core.jQuery;
    var addEventHandlerToElem = function(elem,event,callbackFunc){
        
        if(!elem){            
            Core.log(3, 'elem is not passed in, from addEventHandlerToElem');
            throw new Error('Element not found');
        }
...

    Core.addEventHandlerToElement = addEventHandlerToElem;
    Core.removeEventHandlerFromElem = removeEventHandlerFromElem;
    Core.registerForCustomEvents = registerForCustomEvents;
 …..........
 return Core;        
})(ImagesInc_Core); // using tight augmentation</pre></div><p>Here, we have made a logical separation between the code that deals with event-related functionality in MainCore module and the rest of the code related to this module.</p><p>Notice that we have passed a reference of MainCore module (known to the application as <code class="literal">ImagesInc_Core</code>) to the IIFE that implements this augmentation (using tight augmentation technique) and then we have added new properties to MainCore module as needed. At the end, the reference to the now augmented MainCore module is returned to <code class="literal">ImagesInc_Core</code>, which is the global variable  that provides access to MainCore module.</p><p>We use the same technique again in another part of the code to augment the module with more functionality. Please have a look at the related code in <code class="literal">MainCore.js</code> file of the application.</p></div><div class="section" title="Augmenting MainCore using sub-modules"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec02"/>Augmenting MainCore using sub-modules</h5></div></div></div><p>Let's look at an example<a id="id397" class="indexterm"/> of how we add sub-modules to MainCore module. To add enhanced logging functionality to the application, we have augmented MainCore module with a sub-module which specializes in logging messages for the application.</p><p>The following code snippet shows how this sub-module is being used by MainCore module:</p><div class="informalexample"><pre class="programlisting">mainCore.log = function(severity,msg, color){
        
        // if the logging module has been loaded, then use its full functionality
        // otherwise just log a simple message
        if(mainCore.LoggingHandler &amp;&amp; mainCore.LoggingHandler.logMessage){
          
            mainCore.LoggingHandler.logMessage(severity,msg,color);
            
        }else{
            if(severity === 3){
              color = "color:red;font-weight:bold"; 
            }
            console['log']("%c Severity: " + severity + " ---&gt; " + msg + " (From Core!)", color);
        }
};</pre></div><p>In this method, we<a id="id398" class="indexterm"/> first check to see if <code class="literal">LoggingHandler</code> object (the logging sub-module) exists and also if <code class="literal">logMessage</code> method on that object is implemented. If both conditions are met, then we pass on the logging message and its related information to this sub-module.</p><p>On the other hand, if the logging sub-module or its required method do not exit, we use <code class="literal">mainCore</code> module's own simple logging mechanism to log messages in the browser's console.</p><p>We should have a look at how <code class="literal">LoggingHandler</code> sub-module has been implemented and added to MainCore module.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">// using simple sub-module augmentation
ImagesInc_Core.LoggingHandler = (function(){
    
    var self = {}, messageParam, colorParam;
    self.logMessage = function(severity, message,color) {
        
  …....

return {        
        logMessage: self.logMessage,
        initialize: self.initialize
    };    
})();</pre></div><p>As shown, we have added a property to <code class="literal">ImagesInc_Core</code> object (MainCore module). An IIFE returns an object to this property (<code class="literal">LoggingHandler</code>) when it is executed. This object consists of two methods which provide all the functionality related to the logging mechanism of the <a id="id399" class="indexterm"/>application.</p><p>While the implementation of these two methods is hidden away from the rest of the application, other pieces of the application can interact with this sub-module through MainCore module and the related interface.</p><p>Notice that this sub-module can easily be swapped for a different one or modified internally in any form that we desire. However, as long as the exposed interface does not change, all the external code would still be able to use this sub-module for its logging functionality.</p><p>In fact, we can even remove this sub-module completely and it will not affect the application at all, except for the fact that the advanced logging mechanism for the application would be absent. This highlights some <a id="id400" class="indexterm"/>of the advantages of<a id="id401" class="indexterm"/> modular design in our application, such as <span class="strong"><strong>plug-and-play</strong></span>, <span class="strong"><strong>progressive enhancement</strong></span>, and <span class="strong"><strong>graceful degradation</strong></span>.</p><p>In the same way, we can<a id="id402" class="indexterm"/> also add other sub-modules to MainCore module to provide more functionality without the need to make many changes in the application. This allows us to have a flexible and easily maintainable code base.</p><p>In our application, there are also other sub-modules, which attach themselves to MainCore module, and provide added functionality to the application. We talked about these sub-modules in the previous chapter but I will mention them again here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AjaxEngine</code><a id="id403" class="indexterm"/>: This module is responsible for making AJAX calls to the server, using jQuery AJAX functionality.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CookieHandler</code><a id="id404" class="indexterm"/>: This module looks after all the cookie-related operations in the application, such as writing, reading, and deleting cookies in the browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NotificationHandler</code><a id="id405" class="indexterm"/>: This module is responsible for displaying notifications to the users by leveraging a dialog box component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">StorageHanlder</code><a id="id406" class="indexterm"/>: All the functionality related to the browser's local storage that is implemented in this sub-module, such as storing, reading, and deleting objects in local storage.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Utilities</code><a id="id407" class="indexterm"/><a id="id408" class="indexterm"/>: This module provides helper methods to the application, such as methods to combine two objects, to see if an object is an array, to load files from the server, and so on.</li></ul></div></div></div></div><div class="section" title="Component registration with MainCore"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec29"/>Component registration with MainCore</h3></div></div></div><p>Every component of our application is registered with MainCore module. This allows to create the bridge between the component and the application, by using an instance of <code class="literal">SandBox</code> module.. We will talk <a id="id409" class="indexterm"/>about the <code class="literal">SandBox</code> module shortly but let's have a look at how the registration of the components takes place in the application (in the MainCore module).</p><p>The following diagram provides an overview of this process:</p><div class="mediaobject"><img src="graphics/B04910_08_12.jpg" alt="Component registration with MainCore"/></div><p>Consider the<a id="id410" class="indexterm"/> following implementation in MainCore module:</p><div class="informalexample"><pre class="programlisting">mainCore.registerComponent = function(containerID, componentID, createFunc){
        
        var containerElem, componentObj;
        
        // setting context for the sandbox
        if($){
            containerElem =  $("#" + containerID)[0];        
        }else{        
            containerElem = document.getElementById(containerID);
        }        
        if(createFunc &amp;&amp; typeof createFunc === 'function'){            
            componentObj = createFunc(new SandBox(this,containerElem, componentID));
            //checking for required methods in component
            if (componentObj.init &amp;&amp; typeof componentObj.init === 'function' &amp;&amp; componentObj.destroy &amp;&amp; typeof componentObj.destroy === 'function') {
                 componentObj.id = componentID;
                 registeredComponents.push(componentObj);
            
            }else{                
                this.log(3,"Component does not have necessary methods, thus not registered");
            }
        }else{            
            this.log(3,"no creator function on component, component not registered");
        } 
};</pre></div><p>As you can see, when this method is called at a component's load time by the component, three parameters are <a id="id411" class="indexterm"/>passed into MainCore's <code class="literal">mainCore.registerComponent</code> method: <code class="literal">containerID</code>, <code class="literal">componentID</code>, and <code class="literal">createFunc</code>.</p><p>
<code class="literal">containerID</code> parameter is passed to this method to tell the application what container (HTML element) the component's view needs to be rendered in. <code class="literal">componentID</code> is the ID of the component that gets registered with the application and <code class="literal">createFunc</code> is the callback function on the component, which <code class="literal">mainCore.registerComponent</code> method calls to create an instance of the component.</p><p>We will talk about how components are instantiated in more depth, later in this chapter. But for now, let's have a look at this mechanism from MainCore module's perspective.</p><p>In the above method, we first walk the DOM tree to find the container element for the component's view, either by using jQuery or the DOM API directly.</p><p>Then, we check to see if the required <code class="literal">createFunc</code> parameter has been passed in, and whether it is a function. If so, we call this component's function with an instance of <code class="literal">SandBox</code> module (using dependency injection). Remember that every component gets a different instance of <code class="literal">SandBox</code> module, which is the bridge between the component and the application.</p><p>This is done as follows:</p><div class="informalexample"><pre class="programlisting">componentObj = createFunc(new SandBox(this,containerElem, componentID));</pre></div><p>If the component is designed properly, the result of this function call is an instance of the component which is returned and stored in <code class="literal">componentObj</code> variable.</p><p>There are also a couple<a id="id412" class="indexterm"/> of required methods that we need to make sure exist on the component's instance: <code class="literal">init</code> and <code class="literal">destroy</code> methods. Notice that MainCore is not concerned with how such methods are implemented in the component or what they do, only that they exist. The internal implementation of such methods and what they do are the responsibility of the component itself and each component may implement these methods differently. Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">//checking for required methods in component
if (componentObj.init &amp;&amp; typeof componentObj.init === 'function' &amp;&amp; componentObj.destroy &amp;&amp; typeof componentObj.destroy === 'function') {

           componentObj.id = componentID;
           registeredComponents.push(componentObj);
            
}else{                
           this.log(3,"Component does not have necessary methods, thus not registered");
}</pre></div><p>At the end of the registration phase, each component is pushed to <code class="literal">registeredComponents</code> array, which is a collection of all the registered components.</p><p>We use this array of components to do a few different things in the application. For instance, when the application is starting up, we loop through all the components in this array and call <code class="literal">init</code> method on each one of them. This is done as follows:</p><div class="informalexample"><pre class="programlisting">mainCore.initializeAllComponents = function(){
     
        this.log(1,"Initializing all components...", "orange");
        
        try{            
            for(var i=0; i &lt; registeredComponents.length; i++){          
                registeredComponents[i].init();
            }
            
        }catch(e){            
           this.log(3, 'APPLICATION CATASTROPHIC ERROR!' + e.name + ": " + e.message);
        }
        this.log(1,"All components have been initialized...", "orange");
};</pre></div><p>The preceding method of MainCore module is called in <code class="literal">index.html</code> file, as shown here:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.initializeAllComponents();</pre></div><p>After <code class="literal">init</code> methods of all the components have been called by the application in the start-up phase, we<a id="id413" class="indexterm"/> will see the following messages displayed in the console, if the application is in debug mode.</p><div class="mediaobject"><img src="graphics/B04910_08_11.jpg" alt="Component registration with MainCore"/></div></div><div class="section" title="Dynamic loading of components by MainCore"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec30"/>Dynamic loading of components by MainCore</h3></div></div></div><p>As you may recall, I mentioned previously that application components can be loaded at a later time than<a id="id414" class="indexterm"/> the application's start-up. MainCore module provides the hooks and implements the functionality needed to achieve this.</p><p>I think it might be a good idea to go back to the previous chapter and have a look at the flow diagram which depicts this mechanism before continuing with the explanations to follow, just so you can refresh your memory.</p><p>In our application, when<a id="id415" class="indexterm"/> the user clicks on the <span class="strong"><strong>Support</strong></span> link provided in the footer section, a dialogue box is displayed. This dialogue box provides information regarding where the images of our application have been taken from and whether the user would like to visit that site.</p><p>This widget component (<code class="literal">notificationWidget</code>), is not loaded in <code class="literal">index.html</code> page when the application is initially started up; it is only loaded when the user clicks on the <span class="strong"><strong>Support</strong></span> link.</p><p>However, if the <a id="id416" class="indexterm"/>widget has been previously loaded in the application (if the user had clicked on the <span class="strong"><strong>Support</strong></span> link before), we will simply re-render it on the page. This is because after the first time this component is loaded, it will be kept in cache, even after the user closes the dialogue box by clicking on its <span class="strong"><strong>Close</strong></span> button.</p><p>
<code class="literal">NotificationHandler</code> sub-module is responsible for listening and acting on the click event of the <span class="strong"><strong>Support</strong></span> link. This is done by using a publish-subscribe mechanism (pattern), which we will discuss shortly in this chapter.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">self.handleSupportClick = function(){
        // name of the component when it registers itselft with core is used here
        NotificationWidgetObj = ImagesInc_Core.getComponentByID("notificationWidget");        
        if(!NotificationWidgetObj){            
            ImagesInc_Core.loadComponent(ImagesInc_GlobalData.getNoficationWidgetDefID(), self.renderWidget);
            
        }else{            
            self.renderWidget();
        }
   };</pre></div><p>This method is the callback function for the <span class="strong"><strong>Support</strong></span> link click event in <code class="literal">NotificationHandler</code> sub-module. The very first thing that this method does is to ask the application (MainCore module specifically) whether this component (widget) has been previously loaded and registered with the application, as follows:</p><div class="informalexample"><pre class="programlisting">NotificationWidgetObj = ImagesInc_Core.getComponentByID("notificationWidget");</pre></div><p>If so, this methods calls <code class="literal">NotificationHandler.renderWidget</code> (<code class="literal">self.renderWidget</code>) function, which in turn calls <code class="literal">renderWidget</code> method on the widget component itself. Note that the widget is responsible for its own rendering, as shown here:</p><div class="informalexample"><pre class="programlisting">self.renderWidget = function(){        
       ImagesInc_Core.getComponentByID("notificationWidget").renderWidget();    
};</pre></div><p>If the widget has not been loaded previously, the method asks the MainCore module to load the widget first, and then call <code class="literal">NotificationHandler.renderWidget</code> function, which is the<a id="id417" class="indexterm"/> callback function that is passed in as <code class="literal">self.renderWidget</code>.</p><p>This call is shown as follows:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.loadComponent(ImagesInc_GlobalData.getNoficationWidgetDefID(), self.renderWidget);</pre></div><p>Now the control is given to<a id="id418" class="indexterm"/> MainCore module to load the component (widget) dynamically. This is done by first finding the object definition for the component in the browser's local storage.</p><p>Let's first have a look at how the local storage is populated with the components' object definitions.</p><div class="section" title="Storing object definitions in local storage"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec13"/>Storing object definitions in local storage</h4></div></div></div><p>The application has<a id="id419" class="indexterm"/> been designed to find the object definitions for all the dynamically loaded components, in the browser's local storage.</p><p>However, these definitions are in fact implemented in <code class="literal">PageDefinitions.js</code> file.</p><p>When the <code class="literal">PageDefinitions.js</code> file is loaded, it uses an IIFE to store its object definitions in the browser's local storage, as follows:</p><div class="informalexample"><pre class="programlisting">(function(){
 
    var NotificationWidgetDefinition = {
        componentID: "notificationWidget",
        scriptFile: "NotificationWidget.js",
        scriptPath: "/js/Widgets/",
        cssFile: "NotificationWidget.css",
        cssPath: "css/"
    };
    
...    
    ImagesInc_Core.saveValueToLocalStorage(ImagesInc_GlobalData.getNoficationWidgetDefID(),NotificationWidgetDefinition);

...
                                
})();</pre></div><p>After the browser's local storage is populated with the object definitions, the file is removed from the browser's cache as it can potentially be large and consume a significant amount of memory. This design allows us to minimize the use of the browser's cache, which could be of particular interest on mobile devices, where resources are limited.</p><p>Notice the object<a id="id420" class="indexterm"/> definition for <code class="literal">notificationWidget</code>. On this object, <code class="literal">ScriptFile</code> property holds the name of the <code class="literal">.js</code> file for this component and <code class="literal">ScriptPath</code> property stores the path to this file. MainCore module uses this information to find and load the component from the server.</p></div><div class="section" title="Getting a component's object definition from local storage"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec14"/>Getting a component's object definition from local storage</h4></div></div></div><p>Now that you know how<a id="id421" class="indexterm"/> the local storage is populated with the object definitions, we can look at how MainCore module gets the <code class="literal">notificationWidget</code> object definition from the local storage and loads the related resources.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">mainCore.loadComponent = function(ComponentDefID, callbackFunc){        
        // get the value of Component object defintion from storage
        var ComponentDef =  mainCore.getValueForKeyAsObjectFromStorage(ComponentDefID);
        loadedComponentcallbackFunc = callbackFunc;
                
        if(!ComponentDef){
            // if Component definition is not in the storage then the page object definitions probably needs to be loaded
            mainCore.loadPageDefinitionsFileAndCallBack(function(){mainCore.getComponentObjAndCallback(ComponentDefID, mainCore.loadComponentFilesAndInitializeWithCallBack);});
            
        }else{         
            mainCore.loadComponentFilesAndInitializeWithCallBack(ComponentDef);
        }
};</pre></div><p>In this method, first the local storage in the browser is checked (using the <code class="literal">StorageHandler</code> sub-module behind the scenes) for the object definition of the component. If it is found, then this method calls <a id="id422" class="indexterm"/>another method to dynamically load the necessary resources for the component as follows:</p><div class="informalexample"><pre class="programlisting">mainCore.loadComponentFilesAndInitializeWithCallBack(ComponentDef)</pre></div></div><div class="section" title="Dynamically loading component's resources from the server"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec15"/>Dynamically loading component's resources from the server</h4></div></div></div><p>Once a component's object<a id="id423" class="indexterm"/> definition has been extracted from the local storage, its required <code class="literal">.js</code> and <code class="literal">.css</code> files are loaded from the server using the following method: </p><div class="informalexample"><pre class="programlisting">mainCore.loadComponentFilesAndInitializeWithCallBack = function(pageDefinitionObj, callbackFunc){
...
    mainCore.loadJSfileFromObjDefAndCallBack(pageDefinitionObj.scriptFile, pageDefinitionObj.scriptPath, function(){mainCore.initializeComponent(pageDefinitionObj.componentID, loadedComponentcallbackFunc)});

...
    mainCore.loadCSSfileFromObjDef(pageDefinitionObj.cssFile, pageDefinitionObj.cssPath);
...

}</pre></div><p>As you can see, this method calls other methods which specialize in loading <code class="literal">.js</code> or <code class="literal">.css</code> files, as the mechanism for loading the files into the application is different, based on the file type. Of course the <code class="literal">.js</code> file is where the code for the component resides and the <code class="literal">.css</code> file has the styling-related information for the component.</p><p>Keep in mind that the callback function is called <span class="strong"><strong>asynchronously</strong></span> after the files are loaded into the browser's cache.</p><p>Also, note that MainCore module uses <code class="literal">Utilities</code> sub-module (behind the scenes) to take care of the mechanics of requesting and loading the component files from the server.</p><p>The dynamic loading of components is probably the most involved operation in the application and it can be a little challenging to fully understand it by just reading this section. I highly recommend that you download the application's code and put breakpoints in the methods that I have mentioned in this section when you run the application. Doing so, will help you to fully realize how the flow of loading components dynamically is taking place.</p><p>After a component is <a id="id424" class="indexterm"/>dynamically loaded into the application, it still needs to register itself with MainCore module. We will talk about this process more later in this chapter.</p></div></div><div class="section" title="Routing functionality in MainCore module"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec31"/>Routing functionality in MainCore module</h3></div></div></div><p>As our application is a single page application, and its view needs to change based on the user's interaction, we<a id="id425" class="indexterm"/> need to implement the client-side routing functionality. This also means that we need to incorporate page <a id="id426" class="indexterm"/>view changes based on the user clicking on the back and forward buttons of the browser.</p><p>In our application, I have used the HTML5 History API as the basis for our client-side routing, but we could have also used open source libraries such as <code class="literal">History.js</code> instead.</p><p>Let's see how routing functionality has been implemented in MainCore module.</p><div class="section" title="Adding a URL to the history object of the browser"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec16"/>Adding a URL to the history object of the browser</h4></div></div></div><p>Consider the<a id="id427" class="indexterm"/> following method:</p><div class="informalexample"><pre class="programlisting"> var addToHistory = function(dataObj){        
        // if history object is supported
     if(!!(window.history &amp;&amp; history.pushState)){   
         history.pushState(dataObj,dataObj.url, dataObj.url);
     }else{
         alert('Your browser needs to be upgraded to the latest version');
         Core.log(3, "History API is not supported; from addToHistory");
     }  
};</pre></div><p>This method is called when the application needs to create an entry in the history object of the browser. For instance, when the <span class="strong"><strong>Home</strong></span> link of the header section is clicked, the following callback function is called in the header component:</p><div class="informalexample"><pre class="programlisting">handleHomeClick: function (e) {
     sandBox.loadPage("index.html");
     e.preventDefault();
     e.stopPropagation();
     sandBox.addToHistory({
          url: "index.html"
     });
},</pre></div><p>As you can see, the callback function calls <code class="literal">addToHistory</code> API of its <code class="literal">SandBox</code> instance with an<a id="id428" class="indexterm"/> anonymous object. The <code class="literal">SandBox</code> instance, in turn, calls <code class="literal">addToHistory</code> method of MainCore module. The anonymous object is passed to this method and then the browser's history object is updated, as follows:</p><div class="informalexample"><pre class="programlisting">var addToHistory = function(dataObj){
        
        // if history object is supported
        if(!!(window.history &amp;&amp; history.pushState)){
            
            history.pushState(dataObj,dataObj.url, dataObj.url);            
            
        }else{
            
            alert('Your browser needs to be upgraded to the latest version');
            Core.log(3, "History API is not supported; from addToHistory");
        }        
}; </pre></div><p>There are three parameters which are passed to <code class="literal">pushState</code> API of the history object. These parameters are; <code class="literal">State</code> object, <code class="literal">Title</code>, and <code class="literal">URL</code>, respectively.</p><p>In our preceding example, the following object will be passed to this API as the first parameter:</p><div class="informalexample"><pre class="programlisting">{
          url: "index.html"
} </pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Note that we use <code class="literal">url</code> property of the same object for the other parameters too.</p><p>For more information regarding the browser's <a id="id429" class="indexterm"/>history API, you can refer to the following link:</p><p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">https://developer.mozilla.org/en-US/docs/Web/API/History_API</a>
</p></div></div></div><div class="section" title="Getting a URL from the history object of the browser"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec17"/>Getting a URL from the history object of the browser</h4></div></div></div><p>To get URL entries from<a id="id430" class="indexterm"/> the browser's History object, we first bind <code class="literal">popstate</code> event of the browser to MainCore's <code class="literal">getFromHistory</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">addEventHandlerToElem(window,'popstate',getFromHistory);</pre></div><p>This means that every time the browser's <code class="literal">pop</code> event takes place, which is when the user clicks on the back or forward button of the browser, the following method is called:</p><div class="informalexample"><pre class="programlisting"> var getFromHistory = function(e){
        // if history object is supported
        if(!!(window.history &amp;&amp; history.pushState)){
            if(e.state){
                Core.handlePageChange(e.state.url);
            }else if(e.originalEvent &amp;&amp; e.originalEvent.state){ // to get the original event in case of jQuery
                Core.handlePageChange(e.originalEvent.state.url);
            }else{
                Core.log(2, "Could not get the state of event from history object");
            }            
        }else{            
            alert('Your browser needs to be upgraded to the latest version');
            Core.log(3, "History API is not supported; from getFromHistory");
        }        
};</pre></div><p>The main action taken by this method is to call <code class="literal">handlePageChange</code> method of MainCore module. This method, in turn, publishes a <code class="literal">page-Changed</code> event in the application, as follows:</p><div class="informalexample"><pre class="programlisting">Core.handlePageChange = function(pageURL){      
        Core.publishCustomEvent({
            type: 'page-Changed',
            data:pageURL
        });
        
};</pre></div><p>When this event is published, all the modules that have registered for this event are notified. The modules can then take action based on the published event.</p><p>For instance, <code class="literal">content</code> component has bound <code class="literal">updateContentPage</code> method to this event as follows:</p><div class="informalexample"><pre class="programlisting">'page-Changed': this.updateContentPage</pre></div><p>To better understand <a id="id431" class="indexterm"/>how this process works, we also need to talk about custom events and publish-subscribe (observer) pattern implementation in the application.</p></div></div><div class="section" title="Publish-subscribe implementation in MainCore"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec32"/>Publish-subscribe implementation in MainCore</h3></div></div></div><p>As previously mentioned, one of the goals of our application design has been to create loose coupling among<a id="id432" class="indexterm"/> the application modules.</p><p>We have also talked about the fact that while our application modules are not aware of each other, they need to be able to communicate with one another in an indirect manner.</p><p>These goals can be achieved by<a id="id433" class="indexterm"/> leveraging the <span class="strong"><strong>Mediator</strong></span> design pattern and implementing a publish-subscribe mechanism around that pattern.</p><p>As we saw in the previous chapter, in Mediator pattern pieces of the application do not directly register with each other for custom events. Instead, they register for these events and are notified of the broadcast of such events through an intermediary piece. In our application, the intermediary piece is our MainCore module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If you are not familiar with mediator or publish-subscribe patterns, I highly recommend reading, <span class="emphasis"><em>Mastering JavaScript Design Patterns</em></span> by <span class="emphasis"><em>Simon Timms</em></span>, which discusses many popular patterns as well as mediator pattern. You can find this book at the following link:</p><p>
<a class="ulink" href="https://www.packtpub.com/application-development/mastering-javascript-design-patterns">https://www.packtpub.com/application-development/mastering-javascript-design-patterns</a>
</p></div></div><div class="section" title="Registering components for custom events"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec18"/>Registering components for custom events</h4></div></div></div><p>The following method in MainCore module is used for registering components to receive custom<a id="id434" class="indexterm"/> events:</p><div class="informalexample"><pre class="programlisting">var registerForCustomEvents = function (componentID,eventsObj) {  
    if (typeof componentID === 'string' &amp;&amp; typeof eventsObj === 'object') {
        for(var i=0; i&lt; Core.registeredComponents.length ; i++){            
            if(Core.registeredComponents[i].id === componentID){
                Core.registeredComponents[i].events = eventsObj;
                }
            }
        } else {
            Core.log(3,'Incorrect parameters passed in, from registerForCustomEvents');
        }
};</pre></div><p>As you can see, this method registers the custom event object passed to it with the ID of the component, which needs to be notified when the event is published.</p><p>For instance, <code class="literal">content</code> component registers for the following events:</p><div class="informalexample"><pre class="programlisting">registerForCustomEvents : function(){          
    sandBox.registerForCustomEvents({
        'img-Clicked': this.updateContentPage, //  handles  image click
        'page-Changed': this.updateContentPage, // handles back and forward buttons
        'favorites-Clicked':this.updateContentPage
    });            
},</pre></div><p>When any one of the preceding events is published, the bound event handler method for that event is called.</p><p>Notice that in the code above, no component ID is passed to the <code class="literal">SandBox</code> module instance by the component. However, the <code class="literal">SandBox</code> module instance associated with this component sends the required component ID to MainCore module as follows:</p><div class="informalexample"><pre class="programlisting"> registerForCustomEvents : function(eventsObj){            
    if(eventsObj &amp;&amp; typeof eventsObj === "object"){
        Core.registerForCustomEvents(componentID,eventsObj);                 
    }else{                
        Core.log(3,"incorrect parameter passed in; from SandBox.registerForCustomEvents");
    }  
},</pre></div><p>We will talk about <a id="id435" class="indexterm"/>how the <code class="literal">SandBox</code> instance is aware of the component ID, when we talk about <code class="literal">SandBox</code> module later in this chapter.</p></div><div class="section" title="Broadcasting custom events by components"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec19"/>Broadcasting custom events by components</h4></div></div></div><p>When components need to<a id="id436" class="indexterm"/> publish custom events in the application, they do so by using <code class="literal">publishCustomEvent</code> method in MainCore module.</p><p>Consider the following code for this method:</p><div class="informalexample"><pre class="programlisting">var publishCustomEvent = function(eventObj){      
    for(var i=0; i&lt; Core.registeredComponents.length ; i++){ 
        if(Core.registeredComponents[i].events &amp;&amp; Core.registeredComponents[i].events[eventObj.type]){
            Core.registeredComponents[i].events[eventObj.type](eventObj.data);
        }
    }
};</pre></div><p>As you can see, an event object is passed to this method. The method loops through all the components which have registered for this event and then calls the associated event handler on the components for the event.</p><p>Components can publish their events using their instance of <code class="literal">SandBox</code> module. For example, the <code class="literal">header</code> component of the application broadcasts that the Favorites link in the application has been clicked, as follows:</p><div class="informalexample"><pre class="programlisting">handleFavouritesClick: function (e) {

            e.preventDefault();
            e.stopPropagation();
           
      ...     
            sandBox.publishCustomEvent({
                type: 'favourites-Clicked',
                data: "favourites"
            });
            sandBox.addToHistory({
                url: 'favourites' //update url in the browser
            });            
}</pre></div><p>Since the <code class="literal">content</code> component has registered for this event, the method <code class="literal">updateContentPage</code> of the <code class="literal">content</code> component is subsequently called.</p><p>To sum things up, application components publish custom events, then the components that have registered for these custom events are notified by MainCore module, which calls the associated methods for these custom events. Thus, MainCore module acts as the mediator piece among all the components of the application.</p><p>This concludes our discussion and examination of the core module, but keep in mind that the core module as a whole provides many more capabilities for the application, beyond what we<a id="id437" class="indexterm"/> have discussed here. All such functionality is either implemented in MainCore module (<code class="literal">MainCore.js</code>) or other sub-modules which together, make up the core module.</p><p>Keep in mind that from the component's point of view, all the application functionality is provided by an instance of <code class="literal">SandBox</code> module.</p></div></div></div><div class="section" title="SandBox module implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>SandBox module implementation</h2></div></div></div><p>As mentioned previously, the components in our application do not directly communicate with each other nor do<a id="id438" class="indexterm"/> they communicate directly with any other parts of the application. The only connection between<a id="id439" class="indexterm"/> the components and the rest of the application is through an instance of <code class="literal">SandBox</code> module assigned to them.</p><div class="section" title="SandBox module's constructor"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec33"/>SandBox module's constructor</h3></div></div></div><p>Consider the <a id="id440" class="indexterm"/>following code snippet:</p><div class="informalexample"><pre class="programlisting">var SandBox = function(Core,contextElem, componentSelector){
    var Core = Core, containerElemContext = contextElem, componentID = componentSelector;
    
    return{        
        getElement : function(elementID){            
            if(elementID &amp;&amp; typeof elementID === "string"){
                return Core.getElement(elementID);
                
            }else{                
                Core.log(3,"incorrect parameters passed in; from SandBox.getElement ");
            }
        },
...    
};</pre></div><p>As the preceding code shows, <code class="literal">SandBox</code> module is created as a global object <code class="literal">SandBox</code>, and three parameters are passed to its constructor by MainCore module. <code class="literal">Core</code> parameter, which is a reference to MainCore module; <code class="literal">contextElem</code> parameter, which is a reference to the container element for the component's view that the <code class="literal">SandBox</code> instance belongs to; and <code class="literal">componentSelector</code> , which is the ID of the sandbox's component.</p><p>For instance, the <code class="literal">SandBox</code> instance of <code class="literal">header</code> component, receives the following parameters when it is instantiated: A reference to the <a id="id441" class="indexterm"/>core module as the first parameter, <code class="literal">headerContainer</code> which is the ID of <code class="literal">header</code> component's view container on the page as the second parameter, and <code class="literal">header</code> which is the ID of <code class="literal">header</code> component as the third parameter.</p><p>The reference to Core module is used by the <code class="literal">SandBox</code> module instance to get access to the functionality that Core module provides.</p></div><div class="section" title="Setting a component's container context in the SandBox instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec34"/>Setting a component's container context in the SandBox instance</h3></div></div></div><p>A reference to the container<a id="id442" class="indexterm"/> element of the component's view is used by the <code class="literal">SandBox</code> module instance to set the DOM context of the component's HTML elements. This is so when an HTML element within this container needs to be accessed, the search for this element can start from the container element, as opposed to the <code class="literal">document</code> element of the page.</p><p>Have a look at the following code:</p><div class="informalexample"><pre class="programlisting"> getElementInContext : function(elementID){        
    if(elementID &amp;&amp; typeof elementID === "string"){
        return Core.getChildOfParentByID(containerElemContext,elementID);
    }else{
        Core.log(3,"incorrect parameters passed in; from SandBox.getElementInContext");
    }            
    
},</pre></div><p>Here the <code class="literal">SandBox</code> module instance is calling the core module's <code class="literal">getChildOfParentByID</code> method. This method takes two parameters, <code class="literal">containerElemContext</code>, and <code class="literal">elementID</code>. The objective is to search the DOM tree for the element whose ID has been passed in.</p><p>Using the container element's <code class="literal">DOM</code> Context, we can <a id="id443" class="indexterm"/>start the search in the container of the component as opposed to the top-level element of the DOM tree. This approach allows us to have a much more optimized search for finding our component's elements.</p></div><div class="section" title="Identifying the SandBox module's instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec35"/>Identifying the SandBox module's instance</h3></div></div></div><p>The component ID, which is <a id="id444" class="indexterm"/>passed in as the third parameter to <code class="literal">SandBox</code> module's constructor, identifies the instance of <code class="literal">SandBox</code> module. This is used by the core module, to identify which component the <code class="literal">SandBox</code> instance belongs to.</p><p>For instance, the component's ID is used in the following method of <code class="literal">SandBox</code> module:</p><div class="informalexample"><pre class="programlisting">unregisterCustomEvent : function(eventType){
            
            if(eventType &amp;&amp; typeof eventType === "string"){
                Core.unregisterCustomEvent(componentID,eventType);
                
            }else{
                
                Core.log(3,"incorrect parameter passed in; from SandBox.unregisterCustomEvent");
            } 
},</pre></div><p>In the code snippet above, we are calling <code class="literal">unregisterCustomEvent</code> method of Core module and are passing in the parameter <code class="literal">componentID</code>. This is so core module knows which instance of <code class="literal">SandBox</code> is making this call and in turn, which component wishes to unsubscribe from the custom event.</p></div><div class="section" title="SandBox module considerations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec36"/>SandBox module considerations</h3></div></div></div><p>There are also a couple of other things that you need to keep mind about <code class="literal">SandBox</code> module. First, <code class="literal">SandBox</code> module<a id="id445" class="indexterm"/> can be designed to only provide a subset of Core module's functionality to the components. This enables us to control what application functionality components can have access to. Second, all the methods of <code class="literal">SandBox</code> module are designed to do a very basic error checking. This filter calls which that have passed the basic level of validation to propagate to Core module.</p><p>Keep in mind that <code class="literal">SandBox</code> module is supposed to be only a thin layer which sits between the components and the rest of the application. Thus, it is best to not do extensive validation at <code class="literal">SandBox</code> module level.</p><p>What constitutes<a id="id446" class="indexterm"/> a thin layer is open to interpretations, but since there could potentially be many instances of <code class="literal">SandBox</code> module in the application, it is best to keep it as thin as possible.</p></div></div></div>
<div class="section" title="Application components"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Application components</h1></div></div></div><p>Considering that our application is a<a id="id447" class="indexterm"/> <span class="strong"><strong>proof of concept</strong></span> type application, we have only implemented four<a id="id448" class="indexterm"/> components; <code class="literal">header</code>, <code class="literal">footer</code>, <code class="literal">content</code>, and <code class="literal">notificationWidget</code> (I'm using the component IDs used in the application).</p><p>These components are<a id="id449" class="indexterm"/> implemented in the following files in the application's project, <code class="literal">ImagesInc_Header.js</code>, <code class="literal">ImagesInc_Footer.js</code>, <code class="literal">ImagesInc_Content.js</code>, and <code class="literal">NotificationWidget.js</code>, respectively.</p><p>In the following sections, I will provide an overview of each component, but I highly recommend that you have a look at the code accompanying this book to get a better understanding of how these components are implemented.</p><p>Keep in mind that our components are modules, which create different application views. In an MVC or MV* architectural pattern paradigm, our components contain their own controllers as well as leveraging the application level controller which has been provided to them through their own instance of <code class="literal">SandBox</code> module. </p><p>The components also implement their own views and each component is only aware of its view in the application.</p><p>While an application level model is present (<code class="literal">ImagesInc_GlobalData</code>), and our components can use the data stored in this application model, each component can also contain its own model. Therefore, each component implements its own MVC or MV* architecture.</p><div class="section" title="Registering components with MainCore module"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec67"/>Registering components with MainCore module</h2></div></div></div><p>We have already talked<a id="id450" class="indexterm"/> about how a component is registered with MainCore module from the MainCore's perspective. It is time to have a look at how this is done at the component's level. </p><p>The mechanism for registering components with the application is always the same, regardless of whether the component is loaded at the application start-up phase or at a later time.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.registerComponent("mainPageContainer", "notificationWidget", function(sandBox){

...
    var widgetMainContainer, stockSnapURL = "https://stocksnap.io";
    
    return {        
        init: function(){
            try{                               
                sandBox.contextObj = this;
                sandBox.logMessage(1,'Notification Widget component has been initialized...', 'blue');
            
            }catch(e){
                sandBox.logMessage(3,'Notification Widget has NOT been initialized correctly --&gt; ' + e.message);
            }
        },
        
        destroy: function(removeComponent){

            sandBox.contextObj.unregisterFromEvents();            
            if(removeComponent){
                sandBox.removeComponentFromDom("widgetContainer");
            }           
            sandBox.logMessage(1,'Notification Widget has been destroyed...', "blue");
        },
...

}</pre></div><p>As you can see, when a component's <code class="literal">.js</code> file is loaded, for instance <code class="literal">notificationWidget</code> shown previously, <code class="literal">registerComponent</code> method of MainCore module is called. Thus, MainCore module needs to be loaded before any component files in the application.</p><p>Since we have talked about how this method is called by a component previously, the following should be just a review for you.</p><p>In the preceding code, when <code class="literal">NotificationWidget.js</code> file is loaded, the <code class="literal">registerComponent</code> method of MainCore module is called with three parameters: <code class="literal">mainPageContainer</code>, which is the ID of the container element that hosts the component's view; <code class="literal">notificationWidget</code>, which is the ID of the<a id="id451" class="indexterm"/> component itself, and a third parameter as a <code class="literal">callback</code> function. When this <code class="literal">callback</code> function is called by MainCore module, it receives an instance of <code class="literal">SandBox</code> module.</p><p>Note that the return object from this callback function is the component's singleton object, which has the required methods <code class="literal">init</code> and <code class="literal">destroy</code>. Of course, these methods are used by the application to initialize and destroy the component instance, respectively. We will talk about these methods more when we talk about <code class="literal">notificationWidget</code> component.</p><p>One other thing to notice here is that we have created a closure in this callback function, so only the returned object from this function has access to the private variables of the component.</p></div><div class="section" title="Header component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec68"/>Header component</h2></div></div></div><p>This component registers itself with Core module using the ID <code class="literal">header</code>, and from that point forward, this ID is<a id="id452" class="indexterm"/> used by the application to reference this component.</p><p>As with all the other components in the application, this component implements the required <code class="literal">init</code> and <code class="literal">destroy</code> methods.</p><p>
<code class="literal">header</code> component also implements methods to attach and remove event handlers, for its elements. The method <code class="literal">handleFavouritesClick</code> is an example of an event handler in this component.</p><p>Consider the implementation of this event handler as follows:</p><div class="informalexample"><pre class="programlisting">handleFavouritesClick: function (e) {
            e.preventDefault();
            e.stopPropagation();
            var favoritedImagesArray = sandBox.getValueAsArrayFromCookie(ImagesInc_GlobalData.getFavCookieName());
            
            if(!favoritedImagesArray){ 
                alert('No favorites have been selected!');
                return;
            }            
            sandBox.publishCustomEvent({
                type: 'favorites-Clicked',
                data: "favorites"
            });
            sandBox.addToHistory({
                url: 'favorites' //update url in the browser
            });            
}</pre></div><p>This method is called when the <span class="strong"><strong>Favorites</strong></span> link of <code class="literal">header</code> component is clicked. It first checks to see if there are any favorite images stored in the browser's cookie. However, this check is not done directly by the component itself, as the call is made to the instance of <code class="literal">SandBox</code> module for this component. </p><p>Notice that <code class="literal">header</code> component has no idea how the mechanism for checking the cookie is implemented, and it<a id="id453" class="indexterm"/> does not need to implement such functionality itself.</p><p>If such mechanism is changed at some point in the future, it makes no difference to this component. The component will always make the same call to the <code class="literal">SandBox</code> module instance and lets the application handle this operation.</p><p>Also note that this method updates the URL in the browser, and publishes a custom event that informs the application of the particular event that has taken place. Of course, the component leverages the application's functionality through the <code class="literal">SandBox</code> module instance to accomplish all these tasks.</p></div><div class="section" title="Footer component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec69"/>Footer component</h2></div></div></div><p>The design of <code class="literal">footer</code> component is<a id="id454" class="indexterm"/> very similar to <code class="literal">header</code> component, and it registers itself with Core module with the ID of <code class="literal">footer</code>.</p><p>One method in the component which we need to have a look at is <code class="literal">hanldeSupportClick</code>. This method is called when the <span class="strong"><strong>Support</strong></span> link of <code class="literal">footer</code> component is clicked. Let's examine the implementation of this method, as follows:</p><div class="informalexample"><pre class="programlisting">handleSupportClick : function(e){            

            sandBox.publishCustomEvent({
                type: 'support-Clicked',
                data: "support"

            });            

            e.preventDefault();
            e.stopPropagation();
}</pre></div><p>As you can see, when the<a id="id455" class="indexterm"/> link is clicked, the custom event <code class="literal">support-Clicked</code> is published. If you recall from an earlier section in this chapter, <code class="literal">NotificationHandler</code> module is listening to this event and will take the required action when this event takes place.</p><p>This is another example which shows, while these pieces of the application are communicating with each other, they are not actually aware of each other's existence. These components are loosely coupled using our publish-subscribe implementation.</p></div><div class="section" title="Content component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec70"/>Content component</h2></div></div></div><p>This component can be considered as the main component of our application and it is responsible for <a id="id456" class="indexterm"/>changing the views of the content area. It registers itself with Core module with the ID of <code class="literal">content</code>.</p><p>The content component <a id="id457" class="indexterm"/>implements the required <code class="literal">init</code> and <code class="literal">destroy</code> methods as well as many other methods.</p><p>We are going to have a look at some of the important ones here.</p><div class="section" title="Handling content area click events"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec37"/>Handling content area click events</h3></div></div></div><p>When a user clicks on<a id="id458" class="indexterm"/> the <span class="strong"><strong>Add to Favorites</strong></span> link in the application or when an image is clicked in the content area, the parent container of the <code class="literal">content</code> component's view captures<a id="id459" class="indexterm"/> the event and processes it.</p><p>The binding for the event handling of the parent container takes place in <code class="literal">init</code> method of <code class="literal">content</code> component as follows:</p><div class="informalexample"><pre class="programlisting">sandBox.addEventHandlerToParent("click", this.handleMainContainerClicked);</pre></div><p>As you can see, <code class="literal">handleMainContainerClicked</code> is the callback method that processes this click event.</p><p>Consider how this <a id="id460" class="indexterm"/>method has been implemented:</p><div class="informalexample"><pre class="programlisting">handleMainContainerClicked: function (e) {
    if (e.target != e.currentTarget) {
        e.preventDefault();
        e.stopPropagation();

            if (e.target.tagName.toUpperCase() === 'IMG') {
                sandBox.contextObj.handleImageClick(e.target);
            } else if (e.target.tagName.toUpperCase() === 'A') {
                sandBox.contextObj.handelFavLinkClick(e.target);
            }
    }
}</pre></div><p>As shown, we check to<a id="id461" class="indexterm"/> see if the click event is taking place on an image or on an anchor tag, and based on this determination, we delegate the rest of the event processing to the associated methods.</p><div class="section" title="Handling the Add To Favorite link click event"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec20"/>Handling the Add To Favorite link click event</h4></div></div></div><p>In <code class="literal">handelFavLinkClick</code> method, we check the state of the <span class="strong"><strong>Add to Favorites</strong></span> link and <a id="id462" class="indexterm"/>change its text to <span class="strong"><strong>Remove from Favorites</strong></span>. If the link has already been clicked, and it contains the text <span class="strong"><strong>Remove from Favorites</strong></span>, we re-set the text to its default value of <span class="strong"><strong>Add to Favorites</strong></span>.</p><p>We also add or remove the ID of the favorite image in the browser's cookie, so when the user navigates to the <span class="strong"><strong>Favorites</strong></span> page, the correct favorite images are rendered in the content area.</p><p>Consider the implementation of this method:</p><div class="informalexample"><pre class="programlisting">handelFavLinkClick: function (elem) {
    var anchorState, parentNode, anchorID;
    anchorState = elem.getAttribute('data-state');
    anchorID = elem.getAttribute('id');
    parentNode = sandBox.getParentNode(elem);

    if (anchorState) {
        sandBox.removeValueFromCookie(favCookieName,anchorID);
        sandBox.updateElement(parentNode, sandBox.contextObj.getAnchorHTMLStr(anchorID));

    } else {
        sandBox.populateCookie(favCookieName,anchorID);
        sandBox.updateElement(parentNode, sandBox.contextObj.getAnchorHTMLStr(anchorID, true));
    }
    sandBox.publishCustomEvent({
        type: 'FavLink-Clicked',
        data: anchorID
    });
},</pre></div><p>As you can see, there is<a id="id463" class="indexterm"/> also one other thing that we do in this method, which is to broadcast the related custom event to the application. This allows all the other pieces of the application which are registered for this event to be informed of the event taking place in this component.</p></div><div class="section" title="Handling an image click event"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec21"/>Handling an image click event</h4></div></div></div><p>When an image is clicked in the <a id="id464" class="indexterm"/>content area of the application, the following method is called:</p><div class="informalexample"><pre class="programlisting">handleImageClick: function (elem) {
            var imgName;

            imgName = elem.getAttribute('data-name');
            sandBox.publishCustomEvent({
                type: 'img-Clicked',
                data: imgName
            });
            sandBox.addToHistory({
                url: imgName
            });
}</pre></div><p>Notice that this method does two main things. One is to update the history object of the browser so that the application router can work properly when the user clicks on the back and forward buttons of the browser. The second is to broadcast the message <code class="literal">img-Clicked</code> to the application.</p><p>The interesting point to consider is that our <code class="literal">content</code> component itself listens to this event and acts on this event to update the page view, using the following event registration method:</p><div class="informalexample"><pre class="programlisting">registerForCustomEvents : function(){
          
      sandBox.registerForCustomEvents({
            'img-Clicked': this.updateContentPage, 
       'page-Changed': this.updateContentPage,
             'favourites-Clicked':this.updateContentPage
      });            
}</pre></div><p>As you can see, when <code class="literal">img-Clicked</code> event is received by <code class="literal">content</code> component (which itself had generated), then <code class="literal">updateContentPage</code> method of this component is called.</p><p>Of course, we could <a id="id465" class="indexterm"/>have directly updated the view of the page in <code class="literal">handleImageClick</code> method, but by broadcasting the event at the application level, we can be sure that all the pieces of the application, including <code class="literal">content</code> component itself, can take action upon the broadcast of this event.</p></div></div><div class="section" title="Content area generator methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec38"/>Content area generator methods</h3></div></div></div><p>
<code class="literal">content</code> component also has methods which are responsible for generating the content area of the page, based <a id="id466" class="indexterm"/>on the URL of the browser. The following is a summary of such methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">buildFavouritesPage</code>: This<a id="id467" class="indexterm"/> method loads the related CSS file for the Favorites page (using the <code class="literal">SandBox</code> module instance) and then renders this page based on the number of the favorite images previously selected by the user</li><li class="listitem" style="list-style-type: disc"><code class="literal">buildIndexContentHTML</code>: As the name implies, this method is responsible for building HTML tags for the <a id="id468" class="indexterm"/>content area of <code class="literal">index.html</code> page</li><li class="listitem" style="list-style-type: disc"><code class="literal">buildImagePageHTML</code>: The full <a id="id469" class="indexterm"/>view of the clicked image is rendered using this method</li><li class="listitem" style="list-style-type: disc"><code class="literal">getAnchorHTMLStr</code>: This <a id="id470" class="indexterm"/>method generates the related link for each image so the image can be added or removed from the favorite images list, based on the state of the link</li></ul></div><p>I highly recommend that you have a look at the code for this component to see how these methods are implemented.</p></div></div><div class="section" title="NotificationWidget component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec71"/>NotificationWidget component</h2></div></div></div><p>When this component is<a id="id471" class="indexterm"/> loaded, it registers itself as <code class="literal">notificationWidget</code> with core module.</p><p>We talked about this component previously and while its design is similar to all the other components in the application, there are some differences.</p><p>As mentioned before, this component is not loaded or rendered at the application's start-up phase. It is loaded and rendered dynamically only when needed, based on the user's interaction with<a id="id472" class="indexterm"/> the application. </p><div class="section" title="NotificationWidget's model"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec39"/>NotificationWidget's model</h3></div></div></div><p>This component's view is<a id="id473" class="indexterm"/> stored as a string in the component itself, as follows:</p><div class="informalexample"><pre class="programlisting">var widgetInnerHTMLStr = '&lt;div id="notificationMainContainer"&gt;' +
        '&lt;h1 class="centerElem header"&gt;Thank you for visiting us.&lt;/h1&gt;' +
        '&lt;h3 class="centerElem header"&gt;All the images on this site are provided by &lt;a href="https://stocksnap.io"&gt;stocksnap.io&lt;/a&gt;.&lt;/h3&gt;' +
        '&lt;h3 class="centerElem header"&gt;We thank them and encourage you to visit their site.&lt;/h3&gt;' +
        '&lt;div class="buttonContainer"&gt;' +
            '&lt;div class="button button-left" id="notification_visit"&gt;Visit stocksnap.io&lt;/div&gt;' +
            '&lt;div class="button button-right" id="notification_close"&gt;Close&lt;/div&gt;' +
        '&lt;/div&gt;' +
    '&lt;/div&gt;';</pre></div><p>This string is passed by the component to MainCore module to render its view. You will see how this is done very shortly.</p></div><div class="section" title="Required methods of the notificationWidget component"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec40"/>Required methods of the notificationWidget component</h3></div></div></div><p>As mentioned previously, each<a id="id474" class="indexterm"/> component needs to implement the required methods: <code class="literal">init</code> and <code class="literal">destroy</code>.</p><p>Have a look at the following <code class="literal">init</code> method of <code class="literal">notificationWidget</code> component as follows:</p><div class="informalexample"><pre class="programlisting"> init: function(){
            try{                               
                sandBox.contextObj = this;
                sandBox.logMessage(1,'Notification Widget component has been initialized...', 'blue');
            
            }catch(e){
                sandBox.logMessage(3,'Notification Widget has NOT been initialized correctly --&gt; ' + e.message);
            }
}</pre></div><p>When the application calls <code class="literal">init</code> method of a component, in this case <code class="literal">notificationWidget</code>, a new property is added to the instance of <code class="literal">SandBox</code> module that was passed to the component. This property is <code class="literal">contextObj</code> and its value is set to <code class="literal">this</code>.</p><p>In this context, <code class="literal">this</code> is<a id="id475" class="indexterm"/> a reference to the component itself and is assigned to the <code class="literal">SandBox</code> instance so we can have an easy way to access the context of the component when we need to. This property is particularly useful for our event handler callbacks in the component.</p><p>Consider the following code snippet from <code class="literal">notificationWidget</code> component:</p><div class="informalexample"><pre class="programlisting">handleCloseClick : function(){
            sandBox.contextObj.unregisterFromEvents();
            sandBox.removeComponentFromDom("widgetContainer");
} </pre></div><p>This callback function is called when the user clicks on the <span class="strong"><strong>Close</strong></span> button of the dialogue box which is the view for <code class="literal">notificationWidget</code> component. You might wonder why we are not calling the component's internal method from the callback function as:</p><div class="informalexample"><pre class="programlisting">this.unregisterFromEvents();</pre></div><p>For the above function call to succeed, the callback function needs to run in the context of the component. However, since the context of <code class="literal">this</code> is set at the time of code execution to the object that calls this callback function, and not the component, we are not be able to call the component's internal methods using <code class="literal">this</code>.</p><p>Thus, by setting the property <code class="literal">contextObj</code> on the <code class="literal">SandBox</code> instance, we are able to easily access the original context of the component and call the required internal method as:</p><div class="informalexample"><pre class="programlisting">sandBox.contextObj.unregisterFromEvents();</pre></div><p>Of course, we could also use JavaScript's <code class="literal">bind()</code> method to achieve the same context preservation but I have<a id="id476" class="indexterm"/> used this approach instead, so you can see a different way of resolving this issue.</p><p>The <code class="literal">destroy</code> method of the component is used to make it inactive (no events on the component will be processed) or to completely remove the component from the DOM.</p><p>Consider destroy method implementation of <code class="literal">notificationWidget</code>, as follows:</p><div class="informalexample"><pre class="programlisting">destroy: function(removeComponent){

            sandBox.contextObj.unregisterFromEvents();
            
            if(removeComponent){
                sandBox.removeComponentFromDom("widgetContainer");
            }
            
      sandBox.logMessage(1,'Notification Widget has been destroyed...', "blue");

},</pre></div><p>Depending on the value of <code class="literal">removeComponent</code> flag(<code class="literal">true</code> or <code class="literal">false</code>), which is passed to this method, the component is either disabled or completely removed from the DOM.</p><p>Note that in the above code, the component uses its instance of <code class="literal">SandBox</code> module to remove itself from the DOM and it does not need to implement such functionality itself. This allows the component to only focus on its own specialized tasks and leverage the functionality provided by the application (through the <code class="literal">SandBox</code> instance). This design also limits the component's access to the world beyond its own so we can minimize possible DOM manipulation conflicts, as described in the previous chapter.</p></div></div><div class="section" title="Rendering notificationWidget"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec72"/>Rendering notificationWidget</h2></div></div></div><p>This component is<a id="id477" class="indexterm"/> rendered when <code class="literal">NotificationHandler</code> calls the render method of the component, as follows:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.getComponentByID("notificationWidget").renderWidget();</pre></div><p>Consider the implementation of this method, as shown here:</p><div class="informalexample"><pre class="programlisting">renderWidget : function(){

    var generatedWidget;

    generatedWidget = sandBox.createDocumentLevelComponent(widgetInnerHTMLStr);
     
    generatedWidget.id = "widgetContainer";
     sandBox.setElementContext(generatedWidget.id);
     this.registerForEvents();  
},</pre></div><p>The component uses a method on its instance of <code class="literal">SandBox</code> module to create a document level component (itself), in the following line of code:</p><div class="informalexample"><pre class="programlisting">generatedWidget = sandBox.createDocumentLevelComponent(widgetInnerHTMLStr);</pre></div><p>In turn, from the<a id="id478" class="indexterm"/> <code class="literal">SandBox</code> module instance, the following method on Core module is called:</p><div class="informalexample"><pre class="programlisting">var createDocumentLevelComponent = function(compnentViewStr){
    var mainComponentContainer;
 
    mainComponentContainer =  document.createElement("DIV");
      mainComponentContainer.innerHTML = compnentViewStr;
      document.body.appendChild(mainComponentContainer);
 
    return mainComponentContainer;
            
};</pre></div><p>And a reference to the rendered component's view is passed back from Core module to <code class="literal">renderWidget</code> method of the component object. The rendered component's view is then tagged with an ID and its context is set on the <code class="literal">SandBox</code> module instance, as follows:</p><div class="informalexample"><pre class="programlisting">generatedWidget.id = "widgetContainer";
sandBox.setElementContext(generatedWidget.id);</pre></div><p>Note that it is only at this stage that the component registers for events. This is different than other components in the application, which register for events when they are initialized. The reason is because when <code class="literal">init</code> method of this component is called, the component's view has not yet been rendered on the page. Therefore, there are no HTML elements for this component's view to attach events to. It is only after the rendering of the component's view that we can attach the required event handlers to the elements.</p><p>This widget is an<a id="id479" class="indexterm"/> example of how we can render and activate components in the application at any time, after the start-up phase.</p></div></div>
<div class="section" title="GlobalData module"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>GlobalData module</h1></div></div></div><p>As the name implies, this<a id="id480" class="indexterm"/> module is designed to store application level data and act as the model for our application. It also provides public methods so that other modules can get and set data in this module. This module is defined as <code class="literal">ImagesInc_GlobalData</code> global variable in the application..</p><p>The following shows a snippet of the kind of data that the module stores:</p><div class="informalexample"><pre class="programlisting">    var favCookieName = "Images_Inc", 
        pageDefintionsFile = "PageDefinitions.js", 
        pageDefinitionsFilePath = "js/Modules/PageDefinitions/",
...</pre></div><p>This module is augmented with a sub-module <code class="literal">ImagesInc_PageSections</code>, which stores HTML markup strings related to <code class="literal">header</code> and <code class="literal">footer</code> components.</p><p>It is worth looking at how this sub-module is added to <code class="literal">GlobalData</code> module.</p><div class="informalexample"><pre class="programlisting">var ImagesInc_GlobalData = ImagesInc_GlobalData || null;

var ImagesInc_PageSections = (function(mainModule, subModule){
 // assigning the subModule if it is passed in and also augmenting sub-module
    var pageSections = mainModule.pageSections = mainModule.pageSections || subModule;
     
...

 })(ImagesInc_GlobalData || {}, ImagesInc_PageSections || {} ); // using Asynchronous sub-module</pre></div><p>As you can see, we are using asynchronous sub-module augmentation technique to add the sub-module to <code class="literal">GlobalData</code> module.</p><p>This technique allows us to load <code class="literal">GlobalData</code> and its related sub-module (<code class="literal">ImagesInc_PageSections</code>) in any order that we desire without affecting the module's augmentation. The augmentation is different in comparison to how we added sub-modules to MainCore module in the application, as they could only be added to MainCore module after it was loaded.</p><p>Notice that we create the sub-module if it does not exist in the application when we execute the IIFE, as shown:</p><div class="informalexample"><pre class="programlisting">(ImagesInc_GlobalData || {}, ImagesInc_PageSections || {} );</pre></div><p>Asynchronous sub-module <a id="id481" class="indexterm"/>augmentation also allows us to augment the sub-module itself, if it already exists in the application. The augmentation is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">var pageSections = mainModule.pageSections = mainModule.pageSections || subModule;

    pageSections.headerContainerDefObj = {
 
    sectionHTML :  '&lt;div id="logoDiv" class="logo_titleClass" &gt;' +
...

}</pre></div><p>Admittedly, this technique is a little more complex than the other augmentation techniques that we have used elsewhere in the application but it does provide a greater degree of flexibility.</p><p>I encourage you to have a look at the code related to this sub-module (<code class="literal">GlobalData_Sub.js</code>) to get a better understanding of how the technique works.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we had a closer look at our application's implementation and saw how all the pieces fit and work together to create our modular ecosystem, at the code level.</p><p>We examined how Core module (our application's controller) was created by leveraging different augmentation techniques and adding sub-modules to MainCore module. This approach allowed us to extend our application's capabilities with ease and in a modular way.</p><p>By creating instances of <code class="literal">SandBox</code> module, we established communication bridges among the components and the rest of the application while preserving the loose coupling principle of our design.</p><p>One important aspect of our application, is the ability to load components dynamically and we discussed how such functionality has been implemented in our Core module.</p><p>Using the publish-subscribe and mediator patterns, we created an event handing mechanism which all the pieces of the application can use to communicate with each other. This mechanism was also used in our client side router to change the views of the application.</p><p>At the end of the chapter, we created a global module to store our application level data and act as the model piece of our MV* design.</p><p>In the next chapter, we will discuss testing of our application's modules and will see how unit testing can help us maintain the integrity of our application during its development and operational phases.</p></div></body></html>