<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Persisting Data</h1></div></div></div><p>Most applications need to persist some kind of data. In this chapter, we'll be looking at some approaches to data persistence for Node.js applications.</p><p>The default choice for persistence for a long time has been the traditional relational database. You may have <a id="id326" class="indexterm"/>used <strong>RDBMS</strong>s (relational database management systems) such as Microsoft SQL Server, Oracle, MySQL or PostgreSQL. These systems are often categorized as <em>SQL databases</em> since they all use SQL as their primary query language.</p><p>More recently, there has been <a id="id327" class="indexterm"/>a proliferation of so-called <strong>NoSQL</strong> databases. This umbrella term isn't particularly useful as a category. Some NoSQL databases have no more in common with each other than with traditional relational databases.</p><p>What's interesting is the range of databases available and the use cases they fulfil. Traditional RDBMSs are as powerful and flexible as ever and the right choice for many situations. In this chapter, we'll consider two other types of database, along with how and when to make use of them.</p><p>The systems we'll be looking at <a id="id328" class="indexterm"/>are <strong>MongoDB</strong> and <strong>Redis</strong>. Both of these had their initial release in 2009 and are<a id="id329" class="indexterm"/> now widely-used. Covering either of them in depth would justify a book in itself. The aim of this chapter is to provide an introduction to and high-level overview of each.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">The conceptual data model used by each of these systems</li><li class="listitem">The use cases for which they provide the most benefit</li><li class="listitem">Integrating them with an Express application</li><li class="listitem">Testing data persistence code</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec45"/>Introducing MongoDB</h1></div></div></div><p>MongoDB is <a id="id330" class="indexterm"/>a <strong>document-oriented</strong> DBMS. MongoDB documents<a id="id331" class="indexterm"/> are stored as <strong>binary JSON</strong> (<strong>BSON</strong>). This is similar to JSON, but with support for additional data types. JSON field values can only be<a id="id332" class="indexterm"/> strings, numbers, objects, arrays, Booleans, or null. BSON supports more specific numeric types, dates and timestamps, regular expressions, and binary data. As the name suggests, BSON documents are stored and transferred as binary data. This can be more efficient than JSON's string representation.</p><p>MongoDB documents are <a id="id333" class="indexterm"/>stored in <strong>collections</strong>. These work very much like tables in a traditional relational database. Documents can be inserted, updated, and queried. There are two key differences from a traditional relational database:</p><div><ul class="itemizedlist"><li class="listitem">MongoDB does not support server-side joins. In a traditional RDBMS, you would normalize data into multiple tables and join across them using foreign keys. In MongoDB, you instead use BSON's nested structure to denormalize data about each entity into a single document.</li><li class="listitem">The <em>relational</em> property<a id="id334" class="indexterm"/> of a relational database is that all rows in a table contain the same fields with the same meaning. In MongoDB, documents can have any set of fields.</li></ul></div><p>In practice, documents in the same collection typically have the same fields or at least a common core set of fields. MongoDB supports the creation of indexes on common fields in a collection to make querying more efficient.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Why choose MongoDB?</h2></div></div></div><p>There are <a id="id335" class="indexterm"/>several properties of MongoDB that make it an appealing choice for some use cases, especially in Node.js-based applications. We'll cover these in this section.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec10"/>Object modeling</h3></div></div></div><p>MongoDB's <a id="id336" class="indexterm"/>document-based approach can be a good fit for <a id="id337" class="indexterm"/>persisting domain entities. You may have experience of storing domain entities in a relational database using an <strong>Object-Relational Mapper </strong>(<strong>ORM</strong>). Hibernate and Entity Framework are popular examples of ORMs. One of the jobs <a id="id338" class="indexterm"/>performed by an ORM is mapping a single entity to multiple tables in a normalized schema. When an entity is loaded from the database, it is reconstructed via <code class="literal">JOIN</code> queries between these tables. This is one of the key features of ORMs. It is also one of the most common sources of configuration problems and performance issues when using an ORM. MongoDB persists each entity as a single document, which can be much simpler.</p><p>Of course, cross-table joins can also be useful for traversing relationships between entities. While ORMs typically make this easy, this can itself be a source of performance problems. Implicit loading of related entities often causes <em>N+1</em> problems, issuing thousands of DB queries. Handling these relationships well requires careful thought, whatever kind <a id="id339" class="indexterm"/>of database you are using.</p><p>When using an ORM <a id="id340" class="indexterm"/>and an RDBMS, all inter-entity relationships are foreign keys, but you need to think carefully about how to load them. When modeling data in MongoDB, you must choose between embedded documents or document references for inter-entity relationships. Under either tech stack, the design decisions depend on the data access requirements of your application and designing the data model to reduce the prevalence of inter-entity relationships will simplify matters.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec11"/>JavaScript</h3></div></div></div><p>MongoDB is<a id="id341" class="indexterm"/> a good fit for Node.js in particular. The use of a JSON-like format <a id="id342" class="indexterm"/>maps well to a JavaScript-based programming environment. MongoDB itself also runs JavaScript natively. Database operations can make use of custom JavaScript functions that execute on the server.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec12"/>Scalability</h3></div></div></div><p>MongoDB also<a id="id343" class="indexterm"/> scales in a similar manner to Node.js. It uses partitioning and replication to support horizontal scaling on commodity hardware. There is no technical reason why your application and database have to scale in the same way, but it may be easier to plan for scalability from a business perspective.</p><p>When using an RDBMS, it is more straightforward to scale the database vertically. That means provisioning a high-powered database server that can support multiple application servers. This requires more careful planning and more up-front investment than linearly scaling application and database servers horizontally together.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec47"/>Getting started with MongoDB</h2></div></div></div><p>Visit <a class="ulink" href="https://www.mongodb.org/downloads">https://www.mongodb.org/downloads</a> to download and install the latest version of the <a id="id344" class="indexterm"/>MongoDB Community Server edition for your operating system. There <a id="id345" class="indexterm"/>are more detailed installation instructions in the user manual at <a class="ulink" href="https://docs.mongodb.org/manual/installation/">https://docs.mongodb.org/manual/installation/</a>.</p><p>The commands in the rest of this section make use of executables in MongoDB's <code class="literal">/bin</code> directory. You can run the commands in this directory or, better still, add it to your <code class="literal">PATH</code>.</p><p>Create a <a id="id346" class="indexterm"/>directory for MongoDB to store its data. Then start the MongoDB daemon process (that is, service), providing the path of that directory as follows:</p><div><pre class="programlisting"><strong>&gt; mongod --dbpath C:\data\mongodb</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec13"/>Using the MongoDB shell</h3></div></div></div><p>You can<a id="id347" class="indexterm"/> interact with MongoDB from the console using its built-in shell application. You can launch the MongoDB shell by running the <code class="literal">mongo</code> command, as follows:</p><div><pre class="programlisting"><strong>&gt; mongo demo</strong>
</pre></div><p>This will connect to a database named <code class="literal">demo</code> (creating it, if necessary) on the local server. If you don't specify a database, then the shell connects to a database named <code class="literal">test</code>.</p><p>The first thing to notice is that the shell is just another JavaScript environment. We can try running some of the same commands as at the beginning of <a class="link" title="Chapter 2. Getting Started with Node.js" href="part0018.xhtml#aid-H5A41">Chapter 2</a>, <em>Getting Started with Node.js</em>.</p><div><pre class="programlisting"><strong>&gt; function square(x) { return x*x; }</strong>
<strong>&gt; square(42)</strong>
<strong>1764</strong>
<strong>&gt; new Date()</strong>
<strong>ISODate("2016-01-01T20:05:39.652Z")</strong>
<strong>&gt; var foo = { bar: "baz" }</strong>
<strong>&gt; typeof foo</strong>
<strong>object</strong>
<strong>&gt; foo.bar</strong>
<strong>baz</strong>
</pre></div><p>Just as Node.js builds on JavaScript in ways that make it more suitable for server-side application development, MongoDB adds features more useful to data persistence. Note that <code class="literal">new Date()</code> in the preceding code returns an ISODate, MongoDB's standard datatype for representing dates in BSON documents.</p><p>You can quit the console by typing <code class="literal">exit</code> at any time.</p><p>MongoDB also adds some new global variables for interacting with the database. The most important of these is the <code class="literal">db</code> object. Let's try adding some documents to our database. Recall that MongoDB stores documents in collections. To create a new collection, we just need to start inserting documents into it. For a simple example, we'll use the UK bank holidays for 2016. We can populate this collection using the following script:</p><div><pre class="programlisting">db.holidays.insert(
  { name: "New Year's Day", date: ISODate("2016-01-01") });
db.holidays.insert(
  { name: "Good Friday", date: ISODate("2016-03-25") });
db.holidays.insert(
  { name: "Easter Monday", date: ISODate("2016-03-28") });
db.holidays.insert(
  { name: "Early May bank holiday", date: ISODate("2016-05-02") });
db.holidays.insert(
  { name: "Spring bank holiday", date: ISODate("2016-05-30") });
db.holidays.insert(
  { name: "Summer bank holiday", date: ISODate("2016-08-29") });
db.holidays.insert(
  { name: "Boxing Day", date: ISODate("2016-12-26") });
db.holidays.insert(
  { name: "Christmas Day", date: ISODate("2016-12-27"),
    substitute_for: ISODate("2016-12-25") });</pre></div><p>Note that<a id="id348" class="indexterm"/> Christmas Day falls on a Sunday in 2016, so the bank holiday occurs on the next working day. This gives us a reason to have another field that is only relevant to some documents in the collection.</p><p>You could type these <code class="literal">insert</code> commands into the console manually, but it's easier to tell MongoDB to load them from a script file:</p><div><pre class="programlisting"><strong>&gt; mongo demo holidays.js --shell</strong>
</pre></div><p>The previous command connects to a database named demo, runs the <code class="literal">holiday.js</code> script (available in the book's companion code), then opens a shell to allow us to interact with the database. We can view the complete contents of the collection by running the following command in the MongoDB console:</p><div><pre class="programlisting"><strong>&gt; db.holidays.find()</strong>
<strong>{ "_id" : ObjectId("572f760fffb6888d70c45eeb"), "name" : "New Year's Day", "date" : ISODate("2016-01-01T00:00:00Z") }</strong>
<strong>{ "_id" : ObjectId("572f7610ffb6888d70c45eec"), "name" : "Good Friday", "date" : ISODate("2016-03-25T00:00:00Z") }</strong>
<strong>...</strong>
</pre></div><p>Note that MongoDB has automatically added an <code class="literal">_id</code> field to each document for us.</p><div><h3 class="title"><a id="tip07"/>Tip</h3><p>You can see how MongoDB does this by viewing the source of the <code class="literal">insert</code> method. Just type <code class="literal">db.holidays.insert</code> into the shell (with no parentheses).</p></div><p>We can pull out records by their <code class="literal">_id</code> or other single fields:</p><div><pre class="programlisting"><strong>&gt; db.holidays.find({name: "Boxing Day"})</strong>
</pre></div><p>This will return any objects that match the object passed to <code class="literal">find</code>. To look up documents by something other than exact equality, we can use MongoDB's query operators. These are prefixed with the dollar symbol and specified as object properties. For example, to find holidays in the second half of the year, we can use the <em>greater than or equal to </em>operator as follows:</p><div><pre class="programlisting"><strong>&gt; db.holidays.find({ date: { $gte: new Date("2016-07-01") }})</strong>
</pre></div><p>MongoDB's <strong>aggregation pipeline</strong><a id="id349" class="indexterm"/> allows us to build complex queries from a sequence <a id="id350" class="indexterm"/>of operations called <strong>pipeline stages</strong>. It is the closest thing in MongoDB to complex querying in SQL. Here, we count the number of bank holidays in each month using MongoDB's <code class="literal">$group</code> pipeline stage, which is similar to SQL's <code class="literal">GROUP BY</code> clause:</p><div><pre class="programlisting"><strong>&gt; db.holidays.aggregate({</strong>
<strong>    $group: { _id: { $month: "$date" }, count: { $sum: 1 } }})</strong>
</pre></div><p>An odd quirk <a id="id351" class="indexterm"/>of the calendar in 2016 means that the Christmas Day Bank Holiday actually comes after Boxing Day (since Christmas Day itself is on a Sunday). In the following example, we order bank holidays by the date of the occasion that they mark (stored in the <code class="literal">$substitute_for</code> field if different from the date of the bank holiday):</p><div><pre class="programlisting"><strong>&gt; db.holidays.aggregate([</strong>
<strong>    { $project: { _id: false, name: "$name",</strong>
<strong>          date: { $ifNull: ["$substitute_for", "$date"] } } },</strong>
<strong>    { $sort: { date: 1 } }</strong>
<strong>])</strong>
</pre></div><p>The previous pipeline consists of two stages:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">$project</code> stage specifies a set of fields based on the underlying data (similar to <code class="literal">SELECT</code> in SQL). Note that the <code class="literal">_id</code> field is included by default, but we exclude it here.</li><li class="listitem">The <code class="literal">$sort</code> stage specifies a sort field and direction (similar to SQL's <code class="literal">SORT BY</code> clause). The <code class="literal">1</code> here indicates an ascending sort order.</li></ul></div><p>We have just scratched the surface here. There are many more pipeline phases available in MongoDB. You<a id="id352" class="indexterm"/> can find out more about aggregation in the MongoDB documentation at <a class="ulink" href="https://docs.mongodb.com/manual/core/aggregation-pipeline/">https://docs.mongodb.com/manual/core/aggregation-pipeline/</a>.</p><p>MongoDB also has<a id="id353" class="indexterm"/> a built-in Map-Reduce function for powerful aggregate data processing using arbitrary JavaScript functions. This is beyond the scope of this book, but you can find out more about Map-Reduce and MongoDB's implementation <a id="id354" class="indexterm"/>of it at <a class="ulink" href="https://docs.mongodb.com/manual/core/map-reduce/">https://docs.mongodb.com/manual/core/map-reduce/</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Using MongoDB with Express</h1></div></div></div><p>The games<a id="id355" class="indexterm"/> service module in our application currently<a id="id356" class="indexterm"/> stores all its data in memory. This worked well enough for demo purposes, but isn't suitable for a real application. We lose all the data whenever the application restarts. It also prevents us from scaling our application across multiple processes. Each instance would have its own game service with different<a id="id357" class="indexterm"/> data. Users would see different data depending <a id="id358" class="indexterm"/>on which server happened to handle their request.</p><p>We're going to update our games service to store its data in MongoDB. For this, we're going to make use of a library <a id="id359" class="indexterm"/>called <strong>Mongoose</strong>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec48"/>Persisting objects with Mongoose</h2></div></div></div><p>Recall that, unlike a relational database, MongoDB does not require documents in the same collection<a id="id360" class="indexterm"/> to have the same fields. However, we do typically<a id="id361" class="indexterm"/> expect most items within a collection to share at least a common core of fields.</p><p>Mongoose is an object modeling library for storing entities in MongoDB. It helps with writing common functionality such as validation, query building, and type casting. It also provides hooks for associating business logic with our entities. These are similar to some of the features provided by ORMs such as Entity Framework or Hibernate. Mongoose itself is not an ORM, though. Recall that object-relational mapping is not relevant for document-oriented databases such as MongoDB.</p><p>To use Mongoose, we start by defining<a id="id362" class="indexterm"/> a <strong>schema</strong>. This defines the common fields for documents within a MongoDB collection. Returning to our demo application from the preceding chapters, let's install Mongoose and define a schema for our games collection:</p><div><pre class="programlisting"><strong>&gt; npm install mongoose --save</strong>
</pre></div><p>The following code is added to <code class="literal">src/services/games.js</code>:</p><div><pre class="programlisting">'use strict';

<strong>const mongoose = require('mongoose');</strong>

<strong>const Schema = mongoose.Schema;</strong>
<strong>const gameSchema = new Schema({</strong>
<strong>    word: String,</strong>
<strong>    setBy: String</strong>
});</pre></div><p>The schema defines document fields and specifies the type of each field. To start persisting documents with this schema, we need to <a id="id363" class="indexterm"/>create a <strong>model</strong>.</p><p>Models are constructors that correspond to a MongoDB collection. Instances of a Mongoose model correspond to documents in that collection. Models also provide functions for modifying the collection. We create a model by specifying the schema and (singular) collection name:</p><div><pre class="programlisting">const gameSchema = new Schema({
    word: String,
    setBy: String
});

<strong>const Game = mongoose.model('Game', gameSchema);</strong>
</pre></div><p>The Model <a id="id364" class="indexterm"/>constructor replaces our Game class and <a id="id365" class="indexterm"/>constructor from before. This class also contained two instance methods: <code class="literal">positionsOf</code> and <code class="literal">remove</code>. We can define custom instance methods on a schema, which will be available on all model instances. These must be defined before creating the model:</p><div><pre class="programlisting">const gameSchema = new Schema({
    word: String,
    setBy: String
});

<strong>gameSchema.methods.positionsOf = function(character) {</strong>
<strong>    let positions = [];</strong>
<strong>    for (let i in this.word) {</strong>
<strong>        if (this.word[i] === character.toUpperCase()) {</strong>
<strong>            positions.push(i);</strong>
<strong>        }</strong>
<strong>    }</strong>
<strong>    return positions;</strong>
<strong>};</strong>

const Game = mongoose.model('Game', gameSchema);</pre></div><div><h3 class="title"><a id="note13"/>Note</h3><p>Note that we use a traditional function definition rather than an arrow function in the preceding code. This is necessary in order for the <code class="literal">this</code> keyword inside the function to work correctly. See <a class="ulink" href="http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/">http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/</a> for more details.</p></div><p>We don't need to define a <code class="literal">remove</code> method anymore, because Mongoose provides this automatically. It also provides a <code class="literal">save</code> method, which we can use for persisting new games:</p><div><pre class="programlisting">const Game = mongoose.model('Game', gameSchema);

module.exports.create = (userId, word) =&gt; {
<strong>  let game = new Game({setBy: userId, word: word.toUpperCase()});</strong>
<strong>  return game.save();</strong>
};</pre></div><p>We don't need to specify an ID anymore, since this is also provided by Mongoose. Note that we do <a id="id366" class="indexterm"/>need to specify <code class="literal">word.toUpperCase()</code>, which used to<a id="id367" class="indexterm"/> be in the Game constructor. This isn't a problem, since the constructor is private to our module. No code outside the module can invoke the constructor directly. Where the <code class="literal">toUpperCase</code> call takes place is just an implementation detail.</p><p>Also note that Mongoose's async operations all return promises as an alternative to using callbacks. Mongoose supports both of the asynchronous programming patterns discussed in the previous chapter. Mongoose uses its own implementation of promises. We can configure Mongoose to use ECMAScript 6 promises, though. We also need to tell Mongoose to connect to a MongoDB database. For now, we will hardcode the URL, but we'll see how to make this configurable shortly:</p><div><pre class="programlisting">const mongoose = require('mongoose');
<strong>mongoose.Promise = Promise;</strong>
<strong>mongoose.connect('mongodb://localhost/hangman');</strong>
</pre></div><p>Finally, we need to implement our three methods for retrieving games from the database. We can do this using Mongoose's <code class="literal">find</code> method:</p><div><pre class="programlisting">module.exports.create = (userId, word) =&gt; {
    ...
};
<strong>module.exports.createdBy =</strong>
<strong>    (userId) =&gt; Game.find({setBy: userId});
module.exports.availableTo =</strong>
<strong>    (userId) =&gt; Game.find({setBy: { $ne: userId } });
module.exports.get =</strong>
<strong>    (id) =&gt; Game.findById(id);</strong>
</pre></div><p>The Mongoose <code class="literal">find</code> method works like the MongoDB <code class="literal">find</code> method we saw in the previous section, <em>Using the MongoDB shell</em>. It takes a set of MongoDB query conditions and asynchronously provides a list of documents. <code class="literal">findById</code> takes an ID and asynchronously provides a single document, or null.</p><p>Mongoose also provides a <code class="literal">where</code> method for building up conditions through function calls. The <code class="literal">availableTo</code> function can be rewritten as follows:</p><div><pre class="programlisting">module.exports.availableTo =
  (userId) =&gt; Game.where('setBy').ne(userId);</pre></div><p>As long as you still have MongoDB running locally (as described in <em>Getting started with MongoDB</em> earlier in the chapter), you should now be able to run the application. Try stopping and restarting the application and notice that games are now persisted between restarts.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec49"/>Isolating persistence code</h2></div></div></div><p>It's useful to integrate with a real database to make sure our persistence code is working. But it's not always appropriate for our tests to be dependent on an external MongoDB instance.</p><p>We want developers to be able to check out the code and run the application without needing to run a<a id="id368" class="indexterm"/> database instance. Also, external dependencies slow down our tests. MongoDB stores data on disk, so introduces additional I/O work into our tests.</p><p>The application should depend on an external database in production. In integration, we want to use a real database on the local server. On development machines, it would be better to use an in-memory database by default. So we need to be able to configure a database URL and fall back to an in-memory database in development environments.</p><p>Finally, we need to initialize Mongoose before using it in our games service. This includes specifying the database URL and waiting for a connection to be established. This happens asynchronously, so can't be part of the games service module definition. We also don't want clients of the games service to have to pass in a Mongoose instance to each function call.</p><p>We can address all of these issues by introducing dependency injection to our application. We'll pass in the game service as a dependency to the modules that need it and pass in Mongoose as a dependency to the games service.</p><div><h3 class="title"><a id="tip08"/>Tip</h3><p>This would also give us the option of writing unit tests for other modules that pass in a test double for the games service itself, so don't use MongoDB at all. In larger applications, this kind of test isolation is important for writing fast and maintainable tests.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec50"/>Dependency injection in Node.js</h2></div></div></div><p>You may have used <strong>dependency injection</strong> (<strong>DI</strong>) frameworks such as Unity, Autofac, NInject, or Spring in .NET or Java. These provide features such as declarative configuration<a id="id369" class="indexterm"/> and auto wiring of dependencies. There are similar DI containers available for JavaScript. However, it is more common to <a id="id370" class="indexterm"/>pass around dependencies <a id="id371" class="indexterm"/>explicitly. JavaScript's module pattern makes this approach more natural than in other languages. We don't need to add a lot of fields and constructors/properties to set up dependencies. We can just wrap modules in an initialization function that takes dependencies as parameters.</p><p>In our application, the <code class="literal">app</code> module will wire everything together. The application as a whole depends <a id="id372" class="indexterm"/>on the database. The games and index routes <a id="id373" class="indexterm"/>depend on the game service. To allow the routes to take a dependency on the game service, we just need to top and tail them with a function:</p><div><pre class="programlisting"><strong>'use strict';</strong>

<strong>module.exports = (gamesService) =&gt; {</strong>
    var express = require('express');
    var router = express.Router();
    ...
<strong>    return router;</strong>
<strong>};</strong>
</pre></div><p>The games <a id="id374" class="indexterm"/>service itself is slightly more complicated. We previously added several functions to <code class="literal">module.exports</code>, so we need to put these on an object instead. However, this actually results in shorter code. Also, note that we only create the <code class="literal">Game</code> schema if it hasn't already been defined, to defend against our exported function being called multiple times:</p><div><pre class="programlisting"><strong>module.exports = (mongoose) =&gt; {</strong>
    'use strict';
    
<strong>    let Game = mongoose.models['Game'];</strong>

<strong>    if (!Game) {</strong>
        const Schema = mongoose.Schema;
        const gameSchema = new Schema({
            word: String,
            setBy: String
        });

        gameSchema.methods.positionsOf = function(character) {
            ...
        };
        
        Game = mongoose.model('Game', gameSchema);
<strong>    }</strong>
    
<strong>    return {</strong>
<strong>      create: (userId, word) =&gt; {</strong>
<strong>            const game = new Game({</strong>
<strong>                setBy: userId, word: word.toUpperCase()</strong>
<strong>            });</strong>
<strong>            return game.save();</strong>
<strong>        },</strong>
<strong>        createdBy: userId =&gt; Game.find({setBy: userId}),</strong>
<strong>        availableTo: userId =&gt; Game.where('setBy').ne(userId),</strong>
<strong>        get: id =&gt; Game.findById(id)</strong>
<strong>    };</strong>
<strong>};</strong>
</pre></div><p>Finally, the<a id="id375" class="indexterm"/> application itself depends on <a id="id376" class="indexterm"/>the database connection and wires up the <a id="id377" class="indexterm"/>other dependencies:</p><div><pre class="programlisting"><strong>module.exports = (mongoose) =&gt; {</strong>
    ...

<strong>    let gamesService = require('./services/games')(mongoose);</strong>
<strong>    let routes = require('./routes/index')(gamesService);</strong>
<strong>    let games = require('./routes/games')(gamesService);</strong>
    ...

<strong>    return app;</strong>
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec51"/>Providing dependencies</h2></div></div></div><p>We can<a id="id378" class="indexterm"/> specify the database URL in an environment variable. When this isn't present, our application will instead make use of an in-memory instance of MongoDB. This will be provided by a library called <strong>Mockgoose</strong>. We install this as<a id="id379" class="indexterm"/> a dev dependency, in case we forget to set our environment variable on a production server. We'll get an error rather than quietly using a non-persistent database.</p><div><pre class="programlisting"><strong>&gt; npm install mockgoose@~5.x --save-dev</strong>
</pre></div><p>We create a new module under <code class="literal">src/config/mongoose.js</code> to initialize Mongoose and return a promise that will be fulfilled when it has connected to the database:</p><div><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const debug = require('debug')('hangman:config:mongoose');

mongoose.Promise = Promise;
if (!process.env.MONGODB_URL) {
    debug('MongoDB URL not found. Falling back to in-memory database...');
    require('mockgoose')(mongoose);
}

let db = mongoose.connection;
mongoose.connect(process.env.MONGODB_URL);
module.exports = new Promise(function(resolve, reject) {
    db.once('open', () =&gt; resolve(mongoose));
    db.on('error', reject);
});</pre></div><p>Now we just <a id="id380" class="indexterm"/>need to pass this into our application. The following is the code from <code class="literal">bin/www</code>:</p><div><pre class="programlisting">...

<strong>require('../src/config/mongoose').then((mongoose) =&gt; {</strong>
<strong>    var app = require('../src/app')(mongoose);</strong>
    ...
    server.on('listening', onListening);
<strong>}).catch(function(error) {</strong>
<strong>    console.log(error);</strong>
<strong>    process.exit(1);</strong>
<strong>});</strong>
</pre></div><p>To allow our tests to run, we'll also need to add new <code class="literal">before</code> functions to make use of this module. The following code is from <code class="literal">test/services/games.js</code>:</p><div><pre class="programlisting">'use strict';

const expect = require('chai').expect;

describe('Game service', () =&gt; {
  const firstUserId = 'user-id-1';
  const secondUserId = 'user-id-2';
    
<strong>  let service;</strong>
<strong>  before(done =&gt; {</strong>
<strong>    require('../../src/config/mongoose.js').then((mongoose) =&gt; {</strong>
<strong>      service = require('../../src/services/games.js')(mongoose);</strong>
<strong>      done();</strong>
<strong>    }).catch(done);;</strong>
<strong>  });</strong>
  ...</pre></div><p>The following code is from <code class="literal">test/routes/games.js</code>:</p><div><pre class="programlisting">'use strict';

const request = require('supertest');
const expect = require('chai').expect;

describe('/games', () =&gt; {
  let agent, userId;
<strong>  let mongoose, gamesService, app;</strong>
    
<strong>  before(function(done) {</strong>
<strong>    require('../../src/config/mongoose.js').then((mongoose) =&gt; {</strong>
<strong>      app = require('../../src/app.js')(mongoose);</strong>
<strong>      gamesService =</strong>
<strong>        require('../../src/services/games.js')(mongoose);</strong>
<strong>      done();</strong>
<strong>    }).catch(done);</strong>
<strong>  });</strong>
    
    ...</pre></div><p>We'll also<a id="id381" class="indexterm"/> add a global teardown function to close the database connection after all tests have finished. This is just a Mocha <code class="literal">after</code> hook outside the context of any <code class="literal">describe</code> block. We add this in a new file under <code class="literal">test/global.js</code>:</p><div><pre class="programlisting">'use strict';

after(function(done) {
    require('../src/config/mongoose.js').then(
        (mongoose) =&gt; mongoose.disconnect(done));
});</pre></div><p>Finally, we need to update our <code class="literal">gulpfile.js</code>, to allow our integration tests to run with the new dependency:</p><div><pre class="programlisting">gulp.task('integration-test',
        ['lint-integration-test', 'test'], function(done) {
    const TEST_PORT = 5000;
    
<strong>    require('./src/config/mongoose.js').then((mongoose) =&gt; {</strong>
<strong>        let server, teardown = (error) =&gt; {</strong>
<strong>            server.close(() =&gt;</strong>
<strong>                mongoose.disconnect(() =&gt; done(error)));</strong>
<strong>        };</strong>
<strong>        server = require('http')</strong>
<strong>            .createServer(require('./src/app.js')(mongoose))</strong>
            .listen(TEST_PORT, function() {
                gulp.src('integration-test/**/*.js')
                    .pipe(
                        ...
                    )
<strong>                    .on('error', teardown)</strong>
<strong>                    .on('end', teardown)</strong>
            });
<strong>    });</strong>
});</pre></div><p>We can now<a id="id382" class="indexterm"/> run our application and tests on a local development machine without needing to have MongoDB running, or we can specify the <code class="literal">MONGO_DB</code> environment variable if and when we want to use a real MongoDB instance.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec52"/>Running database integration tests on Travis CI</h2></div></div></div><p>We do want to<a id="id383" class="indexterm"/> regularly integration<a id="id384" class="indexterm"/> test our application against a real <a id="id385" class="indexterm"/>MongoDB instance. Fortunately, Travis CI provides various data stores as part of its environment. We just need to tell it that our build requires MongoDB by adding it to our <code class="literal">travis.yml</code> file. We also need to set the <code class="literal">MONGODB_URL</code> environment variable for tests to be able to connect to the database:</p><div><pre class="programlisting"><strong>services:</strong>
<strong> - mongodb</strong>
<strong>env:</strong>
<strong>  global:</strong>
<strong>    - MONGODB_URL=mongodb://localhost/hangman</strong>
</pre></div><p>Now we can run our application as well as our unit and integration tests with a suitable MongoDB instance on development machines and on the CI server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Introducing Redis</h1></div></div></div><p>Redis is often<a id="id386" class="indexterm"/> classified as <a id="id387" class="indexterm"/>a <strong>key-value</strong> data store. Redis describes itself as a data-structure store. It offers storage types similar to the basic data structures found in most programming languages.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec53"/>Why use Redis?</h2></div></div></div><p>Redis operates <a id="id388" class="indexterm"/>entirely in memory, allowing it to be very fast. This, together with its key-value nature, makes it well-suited for use as a cache. It also supports publish/subscribe channels, which allows it to function as a message broker. We'll look at this further in <a class="link" title="Chapter 10. Creating Real-time Web Apps" href="part0058.xhtml#aid-1NA0K1">Chapter 10</a>, <em>Real-time Web Apps in Node.js</em>.</p><p>More generally, Redis can be a useful backend to allow multiple Node.js processes to co-ordinate with one another. Node.js scales horizontally and most websites will run multiple Node.js<a id="id389" class="indexterm"/> processes. Many websites have "working" data that doesn't need to be persisted long term, but does need to be available quickly and consistently across all processes. Redis's in-memory nature and range of atomic operations make it very useful for this purpose.</p><p>Redis is built more for speed than durability. There are various options to configure it, but all expect some amount of data loss in the event of an outage. This is a compromise of Redis working entirely in-memory for speed. It is possible to reduce data loss to no more than the last second of writes before an outage, without significantly compromising on speed. Redis can be configured to completely minimize data loss by syncing to disk after each operation. However, this has a more significant impact on performance and negates the advantages of Redis's in-memory nature.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec54"/>Installing Redis</h2></div></div></div><p>Source<a id="id390" class="indexterm"/> distributions <a id="id391" class="indexterm"/>of Redis are available from <a class="ulink" href="http://redis.io/download">http://redis.io/download</a>.</p><p>For Windows, it is more useful to download a pre-built binary. It is available as a signed package via NuGet and Chocolatey. If you have Chocolatey available, you can install Redis by running the following command:</p><div><pre class="programlisting"><strong>&gt; choco install redis-64</strong>
</pre></div><p>Alternatively, you can download an unsigned version of the installer from <a class="ulink" href="https://github.com/MSOpenTech/redis/releases">https://github.com/MSOpenTech/redis/releases</a>
</p><p>Once installed, you can start Redis by running <code class="literal">redis-server</code>. In a separate window, run <code class="literal">redis-cli</code> to connect to the server and run commands.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec55"/>Using Redis as a key-value store</h2></div></div></div><p>Everything in Redis<a id="id392" class="indexterm"/> is stored against a key. Keys in Redis can be any binary data, but it's best to think of them as strings. Various types of value can be stored against each key.</p><p>Redis refers to simple scalar values<a id="id393" class="indexterm"/> as <strong>Strings</strong>. Redis also has special treatment for scalar integers. The following example sets and updates a key named <code class="literal">counter</code>:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; set counter 100</strong>
<strong>OK</strong>
<strong>127.0.0.1:6379&gt; get counter</strong>
<strong>"100"</strong>
<strong>127.0.0.1:6379&gt; incr counter</strong>
<strong>(integer) 101</strong>
</pre></div><p>This increment <a id="id394" class="indexterm"/>operation is atomic. Redis also supports setting values atomically. The following command will fail because the key already exists:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; set counter 200 nx</strong>
<strong>(nil)</strong>
</pre></div><p>These features can help coordinating between servers. Redis also supports setting expiry times for keys. This makes it possible to offer caching behavior similar to memcache. Redis has even more flexibility, though, as we'll see in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec56"/>Storing structured data in Redis</h2></div></div></div><p>In addition to <a id="id395" class="indexterm"/>simple key-value pairs, Redis supports other more structured data types.</p><p>
<strong>Lists</strong> are<a id="id396" class="indexterm"/> ordered <a id="id397" class="indexterm"/>collections of values. They are stored as a linked list rather than as arrays. This makes adding/removing elements at the ends of the list efficient (at the cost of slower retrieval of items from the list by index), for example:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; rpush fruit apple banana pear</strong>
<strong>(integer) 3</strong>
<strong>127.0.0.1:6379&gt; rpop fruit</strong>
<strong>"pear"</strong>
<strong>127.0.0.1:6379&gt; lpush fruit orange</strong>
<strong>(integer) 3</strong>
<strong>127.0.0.1:6379&gt; lrange fruit 0 -1</strong>
<strong>1) "orange"</strong>
<strong>2) "apple"</strong>
<strong>3) "banana"</strong>
</pre></div><p>Note that <code class="literal">lrange</code> takes start and end indices. Negative values count backwards from the end of the list, so <code class="literal">-1</code> refers to the last element. Being able to push/pop from either end of a list means that they can be used as stacks or queues, for example, for allowing processes to communicate in a producer-consumer arrangement.</p><p>
<strong>Hashes</strong> are <a id="id398" class="indexterm"/>a set of field-value pairs. These are not as rich as MongoDB documents, but <a id="id399" class="indexterm"/>allow us to associate some data together. For example, we could have implemented our game service using Redis:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; hmset game:2 word JavaScript setBy user-id-7</strong>
<strong>OK</strong>
<strong>127.0.0.1:6379&gt; hget game:2 word</strong>
<strong>"JavaScript"</strong>
<strong>127.0.0.1:6379&gt; hgetall game:2</strong>
<strong>1) "word"</strong>
<strong>2) "JavaScript"</strong>
<strong>3) "setBy"</strong>
<strong>4) "user-id-7"</strong>
</pre></div><p>Note that the top-level key <code class="literal">game:2</code> here is just a convention. It can be useful for developers to <a id="id400" class="indexterm"/>namespace keys in this way, but Redis only understands them as strings.</p><p>
<strong>Sets</strong> are <a id="id401" class="indexterm"/>unordered<a id="id402" class="indexterm"/> collections of values, for example:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; sadd numbers one two three</strong>
<strong>(integer) 3</strong>
<strong>127.0.0.1:6379&gt; smembers numbers</strong>
<strong>1) "two"</strong>
<strong>2) "three"</strong>
<strong>3) "one"</strong>
</pre></div><p>Sets support mathematical operations such as unions and intersections. They also support the retrieval (with optional atomic removal) of random elements.</p><p>
<strong>Sorted sets</strong> are <a id="id403" class="indexterm"/>collections of values, each associated with a numerical<a id="id404" class="indexterm"/> score:</p><div><pre class="programlisting"><strong>127.0.0.1:6379&gt; zadd votes 3 Aye</strong>
<strong>(integer) 1</strong>
<strong>127.0.0.1:6379&gt; zadd votes 4 No</strong>
<strong>(integer) 1</strong>
<strong>127.0.0.1:6379&gt; zadd votes 1 Abstain</strong>
<strong>(integer) 1</strong>
<strong>127.0.0.1:6379&gt; zrevrange votes 0 1</strong>
<strong>1) "No"</strong>
<strong>2) "Aye"</strong>
</pre></div><p>Note that the ranges are ordered smallest to largest by default. We request a reverse range above to get the element with the highest score first. Sorted sets are useful for implementing voting systems (as previously shown) or ranking systems.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Building a user ranking system with Redis</h1></div></div></div><p>We want to be<a id="id405" class="indexterm"/> able to rank users based on how many <a id="id406" class="indexterm"/>games they have completed. We will create a user service, implemented in Redis, that provides the following functionality:</p><div><ul class="itemizedlist"><li class="listitem">Record when a user successfully completes a game</li><li class="listitem">Return the top three users across the site</li><li class="listitem">Return the rank of a given user</li></ul></div><p>We will first<a id="id407" class="indexterm"/> add a feature to make the site a bit more <a id="id408" class="indexterm"/>user-friendly by allowing users to choose a screen name.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Using Redis from Node.js</h2></div></div></div><p>First, we'll <a id="id409" class="indexterm"/>need to install a Node.js client library for Redis. We'll also <a id="id410" class="indexterm"/>use the promise library Bluebird to convert the Redis client library to promises:</p><div><pre class="programlisting"><strong>&gt; npm install redis --save</strong>
<strong>&gt; npm install bluebird --save</strong>
</pre></div><p>First, we'll create a module for configuring the Redis client as shown here in <code class="literal">src/config/redis.js</code>:</p><div><pre class="programlisting">'use strict';

const bluebird = require('bluebird');
const redis = require('redis');
bluebird.promisifyAll(redis.RedisClient.prototype);
module.exports = redis.createClient(process.env.REDIS_URL);</pre></div><p>Now we can create a new user service with methods for getting and setting a username, in <code class="literal">src/services/users.js</code>:</p><div><pre class="programlisting">'use strict';

let redisClient = require('../config/redis.js');

module.exports = {
    getUsername: userId =&gt;
        redisClient.getAsync(`user:${userId}:name`),
    setUsername: (userId, name) =&gt;
        redisClient.setAsync(`user:${userId}:name`, name)
};</pre></div><p>Note that the Redis client provides functions for each Redis command (such as <code class="literal">get</code> and <code class="literal">set</code>). Bluebird provides promise-based versions of each function suffixed with <code class="literal">Async</code>.</p><p>Of course, now that we have test infrastructure for our project, we should add tests for new code as we go as shown here <code class="literal">test/services/users.js</code>:</p><div><pre class="programlisting">'use strict';

const expect = require('chai').expect;
const service = require('../../src/services/users.js');

describe('User service', function() {
    describe('getUsername', function() { 
        it('should return a previously set username', done =&gt; {
            const userId = 'user-id-1';
            const name = 'User Name';
            service.setUsername(userId, name)
                .then(() =&gt; service.getUsername(userId))
                .then(actual =&gt; expect(actual).to.equal(name))
                .then(() =&gt; done(), done);
        });
        
        it('should return null if no username is set', done =&gt; {
            const userId = 'user-id-2';
            
            service.getUsername(userId)
                .then(name =&gt; expect(name).to.be.null)
                .then(() =&gt; done(), done);
        });
    });
});</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec14"/>Testing with redis-js</h3></div></div></div><p>As with the tests<a id="id411" class="indexterm"/> for our games service, we want to be able to integrate with a Redis instance on our CI server. But we don't want to introduce any new dependencies for development. This time, we will make use of a library called redis-js for local testing. Unlike Mockgoose, this does not use an in-memory version of the real DB engine (Redis is already in-memory). This is instead a re-implementation of the Node.js Redis client that stores all of its data in-process:</p><div><pre class="programlisting"><strong>&gt; npm install redis-js --save-dev</strong>
</pre></div><p>Now we can create a module for obtaining the environment-appropriate Redis reference as shown here <code class="literal">src/config/redis.js</code>:</p><div><pre class="programlisting"><strong>'use strict';</strong>

<strong>const bluebird = require('bluebird');</strong>
<strong>const debug = require('debug')('hangman:config:redis');</strong>

<strong>if (process.env.REDIS_URL) {</strong>
<strong>    let redis = require('redis');</strong>
<strong>    bluebird.promisifyAll(redis.RedisClient.prototype);</strong>
<strong>    module.exports = redis.createClient(process.env.REDIS_URL);</strong>
<strong>} else {</strong>
<strong>    debug('Redis URL not found. Falling back to mock DB...');</strong>
<strong>    let redisClient = require('redis-js');</strong>
<strong>    bluebird.promisifyAll(redisClient);</strong>
<strong>    module.exports = redisClient;</strong>
}</pre></div><p>Note that, unlike <a id="id412" class="indexterm"/>Mongoose, the Node.js Redis client can be used immediately. Any commands issued before it has connected are actually queued up internally. This means we can just return the client from the module and require it directly. There wouldn't be any benefit in this case to the dependency injection we used with Mongoose.</p><p>We also need to add Redis to our <code class="literal">.travis.yml</code> file so it runs on the CI server:</p><div><pre class="programlisting">services:
 - mongodb
<strong> - redis-server</strong>
env:
  global:
    - MONGODB_URL=mongodb://localhost/hangman
<strong>    - REDIS_URL=redis://127.0.0.1:6379/</strong>
</pre></div><p>Finally, we need to close the client once our tests have completed, as we did with Mongoose. We also ensure we empty the database on startup (as we don't have a way of deleting user data via the service interface, as we do with games). The following code is from <code class="literal">test/global.js</code>:</p><div><pre class="programlisting">'use strict';

<strong>before(function(done) {</strong>
<strong>    require('../src/config/redis.js').flushdbAsync().then(() =&gt; done());</strong>
<strong>});</strong>

after(function(done) {
<strong>    require('../src/config/redis.js').quit();</strong>
    require('../src/config/mongoose.js').then(
        (mongoose) =&gt; mongoose.disconnect(done));
});</pre></div><p>The following code is from <code class="literal">gulpfile.js</code>:</p><div><pre class="programlisting">        let server, teardown = (error) =&gt; {
<strong>            require('./src/config/redis.js').quit();</strong>
            server.close(() =&gt;
                mongoose.disconnect(() =&gt; done(error)));
        };</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec58"/>Implementing user rankings with Redis</h2></div></div></div><p>Now we <a id="id413" class="indexterm"/>are ready to add the user ranking functionality to our service. The following code is from <code class="literal">src/services/users.js</code>:</p><div><pre class="programlisting">module.exports = {
  ...

  recordWin: userId =&gt;
    redisClient.zincrbyAsync('user:wins', 1, userId),

  getTopPlayers: () =&gt;
    redisClient.zrevrangeAsync('user:wins', 0, 2, 'withscores')
    .then(interleaved =&gt; {
      if (interleaved.length === 0) {
        return [];
      }
      let userIds = interleaved
        .filter((user, index) =&gt; index % 2 === 0)
        .map((userId) =&gt; `user:${userId}:name`);
      return redisClient.mgetAsync(userIds)
        .then(names =&gt; names.map((username, index) =&gt; ({
          name: username,
          userId: interleaved[index * 2],
          wins: parseInt(interleaved[index * 2 + 1], 10)
        })));
    }),

  getRanking: userId =&gt; {
    return Promise.all([
      redisClient.zrevrankAsync('user:wins', userId),
      redisClient.zscoreAsync('user:wins', userId)
    ]).then(out =&gt; {
      if (out[0] === null) {
        return null;
      }
      return { rank: out[0] + 1, wins: parseInt(out[1], 10) };
    });
  }
};</pre></div><p>Most of the Redis commands used here will be familiar from earlier in the chapter. The most interesting function is <code class="literal">getTopPlayers</code>. This makes use of <code class="literal">zrevrange</code> with the <code class="literal">withscores</code> option. This returns an array of user IDs and scores (interleaved together).  We make a second request to the database using <code class="literal">mget</code> (multivalued get) to retrieve the names of all <a id="id414" class="indexterm"/>the users. Once this returns we can combine all the data for each user together into an object.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec59"/>Making use of the users service</h2></div></div></div><p>Wiring this<a id="id415" class="indexterm"/> functionality up to the rest of our application doesn't use any techniques we haven't seen before, so is omitted from the printed code listings for brevity. The full implementation can be found in the companion code for this chapter, along with tests for the rest of the user service methods, at <a class="ulink" href="https://github.com/NodeJsForDevelopers/chapter09">https://github.com/NodeJsForDevelopers/chapter09</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>A note on security</h1></div></div></div><p>We have been running MongoDB and Redis with their default out-of-the-box settings. This is fine for<a id="id416" class="indexterm"/> development purposes. Deploying these services into production requires additional consideration around security. You can find more resources <a id="id417" class="indexterm"/>on this at <a class="ulink" href="https://docs.mongodb.com/manual/administration/security-checklist/">https://docs.mongodb.com/manual/administration/security-checklist/</a> and <a class="ulink" href="http://redis.io/topics/security">http://redis.io/topics/security</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we have understood the difference between different types of database and learned about the key features of MongoDB and Redis. We also persisted our application's data using these databases and used dependency injection to make our application more flexible. We also learned how to configure our development and integration environments to use appropriate database instances.</p><p>Persistence may be considered the bottom layer of our system. In the next chapter, we'll introduce real-time client/server communication into our application. This frontend functionality means focusing more on the top layer of our system. However, we'll also see Redis playing an important role in supporting this functionality.</p></div></body></html>