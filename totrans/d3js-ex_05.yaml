- en: Chapter 5. Using Data and Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Creating a Bar Graph"), *Creating a Bar
    Graph*, you learned how to create a bar graph that was based upon a sequence of
    integers that were statically coded within the application. Although the resulting
    graph looks quite nice, there are several issues with the way the data is provided
    and rendered.
  prefs: []
  type: TYPE_NORMAL
- en: One of the issues is that the data is hard-coded within the application. Almost
    invariably, we are going to load the data from an external source. D3.js provides
    a rich set of functionalities for loading data from sources over the web, and
    which is represented in different formats. In this chapter, you will learn to
    use D3.js for loading data from the web in JSON, CSV, and TSV formats.
  prefs: []
  type: TYPE_NORMAL
- en: A second issue with the data in the example given in the previous chapter was
    that it was simply an array of integers. Data will often be represented as collections
    of objects with multiple properties, many of which we do not need for our visualization.
    They are also often represented as strings instead of numeric values. In this
    chapter, you will learn how to select just the data that you want and to convert
    it to the desired data type.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another issue in our previous bar graph was that we assumed that the values
    represented in the data had a direct mapping to the pixels in the visualization.
    This is normally not the case, and we need to scale the data into the size of
    our rendering in the browser. This can be easily accomplished using scales, which
    we already examined relative to axes, and now we will apply them to data.
  prefs: []
  type: TYPE_NORMAL
- en: One last issue in the previous example was that our code for calculating the
    size and positions of the bars was performed manually. Bar graphs are common enough
    in D3.js applications, and there are built-in functions that can do this for us
    automatically. We will examine using these to simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s jump in. In this chapter, we will specifically cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data in JSON, TSV, or CSV formats from the Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting fields from objects using the `.map()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting string values into their representative numeric data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using linear scales for transforming continuous values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ordinal scales for mapping discrete data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bands for calculating the size and position of our bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying what we've learned to date for creating a rich bar graph using real
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is the core of creating a data visualization. Almost every visual item
    created in D3 will need to be bound to a piece of data. This data can come from
    a number of sources. It can be explicitly coded in the visualization, loaded from
    an external source, or result from manipulation or calculation from other data.
  prefs: []
  type: TYPE_NORMAL
- en: Most data used to create a D3.js visualization is either obtained from a file
    or a web service or URL. This data is often in one of many formats such as JSON,
    XML, **CSV** (**Comma Separated Values**), and **TSV** (**Tab Separated Values**).
    We will need to convert the data in these formats into JavaScript objects, and
    D3.js provides us with convenient functions for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with D3.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'D3.js provides a number of helper functions to load data from outside the browser
    as well as to simultaneously convert it into JavaScript objects. Probably, the
    most common data formats that you may come across and which we will cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that I have omitted XML from the list in our examples.
    D3.js does have functions to load XML, but unlike with JSON, TSV and CSV, the
    results of the load are not converted automatically into JavaScript objects, and
    require additional manipulation using the JavaScript XML/DOM facilities. XML will
    be considered out of scope for this text as most of the scenarios you will currently
    come across will be handled with these three formats, if not solely by JSON, which
    has become almost the ubiquitous data format for the Web.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate working with all these formats of data, we will examine a dataset
    that I have put together and placed in a GitHub that represents the viewership
    of the episodes of Season 5 of AMC's *The Walking Dead*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This GitHub was built manually using data on [https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)](https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)).
  prefs: []
  type: TYPE_NORMAL
- en: Loading JSON data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data in the **JavaScript Object Notation** (**JSON**) format is convenient for
    conversion into JavaScript objects. It is a very flexible format which supports
    named properties as well as hierarchical data.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON data for this example is stored in GitHub and is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The URL is a little unwieldy. You can go directly to the gist with all three
    versions of this data at [https://goo.gl/OfD1hc](https://goo.gl/OfD1hc).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the link will display the data in the browser. This file contains
    an array of JavaScript objects, each of which has six properties and represents
    an individual episode of the program. The first two objects are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This data can be loaded into our D3.js application using the `d3.json()` function.
    This function, like many others in D3.js, performs asynchronously. It takes two
    parameters: the URL of the data to load, and a callback function that is called
    when the data has been loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates loading this data and displaying the first
    item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.1): [http://goo.gl/Qe63wH](http://goo.gl/Qe63wH)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main portion of the code that loads the data is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no visible output from this example, but the output is written to
    the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the loading of data in D3.js is performed asynchronously. The output
    from the `console.log()` call shows that the data is loaded asynchronously and
    is executed first. Later, when the data is loaded, we see the output from the
    second call to `console.log()`.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function itself has two parameters. The first is a reference to
    an object representing an error if one occurs. In such a case, this variable will
    be non-null and contain details. Non-null means the data was loaded, and is represented
    by the data variable.
  prefs: []
  type: TYPE_NORMAL
- en: Loading TSV data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TSV is a type of data that you will come across if you do enough D3.js programming.
    In a TSV file, the values are separated by tab characters. Generally, the first
    line of the file is a tab-separated sequence of names for each of the values.
  prefs: []
  type: TYPE_NORMAL
- en: TSV files have the benefit of being less verbose than JSON files, and are often
    generated automatically by many systems that are not JavaScript based.
  prefs: []
  type: TYPE_NORMAL
- en: The episode data in the TSV format is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the link, you will see the following in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can load the data from this file using `d3.tsv()`. The following contains
    the code for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.2): [http://goo.gl/nlq8jy](http://goo.gl/nlq8jy)'
  prefs: []
  type: TYPE_NORMAL
- en: The code is identical to the JSON example except for the URL and the call to
    `d3.json()`. The output in the console is, however, different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the properties **Episode**, **Season**, **SeriesNumber**, and **USViewers**
    are now of type string instead of integer. TSV files do not have a means of implying
    the type like JSON does, so everything defaults to string. These will often need
    to be converted to another type, and we will examine that in the next section
    on mapping and data conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Loading CSV data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSV is a format similar to TSV except that instead of tab characters delimiting
    the fields, a comma is used. CSV is a fairly common format, common as output from
    spreadsheet applications, which is used for creating data to be consumed by other
    applications in many organizations.
  prefs: []
  type: TYPE_NORMAL
- en: The CSV version of the data is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the link, you will see the following in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The example for demonstrating the loading of the preceding data using `d3.csv()`
    is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.3): [http://goo.gl/JUX9CA](http://goo.gl/JUX9CA)'
  prefs: []
  type: TYPE_NORMAL
- en: The result is identical to that of the TSV example in that all the fields are
    loaded as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping fields and converting strings to numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use this data (in its CSV source) to render a bar graph that
    shows us the comparison of the viewership levels for each episode. If we are to
    use these fields as-is for creating the bar graph, those values will be interpreted
    incorrectly as their types are strings instead of numbers, and our resulting graph
    will be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, for the purpose of creating a bar chart showing viewership, we
    don't need the properties and can omit the `Season`, `SeriesNumber`, and `FirstAirDate`
    fields. It's not a real issue with this dataset, but sometimes, the data can have
    hundreds of columns and billions of rows, so it will be more efficient to extract
    only the necessary properties to help save memory.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accomplished in a naive manner using a `for` loop, copying the
    desired fields into a new JavaScript object, and using one of the parse functions
    to convert the data. D3.js gives us a better way, a functional way, to perform
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: D3.js provides us with the a .`map()` function that can be used on an array,
    which will apply a function to each of the array's items. This function returns
    a JavaScript object, and D3.js collects all these objects and returns them in
    an array. This gives us a simple way of selecting just the properties that we
    want and to convert the data, all in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this in action, open the example given at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.4): [http://goo.gl/ex2e8C](http://goo.gl/ex2e8C)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The important portion of the code is the call to `data.map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function that is passed to the `.map()` returns a new JavaScript object
    for each item in the array data. This new object consists of only the three specified
    properties. These objects are all collected by `.map()` and stored in the `mappedAndConverted`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the first two objects in the new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Episode` and `USViewers` are now numeric values. This is accomplished
    by applying the unary `+` operator, which will convert a string to its appropriate
    numeric type.
  prefs: []
  type: TYPE_NORMAL
- en: Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scales are functions provided by D3.js that map a set of values to another set
    of values. The input set of values is referred to as the domain, and the output
    is the range. The basic reason for the existence of scales is to prevent us from
    coding loops, and doing a lot of math to make these conversions happen. This is
    a very useful thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three general categories of scales: quantitative, ordinal, and time-scale.
    Within each category of scale, D3.js provides a number of concrete implementations
    that exist for accomplishing a specific type of mapping data useful for data visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Covering examples of every type of scale would consume more space than is available
    in this book, and at the same time become tedious to read. We will examine several
    common scales that are used—kind of the 80/20 rule, where the few we cover here
    will be used most of the time you use scales.
  prefs: []
  type: TYPE_NORMAL
- en: Linear scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linear scales are a type of quantitative scale that are arguably the most commonly
    used ones. The mapping performed is linear in that the output range is calculated
    using a linear function of the input domain.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of using a linear scale is the scenario with our *The Walking
    Dead* viewership data. We need to draw bars from this data; but if we use the
    code that we used earlier in the book, our bars will be extremely tall since that
    code has a one to one mapping between the value and the pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our area for the bars on the graph has a height of 400 pixels.
    We would like to map the lowest viewership value to a bar that is 100 pixels tall,
    and map the largest viewership value to 400\. The following example performs this
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.5): [http://goo.gl/dgg0zf](http://goo.gl/dgg0zf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts, as with the CSV example, by loading that data and mapping/converting
    it. The next task is to determine the minimum and maximum viewership values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define several variables representing the minimum and maximum height
    that we would like for the bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The scale is then created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `yScale` object as though it is a function. The following
    will log the results of scaling the minimum and maximum viewership values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the console output, we can see that the scaling resulted in the expected
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Ordinal scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ordinal scales are, in a way, similar to dictionary objects. The values in the
    domain and range are discrete. There must be an entry in the range for every unique
    input value, and that value must have a mapping to a single value in the range.
  prefs: []
  type: TYPE_NORMAL
- en: There are several common uses for ordinal scales, and we will examine four common
    uses that we will use throughout the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping color strings to codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the following link for an example of an ordinal scale. This example does
    not use the data from *The Walking Dead*, and simply demonstrates the mapping
    of string literals representing primary colors into the corresponding color codes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.6): [http://goo.gl/DezcUN](http://goo.gl/DezcUN)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The scale is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pass any of the range values to the `colorScale`, as demonstrated
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the console output, we can see the results of this mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Mapping integers to color scales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3.js comes with several special built-in scales that are referred to as **categorical**
    scales. It sounds like a fancy term, but they are simply mappings of a set of
    integers to unique colors (unique within that scale).
  prefs: []
  type: TYPE_NORMAL
- en: These are useful when you have a set of sequential 0-based integer keys in your
    data, and you want to use a unique color for each, but you do not want to manually
    create all the mappings (like we did for the three strings in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the following link for an example of using a 10 color categorical scale:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.7): [http://goo.gl/RSW9Qa](http://goo.gl/RSW9Qa)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example renders 10 adjacent rectangles, each with a unique color
    from a `category10()` color scale. You will see this in your browser when executing
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping integers to color scales](img/B04230_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The example starts by creating an array of 10 integers from 0 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The scale is created next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can bind the integers to the rectangles, and set the fill for each by
    passing the value to the `colorScale` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: D3.js provides four sets of categorical color scales that can be used depending
    upon your scenario. You can take a look at them on the D3.js documentation page
    at [https://github.com/mbostock/d3/wiki/Ordinal-Scales](https://github.com/mbostock/d3/wiki/Ordinal-Scales).
  prefs: []
  type: TYPE_NORMAL
- en: The ordinal scale using rangeBands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Creating a Bar Graph"), *Creating a Bar
    Graph*, when we drew the graph we calculated the positions of the bars based upon
    a fixed bar size and padding. This is actually a very inflexible means of accomplishing
    this task. D3.js gives us a special scale that we can use, given the domain values
    and essentially a width, that will tell us the start and end values for each bar
    such that all the bars fit perfectly within the range!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look using this special scale with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.8): [http://goo.gl/OG3g7S](http://goo.gl/OG3g7S)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example creates a simple ordinal scale specifying the range using the
    `.rangeBands()` function instead of `.range()`. The entire code of the example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.range()` function will return an array with values representing the extents
    of an equal number of evenly-spaced divisions of the range specified to `.rangeBands()`.
    In this case, the width of the range is `100`, and there are three items specified
    in the domain; hence, the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, this result is the values that represent the start of each band.
    The width of each band can be found using the `.rangeBand()` function, in this
    case returning the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This width may seem simplistic. Why have this function if we can just calculate
    the difference between two adjacent values in the result of `.range()`? To demonstrate,
    let's look at a slight modification of this example, available at the following
    link.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.9): [http://goo.gl/JPsuqh](http://goo.gl/JPsuqh)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes one modification to the call to `.rangeBands()`, adding an additional
    parameter that specifies the padding that should exist between the bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output differs slightly due to the addition of padding between the bands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The width of each band is now 29.03, with a padding of 3.23 between bands (including
    on the outside of the two outer bands).
  prefs: []
  type: TYPE_NORMAL
- en: The value for padding is a value between 0.0 (the default, and which results
    in a padding of 0) and 1.0, resulting in bands of width 0.0\. A value of 0.5 makes
    the padding the same width as each band.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing The Walking Dead viewership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we pull everything from the chapter together to render a bar graph of the
    viewership across all the episodes of *The Walking Dead*:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (5.10): [http://goo.gl/T8d6OU](http://goo.gl/T8d6OU)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing The Walking Dead viewership](img/B04230_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s step through how this is created. After loading the data from the
    JSON file, the first thing that is performed is the extraction of the `USViewership`
    values and the determining of the maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then various variables, which represent various metrics for the graph, and
    the main SVG element are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The container for holding the bars is created next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create an ordinal scale for the bars using `.rangeBands()`. We will
    use this to calculate the bar position and padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also require a scale to calculate the height of each bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used by the selection that creates the bars to position
    each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the groups for the content of each bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we append the rectangle for the bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add a label to the bar to show the exact viewership value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The bars are now complete, so we move on to creating both the axes. We start
    with the left axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And now create a bottom axis which displays the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is reusable code for styling the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to load data from the web and use it as the
    basis for a bar graph. We started with loading data in the JSON, CSV, and TSV
    formats. You learned how to use the `.map()` function to extract just the values
    that you desire from this data, and examined the issues and solutions needed for
    converting string values into numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: Next we covered scales in some more detail, and looked at several examples of
    the ways to use scales for mapping data from one range of values to another as
    well as to map discrete values such as color names to color codes. We covered
    categorical scales, a means of mapping integer values into predefined color maps,
    and a concept that we will use frequently in our examples. Our examination of
    scales ended with a demonstration of using `.rangeBands()`, and how it can help
    us size and place bars within a predefined area.
  prefs: []
  type: TYPE_NORMAL
- en: We closed the chapter by combining all of these concepts together into, what
    is up to this point, our best example of generating a bar chart. This demonstrated
    loading the data, using multiple scales for both data and axes, and using `.rangeBands()`
    to determine the placement of the bars, as well as using not only a vertical but
    also a horizontal axis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will branch out of bar graphs into another type of data
    visualization—scatter (and bubble) plots.
  prefs: []
  type: TYPE_NORMAL
