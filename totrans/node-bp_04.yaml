- en: Chapter 4. Developing a Chat with Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the previous chapter, Node.js collaborates really well with
    frontend frameworks such as AngularJS. It's great that we can transfer data from
    the browser to Node.js and vice-versa. It's even better if we can do in this real
    time. Nowadays, real-time communication is heavily integrated in almost every
    web product. It gives a nice user experience and brings a lot of benefits to the
    application's owners. Usually, when we talk about real-time web components, we
    mean **WebSockets**. WebSocket is a protocol that allows us to establish a two-way
    (bidirectional) conversation between the browser and the server. This opens a
    whole new world and gives us the power to implement fast and robust apps. **Node.js**
    supports WebSockets, and we will see how to build a real-time chat with WebSockets.
    The application will use Socket.IO. It is a library that is built on top of WebSockets
    and provides mechanisms to cover the same functionalities if they are not available.
    We will have an input field, and every user who opens the page will be able to
    send messages to every other user who is available.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to set up Socket.IO and how to use it in
    a browser and start a Node.js server, making real-time chat possible.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring WebSockets and Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to build a chat feature. The first thing that we should
    do is to develop the part that shows the messages on the screen. In a typical
    scenario, we want these messages to be delivered fast, that is, almost immediately
    after they were sent. However, if we don't use sockets to receive the data from
    the server, we need to make an HTTP request. Also, the server should keep the
    information till we request it to do so. So, imagine what would happen if we had
    10 users and each one of them starts sending data.
  prefs: []
  type: TYPE_NORMAL
- en: We need to maintain a user session in order to identify the user's requests.
    These problems are easily solved if we use sockets. Once the socket is opened,
    we have a long live channel, and we can send messages back and forth. This means
    that you can start receiving information without requesting it. The architecture
    is analogous to a big net of bridges. The bridge is always open, and if we need
    to go somewhere, we are free to do so. At the center of the net, we have a hub
    that connects every side with each other. In the context of the web, the hub is
    our server. Every time we need to reach some of the users attached to the net,
    we just need to send a message via the socket. The server receives it and bypasses
    it to the right person. This is one of the most effective ways to implement real-time
    communication. It saves time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens with most of the cool technologies, we don''t need to start from
    scratch and write low-level stuff, such as handshake requests for example. There
    are two types of developers: those who work really hard and abstract the complex
    things into simpler APIs and tools, and those who know how to use them. Developers
    in the second group can make use of libraries such as Socket.IO. This chapter
    deals extensively with the Socket.IO module. It acts as an abstraction over WebSockets
    and simplifies the process to a great extent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, **Socket.IO** is actually more than a layer over **WebSockets**.
    In practice, it does a lot more, as mentioned on the website at [http://socket.io/](http://socket.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Socket.IO aims to make realtime apps possible in every browser and mobile
    device, blurring the differences between the different transport mechanisms. It''s
    care-free realtime 100% in JavaScript."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are some common situations that we usually encounter with the protocol,
    for example, heartbeats, timeouts, and disconnection support. All these events
    are not natively supported by the WebSocket API. Thankfully, Socket.IO is here
    to solve these issues. The library also eliminates some cross-browser problems
    and makes sure that your app works everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used Express and Jade to write the delivery of
    the assets (HTML, CSS, and JavaScript) of the application. Here, we will stick
    to pure JavaScript code and will avoid the usage of additional dependencies. The
    only thing that we need to add to our `package.json` file is Socket.IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After we call `npm install` in our project''s folder, Socket.IO is placed in
    a newly created `node_modules` directory. Let''s create two new directories. The
    following screenshot shows what the application file structure should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the basic application structure](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The file structure
  prefs: []
  type: TYPE_NORMAL
- en: The application will read the `styles.css` file and deliver its content to the
    browser. The same thing will happen with `/html/page.html`, which is the file
    that contains the HTML markup of the project. The Node.js code goes to `/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start using Socket.IO, let''s first write a simple Node.js server
    code, which responds with the chat''s page. We can see the server code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be placed in `/index.js`. The script starts with the
    definition of several global variables. The `http` module is used to create the
    server, and the `fs` module is used to read the CSS and HTML files from the disk.
    The `html` and `css` variables contain the actual code that will be sent to the
    browser. In our case, this data is static. That's why we are reading the files
    only once, that is, when the script is run. We are also doing this synchronously
    by using `fs.readFileSync` and not `fs.readFile`. Just after this, our server
    is initialized and run. The `req.url` variable contains the currently requested
    file. According to its value, we respond to it with proper content. Once the server
    is run, the HTML and CSS code stays the same. If we change something, we need
    to stop and start the script again. That's because we are reading the file's content
    before we start the server. This could be considered as a good practice if there
    are no changes in `/css/styles.css` or `/html/page.html`. Inserting the `fs.readFileSync`
    operations in the server's handler will make our chat a bit slow because we will
    read from the disk during every request.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of the chat requires the code to be written in both places:
    at the server side and the client side. We will continue with the Node.js part
    by extending the previous code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `http.createServer` method returns a new web server object. We have to pass
    this object to Socket.IO. Once everything is done, we have access to the wonderful
    and simple API. We may listen for incoming events and send messages to the users
    who are attached to the server. The `io.sockets` property refers to all the sockets
    created in the system, while the `socket` object, passed as an argument to the
    `connection` handler, represents only one individual user.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the preceding code, we are listening for the `connection` event,
    that is, for a new user to connect to the server. When this happens, the server
    sends a personal message to that user that reads `Welcome!`
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that may happen is we receive a new type of message from the
    user, our script should distribute this information to all the available sockets.
    That's what `io.sockets.emit` does. Keep in mind that the `emit` method may receive
    our own custom event names and data. It is not necessary to strictly follow the
    format used here.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the client side of the chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having completed writing the code for the server side, we can now continue writing
    for the frontend, that is, write the necessary HTML and JavaScript that will communicate
    with the chat server.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the HTML markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the development done so far, our chat feature would look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the HTML markup](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a container that acts as a holder for the incoming messages. There
    are two input boxes. The first one is for the name of the user and the second
    one accepts the message that we have to send. Every user has a random color applied
    to his/her texts. There is no button to send the data to the server; we can do
    this by pressing the *Enter* key. Let''s continue to read the HTML markup saved
    in `/html/page.html` shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The CSS styles are added at the top of the page and to the scripts at the bottom.
    There are just three elements that represent the controls mentioned in the previous
    code. The bootstrap of the logic is placed in a `window.onload` handler. We are
    doing this just to be sure that all the assets are fully loaded. Note that the
    input field, which will accept the message, is disabled by default. Once the socket
    connection is established, we will enable it. There is one last thing that we
    should clarify—the location/source where the `/socket.io/socket.io.js` file is
    coming from. It is not downloaded and saved in the project directories from an
    external source; it is delivered at that location by Socket.IO. That's one of
    the reasons behind passing the `web server` object to Socket.IO at the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the chat logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML markup itself is useless. The next step in our development process
    will be writing the JavaScript code that will communicate with the backend. We
    will need to catch the user''s input and send it to the server. The messages displayed
    on the screen will be painted in different colors. We will start by defining two
    helper methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first one, `addEventListener` function, will add an event listener to a
    `DOM` element. To make our chat work in Internet Explorer, we need to use `attachEvent`
    instead of `addEventListener`. The second, `getRandomColor` function, delivers
    a different color every time. We will use this to distinguish messages from the
    different users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our client-side logic starts with the defining of a few variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `socket` variable to communicate with the server. The next three
    variables are shortcuts to the previously used `DOM` elements. It is recommended
    to create such shortcuts because referencing elements all the time with `document.getElementById`
    or `document.querySelector` may cause of performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat does two things: it sends messages to the Node.js part and receives
    messages from there. Let''s wrap everything into two simple functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are sending the message via the `socket.emit` method and wrapping the
    text in a colored `span` element. Of course, if the user types in something in
    the `name` input field, we use the value and send it along with the rest of the
    data. The `display` function is pretty simple. It just changes the `innerHTML`
    property of the `chat` element. What is interesting is the second line. If we
    use the chat feature a bit, we will notice that `div` will be filled out very
    soon, and what we actually see are only the first messages. By setting the `scrollTop`
    property to `scrollHeight`, we make sure that the holder will be always scrolled
    downwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in our small application is handling the user''s input. This
    can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only one key that is interesting for us at the moment is the *Enter* key.
    Its key code is 13\. If the key is pressed, the value of the field is emitted
    to the server. We are flushing the input field to allow the user to type in a
    new message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we should do is write the code to receive the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are two types of events that we are listening to. They are `welcome` and
    `receive`. The `welcome` event is sent when the connection is established. The
    `receive` event is an incoming event, when some of the users send a message (including
    ourselves). We may ask why we need to send our own message to the server and receive
    it after that. Isn't it easier to place the text directly onto the holder? The
    answer to this is that we need consistency of the data, that is, we should provide
    the same message in absolutely the same order to all the users. This can be guaranteed
    by only one piece of the app and that's the server.
  prefs: []
  type: TYPE_NORMAL
- en: With this last code snippet, we have finished building our chat feature. In
    the last part of this chapter, we will improve user-to-user communication.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing user-to-user communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our chat is now functioning, but it would be nice if we could send a message
    to one specific user. Such a feature requires changes in both places: at the frontend
    and backend. Let''s first change the Node.js script.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the server-side code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the users were anonymous in our system. We just passed the received
    message to all the sockets available. However, to implement a user-to-user conversation,
    we need to set unique ID for every user. Along with that, we have to keep references
    to all the created sockets so that we can emit messages to them. This can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of the `crypto` module, which is available by default in Node.js
    to generate the random unique IDs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also notify the people in the chat about the available users. Otherwise,
    they will not be able to pick an appropriate user to chat with. The notification
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The user''s name was actually passed along with the message. It was a part
    of the message, and the backend doesn''t use it at all. However, in the new scenario,
    we need it with the ID. The previous code sends the `users` array to the browser,
    but before that, it filters it and passes only the ID and the name. As we will
    see in the following code, we also have a `socket` property for every element.
    The following is the updated `connection` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, a new user connection is received at the server. We generate a new ID and
    create a new element inside the `users` array. We keep the socket, the ID, and
    the name of the user. After that, we emit the good old `welcome` message, but
    this time we send the ID as well. Now, the frontend can identify itself into the
    system, and because the `users` variable is updated, we should notify the rest
    of the world about this via the `sendUsers` function. We start listening for the
    `send` message, and once it comes, we update the user''s name in the array with
    the `setUsername` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The subsequent lines check whether there is a `toUser` property. If there is
    one, we know that it contains IDs of some of the other users. So, we simply find
    the user ID and pass the message to the exact socket. If there is no `toUser`
    property, then the data is again sent to everyone using `io.sockets.emit('receive',
    data)`. Together with `toUser`, the frontend should also send `fromUser`. That's
    because normally the guy who sends the text doesn't see its message on the screen
    until the server sends it back. We will use `fromUser` to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the frontend of the chat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we have to do is to show the available users on the screen
    so that we can choose one of them to chat with. Just below the input fields, we
    will add a drop-down menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need a few new variables defined. A new shortcut to the `select` element,
    the currently selected user from the list, and a variable that will hold the current
    user''s ID. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `send` method has changed a bit. We can see it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that we are sending the user''s name in a separate property,
    that is, the ID of the user and the ID of the user we want to chat with. If there
    is no such user, then the value is just an empty string. The `display` method
    can stay the same. We need one more event listener for the drop-down menu changes.
    We will add it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the work is done in the listeners of the socket object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, the `welcome` message is received. It comes with the ID, so we will store
    it in our local variable. We show the welcome message, enable the input, and bring
    the focus there. No changes here. What is new is the last message listener. That's
    the place where we populate the drop-down menu with data. We compose an HTML string
    and set it as a value of the `innerHTML` property at the end. There are two checks.
    The first one prevents the current user from showing in the `select` element.
    The second condition automatically selects a user from the list. This is actually
    quite important because the user's message can be sent many times and the menu
    should maintain its selection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to create a real-time chat by using Socket.IO.
    It's a great Node.js module that simplifies work with WebSockets. It is a technology
    that is widely used today and is part of the future's applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use BackboneJS to create a simple
    to-do application. Again, we will manage the data with the help of Node.js.
  prefs: []
  type: TYPE_NORMAL
