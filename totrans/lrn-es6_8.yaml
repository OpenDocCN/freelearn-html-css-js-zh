- en: Chapter 8. Modular Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 模块化编程
- en: '**Modular programming** is one of the most important and frequently used software
    design techniques. Unfortunately, JavaScript didn''t support modules natively
    that lead JavaScript programmers to use alternative techniques to achieve modular
    programming in JavaScript. But now, ES6 brings modules in to JavaScript officially.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化编程**是软件设计中最重要且最常用的技术之一。不幸的是，JavaScript没有原生支持模块，这导致JavaScript程序员使用替代技术来实现JavaScript中的模块化编程。但现在，ES6正式将模块引入JavaScript。'
- en: This chapter is all about how to create and import JavaScript modules. In this
    chapter, we will first learn how the modules were created earlier, and then we
    will jump to the new built-in module system that was introduced in ES6, known
    as the ES6 modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于如何创建和导入JavaScript模块。在本章中，我们将首先学习模块是如何在早期创建的，然后我们将跳转到ES6中引入的新内置模块系统，称为ES6模块。
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: What is modular programming?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模块化编程？
- en: The benefits of modular programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化编程的好处
- en: The basics of IIFE modules, AMD, UMD, and CommonJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFE模块、AMD、UMD和CommonJS的基本原理
- en: Creating and importing the ES6 modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和导入ES6模块
- en: The basics of the Modular Loader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块加载器的基本原理
- en: Creating a basic JavaScript library using modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块创建基本的JavaScript库
- en: The JavaScript modules in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍JavaScript模块
- en: The practice of breaking down programs and libraries into modules is called
    modular programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序和库分解为模块的实践称为模块化编程。
- en: In JavaScript, a module is a collection of related objects, functions, and other
    components of a program or library that are wrapped together and isolated from
    the scope of the rest of the program or library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模块是一组相关的对象、函数和其他程序或库的组件，它们被封装在一起，并从程序或库的其余部分或库的作用域中隔离出来。
- en: A module exports some variables to the outside program to let it access the
    components wrapped by the module. To use a module, a program needs to import the
    module and the variables exported by the module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将一些变量导出到外部程序，以便它访问模块封装的组件。要使用模块，程序需要导入模块及其导出的变量。
- en: A module can also be split into further modules called as its submodules, thus
    creating a module hierarchy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以进一步拆分为称为其子模块的模块，从而创建模块层次结构。
- en: 'Modular programming has many benefits. Some benefits are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程有许多好处。其中一些好处包括：
- en: It keeps our code both cleanly separated and organized by splitting into multiple
    modules
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将代码拆分为多个模块，它既保持了代码的清晰分离，又进行了组织。
- en: Modular programming leads to fewer global variables, that is, it eliminates
    the problem of global variables, because modules don't interface via the global
    scope, and each module has its own scope
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化编程导致全局变量更少，也就是说，它消除了全局变量的问题，因为模块不通过全局作用域进行接口，每个模块都有自己的作用域
- en: Makes code reusability easier as importing and using the same modules in different
    projects is easier
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得代码的可重用性更容易，因为在不同项目中导入和使用相同的模块更容易。
- en: It allows many programmers to collaborate on the same program or library, by
    making each programmer to work on a particular module with a particular functionality
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许许多程序员在同一程序或库上协作，通过让每个程序员针对具有特定功能的特定模块进行工作。
- en: Bugs in an application can easily be easily identified as they are localized
    to a particular module
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的错误可以很容易地识别，因为它们被局部化到特定的模块中
- en: Implementing modules – the old way
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模块——旧的方式
- en: Before ES6, JavaScript had never supported modules natively. Developers used
    other techniques and third-party libraries to implement modules in JavaScript.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，JavaScript从未支持过原生的模块。开发者使用其他技术和第三方库在JavaScript中实现模块。
- en: Using **Immediately-invoked function expression** (**IIFE**), **Asynchronous
    Module Definition** (**AMD**), **CommonJS**, and **Universal Module Definition**
    (**UMD**) are various popular ways of implementing modules in ES5\. As these ways
    were not native to JavaScript, they had several problems. Let's see an overview
    of each of these old ways of implementing modules.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**立即执行函数表达式**（**IIFE**）、**异步模块定义**（**AMD**）、**CommonJS**和**通用模块定义**（**UMD**）是ES5中实现模块的多种流行方式。由于这些方式并非JavaScript的本地特性，它们存在一些问题。让我们来概述一下这些旧的模块实现方式。
- en: The Immediately-Invoked Function Expression
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即执行函数表达式
- en: The IIFE is used to create an anonymous function that invokes itself. Creating
    modules using IIFE is the most popular way of creating modules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 立即执行函数表达式（IIFE）用于创建一个自调用的匿名函数。使用IIFE创建模块是创建模块最流行的方式。
- en: 'Let''s see an example of how to create a module using IIFE:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用IIFE创建模块的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we created a module using IIFE. The `sum` and `sub` variables are global
    to the module, but not visible outside of the module. The `math` variable is exported
    by the module to the main program to expose the functionalities that it provides.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用IIFE创建了一个模块。`sum`和`sub`变量在模块内部是全局的，但在模块外部不可见。`math`变量由模块导出到主程序，以公开它提供的功能。
- en: This module works completely independent of the program, and can be imported
    by any other program by simply copying it into the source code, or importing it
    as a separate file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块完全独立于程序，可以通过将其复制到源代码中或作为单独的文件导入，由任何其他程序导入。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A library using IIFE, such as jQuery, wraps its all of its APIs in a single
    IIFE module. When a program uses a jQuery library, it automatically imports the
    module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立即执行函数表达式（IIFE）的库，例如jQuery，将其所有API封装在一个单独的IIFE模块中。当程序使用jQuery库时，它会自动导入该模块。
- en: Asynchronous Module Definition
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步模块定义
- en: AMD is a specification for implementing modules in browser. AMD is designed
    by keeping the browser limitations in mind, that is, it imports modules asynchronously
    to prevent blocking the loading of a webpage. As AMD is not a native browser specification,
    we need to use an AMD library. **RequireJS** is the most popular AMD library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AMD是浏览器中实现模块化的规范。AMD在设计时考虑到浏览器的限制，即异步导入模块以防止阻塞网页的加载。由于AMD不是浏览器的原生规范，我们需要使用AMD库。**RequireJS**是最流行的AMD库。
- en: 'Let''s see an example on how to create and import modules using RequireJS.
    According to the AMD specification, every module needs to be represented by a
    separate file. So first, create a file named `math.js` that represents a module.
    Here is the sample code that will be inside the module:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用RequireJS创建和导入模块的示例。根据AMD规范，每个模块都需要由一个单独的文件表示。因此，首先创建一个名为`math.js`的文件，表示一个模块。以下是模块中的示例代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the module exports the `math` variable to expose its functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块导出`math`变量以公开其功能。
- en: 'Now, let''s create a file named `index.js`, which acts like the main program
    that imports the module and the exported variables. Here is the code that will
    be inside the `index.js` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`index.js`的文件，它充当主程序，导入模块和导出的变量。以下是`index.js`文件中的代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `math` variable in the first parameter is the name of the file that is
    treated as the AMD module. The `.js` extension to the file name is added automatically
    by RequireJS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数中的`math`变量是作为AMD模块处理的文件名。文件名`.js`扩展名由RequireJS自动添加。
- en: The `math` variable, which is in the second parameter, references the exported
    variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数中的`math`变量引用了导出的变量。
- en: Here, the module is imported asynchronously, and the callback is also executed
    asynchronously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块是异步导入的，回调函数也是异步执行的。
- en: CommonJS
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS
- en: CommonJS is a specification for implementing modules in **Node.js**. According
    to the CommonJS specification, every module needs to be represented by a separate
    file. The CommonJS modules are imported synchronously.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS是Node.js中实现模块化的规范。根据CommonJS规范，每个模块都需要由一个单独的文件表示。CommonJS模块是同步导入的。
- en: 'Let''s see an example on how to create and import modules using CommonJS. First,
    we will create a file named `math.js` that represents a module. Here is a sample
    code that will be inside the module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用CommonJS创建和导入模块的示例。首先，我们将创建一个名为`math.js`的文件，表示一个模块。以下是模块中的示例代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the module exports the `math` variable to expose its functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块导出`math`变量以公开其功能。
- en: 'Now, let''s create a file named `index.js`, which acts like the main program
    that imports the module. Here is the code that will be inside the `index.js` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`index.js`的文件，它充当主程序，导入模块。以下是`index.js`文件中的代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `math` variable is the name of the file that is treated as module.
    The `.js` extension to the file name is added automatically by CommonJS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`math`变量是作为模块处理的文件名。CommonJS会自动为文件名添加`.js`扩展名。
- en: Universal Module Definition
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用模块定义
- en: We saw three different specifications of implementing modules. These three specifications
    have their own respective ways of creating and importing modules. Wouldn't it
    have been great if we can create modules that can be imported as an IIFE, AMD,
    or CommonJS module?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了实现模块的三个不同规范。这三个规范都有它们各自创建和导入模块的方式。如果我们可以创建可以以 IIFE、AMD 或 CommonJS 模块导入的模块，那岂不是很好？
- en: UMD is a set of techniques that is used to create modules that can be imported
    as an IIFE, CommonJS, or AMD module. Therefore now, a program can import third-party
    modules, irrespective of what module specification it is using.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: UMD 是一组技术，用于创建可以作为 IIFE、CommonJS 或 AMD 模块导入的模块。因此，现在程序可以导入第三方模块，无论它使用的是哪种模块规范。
- en: 'The most popular UMD technique is `returnExports`. According to the `returnExports`
    technique, every module needs to be represented by a separate file. So, let''s
    create a file named `math.js` that represents a module. Here is the sample code
    that will be inside the module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的 UMD 技术是 `returnExports`。根据 `returnExports` 技术规范，每个模块都需要由一个单独的文件表示。所以，让我们创建一个名为
    `math.js` 的文件来表示一个模块。以下是模块内部的示例代码：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can successfully import the `math.js` module any way that you wish,
    for instance, by using CommonJS, RequireJS, or IIFE.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以根据需要成功导入 `math.js` 模块，例如，使用 CommonJS、RequireJS 或 IIFE。
- en: Implementing modules – the new way
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模块 – 新方法
- en: ES6 introduced a new module system called ES6 modules. The ES6 modules are supported
    natively and therefore, they can be referred as the standard JavaScript modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了一种新的模块系统，称为 ES6 模块。ES6 模块是原生支持的，因此它们可以被称为标准 JavaScript 模块。
- en: You should consider using ES6 modules instead of the old ways, because they
    have neater syntax, better performance, and many new APIs that are likely to be
    packed as the ES6 modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑使用 ES6 模块而不是旧方法，因为它们有更简洁的语法、更好的性能，以及许多可能作为 ES6 模块打包的新 API。
- en: Let's have a look at the ES6 modules in detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看ES6模块。
- en: Creating the ES6 modules
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ES6 模块
- en: Every ES6 module needs to be represented by a separate `.js` file. An ES6 module
    can contain any JavaScript code, and it can export any number of variables.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ES6模块都需要由一个单独的 `.js` 文件表示。ES6模块可以包含任何JavaScript代码，并且可以导出任意数量的变量。
- en: A module can export a variable, function, class, or any other entity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以导出一个变量、函数、类或任何其他实体。
- en: 'We need to use the `export` statement in a module to export variables. The
    `export` statement comes in many different formats. Here are the formats:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在模块中使用 `export` 语句来导出变量。`export` 语句有多种不同的格式。以下是这些格式：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are the differences in these formats:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式之间的区别如下：
- en: The first format exports a variable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种格式导出一个变量。
- en: The second format is used to export multiple variables.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种格式用于导出多个变量。
- en: The third format is used to export a variable with another name, that is, an
    alias.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种格式用于使用另一个名称导出一个变量，即别名。
- en: The fourth format is used to export multiple variables with different names.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四种格式用于导出具有不同名称的多个变量。
- en: The fifth format uses `default` as the alias. We will find out the use of this
    later in this chapter.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五种格式使用 `default` 作为别名。我们将在本章后面了解这种用法。
- en: The sixth format is similar to fourth format, but it also has the `default`
    alias.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六种格式与第四种格式类似，但它也具有 `default` 别名。
- en: The seventh format works similar to fifth format, but here you can place an
    expression instead of a variable name.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第七种格式与第五种格式类似，但在这里你可以放置一个表达式而不是变量名。
- en: The eighth format is used to export the exported variables of a submodule.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第八种格式用于导出子模块的导出变量。
- en: The ninth format is used to export all the exported variables of a submodule.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第九种格式用于导出子模块的所有导出变量。
- en: 'Here are some important things that you need to know about the `export` statement:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `export` 语句，以下是一些你需要了解的重要事项：
- en: An export statement can be used anywhere in a module. It's not compulsory to
    use it at the end of the module.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出语句可以在模块的任何位置使用。不需要在模块的末尾使用它。
- en: There can be any number of `export` statements in a module.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中可以有任意数量的 `export` 语句。
- en: You cannot export variables on demand. For example, placing the `export` statement
    in the `if…else` condition throws an error. Therefore, we can say that the module
    structure needs to be static, that is, exports can be determined on compile time.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能按需导出变量。例如，将 `export` 语句放在 `if…else` 条件中会抛出错误。因此，我们可以说模块结构需要是静态的，即导出可以在编译时确定。
- en: You cannot export the same variable name or alias multiple times. But you can
    export a variable multiple times with a different alias.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能多次导出相同的变量名或别名。但您可以多次导出变量，使用不同的别名。
- en: All the code inside a module is executed in the `strict` mode by default.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，模块内的所有代码都在 `strict` 模式下执行。
- en: The values of the exported variables can be changed inside the module that exported
    them.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出变量的值可以在导出它们的模块内部更改。
- en: Importing the ES6 modules
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入 ES6 模块
- en: 'To import a module, we need to use the `import` statement. The `import` statement
    comes in many different formats. Here are the formats:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个模块，我们需要使用 `import` 语句。`import` 语句有多种不同的格式。以下是格式：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An `import` statement consists of two parts: the variable names we want to
    import and the relative path of the module.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `import` 语句由两部分组成：我们想要导入的变量名和模块的相对路径。
- en: 'Here are the differences in these formats:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些格式之间的差异：
- en: In the first format, the `default` alias is imported. The `x` is alias of the
    `default` alias.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种格式中，导入的是 `default` 别名。`x` 是 `default` 别名的别名。
- en: In the second format, the `x` variable is imported.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种格式中，导入的是 `x` 变量。
- en: The third format is the same as the second format. It's just that `x2` is an
    alias of `x1`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种格式与第二种格式相同。只是 `x2` 是 `x1` 的别名。
- en: In the fourth format, we import the `x1` and `x2` variables.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四种格式中，我们导入 `x1` 和 `x2` 变量。
- en: In the fifth format, we import the `x1` and `x2` variables. The `x3` is an alias
    of the `x2` variable.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第五种格式中，我们导入 `x1` 和 `x2` 变量。`x3` 是 `x2` 变量的别名。
- en: In the sixth format, we import the `x1` and `x2` variable, and the `default`
    alias. The `x` is an alias of the `default` alias.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第六种格式中，我们导入 `x1` 和 `x2` 变量以及 `default` 别名。`x` 是 `default` 别名的别名。
- en: In the seventh format, we just import the module. We do not import any of the
    variables exported by the module.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第七种格式中，我们只导入模块。我们不导入模块导出的任何变量。
- en: In the eighth format, we import all the variables, and wrap them in an object
    called `x`. Even the `default` alias is imported.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第八种格式中，我们导入所有变量，并将它们包装在一个名为 `x` 的对象中。即使是 `default` 别名也被导入。
- en: The ninth format is the same as the eighth format. Here, we give another alias
    to the `default` alias.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第九种格式与第八种格式相同。在这里，我们给 `default` 别名提供了另一个别名。
- en: 'Here are some important things that you need to know about the `import` statement:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于 `import` 语句的重要事项，您需要了解：
- en: While importing a variable, if we import it with an alias, then to refer to
    that variable, we have to use the alias and not the actual variable name, that
    is, the actual variable name will not be visible, only the alias will be visible.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入变量时，如果我们用别名导入它，那么要引用该变量，我们必须使用别名而不是实际变量名，也就是说，实际变量名将不可见，只有别名将是可见的。
- en: The `import` statement doesn't import a copy of the exported variables; rather,
    it makes the variables available in the scope of the program that imports it.
    Therefore, if you make a change to an exported variable inside the module, then
    the change is visible to the program that imports it.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import` 语句不会导入导出变量的副本；相反，它使变量在导入它的程序的作用域中可用。因此，如果您在模块内部更改导出的变量，则更改对导入它的程序是可见的。'
- en: The imported variables are read-only, that is, you cannot reassign them to something
    else outside of the scope of the module that exports them.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的变量是只读的，也就是说，您不能在导出它们的模块作用域之外将它们重新分配给其他内容。
- en: A module can only be imported once in a single instance of a JavaScript engine.
    If we try to import it again, then the already imported instance of the module
    will be used.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 引擎的单个实例中，一个模块只能导入一次。如果我们再次尝试导入，则将使用已导入的模块实例。
- en: We cannot import modules on demand. For example, placing the `import` statement
    in the `if…else` condition throws an error. Therefore, we can say that the imports
    should be able to be determined on compile time.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能按需导入模块。例如，将 `import` 语句放在 `if…else` 条件中会抛出错误。因此，我们可以说导入应该在编译时确定。
- en: The ES6 imports are faster than the AMD and CommonJS imports, because the ES6
    imports are supported natively and also as importing modules and exporting variables
    are not decided on demand. Therefore, it makes JavaScript engine easier to optimize
    performance.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 导入比 AMD 和 CommonJS 导入更快，因为 ES6 导入是原生支持的，并且导入模块和导出变量不是按需决定的。因此，这使得 JavaScript
    引擎更容易优化性能。
- en: The module loader
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块加载器
- en: A module loader is a component of a JavaScript engine that is responsible for
    importing modules.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器是 JavaScript 引擎的一个组件，负责导入模块。
- en: The `import` statement uses the build-in module loader to import modules.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句使用内置模块加载器来导入模块。'
- en: The built-in module loaders of the different JavaScript environments use different
    module loading mechanisms. For example, when we import a module in JavaScript
    running in the browsers, then the module is loaded from the server. On the other
    hand, when we import a module in Node.js, then the module is loaded from filesystem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不同 JavaScript 环境的内置模块加载器使用不同的模块加载机制。例如，当我们导入在浏览器中运行的 JavaScript 模块时，模块是从服务器加载的。另一方面，当我们导入
    Node.js 中的模块时，模块是从文件系统中加载的。
- en: The module loader loads modules in a different manner, in different environments,
    to optimize the performance. For example, in the browsers, the module loader loads
    and executes modules asynchronously in order to prevent the importing of the modules
    that block the loading of a webpage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器以不同的方式在不同的环境中加载模块，以优化性能。例如，在浏览器中，模块加载器异步加载和执行模块，以防止导入的模块阻塞网页的加载。
- en: You can programmatically interact with the built-in module loader using the
    module loader API to customize its behavior, intercept module loading, and fetch
    the modules on demand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用模块加载器 API 以编程方式与内置模块加载器交互，以自定义其行为，拦截模块加载，并按需获取模块。
- en: We can also use this API to create our own custom module loaders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用此 API 创建我们自己的自定义模块加载器。
- en: The specifications of the module loader are not specified in ES6\. It is a separate
    standard, controlled by the **WHATWG** browser standard group. You can find the
    specifications of the module loader at [http://whatwg.github.io/loader/](http://whatwg.github.io/loader/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中没有指定模块加载器的规范。它是一个独立的标准，由**WHATWG**浏览器标准小组控制。您可以在[http://whatwg.github.io/loader/](http://whatwg.github.io/loader/)找到模块加载器的规范。
- en: The ES6 specifications only specify the `import` and `export` statements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 规范仅指定了 `import` 和 `export` 语句。
- en: Using modules in browsers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中使用模块
- en: The code inside the `<script>` tag doesn't support the `import` statement, because
    the tag's synchronous nature is incompatible with the asynchronicity of the modules
    in browsers. Instead, you need to use the new `<module>` tag to import modules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>` 标签内的代码不支持 `import` 语句，因为标签的同步性质与浏览器中模块的异步性不兼容。相反，您需要使用新的 `<module>`
    标签来导入模块。'
- en: Using the new `<module>` tag, we can define a script as a module. Now, this
    module can import other modules using the `import` statement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `<module>` 标签，我们可以将脚本定义为模块。现在，这个模块可以使用 `import` 语句导入其他模块。
- en: If you want to import a module using the `<script>` tag, then you have to use
    the **Module Loader API**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 `<script>` 标签导入模块，那么您必须使用**模块加载器 API**。
- en: The specifications of the `<module>` tag are not specified in ES6.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`<module>` 标签的规范没有在 ES6 中指定。'
- en: Using modules in the eval() function
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 eval() 函数中使用模块
- en: You cannot use the `import` and `export` statements in the `eval()` function.
    To import modules in the `eval()` function, you need to use the Module Loader
    API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在 `eval()` 函数中使用 `import` 和 `export` 语句。要在 `eval()` 函数中导入模块，您需要使用模块加载器 API。
- en: The default exports vs. the named exports
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认导出与命名导出的比较
- en: When we export a variable with the `default` alias, then it's called as a **default
    export**. Obviously, there can only be one default export in a module, as an alias
    can be used only once.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `default` 别名导出一个变量时，它被称为**默认导出**。显然，一个模块中只能有一个默认导出，因为别名只能使用一次。
- en: All the other exports except the default export are called as **named exports**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认导出之外的所有导出都称为**命名导出**。
- en: It's recommended that a module should either use default export or named exports.
    It's not a good practice to use both together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 建议模块要么使用默认导出，要么使用命名导出。同时使用两者不是一个好的做法。
- en: The default export is used when we want to export only one variable. On the
    other hand, the named exports are used when we want to export the multiple variables.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只想导出一个变量时，使用默认导出。另一方面，当我们要导出多个变量时，使用命名导出。
- en: Diving into an example
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入一个例子
- en: Let's create a basic JavaScript library using the ES6 modules. This will help
    us understand how to use the `import` and `export` statements. We will also learn
    how a module can import other modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 ES6 模块创建一个基本的 JavaScript 库。这将帮助我们了解如何使用 `import` 和 `export` 语句。我们还将学习一个模块如何导入其他模块。
- en: 'The library that we will create is going to be a math library, which provides
    basic logarithmic and trigonometric functions. Let''s get started with creating
    our library:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的库将是一个数学库，它提供基本的对数和三角函数。让我们开始创建我们的库：
- en: Create a file named `math.js`, and a directory named `math_modules`. Inside
    the `math_modules` directory, create two files named `logarithm.js` and `trigonometry.js,`
    respectively.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `math.js` 的文件，以及一个名为 `math_modules` 的目录。在 `math_modules` 目录内，分别创建两个名为
    `logarithm.js` 和 `trigonometry.js` 的文件。
- en: Here, the `math.js` file is the root module, whereas the `logarithm.js` and
    the `trigonometry.js` files are its submodules.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`math.js` 文件是根模块，而 `logarithm.js` 和 `trigonometry.js` 文件是其子模块。
- en: 'Place this code inside the `logarithm.js` file:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此代码放置在 `logarithm.js` 文件中：
- en: '[PRE8]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the module is exporting the functions named as exports.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，模块导出的是名为 exports 的函数。
- en: It's preferred that the low-level modules in a module hierarchy should export
    all the variables separately, because it may be possible that a program may need
    just one exported variable of a library. In this case, a program can import this
    module and a particular function directly. Loading all the modules when you need
    just one module is a bad idea in terms of performance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块层次结构中，低级模块应该分别导出所有变量是首选的，因为可能程序只需要库中的一个导出变量。在这种情况下，程序可以直接导入此模块和特定函数。当你只需要一个模块时加载所有模块在性能方面是不好的。
- en: 'Similarly, place this code in the `trigonometry.js` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将此代码放置在 `trigonometry.js` 文件中：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we do something similar. Place this code inside the `math.js` file, which
    acts as the root module:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们做类似的事情。将此代码放置在 `math.js` 文件中，该文件作为根模块：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It doesn't contain any library functions. Instead, it makes easy for a program
    to import the complete library. It imports its submodules, and then exports their
    exported variables to the main program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它不包含任何库函数。相反，它使得程序能够轻松导入整个库。它导入其子模块，然后将它们导出的变量导出到主程序中。
- en: Here, in case the `logarithm.js` and `trigonometry.js` scripts depends on other
    submodules, then the `math.js` module shouldn't import those submodules, because
    `logarithm.js` and `trigonometry.js` are already importing them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果 `logarithm.js` 和 `trigonometry.js` 脚本依赖于其他子模块，那么 `math.js` 模块不应该导入这些子模块，因为
    `logarithm.js` 和 `trigonometry.js` 已经导入了它们。
- en: 'Here is the code using which a program can import the complete library:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序可以用来导入整个库的代码：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what modular programming is and learned different modular
    programming specifications. Finally, we created a basic library using the modular
    programming design technique. Now, you should be confident enough to build the
    JavaScript apps using the ES6 modules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了模块化编程是什么，学习了不同的模块化编程规范。最后，我们使用模块化编程设计技术创建了一个基本的库。现在，你应该有足够的信心使用 ES6
    模块构建 JavaScript 应用程序。
