<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Deploying Node.js Applications"><div class="titlepage" id="aid-1UU542"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Deploying Node.js Applications</h1></div></div></div><p>So far, we have only run our application in our local development environment. In this chapter, we will deploy it to the Web. There are many different options for hosting an application. We will work through one deployment option to quickly get an application up and running. We will also discuss broader principles and alternative options for deploying Node.js applications.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Deploying our application to the Web</li><li class="listitem">Using application logs to diagnose issues on remote servers</li><li class="listitem">Setting up database servers and environmental configuration</li><li class="listitem">Deploying automatically from Travis CI</li></ul></div><div class="note" title="Note"><h3 class="title"><a id="tip14"/>Tip</h3><p>If you want to follow along with this chapter, you can use the code from <a class="ulink" href="https://github.com/NodeJsForDevelopers/chapter10/">https://github.com/NodeJsForDevelopers/chapter10/</a> as a starting point. This contains the example code from the end of <a class="link" title="Chapter 10. Creating Real-time Web Apps" href="part0058.xhtml#aid-1NA0K1">Chapter 10</a>, <span class="emphasis"><em>Creating Real-time Web Apps</em></span>, which we will build on in this chapter.</p></div><div class="section" title="Working with Heroku"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>Working with Heroku</h1></div></div></div><p>
<span class="strong"><strong>Heroku</strong></span> is a <a id="id465" class="indexterm"/>cloud-based platform for web applications. It aims to allow developers to focus on applications rather than infrastructure. It provides a low-friction workflow for deploying a new application quickly, while also supporting long-term scalability. It also offers a marketplace of add-on services, such as databases and monitoring.</p><p>There are several similar services to Heroku, some of which we will cover later in this chapter. Heroku was one of the first services of its kind. In particular, it was one of the first to support Node.js as a first-class citizen. It also offers many features for free, including everything needed for the worked example in this section.</p><div class="note" title="Note"><h3 class="title"><a id="note14"/>Note</h3><p>Note that Heroku's <a id="id466" class="indexterm"/>free features are sufficient for deploying an application for development, demonstration, or experimental purposes. It would not be sufficient for a production deployment of an application <a id="id467" class="indexterm"/>serving end users. See <a class="ulink" href="https://www.heroku.com/pricing">https://www.heroku.com/pricing</a> for details of Heroku's pricing tiers.</p></div><div class="section" title="Setting up a Heroku account and tooling"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec65"/>Setting up a Heroku account and tooling</h2></div></div></div><p>To follow the <a id="id468" class="indexterm"/>example in this section, you will first need to sign up for Heroku at <a class="ulink" href="https://signup.heroku.com/">https://signup.heroku.com/</a>.</p><p>We will also be using the heroku toolbelt, a CLI for configuring Heroku. Download and install the version for <a id="id469" class="indexterm"/>your platform from <a class="ulink" href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a>.</p><p>Check that the heroku toolbelt is installed correctly and available on your path. Open a new command prompt and run the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku</strong></span>
</pre></div><p>You should see the help text with a list of available commands. Configure the toolbelt to use your Heroku account by running the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku login</strong></span>
</pre></div></div><div class="section" title="Running an application locally with Heroku"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec66"/>Running an application locally with Heroku</h2></div></div></div><p>Heroku requires a<a id="id470" class="indexterm"/> small configuration file (similar to <code class="literal">.travis.yml</code>) telling it how to run our application. This is a file named <span class="strong"><strong>Procfile</strong></span>, which in our case <a id="id471" class="indexterm"/>contains a single line as follow<a id="id472" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">web: npm start</pre></div><p>This tells Heroku that our application consists of a single web process, which can be started with <code class="literal">npm start</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note15"/>Note</h3><p>Note, especially if you are used to the Windows filesystem, that the uppercase P in the filename is important. The application will be deployed to a Unix-like system, where filenames are case-sensitive.</p></div><p>To verify our <code class="literal">Procfile</code>, we can run our application locally using Heroku:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku local</strong></span>
</pre></div><p>This will launch our application using the <code class="literal">Procfile</code>. Note that it also sets a default port of <code class="literal">5000</code>. You should now be able to visit the application at <code class="literal">http://localhost:5000</code>.</p><p>The <code class="literal">heroku local</code> command also sets up environment variables for our application. These are read from a local <code class="literal">.env</code> file at the root of our application:</p><div class="informalexample"><pre class="programlisting">MONGODB_URL=mongodb://localhost/hangman
REDIS_URL=redis://127.0.0.1:6379/</pre></div><p>You can test<a id="id473" class="indexterm"/> this by starting up local instances of MongoDB and<a id="id474" class="indexterm"/> Redis. Run the following commands in separate prompts (setting the <code class="literal">--dbpath</code> as appropriate):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; redis-server</strong></span>
<span class="strong"><strong>&gt; mongod --dbpath C:\data\mongodb</strong></span>
<span class="strong"><strong>&gt; heroku local</strong></span>
</pre></div><p>Having this <code class="literal">.env</code> file means that we can use <code class="literal">npm start</code> directly (as we have before) to run with mock datastores and <code class="literal">heroku local</code> when we want a more realistic environment, without having to keep track of our current environment variables.</p></div><div class="section" title="Deploying an application to Heroku"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec67"/>Deploying an application to Heroku</h2></div></div></div><p>Now that we <a id="id475" class="indexterm"/>have created a <code class="literal">Procfile</code>, deploying our application<a id="id476" class="indexterm"/> to the web is easy. First, we need to create a new Heroku application:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku create</strong></span>
</pre></div><p>By default, this provisions a minimal application on Heroku, with a randomly assigned name. You can optionally specify an application name as a third parameter.</p><p>This command also returns the public URL for our newly-created app, which we can visit now. The following response is returned:</p><div class="mediaobject"><img src="../Images/image00222.jpeg" alt="Deploying an application to Heroku"/></div><p style="clear:both; height: 1em;"> </p><p>There's not much to see because we haven't deployed anything yet. The quickest way to deploy an application to Heroku is via Git. The <code class="literal">heroku create</code> command also created a new Git remote <a id="id477" class="indexterm"/>for us to push to. You can see this by viewing the<a id="id478" class="indexterm"/> list of Git remotes:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; git remote -v</strong></span>
</pre></div><p>We now have a Git remote named <code class="literal">heroku</code>. Make sure the new <code class="literal">Procfile</code> has been committed. Now, when we push our master branch to this remote, it is automatically built and deployed:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; git push heroku master</strong></span>
</pre></div><p>If we visit the application's URL again now, we see the following:</p><div class="mediaobject"><img src="../Images/image00223.jpeg" alt="Deploying an application to Heroku"/></div><p style="clear:both; height: 1em;"> </p><p>Our application has deployed but is now returning an error. To diagnose the problem with our application, we'll need to look at the logs.</p></div><div class="section" title="Working with Heroku logs, config, and services"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec68"/>Working with Heroku logs, config, and services</h2></div></div></div><p>We can view<a id="id479" class="indexterm"/> the logs from our application by running <code class="literal">heroku logs</code>. If you<a id="id480" class="indexterm"/> look through the logs to the error stacktrace, you'll <a id="id481" class="indexterm"/>see the following error message:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>app[web.1]: Error: Cannot find module 'mockgoose'</strong></span>
</pre></div><p>The <code class="literal">mockgoose</code> package is unavailable because Heroku builds our application using the <code class="literal">dependencies</code> in <code class="literal">package.json</code> and not the <code class="literal">devDependencies</code>. Recall from <a class="link" title="Chapter 9. Persisting Data" href="part0052.xhtml#aid-1HIT82">Chapter 9</a>, <span class="emphasis"><em>Persisting Data</em></span>, that this error is intentional. We wanted the application to fail in live environments if no MongoDB URL is configured.</p><p>To fix this <a id="id482" class="indexterm"/>error, we need to set up a MongoDB instance and<a id="id483" class="indexterm"/> configure our application to connect to it. We'll need to do the<a id="id484" class="indexterm"/> same for our Redis DB. Both of these data stores are available as services from the Heroku marketplace.</p><div class="section" title="Setting up MongoDB"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec15"/>Setting up MongoDB</h3></div></div></div><p>We can add Heroku marketplace services via the command line. MongoLab is a third-party service <a id="id485" class="indexterm"/>providing MongoDB instances. We can add an instance to <a id="id486" class="indexterm"/>our application as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku addons:create mongolab:sandbox</strong></span>
</pre></div><p>This creates a sandbox (free tier) MongoDB instance, suitable for demo purposes. Note from the output of this command that it also created a <code class="literal">MONGOLAB_URI</code> config variable. Heroku will provide this to our application as an environment variable at runtime.</p><p>Our application is expecting an environment variable named <code class="literal">MONGODB_URL</code>. We'll need to create this and set it to the same value as <code class="literal">MONGOLAB_URI</code>. You can view and set config variables for an application as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku config</strong></span>
<span class="strong"><strong>&gt; heroku config:set MONGODB_URL=mongodb://...</strong></span>
</pre></div><p>You should fill in the value of <code class="literal">MONGODB_URL</code> to match the value of <code class="literal">MONGOLAB_URI</code> returned by the first command.</p></div><div class="section" title="Setting up Redis"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec16"/>Setting up Redis</h3></div></div></div><p>Heroku also<a id="id487" class="indexterm"/> provides a Redis service via its marketplace. We'll<a id="id488" class="indexterm"/> add it to our application as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku addons:create heroku-redis:hobby-dev --as:REDIS</strong></span>
</pre></div><p>Again we use the free tier version of this service (hobby-dev) for demo purposes. It's easy to re-scale services to different tiers later.</p><p>The Redis service also allows you to specify an alias for the created service instance. Aliases are specified using the <code class="literal">--as</code> parameter with <code class="literal">heroku addons:create</code>. This is useful for Redis as we may have several Redis instances associated with a single application. It's particularly useful for us, since, by aliasing our instance as REDIS, Heroku will create a <code class="literal">REDIS_URL</code> environment variable. This is exactly what our application expects to see.</p><p>The <code class="literal">heroku addons:create</code> command restarts our application immediately. Our new database instances will take a minute or two to become available though. Wait a minute before restarting the application:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku restart</strong></span>
</pre></div><p>We can now<a id="id489" class="indexterm"/> visit the application URL in our browser and see it running <a id="id490" class="indexterm"/>on the Web!</p><div class="mediaobject"><img src="../Images/image00224.jpeg" alt="Setting up Redis"/></div><p style="clear:both; height: 1em;"> </p></div></div></div></div>
<div class="section" title="Deploying from Travis CI" id="aid-1VSLM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>Deploying from Travis CI</h1></div></div></div><p>Deploying via Git is a quick way to get up and running and is useful for developers. It's not a robust way of pushing out changes though. If we are practicing Continuous Delivery then we may want to deploy on every commit, at least to a UAT environment. But we still want our<a id="id491" class="indexterm"/> CI server to act as a gatekeeper and ensure that we only deploy good builds.</p><p>Travis CI supports deployment to a wide range of hosting providers (as well as arbitrary deployment via custom scripts). We can tell Travis CI to deploy to Heroku by adding a <code class="literal">deploy</code> section to our <code class="literal">travis.yml</code> as follows (replacing <code class="literal">application-name-12345</code> with the name of our previously created Heroku application):</p><div class="informalexample"><pre class="programlisting">services:
- mongodb
- redis-server
<span class="strong"><strong>deploy:</strong></span>
<span class="strong"><strong>  provider: heroku</strong></span>
<span class="strong"><strong>  app: application-name-12345</strong></span>
<span class="strong"><strong>  api_key:</strong></span>
env:
  global:
  - MONGODB_URL=mongodb://localhost/hangman
  - REDIS_URL=redis://127.0.0.1:6379/</pre></div><p>Travis CI will<a id="id492" class="indexterm"/> only deploy our application if the build passes. In order for Travis CI to communicate with Heroku, it requires our Heroku API key. But we may not want to commit this to source control (especially if our Git repository is public). Travis CI allows you to avoid this by specifying encrypted environment variables for the build.</p><div class="section" title="Setting encrypted Travis CI environment variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec69"/>Setting encrypted Travis CI environment variables</h2></div></div></div><p>Environment <a id="id493" class="indexterm"/>variables can be encrypted <a id="id494" class="indexterm"/>using a public key that Travis CI associates with our repository. Travis CI then uses the corresponding private key to decrypt these variables at build time.</p><p>The easiest way to encrypt environment variables with the correct key is to use the Travis CLI. This is available as a Ruby package.</p><div class="section" title="Installing Ruby"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec17"/>Installing Ruby</h3></div></div></div><p>If you do<a id="id495" class="indexterm"/> not have Ruby installed on <a id="id496" class="indexterm"/>your<a id="id497" class="indexterm"/> system already, see <a class="ulink" href="https://www.ruby-lang.org/en/documentation/installation/">https://www.ruby-lang.org/en/documentation/installation/</a>. The best way to install on <a id="id498" class="indexterm"/>Windows is to use <code class="literal">RubyInstaller</code>, from <a class="ulink" href="http://rubyinstaller.org/">http://rubyinstaller.org/</a>.</p><p>You can check whether Ruby is installed and configured on your path by running the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; ruby -ver</strong></span>
</pre></div><p>You should have version 2.0.0 or higher.</p></div><div class="section" title="Creating an encrypted environment variable"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec18"/>Creating an encrypted environment variable</h3></div></div></div><p>Once you<a id="id499" class="indexterm"/> have Ruby installed and on your path, you can install the Travis CLI as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; gem install travis --no-rdoc --no-ri</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="note16"/>Note</h3><p>
<span class="strong"><strong>Gem</strong></span><a id="id500" class="indexterm"/> is the Ruby package manager, similar to <code class="literal">npm</code>. The <code class="literal">--no-doc</code> and <code class="literal">--no-ri</code> arguments here skip installation of low-level API docs, which we don't need.</p></div><p>Now we can<a id="id501" class="indexterm"/> add our encrypted environment variable. First we need to obtain the Heroku API key for our application:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; heroku auth:token</strong></span>
</pre></div><p>Now we can add this to our <code class="literal">.travis.yml</code> file as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; travis encrypt [AUTH_TOKEN] --add deploy.api_key</strong></span>
</pre></div><p>
<code class="literal">[AUTH_TOKEN] </code>is the output from the previous command.</p><p>This encrypts the API key and automatically adds the encrypted version into our <code class="literal">.travis.yml</code> file. Before committing, try updating something in the application, for example the page title from <code class="literal">src/routes/index.js</code>:</p><div class="informalexample"><pre class="programlisting">...
            .then(results =&gt; {
                res.render('index', {
<span class="strong"><strong>                            title: 'Hangman online',</strong></span>
                            userId: req.user.id,
                            createdGames: results[0],
...</pre></div><p>Now commit and push the master branch (to <code class="literal">origin</code>, not directly to <code class="literal">heroku</code>) and wait for the Travis CI build to complete. The build output shows our application being deployed:</p><div class="mediaobject"><img src="../Images/image00225.jpeg" alt="Creating an encrypted environment variable"/></div><p style="clear:both; height: 1em;"> </p><p>If you visit the application again, you should see the new version with the updated title.</p><p>Recall that Travis CI is actually building our application for multiple versions of Node.js. By default, Travis CI deploys our application at the end of each build job. This is unnecessary<a id="id502" class="indexterm"/> and slows down our overall build. We can tell Travis CI to deploy only from a specific build job by altering our <code class="literal">.travis.yml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">deploy:
  provider: heroku
  app: afternoon-cliffs-85674
<span class="strong"><strong>  on:</strong></span>
<span class="strong"><strong>    node: 6</strong></span>
  api_key:
    secure: ...</pre></div><p>If we commit and check the output from Travis CI again, we can see that only the Node.js v6 build job performs a deployment.</p></div></div></div>
<div class="section" title="Further resources" id="aid-20R681"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Further resources</h1></div></div></div><p>For further<a id="id503" class="indexterm"/> considerations on deploying web apps, see The Twelve-Factor App (<a class="ulink" href="http://12factor.net/">http://12factor.net/</a>). This is a detailed resource about important considerations for running enterprise-grade web applications on services such as Heroku.</p><p>There are, of course, a great many options for hosting a web application. Azure's web app service and AWS's Elastic<a id="id504" class="indexterm"/> Beanstalk both support Node.js as a first-class citizen. Modulus (<a class="ulink" href="https://modulus.io/">https://modulus.io/</a>) provides Node.js and Mongo DB hosting, with powerful scaling, monitoring, and load-balancing features.</p><p>The preceding are all <a id="id505" class="indexterm"/>examples of application hosting platforms (<span class="strong"><strong>Platform-as-a-Service</strong></span> (<span class="strong"><strong>PaaS</strong></span>), in cloud terminology). You can, of course, also deploy Node.js applications to bare infrastructure (either cloud infrastructure or your own machines). For a detailed guide, see <a class="ulink" href="https://certsimple.com/blog/deploy-node-on-linux">https://certsimple.com/blog/deploy-node-on-linux</a>.</p><p>You may need to manage releases of your application through multiple environments. Your CI server might first deploy your application to an integration environment and run tests on it there before deploying to UAT. You may then want to be able to push the exact same release from UAT to Stage and Live environments at the click of a button.</p><p>Heroku Pipelines and Azure Web App deployment slots allow you to manage the release of your application through different environments. <span class="strong"><strong>Wercker</strong></span> (<a class="ulink" href="http://wercker.com/">http://wercker.com/</a>) is a build and <a id="id506" class="indexterm"/>deployment service that can automate more complex workflows. It also provides isolated environments based on Docker containers.</p></div>
<div class="section" title="Summary" id="aid-21PMQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we have deployed an application to the web using Heroku, configured environment settings and provisioned databases, set up Travis CI to automatically deploy successful builds, and learned about further options and considerations for deploying Node.js applications.</p><p>Now that our application is available online, we can start thinking about how to integrate it with the wider Web. In the next chapter, we'll look at allowing users to log in using third party social media services as an identity provider.</p></div></body></html>