- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic Element Manipulation Using the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning the difficult concepts of the previous chapter will be rewarded in
    this chapter. We will take our DOM knowledge one step further and learn how to
    manipulate the DOM elements on the page with JavaScript. First, we need to learn
    how to navigate the DOM and select the elements we want. We will learn how we
    can add and change attributes and values, and how to add new elements to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to add style to elements, which can be used to make
    items appear and disappear. Then we will introduce you to events and event listeners.
    We will start easy, but by the end of this chapter you will be able to manipulate
    web pages in many ways, and you will have the knowledge to create basic web apps.
    The sky is the limit after getting this skill down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic DOM traversing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing elements in the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element click handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This and the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating element style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the classes of an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners on elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned a lot about the DOM already. In order to interact with our web
    page and create a dynamic web page, we have to connect our JavaScript skills to
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Basic DOM traversing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can traverse the DOM using the `document` object that we saw in the previous
    chapter. This document object contains all the HTML and is a representation of
    the web page. Traversing over these elements can get you to the element you need
    in order to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the most common way to do it, but this will help understand how
    it works later. And sometimes, you might actually find yourself needing these
    techniques as well. Just don''t panic: there are other ways to do it, and they
    will be revealed in this chapter!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even for a simple HTML piece there are already multiple ways to traverse the
    DOM. Let''s go hunting for treasure in our DOM. We start with this little HTML
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We now want to traverse the DOM of this snippet to find the treasure. We can
    do this by stepping into the document object and navigating our way from there
    onwards. It is easiest to do this exercise in the console in the browser, because
    that way you'll get direct feedback about where in the DOM you are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by using the `body` property from the document. This contains
    everything that''s inside the `body` element. In the console, we''ll type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We should get a really long object. There are a few ways from this object to
    get to our treasure. To do so, let's discuss the children and `childNodes` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`childNodes` is more a complete term than children. Children just contain all
    the HTML elements, so are really the nodes. `childNodes` also contain text nodes
    and comments. With children, however, you can use the ID, and therefore they are
    easier to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to the treasure using children you would have to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, on every element we select, we have to select the children again.
    So, first, we grab the children from the body, then we select `forest` from these
    children. Then from `forest`, we want to grab its children again, and from these
    children we want to select `tree2`. From `tree2` we want to grab the children
    again, from these children we need `shrubbery`. And then finally, we can grab
    the children from `shrubbery` and select `treasure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to the treasure using `childNodes` you would have to use your console
    a lot because text and comment nodes are also in there. `childNodes` is an array,
    so you will have to select the right index to select the right child. There is
    one advantage here: it is a lot shorter because you won''t need to select the
    name separately.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also combine them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are many ways to traverse the document. Depending on what you need, you
    might have to use one specific way. For tasks that require DOM traversing, it
    is usually the case that if it is works, it is a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen how we can move down the DOM, but we can also move up.
    Every element knows its parent. We can use the `parentElement` property to move
    back up. For example, if we use the treasure HTML sample and type this into the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are back at `forest`, since that is the parent element of `tree2`. This can
    be very useful, in particular when combined with functions such as `getElementById()`,
    which we will see later in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only can we move up and down, we can also move sideways. For example, if
    we select `tree2` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get to `tree1` using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And from `tree1` we can get to `tree2` using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative to `nextElementSibling`, which returns the next node that
    is an element, you could use `nextSibling`, which will return the next node of
    any type.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, experiment with traversing the DOM hierarchy. You can use
    this sample HTML website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and open the above sample web page, or visit your favorite website, and
    open the document body in the console with `console.dir(document)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `body.children` property, select some of the child elements. View how
    they match the page content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to and output the next nodes or elements into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting elements as objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we know how to traverse the DOM, we can make changes to the elements. Instead
    of using `console.dir()`, we can just type in the path to the element we want
    to change. We now have the element as a JavaScript object, and we can make changes
    to all its properties. Let's use a simpler HTML page for this one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can traverse to the `p` element, for example, by using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the power to manipulate the properties of the element, and the
    element itself, directly! Let's execute this newly gained power in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Changing innerText
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `innerText` property focuses on the text between the opening and closing
    of the element, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The retrieved value would be `here` as plain text. For example, if we go to
    the console and we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The message that is displayed on the page changes from `Hi!` to `Bye!` immediately.
    `innerText` returns the content of the element as plain text, which is not a problem
    in this case because there is only text in there. However, if there is any HTML
    inside the element you need to select, or if you want to add HTML, you cannot
    use this method. It will interpret the HTML as text and just output it on the
    screen. So if we executed this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It will output to the screen `<p>Bye!</p>`, with the HTML around it, as if it
    was intended as a text string. To get around this, you need to use `innerHTML`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing innerHTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you did not only want to work with plain text, or perhaps specify some HTML
    formatting with your value, you could use the `innerHTML` property instead. This
    property doesn''t just process be plain text, it can also be inner HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will display **Bye!** in bold on the screen, having taken the `b` element
    into account rather than just printing it as if it were a single string value.
  prefs: []
  type: TYPE_NORMAL
- en: You were already promised that you could access elements in a more convenient
    way than traversing the DOM. Let's see how exactly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements in the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple methods to select elements from the DOM. After getting the
    elements, we are able to modify them. In the following sections, we will discuss
    how to get elements by their ID, tag name, and class name, and by CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of traversing it step by step as we just did, we are going to use built-in
    methods that can go through the DOM and return the elements that match the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the following HTML snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by accessing elements by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can grab elements by ID with the `getElementById()` method. This returns
    one element with the specified ID. IDs should be unique, as only one result will
    be returned from the HTML document. There are not a lot of rules for valid IDs;
    they cannot contain spaces and must be at least one character. As with the conventions
    for naming variables, it is a best practice to make it descriptive and avoid special
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to select the element with an ID of `two` right away, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the full HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To reiterate, if you have more than one element with the same ID, it will just
    give you back the first one it encounters. You should avoid this situation in
    your code though.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the full file looks like with the JavaScript inside the HTML page,
    instead of simply querying the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it would log the full HTML `div` with `id="two"` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try experimenting with getting elements by their IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML element and assign an ID in the element attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the page element using its ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the selected page element into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing elements by tag name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we ask for elements by tag name, we get an array as a result. This is because
    there could be more than one element with the same tag name. It will be a collection
    of HTML elements, or `HTMLCollection`, which is a special JavaScript object. It''s
    basically just a list of nodes. Execute the following command in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all the elements in the DOM with the `div` tag are returned.
    You can read what the ID is and what the class is from the syntax. The first ones
    in the collection are the objects: `div` is the name, `#` specifies the ID, and
    `.` specifies the class. If there are multiple dots, there are multiple classes.
    Then you can see the elements again (`namedItems`), this time as key-value pairs
    with their ID as the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access them using the `item()` method to access them by index, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access them by name, using the `namedItem()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When there is only one match, it will still return an `HTMLCollection`. There
    is only one `h1` tag, so let''s demonstrate this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since `h1` doesn't have an ID or class, it is only `h1`. And since it doesn't
    have an ID, it is not a `namedItem` and is only in there once.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use JavaScript to select page elements via their tag name:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a simple HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three HTML elements using the same tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some content within each element so you can distinguish between them
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a script element to your HTML file, and within it select the page elements
    by tag name and store them in a variable as an array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the index value, select the middle element and output it into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing elements by class name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can do something very similar for class names. In our example HTML, we have
    two different class names: `example` and `something`. If you get elements by class
    name, it gives back an HTMLCollection containing the results. The following will
    get all the elements with the class `example`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it only returned the `div` tags with the `example` class. It
    left out the `div` with the `something` class.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select all matching page elements using the class name of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple HTML file to work on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three HTML elements adding the same class to each. You can use different
    tags as long as the same element class is included. Add some content within each
    element so you can distinguish between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a script element to your file, and within it select the page elements by
    class name. Assign the resulting `HTMLCollection` values to a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use an index value to select the individual `HTMLCollection` items,
    just as you would for array items. Starting with an index of 0, select one of
    the page elements with the class name and output the element into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing elements with a CSS selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also access elements using a CSS selector. We do this with `querySelector()`
    and `querySelectorAll()`. We then give the CSS selector as an argument, and this
    will filter the items in the HTML document and only return the ones that satisfy
    the CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS selector might look a bit different than you might think at first. Instead
    of looking for a certain layout, we use the same syntax as we use when we want
    to specify a layout for certain elements. We haven't discussed this yet, so we
    will cover it here briefly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we state `p` as a CSS selector, it means all the elements with tag `p`.
    This would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we say `p.example`, it means all the `p` tag elements with `example` as the
    class. They can also have other classes; as long as `example` is in there, it
    will match. We can also say `#one`, which means select all with an ID of `one`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is the same result as `getElementById()`. Which one to use is a
    matter of taste when all you really need to do is select by ID—this is great input
    for a discussion with another developer. `querySelector()` allows for more complicated
    queries, and some developers will state that `getElementById()` is more readable.
    Others will claim that you might as well use `querySelector()` everywhere for
    consistency. It doesn't really matter at this point, but try to be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry too much about all these options for now; there are many, and you'll
    figure them out when you need them. This is how you can use the CSS selectors
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using querySelector()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This first option will select the first element that matches the query. So,
    enter the following in the console, still using the HTML snippet introduced at
    the start of the section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It only returns the first `div`, because that''s the first one it encounters.
    We could also ask for an element with the class .`something`. If you recall, we
    select classes using dot notation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, you can only use valid CSS selectors: elements, classes,
    and IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use `querySelector()` to enable single element selection:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another simple HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create four HTML elements adding the same class to each. They can be different
    tag names as long as they have the class within the element attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some content within each element so you can distinguish between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within a script element, use `querySelector()` to select the first occurrence
    of the elements with that class and store it in a variable. If there is more than
    one matching result in `querySelector()`, it will return the first one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the element into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using querySelectorAll()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes it is not enough to return only the first instance, but you want
    to select all the elements that match the query. For example when you need to
    get all the input boxes and empty them. This can be done with `querySelectorAll()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is of object type `NodeList`. It contains all the nodes that
    match the CSS selector. With the `item()` method we can get them by index, just
    as we did for the `HTMLCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use `querySelectorAll()` to select all matching elements in an HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML file and add four HTML elements, adding the same class to each
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some content within each element so you can distinguish between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within a script element, use `QuerySelectorAll()` to select all the matching
    occurrences of the elements with that class and store them in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output all the elements into the console, first as an array and then looping
    through them to output them one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element click handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTML elements can do something when they are clicked. This is because a JavaScript
    function can be connected to an HTML element. Here is one snippet in which the
    JavaScript function associated with the element is specified in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the text in the `div` gets clicked, a pop up with the text `Ouch!
    Stop it!` opens. Here, the JavaScript is specified directly after `onclick`, but
    if there is JavaScript on the page, you can also refer to a function that''s in
    that JavaScript like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code is doing the exact same thing. As you can imagine, with bigger functions
    this would be a better practice. The HTML can also refer to scripts that get loaded
    into the page.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a way to add a click handler using JavaScript. We select the HTML
    element we want to add the click handler to, and we specify the onclick property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is at the moment not doing anything if you click it. If we want to
    dynamically add a click handler to the `div` element, we can select it and specify
    the property via the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As it's been added in the console, this functionality will be gone when you
    refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: This and the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `this` keyword always has a relative meaning; it depends on the exact context
    it is in. In the DOM, the special `this` keyword refers to the element of the
    DOM it belongs to. If we specify an `onclick` to send `this` in as an argument,
    it will send in the element the `onclick` is in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what it will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is logging the element it is in, the `button` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the parent of `this` with a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the body is the parent of the button. So if we click
    the button with the new function, it will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We could output any other property of the element the same way; for example,
    `console.log(el.innerText);` would print the inner text value as we saw in the
    *Changing innerText* section.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `this` keyword is referring to the element, and from this element we
    can traverse the DOM like we just learned. This can be very useful, for example,
    when you need to get the value of an input box. If you send `this`, then you can
    read and modify the properties of the element that triggered the function.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a button within a basic HTML document and add the `onclick` attribute.
    The example will demonstrate how you can reference object data with `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function to handle a click within your JavaScript code. You can name
    the function `message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add this to the `onclick` function parameters sending the current element object
    data using `this`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `message` function, use `console.dir()` to output in the console
    the element object data that was sent to the function using `onclick` and `this`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a second button to the page also invoking the same function on the click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the button is clicked, you should see the element that triggered the click
    in the console, like so:![Graphical user interface, text, application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_10_01.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.1: Implementing the onclick attribute'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating element style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After selecting the right element from the DOM, we can change the CSS style
    that applies to it. We can do this using the `style` property. This is how to
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the right element from the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the right property of the style property of this element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to make a button that will toggle the appearing and disappearing
    of a line of text. To hide something using CSS, we can set the `display` property
    of the element to `none`, like this for a `p` (paragraph) element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can toggle it back to visible using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add this style using JavaScript as well. Here is a little HTML and JavaScript
    snippet that will toggle the displaying of a piece of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the `if` statement we are checking for whether it is currently
    hiding, if it is hiding, we show it. Otherwise, we hide it. If you click the button
    and it is currently visible, it will disappear. If you click the button when the
    text is gone, it will appear.
  prefs: []
  type: TYPE_NORMAL
- en: You can do all sorts of fun things using this style element. What do you think
    this does when you click the button?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you see when you first open the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16682_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: A button that will do wonderful things when it is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: 'And when you click the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16682_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Beautiful rainbow made by JavaScript at the click of a button'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over this script to see how works. First of all, there are a few `div`
    tags in the HTML that all have the ID of a certain color. There is a `style` tag
    specified in HTML, which gives a default layout to these `div` tags of 30px by
    30px and a white background.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the button, the `rainbowify()` JavaScript function is executed.
    In this function the following things are happening:'
  prefs: []
  type: TYPE_NORMAL
- en: All the `div` elements get selected and stored in an array, `divs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We loop over this `divs` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every element in the `divs` array, we are setting the `backgroundColor`
    property of style to the ID of the element. Since all the IDs represent a color,
    we see a rainbow appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can imagine, you can really have a lot of fun playing around with this.
    With just a few lines of code, you can make all sorts of things appear on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the classes of an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML elements can have classes, and as we have seen, we can select elements
    by the name of the class. As you may remember, classes are used a lot for giving
    elements a certain layout using CSS.
  prefs: []
  type: TYPE_NORMAL
- en: With JavaScript, we can change the classes of HTML elements, and this might
    trigger a certain layout that is associated with that class in CSS. We are going
    to have a look at adding classes, removing classes, and toggling classes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding classes to elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might sound a bit vague, so let's have a look at an example where we are
    going to add a class to an element, which in this case will add a layout and make
    the element disappear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have some CSS specified in the `style` tag. Elements with
    the `hide` class have a `display`: `none` style, meaning they are hidden. Elements
    with the `square` class are 100 by 100 pixels and are yellow. But when they have
    both the `square` and `blue` class, they are blue.'
  prefs: []
  type: TYPE_NORMAL
- en: When we click on the **Disappear!** button, the `disappear()` function gets
    called. This one is specified in the script tag. The `disappear()` function changes
    the classes by getting the `classList` property of the element with the ID `shape`,
    which is the square we are seeing. We are adding the `hide` class to the `classList`
    and because of this, the elements get the `display:` `none` layout and we can
    no longer see it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing classes from elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also remove a class. If we remove the `hide` class from the `classList`,
    for example, we could see our element again because the `display: none` layout
    no longer applies.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are removing another class. Can you figure out what will
    happen if you press the button by looking at the code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When the button gets pressed, the change function gets triggered. This function
    removes the `blue` class, which removes the blue background color from the layout,
    leaving us with the yellow background color and the square will turn yellow.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why the square was blue in the first place since it had two layouts
    for `background-color` assigned to it with the CSS. This happens with a points
    system. When a styling is more specific, it gets more points. So, specifying two
    classes with no space in between means that it applies to elements with these
    two classes. This is more specific than pointing at one class.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to an ID in CSS, `#nameId`, gets even more points and would be prioritized
    over class-based layouts. This layering allows for less duplicate code, but it
    can become messy, so always make sure to combine the CSS and the HTML well to
    get the desired layout.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you would want to add a class when it doesn't already have that
    particular class, but remove it when it does. This is called toggling. There is
    a special method to toggle classes. Let's change our first example to toggle the
    `hide` class so the class will appear when we press the button the second time,
    disappear the third time, and so on. The `blue` class was removed to make it shorter;
    it's not doing anything in this example other than making the square blue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Pressing the `Magic!` button will add the class to the `classList` when it isn't
    there and remove it when it is there. This means that you can see the result every
    time you press the button. The square keeps appearing and disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen already that we can change the class and style attributes, but
    there is a more general method that can be used to change any attribute. Just
    a quick reminder, attributes are the parts in HTML elements that are followed
    by equals signs. For example, this HTML link to Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The attributes in this example are `id`, `class`, and `href`. Other common attributes
    are `src` and `style`, but there are many others out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `setAttribute()` method, we can add or change attributes on an element.
    This will change the HTML of the page. If you inspect the HTML in the browser
    you will see that the changed attributes are visible. You can do this from the
    console and see the result easily, or write another HTML file with this built
    in as a function. In this HTML snippet, you will see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the page before clicking the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16682_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Page with a yellow square div'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the button, the HTML of the `div` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the attributes are changed. The `id` has changed from `shape`
    to `new`. The `class` has changed from `square` to `circle` and a `style` has
    been added. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16682_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Page with a red circle with a black line around it'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful tool that can be used to interact with the DOM in very
    many ways. Think, for example, of a tool that can be used to create images, or
    even postcards. Beneath the surface, there is a lot of manipulating going on.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note here that JavaScript interacts with the DOM and not
    with the HTML file—therefore, the DOM is the one that gets changed. If you click
    the button again, you'll get an error message in the console because no element
    with `id="shape"` is found in the DOM, and as a result we try to call a method
    on a null value.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating custom attributes: using an array of names, the following code will
    update the element''s HTML, adding HTML code using the data from the array. The
    items within the array will be output to the page as HTML code. The user will
    be able to click the page elements and they will display the page element attribute
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_10_06.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: Creating custom attributes with an array of names'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the HTML will start getting more complex from now on, and we''re only trying
    to test your JavaScript, we will provide HTML templates to use where needed. You
    can use the following HTML template and provide your answer as the completed `script`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of names. You can add as many as you want—all the string values
    will be output onto the page within a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the page elements as JavaScript objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a function and also invoke that function within the JavaScript code. The
    function can be called `build()` as it will be building the page content. Within
    the `build` function, you will be setting up the HTML in a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table named `html`, and within the tags, loop through the contents
    of the array and output the results into the `html` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class called `box` to one of the cells that has the index value of the
    item from the array, adding the same class to the elements for each additional
    row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you create the HTML for the elements within the `tr` element, create an attribute
    called `data-row` in the main `row` element that includes the index value of the
    item from the array. In addition, add another attribute within the element called
    `data-name` that will contain the text output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the attribute of the same `tr` element, also add `onclick` to invoke
    a function named `getData` passing the current element object as `this` into the
    function parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the table of HTML code to the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function named `getData` that will be invoked once the HTML `tr` elements
    are clicked. Once the `tr` element is clicked, use `getAttribute` to get the attribute
    values of the row value and the contents of the text output and store them in
    different variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the values in the attributes stored in the preceding step, output the
    values into the `message` element on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user clicks the element on the page, it will display the details coming
    from the element attributes within the element with the `id` of `message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Event listeners on elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Events are things that happen on a web page, like clicking on something, moving
    the mouse over an element, changing an element, and there are many more. We have
    seen how to add an `onclick` event handler already. In the same way, you can add
    an `onchange` handler, or an `onmouseover` handler. There is one special condition,
    though; one element can only have one event handler as an HTML attribute. So,
    if it has an `onclick` handler, it cannot have an `onmouseover` handler as well.
    At this point, we have only seen how to add event listeners using HTML attributes
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a way to register event handlers using JavaScript as well. We call
    these event listeners. Using event listeners, we can add multiple events to one
    element. This way, JavaScript is constantly checking, or listening, for certain
    events to the elements on the page. Adding event listeners is a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the element you want to add an event to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `addEventListener("event", function)` syntax to add the event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Even though it is two steps, it can be done in one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is getting the element with the ID `square` and adding the `changeColor`
    function as the event for whenever it gets clicked. Note that when using event
    listeners, we remove the `on` prefix from the event type. For example, `click`
    here references the same event type as `onclick`, but we have removed the `on`
    prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider another way to add an event listener (don't worry, we will review
    these methods in detail in *Chapter 11*, *Interactive Content and Event Listeners*)
    by setting the `event` property of a certain object to a function.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fun fact here—event listeners often get added during other events!
  prefs: []
  type: TYPE_NORMAL
- en: 'We could reuse our trusty `onclick` listener in this context, but another common
    one is when the web page is done loading with `onload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This function will then be executed. This is common for `window.onload`, but
    less common for many others, such as `onclick` on a `div` (it is possible though).
    Let's look at an example of the first event listener we looked at on a web page.
    Can you figure out what it will be doing when you click on the square?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The web page starts with a gray square with the text `Click for magic` in it.
    After the web page is done loading, an event gets added for this square. Whenever
    it gets clicked, the `changeColor` function will be executed. This function uses
    random variables to change the color using RGB colors. Whenever you click the
    square, the color gets updated with random values.
  prefs: []
  type: TYPE_NORMAL
- en: You can add events to all sorts of elements. We have only used the `click` event
    so far, but there are many more. For example, `focus`, `blur`, `focusin`, `focusout`,
    `mouseout`, `mouseover`, `keydown`, `keypress`, and `keyup`. These will be covered
    in the next chapter, so keep going!
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try an alternative way to implement similar logic to *Practice exercise 10.7*.
    Use the following HTML code as a template for this exercise, and add the contents
    of the `script` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select all the page buttons into a JavaScript object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through each button, and create a function within the button scope called
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `output()` function, add a `console.log()` method that outputs the
    current object's `textContent`. You can reference the current parent object using
    the `this` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you loop through the buttons attach an event listener that when clicked invokes
    the `output()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating new elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen so many cool ways to manipulate the DOM already.
    There is still an important one missing, the creation of new elements and adding
    them to the DOM. This consists of two steps, first creating new elements and second
    adding them to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not as hard as it may seem. The following JavaScript does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates an element of type `p` (paragraph). This is a `createElement()`
    function that is on the `document` object. Upon creation, you need to specify
    what type of HTML element you would want to create, which in this case is a `p`,
    so something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And as `innerText`, it is adding a random number. Next, it is adding the element
    as a new last child of the body. You could also add it to another element; just
    select the element you want to add it to and use the `appendChild()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see it incorporated in a HTML page. This page has a button, and
    whenever it gets pressed, the `p` gets added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of this page after having pressed the button five times.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16682_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Random numbers after pressing the button five times'
  prefs: []
  type: TYPE_NORMAL
- en: Once we refresh the page, it's empty again. The file with the source code doesn't
    change and we're not storing it anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 10.10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shopping list: Using the following HTML template, update the code to add new
    items to the list of items on the page. Once the button is clicked, it will add
    a new item to the list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the page elements as JavaScript objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `onclick` event listener to the add button. Once the button is clicked,
    it should add the contents of the input field to the end of the list. You can
    call the function `addOne()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `addOne()`, create `li` elements to append to the main list on the page.
    Add the input value to the list item text content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `addOne()` function, get the current value of the `addItem` input
    field. Use that value to create a `textNode` with that value, adding it to the
    list item. Append the `textNode` to the list item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collapsible accordion component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build a collapsing and expanding accordion component that will open page elements,
    hiding and showing content when the title tab is clicked. Using the following
    HTML as a template, add the completed `script` element and create the desired
    functionality with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `querySelectorAll()`, select all the elements with a class of `title`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `querySelectorAll()`, select all the elements with a class of `myText`.
    This should be the same number of elements as the `title` elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through all the `title` elements and add event listeners that, once
    clicked, will select the next element siblings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the element on the `click` action and toggle the `classlist` of the element
    with the `class` of `active`. This will allow the user to click the element and
    hide and show the below content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a function that will be invoked each time the elements are clicked that
    will remove the `class` of `active` from all the elements. This will hide all
    the elements with `myText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interactive voting system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The below code will create a dynamic list of people that can be clicked, and
    it will update the corresponding value with the number of times that name was
    clicked. It also includes an input field that will allow you to add more users
    to the list, each of which will create another item in the list that can be interacted
    with the same as the default list items.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_10_08.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Creating an interactive voting system'
  prefs: []
  type: TYPE_NORMAL
- en: Use the following HTML code as a template to add JavaScript to, and provide
    your answer as the completed `script` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of people's names called `myArray`. This will be the default
    original list of names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the page elements as JavaScript objects so they can easily be selected
    within the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add event listener to the **Add Friend** button. Once clicked, this will get
    the value from the input field and pass the values to a function that will add
    the friend list to the page. Additionally, add the new friend's name into the
    people's names array you created. Get the current value in the input field and
    push that value into the array so the array matches the values on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a function to build the content on the page, using the `forEach()` loop
    get all the items within the array and add them to the page. Include `0` as a
    default for the vote count, as all individuals should start on zero votes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a main function that will create the page elements, starting with the
    parent table row, `tr`. Then create three table cell, `td`, elements. Add content
    to the table cells, including the vote count in the last column, the person name
    in the middle, and the index plus 1 in the first column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the table cells to the table row and append the table row to the output
    area on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener that will increase the vote counter for that row when
    the user clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the text content from the last column in the row. It should be the value
    of the current counter. Increment the counter by one and make sure the datatype
    is a number so you can add to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the last column with the new click counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hangman game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a Hangman game using arrays and page elements. You can use the following
    HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an array that contains some words or phrases that you want to use in
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In JavaScript, create a main game object containing a property to contain the
    current word solution, and another property to contain the array of letters of
    the solution. It should also create an array to contain the page elements and
    correspond with the values of the index values of each letter from the solution,
    and finally add a property to count the number of letters left to solve and end
    the game when needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all the page elements into variables so they are easier to access in
    the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the **Start Game** button, making it clickable, and
    when it gets clicked it should launch a function called `startGame()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `startGame()`, check if the `words` array has any words left. If it does,
    then hide the button by setting the `.display` object to `none`. Clear the game
    contents and set the total to `0`. Within the current word in the game object,
    assign a value, which should be the response of `shift()` from the array containing
    the in-game words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the game solution, convert the string into an array of all the characters
    in the word solution using `split()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called `builder()` that can be used to build the game board.
    Invoke the function within the `startGame()` function once all the game values
    are cleared and set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a separate function that you can use to generate page elements. In the
    parameters, get the type of element, the parent that the new element will be appended
    to, the output content for the new element, and a class to add to the new element.
    Using a temporary variable, create the element, add the class, append to the parent,
    set the `textContent`, and return the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `builder()` function, which will also get invoked once `startGame()`
    is run, clear the `innerHTML` from the letters and puzzle page elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the game solution array, getting each letter of the solution.
    Use the `builder()` function to generate page elements, add an output value of
    `-`, set a class, and append it to the main puzzle page element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the value is blank, and if it is, clear `textContent` and update the
    border to white. If it's not blank, increment the total so that it reflects the
    total number of letters that must be guessed. Push the new element into the game
    puzzle array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new function to update the score so that you can output the current
    number of letters left. Add it to the `builder()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a loop to represent the 26 letters of the alphabet. You can generate
    the letter by using an array containing all the letters. The string method `fromCharCode()`
    will return the character from the numeric representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create elements for each letter, adding a `class` of `box` and appending it
    to the `letters` page element. As each element gets created, add an event listener
    that runs a function called `checker()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the letter gets clicked, we need to invoke the `checker()` function, which
    will remove the main class, add another class, remove the event listener, and
    update the background color. Also invoke a function called `checkLetter()`, passing
    the value of the clicked letter into the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `checkLetter()` function will loop through all the solution letters. Add
    a condition to check if the solution letter is equal to the letter selected by
    the player. Make sure to convert the inputted letter to uppercase so that you
    can match the letters accurately. Update the matching letters in the puzzle using
    the game puzzle array and the index from the letter in the solution. The index
    values will be the same on each, which provides an easy way to match the visual
    representation with what is in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract one from the game global object that tracks the total letters left
    to be solved, invoke the `updatescore()` function to check if the game is over,
    and update the score. Set the `textContent` of the puzzle to the letter removing
    the original dash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `updatescore()` function, set the score to the number of letters left.
    If the total left is less than or equal to zero, the game is over. Show the button
    so that the player has an option for the next phrase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What output will the following code produce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What output will be seen within the browser page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What will be seen in the input field from the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the following code, what is output into the console when the element with
    the word `three` gets clicked? What is the output when the element with the word
    `one` gets clicked?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What line of code needs to be added to remove the event listener when the button
    is clicked in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we really took our web skills to the next level. Manipulating
    the DOM allows all kinds of interactions with the web page, meaning that the web
    page is no longer a static event.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by explaining the dynamic web and how to traverse the DOM. After
    having walked over the elements manually, we learned that there's an easier way
    to select elements in the DOM with the `getElementBy…()` and the `querySelector()`
    methods. After having selected them, we had the power to modify them, add new
    elements to them, and do all sorts of things using the elements we selected. We
    started with some more basic HTML handlers, and we could assign a function to,
    for example, the `onclick` attribute of the HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: We also accessed the clicked element using the `this` argument that was sent
    in as a parameter, and we could modify it in different ways, for example, by changing
    the `style` property. We also saw how to add classes to an element, create new
    elements, and add them to the DOM. And finally, we worked with event listeners
    on elements that really took our dynamic web pages to the next level. With event
    listeners, we can specify more than one event handler for a certain element. All
    these new skills allow us to create amazing things in the web browser. You can
    actually create complete games now!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take your event handler skills to the next level and will
    enhance your ability to create interactive web pages even further (and make it
    a bit easier as well!).
  prefs: []
  type: TYPE_NORMAL
