<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Animation and Physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Animation and Physics</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating animations with Tween.js</li><li class="listitem" style="list-style-type: disc">Animation using morph targets</li><li class="listitem" style="list-style-type: disc">Animation with skeletons</li><li class="listitem" style="list-style-type: disc">Using morph animations created in Blender</li><li class="listitem" style="list-style-type: disc">Using skeleton animations created in Blender</li><li class="listitem" style="list-style-type: disc">Adding a simple collision detection</li><li class="listitem" style="list-style-type: disc">Saving a movie of an animation in Chrome</li><li class="listitem" style="list-style-type: disc">Dragging and dropping objects around a scene</li><li class="listitem" style="list-style-type: disc">Adding a physics engine</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec87"/>Introduction</h1></div></div></div><p>In the chapters so far, we've mostly dealt with static scenes or scenes with limited animation. In this chapter, we show you a number of recipes that you can use to make your scenes more dynamic. We show you recipes that talk about how to add advanced animations, how to drag and drop objects around your scene, and even how to add physics to your scene, such as gravity and collision detection.</p></div></div>
<div class="section" title="Creating animations with Tween.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec88"/>Creating animations with Tween.js</h1></div></div></div><p>In<a id="id524" class="indexterm"/> <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, we've already showed <a id="id525" class="indexterm"/>you how to set up an animation loop, and in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>, we showed you how to create simple animations by changing properties of <code class="literal">THREE.Mesh</code>. When you have many or complex animations, the code can quickly become complex to maintain or understand. In this recipe, we'll show you how you can use an external JavaScript library that makes the creation of animations easier and more maintainable. We'll use the <span class="strong"><strong>Tween.js</strong></span> library for this.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec302"/>Getting ready</h2></div></div></div><p>For<a id="id526" class="indexterm"/> this recipe, we use a library from <a class="ulink" href="https://github.com/sole/tween.js/">https://github.com/sole/tween.js/</a>. As this is an external library, we first need to make<a id="id527" class="indexterm"/> sure it is included in our HTML page. For this, first<a id="id528" class="indexterm"/> add the following within the head element of your page:</p><div class="informalexample"><pre class="programlisting">  &lt;script src="../libs/tween.js"&gt;&lt;/script&gt;</pre></div><p>For this recipe, we'll create a simple animation using this library. If you open the <code class="literal">07.01-animation-with-tweenjs.html</code> example in your browser, you can view the final result, which is similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_01.jpg" alt="Getting ready"/></div><p>If you open this example in your browser, you'll see a small red cube that moves to a different position and rotates while it is moving. This animation is configured using the <code class="literal">Tween.js</code> library.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec303"/>How to do it…</h2></div></div></div><p>Once you've added the required library to your HTML page, creating the animation only takes a couple of simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To<a id="id529" class="indexterm"/> use this library, we need to first <a id="id530" class="indexterm"/>create an instance of a <code class="literal">TWEEN.Tween</code> object:<div class="informalexample"><pre class="programlisting">  var tween = new TWEEN.Tween({x:0 , y:1.25, z:0, rot: 0});</pre></div><p>This creates a <code class="literal">TWEEN.Tween</code> instance. We can use this instance to move the provided properties from the start value (the value we added in this step) to an end value.</p></li><li class="listitem">The next step is to define the target values for the properties. We do this by using the <code class="literal">to</code> function:<div class="informalexample"><pre class="programlisting">  tween.to({x:5, y:15, z:-10, rot: 2*Math.PI}, 5000);</pre></div><p>With this function, we tell the <code class="literal">tween</code> object that we want to slowly change the provided values in the constructor to these values. So, we change the <code class="literal">x</code> property from <code class="literal">0</code> to <code class="literal">5</code>. The second parameter, which is <code class="literal">5000</code>, defines how many milliseconds this change should take.</p></li><li class="listitem">We can also choose how the value changes over time. You can for instance use a linear easing function, which changes the values at a constant rate, a quadratic one, which starts with small changes and quickly increases, or even use an easing function that bounces (overshoots) at the end. There are many more easing functions that are predefined in <code class="literal">TWEEN</code> (see the <span class="emphasis"><em>There's more…</em></span> section for more information). You do this by calling the easing function:<div class="informalexample"><pre class="programlisting">  tween.easing(TWEEN.Easing.Elastic.InOut);</pre></div></li><li class="listitem">So far, we have changed the values of these properties from one value to another, but we don't really do anything when a value changes. In this recipe, we want to change the position and the rotation of the cube. You do this by calling the <code class="literal">onUpdate</code> function and passing in the function that should be called on each change:<div class="informalexample"><pre class="programlisting">  tween.onUpdate(function() {
    cube.position.set(this.x, this.y, this.z);
    cube.rotation.set(this.rot, this.rot, this.rot);
  });</pre></div><p>As you can see in this code snippet, we use the provided properties to set the rotation and position properties of cube.</p></li><li class="listitem">There are a number of other settings you can use on the <code class="literal">tween</code> object to control how the animation behaves. For this recipe, we tell the <code class="literal">tween</code> object to repeat its animation indefinitely and use a yo-yo effect that reverses the animation each time it is repeated:<div class="informalexample"><pre class="programlisting">  tween.repeat(Infinity);
  tween.yoyo(true);</pre></div></li><li class="listitem">Finally, we can start the <code class="literal">tween</code> object by calling the start function:<div class="informalexample"><pre class="programlisting">  tween.start();</pre></div></li><li class="listitem">At<a id="id531" class="indexterm"/> this point, you won't see anything<a id="id532" class="indexterm"/> happening. There is one last step you need to add to the <code class="literal">render</code> loop to inform the <code class="literal">tween</code> object how much time has passed so that it can calculate the correct values for the properties you provided in step 1:<div class="informalexample"><pre class="programlisting">  TWEEN.update();</pre></div><p>This will update all the <code class="literal">TWEEN.Tween</code> objects you've defined and call the <code class="literal">onUpdate</code> functions with the <code class="literal">updated</code> values.</p></li></ol></div><p>You define the start value, the end value, and how the start value should transition to the end value.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec304"/>How it works…</h2></div></div></div><p>Whenever you call <code class="literal">TWEEN.update()</code>, the <code class="literal">TWEEN</code> library will determine how much time has passed from the previous call to <code class="literal">TWEEN.update</code> for each <code class="literal">TWEEN.Tween</code> object (or in the case of the first time, the time from calling <code class="literal">start()</code> on the <code class="literal">TWEEN.Tween</code> object). Based on this difference, the start time of <code class="literal">tween</code>, and the configured <code class="literal">easing</code> property, this library calculates new values for the passed-in properties. Finally, it will call the function passed into <code class="literal">onUpdate()</code> so that you can take action on the changed values.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec305"/>There's more…</h2></div></div></div><p>In this recipe, we didn't show all the configuration you can pass into the <code class="literal">TWEEN.Tween</code> object. For a complete overview of all the different easing options and other properties of the <code class="literal">TWEEN.Tween</code> object, refer <a id="id533" class="indexterm"/>to the GitHub project site at <a class="ulink" href="https://github.com/sole/tween.js/">https://github.com/sole/tween.js/</a>.</p><p>Before we move on to the next recipe, there is one additional interesting aspect of the Tween.js library. In our recipe, we configured the <code class="literal">TWEEN.Tween</code> object step by step. You can also configure the object in one call like this:</p><div class="informalexample"><pre class="programlisting">  var tween = new TWEEN.Tween({x:0 , y:1.25, z:0, rot: 0}).to({x:5, y:15, z:-10, rot: 2*Math.PI}, 5000).easing(TWEEN.Easing.Elastic.InOut).onUpdate(function() {
    cube.position.set(this.x, this.y, this.z);
    cube.rotation.set(this.rot, this.rot, this.rot);
  })
  .repeat(Infinity)
  .yoyo(true)
  .start();</pre></div><p>This works because Tween.js offers a fluent API. So for each function call, this library returns the original <code class="literal">TWEEN.Tween</code> object. This means that you can easily chain calls together like we did in the previous code fragment.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec306"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You <a id="id534" class="indexterm"/>can use the Tween.js library in pretty <a id="id535" class="indexterm"/>much every case where we used an animation in this book. For instance, in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>, we showed you the Rotating an object around its own axis recipe. The rotation could be easily managed using a <code class="literal">TWEEN.Tween</code> object. In <a class="link" href="ch03.html" title="Chapter 3. Working with the Camera">Chapter 3</a>, <span class="emphasis"><em>Working with the Camera</em></span>, we showed you how to zoom in on an object in the <span class="emphasis"><em>Zooming the camera to an object</em></span> recipe. With the Tween.js library, we can easily animate this zoom functionality.</li></ul></div></div></div>
<div class="section" title="Animating using morph targets"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec89"/>Animating using morph targets</h1></div></div></div><p>When <a id="id536" class="indexterm"/>modeling 3D objects and characters, there<a id="id537" class="indexterm"/> are generally two different ways of creating animations. You can animate using morph targets, or you can use skeleton-and-bones-based animations. Three.js facilitates both of these approaches. In this recipe, we'll look at the morph-based animation. With morph-based animations, like the name implies, you morph one geometry shape into another. This works great for facial expressions and other very detailed animations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec307"/>Getting ready</h2></div></div></div><p>For this recipe, we don't require any additional libraries as morph-based animations are supported by the standard Three.js distribution. To make this recipe more understandable, we use an existing 3D model to demonstrate how morphing works. You can see the model and the available morphs when you open the <code class="literal">07.02-animation-with-morphing.html</code> example in your browser. You will see something similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_02.jpg" alt="Getting ready"/></div><p>In<a id="id538" class="indexterm"/> this example, you can see a simple model of a car. Using<a id="id539" class="indexterm"/> the sliders in the top-right section, you can slowly morph this car into a different model, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_03.jpg" alt="Getting ready"/></div><p>If <a id="id540" class="indexterm"/>you check the <span class="strong"><strong>animate</strong></span> box, an animation that <a id="id541" class="indexterm"/>automatically morphs this car will start.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec308"/>How to do it…</h2></div></div></div><p>To use morphing animations, we need to take the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is load the model that contains morph targets. For this recipe, we've got a <code class="literal">JSON</code>-based model, which we load like this:<div class="informalexample"><pre class="programlisting">  var jsonLoader = new THREE.JSONLoader();
  jsonLoader.load("../assets/models/morph/car.js",
  function(model, materials) {
    ...
  });</pre></div><p>Here, we use <code class="literal">THREE.JSONLoader</code> to load a model, and once it is loaded, we call the provided function.</p></li><li class="listitem">Before we create <code class="literal">THREE.Mesh</code>, there is one additional step we need to take. We need to set the <code class="literal">morphTargets</code> property on the materials that are set to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">  materials.forEach(function(mat) {
    mat.morphTargets = true;
  });</pre></div></li><li class="listitem">Next, we need to create <code class="literal">THREE.Mesh</code> and add it to the scene:<div class="informalexample"><pre class="programlisting">  car = new THREE.Mesh(model,new THREE.MeshFaceMaterial( materials ));
  scene.add(car);</pre></div><p>As you can see, we follow the standard way of creating <code class="literal">THREE.Mesh</code> and add it to the scene just like any other object.</p></li><li class="listitem">Now<a id="id542" class="indexterm"/> that we've got an object in the <a id="id543" class="indexterm"/>scene that can be morphed, we can use the <code class="literal">morphTargetInfluences</code> property to set how much the object is morphed into a specific direction. In the example for this recipe, we used the UI to control this setting as follows:<div class="informalexample"><pre class="programlisting">  gui.add(control, 'mt_1', 0,1).step(0.01).listen().onChange(function(a){
    car.morphTargetInfluences[1] = a;
  });
  gui.add(control, 'mt_2', 0,1).step(0.01).listen().onChange(function(a){
    car.morphTargetInfluences[2] = a;
  });;
  gui.add(control, 'mt_3', 0,1).step(0.01).listen().onChange(function(a){
    car.morphTargetInfluences[3] = a;
  });</pre></div><p>The model we used in this recipe has four morph targets (with names <code class="literal">mt_0</code>, <code class="literal">mt_1</code>, <code class="literal">mt_2</code>, and <code class="literal">mt_3</code>), its base state and three other car models. By increasing the <code class="literal">morphTargetInfluence</code> object of one of those other models, we can morph the model into that direction.</p></li></ol></div><p>As you can see in this recipe, by simply changing the value of a specific <code class="literal">morphTargetInfluences</code> value, you can change the way your model looks.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec309"/>How it works…</h2></div></div></div><p>In models that support multiple morph targets, an additional set of vertices is stored to represent that position for each of the targets. So, if you've got a face model that has a morph target for a smile, one for a frown, and one for a smirk, you effectively store four times as many vertex positions. With the <code class="literal">morphTargetInfluences</code> property, you can tell Three.js how far the base state (the <code class="literal">geometry.vertices</code> property) should be morphed toward that specific morph target. Three.js will then calculate the average position of each individual vertex and render the updated model. A very interesting thing is that you can combine morph targets. So if you've got separate morph targets for eye movement and mouth movement, you can easily create very animated and lifelike animations.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec310"/>There's more…</h2></div></div></div><p>In <a id="id544" class="indexterm"/>this recipe, we loaded an external model that <a id="id545" class="indexterm"/>contained the morph targets. If you've already got a simple geometry that you want to use for morph-based animations, you can also easily do that. For instance, if you've got a geometry, you can add <code class="literal">morphTargets</code> using the following code:</p><div class="informalexample"><pre class="programlisting">  cubeGeometry.morphTargets[0] = {name: 't1', vertices:cubeTarget2.vertices};
  cubeGeometry.morphTargets[1] = {name: 't2', vertices:cubeTarget1.vertices};</pre></div><p>The important aspect here is to make sure you provide the same amount of vertices to the <code class="literal">vertices</code> property as there are in the <code class="literal">initial</code> geometry. You can now control the morph between the various targets using the <code class="literal">morphTargetInfluences</code> properties on <code class="literal">THREE.Mesh</code>:</p><div class="informalexample"><pre class="programlisting">  cube.morphTargetInfluences[0] = 0.4;
  cube.morphTargetInfluences[1] = 0.6;</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec311"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An alternative way to animate models can be done using skeleton and bones. We explain how to do this in the <span class="emphasis"><em>Animation with skeletons</em></span> recipe. We also provide two recipes in this chapter where we define morph-and-skeleton-based animations in an external tool (Blender, in our case) and play the animation in Three.js. See the <span class="emphasis"><em>Using morph animations created in Blender</em></span> and <span class="emphasis"><em>Using skeleton animations created in Blender</em></span> recipes for more information about these approaches.</li></ul></div></div></div>
<div class="section" title="Animating with skeletons"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec90"/>Animating with skeletons</h1></div></div></div><p>A<a id="id546" class="indexterm"/> common way to animate complex models is using bones <a id="id547" class="indexterm"/>and skinning. In this approach, we define a geometry, add a skeleton, and tie the geometry to that skeleton. Whenever we move or rotate one of the bones of the skeleton, the geometry is deformed accordingly. In this recipe, we will show you how you can use the Three.js functionality to move and rotate bones directly from JavaScript.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec312"/>Getting ready</h2></div></div></div><p>For this recipe, we use an external model that already contains a skeleton we can move around. To load this model, we use <code class="literal">THREE.JSONLoader</code>, which is available in the standard distribution of Three.js. So, we don't need to import any additional JavaScript files to get this recipe to work. Of course, we've provided an example of this recipe in action, which <a id="id548" class="indexterm"/>you can view by opening the <code class="literal">07.03-animation-with-skeleton.html</code> example in your browser. You will see something similar<a id="id549" class="indexterm"/> to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_04.jpg" alt="Getting ready"/></div><p>This example shows you a model of a giraffe and provides an interface that you can use to move the neck bone. You can change the rotation of the neck bone and even its position. When you do this, you'll see that part of the mesh responds to the movement of this bone. In this recipe, we'll show you how to accomplish this for yourself.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec313"/>How to do it…</h2></div></div></div><p>Working directly with bones isn't that difficult and only takes a couple of small steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is load a model that contains bones. For this recipe, we once again use <code class="literal">THREE.JSONLoader</code>:<div class="informalexample"><pre class="programlisting">  var jsonLoader = new THREE.JSONLoader();
  jsonLoader.load("../assets/models/bones/giraffe.js",function(model, materials) {
    ...
  });</pre></div></li><li class="listitem">Once <a id="id550" class="indexterm"/>the model  from step 1 has been loaded, we can set up<a id="id551" class="indexterm"/> the materials and create the mesh. Let's first look at the materials:<div class="informalexample"><pre class="programlisting">  materials.forEach(function(mat) {
    mat.skinning = true;
  });</pre></div><p>Here, we set the <code class="literal">skinning</code> property of the material to <code class="literal">true</code>. This tells Three.js that this object contains bones and the geometry should deform when the bones move.</p></li><li class="listitem">Next, we create the mesh and add it to the scene:<div class="informalexample"><pre class="programlisting">  var giraffe = new THREE.SkinnedMesh(model, materials[0]);
  scene.add(giraffe);</pre></div><p>As you can see, we've used a different kind of mesh for this object. Instead of the <code class="literal">THREE.Mesh</code> object, we've used a <code class="literal">THREE.SkinnedMesh</code> object.</p></li><li class="listitem">To access the bones, we access the children elements of <code class="literal">THREE.SkinnedMesh</code>. Getting the correct bone to animate might take some experimenting if the bones aren't clearly named. The easiest way to determine which bone to use is to look through the output of the JavaScript console and browse the children of the mesh.<div class="mediaobject"><img src="graphics/1182OS_07_05.jpg" alt="How to do it…"/></div></li><li class="listitem">In<a id="id552" class="indexterm"/> this case, we want to rotate the tail bone and <a id="id553" class="indexterm"/>rotate and position the neck. For this, we add the following to the <code class="literal">render</code> loop:<div class="informalexample"><pre class="programlisting">  // the neck bone
  giraffe.children[0].children[1].children[0].children[0].rotation.x = control.neck_rot_x;
  giraffe.children[0].children[1].children[0].children[0].rotation.y = control.neck_rot_y;
  giraffe.children[0].children[1].children[0].children[0].rotation.z = control.neck_rot_z;
  giraffe.children[0].children[1].children[0].children[0].position.x = control.neck_pos_x;
  giraffe.children[0].children[1].children[0].children[0].position.y = control.neck_pos_y;
  giraffe.children[0].children[1].children[0].children[0].position.z = control.neck_pos_z;
  // the tail bone
  giraffe.children[0].children[0].children[0].rotation.z -= 0.1</pre></div><p>That's it! Whenever we now change the position of the rotation of the bones we used in the previous code snippet, the geometry will deform accordingly.</p></li></ol></div><p>Working with bones isn't that difficult, but selecting the correct bone to change and move around can take some experimentation.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec314"/>How it works…</h2></div></div></div><p>When you enable the <code class="literal">skinning</code> property on the material, Three.js passes all the information about the relevant bones and positions into its vertex shader. The vertex shader will use this information<a id="id554" class="indexterm"/> to position the vertices to their new position <a id="id555" class="indexterm"/>based on the position and rotation of the relevant bones. More information and a good introduction on how to execute skeletal animations<a id="id556" class="indexterm"/> from a vertex shader can be found on the OpenGL website at <a class="ulink" href="https://www.opengl.org/wiki/Skeletal_Animation">https://www.opengl.org/wiki/Skeletal_Animation</a>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec315"/>There's more…</h2></div></div></div><p>If you want to get a quick overview of how the bones are organized in a model, you can use a specific helper class that is provided by Three.js. The following code snippet shows you how to create <code class="literal">THREE.SkeletonHelper</code> for the model we used in this recipe:</p><div class="informalexample"><pre class="programlisting">  var helper = new THREE.SkeletonHelper(giraffe);
  scene.add(helper);</pre></div><p>This will visualize the bones of a model, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_06.jpg" alt="There's more…"/></div><p>If you<a id="id557" class="indexterm"/> move bones around, which we do in our recipe, you also<a id="id558" class="indexterm"/> need to add the following line to your <code class="literal">render</code> loop:</p><div class="informalexample"><pre class="programlisting">  helper.update();</pre></div><p>This way, <code class="literal">THREE.SkeletonHelper</code> will always reflect the latest state of the model.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec316"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A simpler way to animate models is using morph targets. We explain how to do this in the <span class="emphasis"><em>Animation using morph targets</em></span> recipe. We also provide two recipes in this chapter where we define morph-and-skeleton-based animations in an external tool (Blender, in our case) and play the animation in Three.js. Refer to the <span class="emphasis"><em>Using morph animations created in Blender</em></span> and <span class="emphasis"><em>Using skeleton animations created in Blender</em></span> recipes for more information on these approaches.</li></ul></div></div></div>
<div class="section" title="Using morph animations created in Blender"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec91"/>Using morph animations created in Blender</h1></div></div></div><p>Creating morph animations by hand is difficult to do in Three.js. Simple transformations can <a id="id559" class="indexterm"/>probably be handled, but creating advanced animations programmatically is very difficult. Luckily, there are a large number of external 3D programs that you can use to create the models and animations. In this recipe, we'll use Blender, which we already used in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>, to create a morph-based animation and play it back using Three.js.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec317"/>Getting ready</h2></div></div></div><p>To use this recipe, you have to have Blender installed and enable the Three.js exporter plugin. We've already explained how to do this in the <span class="emphasis"><em>Creating and exporting a model from Blender</em></span> recipe, in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>. So if you haven't already done so, you should first install Blender and then the Three.js export plugin. Once you've installed Blender, you should create an animation that uses shape keys to define various formats. Doing this is out of the scope of this book, but to make sure, you can test the steps explained in this recipe—we've included a Blender file, which has a minimal shape-keys-based animation. So before we get started with the recipe, we'll load the example Blender model. </p><p>For this, take the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>Blender</strong></span> and navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open</strong></span>.</li><li class="listitem">In the window that opens, navigate to the sources provided with the book and open the <code class="literal">simplemorph.blend</code> file, which can be found in the <code class="literal">assets/models/blender</code> directory.</li><li class="listitem">Once this file is opened, you'll see a cube in the center of an empty scene like this:<div class="mediaobject"><img src="graphics/1182OS_07_07.jpg" alt="Getting ready"/></div><p>This is the starting point from where we start the recipe.</p></li><li class="listitem">If <a id="id560" class="indexterm"/>you want to preview the (very simple) animation we've created here, just click on the <span class="strong"><strong>play</strong></span> button or use the <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>A</em></span> key combination.</li><li class="listitem">We will load this file in Three.js and play the animation we created in Blender. To see the final result, open the <code class="literal">07.04-create-morph-in-blender.html</code> example in your browser. You will see something similar to what is shown in the following screenshot:<div class="mediaobject"><img src="graphics/1182OS_07_08.jpg" alt="Getting ready"/></div><p>You'll see an animating cube that uses morph targets (defined as shape keys in Blender) to morph a cube into different shapes.</p></li></ol></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec318"/>How to do it…</h2></div></div></div><p>If <a id="id561" class="indexterm"/>you've followed the steps explained in the <span class="emphasis"><em>Getting ready</em></span> section of this recipe, you'll be looking at a simple Blender workspace with a single cube and an animation that slowly morphs the cube using a set of shape keys. To export this animation from Blender and use it in Three.js, we need to take a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is export the model and the animation to which we can load it in Three.js. To do this, navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> | <span class="strong"><strong>Three.js</strong></span>.</li><li class="listitem">In the window that opens, we can select a destination and a filename. For this recipe, name the file <code class="literal">simplemorph.js</code> and set the destination to the <code class="literal">assets/models/morph</code> folder.</li><li class="listitem">Before we hit the <span class="strong"><strong>Export</strong></span> button, we need to configure some Three.js-specific properties. You can do this in the panel on the left-hand side in the <span class="strong"><strong>Export Three.js</strong></span> section. In that section, make sure that the <span class="strong"><strong>Morph animation</strong></span> checkbox is selected. Once you've checked the box, click on the <span class="strong"><strong>Export</strong></span> button.</li><li class="listitem">Now we're done with our work in Blender and can load the exported model in Three.js. For this, we use <code class="literal">THREE.JSONLoader</code> like this:<div class="informalexample"><pre class="programlisting">  var loader = new THREE.JSONLoader();
  loader.load("../assets/models/morph/simplemorph.js",function(model){
    ...
  });</pre></div><p>In this code snippet, we load the model using <code class="literal">THREE.JSONLoader</code>.</p></li><li class="listitem">Once <a id="id562" class="indexterm"/>the model is loaded, we need to create a material where we need to set the <code class="literal">morphTargets</code> property to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">  var mat = new THREE.MeshLambertMaterial({color: 0xff3333, morphTargets:true})</pre></div></li><li class="listitem">With this material, we can create the mesh to be added to the scene. This time, as we want to use the animation provided from Blender, we create <code class="literal">THREE.MorphAnimMesh</code>, which we add to the scene:<div class="informalexample"><pre class="programlisting">  mesh = new THREE.MorphAnimMesh(model, mat);
  mesh.castShadow = true;
  scene.add(mesh);</pre></div></li><li class="listitem">We need to take a final step before we can play the animation:<div class="informalexample"><pre class="programlisting">  mesh.parseAnimations();
  mesh.playAnimation('animation', 20);
  mesh.duration = 10;
  render();</pre></div><p>With the <code class="literal">parseAnimation()</code> function, Three.js will parse the names of the provided morph target elements from the model and use it to create an animation. When you export using the Three.js plugin from Blender, the name of the animation is <code class="literal">animation</code>. To play the animation, we call <code class="literal">playAnimation</code> with the name of the animation and the frame rate, and finally, we set the duration (in seconds) of the animation. Note that you don't always have to set the duration of an animation. In some cases, the model itself provides the duration.</p></li><li class="listitem">The final change we need to make is in the <code class="literal">render</code> function itself:<div class="informalexample"><pre class="programlisting">  var t = new THREE.Clock();
  function render() {
    renderer.render(scene, camera);
    mesh.updateAnimation(t.getDelta());
    requestAnimationFrame(render);
  }</pre></div><p>Here, we create a global <code class="literal">THREE.Clock()</code> instance, which we use to determine how much time is passed between sequential calls to the <code class="literal">render</code> function. This is passed into the <code class="literal">updateAnimation</code> function of <code class="literal">THREE.MorphAnimMesh</code> so that it can calculate which frame to show.</p></li></ol></div><p>As<a id="id563" class="indexterm"/> you've seen from the recipe, getting an animation to play in Three.js from Blender isn't that difficult. One thing to take into account here, though, is that this can result in huge files when you've got models with a high vertex count. This happens because the Blender export plugin creates a new morph target for each frame of the animation.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec319"/>There's more…</h2></div></div></div><p>In this recipe, we've used the Three.js export function of Blender to save the model in a format <code class="literal">THREE.JSONLoader</code> can load. There are a large number of other 3D formats available, which can be used to store 3D scenes and animations that are supported by Three.js. An<a id="id564" class="indexterm"/> overview of the file formats that are available in Three.js can be found on the Three.js GitHub site at <a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec320"/>See also</h2></div></div></div><p>In this chapter, we've got some other recipes that deal with animations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Animation using morph targets</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Animation with skeletons</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using skeleton animations created in Blender</em></span></li></ul></div></div></div>
<div class="section" title="Using skeleton animations created in Blender"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec92"/>Using skeleton animations created in Blender</h1></div></div></div><p>In<a id="id565" class="indexterm"/> the <span class="emphasis"><em>Animation with skeletons</em></span> recipe, we animated a model by directly changing the position and rotation of its bones. This works great in an interactive scenery but isn't a practical way to create animations. With Blender and other 3D tools, you've got a large set of tools to create animations based on a specific skeleton and a set of bones. In this recipe, we'll show you how you can play back a skeleton-based animation that was created in Blender.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec321"/>Getting ready</h2></div></div></div><p>To use this recipe, you need to have Blender installed and enable the Three.js exporter plugin. If you haven't done so, follow the steps from the <span class="emphasis"><em>Creating and exporting a model from Blender</em></span> recipe, in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>. Once Blender and the Three.js <a id="id566" class="indexterm"/>export plugin have been installed, we need to create a skeleton-based animation. Creating this in Blender is out of the scope of this book, so we've provided an existing model to demonstrate this recipe. To get started, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>Blender</strong></span> and navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open</strong></span>.</li><li class="listitem">In the window that opens, navigate to the sources provided with the book and open the <code class="literal">crow-skeleton.blend</code> file, which can be found in the <code class="literal">assets/models/blender</code> directory.</li><li class="listitem">Once this file is open, you'll see a crow in the center of an empty scene like this:<div class="mediaobject"><img src="graphics/1182OS_07_09.jpg" alt="Getting ready"/></div><p>This is the starting point of this recipe.</p></li><li class="listitem">If you want to preview the crow animation, click on the <span class="strong"><strong>play</strong></span> button or use the <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>A</em></span> key combination.</li></ol></div><p>We have also provided an example that you can open in your browser to see the same animation in a Three.js scene. When you open the <code class="literal">07.05-create-skeleton-animation-in-blender.html</code> example in your browser, you should see something like this:</p><div class="mediaobject"><img src="graphics/1182OS_07_10.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec322"/>How to do it…</h2></div></div></div><p>Before we can use the model in Three.js, we first have to export it from Blender:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start the export, first navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> | <span class="strong"><strong>Three.js</strong></span>.</li><li class="listitem">In the window that opens, we can select a destination and a filename. For this recipe, name the file <code class="literal">crow.js</code> and set the destination to the <code class="literal">assets/models/bones</code> folder.</li><li class="listitem">Before we hit the <span class="strong"><strong>Export</strong></span> button, we need to configure some Three.js-specific properties. You can do this in the panel on the left-hand side in the <span class="strong"><strong>Export Three.js</strong></span> section. In that section, make sure that the <span class="strong"><strong>Bones</strong></span>, <span class="strong"><strong>Skinning</strong></span>, and <span class="strong"><strong>Skeletal</strong></span> animation checkboxes are selected. If the <span class="strong"><strong>Morph Animation</strong></span> checkbox is selected, disable it. Once you've checked the box, click on the <span class="strong"><strong>Export</strong></span> button.</li><li class="listitem">Now that we've exported the model, the first thing we need to do in Three.js is load the model using <code class="literal">THREE.JSONLoader</code>:<div class="informalexample"><pre class="programlisting">  var loader = new THREE.JSONLoader();
  loader.load("../assets/models/bones/crow.js",function(model){
    ...
  });</pre></div></li><li class="listitem">Once<a id="id567" class="indexterm"/> the model is loaded in Three.js. we can process it. The first thing we do in the callback from the <code class="literal">loader.load</code> function is to set up the material:<div class="informalexample"><pre class="programlisting">  var mat = new THREE.MeshLambertMaterial({color: 0xf33f33,shading: THREE.FlatShading, skinning:true})</pre></div><p>This is just a standard <code class="literal">THREE.MeshLambertMaterial</code> object. The only thing you need to make sure is to set the <code class="literal">skinning</code> property of the material to <code class="literal">true</code>.</p></li><li class="listitem">Now that we've got the model and the material, we can create a mesh. As we're working with skeletons, we need to create <code class="literal">THREE.SkinnedMesh</code>:<div class="informalexample"><pre class="programlisting">  mesh = new THREE.SkinnedMesh(model, mat);</pre></div></li><li class="listitem">Next, we need to select the animation we want to play. For this, you use the following code snippet:<div class="informalexample"><pre class="programlisting">  model.animation = "Crow.ArmatureAction";
  THREE.AnimationHandler.add(model.animations[0]);
  var animation = new THREE.Animation(mesh, model.animation );
  animation.play();</pre></div><p>You need to make sure the <code class="literal">animation</code> property contains the name of an animation from the <code class="literal">model.animations</code> array. In this case, we've only got one animation with the <code class="literal">Crow.ArmatureAction</code> name. Skeleton-based animations are handled using <code class="literal">THREE.AnimationHandler</code>. So, we add the animation from our model to the handler. Next, we need to create a <code class="literal">THREE.Animation</code> instance. This object combines our model with the animation we want to play. When we have this object we can call the <code class="literal">play()</code> function to tell Three.js to play the animation.</p></li><li class="listitem">The final step we need to take before the animation will play is to update the <code class="literal">render</code> loop:<div class="informalexample"><pre class="programlisting">  var t = new THREE.Clock();
  function render() {
    renderer.render(scene, camera);
    THREE.AnimationHandler.update( t.getDelta() );
    requestAnimationFrame(render);
  }</pre></div><p>Here, we use <code class="literal">THREE.Clock()</code> to determine how much time has passed (<code class="literal">t.getDelta()</code>) between this frame and the previous one. This is passed into <code class="literal">THREE.AnimationHandler</code> to update all the registered animations and move the mesh in the correct position.</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec323"/>How it works…</h2></div></div></div><p>When<a id="id568" class="indexterm"/> exporting the animation, the Three.js exporter will write out the position and rotation of the bones at the times we specified in Blender. This information can then be used directly in Three.js to determine the position and rotation of the bones when we're playing back the animation. This way, we can create fairly complex animations without having to create huge model files.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec324"/>There's more…</h2></div></div></div><p>Working with skeletons in Blender and creating animations from them is a subject on which much is written. If you're interested in learning more about rigging models and creating skeleton-based animations, a couple of good resources to start with are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Blender <a id="id569" class="indexterm"/>Tutorial: Basics of Character Rigging at <a class="ulink" href="http://www.youtube.com/watch?v=cGvalWG8HBU">http://www.youtube.com/watch?v=cGvalWG8HBU</a></li><li class="listitem" style="list-style-type: disc">Blender manual: rigging at <a class="ulink" href="http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging">http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging</a></li><li class="listitem" style="list-style-type: disc">Blender Guru: introduction to rigging at <a class="ulink" href="http://www.blenderguru.com/tutorials/introduction-to-rigging">http://www.blenderguru.com/tutorials/introduction-to-rigging</a></li><li class="listitem" style="list-style-type: disc">Building A Basic Low Poly Character Rig In Blender at <a class="ulink" href="http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955">http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec325"/>See also</h2></div></div></div><p>In this chapter, we have some other recipes that deal with animations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Animation using morph targets</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Animation with skeletons</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using morph animations created in Blender</em></span></li></ul></div></div></div>
<div class="section" title="Adding a simple collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec93"/>Adding a simple collision detection</h1></div></div></div><p>When <a id="id570" class="indexterm"/>you're creating games or interactive environments, a common requirement is the option to detect collisions between objects. In the <span class="emphasis"><em>Adding a physics engine</em></span> recipe, we use an external library to handle collisions (and other physics). This, however, is a rather heavy solution if all you require is the option to detect collisions. In this recipe, we provide a simple approach that you can use if you want to detect collisions without having to use an external library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec326"/>Getting ready</h2></div></div></div><p>In this recipe, we use <code class="literal">THREE.Raycaster</code> to check for collisions. This object is provided by the standard Three.js distribution, so you don't need any additional libraries. We've provided a simple example that shows you how this recipe can be applied. For this, open the <code class="literal">07.06-add-simple-detection-collision.html</code> example in your browser, and you will see something similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_11.jpg" alt="Getting ready"/></div><p>In this example, you can move the central cube around using the arrow keys and rotate it around the <span class="emphasis"><em>y</em></span> axis with the <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span> keys. Whenever a collision occurs with one of the other cubes, we change the opacity to indicate a collision.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec327"/>How to do it…</h2></div></div></div><p>To accomplish collision detection, we need to take a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's<a id="id571" class="indexterm"/> start simple and create the cube that we'll move around. We will detect collisions between this cube and the cubes we define in step 2:<div class="informalexample"><pre class="programlisting">  var cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
  var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff2255});
var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.name='cube';
scene.add(cube);</pre></div></li><li class="listitem">Now, let's create an array that will hold all the objects that we can collide with and add some cubes to that array:<div class="informalexample"><pre class="programlisting">var cubes = [];
var cubeMaterial2 = new THREE.MeshLambertMaterial({color: 0xff0000});
var cube2 = new THREE.Mesh(cubeGeometry, cubeMaterial2);
cube2.position.set(5,0,0);
cube2.name='cube-red';
scene.add(cube2);
cubes.push(cube2);
...
var cubeMaterial5 = new THREE.MeshLambertMaterial({color: 0xff00ff});
var cube5 = new THREE.Mesh(cubeGeometry, cubeMaterial5);
cube5.position.set(-5,0,0);
cube5.name='cube-purple';
scene.add(cube5);
cubes.push(cube5);</pre></div></li><li class="listitem">Now that we've got the object to move around and the objects to detect the collisions with, we can add the code to detect collisions. In the <code class="literal">render</code> loop, we need to add the following:<div class="informalexample"><pre class="programlisting">// reset the opacity at the beginning of the loop
cubes.forEach(function(cube){
    cube.material.transparent = false;
    cube.material.opacity = 1.0;

});

var cube = scene.getObjectByName('cube');
var originPoint = cube.position.clone();

for (var vertexIndex = 0; 
         vertexIndex &lt; cube.geometry.vertices.length;
         vertexIndex++) {
    var localVertex = cube.geometry.
    vertices[vertexIndex].clone();
    var globalVertex = localVertex.applyMatrix4( 
                          cube.matrix);
    var directionVector = globalVertex.sub( 
                          cube.position);

    var ray = new THREE.Raycaster( 
                   originPoint,
                   directionVector.clone().normalize() );
    var collisionResults = ray.intersectObjects( cubes );
    if ( collisionResults.length &gt; 0 
                 &amp;&amp; collisionResults[0].distance &lt; 
                         directionVector.length() ) {
         collisionResults[0].object
                    .material.transparent = true;
        collisionResults[0]
                    .object.material.opacity = 0.4;
    }
}</pre></div><p>In this piece of code, we simply check whether one of the vertices of our moving cube intersects with any of the cubes in the <code class="literal">cubes</code> array. If we detect a collision, we change the opacity of the cube we collided with.</p></li></ol></div><p>With<a id="id572" class="indexterm"/> these steps, we have a rudimentary solution to detect collisions. This approach works great to detect collisions between flat objects but might miss detection with small spike-like objects. You can enhance this solution by checking collisions against more vertices. You can, for instance, add more vertices by increasing the <code class="literal">widthSegments</code>, <code class="literal">heightSegments</code>, and <code class="literal">depthSegments</code> objects of the cube, or you can calculate intermediate vertices yourself.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec328"/>How it works…</h2></div></div></div><p>To detect collisions in this approach, we shoot a ray using <code class="literal">THREE.RayCaster</code> from the center of the cube that is moving to each of its vertices. If this ray intersects with one of the other cubes from the <code class="literal">cubes</code> array in its path from the center to a vertex, it means that one of the vertices is inside one of the other cubes. We interpret this as a collision and can take appropriate action.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec329"/>There's more…</h2></div></div></div><p>This recipe is based on the great work done by Lee Stemkoski, who provided an initial implementation of this approach at <a class="ulink" href="http://stemkoski.github.io/Three.js/Collision-Detection.html">http://stemkoski.github.io/Three.js/Collision-Detection.html</a>. Besides a ray-based approach to collision detection, there are, of course, alternative approaches. A very common<a id="id573" class="indexterm"/> approach is to use the bounding boxes of a mesh to <a id="id574" class="indexterm"/>detect whether two meshes touch. Three.js even provides a function for this in the <code class="literal">THREE.Box3</code> object called <code class="literal">isIntersectionBox</code>. As using a ray casting approach is a rather computationally expensive way to detect collisions, often a bounding box approach is used first, followed by the more accurate ray casting method.</p><p>A couple of good resources on such an approach can be found here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>3D Theory - Collision Detection</em></span> at <a class="ulink" href="http://www.euclideanspace.com/threed/animation/collisiondetect/">http://www.euclideanspace.com/threed/animation/collisiondetect/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>AABB to AABB detection in C++</em></span> at <a class="ulink" href="http://www.miguelcasillas.com/?p=30">http://www.miguelcasillas.com/?p=30</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>3D Collision detection and resolution using sweeping AABB bounding boxes</em></span> at <a class="ulink" href="http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping">http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping</a></li></ul></div><p>The physics engine we will use in the <span class="emphasis"><em>Adding a physics engine</em></span> recipe also uses a shapes-based approach to collision detection. Besides just a bounding box, it provides a number of different shapes to detect collisions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec330"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <span class="emphasis"><em>Adding a physics engine</em></span> recipe, we detect collisions using the physics engine. For another recipe that uses <code class="literal">THREE.RayCaster</code>, you can also look at the <span class="emphasis"><em>Dragging and dropping objects around a scene</em></span> recipe, which can also be found in this chapter.</li></ul></div></div></div>
<div class="section" title="Saving a movie of an animation in Chrome"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec94"/>Saving a movie of an animation in Chrome</h1></div></div></div><p>In <a id="id575" class="indexterm"/>this chapter, we've showed you various ways to<a id="id576" class="indexterm"/> create animations. Sometimes, however, people don't have a WebGL-enabled browser, or you want to just share the resulting animation and not the WebGL website. In these cases, it would be very helpful to be able to just save the animation to your local filesystem and share it. In this recipe, we show you one approach you can use for this scenario.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec331"/>Getting ready</h2></div></div></div><p>To work with this recipe, you need to make sure that you use Google Chrome. We use an internal functionality to save the animation as a WebM file, which unfortunately, still only works on Google Chrome. We don't have to create the complete functionality for this<a id="id577" class="indexterm"/> recipe from scratch, as there is a library available <a id="id578" class="indexterm"/>that handles the low-level technical stuff for us: CCapture (<a class="ulink" href="https://github.com/spite/ccapture.js/">https://github.com/spite/ccapture.js/</a>). To work with this library, we<a id="id579" class="indexterm"/> need to load the following two JavaScript files at the top of our HTML page:</p><div class="informalexample"><pre class="programlisting">  &lt;script src="../libs/CCapture.min.js"&gt;&lt;/script&gt;
  &lt;script src="../libs/Whammy.js"&gt;&lt;/script&gt;</pre></div><p>We've provided a very simple example that shows you this recipe in action. If you open up <code class="literal">07.07-save-a-movie-of-an-animation.html</code> in your browser, you'll see a slowly moving cube in your browser, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_12.jpg" alt="Getting ready"/></div><p>The reason this cube moves so slowly is that in the background, a movie is being saved. The libraries used slow down the animation to make sure no frames are skipped. To save the movie, click on the <span class="strong"><strong>saveMovie</strong></span> menu button at the top of the screen.</p><p>The resulting movie can now be played in the movie player of your choice, which supports WebM (for instance, VLC or mPlayer) as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_13.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec332"/>How to do it…</h2></div></div></div><p>Once <a id="id580" class="indexterm"/>you've included the appropriate libraries<a id="id581" class="indexterm"/> in your HTML page, using this library is actually very easy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create a <code class="literal">capture</code> object:<div class="informalexample"><pre class="programlisting">  Var capturer = new CCapture({
    framerate: 20
  });</pre></div><p>Here, we create a capturer that captures 20 frames per second.</p></li><li class="listitem">The next step before we start rendering the scene is to start <code class="literal">capturer</code>:<div class="informalexample"><pre class="programlisting">  capturer.start();
  // call the render loop
  render();</pre></div></li><li class="listitem">We also need to tell <code class="literal">capturer</code> what to capture in the <code class="literal">render</code> loop:<div class="informalexample"><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    capturer.capture( renderer.domElement );
    requestAnimationFrame(render);
  }</pre></div><p>With these steps, the <code class="literal">capturer</code> object will start capturing the output of our WebGL canvas 20 times per second.</p></li><li class="listitem">As a last step, we need to add a functionality to save the movie (in our example, this is triggered by clicking on the <span class="strong"><strong>saveMovie</strong></span> button):<div class="informalexample"><pre class="programlisting">  this.saveMovie = function() {
    var videoUrl = capturer.save();
    var link = document.createElement("a");
    link.download = 'video.webm';
    link.href = videoUrl;
    link.click();
  };</pre></div><p>This will download the movie as <code class="literal">video.webm</code> and save it to your local disk.</p></li></ol></div><p>When <a id="id582" class="indexterm"/>you run this, you will notice that the frame <a id="id583" class="indexterm"/>rate in your browser drops significantly. The reason is that the CCapture library changes the behavior of the <code class="literal">requestAnimationFrame</code> function to make sure it has enough time to capture the screen and add it as a frame to the movie. The movie file that is created will look like you expected and have the number of frames per second, as specified in step 1 of this recipe.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec333"/>There's more…</h2></div></div></div><p>The approach that we showed you in the recipe works great for most types of animations. However, when you want to record a user interacting with your scene, you can't use this library as it slows down the rendering of your scene, which makes interacting with the scene difficult. An alternative way to record the scene is using a backend service that collects screenshots and creates a movie server side. An example of such a setup can be found at <a class="ulink" href="http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets">http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec334"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you just want to save a screenshot instead of a complete movie, you can use the <span class="emphasis"><em>Saving WebGL output to disk</em></span> recipe, which we explained in <a class="link" href="ch06.html" title="Chapter 6. Point Clouds and Postprocessing">Chapter 6</a>, <span class="emphasis"><em>Point Clouds and Postprocessing</em></span>.</li></ul></div></div></div>
<div class="section" title="Dragging and dropping objects around a scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec95"/>Dragging and dropping objects around a scene</h1></div></div></div><p>When <a id="id584" class="indexterm"/>you create an interactive environment, a common requirement is the option to use your mouse to drag objects around. This functionality isn't something that is supported out of the box by Three.js. In this recipe, we'll show you the steps that are needed to implement this functionality.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec335"/>Getting ready</h2></div></div></div><p>For <a id="id585" class="indexterm"/>this recipe, we only use the functionality that is available in the standard Three.js library. We'll use the <code class="literal">THREE.Raycaster</code> object together with <code class="literal">THREE.Projector</code> to implement the drag and drop functionality. To see the drag and drop functionality in action, you can open the <code class="literal">07.08-drag-n-drop-object-around-scene.html</code> example in your browser, and you will see something similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_14.jpg" alt="Getting ready"/></div><p>In this example, you can see a large number of cubes, which you can move individually. Just click on one with the mouse and drag it to a new position. This scene also uses <code class="literal">THREE.OrbitControls</code>, so when you click on the white background, you can use your mouse to rotate the scene.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec336"/>How to do it…</h2></div></div></div><p>For this recipe, we need to take a fair amount of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we do is create a number of global variables, which we'll access in the following steps:<div class="informalexample"><pre class="programlisting">  var plane;
  var selectedObject;
  var projector = new THREE.Projector();
  var offset = new THREE.Vector3();
  var objects =[];</pre></div><p>We'll explain how these objects are used in the upcoming steps.</p></li><li class="listitem">When <a id="id586" class="indexterm"/>we want to move an object around, we need to determine on what plane (around which axis) we're going to move the selected cube. A mouse moves in two dimensions, while our scene moves in three. For this, we'll use a invisible helper plane, which we define like this:<div class="informalexample"><pre class="programlisting">  plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000, 18, 18 ), new THREE.MeshBasicMaterial() );
  plane.visible = false;
  scene.add( plane );</pre></div><p>This plane is assigned to the global plane variable we saw in step 1.</p></li><li class="listitem">The next step is to create all the cubes. For an easy understanding of this recipe, we list the code about how cubes are created:<div class="informalexample"><pre class="programlisting">  for (var i = 0 ; i &lt; 200 ; i ++) {
    var cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
    var cubeMaterial = new 
    THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
    cubeMaterial.transparent = true;
    cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
<span class="strong"><strong>    objects.push(cube);</strong></span>
    // randomize position, scale and rotation
    scene.add(cube);
  }</pre></div><p>The most interesting line is the highlighted one, where we add the created cube to the global array with the name objects. Only cubes from this array can be moved around.</p></li><li class="listitem">Now that we've got the basics out of the way, we need to tell Three.js what to do when the mouse moves, when a mouse button is clicked on, and when a mouse button is released. Let's first look at the <code class="literal">onmousemove</code> function:<div class="informalexample"><pre class="programlisting">  document.onmousemove = function(e) {
    ...
  };</pre></div><p>Before we can access the information from the mouse movement, we need to register a listener. We do this, as you can see in the code snippet, by assigning a function to the <code class="literal">document.onmousemove</code> property. In the following steps, we'll look at the contents of this <code class="literal">onmousemove</code> function.</p></li><li class="listitem">In<a id="id587" class="indexterm"/> the <code class="literal">onmousemove</code> function, we do a couple of different things. The first thing we always need to do is convert the mouse position to a position in 3D space and create <code class="literal">THREE.Raycaster</code> for that position:<div class="informalexample"><pre class="programlisting">  // get the mouse position in viewport coordinates
  var mouse_x = ( event.clientX / window.innerWidth ) * 2 - 1;
  var mouse_y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  // get the 3D position and create a raycaster
  var vector = new THREE.Vector3( mouse_x, mouse_y, 0.5 );
  projector.unprojectVector( vector, camera );
  var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );</pre></div><p>At this point, we can use <code class="literal">THREE.Raycaster</code> to select objects that are the position of our mouse.</p></li><li class="listitem">The next step is to either drag an object around if we've already clicked on one (see steps 7, 8, and 9 for more details on this), or reposition the plane we created in step 2:<div class="informalexample"><pre class="programlisting">  if (selectedObject) {
    var intersects = raycaster.intersectObject( plane );
    selectedObject.position.copy(intersects[ 0 ] .point.sub( offset ) );
  } else {
    var intersects = raycaster.intersectObjects(objects);
    if ( intersects.length &gt; 0 ) {
      plane.position.copy( intersects[0]
        .object.position );
        plane.lookAt( camera.position );
    }
  }</pre></div><p>If we've selected an object and are dragging it around, we set the position of that object based on the position where the ray cast from our mouse intersects the invisible helper plane using the offset that we calculate in step 9. If we aren't dragging an object around, and using our ray we determine that we intersect one of the cubes, we move our helper <code class="literal">plane</code> object to the position of that object and make sure the plane faces the camera (<code class="literal">plane.lookAt(camera.position)</code>). The object, if we select it, will move alongside this helper <code class="literal">plane</code> object.</p></li><li class="listitem">Next, we <a id="id588" class="indexterm"/>need to define a function to handle the <code class="literal">onmousedown</code> events:<div class="informalexample"><pre class="programlisting">  document.onmousedown = function(event) {
    ...
  };</pre></div></li><li class="listitem">Now, let's look at what to fill in for the <code class="literal">onmousedown</code> event:<div class="informalexample"><pre class="programlisting">  var mouse_x = (event.clientX / window.innerWidth)* 2 - 1;
  var mouse_y = -(event.clientY / window.innerHeight)* 2 + 1;
  var vector = new THREE.Vector3(mouse_x, mouse_y, 0.5);
  projector.unprojectVector(vector, camera);
  var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
  var intersects = raycaster.intersectObjects(objects);</pre></div><p>We once again use <code class="literal">THREE.Raycaster</code> to determine whether an object intersects with a ray cast from the position of our mouse.</p></li><li class="listitem">Now that we know the intersects, we can use them to select the object we're interested in:<div class="informalexample"><pre class="programlisting">  if (intersects.length &gt; 0) {
    orbit.enabled = false;
    selectedObject = intersects[0].object;
    // and calculate the offset
    var intersects = raycaster.intersectObject(plane);
    offset.copy(intersects[0].point).sub(plane.position);
}</pre></div><p>As you can see in this snippet, we first disable the <code class="literal">orbit</code> controller (as we want to drag the object around and not rotate the scene). Next, we assign the first intersected object to the <code class="literal">selectedObject</code> variable, which we used in step 6 to move the selected cube around. Finally, we need to determine the offset between the point where we clicked and the center of the plane. We need this to correctly position the cube in step 6.</p></li><li class="listitem">The last step we need to take is to enable the orbit controller when we release the mouse button and set the <code class="literal">selectedObject</code> property back to null:<div class="informalexample"><pre class="programlisting">  document.onmouseup = function(event) {
    orbit.enabled = true;
    selectedObject = null;
  }</pre></div></li></ol></div><p>As<a id="id589" class="indexterm"/> you can see, there are plenty of steps you need to take to implement this recipe. You can also look at the sources from <code class="literal">07.08-drag-n-drop-object-around-scene.html</code>, which also contain inline documentation about why certain steps are needed.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec337"/>There's more…</h2></div></div></div><p>This recipe was based on the example from the Three.js website, which you can find at <a class="ulink" href="http://threejs.org/examples/#webgl_interactive_draggablecubes">http://threejs.org/examples/#webgl_interactive_draggablecubes</a>. So, for another example to play around with, you can look at that implementation.</p><p>In this recipe, we showed you how you can move the complete mesh around. You can also use this same approach to move individual vertices, faces, or lines around. So, with a little bit of effort, you can use this approach to create a kind of sculpting tool with which you could <a id="id590" class="indexterm"/>directly modify a geometry from your browser. For instance, you could create something like this <a class="ulink" href="http://stephaneginier.com/sculptgl/">http://stephaneginier.com/sculptgl/</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec338"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this chapter, we also use <code class="literal">THREE.Raycaster</code> for the <span class="emphasis"><em>Adding simple collision detection</em></span> recipe. If you want to drag and drop external files onto your Three.js scene, you can refer to the <span class="emphasis"><em>Dragging a file from the desktop to the scene</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>.</li></ul></div></div></div>
<div class="section" title="Adding a physics engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec96"/>Adding a physics engine</h1></div></div></div><p>In<a id="id591" class="indexterm"/> the recipes so far, we've added animations and detection collisions to the scene manually. In this recipe, we'll show you how to use an external physics engine to add gravity, collision detection, and other physics effects to your scene.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec339"/>Getting ready</h2></div></div></div><p>For this recipe, we need to use a couple of external libraries. At the top of your HTML page, you have to add the following:</p><div class="informalexample"><pre class="programlisting">  &lt;script src="../libs/physi.js"&gt;&lt;/script&gt;</pre></div><p>This <a id="id592" class="indexterm"/>library contains the main implementation of the physics engine. This library in itself uses two additional libraries that need to be provided. You first need to make sure the <code class="literal">ammo.js</code> library is stored in the same location as the <code class="literal">physi.js</code> library, and at the beginning of your JavaScript code, you should add this:</p><div class="informalexample"><pre class="programlisting">  Physijs.scripts.worker = "../libs/physijs_worker.js";</pre></div><p>This points to <a id="id593" class="indexterm"/>a web worker (<a class="ulink" href="http://www.w3.org/TR/workers/">http://www.w3.org/TR/workers/</a>) that handles the physics calculations in a separate thread. There is, of course, a ready-to-use example of this recipe that you can use as a reference or to experiment with. The example for this recipe is called <code class="literal">07.09-add-a-physics-engine.html</code>, and when this is opened in the browser you will see something similar to what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_07_15.jpg" alt="Getting ready"/></div><p>In this example, you can use the <span class="strong"><strong>addCube</strong></span> button to add cubes to the scene. This cube will be added high above the ground plane and will drop down. The physics engine will determine how the falling cube interacts with its environment.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec340"/>How to do it…</h2></div></div></div><p>In this recipe, we only set up a basic physics-enabled scene. Refer to the <span class="emphasis"><em>There's more…</em></span> section of this recipe for additional functionality provided by the <code class="literal">Physijs</code> library. To create a <a id="id594" class="indexterm"/>basic scene, you need to take the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing to do is that instead of creating <code class="literal">THREE.Scene</code>, we'll create <code class="literal">Physics.Scene</code>:<div class="informalexample"><pre class="programlisting">  scene = new Physijs.Scene;
  scene.setGravity(new THREE.Vector3( 0, -30, 0 ));</pre></div><p>On this newly created scene, we also need to set the <code class="literal">gravity</code> property. In this case, we set a gravity of <code class="literal">-30</code> on the <span class="emphasis"><em>y</em></span> axis, which means a scene where objects fall down.</p></li><li class="listitem">Next, let's create <code class="literal">THREE.Geometry</code> and <code class="literal">THREE.MeshLambertMaterial</code>, which we'll use for the cubes:<div class="informalexample"><pre class="programlisting">  var cubeGeometry = new THREE.BoxGeometry(
    4 * Math.random() + 2, 
    4 * Math.random() + 2, 
    4 * Math.random() + 2);
  var cubeMaterial = new THREE.MeshLambertMaterial(
    {
      color: 0xffffff * Math.random()
    }
  );</pre></div><p>There is nothing special to do in this step for <code class="literal">Physijs</code>.</p></li><li class="listitem">The next step is to create a mesh object. For objects to work with <code class="literal">Physijs</code>, we need to create a <code class="literal">Physijs</code> library specific mesh and a <code class="literal">Physijs</code> library specific material:<div class="informalexample"><pre class="programlisting">  var box_material = Physijs.createMaterial(
    cubeMaterial, 
    control.friction, 
    control.restitution);
  var cube = new Physijs.BoxMesh(
    cubeGeometry,
    box_material,
    10
  );
  scene.add(cube);</pre></div><p>For the material, we use the <code class="literal">Physijs.createMaterial</code> function. This wraps our material created in step 2 and allows us to define the friction and restitution properties. The friction defines the roughness of the object and affects how far it can slide over another object. The <code class="literal">restitution</code> object is used for the bounciness of an object. To create a mesh, we use the <code class="literal">Physijs.BoxMesh</code> object, provide the geometry and the material we just created, and also add the weight of the object. <code class="literal">Physijs</code> provides differently shaped meshes; for more information on them, refer to the <span class="emphasis"><em>There's more…</em></span> section of this recipe.</p></li><li class="listitem">The<a id="id595" class="indexterm"/> final step we need to take is to update the <code class="literal">render</code> loop:<div class="informalexample"><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    requestAnimationFrame(render);
    scene.simulate();
  }</pre></div><p>Here, we add the <code class="literal">scene.simulate</code> function. This is used to calculate the new positions of all the objects that have been wrapped in a <code class="literal">Physijs</code> library specific mesh.</p></li></ol></div><p>With these basic steps, you've got a fully working physics-enabled Three.js scene. An important aspect to take into account when using this engine is that there is a hit on performance. For each object of the scene, <code class="literal">Physijs</code> will need to calculate its next position and rotation. This works great for tens of objects, but you'll see a severe hit when working with hundreds of Physijs-managed objects.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec341"/>How it works…</h2></div></div></div><p>We call <code class="literal">scene.simulate()</code>, which we added to the <code class="literal">render</code> loop in step 4, for each frame that is rendered. When this function is called, <code class="literal">Physijs</code> will look at all the objects it knows about, and it also looks at the gravity configured on the scene and will use that information to calculate new positions and rotations for each object if collisions between objects occur. it will use the <code class="literal">friction</code> and <code class="literal">restitution</code> properties of the <code class="literal">Physijs</code> material and the weight function of an object to determine how that object and the one it collides with should react. This is repeated in each <code class="literal">render</code> loop and gives the simulation of real physics in the scene.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec342"/>There's more…</h2></div></div></div><p>What we've done in this recipe is only a very small part of what is possible with this physics engine. You <a id="id596" class="indexterm"/>can find more information on the Physijs website at <a class="ulink" href="http://chandlerprall.github.io/Physijs/">http://chandlerprall.github.io/Physijs/</a>. Interesting subjects from that site are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Support for <a id="id597" class="indexterm"/>different object shapes: <a class="ulink" href="https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes">https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes</a>.</li><li class="listitem" style="list-style-type: disc">How to add constraints to your object. This makes it possible to constrain the movement of an object around an axis (like a slider), a joint, or even another object. More information on this feature can be found at <a class="ulink" href="https://github.com/chandlerprall/Physijs/wiki/Constraints">https://github.com/chandlerprall/Physijs/wiki/Constraints</a>.</li></ul></div><p>Physijs uses an<a id="id598" class="indexterm"/> external physics library for all the calculations. For more information on that engine, look at the ammo.js website (<a class="ulink" href="https://github.com/kripken/ammo.js/">https://github.com/kripken/ammo.js/</a>). Note that ammo.js itself is a JavaScript port of the Bullet physics engine. So, if you really want to dive into the details, you should look at<a id="id599" class="indexterm"/> the Bullet documentation that can be found at <a class="ulink" href="http://bulletphysics.org/wordpress/">http://bulletphysics.org/wordpress/</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec343"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you don't want to include a complete physics engine inside your project, you can also simulate parts of a physics engine yourself. How to add basic collision detection to your scene is explained in the <span class="emphasis"><em>Adding a simple collision detection</em></span> recipe.</li></ul></div></div></div></body></html>