- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Node.js Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main tasks required in server-side development is transferring data,
    either reading data sent by a client or browser or writing data that must be transmitted
    or stored in some way. In this chapter, I will introduce the Node.js API for dealing
    with data sources and data destinations, known as *streams*. I will explain the
    concept behind streams, show how they are used to deal with HTTP requests, and
    explain why one common source of data – the file system – should be used with
    caution in a server-side project. *Table 6.1* puts streams in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.1: Putting streams in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | Streams are used by Node.js to represent data sources or
    destinations, including HTTP requests and responses. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Streams don’t expose the details of how data is produced
    or consumed, which allows the same code to process data from any source. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | Node.js provides streams to deal with HTTP requests.
    The streams API is used to read data from the HTTP request and write data to the
    HTTP response. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | The streams API can be a little
    awkward to work with, but this can be improved with the use of third-party packages,
    which often provide more convenient methods to perform common tasks. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Streams are integral to Node.js development.
    Third-party packages can simplify working with streams, but it is helpful to understand
    how streams work for when problems arise. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 6.2* sums up what the chapter will cover.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Write data to a stream | Use the `write` or `end` methods. | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Set response headers | Use the `setHeader` method. | 5–7 |'
  prefs: []
  type: TYPE_TB
- en: '| Manage data buffering | Use the result from the `write` method and handle
    the `drain` event. | 8–9 |'
  prefs: []
  type: TYPE_TB
- en: '| Read data from a stream | Handle the `data` and `end` events or use an iterator.
    | 10–15 |'
  prefs: []
  type: TYPE_TB
- en: '| Connect streams | Use the `pipe` method. | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| Transform data | Extend the `Transform` class and use the stream object mode.
    | 17–19 |'
  prefs: []
  type: TYPE_TB
- en: '| Serve static files | Use the Express static middleware or use the `sendFile`
    and `download` methods. | 20–26 |'
  prefs: []
  type: TYPE_TB
- en: '| Encode and decode data | Use the Express JSON middleware and the `json` response
    method. | 27–28 |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I will continue to use the `webapp` project created in *Chapter
    4* and modified in *Chapter 3*. To prepare for this chapter, replace the contents
    of the `server.ts` file in the `src` folder with the code shown in *Listing 6.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.1: Replacing the contents of the server.Ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Express router filters out favicon requests and passes on all other HTTP
    GET requests to a function named `basicHandler`, which is imported from the `handler`
    module. To define the handler, replace the contents of the `handler.ts` to the
    `src` folder with the code shown in *Listing 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.2\. The contents of the handler.ts file in the src folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This handler uses the Node.js `IncomingMessage` and `ServerResponse` types,
    even though Express is used to route requests. I will demonstrate the enhancements
    Express provides in the *Using third-party enhancements* section, but I am going
    to start with the built-in features that Node.js provides.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples in this chapter require an image file. Create the `static` folder
    and add to it an image file named `city.png`. You can use any PNG image file as
    long as you name it `city.png`, or you can download the public domain panorama
    of the New York City skyline that I used, shown in *Figure 6.1*, from the code
    repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The city.png file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: Run the command shown in *Listing 6.3* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.3: Starting the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser and request `http://localhost:5000`. You will see the result
    shown in *Figure 6.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Running the example project'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to understand streams is to ignore data and think about water
    for a moment. Imagine you are in a room in which a pipe with a faucet enters through
    one wall. Your job is to build a device that will collect the water from the pipe.
    There is obviously something connected to the other end of the pipe that produces
    the water, but you are only able to see the faucet, and so the design of your
    device will be dictated by what you know: you have to create something that will
    connect to the pipe and receive the water when the faucet is turned on. Having
    such a limited view of the system you are working with may feel like a restriction,
    but the pipe can be connected to any source of water and your device works just
    as well whether the water comes from a river or a reservoir; it is all just water
    coming through the pipe via the faucet, and it is always consumed consistently.'
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the pipe, the producer of the water has a pipe into which
    they pump their water. The water producer can’t see what you have attached to
    the other end of the pipe and does not know how you are going to consume the water.
    And it doesn’t matter, because all the producer has to do is push their water
    through the pipe, regardless of whether their water will be used to drive a water
    mill, fill a swimming pool, or run a shower. You can change the device attached
    to your pipe and nothing would change for the producer, who still keeps pumping
    water into the same pipe in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of web development, a *stream* solves the problem of distributing
    data in the same way that the pipe solves the problem of distributing water. Like
    a pipe, a stream has two ends. At one end is the data producer, also known as
    the *writer*, who puts a sequence of data values into the stream. At the other
    end is the data consumer, also known as the *reader*, who receives the sequence
    of data values from the stream. The writer and reader each have their own API
    that allows them to work with the stream, as shown in *Figure 6.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The anatomy of a stream'
  prefs: []
  type: TYPE_NORMAL
- en: This arrangement has two important characteristics. The first is that the data
    arrives in the same order in which it is written, which is why streams are usually
    described as a *sequence* of data values.
  prefs: []
  type: TYPE_NORMAL
- en: The second characteristic is that the data values can be written to the stream
    over time so that the writer doesn’t have to have all the data values ready before
    the first value is written. This means that the reader can receive and start processing
    data while the writer is still preparing or computing later values in the sequence.
    This makes streams suitable for a wide range of data sources, and they also integrate
    well with the Node.js programming model, as the examples in this chapter will
    demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Using Node.js streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `streams` module contains classes that represent different kinds of streams,
    and the two most important are described in *Table 6.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.3: Useful stream classes'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Writable` | This class provides the API for writing data to a stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `Readable` | This class provides the API for reading data from a stream.
    |'
  prefs: []
  type: TYPE_TB
- en: In Node.js development, one end of a stream is usually connected to something
    outside of the JavaScript environment, such as a network connection or the file
    system, and this allows data to be read and written in the same way regardless
    of where it is going to or coming from.
  prefs: []
  type: TYPE_NORMAL
- en: For web development, the most important use of streams is they are used to represent
    HTTP requests and responses. The `IncomingMessage` and `ServerResponse` classes,
    which are used to represent HTTP requests and responses, are derived from the
    `Readable` and `Writable` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Writable` class is used to write data to a stream. The most useful features
    provided by the `Writable` class are described in *Table 6.4* and explained in
    the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.4: Useful Writable Features'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `write(data, callback)` | This method writes data to the stream and invokes
    the optional callback function when the data has been flushed. Data can be expressed
    as a `string`, `Buffer`, or `Uint8Array`. For string values, an optional encoding
    can be specified.The method returns a `boolean` value that indicates whether the
    stream is able to accept further data without exceeding its buffer size, as described
    in the *Avoiding excessive data buffering* section. |'
  prefs: []
  type: TYPE_TB
- en: '| `end(data, callback)` | This method tells Node.js that no further data will
    be sent. The arguments are an optional final chunk of data to write and an optional
    callback function that will be invoked when the data is finished. |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy(error)` | This method destroys the stream immediately, without waiting
    for any pending data to be processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | This property returns `true` if the stream has been closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `destroyed` | This property returns `true` if the `destroy` method has been
    called. |'
  prefs: []
  type: TYPE_TB
- en: '| `writable` | This property returns `true` if the stream can be written to,
    meaning that the stream has not ended, encountered an error, or been destroyed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `writableEnded` | This property returns `true` if the `end` method has been
    called. |'
  prefs: []
  type: TYPE_TB
- en: '| `writableHighWaterMark` | This property returns the size of the data buffer
    in bytes. The `write` method will return `false` when the amount of buffered data
    exceeds this amount. |'
  prefs: []
  type: TYPE_TB
- en: '| `errored` | This property returns `true` if the stream has encountered an
    error. |'
  prefs: []
  type: TYPE_TB
- en: The `Writable` class also emits events, the most useful of which are described
    in *Table 6.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.5: Useful Writable Events'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | This event is emitted when the stream is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `drain` | This event is emitted when the stream can accept data without buffering.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | This event is emitted when an error occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| `finish` | This event is emitted when the `end` method is called and all
    of the data in the stream has been processed. |'
  prefs: []
  type: TYPE_TB
- en: The basic approach to using a writable stream is to call the `write` method
    until all of the data has been sent to the stream, and then call the `end` method,
    as shown in *Listing 6.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.4: Writing Data in the handler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save the changes, allow Node.js to restart, and then request `http://localhost:5000`.
    The handler will write its data to the response stream, producing the result shown
    in *Figure 6.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Writing data to an HTTP response stream'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to think of the endpoint of the stream as being a straight pipe to
    the ultimate recipient of the data, which is the web browser in this case, but
    that’s rarely the case. The endpoint for most streams is the part of the Node.js
    API that interfaces with the operating system, in this case, the code that deals
    with the operating system’s network stack to send and receive data. This indirect
    relationship leads to important considerations, as described in the sections that
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stream enhancements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some streams are enhanced to ease development, which means that the data you
    write to the stream won’t always be the data that is received at the other end.
    In the case of HTTP responses, for example, the Node.js HTTP API aids development
    by ensuring that all responses conform to the basic requirements of the HTTP protocol,
    even when the programmer doesn’t explicitly use the features provided to set the
    status code and headers. To see the content that the example in *Listing 6.4*
    writes to the stream, open a new command prompt and run the Linux command shown
    in *Listing 6.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.5: Making an HTTP Request (Linux)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are a Windows user, use PowerShell to run the command shown in *Listing
    6.6* instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.6: Making an HTTP Request (Windows)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands make it easy to see the entire response sent by Node.js. The
    code in *Listing 6.4* uses just the `write` and `end` methods, but the HTTP response
    will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Node.js HTTP API makes sure the response is legal HTTP by adding an HTTP
    version number, a status code and message, and a minimal set of headers. This
    is a useful feature, and it helps illustrate the fact that you cannot assume that
    the data you write to a stream will be the data that arrives at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServerResponse` class demonstrates another kind of stream enhancement,
    which is methods or properties that write content to the stream for you, as shown
    in *Listing 6.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.7: Using a Stream Enhancement Method in the handler.ts File in the
    src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scenes, the `ServerResponse` class merges the arguments passed to
    the `setHeader` method with the default content used for responses. The `ServerResponse`
    class is derived from `Writable` and implements the methods and properties described
    in *Table 6.4*, but the enhancements make it easier to write content to the stream
    that is specific to HTTP requests, like setting a header in the response. If you
    run the commands shown in *Listing 6.6* or *Listing 6.7* again, you will see the
    effect of calling the `setHeader` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding excessive data buffering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writable streams are created with a buffer in which data is stored before it
    is processed. The buffer is a way of improving performance, by allowing the producer
    of data to write data to the stream in bursts faster than the stream endpoint
    can process them.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the stream processes a chunk of data, it is said to have *flushed*
    the data. When all of the data in the stream’s buffer has been processed, the
    stream buffer is said to have been *drained*. The amount of data that can be stored
    in the buffer is known as the *high-water mark*.
  prefs: []
  type: TYPE_NORMAL
- en: A writable stream will always accept data, even if it has to increase the size
    of its buffer, but this is undesirable because it increases the demand for memory
    that can be required for an extended period while the stream flushes the data
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal approach is to write data to a stream until its buffer is full and
    then wait until that data is flushed before further data is written. To help achieve
    this goal, the `write` method returns a `boolean` value that indicates whether
    the stream can receive more data without expanding its buffer beyond its target
    high-water mark.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6.8* uses the value returned by the `write` method to indicate when
    the stream buffer has reached capacity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.8: Checking Stream Capacity in the handler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to increase the maximum value used by the `for` loop, but for
    my development PC, rapidly writing 10,000 messages to the stream will reliably
    reach the stream limits. Use a browser to request `http://localhost:5000`, and
    you will see messages like these produced by the Node.js console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writable streams emit the `drain` event when their buffers have been drained,
    at which point more data can be written. In *Listing 6.9*, data is written to
    the HTTP response stream until the `write` method returns `false` and then stops
    writing until the `drain` event is received. (If you want to know when an individual
    chunk of data is flushed, then you can pass a callback function to the stream’s
    `write` method.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.9: Avoiding Excessive Data Buffering in the handler.ts File in the
    src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `writeData` function enters a `do...while` loop that writes data to the
    stream until the `write` method returns `false`. The `once` method is used to
    register a handler that will be invoked once when the `drain` event is emitted,
    and which invokes the `writeData` function to resume writing. Once all of the
    data has been written, the `end` method is called to finalize the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoiding the Early End Pitfall**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common mistake – and one that I make regularly – is to put the call to the
    `end` method outside of the callback functions that write the data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The outcome can differ but is usually an error because the callback will invoke
    the `write` method after the stream has been closed, or not all the data will
    be written to the stream because the `drain` event won’t be emitted. To avoid
    this mistake, ensure that the `end` method is invoked within the callback function
    once the data has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a browser to request `http://localhost:5000`, and you will see Node.js
    console messages that show the writing stops as the buffer reaches capacity, resuming
    once the buffer is drained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Reading data from a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important source of data in a web application comes from HTTP request
    bodies. The example project needs a little preparation so that the client-side
    code can make an HTTP request with a body. Add a file named `index.html` to the
    `static` folder with the content shown in *Listing 6.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.10: The Contents of the index.html File in the static Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple HTML document that contains some JavaScript code. I’ll make
    improvements later in the chapter, including separating the JavaScript and HTML
    content into separate files, but this is enough to get started. The JavaScript
    code in *Listing 6.10* uses the browser’s Fetch API to send an HTTP POST request
    with a body that contains 1,000 lines of text. *Listing 6.11* updates the existing
    request handler so that it responds with the contents of the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.11: Updating the Handlers in the handler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I use the `readFileSync` function to perform a blocking read of the `index.html`
    file, which is simple but is not the best way to read files, as I explain later
    in this chapter. To create a new handler that will be used to read the data sent
    by the browser, add a file named `readHandler.ts` to the `src` folder with the
    contents shown in *Listing 6.12*. For the moment, this handler is a placeholder
    that ends the response without producing any content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.12: The Contents of the readHandler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6.13* completes the preparation by adding a route that matches POST
    requests and sends them to the new handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.13: Adding a Route in the server.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, and you will see the button
    defined by the HTML document. Click the button, and the browser will send an HTTP
    POST request and display the status message from the response it receives, as
    shown in *Figure 6.5*. The content presented by the browser is completely unstyled,
    but this is enough for now.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Sending an HTTP POST request'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Readable class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Readable` class is used to read data from a stream. *Table 6.6* describes
    the most useful `Readable` features.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 6.6*: Useful Readable Features'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `pause()` | Calling this method tells the stream to temporarily stop emitting
    the `data` event. |'
  prefs: []
  type: TYPE_TB
- en: '| `resume()` | Calling this method tells the stream to resume emitting the
    `data` event. |'
  prefs: []
  type: TYPE_TB
- en: '| `isPaused()` | This method returns `true` if the stream’s `data` events have
    been paused. |'
  prefs: []
  type: TYPE_TB
- en: '| `pipe(writable)` | This method is used to transfer the stream’s data to a
    `Writable`. |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy(error)` | This method destroys the stream immediately, without waiting
    for any pending data to be processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | This property returns `true` if the stream has been closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `destroyed` | This property returns `true` if the `destroy` method has been
    called. |'
  prefs: []
  type: TYPE_TB
- en: '| `errored` | This property returns `true` if the stream has encountered an
    error. |'
  prefs: []
  type: TYPE_TB
- en: The `Readable` class also emits events, the most useful of which are described
    in *Table 6.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.7: Useful Readable Events'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | This event is emitted when the stream is in flowing mode and provides
    access to the data in the stream. See the *Reading Data with events* section for
    details. |'
  prefs: []
  type: TYPE_TB
- en: '| `end` | This event is emitted when there is no more data to be read from
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | This event is emitted when the stream is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `pause` | This event is emitted when data reading is paused by calling the
    `pause` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `resume` | This event is emitted when data reading is restarted by calling
    the `resume` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | This event is triggered if there is an error reading data from
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: Reading data with events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data can be read from the stream using events, as shown in *Listing 6.14*, where
    a callback function is used to process data as it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.14: Reading Data in the readHandler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `data` event is emitted when data is available to be read from the stream
    and is available for processing by the callback function used to handle the event.
    The data is passed to the callback function as a `Buffer`, which represents an
    array of unsigned bytes, unless the `setEncoding` method has been used to specify
    character encoding, in which case the data is expressed as a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: This example sets the character encoding to UTF-8 so that the callback function
    for the `data` event will receive `string` values, which are then written out
    using the `console.log` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `end` event is emitted when all of the data has been read from the stream.
    To avoid a variation of the early-end pitfall I described earlier, I call the
    response’s `end` method only when the readable stream’s `end` method is emitted.
    Use a browser to request `http://localhost:5000` and click the **Send Request**
    button, and you will see a sequence of Node.js console messages as the data is
    read from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript main thread ensures that `data` events are processed sequentially,
    but the basic idea is that data is read and processed as quickly as possible,
    such that the `data` event will be emitted as soon as possible once data is available
    to be read.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data with an iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instances of the `Readable` class can be used as a source of data in a `for`
    loop, which can provide a more familiar way to read data from a stream, as shown
    in *Listing 6.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.15: Reading Data in a Loop in the readHandler.ts File in the src
    Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `async` and `await` keywords must be used as shown in the example, but the
    result is that the `for` loop reads data from the stream until it is all consumed.
    This example produces the same output as *Listing 6.14*.
  prefs: []
  type: TYPE_NORMAL
- en: Piping data to a writable stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pipe` method is used to connect a `Readable` stream to a `Writeable` stream,
    ensuring that all of the data is read from the `Readable` and written to the `Writable`
    without further intervention, as shown in *Listing 6.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.16: Piping Data into the readHandler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest way to transfer data between streams, and the `end` method
    is called automatically on the `Writeable` stream once all of the data has been
    transferred. Use a browser to request `http://localhost:5000` and click the **Send
    Request** button. The data that is sent in the HTTP request is piped to the HTTP
    response and displayed in the browser window, as shown in *Figure 6.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Piping data'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Transform` class is used to create objects, known as *transformers*, that
    receive data from a `Readable` stream, process it in some way, and then pass it
    on. Transformers are applied to streams with the `pipe` method, as shown in *Listing
    6.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.17: Creating a Transformer in the readHandler.ts File in the src
    Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument to the `Transform` constructor is an object whose `transform`
    property value is a function that will be invoked when there is data to process.
    The function receives three arguments: a chunk of data to process, which can be
    of any data type, a string encoding type, and a callback function that is used
    to pass on the transformed data. In this example, the data that is received is
    converted to a string on which the `toLowerCase` method is called. The result
    is passed to the callback function, whose arguments are an object that represents
    any error that has occurred and the transformed data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The transformer is applied with the `pipe` method and, in this case, is chained
    so that the data read from the HTTP request is transformed and then written to
    the HTTP response. Note that a new `Transform` object must be created for every
    request, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, and click on the **Send Request**
    button. The content displayed by the browser, which comes from the HTTP response
    body, is all lowercase, as shown in *Figure 6.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Using a simple transformer'
  prefs: []
  type: TYPE_NORMAL
- en: Using object mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The streams created by the Node.js API, such as the ones used for HTTP requests
    or files, work only on strings and byte arrays. This isn’t always convenient,
    and so some streams, including transformers, can use *object mode*, which allows
    objects to be read or written. To prepare for this example, *Listing 6.18* updates
    the JavaScript code contained within the static HTML file to send a request containing
    an array of JSON-formatted objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.18: Sending a JSON Request Body in the index.html File in the static
    Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The data sent by the client can still be read as a string or a byte array, but
    a transform can be used to convert the request payload into a JavaScript object
    or convert a JavaScript object into a string or byte array, known as *object mode*.
    Two `Transform` constructor configuration settings are used to tell Node.js how
    a transformer will behave, as described in *Table 6.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.8: The Transform Constructor Configuration Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `readableObjectMode` | When set to `true`, the transformer will consume string/byte
    data and produce an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `writableObjectMode` | When set to `true`, the transformer will consume an
    object and produce string/byte data. |'
  prefs: []
  type: TYPE_TB
- en: '*Listing 6.19* shows a transformer that sets the `readableObjectMode` setting
    to `true`, which means that it will read string data from the HTTP request payload
    but produce a JavaScript object when its data is read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.19: Parsing JSON in the readHandler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the HTTP request has a `Content-Type` header that indicates the payload is
    JSON, then the transformer is used to parse the data, which is received by the
    request handler using the `data` event. The parsed payload is checked to see if
    it is an array, and if it is, then its length is used to generate a response.
    Use a browser to request `http://localhost:5000` (or make sure to reload the browser
    so that the changes in *Listing 6.18* take effect), click the **Send Request**
    button, and you will see the response shown in *Figure 6.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Using a transformer in object mode'
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sections that follow, I describe useful enhancements provided by the
    Express package to deal with streams and tasks that are related to HTTP. Express
    isn’t the only package that provides these kinds of features, but it is a good
    default choice for new projects and gives you a foundation from which to compare
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important tasks for a web server is to respond to requests for
    files, which provide browsers with the HTML, JavaScript, and other static content
    required by the client-side part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js provides a comprehensive API to deal with files in the `fs` module,
    and it has support for reading and writing streams, along with convenience features
    that read or write complete files, such as the `readFileSync` function I used
    to read the contents of an HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I have not described the API in any detail is that working directly
    with files within a web server project is incredibly dangerous and should be avoided
    whenever possible. There is a huge scope to create malicious requests whose paths
    attempt to access files outside of the expected locations, for example. And, through
    personal experience, I have learned not to let clients create or modify files
    on the server under any circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: I have worked on too many projects where malicious requests have been able to
    overwrite system files or simply overwhelm servers by writing so much data that
    storage space is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to deal with files is to use a well-tested package, rather than
    write custom code, and it is for this reason that I have not described the features
    of the `fs` module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to ignore my warning, then you can find details of the `fs` module
    and the features it provides at [https://nodejs.org/dist/latest-v20.x/docs/api/fs.html](https://nodejs.org/dist/latest-v20.x/docs/api/fs.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Express package has integrated support to serve requests for files. To prepare,
    add a file named `client.js` to the `static` folder with the content shown in
    *Listing 6.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.20: The Contents of the client.js File in the static Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is the same JavaScript code used in earlier examples but put into a separate
    file, which is the typical way of distributing JavaScript to clients. *Listing
    6.21* updates the HTML file to link to the new JavaScript file, and it also includes
    the image file that was added to the project at the start of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.21: Changing Content in the index.html File in the static Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Having prepared the content, the next step is to configure Express to serve
    the files. Express comes with support for middleware components, which just means
    request handlers that can inspect and intercept all the HTTP requests the server
    receives. Middleware components are set up with the `use` method, and *Listing
    6.22* sets up the middleware component that Express provides to serve files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.22: Adding Support for Static Files in the server.ts File in the
    src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `express` object, which is the default export from the `express` module,
    defines a method named `static` that creates the middleware component that serves
    static files. The argument to the `static` method is the directory that contains
    the files, which is also named `static`. The result is a request handler that
    can be registered with the `Express.use` method.
  prefs: []
  type: TYPE_NORMAL
- en: The middleware component will attempt to match request URLs to files in the
    `static` directory. The name of the directory that contains the files is omitted
    from the URLs, so a request for `http://localhost:5000/client.js`, for example,
    will be handled by returning the contents of the `client.js` file in the `static`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` method can accept a configuration object, but the default values
    are well-chosen and suit most projects, including using the `index.html` as the
    default for requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to change the settings, you can see the options at [https://expressjs.com/en/4x/api.html#express.static](https://expressjs.com/en/4x/api.html#express.static).
  prefs: []
  type: TYPE_NORMAL
- en: The middleware component sets the response headers to help the client process
    the contents of the files that are used. This includes setting the `Content-Length`
    header to specify the amount of data the file contains, and the `Content-Type`
    header to specify the type of data.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I can remove some of the existing handlers from the example. The
    handler for `favicon.ico` requests is no longer required because the new middleware
    will automatically generate “not found” responses when requests ask for files
    that don’t exist. The catch-all route is no longer required because the `static`
    middleware responds to requests with the contents of the `index.html` file. Use
    a browser to request `http://localhost:5000`, and you will see the response shown
    in *Figure 6.9*, which also shows the data types that the browser has received.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Using the Express static middleware'
  prefs: []
  type: TYPE_NORMAL
- en: Serving files from client-side packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One source of static files is packages that are added to the Node.js project,
    but whose files are intended for consumption by browsers (or other HTTP clients).
    A good example is the Bootstrap CSS package, which contains CSS stylesheets and
    JavaScript files that are used to style the HTML content displayed by browsers.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a client-side framework such as Angular or React, these CSS
    and JavaScript files will be incorporated into a single compressed file as part
    of the project build process.
  prefs: []
  type: TYPE_NORMAL
- en: For projects that don’t use these frameworks, the simplest way to make the files
    available is to set up additional instances of the static file middleware. To
    prepare, run the command shown in *Listing 6.23* in the `webapp` folder to add
    the Bootstrap package to the example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.23: Adding a Package to the Example Project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6.24* configures Express to serve files from the package directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.24\. Adding Middleware in the server.ts File in the src Folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Some knowledge of the packages you are using is required. In the case of the
    Bootstrap package, I know that the files used by clients are in the `dist` folder,
    and so this is the folder that I specified when setting up the middleware clients.
    The final step is to add a reference to a Bootstrap stylesheet and apply the styles
    it contains, as shown in *Listing 6.25*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.25\. Adding a Stylesheet Reference in the index.html File in the static
    Folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `bootstrap.min.css` file contains the styles I want to use, which are applied
    by adding the `button` element to classes. Use a browser to request `http://localhost:5000`,
    and you will see the effect of the styles, as shown in *Figure 6.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: See [https://getbootstrap.com](https://getbootstrap.com) for details of the
    features the Bootstrap package provides, some of which I use in later chapters.
    There are other CSS packages available if you can’t get along with Bootstrap.
    A popular alternative is Tailwind ([https://tailwindcss.com](https://tailwindcss.com)),
    but a quick web search will present you with a long list of alternatives to consider.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Using static content from a third-party package'
  prefs: []
  type: TYPE_NORMAL
- en: Sending and downloading files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Response` class, through which Express provides `ServerResponse` enhancements,
    defines the methods described in *Table 6.9* to deal with files directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.9: Useful Response Methods for Files'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `sendFile(path, config)` | This method sends the contents of the specified
    file. The response `Content-Type` header is set based on the file extension. |'
  prefs: []
  type: TYPE_TB
- en: '| `download(path)` | This method sends the contents of the specified file such
    that most browsers will prompt the user to save the file. |'
  prefs: []
  type: TYPE_TB
- en: The `sendFile` and `download` methods are useful because they provide solutions
    to problems that cannot be solved using the `static` middleware. *Listing 6.26*
    creates simple routes that use these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.26: Adding Routes in the server.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `sendFile` method is useful when you need to respond with the content of
    a file but the request path doesn’t contain the filename. The arguments are the
    name of the file and a configuration object, whose root property specifies the
    directory that contains the file.
  prefs: []
  type: TYPE_NORMAL
- en: The `download` method sets the `Content-Disposition` response header, which
    causes most browsers to treat the file contents as a download that should be saved.
    Use a browser to request `http://localhost:5000/sendcity` and `http://localhost:5000/downloadcity`.
    The first URL will cause the browser to display the image in the browser window.
    The second URL will prompt the user to save the file. Both responses are shown
    in *Figure 6.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Using the file response enhancements'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically decoding and encoding JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Express package includes a middleware component that decodes JSON response
    bodies automatically, performing the same task as the stream transformer I created
    earlier in the chapter. *Listing 6.27* enables this middleware by calling the
    `json` method defined on the default export from the `express` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.27: Enabling JSON Middleware in the server.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The middleware component must be registered before the routes that read response
    bodies so that JSON requests are parsed before they are matched to a handler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `json` method can accept a configuration object that changes the way that
    JSON is parsed. The defaults are suitable for most projects, but see [https://expressjs.com/en/4x/api.html#express.json](https://expressjs.com/en/4x/api.html#express.json)
    for details of the available options.
  prefs: []
  type: TYPE_NORMAL
- en: The `Request` class through which Express provides enhancements to the `IncomingRequest`
    class defines a `body` property, which is assigned the object created by the JSON
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` body, which provides `ServerResponse` enhancements, defines the
    `json` method, which accepts an object that is serialized to JSON and used as
    the response body.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6.28* updates the handler to use the `Request` class, disables the
    custom transformer, and sends a JSON response to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 6.28: Using the JSON Object in the readHandler.ts File in the src Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Use a web browser to request `http://localhost:5000`, and click the **Send Request**
    button. The response will confirm that the JSON request body was parsed into a
    JavaScript array and the response was sent back as JSON as well, as shown in *Figure
    6.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Using the Express JSON middleware'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I described the API features that Node.js provides to read
    and write data, particularly when processing an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: Streams are used as abstract representations of sources and destinations for
    data, including HTTP requests and responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is buffered when it is written to a stream, but it is a good idea to avoid
    excessive buffering because it can exhaust system resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be read from a stream by handling events or using a `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be piped from a readable stream to a writable stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be transformed as it is piped and can be between JavaScript objects
    and strings/byte arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js provides an API to work with files, but third-party packages are the
    safest way to work with files in a web server project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages, such as Express, provide enhancements to the Node.js streams
    to perform common tasks, such as decoding JSON data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I describe two aspects of web development in which Node.js
    works together with other components to deliver an application.
  prefs: []
  type: TYPE_NORMAL
