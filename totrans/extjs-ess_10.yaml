- en: Chapter 10. Guaranteeing Your Code's Quality with Unit and UI Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章.通过单元和UI测试确保代码质量
- en: Being confident in our code's quality and functionality is of utmost importance
    when we come to add new features, refactor existing features, and ultimately,
    ship our product.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加新功能、重构现有功能以及最终发布产品时，对我们的代码质量和功能充满信心是至关重要的。
- en: Without any process in place to automatically check our code, we will always
    be nervous about the impact our changes will have on the rest of the application.
    The time between bugs being introduced and them being discovered is extended,
    resulting in the cost of resolving them rising dramatically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有自动检查我们代码的流程，我们总会担心我们的更改会对应用程序的其他部分产生什么影响。引入错误和发现错误之间的时间延长，导致解决它们的成本大幅上升。
- en: 'This chapter will focus on how we can ensure that our code is of a high standard
    and that it functions as it should at all times. We will explore the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍我们如何确保我们的代码具有高标准，并且始终按预期工作。我们将探讨以下主题：
- en: Best practices for writing testable JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试JavaScript的最佳实践
- en: Development approaches that will put testing front and center
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试置于开发流程核心的开发方法
- en: Introduction to the Siesta testing framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Siesta测试框架简介
- en: How to write unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写单元测试
- en: How to write UI tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写UI测试
- en: How to integrate testing into the development workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将测试集成到开发工作流程中
- en: Writing testable JavaScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可测试的JavaScript
- en: JavaScript has always been a language that has been difficult to test. This
    has largely been down to the unstructured nature in which it was used and the
    tendency to sprinkle it into pages to add small effects and pieces of functionality.
    This meant that isolating small sections of code to test them was extremely difficult
    and so, it tended to just not be done.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript一直是一种难以测试的语言。这很大程度上是由于它被使用的非结构化性质以及将其撒入页面以添加小效果和功能片段的倾向。这意味着隔离小段代码以进行测试变得极其困难，因此，往往根本不进行测试。
- en: These days, JavaScript is used to write serious applications, and developers
    are building upon frameworks, such as Ext JS, to introduce a more rigid architecture
    to their projects. This structure makes testing units of functionality much easier
    and gives us much simpler scenarios to work with and construct tests around.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript被用来编写严肃的应用程序，开发者正在基于框架，如Ext JS，为他们的项目引入更严格的架构。这种结构使得测试功能单元变得更加容易，并为我们提供了更简单的场景来工作和构建测试。
- en: Although by writing an application using Ext JS you have already taken a big
    step towards more testable code, there are some good practices to follow to ensure
    things are even easier, which we will explore in this section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用Ext JS编写应用程序已经使你朝着更可测试的代码迈出了重要一步，但还有一些良好的实践需要遵循，以确保事情更加简单，我们将在本节中探讨这些内容。
- en: Single responsibility
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责
- en: By ensuring that your classes and methods are only responsible for a single
    piece of functionality, means that testing that functionality is much easier as
    the inputs and outputs are much more clear-cut.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保你的类和方法只负责单一的功能部分，意味着测试该功能变得更加容易，因为输入和输出更加清晰。
- en: For example, having a method that, on a button click, will update three parts
    of your application in one big method will be complex to test. To test that single
    method, we would need to have all three areas available and check for the appropriate
    result in each.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个方法，在按钮点击时，将更新应用程序的三个部分，这个方法将非常复杂。为了测试这个单一的方法，我们需要所有三个区域都可用，并在每个区域检查适当的结果。
- en: If we extracted this into three separate methods, we could test each in isolation
    and concentrate on that function and its results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些提取为三个独立的方法，我们就可以单独测试每个方法，并专注于该函数及其结果。
- en: Accessible code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问的代码
- en: If a function in our code base is **private** (that is, inaccessible to outside
    code via a closure, for example) then we will be unable to test it or mock it.
    This approach makes it impossible to test these private functions and very difficult
    to test methods that rely on them as they may need to be mocked.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码库中的函数是**私有的**（即，例如，通过闭包无法从外部代码访问），那么我们将无法测试它或模拟它。这种方法使得测试这些私有函数变得不可能，并且测试依赖于它们的函数变得非常困难，因为它们可能需要被模拟。
- en: It is therefore, sometimes necessary to make these private functions publicly
    accessible to aid testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时有必要将这些私有函数公开化，以帮助测试。
- en: Nested callbacks
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套回调
- en: 'Deeply nested callback functions are extremely difficult to test as they are
    all private and rely on lots of conditions to align to exercise them all. This
    relates closely to the previous point of making code accessible. Rather than nesting
    lots of callbacks, consider extracting them into member functions. The following
    example shows how the functions handling the `async` calls can''t be tested:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 深层嵌套的回调函数非常难以测试，因为它们都是私有的，并且依赖于许多条件来对它们进行测试。这与之前提到的使代码可访问性的观点密切相关。与其嵌套大量的回调，不如考虑将它们提取到成员函数中。以下示例展示了处理
    `async` 调用的函数无法进行测试：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This could be refactored to use member functions that can all be tested individually.
    In addition, the code is much cleaner and avoids lots of nested callbacks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用可以单独测试的成员函数来重构。此外，代码更加整洁，避免了大量的嵌套回调。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Separate event handlers from actions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事件处理程序与操作分离
- en: 'When attaching functionality to an event, we often carry out the action within
    the same function. The following example shows a button click handler that makes
    an AJAX request to delete a user, based on the selected row in a grid:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当将功能附加到事件时，我们通常在同一个函数内执行操作。以下示例展示了按钮点击处理程序，它基于网格中选定的行向用户发送删除请求：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The problem with this code is that to test deleting a user, we need to have
    a grid available and a row selected, which is cumbersome to set up. What would
    be better is to extract the action from the handler so that the action can be
    tested without the need for the setup code. It also has the added benefit of being
    able to be executed from a different context; for example, from a delete key handler.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，为了测试删除用户，我们需要有一个网格和一个选定的行可用，这设置起来很麻烦。更好的做法是从处理程序中提取操作，这样就可以在不需要设置代码的情况下测试操作。这还有一个额外的优点，即可以从不同的上下文中执行；例如，从删除键处理程序中执行。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Testing frameworks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试框架
- en: There are a large number of JavaScript testing frameworks which would all work
    well with Ext JS applications. They each offer different ways of doing things
    and a different feature set. We will discuss Jasmine ([http://jasmine.github.io/](http://jasmine.github.io/))
    and Siesta ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/))
    in this section, and move on to explain Siesta in detail in subsequent sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 JavaScript 测试框架都可以很好地与 Ext JS 应用程序一起工作。它们各自提供了不同的做事方式和不同的功能集。在本节中，我们将讨论
    Jasmine ([http://jasmine.github.io/](http://jasmine.github.io/)) 和 Siesta ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/))，并在后续章节中详细解释
    Siesta。
- en: Jasmine
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine
- en: Jasmine is a simple, free, BDD-style framework which is widely used across the
    industry, including Sencha, to develop Ext JS and Sencha Touch.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个简单、免费、BDD 风格的框架，在业界广泛使用，包括 Sencha，用于开发 Ext JS 和 Sencha Touch。
- en: 'This framework takes a very descriptive approach to outlining tests:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架在概述测试时采用了一种非常描述性的方法：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Test suites and specs are just simple functions which should execute the test
    code and then assert whether the outcome was correct.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件和规范只是简单的函数，它们应该执行测试代码，然后断言结果是否正确。
- en: The `describe` method lets us define a test suite, which can include multiple
    specs (or indeed nested test suites). Specs are defined with the `it` method,
    which accepts a description of the spec and a function that forms the test. Within
    this function, our test is set up and executed, and its results analyzed to ensure
    the correct result was achieved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 方法让我们定义一个测试套件，它可以包括多个规范（或实际上嵌套的测试套件）。规范是通过 `it` 方法定义的，它接受规范的描述和一个形成测试的函数。在这个函数中，我们设置并执行测试，并分析其结果以确保达到了正确的结果。'
- en: Jasmine has a test harness page which executes all of the included test suites
    and displays the results. It can also be executed headlessly with a tool such
    as PhantomJS. This makes it perfect to integrate with your CI process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 有一个测试 harness 页面，它执行所有包含的测试套件并显示结果。它也可以使用像 PhantomJS 这样的工具无头执行。这使得它非常适合与
    CI 流程集成。
- en: Siesta
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Siesta
- en: Siesta is a powerful testing framework which is focused on testing Ext JS and
    Sencha Touch applications. It allows us to write unit and UI tests for our applications,
    also boasting a powerful event recorder built in to record and test interactions
    with specific UI elements. Having a Sencha slant means it has helper methods to
    assist testing of common components and also supports Sencha style constructs,
    such as Component Queries and `Ext.Loader`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Siesta 是一个强大的测试框架，专注于测试 Ext JS 和 Sencha Touch 应用程序。它允许我们为我们的应用程序编写单元和 UI 测试，还内置了一个强大的事件记录器，用于记录和测试与特定
    UI 元素的交互。由于有 Sencha 的倾向，它还提供了辅助方法来帮助测试常见组件，并支持 Sencha 风格构造，如组件查询和 `Ext.Loader`。
- en: This Sencha focus makes Siesta perfect for testing Ext JS applications and makes
    tasks much simpler because of its knowledge of the framework. An added bonus is
    that it is written with Ext JS and tested using itself, so developers are using
    their product in anger everyday giving this framework a high degree of developer
    focus.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 Sencha 专注使 Siesta 成为测试 Ext JS 应用程序的理想选择，因为它对框架的了解，使得任务变得更加简单。一个额外的优势是，它是用
    Ext JS 编写的，并使用自身进行测试，因此开发者每天都在使用他们的产品，这为这个框架提供了高度的开发者关注。
- en: 'Siesta allows you to include multiple specs in a single suite with each spec
    testing an area of your application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Siesta 允许您在一个测试套件中包含多个规范，每个规范测试应用程序的一个区域：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function passed to `StartTest` contains all of the test logic, including
    the test steps and the assertions. The object `t` passed into this function gives
    us access to a large number of assertion methods which we will explore later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `StartTest` 的函数包含所有测试逻辑，包括测试步骤和断言。传递给此函数的对象 `t` 给我们提供了访问大量断言方法的权限，我们将在稍后探讨。
- en: We recommend using Siesta as your testing framework because of its close integration
    with Ext JS, which makes it extremely easy to implement tests quickly and effectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用 Siesta 作为您的测试框架，因为它与 Ext JS 的紧密集成，这使得快速有效地实施测试变得极其容易。
- en: Writing unit tests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'Siesta allows us to create unit test suites which allow us to exercise non-UI
    logic. We will write some simple tests for our `BizDash.config.Config` class to
    test its methods. A slightly cut down version of this class is shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Siesta 允许我们创建单元测试套件，这使我们能够测试非 UI 逻辑。我们将为 `BizDash.config.Config` 类编写一些简单的测试来测试其方法。这个类的简化版本如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Testing project structure
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试项目结构
- en: We will start by adding the Siesta framework files to our project folder; these
    can be downloaded from the Siesta website ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将 Siesta 框架文件添加到我们的项目文件夹中；这些可以从 Siesta 网站下载（[http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/))。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Siesta offers a Lite version, which can be used for free but is limited in its
    feature set. The standard license gives you access to extra features and support.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Siesta 提供了一个 Lite 版本，可以免费使用，但功能有限。标准许可证则为您提供了访问额外功能和支持的权利。
- en: 'We then create a tests folder where we will keep our test suites. Our folder
    structure should look something like the following image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个测试文件夹，我们将在这里保存我们的测试套件。我们的文件夹结构应该看起来像以下图片：
- en: '![Testing project structure](img/3717_10_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![测试项目结构](img/3717_10_01.jpg)'
- en: 'Next, we will create a test suite for the `Config` class. We will mirror the
    app''s folder structure and have a folder named the same as the class being tested,
    prefixed with an underscore. In this case, we end up with the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `Config` 类创建一个测试套件。我们将模仿应用程序的文件夹结构，并创建一个与被测试的类同名但以下划线为前缀的文件夹。在这种情况下，我们最终得到以下结构：
- en: '![Testing project structure](img/3717_10_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![测试项目结构](img/3717_10_02.jpg)'
- en: By following this convention, the tests are grouped by their class and so can
    be easily navigable. This is purely a suggested structure and your test suite
    can follow an entirely different pattern if you wish.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个约定，测试会根据它们的类分组，因此可以轻松导航。这纯粹是一个建议的结构，如果你的测试套件愿意遵循完全不同的模式，也可以。
- en: Creating the test harness
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试工具
- en: To run Siesta tests, we must have a test definition script (like the one we
    created in the previous section) and an HTML page that loads the Siesta framework
    and the definition script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Siesta 测试，我们必须有一个测试定义脚本（就像我们在上一节中创建的那样）以及一个加载 Siesta 框架和定义脚本的 HTML 页面。
- en: 'Our test definition should contain the following code and be within the `index.js`
    file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试定义应该包含以下代码，并且位于 `index.js` 文件中：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first section configures Siesta with a test suite title and tells it to
    preload the built versions of our application (the ones that are created after
    running `sencha app build`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分配置Siesta测试套件标题，并告诉它预加载我们应用程序的构建版本（在运行`sencha app build`之后创建的版本）。
- en: Next, we tell the harness to start running our tests, which we will structure
    in groups. At the moment we have no tests to run, but when we do, we will reference
    the files in the `items` array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉测试工具开始运行我们的测试，我们将以组的形式结构化这些测试。目前我们没有要运行的测试，但当我们有测试时，我们将引用`items`数组中的文件。
- en: Our HTML page is extremely simple and just loads in the Siesta and Ext JS frameworks
    and our test definition script.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML页面非常简单，只是加载了Siesta和Ext JS框架以及我们的测试定义脚本。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the first test
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加第一个测试
- en: We will start by adding a test for the `getBuildNumber` method. Add a new file
    called `010_getBuildNumber.t.js`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将为`getBuildNumber`方法添加一个测试。添加一个名为`010_getBuildNumber.t.js`的新文件。
- en: The naming convention we use here is not required but is used throughout the
    Siesta documentation. The numbering allows the tests to run in a specific order,
    with the name referring to the method or feature under test. The `.t.js` extension
    is used as a way of identifying a test file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的命名约定不是必需的，但在Siesta文档中广泛使用。编号允许测试以特定顺序运行，名称指代正在测试的方法或功能。`.t.js`扩展用于识别测试文件。
- en: 'In this file, we call the `StartTest` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们调用`StartTest`方法：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we call the `getBuildNumber` method and check that the result we get
    back is correct:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`getBuildNumber`方法并检查返回的结果是否正确：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we must reference this new file in the `index.js` `items` array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在`index.js`的`items`数组中引用这个新文件：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Executing tests
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'To run our tests, we simply open `index.html` in our browser and click the
    **Run All** button at the bottom left of the screen. Siesta will then execute
    each test listed and display the results as seen in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，我们只需在浏览器中打开`index.html`，然后点击屏幕左下角的**运行所有**按钮。Siesta将执行列出的每个测试并显示结果，如下面的截图所示：
- en: '![Executing tests](img/3717_10_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![执行测试](img/3717_10_03.jpg)'
- en: Extending tests
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展测试
- en: We can add as many assertions and tests to this initial file as we wish, but
    it is often wise to put different test types in different files to keep things
    organized and to ensure a clean environment, unsullied by previous tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加尽可能多的断言和测试到这个初始文件中，但通常将不同的测试类型放在不同的文件中是明智的，以保持事物有序并确保一个干净的环境，不受先前测试的污染。
- en: We will now add some new test files to test some edge cases. Each of these files
    should be added to the `index.js` file, so they are included in test runs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一些新的测试文件来测试一些边缘情况。每个这些文件都应该添加到`index.js`文件中，以便它们包含在测试运行中。
- en: 'Our next spec, `020_getBuildNumber_emptyString.t.js`, will test the output
    when the version number is set to an empty string. We use the `toBeUndefined`
    method to check the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个规范`020_getBuildNumber_emptyString.t.js`将测试当版本号设置为空字符串时的输出。我们使用`toBeUndefined`方法来检查输出：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will use our poor implementation of the `getBuildNumber` method
    to demonstrate how to test that a method should throw an exception when the `version`
    config is null. To do this, we use the `toThrow` assertion, passing to it the
    method to test:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用我们糟糕的`getBuildNumber`方法实现来演示如何测试当`version`配置为null时，方法应该抛出异常。为此，我们使用`toThrow`断言，并将要测试的方法传递给它：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The framework will automatically call the method we pass into `expect` and pass
    the test if it throws an exception.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 框架将自动调用我们传递给`expect`的方法，如果它抛出异常，则通过测试。
- en: Testing UI interaction
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试UI交互
- en: One of the big benefits of Siesta is its ability to test real UI interactions,
    allowing us to create automated, repeatable tests, based on the way the application
    is actually rendered and how a real user would interact with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Siesta的一个主要优点是它能够测试真实的UI交互，允许我们创建基于应用程序实际渲染方式和真实用户如何与之交互的自动化、可重复的测试。
- en: In this section, we will test the product grid that we created in [Chapter 7](ch07.html
    "Chapter 7. Constructing Common UI Widgets"), *Constructing Common UI Widgets*.
    We will look at testing how it has been rendered and then move on to testing clicks
    on the grid row's **Details** button.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试我们在[第7章](ch07.html "第7章。构建常用UI小部件")中创建的产品网格，*构建常用UI小部件*。我们将查看测试其渲染方式，然后继续测试网格行上的**详情**按钮的点击。
- en: Testing cell contents
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试单元格内容
- en: To kick off, we are going to test whether each cell of the grid renders the
    correct values based on the data in the store it is bound to. This will catch
    any issues with field names changing and grid column configurations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试每个单元格是否根据其绑定的存储中的数据渲染正确的值。这将捕获字段名称更改和网格列配置中的任何问题。
- en: 'We start by creating a new test suite, like we did in the previous section,
    and a new test file called `010_GridCellContents.t.js`. Our folder structure will
    look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的测试套件，就像我们在上一节中做的那样，并创建一个名为`010_GridCellContents.t.js`的新测试文件。我们的文件夹结构将如下所示：
- en: '![Testing cell contents](img/3717_10_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![测试单元格内容](img/3717_10_04.jpg)'
- en: Be careful to update all the paths in your `index.html` and `index.js` files
    to suit the new location.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意更新你的`index.html`和`index.js`文件中的所有路径，以适应新的位置。
- en: In these test suites, we will include the entire `app.js` file, which means
    the application will be launched as it would be if you opened it in the browser.
    This means we can interact with the UI straightaway.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些测试套件中，我们将包括整个`app.js`文件，这意味着应用程序将以你打开浏览器时的方式启动。这意味着我们可以立即与UI交互。
- en: If you expand the DOM panel on the right-hand side of the Siesta interface,
    it will display the UI as it appears during the test. If you watch this area when
    tests are running, you will see the interactions happening in real time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开Siesta界面右侧的DOM面板，它将显示测试期间出现的UI。如果你在测试运行时观察此区域，你将看到实时发生的交互。
- en: Setting up expected data
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置预期数据
- en: 'It is important that we know what data our grid is rendering, so we can check
    whether it is correct. For that reason, our first step is to populate our products''
    store with known test data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的网格正在渲染什么数据非常重要，这样我们就可以检查它是否正确。因此，我们的第一步是将已知测试数据填充到我们的产品存储中：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Checking cell contents
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查单元格内容
- en: Now we can use the built-in `matchGridCellContent` method available to us via
    the `t` parameter. This method accepts a grid instance (or Component Query to
    find one), the cell row and column, the value expected, and a description of the
    test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用通过`t`参数提供的内置`matchGridCellContent`方法。此方法接受一个网格实例（或用于找到它的组件查询），单元格行和列，预期的值以及测试的描述。
- en: 'We can add a test to check whether the first column (containing the product''s
    name) has the correct value, based on the data we added into our store:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个测试来检查第一列（包含产品名称）是否具有正确的值，基于我们添加到我们存储中的数据：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Simulating clicks
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟点击
- en: 'Next, we will test the product editing process following a click on one of
    the grid row''s **Details** button. We want to test after this interaction, whether:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试在点击网格行中的一个“详情”按钮后的产品编辑过程。我们希望在这次交互之后测试以下内容：
- en: A new product form is created and shown
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并显示一个新的产品表单
- en: The form is populated with the correct record details
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单已填充正确的记录详情
- en: The grid is updated in real time after editing the `Name` field
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑“名称”字段后，网格实时更新
- en: The form is hidden and the record committed after clicking on the **Save** button
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“保存”按钮后，表单被隐藏并提交记录
- en: We start by creating a new test file (`020_ProductEdit.t.js`) and including
    the same initial store population code as we did in the last section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的测试文件（`020_ProductEdit.t.js`），并包含与上一节中相同的初始存储填充代码。
- en: 'Now, we need to get a reference to the cell that holds the `Details` button.
    We do this using the `getCell` method, passing it a Component Query to find the
    grid and the row/cell indexes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要获取包含“详情”按钮的单元格的引用。我们通过使用`getCell`方法来实现，传递给它一个组件查询以找到网格和行/单元格索引：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For this test, we are going to perform multiple actions in sequence which may
    be asynchronous. We could use callback methods to chain these items, but instead,
    we will use the chain method which makes this process much easier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将按顺序执行多个操作，这些操作可能是异步的。我们可以使用回调方法来链接这些项，但我们将使用链式方法，这使得这个过程更容易。
- en: 'First, we will instigate a click on the cell and then confirm that a `ProductForm`
    component has been created. We do this using the `cqExists` (Component Query exists)
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将引发对单元格的点击，然后确认已创建了一个`ProductForm`组件。我们使用`cqExists`（组件查询存在）方法来完成此操作：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each function we pass to the `chain` method is passed a `next` method that should
    be called at the end, so that the next item in the chain is then executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`chain`方法的每个函数都传递一个`next`方法，应在链的末尾调用此方法，以便执行链中的下一个项。
- en: 'We now want to check if the form has been populated with the correct values
    from the chosen record. First, we add a small pause of 10 milliseconds in the
    chain to allow the form time to populate, and then we call the `fieldHasValue`
    method for each field. We pass it in a Component Query to find the desired field,
    the value we expect it to have, and a description of the test:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要检查表单是否已从所选记录中填充了正确的值。首先，我们在链中添加一个10毫秒的小暂停，以便让表单有时间填充，然后我们为每个字段调用`fieldHasValue`方法。我们通过组件查询传递给它，以找到所需的字段，我们期望它拥有的值，以及测试的描述：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step we want to test is what happens when one of the fields is updated.
    To do this, we add another step to our chain and update the `Name` field. We then
    check whether the grid has updated accordingly and that the model instance is
    now marked as dirty (that is, it has a change waiting to be committed):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们想要测试的是当一个字段被更新时会发生什么。为此，我们在链中添加另一个步骤并更新`名称`字段。然后我们检查网格是否相应更新，并且模型实例现在被标记为脏（即，有一个等待提交的更改）：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we test the save process. We simulate a click on the `Save` button
    and test that the product form is closed and the changes to the record are committed.
    Finally, we call the done method to tell the harness that our tests are complete:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试保存过程。我们模拟点击`保存`按钮并测试产品表单是否已关闭，并且记录的更改已被提交。最后，我们调用done方法来告诉测试框架我们的测试已完成：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `>>` prefixed should be used to denote a Component Query string. If omitted,
    the query will be interpreted as a CSS style selector.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀`>>`应用于表示组件查询字符串。如果省略，查询将被解释为CSS样式选择器。
- en: Event recorder
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件记录器
- en: In the preceding example, we have performed very simple steps in our tests.
    However, hand coding all of the Component Queries for each button and the order
    of the interactions can get cumbersome. Siesta Standard features an event recorder
    that allows us to record a series of interactions and generate the code required
    to include these steps in a test. It is worth noting that this code is rarely
    used "as-is"; instead, it is usually modified and enhanced before being added
    to a test script.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在测试中执行了非常简单的步骤。然而，为每个按钮和交互顺序手动编码所有组件查询可能会变得繁琐。Siesta Standard提供了一个事件记录器，允许我们记录一系列交互并生成将这些步骤包含在测试中所需的代码。值得注意的是，此代码很少“原样”使用；相反，它通常在添加到测试脚本之前进行修改和增强。
- en: 'To launch the event recorder, click the video camera icon in the test results
    window, which will show an empty list of steps, as seen in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动事件记录器，请点击测试结果窗口中的视频摄像头图标，这将显示一个空的步骤列表，如下截图所示：
- en: '![Event recorder](img/3717_10_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![事件记录器](img/3717_10_05.jpg)'
- en: We will use the event recorder to test the cancel process of the product form.
    We start by running the `ProductEdit` test so that we have an interface to interact
    with and record against. We then click the record button (the small red circle)
    and start interacting with the interface in the DOM panel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用事件记录器来测试产品表单的取消过程。我们首先运行`ProductEdit`测试，以便我们有一个可以与之交互并记录的界面。然后我们点击记录按钮（小红色圆圈）并开始与DOM面板中的界面进行交互。
- en: 'We will perform the following actions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下操作：
- en: Click on the **Details** button.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**详情**按钮。
- en: Edit the **Name** field in the product form.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑产品表单中的**名称**字段。
- en: Click on the **Cancel** button.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**取消**按钮。
- en: Once we do these, we will click on the stop button and the steps will populate
    the grid.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成这些后，将点击停止按钮，步骤将填充到网格中。
- en: '![Event recorder](img/3717_10_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![事件记录器](img/3717_10_06.jpg)'
- en: You will see each action shown as a row with the action type, the target of
    the action (in this case the Component Query used to target the element or the
    text typed), and the offset of the action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到每个动作都显示为一行，包括动作类型、动作的目标（在这种情况下是用于定位元素的组件查询或输入的文本），以及动作的偏移量。
- en: If you would like to alter the target used, you can click on the cell and choose
    a different query from the given list, or modify it manually.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改目标，你可以点击单元格并从提供的列表中选择不同的查询，或者手动修改它。
- en: Once you are happy with the steps, you can generate the code to include in the
    test spec. Simply click on the **Generate Code** button and the code will be displayed,
    which can be copied and pasted into our test file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对步骤满意，你可以生成要包含在测试规范中的代码。只需点击**生成代码**按钮，代码就会显示出来，可以复制并粘贴到我们的测试文件中。
- en: The output of the recorder generally uses the more condensed, declarative syntax
    for chain steps. Both are perfectly valid and result in the same outcome.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器的输出通常使用更简洁、声明性的语法来表示链式步骤。这两种语法都是完全有效的，并且会产生相同的结果。
- en: In most cases, this is enough to get us started, and we can add more steps to
    the chain which will check for the right outcome after each action.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这足以让我们开始，并且我们可以向链中添加更多步骤，这些步骤将在每个动作之后检查正确的结果。
- en: 'Taking our example, we may construct the following test assertions around the
    recorded steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的例子为例，我们可以在记录的步骤周围构建以下测试断言：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Test automation and integration
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化和集成
- en: So far, we have only run our Siesta unit tests in a browser using the Siesta
    interface, which is great for development. However, we will generally want to
    run these tests as part of an automated build process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用Siesta界面在浏览器中运行了我们的Siesta单元测试，这对于开发来说非常好。然而，我们通常希望将这些测试作为自动化构建过程的一部分来运行。
- en: We can very easily run our test suites from a command line using PhantomJS or
    WebDriver. We will now demonstrate how to use WebDriver to run cross-browser tests
    from the command line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地从命令行使用PhantomJS或WebDriver运行我们的测试套件。现在我们将演示如何使用WebDriver从命令行运行跨浏览器测试。
- en: 'WebDriver is a tool that allows cross-browser test automation and comes bundled
    with Siesta, making it extremely easy to get it working. In their simplest form,
    we can run the tests we have just created, which must be available from a server
    or localhost, in Google Chrome using the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver是一个允许跨浏览器测试自动化的工具，它随Siesta一起打包，使得它非常容易工作。在其最简单的形式中，我们可以运行我们刚刚创建的测试，这些测试必须可以从服务器或本地主机访问，并在Google
    Chrome中使用以下代码运行：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By executing this code from our root project directory, an instance of Google
    Chrome will be launched, the tests run, and the outcome is printed in the Terminal/Command
    Prompt window.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从我们的根项目目录执行此代码，将启动一个Google Chrome实例，运行测试，并在终端/命令提示符窗口中打印结果。
- en: '![Test automation and integration](img/3717_10_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![测试自动化和集成](img/3717_10_07.jpg)'
- en: You can extend this to include FireFox, Safari, Chrome, and Internet Explorer
    by using the `--browser=*` option. This will open each browser in turn and execute
    the tests—perfect for cross-browser testing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`--browser=*`选项将其扩展到包括FireFox、Safari、Chrome和Internet Explorer。这将依次打开每个浏览器并执行测试——非常适合跨浏览器测试。
- en: Test reports
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试报告
- en: It is also possible to generate a test report after each run that you can include
    in your build assets, for example. To do this, we include the `--report-format=json
    and --report-file=BuildReport.json` options at the end of our command, to save
    a JSON version of our test results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行后，也可以生成一个测试报告，例如将其包含在构建资产中。为此，我们在命令的末尾包含`--report-format=json`和`--report-file=BuildReport.json`选项，以保存测试结果的JSON版本。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has focused on how we can write better, more testable JavaScript
    code, and then moved on to how we can use testing frameworks to execute repeatable
    tests on this code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了我们如何编写更好、更可测试的JavaScript代码，然后转向如何使用测试框架来执行对代码的重复性测试。
- en: We dove into the Siesta testing framework and demonstrated how to write simple
    unit tests as well as more complex UI tests that test our applications as if users
    were interacting with them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了Siesta测试框架，并展示了如何编写简单的单元测试以及更复杂的UI测试，这些测试可以像用户与他们交互一样测试我们的应用程序。
- en: Finally, we saw how our test suites can be run to test cross-browser effectiveness
    as part of a build process from the command line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何从命令行运行我们的测试套件，以测试构建过程中的跨浏览器有效性。
