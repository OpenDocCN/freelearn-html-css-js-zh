- en: Chapter 10. Guaranteeing Your Code's Quality with Unit and UI Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being confident in our code's quality and functionality is of utmost importance
    when we come to add new features, refactor existing features, and ultimately,
    ship our product.
  prefs: []
  type: TYPE_NORMAL
- en: Without any process in place to automatically check our code, we will always
    be nervous about the impact our changes will have on the rest of the application.
    The time between bugs being introduced and them being discovered is extended,
    resulting in the cost of resolving them rising dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on how we can ensure that our code is of a high standard
    and that it functions as it should at all times. We will explore the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for writing testable JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development approaches that will put testing front and center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Siesta testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write UI tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate testing into the development workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing testable JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has always been a language that has been difficult to test. This
    has largely been down to the unstructured nature in which it was used and the
    tendency to sprinkle it into pages to add small effects and pieces of functionality.
    This meant that isolating small sections of code to test them was extremely difficult
    and so, it tended to just not be done.
  prefs: []
  type: TYPE_NORMAL
- en: These days, JavaScript is used to write serious applications, and developers
    are building upon frameworks, such as Ext JS, to introduce a more rigid architecture
    to their projects. This structure makes testing units of functionality much easier
    and gives us much simpler scenarios to work with and construct tests around.
  prefs: []
  type: TYPE_NORMAL
- en: Although by writing an application using Ext JS you have already taken a big
    step towards more testable code, there are some good practices to follow to ensure
    things are even easier, which we will explore in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By ensuring that your classes and methods are only responsible for a single
    piece of functionality, means that testing that functionality is much easier as
    the inputs and outputs are much more clear-cut.
  prefs: []
  type: TYPE_NORMAL
- en: For example, having a method that, on a button click, will update three parts
    of your application in one big method will be complex to test. To test that single
    method, we would need to have all three areas available and check for the appropriate
    result in each.
  prefs: []
  type: TYPE_NORMAL
- en: If we extracted this into three separate methods, we could test each in isolation
    and concentrate on that function and its results.
  prefs: []
  type: TYPE_NORMAL
- en: Accessible code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a function in our code base is **private** (that is, inaccessible to outside
    code via a closure, for example) then we will be unable to test it or mock it.
    This approach makes it impossible to test these private functions and very difficult
    to test methods that rely on them as they may need to be mocked.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore, sometimes necessary to make these private functions publicly
    accessible to aid testing.
  prefs: []
  type: TYPE_NORMAL
- en: Nested callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deeply nested callback functions are extremely difficult to test as they are
    all private and rely on lots of conditions to align to exercise them all. This
    relates closely to the previous point of making code accessible. Rather than nesting
    lots of callbacks, consider extracting them into member functions. The following
    example shows how the functions handling the `async` calls can''t be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This could be refactored to use member functions that can all be tested individually.
    In addition, the code is much cleaner and avoids lots of nested callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Separate event handlers from actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When attaching functionality to an event, we often carry out the action within
    the same function. The following example shows a button click handler that makes
    an AJAX request to delete a user, based on the selected row in a grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that to test deleting a user, we need to have
    a grid available and a row selected, which is cumbersome to set up. What would
    be better is to extract the action from the handler so that the action can be
    tested without the need for the setup code. It also has the added benefit of being
    able to be executed from a different context; for example, from a delete key handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a large number of JavaScript testing frameworks which would all work
    well with Ext JS applications. They each offer different ways of doing things
    and a different feature set. We will discuss Jasmine ([http://jasmine.github.io/](http://jasmine.github.io/))
    and Siesta ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/))
    in this section, and move on to explain Siesta in detail in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jasmine is a simple, free, BDD-style framework which is widely used across the
    industry, including Sencha, to develop Ext JS and Sencha Touch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This framework takes a very descriptive approach to outlining tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Test suites and specs are just simple functions which should execute the test
    code and then assert whether the outcome was correct.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe` method lets us define a test suite, which can include multiple
    specs (or indeed nested test suites). Specs are defined with the `it` method,
    which accepts a description of the spec and a function that forms the test. Within
    this function, our test is set up and executed, and its results analyzed to ensure
    the correct result was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine has a test harness page which executes all of the included test suites
    and displays the results. It can also be executed headlessly with a tool such
    as PhantomJS. This makes it perfect to integrate with your CI process.
  prefs: []
  type: TYPE_NORMAL
- en: Siesta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Siesta is a powerful testing framework which is focused on testing Ext JS and
    Sencha Touch applications. It allows us to write unit and UI tests for our applications,
    also boasting a powerful event recorder built in to record and test interactions
    with specific UI elements. Having a Sencha slant means it has helper methods to
    assist testing of common components and also supports Sencha style constructs,
    such as Component Queries and `Ext.Loader`.
  prefs: []
  type: TYPE_NORMAL
- en: This Sencha focus makes Siesta perfect for testing Ext JS applications and makes
    tasks much simpler because of its knowledge of the framework. An added bonus is
    that it is written with Ext JS and tested using itself, so developers are using
    their product in anger everyday giving this framework a high degree of developer
    focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Siesta allows you to include multiple specs in a single suite with each spec
    testing an area of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function passed to `StartTest` contains all of the test logic, including
    the test steps and the assertions. The object `t` passed into this function gives
    us access to a large number of assertion methods which we will explore later.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using Siesta as your testing framework because of its close integration
    with Ext JS, which makes it extremely easy to implement tests quickly and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Siesta allows us to create unit test suites which allow us to exercise non-UI
    logic. We will write some simple tests for our `BizDash.config.Config` class to
    test its methods. A slightly cut down version of this class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Testing project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by adding the Siesta framework files to our project folder; these
    can be downloaded from the Siesta website ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Siesta offers a Lite version, which can be used for free but is limited in its
    feature set. The standard license gives you access to extra features and support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a tests folder where we will keep our test suites. Our folder
    structure should look something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing project structure](img/3717_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create a test suite for the `Config` class. We will mirror the
    app''s folder structure and have a folder named the same as the class being tested,
    prefixed with an underscore. In this case, we end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing project structure](img/3717_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By following this convention, the tests are grouped by their class and so can
    be easily navigable. This is purely a suggested structure and your test suite
    can follow an entirely different pattern if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test harness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run Siesta tests, we must have a test definition script (like the one we
    created in the previous section) and an HTML page that loads the Siesta framework
    and the definition script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test definition should contain the following code and be within the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first section configures Siesta with a test suite title and tells it to
    preload the built versions of our application (the ones that are created after
    running `sencha app build`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we tell the harness to start running our tests, which we will structure
    in groups. At the moment we have no tests to run, but when we do, we will reference
    the files in the `items` array.
  prefs: []
  type: TYPE_NORMAL
- en: Our HTML page is extremely simple and just loads in the Siesta and Ext JS frameworks
    and our test definition script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding the first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by adding a test for the `getBuildNumber` method. Add a new file
    called `010_getBuildNumber.t.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention we use here is not required but is used throughout the
    Siesta documentation. The numbering allows the tests to run in a specific order,
    with the name referring to the method or feature under test. The `.t.js` extension
    is used as a way of identifying a test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we call the `StartTest` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `getBuildNumber` method and check that the result we get
    back is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must reference this new file in the `index.js` `items` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Executing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our tests, we simply open `index.html` in our browser and click the
    **Run All** button at the bottom left of the screen. Siesta will then execute
    each test listed and display the results as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing tests](img/3717_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extending tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add as many assertions and tests to this initial file as we wish, but
    it is often wise to put different test types in different files to keep things
    organized and to ensure a clean environment, unsullied by previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will now add some new test files to test some edge cases. Each of these files
    should be added to the `index.js` file, so they are included in test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next spec, `020_getBuildNumber_emptyString.t.js`, will test the output
    when the version number is set to an empty string. We use the `toBeUndefined`
    method to check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use our poor implementation of the `getBuildNumber` method
    to demonstrate how to test that a method should throw an exception when the `version`
    config is null. To do this, we use the `toThrow` assertion, passing to it the
    method to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The framework will automatically call the method we pass into `expect` and pass
    the test if it throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Testing UI interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the big benefits of Siesta is its ability to test real UI interactions,
    allowing us to create automated, repeatable tests, based on the way the application
    is actually rendered and how a real user would interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will test the product grid that we created in [Chapter 7](ch07.html
    "Chapter 7. Constructing Common UI Widgets"), *Constructing Common UI Widgets*.
    We will look at testing how it has been rendered and then move on to testing clicks
    on the grid row's **Details** button.
  prefs: []
  type: TYPE_NORMAL
- en: Testing cell contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To kick off, we are going to test whether each cell of the grid renders the
    correct values based on the data in the store it is bound to. This will catch
    any issues with field names changing and grid column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new test suite, like we did in the previous section,
    and a new test file called `010_GridCellContents.t.js`. Our folder structure will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing cell contents](img/3717_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be careful to update all the paths in your `index.html` and `index.js` files
    to suit the new location.
  prefs: []
  type: TYPE_NORMAL
- en: In these test suites, we will include the entire `app.js` file, which means
    the application will be launched as it would be if you opened it in the browser.
    This means we can interact with the UI straightaway.
  prefs: []
  type: TYPE_NORMAL
- en: If you expand the DOM panel on the right-hand side of the Siesta interface,
    it will display the UI as it appears during the test. If you watch this area when
    tests are running, you will see the interactions happening in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up expected data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is important that we know what data our grid is rendering, so we can check
    whether it is correct. For that reason, our first step is to populate our products''
    store with known test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Checking cell contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can use the built-in `matchGridCellContent` method available to us via
    the `t` parameter. This method accepts a grid instance (or Component Query to
    find one), the cell row and column, the value expected, and a description of the
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a test to check whether the first column (containing the product''s
    name) has the correct value, based on the data we added into our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Simulating clicks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will test the product editing process following a click on one of
    the grid row''s **Details** button. We want to test after this interaction, whether:'
  prefs: []
  type: TYPE_NORMAL
- en: A new product form is created and shown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form is populated with the correct record details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The grid is updated in real time after editing the `Name` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form is hidden and the record committed after clicking on the **Save** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start by creating a new test file (`020_ProductEdit.t.js`) and including
    the same initial store population code as we did in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to get a reference to the cell that holds the `Details` button.
    We do this using the `getCell` method, passing it a Component Query to find the
    grid and the row/cell indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For this test, we are going to perform multiple actions in sequence which may
    be asynchronous. We could use callback methods to chain these items, but instead,
    we will use the chain method which makes this process much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will instigate a click on the cell and then confirm that a `ProductForm`
    component has been created. We do this using the `cqExists` (Component Query exists)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each function we pass to the `chain` method is passed a `next` method that should
    be called at the end, so that the next item in the chain is then executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to check if the form has been populated with the correct values
    from the chosen record. First, we add a small pause of 10 milliseconds in the
    chain to allow the form time to populate, and then we call the `fieldHasValue`
    method for each field. We pass it in a Component Query to find the desired field,
    the value we expect it to have, and a description of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step we want to test is what happens when one of the fields is updated.
    To do this, we add another step to our chain and update the `Name` field. We then
    check whether the grid has updated accordingly and that the model instance is
    now marked as dirty (that is, it has a change waiting to be committed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we test the save process. We simulate a click on the `Save` button
    and test that the product form is closed and the changes to the record are committed.
    Finally, we call the done method to tell the harness that our tests are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `>>` prefixed should be used to denote a Component Query string. If omitted,
    the query will be interpreted as a CSS style selector.
  prefs: []
  type: TYPE_NORMAL
- en: Event recorder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we have performed very simple steps in our tests.
    However, hand coding all of the Component Queries for each button and the order
    of the interactions can get cumbersome. Siesta Standard features an event recorder
    that allows us to record a series of interactions and generate the code required
    to include these steps in a test. It is worth noting that this code is rarely
    used "as-is"; instead, it is usually modified and enhanced before being added
    to a test script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the event recorder, click the video camera icon in the test results
    window, which will show an empty list of steps, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event recorder](img/3717_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will use the event recorder to test the cancel process of the product form.
    We start by running the `ProductEdit` test so that we have an interface to interact
    with and record against. We then click the record button (the small red circle)
    and start interacting with the interface in the DOM panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Details** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the **Name** field in the product form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Cancel** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we do these, we will click on the stop button and the steps will populate
    the grid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Event recorder](img/3717_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will see each action shown as a row with the action type, the target of
    the action (in this case the Component Query used to target the element or the
    text typed), and the offset of the action.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to alter the target used, you can click on the cell and choose
    a different query from the given list, or modify it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are happy with the steps, you can generate the code to include in the
    test spec. Simply click on the **Generate Code** button and the code will be displayed,
    which can be copied and pasted into our test file.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the recorder generally uses the more condensed, declarative syntax
    for chain steps. Both are perfectly valid and result in the same outcome.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, this is enough to get us started, and we can add more steps to
    the chain which will check for the right outcome after each action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking our example, we may construct the following test assertions around the
    recorded steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Test automation and integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only run our Siesta unit tests in a browser using the Siesta
    interface, which is great for development. However, we will generally want to
    run these tests as part of an automated build process.
  prefs: []
  type: TYPE_NORMAL
- en: We can very easily run our test suites from a command line using PhantomJS or
    WebDriver. We will now demonstrate how to use WebDriver to run cross-browser tests
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebDriver is a tool that allows cross-browser test automation and comes bundled
    with Siesta, making it extremely easy to get it working. In their simplest form,
    we can run the tests we have just created, which must be available from a server
    or localhost, in Google Chrome using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By executing this code from our root project directory, an instance of Google
    Chrome will be launched, the tests run, and the outcome is printed in the Terminal/Command
    Prompt window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Test automation and integration](img/3717_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can extend this to include FireFox, Safari, Chrome, and Internet Explorer
    by using the `--browser=*` option. This will open each browser in turn and execute
    the tests—perfect for cross-browser testing.
  prefs: []
  type: TYPE_NORMAL
- en: Test reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to generate a test report after each run that you can include
    in your build assets, for example. To do this, we include the `--report-format=json
    and --report-file=BuildReport.json` options at the end of our command, to save
    a JSON version of our test results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has focused on how we can write better, more testable JavaScript
    code, and then moved on to how we can use testing frameworks to execute repeatable
    tests on this code.
  prefs: []
  type: TYPE_NORMAL
- en: We dove into the Siesta testing framework and demonstrated how to write simple
    unit tests as well as more complex UI tests that test our applications as if users
    were interacting with them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how our test suites can be run to test cross-browser effectiveness
    as part of a build process from the command line.
  prefs: []
  type: TYPE_NORMAL
