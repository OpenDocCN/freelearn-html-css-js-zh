<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Combining UI Widgets into the Perfect Layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Combining UI Widgets into the Perfect Layout</h1></div></div></div><p>Layouts are fundamental to the appearance and usability of your application. UI widgets can be combined, and arranged, in any number of different configurations to create simple and complex application layouts.</p><p>An Ext JS widget requires a layout to manage its sizing and positioning on the screen. The framework has a large number of different layouts, which provide simple configurations and flexibility to produce applications.</p><p>This chapter will cover the most common topics relating to layouts. These are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How components fit together in layouts</li><li class="listitem" style="list-style-type: disc">Examples and explanations of working with the most common layouts, namely:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The border layout</li><li class="listitem" style="list-style-type: disc">The fit layout</li><li class="listitem" style="list-style-type: disc">HBox and VBox layouts</li></ul></div></li><li class="listitem" style="list-style-type: disc">How to design layouts that are responsive to the user's screen size</li></ul></div><div class="section" title="Layouts and how they work"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Layouts and how they work</h1></div></div></div><p>In Ext JS, containers<a id="id242" class="indexterm"/> have layouts that manage the sizing and positioning of their child components. Traditionally, a developer would apply a combination of CSS rules to the elements in the DOM to build the desired screen layout. Ext JS takes care of most of this for us, by allowing us to define a layout configuration in our container/component and configure the sizing and positioning with JavaScript.</p><p>By default, a container is configured with an Auto layout, which makes child components flow naturally at full width in much the same way DIVs do in a regular HTML page.</p><p>The following<a id="id243" class="indexterm"/> is a list of layouts that are provided by the framework. It is possible, and common, to combine a number of layouts together; this is so that child containers or components are positioned and sized appropriately. For example, a tab panel (card layout) has multiple child containers, of which each may have different layouts. Each of these layouts has different configuration options to control how your app renders. By<a id="id244" class="indexterm"/> default, the Ext JS UI widgets have component layouts configured, which you may need to be aware of.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Absolute</strong></span>: Using <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> coordinates, the absolute layout fixes the position of the <a id="id245" class="indexterm"/>container on screen. Overlapping is possible with this layout.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Accordion</strong></span>: The <a id="id246" class="indexterm"/>accordion layout provides the ability to create an accordion stack of panels on screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Anchor</strong></span>: This<a id="id247" class="indexterm"/> is a layout that enables anchoring of contained elements relative to the container's dimensions.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Border</strong></span>: The<a id="id248" class="indexterm"/> border layout enables you to attach containers to the border of a central region giving you a north, south, east, and west region. This layout has built-in behavior for collapsing and resizing regions.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Card</strong></span>: A<a id="id249" class="indexterm"/> card layout provides a stack of containers that can be moved back and forth. A card layout is ideal for a wizard-style component or tabbed components.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Center</strong></span>: The <a id="id250" class="indexterm"/>contents of a center layout are centered within their container.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Column</strong></span>: A <a id="id251" class="indexterm"/>column layout is ideal for presenting your interface in multiple columns.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fit</strong></span>: A very <a id="id252" class="indexterm"/>common layout, the fit layout stretches the widget to the size and position of the parent container. You can only have one item in a fit layout.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HBox</strong></span>: Much <a id="id253" class="indexterm"/>like the column layout, this layout presents components horizontally. It has some useful configurations to stretch and position child components.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>VBox</strong></span>: Much <a id="id254" class="indexterm"/>like the HBox layout, this layout presents components vertically, one below the other. It has some useful configurations to stretch and position child components.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Table</strong></span>: While tables are less popular with developers, a table layout can still be useful. The <a id="id255" class="indexterm"/>content in a table layout will be rendered as an HTML table.</li></ul></div><div class="section" title="How the layout system works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>How the layout system works</h2></div></div></div><p>As we know, it's the layout that's responsible for the sizing and positioning of your container's children. Correctly rendering the screen requires that all child components have their<a id="id256" class="indexterm"/> sizes and positions calculated so that the DOM can be updated. The<a id="id257" class="indexterm"/> framework does this with the <code class="literal">updateLayout</code> method. This method recurses fully through all child components and calculates the appropriate positions and sizes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For those familiar with previous versions of the framework, the <code class="literal">updateLayout</code> method replaced the <code class="literal">doLayout</code> method in Ext JS 4.1.</p></div></div><p>The framework automatically takes care of sizing and positioning by calling the <code class="literal">updateLayout</code> method. For example, when the browser window is adjusted or resized, or you add or remove components, the framework will do the necessary calculations to ensure your components appear correctly on screen.</p><p>There are some circumstances when it is beneficial to call the <code class="literal">updateLayout</code> manually. Laying out components can be a resource-intensive task, and if you know you are going to make a number of updates to components, then it may be worth thinking about batching the layout into one. For instance, adding three components one after another would trigger three calls to <code class="literal">updateLayout</code> (which recurses through all child components). By using a <code class="literal">suspendLayout</code> flag, we can prevent our application from updating the DOM until we're ready. When we are ready, it's a simple case of switching the <code class="literal">suspendLayout</code> flag off by setting it to false and then manually calling the <code class="literal">updateLayout</code> method of the container.</p></div></div></div>
<div class="section" title="The component layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>The component layout</h1></div></div></div><p>A <a id="id258" class="indexterm"/>component also has a layout which defines how it sizes and positions its internal child items. Component layouts are configured using the <code class="literal">componentLayout</code> config option.</p><p>In most circumstances, you will not require the <code class="literal">componentLayout</code> configuration, unless you plan on writing custom components that have complex layout requirements.</p></div>
<div class="section" title="Using the border layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Using the border layout</h1></div></div></div><p>If you<a id="id259" class="indexterm"/> are looking to create a desktop style experience with your user interface, then the border layout is for you.</p><div class="mediaobject"><img src="graphics/3717_06_01.jpg" alt="Using the border layout"/></div><p>The border layout is an application-oriented layout, supporting multiple nested panels, the ability to collapse regions by clicking on the regions' header or collapse icon, and the resizing of regions by clicking and dragging the splitter bar between them.</p><p>One of the building blocks of our BizDash application will be a Viewport with a border layout. Here, we will learn how to create a simple border layout using the maximum number of regions configurable (north, south, east, west, and center). The west and east regions will be collapsible, with the east region loading pre-collapsed. Resizing will be demonstrated in the south and west regions. These four borders will surround the center region, which regardless of your configuration, is required for a border layout to work.</p><div class="section" title="Starting with the Viewport"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Starting with the Viewport</h2></div></div></div><p>A Viewport <a id="id260" class="indexterm"/>renders itself to the document's body and automatically<a id="id261" class="indexterm"/> consumes the viewable area. It represents the entire viewable browser area and automatically uses 100 percent of the browser window's width and height (minus address bars, developer tools, and so on, of course). Our Viewport will have a border layout to manage the size and positioning of its child containers.</p><p>In our application, we set the <code class="literal">autoCreateViewport</code> property in <code class="literal">app.js</code> to <code class="literal">BizDash.view.main.Main</code>. This automatically sets our main view container to a Viewport<a id="id262" class="indexterm"/> for us.</p><div class="informalexample"><pre class="programlisting">Ext.application({
  name: 'BizDash',
  extend: 'BizDash.Application',
  autoCreateViewport: 'BizDash.view.main.Main'
});</pre></div></div><div class="section" title="Configuring the border layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Configuring the border layout</h2></div></div></div><p>Our<a id="id263" class="indexterm"/> main view takes the following configuration:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  xtype: 'app-main',
  controller: 'main',
  viewModel: {
    type: 'main'
  },
  layout: {
    type: 'border'
  },
  items: [
    {
      region: 'north',
      margins: 5,
      height: 100,
    },
    {
      title: 'West',
      xtype: 'panel',
      region: 'west',
      margins: '0 5 0 5',
      flex: 3,
      collapsible: true,
      split: true,
      titleCollapse: true,
      tbar: [{
        text: 'Button'
      }]
      bind: {
        title: '{name}'
      },
      html: 'This area is commonly used for navigation, for example, using a tree component.',
  {
    title: 'Center',
    region: 'center',
    xtype: 'tabpanel',
    items:[{
      title: 'Tab 1',
      html: 'Content appropriate for the current navigation'
    }]
  },
  {
    title: 'East',
    region: 'east',
    margins: '0 5 0 5',
    width: 200,
    collapsible: true,
    collapsed: true
  },
  {
    title: 'South',
    region: 'south',
    margins: '0 5 5 5',
    flex: .3,
    split: true
  }]
});</pre></div><p>The <a id="id264" class="indexterm"/>border layout, as the name suggests, creates a layout of components that border a central component. Therefore, a requirement of the border layout is that one item must be specified as the center.</p><p>The center region, which you must include for a border layout to work, automatically expands to consume the empty space left over from the other regions in your layout. It does this by having a pre-defined flex value of <code class="literal">1</code> for both height and width.</p><p>The north and south regions take a height or flex configuration. In our app, the north region has a fixed height of 100 px and the south region has a flex of 3. The south and center regions' heights are calculated based on the height remaining in the browser window. Here, the height of the south region is just under a third of the height of the center. The west and east regions, instead, take a width or flex configuration.</p><p>We <a id="id265" class="indexterm"/>add further functionality with <code class="literal">collapsed</code>, <code class="literal">collapsible</code>, <code class="literal">split</code>, and <code class="literal">titleCollapse</code> specified in the desired regions' configuration. They do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">collapsed</code>: If set to <code class="literal">true</code>, it means the region will start collapsed (the regions need to be <code class="literal">Ext.panel.Panel</code> to be collapsible)</li><li class="listitem" style="list-style-type: disc"><code class="literal">collapsible</code>: If set to <code class="literal">true</code>, it allows the user to expand/collapse the panel by clicking on the toggle tool that's added to the header</li><li class="listitem" style="list-style-type: disc"><code class="literal">titleCollapse</code>: If set to <code class="literal">true</code>, it makes the panel collapse no matter where the user clicks on the panel's header</li><li class="listitem" style="list-style-type: disc"><code class="literal">split</code>: If set to <code class="literal">true</code>, it makes the region resizable by allowing the users to click and drag the dividing bar between regions.</li></ul></div></div></div>
<div class="section" title="Using the fit layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Using the fit layout</h1></div></div></div><p>The fit<a id="id266" class="indexterm"/> layout in Ext JS is ideal if you want a container to expand a component to fill its parent. The fit layout is easy to use and requires no configuration.</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  xtype: 'app-main',
  controller: 'main', 
  viewModel: {
    type: 'main'
  },
  layout: {
    type: 'border'
  },
  items: [{
  ...
  },
  {
    title: 'South',
    region: 'south',
    margins: '0 5 5 5',
    flex: .3,
    split: true,
    layout: 'fit',
    items: [{
      xtype: 'component',
      html: 'South Region'
    }]
  }]
});</pre></div><p>The <code class="literal">main</code> class has a border layout, but the south region requires a fit layout for its child panel.</p><p>The fit layout works by defining the <code class="literal">layout</code> config option as <code class="literal">fit</code> in the parent container. This tells Ext JS that the child item should expand to fill the entire space available from its parent.</p><p>It's worth noting that the fit layout will only work for the first child item of the parent container. If you have multiple items defined, the first will be displayed (as it will expand into the remaining space of its parent) and the others will not be visible.</p></div>
<div class="section" title="Using the HBox layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Using the HBox layout</h1></div></div></div><p>The HBox <a id="id267" class="indexterm"/>layout allows you to align components horizontally across a container in a manner similar to a column layout. However, it's a bit more advanced, as it lets you configure additional properties, such as the height of the columns as well.</p><div class="mediaobject"><img src="graphics/3717_06_02.jpg" alt="Using the HBox layout"/></div><p>Let's create an overview widget with three columns to show events, messages, and notes:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.view.dashboard.Overview', {
  extend: 'Ext.container.Container',
  xtype: 'app-overview',
  controller: 'overview',
  viewModel: {
    type: 'overview'
  },
  layout: {
    type: 'hbox',
    align: 'stretchmax'
  },
  items: [
    {
      flex: .3,
      title: 'Today\'s Events'
    },
    {
      flex: .3,
      title: 'Messages'
    },
    { 
      width: 200,
      title: 'Notes'
    }
  ]
});</pre></div><p>Defining an HBox layout ensures that Ext JS horizontally positions each child item giving the appearance of columns in our dashboard application.</p><p>We have configured <code class="literal">stretchmax</code> on the <code class="literal">align</code> config option, meaning that all child items will automatically be stretched to the height of the tallest child. The <code class="literal">align</code> config option controls<a id="id268" class="indexterm"/> how child items are vertically aligned in an HBox layout. Valid values are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">begin</code>: This is the default value. All items in the HBox layout will be vertically aligned to the top of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">middle</code>: All items<a id="id269" class="indexterm"/> will be vertically aligned to the middle (or center) of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretch</code>: Each item will be vertically stretched to fit the height of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretchmax</code>: This vertically stretches all items to the height of the largest item, creating a uniform look without having to individually define a height for each item</li></ul></div><p>The VBox<a id="id270" class="indexterm"/> layout has a very similar config to this layout, but the options are slightly different, as they are designed to control the horizontal alignment.</p><p>By defining a height of 200 and configuring <code class="literal">align: 'stretchmax'</code>, all other panels will have their height stretched to 200 px.</p><div class="section" title="Widths in HBox layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Widths in HBox layouts</h2></div></div></div><p>HBoxes<a id="id271" class="indexterm"/> can have their width defined in two different ways: fixed widths and flex widths.</p><div class="section" title="Fixed width"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec36"/>Fixed width</h3></div></div></div><p>Child<a id="id272" class="indexterm"/> containers can have their width fixed by defining a width configuration in the object. Containers with a fixed width will retain their width dimensions, even when the browser window is resized. Therefore, they are not fluid.</p><p>If, however, you require your layout to be more responsive to the resizing of windows and so on, then it's a <code class="literal">flex</code> config that's required.</p></div><div class="section" title="Flex width"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec37"/>Flex width</h3></div></div></div><p>The <code class="literal">flex</code> config option relatively flexes the child items horizontally in their parent containers. For <a id="id273" class="indexterm"/>example, take a container with flex: 1 and one with flex: 3. In these cases, 25 percent of the remaining parent space is given to the first container and 75 percent of the space is given to the other.</p><p>Flex values are calculated in the following way:</p><div class="informalexample"><pre class="programlisting">((Container Width – Fixed Width of Child Components) / Sum of Flexes) * Flex Value.</pre></div></div></div><div class="section" title="Packing items together"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Packing items together</h2></div></div></div><p>Another <a id="id274" class="indexterm"/>useful config option for the HBox layout is <code class="literal">pack</code>.</p><p>The <a id="id275" class="indexterm"/>
<code class="literal">pack</code> config option controls how the child items are packed together. If the items do not stretch to the full width of the parent container, it's possible to align them to the left, middle, or right using this option. Valid values are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: This is the default value. It aligns all items to the left of the parent container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">center</code>: This aligns all items to the middle of the container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: It aligns all items to the right of the container.</li></ul></div><p>The VBox layout contains the same <code class="literal">pack</code> config, but it is designed to configure the packing of child items vertically.</p></div></div>
<div class="section" title="Using the VBox layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Using the VBox layout</h1></div></div></div><p>The <a id="id276" class="indexterm"/>VBox layout is very similar to the HBox layout. The only difference is that VBox allows you to align components vertically in a container. Just like the HBox layout, this layout is configured by setting fixed widths for its children using the <code class="literal">width</code> config, or by calculating the width automatically with the <code class="literal">flex</code> config.</p><div class="mediaobject"><img src="graphics/3717_06_03.jpg" alt="Using the VBox layout"/></div><div class="section" title="Alignment and packing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Alignment and packing</h2></div></div></div><p>The VBox layout has some useful configuration options that are described here.</p><div class="section" title="align: String"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec38"/>align: String</h3></div></div></div><p>The <code class="literal">align</code> config option controls how child items are horizontally aligned in a VBox layout. Valid <a id="id277" class="indexterm"/>values are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">begin</code>: This is the default value. All items in the VBox layout are horizontally aligned to the left of the container and use their <code class="literal">width</code> config to define how wide they are.</li><li class="listitem" style="list-style-type: disc"><code class="literal">middle</code>: All items are horizontally aligned to the middle (or center) of the container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretch</code>: Each item is horizontally stretched to fit the width of the container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretchmax</code>: This horizontally stretches all items to the width of the largest item, creating a uniform look without having to individually define a width for each item.</li></ul></div></div><div class="section" title="pack: String"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec39"/>pack: String</h3></div></div></div><p>The <code class="literal">pack</code> config option controls how the child items are packed together. If the items do not stretch <a id="id278" class="indexterm"/>to the full height of the parent container (that is, have no flex values), it's possible to align them to the top, middle, or bottom using this option. Valid values are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: This is the default value. It aligns all items to the top of the parent container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">center</code>: This aligns all items to the middle (or center) of the container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: This aligns all items to the bottom of the container.</li></ul></div></div></div></div>
<div class="section" title="Responsive layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Responsive layouts</h1></div></div></div><p>Long gone <a id="id279" class="indexterm"/>are the days when web browsers were only found in desktop PCs and laptops. Nowadays, they can be found in an ever-increasing range of hardware, such as phones, tablets, TVs, and cars, to name a few. Since the release of the iPhone in 2007, a new type of web, the mobile web, has grown in popularity, and the expectations of users have changed. Users expect to access a web application and have fantastic experience, no matter how large or small their screen is.</p><p>Until the advent of Ext JS 5, it was difficult to cater to the differing needs of users. Ext JS 5 has, however, adopted the popular move towards responsive design, giving developers a practical way of adapting the app layout, depending on the size and resolution of the screen presenting it.</p><div class="section" title="Ext.mixin.Responsive and Ext.plugin.Responsive"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Ext.mixin.Responsive and Ext.plugin.Responsive</h2></div></div></div><p>There is a new responsive mixin and plugin that adds a <code class="literal">responsiveConfig</code> option.</p><p>In <a id="id280" class="indexterm"/>our border layout, we want to alter how the <a id="id281" class="indexterm"/>regions are presented, based on the screen orientation. Adding the <code class="literal">responsiveConfig</code> with the following <span class="emphasis"><em>rules</em></span> to the main view tells the application to add the navigation panel to the north or west region based on the orientation of the screen:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  xtype: 'app-main',
  controller: 'main',
  viewModel: {
    type: 'main'
  },
  layout: {
    type: 'border'
  },
  items: [
    {
      xtype: 'panel',
      bind: {
        title: '{name}'
      },
      html: 'This area is commonly used for navigation, for example, using a tree component.',
      width: 250,
      split: true,
      tbar: [
        {
          text: 'Button'
        }
      ],
      plugins: 'responsive',
      responsiveConfig: {
        landscape: {
          region: 'west'
        },
        portrait: {
        region: 'north'
        }
      }
    },
  {
    region: 'center',
    xtype: 'tabpanel',
    items:[
      {
        title: 'Tab 1',
        html: 'Content appropriate for the current navigation'
      }]
    }]
  });</pre></div><p>In this example, the <code class="literal">responsiveConfig</code> has two rules defined: one for landscape and another<a id="id282" class="indexterm"/> for portrait. When the application satisfies the rule, the config defined in the object of that rule will be applied to the component:</p><div class="informalexample"><pre class="programlisting">responsiveConfig: {
  landscape: {
    region: 'west'
  },
  portrait: {
    region: 'north'
  }
}</pre></div><p>If, for example, our screen orientation is landscape, then the framework will apply <code class="literal">region: 'west'</code> to the panel. This is the same as the following:</p><div class="informalexample"><pre class="programlisting">{
  xtype: 'panel',
  bind: {
    title: '{name}'
  },
  html: 'This area is commonly used for navigation, for example, using a tree component.',
  width: 250,
  split: true,
  tbar: [
    {
      text: 'Button'
    }
  ],
  region: 'west'
}</pre></div></div><div class="section" title="ResponsiveConfig rules"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>ResponsiveConfig rules</h2></div></div></div><p>We <a id="id283" class="indexterm"/>must define rules that contain a condition, or multiple <a id="id284" class="indexterm"/>conditions, based on which the rules will be applied. These rules can be any valid JavaScript expression, but the following values are considered in scope:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">landscape</code>: This returns true when the orientation is landscape or on a desktop device.</li><li class="listitem" style="list-style-type: disc"><code class="literal">portrait</code>: This returns true when the orientation is portrait but is always false on desktop devices.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tall</code>: This returns true if the height is greater than the width.</li><li class="listitem" style="list-style-type: disc"><code class="literal">wide</code>: This returns true if the width is greater than the height.</li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>: This defines the width of the Viewport.</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: This defines the height of the Viewport.</li></ul></div><p>The width and height are particularly useful, as these give us a way to define our own values in a way similar to breakpoints in media queries.</p><p>The following example shows how to create a rule that will be applied when a portrait device is less than 400 pixels wide:</p><div class="informalexample"><pre class="programlisting">responsiveConfig: {
  'portrait &amp;&amp; width &lt; 400': {
  ...
  }
}</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Summary</h1></div></div></div><p>Throughout this chapter, we have explored in detail how to define the layout of our components on screen using Ext JS. We have covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How the layout manager works</li><li class="listitem" style="list-style-type: disc">An overview of layouts available to us</li><li class="listitem" style="list-style-type: disc">Examples of how to use the border, fit and HBox/VBox layouts</li><li class="listitem" style="list-style-type: disc">Designing a responsive layout to cope with different screen sizes and device types</li></ul></div><p>We will make use of all of these lessons throughout the rest of the book, as our example application comes to life and we start to integrate our widgets into it.</p><p>In the next chapter, we will demonstrate how to create common UI widgets for our sample application. These widgets will make use of some of the layouts we have seen in this chapter.</p></div></body></html>