- en: Consuming a RESTful API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费RESTful API
- en: 'To demonstrate some more advanced topics related to the consumption of our
    API, we will implement a really simple web client. It will help us cover those
    topics, and it can serve as a reference implementation for the catalog''s consumers.
    For this frontend client, we will use the famous JavaScript library, jQuery. Utilizing
    it will help us cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示与我们API消费相关的一些更高级的主题，我们将实现一个非常简单的网络客户端。这将帮助我们涵盖这些主题，并且可以作为目录消费者的参考实现。对于这个前端客户端，我们将使用著名的JavaScript库，jQuery。利用它将帮助我们涵盖以下内容：
- en: Consuming RESTful services with jQuery
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery消费RESTful服务
- en: Content Delivery Network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容分发网络
- en: Troubleshooting and identifying problems on the wire
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线故障排除和问题识别
- en: Cross-Origin Resource Sharing policy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨源资源共享策略
- en: Client-side handling of different HTTP status codes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同HTTP状态码的客户端处理
- en: Consuming RESTful services with jQuery
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery消费RESTful服务
- en: 'JQuery is a fast, light, and powerful JavaScript library; it eliminates DOM-related
    complexity by providing direct access to HTML elements once the DOM three has
    been loaded. To use jQuery within an HTML document, you have to import it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery是一个快速、轻量级且功能强大的JavaScript库；它通过在DOM三加载后直接访问HTML元素来消除与DOM相关的复杂性。要在HTML文档中使用jQuery，你必须导入它：
- en: '`<script type="text/javascript" src="img/jquery-3.3.1.min.js "></script>`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script type="text/javascript" src="img/jquery-3.3.1.min.js "></script>`'
- en: Assume that somewhere within an HTML document, there is a button defined as `<input
    type="button" id="btnDelete" value="Delete"/>`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在一个HTML文档的某个地方，有一个定义为`<input type="button" id="btnDelete" value="Delete"/>`的按钮。
- en: 'To assign a function to the click event of this button with JQuery means we
    need to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数分配给这个按钮的点击事件，使用JQuery意味着我们需要做以下操作：
- en: Import the jquery library in the HTML document
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档中导入jQuery库
- en: Assure that the DOM document of the HTML document is completely loaded
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保HTML文档的DOM文档已完全加载
- en: Access the button using the identifier defined by the ID attribute
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由ID属性定义的标识符访问按钮
- en: 'Provide a handler function as an argument to the `click` event:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理函数作为参数传递给`click`事件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `$('#identifier')` expression provides direct access to elements in DOM
    three, `$` states that an object is referenced, and the value within the bracket,
    prefix by `#` specifies its identifier. jQuery will have access to the element
    only after the entire document has been loaded; that's why elements should be
    accessed within `${document).ready()` block scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''#identifier'')`表达式提供了对DOM三中元素的直接访问，`$`表示一个对象被引用，括号内的值，由`#`前缀指定，指定了其标识符。jQuery只有在整个文档加载完毕后才能访问元素；这就是为什么应该在`${document).ready()`块作用域内访问元素。'
- en: 'Similarly, you can access the value of a text input with an identifier `txt`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以通过一个标识符`txt`访问文本输入的值：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `$(document)`object is predefined in jQuery and represents the entire DOM
    document of the HTML page. In a similar way, jQuery predefines a function for
    AJAX-enabled communication, that is, for sending HTTP request to an HTTP endpoint.
    This function is named after **Asynchronous JavaScript + XML-** AJAX, which was
    the de facto standard that enabled a JavaScript application to communicate with
    HTTP-enabled backends. Nowadays, **JSON** is being widely used; however, naming
    conversion for AJAX is still used as a term for asynchronous communication, regardless
    of the data format; that is why the predefined function in jQuery is called `$.ajax(options,
    handlers)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的`$(document)`对象是预定义的，代表HTML页面的整个DOM文档。以类似的方式，jQuery预定义了一个用于AJAX启用通信的函数，即发送HTTP请求到HTTP端点。这个函数以**Asynchronous
    JavaScript + XML-** AJAX命名，它是JavaScript应用程序与HTTP启用后端通信的事实标准。如今，**JSON**被广泛使用；然而，AJAX的命名转换仍然用作异步通信的术语，无论数据格式如何；这就是为什么jQuery中的预定义函数被称为`$.ajax(options,
    handlers)`。
- en: 'To send an http request with the `$.ajax` function, invoke it by providing
    the endpoint URL, http method for the request, and its content type; the result
    will be returned in a callback function. The following example shows how an item
    with identifier 3 is requested from our catalog:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`$.ajax`函数发送HTTP请求，通过提供端点URL、请求的HTTP方法和其内容类型来调用它；结果将在回调函数中返回。以下示例显示了如何从我们的目录中请求标识符为3的项目：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Posting data to an endpoint is rather similar:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 向端点发送数据相当类似：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Simply use the appropriate options `type` set to POST, and the `dateType` set
    to JSON. Those will specify that a POST request is to be sent to the endpoint
    in the JSON format. The payload of the object is provided as a value to the `data`
    attribute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地使用适当的选项`type`设置为POST，并将`dateType`设置为JSON。这将指定要发送到端点的POST请求是以JSON格式。对象的有效负载作为`data`属性的值提供。
- en: 'Invoking a `delete` method is quite similar:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`delete`方法相当类似：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A basic understanding of how jQuery works is just about fine for the scope
    of this book. Now, let''s glue all this together and create two HTML pages; that
    way, we will handle creating, displaying, and deleting an item in our catalog,
    starting with the page that displays an item and allows its deletion. This page
    loads an item from the catalog using `GET` request, and then displays the item''s
    attributes in the HTML page in a table-like manner:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的范围，对jQuery如何工作有一个基本理解就足够了。现在，让我们将这些内容粘合在一起，创建两个HTML页面；这样，我们将处理创建、显示和删除目录中的项，从显示项并允许其删除的页面开始。此页面使用`GET`请求从目录中加载项，然后在HTML页面中以类似表格的方式显示项的属性：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The page that handles creation is quite similar. However, it provides text
    inputs instead of span labels for an item''s fields, where the view page will
    display the data for the attributes of the loaded item. JQuery provides a simplified
    access model to the input controls, rather than DOM—simply access the input element
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理创建的页面相当相似。然而，它为项目的字段提供文本输入而不是span标签，而在视图页面将显示加载项的属性数据。JQuery提供了一个简化的输入控件访问模型，而不是DOM——只需按如下方式访问输入元素：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s give that a try and load an existing item in the view page by opening
    our static page directly from the filesystem in a browser of your choice. It looks
    as if we have some kind of a problem, as nothing gets displayed. Enabling client-side
    debugging using the browser''s developer suite doesn''t give much more information
    either:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，通过在浏览器中选择直接从文件系统中打开我们的静态页面来在视图页面中加载现有项。看起来我们遇到了某种问题，因为没有显示任何内容。启用浏览器开发者工具进行客户端调试也没有提供更多信息：
- en: '![](img/0b436898-ce3a-401f-9f8a-03f6f24c5f06.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b436898-ce3a-401f-9f8a-03f6f24c5f06.png)'
- en: It states that the content is partially blocked; however, it is not quite clear
    whether this is due to a backend-related error, or something has gone wrong on
    the client side. We will look at how to troubleshoot such problematic situations
    in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示内容部分被阻止；然而，并不清楚这是否是由于后端相关错误，或者客户端发生了某些错误。我们将在下一节中查看如何解决此类问题。
- en: Troubleshooting and identifying problems on the wire
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线故障排除和问题识别
- en: Sometimes the interaction between the client and the server fails, and the reason
    for such failures often requires analysis; otherwise, their root cause stays unknown.
    We spotted that our client application does not load and thus doesn't display
    data for an existing item. Let's try to investigate the root cause for that by
    setting up an `http` tunnel between the client and the server. This will be a
    kind of MiM (man-in-the-middle)-based investigation, as we will listen to one
    port and redirect the incoming request to another, to see whether the server returns
    correct responses or its pipe gets broken somewhere in the middle. There are various
    TCP tunnels available out there; I have been using a simple open source one available
    on GitHub at [https://github.com/vakuum/tcptunnel](https://github.com/vakuum/tcptunnel).
    Its author also maintains a separate website where you can download prebuilt binaries
    for the most common operating system; they are available at [http://www.vakuumverpackt.de/tcptunnel/](http://www.vakuumverpackt.de/tcptunnel/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时客户端和服务器之间的交互会失败，此类失败的原因通常需要分析；否则，其根本原因将保持未知。我们发现我们的客户端应用程序没有加载，因此没有显示现有项的数据。让我们通过在客户端和服务器之间设置一个`http`隧道来尝试调查其根本原因。这将是一种基于MiM（中间人）的调查，因为我们将在一个端口上监听并将传入的请求重定向到另一个端口，以查看服务器是否返回正确的响应或其管道在中间某处被破坏。市面上有各种TCP隧道；我一直在使用GitHub上可用的简单开源隧道，网址为[https://github.com/vakuum/tcptunnel](https://github.com/vakuum/tcptunnel)。其作者还维护了一个单独的网站，您可以从那里下载适用于最常见操作系统的预构建二进制文件；它们可在[http://www.vakuumverpackt.de/tcptunnel/](http://www.vakuumverpackt.de/tcptunnel/)找到。
- en: 'After you have built or downloaded a copy of the tunnel, start it as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在您构建或下载隧道副本后，按照以下方式启动它：
- en: '`./tcptunnel --local-port=3001 --remote-port=3000 --remote-host=localhost --log`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`./tcptunnel --local-port=3001 --remote-port=3000 --remote-host=localhost --log`'
- en: 'This will start the application listening on port 3001 and will forward each
    incoming request to location port 3000; the `--log` option specifies that all
    the data flow passing the tunnel should be logged in the console. Finally, modify
    HTML pages to use port 3001 instead of 3000, and let''s see what the tunnel would
    show us after firing new GET request for the item with id 3, this time on port
    `3001: http://localhost:3001/catalog/v2/item/3`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序监听端口3001，并将每个传入请求转发到端口3000的位置；`--log`选项指定所有通过隧道的流量都应该在控制台中记录。最后，修改HTML页面以使用端口3001而不是3000，然后让我们在端口`3001`上对新请求id为3的项目执行新的GET请求，这次是`http://localhost:3001/catalog/v2/item/3`：
- en: '![](img/0cfcd321-5119-4be0-9ed5-bd6ba36433ed.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0cfcd321-5119-4be0-9ed5-bd6ba36433ed.png)'
- en: Surprisingly, the tunnel shows that the server responds normally with `200 OK`
    and a relevant payload. So it seems as if the problem is not on the server side.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，隧道显示服务器以`200 OK`和相关的有效负载正常响应。所以看起来问题不在服务器端。
- en: 'Well, since the error is obviously not on the server side, let''s try to investigate
    deeper what has happened on the client side. Nowadays, all popular browsers have
    so-called web developer tools. They provide access to `http` logs, dynamically-rendered
    code, the DOM three of the HTML document, and so on. Let''s invoke our RESTful
    GET operation with Mozillas Firefox and see what its web console will log about
    our request. Open the Mozilla Firefox menu and select `Web Developer`, and then
    select `Browser Console`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然错误显然不是在服务器端，我们就尝试深入调查客户端发生了什么。如今，所有流行的浏览器都有所谓的开发者工具。它们提供了对`http`日志、动态渲染的代码、HTML文档的DOM树等的访问。让我们使用Mozilla
    Firefox调用我们的RESTful GET操作，看看它的Web控制台会记录关于我们请求的什么信息。打开Mozilla Firefox菜单，选择`Web开发者`，然后选择`浏览器控制台`：
- en: '![](img/108af34a-7ae8-4c75-ae49-437241ba2207.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/108af34a-7ae8-4c75-ae49-437241ba2207.png)'
- en: 'Aha! Seems like we found it: `Cross-Origin Request Blocked: The Same Origin
    Policy disallows reading the remove resource at...`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！看起来我们找到了：`跨源请求被阻止：同源策略阻止读取远程资源...`。
- en: This error is blocking the server-side response at client level. In the next
    section, we will see what this actually means.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误在客户端级别阻止了服务器端响应。在下一节中，我们将看到这实际上意味着什么。
- en: Cross Origin Resource Sharing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨源资源共享
- en: Cross-site HTTP requests are requests that refer to resources to be loaded from
    a domain different from the one that initially requested them. In our case, we
    started the client from our filesystem, and it requested resources from a network
    address. This is considered a potential **Cross-site scripting** request, which,
    according to the **W3C recommendation** at [http://w3.org/cors/TR/cors](http://w3.org/cors/TR/cors),
    should be carefully handled. This means that if an external resource is requested,
    the domain where it is requested from—its Origin—should be explicitly specified
    in a header, as long as an external resource loading is not allowed in general.
    This mechanism prevents Cross-Side Scripting (XSS) attacks, and it is based on
    HTTP headers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站HTTP请求是指指向从请求它们的域不同的域的资源请求。在我们的情况下，我们从文件系统启动客户端，并从网络地址请求资源。这被认为是一个潜在的**跨站脚本**请求，根据[http://w3.org/cors/TR/cors](http://w3.org/cors/TR/cors)的**W3C建议**，应该谨慎处理。这意味着如果请求外部资源，请求它的域——它的源——应该在一个头中明确指定，只要通常不允许加载外部资源。这种机制防止跨站脚本（XSS）攻击，并且基于HTTP头。
- en: 'The following HTTP request headers specify how external resources should be
    handled on the client side:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下HTTP请求头指定了客户端如何处理外部资源：
- en: '`Origin` defines where the request originated from'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Origin`定义了请求的来源'
- en: '`Access-Control-Request-Method` defines the HTTP method that was used to request
    the resource'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Request-Method`定义了请求资源所使用的HTTP方法'
- en: '`Access-Control-Request-Header` defines any headers that will be allowed in
    combination with the external resource request'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Request-Header`定义了与外部资源请求一起允许的任何头'
- en: 'On the server side,  the following headers indicate whether a response is eligible
    for a CORS-enabled client request:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，以下头指示响应是否适合CORS启用客户端请求：
- en: '`Access-Control-Allow-Origin`: This header either, if exists, specifies that
    the requester''s host is allowed by repeating it, or it could specify that all
    remote origins are allowed by returning a wildcard: ''*'''
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin`：此头如果存在，则指定请求者的主机被允许通过重复它，或者它可以指定所有远程源都被允许通过返回一个通配符：`*`'
- en: '`Access-Control-Allow-Methods`: This header specifies the HTTP methods that
    the server would allow from cross-side''s domain'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Methods`：此标头指定服务器允许来自跨域的 HTTP 方法'
- en: '`Access-Control-Allow-Headers`: This header specifies the HTTP headers that
    the server would allow from cross-side''s domain'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Headers`：此标头指定服务器允许来自跨域的 HTTP 标头'
- en: There are some more `Access-Control-*` headers that can be used for further
    granularity when incoming XSS requests are to be served, or not, based on credentials
    and request's max-age, but basically, the most important ones are for the allowed
    origin, allowed methods, and allowed headers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他的 `Access-Control-*` 标头，可以在根据凭据和请求的最大存活时间来决定是否提供 XSS 请求时使用，但基本上，最重要的还是用于允许的来源、允许的方法和允许的标头。
- en: 'There is a node module that handles `CORS` configuration at server side; it
    is installed by `npm install -g cors` and is easily enabled in our application
    via a middleware module. Simply use it in all the exposed routes by passing it
    to the application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个节点模块可以处理服务器端的 `CORS` 配置；它通过 `npm install -g cors` 安装，并且可以通过中间件模块轻松地在我们的应用程序中启用。只需在所有公开的路由中使用它，并将其传递给应用程序：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the tunnel after you enabled the `cors` middleware to see that the server
    would now gracefully handle requests from different origins by serving the "Access-Control-Allow-Origin''
    header set to ''*''":'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 `cors` 中间件之后使用隧道，以查看服务器现在将优雅地处理来自不同来源的请求，通过提供设置为 '*' 的 "Access-Control-Allow-Origin"
    标头：
- en: '![](img/878c48f5-d925-4b5e-b648-d38828558808.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/878c48f5-d925-4b5e-b648-d38828558808.png)'
- en: Content Delivery Networks
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容分发网络
- en: When we imported the jQuery library into our client application, we directly
    referred to its optimized source from its vendor as `<script type="text/javascript"
    src="img/jquery-3.3.1.min.js "/>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 jQuery 库导入到我们的客户端应用程序中时，我们直接从供应商那里引用其优化的源代码，如下所示：`<script type="text/javascript"
    src="img/jquery-3.3.1.min.js "/>`.
- en: Now, imagine that for some reason this site goes down either temporarily or
    for good; this will make our application unusable, as the import wouldn't work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设由于某种原因，这个网站暂时或永久性地关闭；这将使我们的应用程序无法使用，因为导入将无法工作。
- en: Content Delivery Networks come to help in these cases. They serve as a repository
    for libraries or other static media content, assuring that the needed resources
    will be available without downtime, even when something goes wrong with their
    vendors. One of the most popular JavaScript CDNs is [https://cdnjs.com/](https://cdnjs.com/);
    it provides the most common JS libraries available out there. We will switch our
    clients to refer to the jquery library from this CDN rather than from its vendors'
    website at `<script type="text/javascript" src="img/jquery-3.3.1.min.js "/>`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内容分发网络在这些情况下提供了帮助。它们作为库或其他静态媒体内容的存储库，确保即使供应商出现问题，所需资源也将可用，不会中断服务。最受欢迎的 JavaScript
    CDN 之一是 [https://cdnjs.com/](https://cdnjs.com/)；它提供了最常用的 JS 库。我们将把我们的客户端切换到从这个
    CDN 而不是从其供应商网站 `<script type="text/javascript" src="img/jquery-3.3.1.min.js "/>`
    引用 jQuery 库。
- en: While there is hardly anything wrong with directly downloading your JS libraries
    and placing them in the static directory of your node.js project, it may lead
    to having local changes and fixes directly in your library dependencies. This
    can easily result in incompatible changes and can prevent your application from
    easily switching to newer versions in the future. As long as your dependencies
    are open source, you should strive to improve them by contributing fixes or reporting
    bugs rather than having fixes in your own local fork. Still, if you are unfortunate
    enough to run into a bug that you can easily fix, you can fork the library to
    resolve your problem faster. However, always consider contributing the fix back
    to the community. After it is accepted, switch back to the official version; otherwise,
    you will find yourself in a difficult situation the next time with another issue,
    and the community would track it much harder if reported from a forked version.
    That is the beauty of open source, and that is why you should always consider
    consuming JavaScript APIs' Content Delivery Networks. They will provide you with
    the stability and support you may need at any point in the life of your application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接下载您的 JS 库并将它们放置在 node.js 项目的静态目录中几乎没有什么问题，但这可能会导致您的库依赖项中直接包含本地更改和修复。这很容易导致不兼容的更改，并阻止您的应用程序轻松切换到未来的新版本。只要您的依赖项是开源的，您就应该努力通过贡献修复或报告错误来改进它们，而不是在您自己的本地分支中进行修复。尽管如此，如果您不幸遇到一个您可以轻松修复的错误，您可以将库分支以更快地解决问题。然而，始终考虑将修复贡献回社区。一旦被接受，就切换回官方版本；否则，您在下一次遇到问题时会发现自己处于困难境地，如果从分支版本报告，社区会跟踪它更加困难。这就是开源的美丽之处，这就是为什么您应该始终考虑消费
    JavaScript API 的内容分发网络。它们将在您应用程序生命周期的任何时刻为您提供所需的稳定性和支持。
- en: Handling HTTP status codes on the client side
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端处理 HTTP 状态码
- en: We spent quite some time addressing how RESTful services should represent each
    state, including erroneous ones, gracefully. A well-defined API should demand
    from its consumers to handle all its errors gracefully and to provide as much
    information per state as required, rather than just stating "An error has occurred".
    That is why it should look up the returned status code and clearly distinguish
    between client requests such as `400 Bad Request` or `415 Unsupported media types`
    caused by faulty payload, caused by wrong media types, or authentication-related
    errors, such as `401 Unauthorized`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了不少时间来处理 RESTful 服务应该如何优雅地表示每个状态，包括错误状态。一个定义良好的 API 应该要求其消费者优雅地处理所有错误，并为每个状态提供尽可能多的信息，而不仅仅是说“发生了错误”。这就是为什么它应该查找返回的状态码，并清楚地区分由错误的负载引起的客户端请求，例如
    `400 Bad Request` 或由错误的媒体类型引起的 `415 Unsupported media types`，或者与身份验证相关的错误，例如 `401
    Unauthorized`。
- en: 'The status code of an erroneous response is available in the `error` callback
    of the jQuery callback function and should be used to provide detailed information
    back to the request:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应的状态码在 jQuery 回调函数的 `error` 回调中可用，并应用于向请求提供详细信息：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unsuccessful requests are handled by the error callback function. It provides
    `jqXHR` - the `XmlHttpRequest` JavaScript*—*object as its first argument. It carries
    across all the request/response related information, such as status code and headers.
    Use it to determine what the requested server has returned so that your application
    can handle different errors more granularly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的请求由错误回调函数处理。它将 `jqXHR` ——即 `XmlHttpRequest` JavaScript*—*对象作为其第一个参数提供。它携带所有请求/响应相关信息的传递，例如状态码和头信息。使用它来确定请求的服务器返回了什么，以便您的应用程序可以更细致地处理不同的错误。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a simple web-based client with the jQuery library.
    We utilized this client to demonstrate how the Cross-Origin Resource Sharing policy
    works, and we used a man in the middle means to troubleshoot issues on the wire.
    Finally, we looked at how errors should be handled on the client side. This chapter
    brings us one step closer to the end of our journey, as we got the first consumer
    of our service. In the next chapter, we will walk you through the final step before
    bringing a service to production—choosing its security model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 jQuery 库实现了一个简单的基于 Web 的客户端。我们利用这个客户端来演示跨源资源共享策略的工作原理，并使用中间人手段来调试线上的问题。最后，我们探讨了客户端应该如何处理错误。这一章让我们离旅程的终点更近一步，因为我们获得了我们服务的第一个消费者。在下一章中，我们将向您介绍将服务推向生产前的最后一步——选择其安全模型。
