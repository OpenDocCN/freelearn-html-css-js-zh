<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor184"/>10</h1>
<h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Deploying a Sequelize Application</h1>
<p>After installing an admin dashboard, configuring our web application to book flights, and having built a backend server, we are now ready to start developing the frontend interface along with deploying the application. Just in time too, because our board members want to see some progress, and they would like to see a working prototype for purchasing a ticket.</p>
<p>Throughout this chapter, and to meet the requirements of our board members, we will need to do the following:</p>
<ul>
<li>Refactor some of our current routes and add another route for listing flight schedules</li>
<li>Integrate Express’ static middleware and secure the admin interface</li>
<li>Create a page to list and book flights</li>
<li>Deploy the application to a service such as Fly.io</li>
</ul>
<h1 id="_idParaDest-177"><a id="_idTextAnchor186"/>Technical requirements</h1>
<p>For the tasks in this chapter, we will be installing the following additional software:</p>
<ul>
<li>A version control manager called Git</li>
<li>The Fly.io CLI for deploying to a cloud application platform</li>
</ul>
<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch10">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch10</a>.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor187"/>Refactoring and adding flight schedule routes</h1>
<p>Before we <a id="_idIndexMarker761"/>start creating the customer interface for purchasing a <a id="_idIndexMarker762"/>boarding ticket, we will need to make several adjustments to our code base. Let us begin by creating a new file located at <code>routes/airplanes.js</code> and moving the <code>app.post('/airplanes', …)</code> and <code>app.get('/airplanes/:id', …)</code> blocks into that file as follows:</p>
<pre class="source-code">
async function getAirplane(req, res) {
    const airplane = await models.Airplane.findByPk
     (req.params.id);
    if (!airplane) {
        return res.sendStatus(404);
    }
    res.json(airplane);
}
exports.getAirplane = getAirplane;</pre>
<p>This route will return an <code>Airplane</code> model record based on the primary key, which is defined in Express’ Request object (indicated by the <code>:id</code> symbol). If there were no records to be found, then we will return a <code>404</code> (not found) status.</p>
<p>Next, we will take the <code>createAirplane</code> code block from <code>routes/flights.js</code> and move it into the <code>routes/airplanes.js</code> file:</p>
<pre class="source-code">
async function createAirplane(req, res) {
    const { name, seats } = req.body;
    try {
        const airplane = await models.Airplane.create({
            planeModel: name,
            totalSeats: seats,
        });
        return res.json(airplane);
    } catch (error) {
        res.status(500).send(error);
    }
}
exports.createAirplane = createAirplane;</pre>
<p>Within <code>routes/flights.js</code>, we <a id="_idIndexMarker763"/>will want to add a <a id="_idIndexMarker764"/>new handler called <code>flightSchedules</code>:</p>
<pre class="source-code">
async function flightSchedules(req, res) {
    const records = await models.FlightSchedule.findAll({
       include: [models.Airplane]
    });
    res.json(records);
}
exports.flightSchedules = flightSchedules;</pre>
<p>After that, within the <code>index.js</code> file, in the project’s root directory, we can remove the <code>app.get('/', …)</code> block and modify the route requiring blocks (just above the block that we removed) to match the new method paths as follows:</p>
<pre class="source-code">
const { bookTicket } = require("./routes/tickets")
const { createSchedule, flightSchedules } = 
require("./routes/flights");
const { getAirplane, createAirplane } = 
require("./routes/airplanes");</pre>
<p>The <code>app.get('/airplanes/:id', …)</code> block should now look as follows:</p>
<pre class="source-code">
app.get('/airplanes/:id', getAirplane);</pre>
<p>And below <a id="_idIndexMarker765"/>that, we can add the flight schedule route:</p>
<pre class="source-code">
app.get('/flights', flightSchedules);</pre>
<p>Next, we will <a id="_idIndexMarker766"/>want to adjust the error returned from the customers model. Within <code>models/customers.js</code>, replace the existing attributes with the following code:</p>
<pre class="source-code">
    name: {
      type: DataTypes.STRING,
      validate: {
        notEmpty: {
            msg: "A name is required for the customer",
        }
      }
    },
    email: {
      type: DataTypes.STRING,
      validate: {
        isEmail: {
            msg: "Invalid email format for the customer",
        }
      }
    }</pre>
<p>The last modification for flights and booking a ticket involves making some adjustments to the <code>routes/tickets.js</code> file. First, we will want to add Sequelize’s <code>ValidationError</code> at the top of the file:</p>
<pre class="source-code">
const { ValidationError } = require("@sequelize/core");</pre>
<p>Since we <a id="_idIndexMarker767"/>will be finding, or creating, a customer throughout <a id="_idIndexMarker768"/>the booking process, we will want to change the <code>req.body</code> line to this:</p>
<pre class="source-code">
const { scheduleId, seat, name, email } = req.body;</pre>
<p>And below that line, we will add the following:</p>
<pre class="source-code">
const [customer] = await models.Customer.findOrCreate({
    where: {
        email,
    },
    defaults: {
        name,
    }
});</pre>
<p>This will tell Sequelize to find or create a customer record using the email as a key and will hydrate the record with the name (if the record is new) from the <code>POST</code> request.</p>
<p>Just above the <code>await schedule.addBoardingTicket(…)</code> block, we will want to add a method that defines the customer association for the newly created boarding ticket:</p>
<pre class="source-code">
await boardingTicket.setCustomer(
 customer,
 { transaction: tx }
);</pre>
<p>The remaining modification for this file is replacing the <code>catch</code> block with the following code:</p>
<pre class="source-code">
    } catch (error) {
        if (error instanceof ValidationError) {
            let errObj = {};
            error.errors.map(err =&gt; {
               errObj[err.path] = err.message;
            });
            return res.status(400).json(errObj);
        }
        if (error instanceof Error) {
            return res.status(400).send(error.message);
        }
        return res.status(400).send(error.toString());
    }</pre>
<p>This error <a id="_idIndexMarker769"/>block will check whether the incoming error is <a id="_idIndexMarker770"/>a Sequelize <code>ValidationError</code> type and if so, will map out the errors to <code>errorObj</code> with the column (<code>err.path</code>) as a key and the error message (<code>err.message</code>) as the value – then, it will return the <code>error</code> object. The next <code>if</code> block will check whether the error is a generic <code>Error</code> type, and if so, return the <code>error.message</code> value – otherwise, it will return the <code>error</code> variable as a string. This will provide a more ergonomic way of handling errors for a quick prototype website.</p>
<p>Those are all of the modifications that are necessary for managing flights and creating flight tickets. The next step is to set the foundation for our static assets and secure our admin dashboard.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Integrating Express’ static middleware and securing the admin interface</h1>
<p>Before exposing <a id="_idIndexMarker771"/>our application to the general public, we will need <a id="_idIndexMarker772"/>to secure the admin dashboard routes, along with exposing the static assets for frontend development. First, we will want to create a new directory with an empty file located at <code>public/index.xhtml</code>. After that, we can start making modifications to the <code>index.js</code> file (within the project’s root directory). At the top, we will need Node.js’ path module:</p>
<pre class="source-code">
const path = require("path");</pre>
<p>Just below the <code>app.use('/graphql', server)</code> block, we will want to tell Express to serve static assets that are found within the public directory:</p>
<pre class="source-code">
app.use(express.static(path.join(__dirname, "public")));</pre>
<p>Express will try to find a matching file with the associated route in the public directory before cascading down to our API routes (for example, <code>/airplanes</code> or <code>/flights</code>). The reason why we use <code>path.join</code> here is to avoid mismatches from relative paths, which allows us to run the application from any directory.</p>
<p>Next, we will want to secure our admin dashboard – in the name of brevity, we will use the HTTP authentication method. This will require us to install the <code>express-basic-auth</code> package:</p>
<pre>npm i --save express-basic-auth</pre>
<p>Add the requirement at the top of <code>index.js</code>:</p>
<pre class="source-code">
const basicAuth = require("express-basic-auth");</pre>
<p>Replace the <code>app.use(adminJs.options.rootPath, router)</code> block with the following:</p>
<pre class="source-code">
app.use(adminJs.options.rootPath, basicAuth({
        users: { 'admin': 'supersecret' }, challenge: true,
        }), router);</pre>
<p>This will tell Express to ask for a username and password combination (<code>admin</code> and <code>supersecret</code> respectively) when accessing the AdminJS root path. Now, when we start our application and head over to <code>http://localhost:3000/admin</code>, we should be greeted by a login dialog similar to that in <em class="italic">Figure 10.1</em>:</p>
<div><div><img alt="Figure 10.1 – Admin login " height="322" src="img/Figure_10.01_B17841.jpg" width="882"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Admin login</p>
<p>Now that <a id="_idIndexMarker773"/>our AdminJS routes are secure, we can <a id="_idIndexMarker774"/>start creating the frontend page that our customers will see when they visit the application.</p>
<p class="callout-heading">Note</p>
<p class="callout">In a real-world scenario application, instead of using basic authentication, we would use another form of authentication such as JSON Web Tokens or a Single Sign-On Service.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor189"/>Creating a page to list and book flights</h1>
<p>For this <a id="_idIndexMarker775"/>application, we will be requiring two external libraries to help build <a id="_idIndexMarker776"/>the frontend components for the application. The first <a id="_idIndexMarker777"/>library is <strong class="bold">Bulma</strong>, which is a CSS framework designed for quick prototyping and doesn’t require its own JavaScript library. For more information on Bulma, you can <a id="_idIndexMarker778"/>visit its website, located at <a href="https://bulma.io/">https://bulma.io/</a>. The next library is <strong class="bold">AlpineJS</strong>, which <a id="_idIndexMarker779"/>is a framework that helps us avoid writing JavaScript to modify states or behaviors by using HTML tags <a id="_idIndexMarker780"/>and markup. More information can be found at <a href="https://alpinejs.dev/">https://alpinejs.dev/</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Other fantastic frontend frameworks that can be used instead of AlpineJS include VueJS, React, or Deepkit. AlpineJS was chosen for this book due to its minimal setup and requirements.</p>
<p>Let us start <a id="_idIndexMarker781"/>with the bare necessities, the HTML for a simple header <a id="_idIndexMarker782"/>section of the website:</p>
<ol>
<li>Within <code>public/index.xhtml</code>, add the following code:<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
  &lt;title&gt;Welcome to Avalon Airlines!&lt;/title&gt;
  &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"&gt;
  &lt;script src="img/cdn.min.js" defer&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;section class="section"&gt;
    &lt;div class="container"&gt;
      &lt;h1 class="title"&gt;
        Welcome to Avalon Airlines!
      &lt;/h1&gt;
      &lt;p class="subtitle"&gt;
        Where would you like to go 
         &lt;strong&gt;today&lt;/strong&gt;?
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
<li>After <a id="_idIndexMarker783"/>the first <code>&lt;section&gt;</code>, we will want to add another <a id="_idIndexMarker784"/>with a container separated by two columns as follows:<pre>  &lt;section class="section"&gt;
    &lt;div class="container"&gt;
      &lt;div class="columns" x-data="{
                    flights: [],
                    selected: {}
                  }" x-init="fetch('/flights')
                      .then(res =&gt; res.json())
                      .then(res =&gt; flights = res)"&gt;
        &lt;div class="column"&gt;
        &lt;/div&gt;
        &lt;div class="column"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;</pre></li>
</ol>
<p>The <code>x-data</code> attribute will tell AlpineJS what kind of shape our model and data will hold. This <a id="_idIndexMarker785"/>data will be propagated down to children elements. The <code>x-init</code> attribute will run upon initialization of the element and will <a id="_idIndexMarker786"/>fetch from our API calling <code>/flights</code>. Afterward, we take the results and convert them into a JSON object and then we assign the JSON response to the <code>flights</code> array within our <code>x-data</code> attribute.</p>
<ol>
<li value="3">In the first column, from the section that we just created, we will want to create a table that renders all of the available flights:<pre>&lt;table class="table is-bordered is-striped is-narrow is-hoverable is-fullwidth"&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;Origin&lt;/th&gt;
        &lt;th&gt;Departure&lt;/th&gt;
        &lt;th&gt;Departure Time&lt;/th&gt;
        &lt;th&gt;Model&lt;/th&gt;
        &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;template x-for="flight in flights"&gt;
        &lt;tr&gt;
          &lt;td x-text="flight.originAirport"&gt;&lt;/td&gt;
          &lt;td x-text="flight.destinationAirport"&gt;&lt;/td&gt;
          &lt;td x-text="flight.departureTime"&gt;&lt;/td&gt;
          &lt;td x-text=
           "flight.Airplane.planeModel"&gt;&lt;/td&gt;
          &lt;td&gt;&lt;button x-on:click="selected = flight" 
           class="button is-primary is-light is-
           small"&gt;Book
              Flight&lt;/button&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/template&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;</pre></li>
</ol>
<p>AlpineJS <a id="_idIndexMarker787"/>will recognize the <code>x-for</code> attribute, which operates <a id="_idIndexMarker788"/>similarly to <code>for</code> loops in other languages – anything inside of that block will be rendered for each iteration. If the <code>flights</code> array is empty, then the <code>template</code> block will not be rendered. The <code>x-on:click</code> attribute will add a click event listener to the <code>button</code> element, which will assign the selected variable (part of our <code>x-data</code> model from the parent element) to the associated flight entry.</p>
<ol>
<li value="4">Next, we will want to create the logic for handling our form submission. Just above the closing body tag (<code>&lt;/body&gt;</code>), we will want to add the following:<pre>&lt;script&gt;
  function flightForm() {
    return {
      data: {
        email: "",
        name: "",
        seat: "",
        success: false,
      },
      formMessages: [],
      loading: false,</pre></li>
</ol>
<p>The <code>data</code>, <code>formMessages</code>, and <code>loading</code> variables are all states for AlpineJS. We can choose whatever names we want, as it does not matter for AlpineJS. </p>
<ol>
<li value="5">Now, for the <a id="_idIndexMarker789"/>submission event handling part, just below <a id="_idIndexMarker790"/>the <code>loading: false</code> block, add the following:<pre>      submit(e) {
        this.loading = true;
        fetch("/book-flight", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
          },
          body: JSON.stringify({
            ...this.data,
            scheduleId: this.selected.id,
          }),
        })</pre></li>
</ol>
<p>Once the submit event has been invoked, a <code>POST</code> <code>/book-flight</code> request is made with the necessary JSON headers and body parameters. The <code>this.selected.id</code> variable will reference our parent’s element’s <code>x-data</code> model. </p>
<ol>
<li value="6">After the fetch, we <a id="_idIndexMarker791"/>will need to handle the appropriate responses. Let <a id="_idIndexMarker792"/>us start with a successful path and add the following code just after the fetch block:<pre>          .then(async (response) =&gt; {
            const { headers, ok, message, body } = 
             response;
            const isJson = headers.get('content-
             type')?.includes('application/json');
            const data = isJson ? await 
             response.json() : await response.text();
            if (!ok) {
              return Promise.reject(isJson ? 
              Object.values(data) : data);
            }
           // boarding ticket was successfully created
            this.formMessages = [];
            this.data = {
              email: "",
              name: "",
              seat: this.data.seat,
              success: true,
            }
          })</pre></li>
</ol>
<p>This method <a id="_idIndexMarker793"/>will check whether the data is JSON or plain text. Then, it will <a id="_idIndexMarker794"/>check whether the response is OK (and return a rejected promise if it returned errors). If the ticket was successfully created, we will reset the email, name, and seat to their initial values and set <code>success</code> to <code>true</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">We are setting the name and email to empty strings in the previous example to clear out the current form’s data. If we were to omit these explicit values, then AlpineJS would show the name and email inputs with their previous values when the <code>flightForm</code> appears on the screen.</p>
<ol>
<li value="7">After that, we can add the <code>catch</code> and <code>finally</code> blocks and close the remaining script:<pre>          .catch((err) =&gt; {
            this.formMessages = Array.isArray(err) ? 
             err : [err];
          })
          .finally(() =&gt; {
            this.loading = false;
          });
      },
    };
  }
&lt;/script&gt;</pre></li>
</ol>
<p>The caught error will propagate itself to <code>formMessages</code> as an array and regardless of success or failure, we will want to use the <code>finally</code> block to set the loading state to <code>false</code>.</p>
<ol>
<li value="8">Let’s return <a id="_idIndexMarker795"/>to the section with the two columns that we created <a id="_idIndexMarker796"/>earlier – in the second column, we will want to add a success message as well as the form itself. We will start with a section that displays information about the currently selected flight for our form:<pre>&lt;div x-show="!!selected.id"&gt;
  &lt;section class="hero is-info"&gt;
    &lt;div class="hero-body"&gt;
      &lt;p class="title"&gt;
        &lt;span x-text="selected.originAirport"&gt;&lt;/span&gt; &amp;#8594; &lt;span x-text="selected.destinationAirport"&gt;
        &lt;/span&gt;
      &lt;/p&gt;
      &lt;p class="subtitle"&gt;
        Departs at &lt;span x-text="selected.
        departureTime"&gt;&lt;/span&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;</pre></li>
</ol>
<p>The <code>x-show</code> attribute will hide an element if the value yields as <code>true</code>. The next few elements <a id="_idIndexMarker797"/>will use the data from our selected object property <a id="_idIndexMarker798"/>from the parent element’s <code>x-data</code> model. This element should be hidden until we select a flight. The <code>x-text</code> attribute will tell AlpineJS to render the element’s <code>innerText</code> to the value associated with the attribute (for example, <code>selected.originAirport</code>, or <code>selected.departureTime</code>).</p>
<ol>
<li value="9">Once the <code>hero</code> section is setup, we will add a form for the success message when a flight is successfully booked:<pre>&lt;form x-data="flightForm()" @submit.prevent="submit"&gt;
  &lt;div x-show="!!data.success"&gt;
    &lt;section class="hero is-primary"&gt;
      &lt;div class="hero-body"&gt;
        &lt;p class="title"&gt;
          Your boarding ticket has been created!
        &lt;/p&gt;
        &lt;p class="subtitle"&gt;
          Your seat for this flight is &lt;span 
           x-text="data.seat"&gt;&lt;/span&gt;
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/section&gt;
    &lt;div class="mt-4 field is-grouped is-grouped-  
     centered"&gt;
      &lt;p class="control"&gt;
        &lt;a class="button is-light" 
          x-on:click="selected = {}; data.success =     
          false; data.seat = ''"&gt;
          OK
        &lt;/a&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;</pre></li>
</ol>
<p>We encapsulated <a id="_idIndexMarker799"/>the states of <code>flightForm</code> and the events <a id="_idIndexMarker800"/>within the <code>&lt;form&gt;</code> tag. The <code>@submit.prevent="submit"</code> attribute will tell AlpineJS to prevent bubble propagation when submitting the event and to use our <code>submit</code> function inside of the <code>flightForm</code> method. </p>
<p>Next, we will check to see whether <code>success</code> is <code>true</code> and if so, show the order confirmation section. We will want some way to reset the state once a client has purchased a ticket (in case they want to purchase another ticket), which is what the <code>x-on:click</code> event does when we click the <strong class="bold">OK</strong> button.</p>
<ol>
<li value="10">Now, for the actual form, we will check to see whether <code>data.success</code> is <code>false</code> and if so, show the form with some basic fields. Inside the same <code>form</code> attribute, add the following:<pre>&lt;div x-show="!data.success"&gt;
  &lt;div class="field pt-4"&gt;
    &lt;label class="label"&gt;Full Name&lt;/label&gt;
    &lt;div class="control"&gt;
      &lt;input class="input" type="text" x-model=
       "data.name" placeholder="e.g Alex Smith"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;label class="label"&gt;Your Email&lt;/label&gt;
    &lt;div class="control"&gt;
      &lt;input class="input" type="email" 
        x-model="data.email"
        placeholder="e.g. alexsmith@avalon-
        airlines.com"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;label class="label"&gt;Seat Selection&lt;/label&gt;
    &lt;div class="control"&gt;
      &lt;input class="input" type="text" 
        x-model="data.seat" placeholder="e.g. 1A"&gt;
    &lt;/div&gt;
  &lt;/div&gt;</pre></li>
</ol>
<p>The <code>x-model</code> attribute <a id="_idIndexMarker801"/>will bind the input’s value with <a id="_idIndexMarker802"/>the <code>x-data</code> object (for example, <code>x-model="data.email"</code> will associate itself with the <code>data.email</code> attribute of <code>flightForm</code>). </p>
<ol>
<li value="11">Just below this code, we can add the call-to-action buttons for purchasing a ticket or canceling the order:<pre>&lt;div class="field is-grouped is-grouped-centered"&gt;
  &lt;p class="control"&gt;
    &lt;button type="submit" :disabled="loading" 
    class="button is-primary"&gt;
      Purchase Ticket
    &lt;/button&gt;
  &lt;/p&gt;
  &lt;p class="control"&gt;
    &lt;a class="button is-light" x-on:click="selected = {}; 
    data.success = false; formMessages = []"&gt;
      Cancel
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/div&gt;</pre></li>
</ol>
<p>The <code>:disabled</code> attribute is an AlpineJS shorthand code for disabling a particular element <a id="_idIndexMarker803"/>under a specific condition (in our case, this would <a id="_idIndexMarker804"/>be the loading variable). Clicking on the <code>data.success</code> variable to <code>false</code>, and make <code>formMessages</code> into an empty array.</p>
<ol>
<li value="12">Finally, we can add a template for handling our <code>formMessages</code> variable and close the remaining HTML tags:<pre>                &lt;template x-for="message in 
                 formMessages"&gt;
                  &lt;article class="message is-warning"&gt;
                    &lt;div class="message-header"&gt;
                      &lt;p&gt;A correction is required&lt;/p&gt;
                    &lt;/div&gt;
                    &lt;div x-text="message" class=
                     "message-body"&gt;&lt;/div&gt;
                  &lt;/article&gt;
                &lt;/template&gt;
              &lt;/div&gt;
            &lt;/form&gt;</pre></li>
</ol>
<p>Our frontend <a id="_idIndexMarker805"/>application should now be complete. If we visit <code>http://localhost:3000/</code>, it should <a id="_idIndexMarker806"/>look similar to <em class="italic">Figure 10.2</em>. Clicking on the <strong class="bold">Book Flight</strong> button should generate something similar to <em class="italic">Figure 10.3</em>:</p>
<div><div><img alt="Figure 10.2 – Welcome to Avalon Airlines! " height="374" src="img/Figure_10.02_B17841.jpg" width="867"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Welcome to Avalon Airlines!</p>
<div><div><img alt="Figure 10.3 – Booking a flight " height="775" src="img/Figure_10.03_B17841.jpg" width="1255"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Booking a flight</p>
<p>When <a id="_idIndexMarker807"/>we click on <strong class="bold">Purchase Ticket</strong> without entering any information, we <a id="_idIndexMarker808"/>should be greeted with a few warnings, as shown in <em class="italic">Figure 10.4</em>:</p>
<div><div><img alt="Figure 10.4 – Warnings from Sequelize " height="1115" src="img/Figure_10.04_B17841.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Warnings from Sequelize</p>
<p>When we <a id="_idIndexMarker809"/>enter in the appropriate information, the application will <a id="_idIndexMarker810"/>create a new customer and boarding ticket along with a success message, as shown in <em class="italic">Figure 10.5</em>:</p>
<div><div><img alt="Figure 10.5 – The success message " height="681" src="img/Figure_10.05_B17841.jpg" width="1484"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – The success message</p>
<p>Visiting the <a id="_idIndexMarker811"/>admin dashboard will confirm that our ticket and customer <a id="_idIndexMarker812"/>account were created successfully. We can see the boarding tickets at <code>http://localhost:3000/admin/resources/BoardingTickets</code> (remember to log in with appropriate credentials), similar to <em class="italic">Figure 10.6</em>:</p>
<div><div><img alt="Figure 10.6 – The admin dashboard showing the boarding tickets " height="553" src="img/Figure_10.06_B17841.jpg" width="1067"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – The admin dashboard showing the boarding tickets</p>
<p>It looks as <a id="_idIndexMarker813"/>though our application is ready to be deployed. In the next <a id="_idIndexMarker814"/>section, we will go over the requirements for setting up an environment on a cloud application platform such as Fly.io.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor190"/>Deploying the application</h1>
<p>Before we begin, we will want to make sure our project is initialized as a git repository, if your machine <a id="_idTextAnchor191"/><a id="_idIndexMarker815"/>does not have git installed you may find instruction <a id="_idIndexMarker816"/>on how to install the binary here <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>. If you’ve been following along, and haven’t yet initialized your project as a git repository, you can do so by running the following command in your project’s root directory:</p>
<pre>git init</pre>
<p>For the deployment process, we will use a cloud hosting service <a id="_idIndexMarker817"/>called <strong class="bold">Fly.io</strong> (<a href="https://fly.io/">https://fly.io/</a>). Fly.io offers a useful command line tool to help us register and authenticate into an account in addition to making application deployments easier. Detailed <a id="_idIndexMarker818"/>instructions on getting started with Fly.io’s CLI can be found at <a href="https://fly.io/docs/hands-on/install-flyctl/">https://fly.io/docs/hands-on/install-flyctl/</a>.</p>
<p>For MacOS users, with Homebrew, we can install the binary with this command:</p>
<pre>brew install flyctl</pre>
<p>Linux users can install the binary with this command:</p>
<pre>curl -L https://fly.io/install.sh | sh</pre>
<p>For Window users, Fly.io recommends using the PowerShell for downloading the binary:</p>
<pre>iwr https://fly.io/install.ps1 -useb | iex</pre>
<p>Once the binary installation has been completed, we will need to login, or register a new account, and then create a new application. If you have not created your free Fly.io account previously, we can use the following command to get started</p>
<pre>flyctl auth signup</pre>
<p>Alternatively, we can authenticate ourselves if we had registered an account previously:</p>
<pre>flyctl auth login</pre>
<p>After we have authenticated, we can now deploy our application:</p>
<pre>flyctl launch</pre>
<p>This command will ask us for an application name and region which we can leave these values as blank or its default value. We will also be asked if we want to create a Postgres database and deploy the application right away which we should decline by entering in the “n” key as a response. The following should look similar to your screen:</p>
<pre>Creating app in /Users/daniel/Documents/Book/code/ch10
Scanning source code
Detected a NodeJS app
Using the following build configuration:
	Builder: heroku/buildpacks:20
? App Name (leave blank to use an auto-generated name):
Automatically selected personal organization: Daniel Durante
? Select region: iad (Ashburn, Virginia (US))
Created app nameless-shape-3908 in organization personal
Wrote config file fly.toml
? Would you like to set up a Postgresql database now? No
? Would you like to deploy now? No
Your app is ready. Deploy with `flyctl deploy`</pre>
<p>Don’t deploy <a id="_idIndexMarker819"/>the application just yet. We will need to enable MySQL with our Fly.io application first. At the moment, Fly.io does not offer a way to sidecar a MySQL database within the same application as our web application. The solution for this is to create a separate a Fly.io application with MySQL only.</p>
<p>In the project’s root directory, we will want to create a new folder called, “fly-mysql” and run the following command within that folder:</p>
<pre>fly launch</pre>
<p>Respond to the questions the same way we originally did in the previous <code>fly launch</code> command. Now, our database will need to be stored somewhere, so let us begin by creating a volume on Fly.io and choosing the same region as the previous step. Within the <em class="italic">fly-mysql</em> directory run the following command to create a new volume:</p>
<pre>fly volumes create mysqldata --size 1</pre>
<p class="callout-heading">Note</p>
<p class="callout">The “--size” parameter for <code>fly volumes create &lt;name&gt;</code> references the number of gigabytes as its unit. For more information about the <code>volumes</code> Fly.io subcommand more information <a id="_idIndexMarker820"/>can be found at <a href="https://fly.io/docs/reference/volumes/">https://fly.io/docs/reference/volumes/</a>.</p>
<p>Now, we can <a id="_idIndexMarker821"/>set our passwords for the MySQL instance (replace “password” with something more appropriate):</p>
<pre>fly secrets set MYSQL_PASSWORD=password MYSQL_ROOT_PASSWORD=root_password</pre>
<p>Throughout this process, Fly.io has created a <code>fly.toml</code> file for its applications (one for our web application in the project’s root directory and another for MySQL in the <code>fly-mysql</code> directory). This is similar to Heroku’s <code>Procfile</code> or CloudFlare’s <code>wrangler.toml</code> file. Within the fly.toml file we will want to replace its contents, after the first line (the application’s name) or starting from the <code>kill_signal</code> line, with the following:</p>
<pre class="source-code">
kill_signal = “SIGINT”
kill_timeout = 5
[mounts]
  source=”mysqldata”
  destination=”/data”
[env]
  MYSQL_DATABASE = “avalon_airlines”
  MYSQL_USER = “avalon_airlines”
[build]
  image = “mysql:5.7”
[experimental]
  cmd = [
    “--default-authentication-plugin”,
    “mysql_native_password”,
    “--datadir”,
    “/data/mysql”
  ]</pre>
<p>After modifying <a id="_idIndexMarker822"/>the file’s contents, we can scale our MySQL application to have 256 MB of RAM and deploy the MySQL instance:</p>
<pre>fly scale memory 256
fly deploy</pre>
<p>Now, going back to the project’s root directory, we can add a <code>DATABSE_URL</code> environment secret to our web application’s Fly.io configuration by running the following command:</p>
<pre>flyctl secrets set DATABASE_URL=mysql://avalon_airlines:&lt;YOUR PASSWORD&gt;@&lt;YOUR MYSQL’S APPLICATION NAME&gt;.internal/avalon_airlines</pre>
<p>Replace <code>YOUR_PASSWORD</code> with the password that was previously set for the MySQL’s application’s <code>MYSQL_PASSWORD</code> secret. Your MySQL’s application name should be available in the <code>fly-mysql/fly.toml</code> file marked with the <code>app</code> key.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you lose track of your application’s names, the Fly.io CLI provides a way to list all of your account’s application using the <code>flyctl apps list</code> command.</p>
<p>We will need to make some modifications to the <code>package.json</code> file. Since the application’s builder is using Heroku’s buildpacks, the application will be built with whatever the latest <code>start</code> script by <a id="_idIndexMarker823"/>default which currently uses nodemon. We can ensure the application is <a id="_idIndexMarker824"/>built with the proper Node.js version, and removing the nodemon dependency by replacing the <code>start</code> script within <code>package.json</code> to look like the following:</p>
<pre class="source-code">
  “scripts”: {
    “start”: “node index.js”,
    “dev”: “nodemon index.js”
  },
  “engines”: {
    “node”: “16.x”
  },</pre>
<p>Now, for when we are developing the application locally, we will want to execute <code>npm run dev</code> instead of <code>npm run start</code>. </p>
<p class="callout-heading">Note</p>
<p class="callout">More information, and caveats, for <a id="_idIndexMarker825"/>Heroku’s Node.js buildpack can be found at <a href="https://devcenter.heroku.com/articles/nodejs-support">https://devcenter.heroku.com/articles/nodejs-support</a>.</p>
<p>From the Avalon Airlines project, we would need to open and modify the <code>config/index.js</code> file and replace the production object with the appropriate database connection values:</p>
<pre class="source-code">
    “production”: {
        “use_env_variable”: “DATABASE_URL”,
        “dialect”: “mysql”
    }</pre>
<p>Fly.io will deploy within a container cluster that exposes ports from a dynamic range. Due to this stipulation, we are required to modify the <code>app.listen(3000, …)</code> at the bottom of <code>index.js</code>:</p>
<pre class="source-code">
app.listen(process.env.PORT || 3000, function () {
    console.log(“&gt; express server has started”);
});</pre>
<p>This will use the <code>PORT</code> environment variable, and default to a value of 3000 if the environment variable is not found, exposing our Express application properly on Fly.io’s ecosystem. There is <a id="_idIndexMarker826"/>one more change on the project root directory within the <code>fly.toml</code> file we will need to replace the <code>[env]</code> block with the following:</p>
<pre class="source-code">
[env]
  PORT = “8080”
  NODE_ENV = “production”</pre>
<p>Everything else should remain the same, and now, we can deploy and open our application:</p>
<pre>flyctl deploy
flyctl open</pre>
<p class="callout-heading">Note</p>
<p class="callout">You may receive a similar error as, “Cannot find module 'sequelize',” this can be from a third-party application dependency such as Admin.js. As a temporarily solution we can manually install, and save, the original Sequelize library by entering <code>npm i sequelize</code> into your terminal within the projects directory and re-deploy your application.</p>
<p>You may notice that the website looks a little bare, we can head over to the <code>/admin</code> dashboard route and start populating our airplane inventory and flight schedules. Once that is done, we can start processing and booking tickets for Avalon Airlines!</p>
<div><div><img alt="Figure 10.7 – The Avalon Airlines homepage with a flight scheduled! " height="555" src="img/Figure_10.7_B17841.jpg" width="1216"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – The Avalon Airlines homepage with a flight scheduled!</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, we went through the process of adding a frontend page with the ability to generate a list of flight schedules and create boarding tickets. We also learned how to deploy our application to a cloud application environment.</p>
<p>Congratulations! We have completed the process of becoming familiar with Sequelize to deploying a Sequelize-based web application. In a real-world scenario, we would want to make a few more adjustments, such as securely storing database credentials, setting up transactional emails, adding more pages, processing credit cards, and having an actual seating inventory management system. At this point, the rest is up to you and only the sky is the limit! Hopefully, this will be a satisfying start for you! It certainly should be, because the Avalon Airlines board members are pleased so far, and they’ve decided to fund our next round.</p>
</div>
</div></body></html>