- en: Real-Time Communication with Socket.IO and ExpressJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NodeJS events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Socket.IO events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Socket.IO namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and joining to Socket.IO rooms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing middleware for Socket.IO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Socket.IO with ExpressJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ExpressJS middleware in Socket.IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB.
    You will also need to install Git, in order use the Git repository of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/xfyDBn](https://goo.gl/xfyDBn)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications usually require real-time communication where data is
    continuously flowing from client to server and vice versa with (almost) no delay.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 WebSocket Protocol was created to fulfill this requirement. WebSocket
    uses a single TCP connection that is kept open even when the server or client
    is not sending any data. That means, while a connection between the client and
    the server exists, data can be sent at any time without having to open a new connection
    to the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Real-time communication has several applications from building chat applications
    to multi-user games, where the response time is really important.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on learning how to build a real-time web application
    using Socket.IO ([https://socket.io](https://socket.io)) and understanding the
    Node.js event-driven architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO is one of the most used libraries for implementing real-time communication.
    Socket.IO uses WebSocket whenever possible but falls-back to other methods when
    WebSocket is not supported on a specific web browser. Because you probably want
    to make your application accessible from any web browser, having to work directly
    with WebSocket may not seem like a good idea.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Node.js events
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has an event-driven architecture. Most of Node.js' core API is built
    around `EventEmitter`. This is a Node.js module that allows `listeners` to subscribe
    to certain named events that can be triggered later by an **emitter**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own event emitter easily by just including the events Node.js
    module and creating a new instance of `EventEmitter`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can trigger the `welcome` event by using the `emit` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is actually, pretty simple. One of the advantages is that you can subscribe
    multiple listeners to the same event, and they will get triggered when the `emit`
    method is used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `EventEmitter` API provides several helpful methods that give you more
    control to handle events. Check the official Node.js documentation to see all
    information about the API: [https://nodejs.org/api/events.html](https://nodejs.org/api/events.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will create a class that will extend `EventEmitter`, and
    which will contain its own instance methods to trigger listeners attached to a
    specific event. First, create a new project by opening a Terminal and running
    the following line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class that extends `EventEmitter` and define two instance methods
    called `start` and `stop`. When the `start` method is called, it will trigger
    all listeners attached to the `start` event. It will keep the starting time using
    `process.hrtime`. Then, when the `stop` method is called, it will trigger all
    listeners attached to the `stop` event passing as an argument the difference in
    time since the `start` method was called:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `timer.js`
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the events NodeJS module:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define two constants that we will use to convert the returned value of `process.hrtime`
    from seconds to nanoseconds and then to milliseconds:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define a class named `Timer` with two instance methods:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new instance of the previously defined class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Attach an event listener to the `start` event that will have a loop that will
    perform multiplications. Afterwards, it will call the `stop` method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Attach an event listener to the `stop` event that will print the time it took
    for the event `start` to execute all its attached listeners:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the `start` method to trigger all `start` event listeners:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new Terminal and run:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `start` method is executed, it keeps the starting time using `process.hrtime`,
    which returns the current high-resolution real time in an array of two items,
    where the first item is a number that represents seconds while the second item
    is another number that represents nanoseconds. Then, it triggers all event listeners
    attached to the `start` event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, when the `stop` method is executed, it uses the result of
    previously calling `process.hrtime` as an argument to the same function, which
    returns the difference in time. This is useful to measure the time from when the
    `start` method was called until the time when the `stop` method was called.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common mistake is to assume that events are called asynchronously. It is
    true that defined events can be called at any time. However, they are still executed
    synchronously. Take the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The outputs for the preceding code will be shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you have a loop running inside one of your events, the next event won't get
    called until the previous one finishes executing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Events can be made asynchronous by simply adding an `async`Â function as an
    event listener. By doing so, every function will still be called in order from
    the first `listener` defined to the last. However, the emitter won''t wait for
    the first `listener` to finish its execution to call the next listener. That means
    you cannot guarantee that the output will always be in the same order, for instance:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The outputs for the preceding code will be shown as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Asynchronous functions allow us to write non-blocking applications. If implemented
    correctly, you won't run into problems like this above.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`EventEmitter` instances have a method called `listeners` which when executed,
    providing an event name as an argument, returns an array of the attached listeners
    for that specific event. We can use this method in a way to allow `async` functions
    to be executed in the order they were attached, for instance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will execute and display output in the order they were attached:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Understanding Socket.IO events
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO is an event-driven module or library, and, as you probably guessed,
    is based on `EventEmitter`. Everything in Socket.IO works with events. An event
    is triggered when a new connection is made to the Socket.IO server and an event
    can be emitted to send data to the client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO server API differs from the Socket.IO client API. However, both
    work with events to send data from client to server and vice versa.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO server events
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO uses a single TCP connection to a single path. That means, by default,
    the connection is made to the URL `http[s]://host:port/socket.io`. However, within
    Socket.IO, it allows you to define **namespaces**. That means, different end-points
    but the connection will still remain a single URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: By default, Socket.IO Server uses the `"/"` or root namespace
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, define multiple instances and listen to different URLs as
    well. However, we will assume, for the purpose of this recipe, that only one connection
    is created.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The Socket.IO namespace has the following events that your application can
    subscribe to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`connect` or `connection`: When a new connection is made, this event is fired.
    It provides a **socket object** to the listener as the first parameter that represents
    the new connection with the client'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Socket.IO socket object has the following events:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`disconnecting`: This event is emitted when the client is going to be disconnected
    from the server. It provides to the listener a parameter that specifies the reason
    for the disconnection'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`disconnected`: Similar to the disconnecting event. However, this event is
    fired after the client has been disconnected from the server:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`error`: This event is emitted when an error occurs within events'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`[eventName]`: A user-defined event that will get fired when the client emits
    an event with the same name. The client can emit an event providing data in the
    arguments. On the server, the event will be fired and it will receive the data
    sent by the client'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket.IO client events
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A client doesn't necessarily need to be a web browser. We could write a Node.js
    Socket.IO client application as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The Socket.IO client events are extensive and give a lot of control over your
    application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`connect`: This event gets fired when there is a successful connection to the
    server'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`connect_error`: This event is emitted when there is an error when trying to
    connect or reconnect to the server'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`connect_timeout:` By default, the timeout set before a `connect_error` and
    `connect_timeout` is emitted is 20 seconds. After this, the Socket.IO client may
    try to reconnect to the server once again:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`disconnect`: This event is fired when the client is disconnected from the
    server. An argument is provided specifying the reason of the disconnection:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`reconnect`: Fired after a successful reconnection attempt. An argument is
    provided that specifies how many attempts happened before the connection was successful:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`reconnect_attempt` or `reconnecting`: This event is emitted when trying to
    reconnect to the server. An argument is provided specifying the number of current
    attempts to connect to the server:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`reconnect_error`: Similar to the `connect_error` event. However, it gets fired
    only if there is an error when trying to reconnect to the server:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`reconnect_failed:` By the default, the maximum number of attempts is set to
    `Infinity`. That means, it is unlikely that this event will ever get fired. However,
    we can specify an option to limit the maximum number of connection attempts. Let''s
    see that later:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ping`: In short, this event gets fired to check if the connection with the
    server is still alive:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`pong`: Fired when a response is received from the server after the event `ping`
    is fired. An argument is provided specifying the latency or response time:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`error`: This event is fired when an error occurs within events:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`[eventName]`: A user-defined event that gets fired when the event is emitted
    in the server. The arguments provided by the server will be received by the client.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will build a Socket.IO server and a Socket.IO client using
    what you have just learned about events. Before you start, create a new `package.json`
    file with the following content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Socket.IO server will be built to respond to a single event named `time`.
    When the event is fired, it will get the server's current time and emit another
    event named `"got time?"` providing two arguments, the current `time` and a `counter`
    that specifies how many times a request was made.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `simple-io-server.js`
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO module and initialize a new server:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the URL path where connections will be made:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the root or `"/"` namespace:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When a new connection is made, initialize a `counter` variable to `0`. Then,
    add a new listener to the `time` event that will increase the `counter` by one,
    every time there is a new request, and emit the `"got time?"` event that will
    be later defined on the client side:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listen on port `1337` for new connections:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save the file
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, build a Socket.IO client that will connect to our server:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `simple-io-client.js`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO client module:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize a new Socket.IO client providing the server URL and an options object
    where we will define the path used in the URL where the connections will be made:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add an event listener to the `connect` event. Then, when a connection is made,
    using a `for` loop, emit the `time` event 5 times:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add an event listener to the `"got time?"` event that will expect to receive
    two arguments the time and a counter that specifies how many requests were made
    to the server, then print on the console:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save the file
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a Terminal and run first the Socket.IO server:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open another terminal and run the Socket.IO client:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything works with events. Socket.IO allows events to be defined in the server
    side that the client can emit. On the other side, it also allows to define events
    in the client side that the server can emit.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user-defined event is emitted by the server side, the data is sent to
    the client. The Socket.IO client checks whether there is a listener for that event
    first. Then, if there is a listener, it will get triggered. The same thing happens
    the other way around when a user-defined event is emitted by the client side:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: An event listener `time` was added in our Socket.IO server's **socket object**
    which can be emitted by the client side
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An event listener `"got time?"` was added in our Socket.IO Client which can
    be emitted by the server side
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On connection, the client emits the `time` event first
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, the `time` event is fired on the server side which will emit the
    `"got time?"` event providing two arguments, the current server's `time` and a
    `counter` that specifies how many times a request was made
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `"got time?"` event is fired on the client side receiving two arguments
    that were provided by the server, the `time` and a `counter`
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with Socket.IO namespaces
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces are a way of separating the business logic of your application while
    reusing the same TCP connection or minimizing the need for creating new TCP connections
    for to implement real-time communication between the server and the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces look pretty similar to ExpressJS'' route paths:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, as mentioned in previous recipes, these are not related to URLs. By
    default, a single TCP connection is created at this URL `http[s]://host:port/socket.io`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusing the same event names is a good practice when using namespaces. For
    example, let''s suppose that we have a Socket.IO server that we use to emit a
    `setWelcomeMsg` event when the client emits a `getWelcomeMsg` event:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, we defined a listener for the event `getWelcomeMsg` in two
    different namespaces:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: If the client is connected to the English or `/en` namespace, when the `setWelcomeMsg`
    event is fired, the client will receive `"Hello World!"`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, if the client is connected to the Spanish or `/es` namespace,
    when the `setWelcomeMsg` event is fired, the client will receive `"Hola Mundo!"`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how to work with two different namespaces that
    contain the same event names. Before you start, create a new `package.json` file
    with the following content:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Socket.IO server that will fire a `data` event and send an object containing
    two properties, `title` and `msg`, that will be used to populate HTML content
    in the selected language. Use namespaces to separate and send different data according
    to the language that the client chooses, English or Spanish.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `nsp-server.js`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO npm module and the required modules for creating an HTTP
    server:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `http` module to create a new HTTP server that will serve an HTML file
    you will create later as a Socket.IO client:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Specify the path new connections will be made to:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For the `"/en"` namespace, add a new event listener, `getData`, which when
    fired will emit a `data` event on the client side and send an object including
    a `title` and a `msg` property in the English language:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the `"/es"` namespace, do the same. However, the object sent to the client
    will include a `title` and a `msg` property in the Spanish language:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the underlying
    HTTP server:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Save the file.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, create a Socket.IO client that will connect to our server and populate
    HTML content based on the data received from the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `nsp-client.html`
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, specify the document type as HTML5\. Next to it, add an `html` tag and
    set the language to English. Inside the `html` tag, include the `head` and `body`
    tags as well:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Inside the `body` tag, add the first three elements: a heading (`h1`) that
    will contain the title of the content, a `p` tag that will include a message from
    the server, and a `button` that will be used to switch to a different namespace.
    Also, include the Socket.IO client library. The Socket.IO server will make the
    library file available at this URL: http[s]://host:port/socket.io/socket.io.js
    . Then, also include as well the `babel` standalone library which will transform
    the code in the next steps into JavaScript code that can run in all browsers:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside the `body`, after the last `script` tags, add another `script` tag and
    set its type to `"text/babel"`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After that, inside the `script` tag, add the following JavaScript code
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define three constants that will contain a reference to the elements we have
    created in the `body`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define a Socket.IO client manager. It will help us to create sockets with the
    provided configuration:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new socket that will connect to the `"/en"` namespace. We will assume
    that this is the default connection:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Reserve two connections for namespaces `"/en"` and `"/es"`. A reserved connection
    will allow us to switch to a different namespace without the need of to create
    a new TCP connection:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add an event listener that, once the socket is connected, will emit a `getData`
    event to request data from the server:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add an event listener for the `data` event that will get triggered when the
    client received data from the server:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add an event listener for the `button`. When it gets clicked, switch to a different
    namespace:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Save the file
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new terminal and run:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the web browser, navigate to:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's test it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see your previous work in action, follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Once you navigate to `http://localhost:1337/` in your web browser, click on
    the `"Get Content in Spanish"` button to switch to the Spanish namespace
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `"Get Content in English"` button to switch back to the English
    namespace
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is what happens on the server side:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We defined two namespaces, `"/en"` and `"/es"`, then added a new event listener,
    `getData`, to the **socket object.**
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `getData` event is fired in any of the two defined namespaces, it will
    emit a data event and send an object, that contains a title and a message property,
    to the client
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the client side, inside the script tag in our HTML document:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, a new socket is created for the namespace `"/en"`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At the same time, we created two new **sockets** for the namespaces `"/en"`
    and `"/es"`. They will act as reserved connections:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After, an event listener connect was added that sends a request to the server
    on connection
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, another event listener data was added that is fired when data is received
    from the server
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the event listener that handles onclick events for our button, we change
    the nsp property to switch to a different namespace. However, for this to happen,
    we had to disconnect the **socket** first, and call the open method to make a
    new connection again using the new namespace
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see one of the confusing parts about reserved connections. When you
    create one or more **sockets** in the same namespace, the first connection is
    reused, for example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: On the client side, if there were no reserved connections, then switching to
    a namespace that was not used before would result in a new connection being created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious, remove these two lines from the `nsp-client.html` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Afterwards, restart or run the Socket.IO server again. You will notice that
    there is a slow response when switching to a different namespace because a new
    connection is created instead of being reused.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative way of achieving the same goal. We could have created
    two sockets that point to two different namespaces, `"/en"` and `"/es"`. Then,
    we could have added two event listeners connect and data to each socket. However,
    because the first and second socket would contain the same event names and receive
    data in the same format from the server, we would have gotten repeated code. Imagine
    the case if we had to do the same for five different namespaces that have the
    same event names and receive data in the same format, there would be too many
    repeated lines of code. This is where switching namespaces and reusing the same
    socket object is helpful. However, there may be cases were two or more different
    namespaces have different event names for different kinds of event, in that case,
    it is better to add event listeners for each of the namespaces separately. For
    example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the client side, you have probably noticed one thing that we didn't use before,
    `io.Manager`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: io.Manager
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This allows us predefine or configure how new connections will be created. The
    options defined in a `Manager`, as the URL, will be passed to the socket on initiation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTML file, inside a `script` tag, we created a new instance of `io.Manager`
    and passed two arguments; the server URL and an options object including a `path`
    property which indicates where new connections will be made:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To find out more about the `io.Manager` API visit the official documentation
    Website offer for Socket.IO [https://socket.io/docs/client-api/#manager](https://socket.io/docs/client-api/#manager).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we used the `socket` method to initialize and create a new Socket for
    the provided namespace:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This way, it is easier to work with several namespaces at the same time without
    having to configure each one of them with the same options.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Defining and joining Socket.IO rooms
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within namespaces, you can define rooms or channels that a socket can join and
    leave.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a room is created with a random un-guessable ID for the connected
    **socket**:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'On connection, when emitting an event, for example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'What happens underneath is similar to this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `join` method was used to include the socket inside a room. In this case,
    the socket ID is the joint room, and the only client connected to that room is
    the socket itself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Because a socket ID represents a unique connection with a client and, by default,
    a room with the same ID is created; all data sent by the server to that room will
    be received only by that client. However, if several clients or socket IDs join
    a room with the same name and the server sends data; all clients could be able
    to receive it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how to join a room and broadcast a message to
    all clients connected to that specific room. Before you start, create a new `package.json`
    file with the following content:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Socket.IO server that will notify all the connected clients to the `"commonRoom"`
    room when a new socket is connected.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `rooms-server.js`
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO NPM module and initialize a new HTTP server:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Specify the path where new connections will be made:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use the root namespace to listen for events:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Define a method that will be used to emit an `updateClientCount` event to all
    socket clients connected to the `"commonRoom"` providing as an argument the number
    of connected clients:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'On connection, all newly connected Socket clients will join the `commonRoom`.
    Then, the server will emit a `welcome` event. After this, notify all connected
    sockets to update the number of connected clients and also do the same operation
    once a client is disconnected:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the HTTP
    server:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Save the file.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build a Socket.IO client that will connect to the Socket.IO server
    and populate the HTML content with received data:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `rooms-client.html`
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Inside the script tag, add code in the following steps, starting from step 4
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define two constants that will make a reference to two HTML elements that we
    will update according to the data sent by the Socket.IO Server:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define a Socket.IO Client Manager:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use the root namespace which is the one used in the Socket.IO Server:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add an event listener for the `welcome` event that expects an argument that
    will contain a welcome message sent by the server:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add an event listener for the `updateClientCount` event that expects an argument
    that will contain the number of connected clients:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Save the file
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new Terminal and run:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'On the web browser, navigate to:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Without closing the previous tab or window, on the web browser, navigate once
    again to:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The number of connected clients in both tabs or windows should have increased
    to `2`
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending the same message or data, to more than one client, is called broadcasting.
    The method we have seen broadcasts a message to all clients, including the client
    that generated the request.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other several methods to broadcast a message. For instance:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Which will emit an `updateClientCount` event to all clients in `commonRoom`
    expect to the sender or the socket that originated the request.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list check the official documentation of Socket.IO emit cheatsheet:
    [https://socket.io/docs/emit-cheatsheet/](https://socket.io/docs/emit-cheatsheet/)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Writing middleware for Socket.IO
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket.IO allows us to define two kinds of middleware functions in the server
    side:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace middleware**: Registers a function that gets executed for every
    new connected Socket and has the following signature:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Socket middleware**: Registers a function that gets executed for every incoming
    Packet and has the following signature:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It works similarly to how ExpressJS middleware functions do. We can add new
    properties to the `socket` or `packet` objects. Then, we can call `next` to pass
    the control to the next middleware in the chain. If `next` is not called, then
    the `socket` won't be connected, or the `packet` received.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will build a Socket.IO server application where you will
    define middleware functions to restrict access to a certain namespace as well
    as restricting access to a certain socket based on some criteria. Before you start,
    create a new `package.json` file with the following content:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Socket.IO server application will expect the users to be logged-in in order
    for them to be able to connect to the `/home` namespace. Using socket middleware,
    we will also restrict access to `/home` namespace to a certain user:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `middleware-server.js`
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO library and initialize a new HTTP server:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Specify the path where new connections will be made:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Define an array of users that we will use as an in-memory database:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Define a method to verify if the provided username and password exist in the
    users array:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Define a namespace middleware function that will check whether the user is
    already logged-in. A client won''t be able to connect to a specific namespace
    using this middleware if they are not logged in:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Define two namespaces, one for `/login` and another for `/home`. The `/home`
    namespace will use our previously defined middleware function to check whether
    the user is logged in:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When a new socket is connected to `/login` namespace, first we will define
    a socket middleware function for checking all incoming packages and ban access
    to the `johntm` username. Then, we will add an event listener for the enter event
    that will expect to receive a plain object containing a username and password,
    and if they exist in the users array, then we set a session object which will
    tell whether the user is logged in. Otherwise, we will send a `loginError` event
    with an error message to the client:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listen on port 1337 for new connections and attach Socket.IO to the HTTP server:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Save the file
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build a Socket.IO client application that will connect to our Socket.IO
    Server and allow us to attempt to log in and test:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `middleware-cli.html`
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Inside the script tag, add the code in the following steps, starting from step
    4
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define three constant that will make a reference to the HTML elements that
    we will use to get input or display output:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Define a Socket.IO Manager:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Let''s define a namespace constant that will contain an object containing the
    Socket.IO namespaces `/home` and `/login`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Add an event listener for the connect event to the `/home` namespace. It will
    get triggered only when the `/home` namespace successfully connects to the server:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Add an event listener for the `loginSuccess` event to the `/login` namespace.
    It will ask the `/home` namespace to connect to the server again. If the user
    is logged in, then the server will allow this connection:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Add an event listener for the `loginError` event to the `/login` namespace.
    It will display error messages sent by the server:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add an event listener for the submit event for the login form. It will emit
    the enter event providing an object containing the username and password filled
    in the form:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Save the file
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test it...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see our previous work in action:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Socket.IO server first. Open a new terminal and run:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'On your web browser, navigate to:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: You will see a login form with two fields, `username` and `password`
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to log in with random invalid credentials. The following error is displayed:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, try to log in with `johntm` as `username` and any `password`. The following
    error is displayed:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'After that, log in with any of the two other valid credentials. For instance,
    using `jingxuan` as username and `qscwdvb` as password. The following title is
    displayed:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Integrating Socket.IO with ExpressJS
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO works well with ExpressJS. In fact, it's possible to run an ExpressJS
    application and a Socket.IO server using the same port or HTTP server.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how to integrate Socket.IO with ExpressJS. You
    will build an ExpressJS application that will serve an HTML file containing a
    Socket.IO client application. Before you start, create a new `package.json` file
    with the following content:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Socket.IO client application that will connect to the Socket.IO server,
    that you will build next, and display a welcome message sent by the server.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-view.html`
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Save the file
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, build an ExpressJS application and a Socket.IO server. The ExpressJS
    application will serve the previously created HTML file on the root path `"/"`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-server.js`
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize a new Socket.IO server application and an ExpressJS application:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Define the URL path where new connections will be made to the Socket.IO server:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Define a route method to serve our HTML file containing our Socket.IO client
    application:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Define a namespace `"/"` and emit a `welcome` event with welcome message:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Attach the Socket.IO to ExpressJS Server:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Save the file
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Terminal and run:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In your browser, visit:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO's `attach` method expects to receive a HTTP server as a parameter
    in order to attach the Socket.IO server application to it. The reason why we can
    attach Socket.IO to an ExpressJS server application is because the `listen` method
    returns the underlying HTTP server to which ExpressJS is connected.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, the `listen` method returns the underlying HTTP server. Then, it
    is passed as a parameter to the `attach` method. This way, we can share the same
    connection with ExpressJS.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that we can share the same underlying HTTP server between
    ExpressJS and Socket.IO. However, that is not all.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we define a Socket.IO path is actually useful when working with
    ExpressJS. Take the following example:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, we are using the same URL path for Socket.IO and ExpressJS.
    We accept new connections to the Socket.IO server on the `/socket.io` path, but
    we also send content for `/socket.io` using the GET route method.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though this preceding example won''t actually break your application,
    make sure to never use the same URL path to serve content from ExpressJS and accept
    new connections for Socket.IO at the same time. For instance, changing the previous
    code to this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'While you may expect your browser, when visiting `http://localhost:1337/socket.io/message`,
    to display `message`, that won''t be the case and you will see the following instead:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: That is because Socket.IO will interpret the incoming data first and it won't
    understand the data you just sent. In addition, your route handler will never
    be executed.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, the Socket.IO server also serves, by default, its own Socket.IO
    Client under the defined URL path. For example, try visiting [http://localhost:1337/socket.io/socket.io.js](http://localhost:1337/socket.io/socket.io.js)
    and you will be able to see the minimized JavaScript code of the Socket.IO client.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to server your own version of Socket.IO client or if it is included
    in the bundle of your application, you can disable the default behavior in your
    Socket.IO server application with the `serveClient` method:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: See also
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Using Express.js'' built-in middleware function for
    serving static assets*'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ExpressJS middleware in Socket.IO
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket.IO namespace middleware works pretty similar to how ExpressJS middleware
    does. In fact, the Socket Object also contains a `request` and a `response` object
    that we can use to store other properties in the same manner as we do with ExpressJS
    middleware functions:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Because ExpressJS middleware functions have the following signature:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We can safely execute the same function in a Socket.IO namespace middleware
    passing the necessary arguments:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: However, that doesn't mean that all ExpressJS middleware functions will work
    out of the box. For example, if an ExpressJS middleware function uses methods
    only available within ExpressJS, it may fail or have an unexpected behavior.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how to integrate the ExpressJS `express-session`
    middleware to share the session object between Socket.IO and ExpressJS. Before
    you start, create a new `package.json` file with the following content:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How to do it...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build a Socket.IO client application that will connect to a Socket.IO server
    you will build next. Include a form where the user can type a username and a password
    to attempt to log in. The Socket.IO client will only be able to connect to the
    `/home` namespace after the user is logged-in:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-cli.html`
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following HTML content:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Inside the script tag add the code in the next steps, starting from step 4
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define constants that make a reference to the HTML elements that we will use:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Define a Socket.IO Manager:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Define two namespaces, one for `/login` and another one for `/home`:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Add an event listener for the `welcome` event that will be triggered by the
    server side once a connection is allowed to the `/home` namespace:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Add an event listener for `loginSuccess` event that, when triggered, will ask
    the `/home` namespace to try and reconnect to the Socket.IO Server:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Add an event listener for `loginError` event that will display an error when
    invalid credentials are provided:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Add an event listener for `submit` event that will get triggered when submitting
    the form. It will emit an `enter` event with data containing the provided `username`
    and `password`:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Save the file.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build an ExpressJS application that will serve the Socket.IO client
    on the root path `"/"` and a Socket.IO server that will include the logic for
    logging the user:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-srv.js`
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize a new ExpressJS application and a Socket.IO server application.
    Also, include the `express-session` NPM module:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Define the path where new connections to Socket.IO server will be made:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Define an ExpressJS session middleware function with the given options:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Define a Socket.IO namespace middleware that will use the previously created
    session middleware to generate a session object:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Define two namespaces, one for `/home` and another for `/login`:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Define an in-memory database or array of objects that will contain `username`
    and `password` properties. These define which users are allowed to login:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Include the session middleware in ExpressJS:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Add a route method for `/home` path that will serve our previously created
    HTML document containing the Socket.IO client:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Use the session middleware in `/home` Socket.IO namespace. Then, check for
    every new socket if the user is logged in. If not, forbid the user to connect
    to this namespace:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Once a connection is made to the `/home` namespace, meaning that the user can
    log in, emits a `welcome` event with a welcome message that will be displayed
    to the user:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Use the Session Middleware in the `/login` Socket.IO namespace. Then, when
    the client emits an `enter` event with the provided username and password, it
    verifies the profile exists in the `users` array. If the user exists, set the
    `isLogged` property to `true` and the `username` property to the current user
    that has logged in:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listen on port `1337` for new connections and attach the Socket.IO server to
    it:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¨ç«¯å£`1337`ä¸çå¬æ°è¿æ¥å¹¶å°Socket.IOæå¡å¨éå å°å®ï¼
- en: '[PRE159]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Save the file
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¿å­æä»¶
- en: 'Open a new Terminal and run:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå¼ä¸ä¸ªæ°çç»ç«¯å¹¶è¿è¡ï¼
- en: '[PRE160]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In your browser, visit:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¨æ¨çæµè§å¨ä¸­ï¼è®¿é®ï¼
- en: '[PRE161]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Login with valid credentials. For example:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç¨ææçå­æ®ç»å½ãä¾å¦ï¼
- en: '[PRE162]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: If you logged in successfully, after refreshing the page, your Socket.IO client
    application will still be able to connect to `/home` and you will see a welcome
    message every time
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦ææ¨æåç»å½ï¼å¨å·æ°é¡µé¢åï¼æ¨çSocket.IOå®¢æ·ç«¯åºç¨ä»ç¶å¯ä»¥è¿æ¥å°`/home`ï¼å¹¶ä¸æ¯æ¬¡é½ä¼æ¾ç¤ºæ¬¢è¿ä¿¡æ¯
- en: How it works...
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®æ¯å¦ä½å·¥ä½ç...
- en: When the session middleware is used inside ExpressJS, after modifying the session
    object, the `save` method is automatically called at the end of the response.
    However, that is not the case when using the session middleware in Socket.IO namespaces,
    that is why we call the `save` method manually to save the session back to the
    store. In our case, the store is the memory where the sessions are kept until
    the server stops.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: å½å¨ExpressJSä¸­ä½¿ç¨sessionä¸­é´ä»¶æ¶ï¼å¨ä¿®æ¹sessionå¯¹è±¡åï¼`save`æ¹æ³ä¼å¨ååºç»ææ¶èªå¨è°ç¨ãç¶èï¼å¨ä½¿ç¨Socket.IOå½åç©ºé´ä¸­çsessionä¸­é´ä»¶æ¶å¹¶éå¦æ­¤ï¼è¿å°±æ¯ä¸ºä»ä¹æä»¬æå¨è°ç¨`save`æ¹æ³å°sessionä¿å­åå­å¨å¨ãå¨æä»¬çä¾å­ä¸­ï¼å­å¨å¨æ¯åå­ï¼ä¼è¯å¨æ­¤å¤ä¿æï¼ç´å°æå¡å¨åæ­¢ã
- en: Forbidding access to certain namespaces based on specific conditions is possible
    thanks to Socket.IO namespace middleware. If the control is not passed to the
    `next` handler, then the connection is not made. That's why after the login is
    successful, we ask the `/home` namespace to attempt to connect again.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: åºäºç¹å®æ¡ä»¶ç¦æ­¢è®¿é®æäºå½åç©ºé´æ¯å¯è½çï¼è¿è¦å½åäºSocket.IOå½åç©ºé´ä¸­é´ä»¶ãå¦ææ§å¶ææ²¡æä¼ éç»`next`å¤çå¨ï¼é£ä¹è¿æ¥å°±ä¸ä¼å»ºç«ãè¿å°±æ¯ä¸ºä»ä¹å¨ç»å½æååï¼æä»¬è¦æ±`/home`å½åç©ºé´åæ¬¡å°è¯è¿æ¥ã
- en: See also
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åè§
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Writing middleware functions*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ç¬¬äºç« ](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml)ï¼*ä½¿ç¨ExpressJSæå»ºWebæå¡å¨*ï¼é¨å*ç¼åä¸­é´ä»¶å½æ°*'
