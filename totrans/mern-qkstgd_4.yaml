- en: Real-Time Communication with Socket.IO and ExpressJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NodeJS events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Socket.IO events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Socket.IO namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and joining to Socket.IO rooms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing middleware for Socket.IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Socket.IO with ExpressJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ExpressJS middleware in Socket.IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB.
    You will also need to install Git, in order use the Git repository of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/xfyDBn](https://goo.gl/xfyDBn)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications usually require real-time communication where data is
    continuously flowing from client to server and vice versa with (almost) no delay.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 WebSocket Protocol was created to fulfill this requirement. WebSocket
    uses a single TCP connection that is kept open even when the server or client
    is not sending any data. That means, while a connection between the client and
    the server exists, data can be sent at any time without having to open a new connection
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time communication has several applications from building chat applications
    to multi-user games, where the response time is really important.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on learning how to build a real-time web application
    using Socket.IO ([https://socket.io](https://socket.io)) and understanding the
    Node.js event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO is one of the most used libraries for implementing real-time communication.
    Socket.IO uses WebSocket whenever possible but falls-back to other methods when
    WebSocket is not supported on a specific web browser. Because you probably want
    to make your application accessible from any web browser, having to work directly
    with WebSocket may not seem like a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Node.js events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has an event-driven architecture. Most of Node.js' core API is built
    around `EventEmitter`. This is a Node.js module that allows `listeners` to subscribe
    to certain named events that can be triggered later by an **emitter**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own event emitter easily by just including the events Node.js
    module and creating a new instance of `EventEmitter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can trigger the `welcome` event by using the `emit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually, pretty simple. One of the advantages is that you can subscribe
    multiple listeners to the same event, and they will get triggered when the `emit`
    method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EventEmitter` API provides several helpful methods that give you more
    control to handle events. Check the official Node.js documentation to see all
    information about the API: [https://nodejs.org/api/events.html](https://nodejs.org/api/events.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will create a class that will extend `EventEmitter`, and
    which will contain its own instance methods to trigger listeners attached to a
    specific event. First, create a new project by opening a Terminal and running
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class that extends `EventEmitter` and define two instance methods
    called `start` and `stop`. When the `start` method is called, it will trigger
    all listeners attached to the `start` event. It will keep the starting time using
    `process.hrtime`. Then, when the `stop` method is called, it will trigger all
    listeners attached to the `stop` event passing as an argument the difference in
    time since the `start` method was called:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `timer.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the events NodeJS module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two constants that we will use to convert the returned value of `process.hrtime`
    from seconds to nanoseconds and then to milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a class named `Timer` with two instance methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new instance of the previously defined class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach an event listener to the `start` event that will have a loop that will
    perform multiplications. Afterwards, it will call the `stop` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach an event listener to the `stop` event that will print the time it took
    for the event `start` to execute all its attached listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `start` method to trigger all `start` event listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new Terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `start` method is executed, it keeps the starting time using `process.hrtime`,
    which returns the current high-resolution real time in an array of two items,
    where the first item is a number that represents seconds while the second item
    is another number that represents nanoseconds. Then, it triggers all event listeners
    attached to the `start` event.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, when the `stop` method is executed, it uses the result of
    previously calling `process.hrtime` as an argument to the same function, which
    returns the difference in time. This is useful to measure the time from when the
    `start` method was called until the time when the `stop` method was called.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common mistake is to assume that events are called asynchronously. It is
    true that defined events can be called at any time. However, they are still executed
    synchronously. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs for the preceding code will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you have a loop running inside one of your events, the next event won't get
    called until the previous one finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events can be made asynchronous by simply adding an `async`Â function as an
    event listener. By doing so, every function will still be called in order from
    the first `listener` defined to the last. However, the emitter won''t wait for
    the first `listener` to finish its execution to call the next listener. That means
    you cannot guarantee that the output will always be in the same order, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs for the preceding code will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous functions allow us to write non-blocking applications. If implemented
    correctly, you won't run into problems like this above.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventEmitter` instances have a method called `listeners` which when executed,
    providing an event name as an argument, returns an array of the attached listeners
    for that specific event. We can use this method in a way to allow `async` functions
    to be executed in the order they were attached, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute and display output in the order they were attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Socket.IO events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO is an event-driven module or library, and, as you probably guessed,
    is based on `EventEmitter`. Everything in Socket.IO works with events. An event
    is triggered when a new connection is made to the Socket.IO server and an event
    can be emitted to send data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO server API differs from the Socket.IO client API. However, both
    work with events to send data from client to server and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO server events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO uses a single TCP connection to a single path. That means, by default,
    the connection is made to the URL `http[s]://host:port/socket.io`. However, within
    Socket.IO, it allows you to define **namespaces**. That means, different end-points
    but the connection will still remain a single URL.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Socket.IO Server uses the `"/"` or root namespace
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, define multiple instances and listen to different URLs as
    well. However, we will assume, for the purpose of this recipe, that only one connection
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Socket.IO namespace has the following events that your application can
    subscribe to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect` or `connection`: When a new connection is made, this event is fired.
    It provides a **socket object** to the listener as the first parameter that represents
    the new connection with the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Socket.IO socket object has the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disconnecting`: This event is emitted when the client is going to be disconnected
    from the server. It provides to the listener a parameter that specifies the reason
    for the disconnection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`disconnected`: Similar to the disconnecting event. However, this event is
    fired after the client has been disconnected from the server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`error`: This event is emitted when an error occurs within events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`[eventName]`: A user-defined event that will get fired when the client emits
    an event with the same name. The client can emit an event providing data in the
    arguments. On the server, the event will be fired and it will receive the data
    sent by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket.IO client events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A client doesn't necessarily need to be a web browser. We could write a Node.js
    Socket.IO client application as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Socket.IO client events are extensive and give a lot of control over your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect`: This event gets fired when there is a successful connection to the
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`connect_error`: This event is emitted when there is an error when trying to
    connect or reconnect to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`connect_timeout:` By default, the timeout set before a `connect_error` and
    `connect_timeout` is emitted is 20 seconds. After this, the Socket.IO client may
    try to reconnect to the server once again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`disconnect`: This event is fired when the client is disconnected from the
    server. An argument is provided specifying the reason of the disconnection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`reconnect`: Fired after a successful reconnection attempt. An argument is
    provided that specifies how many attempts happened before the connection was successful:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`reconnect_attempt` or `reconnecting`: This event is emitted when trying to
    reconnect to the server. An argument is provided specifying the number of current
    attempts to connect to the server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`reconnect_error`: Similar to the `connect_error` event. However, it gets fired
    only if there is an error when trying to reconnect to the server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`reconnect_failed:` By the default, the maximum number of attempts is set to
    `Infinity`. That means, it is unlikely that this event will ever get fired. However,
    we can specify an option to limit the maximum number of connection attempts. Let''s
    see that later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ping`: In short, this event gets fired to check if the connection with the
    server is still alive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`pong`: Fired when a response is received from the server after the event `ping`
    is fired. An argument is provided specifying the latency or response time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`error`: This event is fired when an error occurs within events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`[eventName]`: A user-defined event that gets fired when the event is emitted
    in the server. The arguments provided by the server will be received by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will build a Socket.IO server and a Socket.IO client using
    what you have just learned about events. Before you start, create a new `package.json`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a Terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Socket.IO server will be built to respond to a single event named `time`.
    When the event is fired, it will get the server's current time and emit another
    event named `"got time?"` providing two arguments, the current `time` and a `counter`
    that specifies how many times a request was made.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `simple-io-server.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO module and initialize a new server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the URL path where connections will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the root or `"/"` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new connection is made, initialize a `counter` variable to `0`. Then,
    add a new listener to the `time` event that will increase the `counter` by one,
    every time there is a new request, and emit the `"got time?"` event that will
    be later defined on the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen on port `1337` for new connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, build a Socket.IO client that will connect to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `simple-io-client.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO client module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize a new Socket.IO client providing the server URL and an options object
    where we will define the path used in the URL where the connections will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener to the `connect` event. Then, when a connection is made,
    using a `for` loop, emit the `time` event 5 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener to the `"got time?"` event that will expect to receive
    two arguments the time and a counter that specifies how many requests were made
    to the server, then print on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a Terminal and run first the Socket.IO server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another terminal and run the Socket.IO client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything works with events. Socket.IO allows events to be defined in the server
    side that the client can emit. On the other side, it also allows to define events
    in the client side that the server can emit.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user-defined event is emitted by the server side, the data is sent to
    the client. The Socket.IO client checks whether there is a listener for that event
    first. Then, if there is a listener, it will get triggered. The same thing happens
    the other way around when a user-defined event is emitted by the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: An event listener `time` was added in our Socket.IO server's **socket object**
    which can be emitted by the client side
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An event listener `"got time?"` was added in our Socket.IO Client which can
    be emitted by the server side
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On connection, the client emits the `time` event first
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, the `time` event is fired on the server side which will emit the
    `"got time?"` event providing two arguments, the current server's `time` and a
    `counter` that specifies how many times a request was made
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `"got time?"` event is fired on the client side receiving two arguments
    that were provided by the server, the `time` and a `counter`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with Socket.IO namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces are a way of separating the business logic of your application while
    reusing the same TCP connection or minimizing the need for creating new TCP connections
    for to implement real-time communication between the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces look pretty similar to ExpressJS'' route paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: However, as mentioned in previous recipes, these are not related to URLs. By
    default, a single TCP connection is created at this URL `http[s]://host:port/socket.io`
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusing the same event names is a good practice when using namespaces. For
    example, let''s suppose that we have a Socket.IO server that we use to emit a
    `setWelcomeMsg` event when the client emits a `getWelcomeMsg` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we defined a listener for the event `getWelcomeMsg` in two
    different namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: If the client is connected to the English or `/en` namespace, when the `setWelcomeMsg`
    event is fired, the client will receive `"Hello World!"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, if the client is connected to the Spanish or `/es` namespace,
    when the `setWelcomeMsg` event is fired, the client will receive `"Hola Mundo!"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how to work with two different namespaces that
    contain the same event names. Before you start, create a new `package.json` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Socket.IO server that will fire a `data` event and send an object containing
    two properties, `title` and `msg`, that will be used to populate HTML content
    in the selected language. Use namespaces to separate and send different data according
    to the language that the client chooses, English or Spanish.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `nsp-server.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO npm module and the required modules for creating an HTTP
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `http` module to create a new HTTP server that will serve an HTML file
    you will create later as a Socket.IO client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the path new connections will be made to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `"/en"` namespace, add a new event listener, `getData`, which when
    fired will emit a `data` event on the client side and send an object including
    a `title` and a `msg` property in the English language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `"/es"` namespace, do the same. However, the object sent to the client
    will include a `title` and a `msg` property in the Spanish language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the underlying
    HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterwards, create a Socket.IO client that will connect to our server and populate
    HTML content based on the data received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `nsp-client.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, specify the document type as HTML5\. Next to it, add an `html` tag and
    set the language to English. Inside the `html` tag, include the `head` and `body`
    tags as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `body` tag, add the first three elements: a heading (`h1`) that
    will contain the title of the content, a `p` tag that will include a message from
    the server, and a `button` that will be used to switch to a different namespace.
    Also, include the Socket.IO client library. The Socket.IO server will make the
    library file available at this URL: http[s]://host:port/socket.io/socket.io.js
    . Then, also include as well the `babel` standalone library which will transform
    the code in the next steps into JavaScript code that can run in all browsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `body`, after the last `script` tags, add another `script` tag and
    set its type to `"text/babel"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After that, inside the `script` tag, add the following JavaScript code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define three constants that will contain a reference to the elements we have
    created in the `body`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Socket.IO client manager. It will help us to create sockets with the
    provided configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new socket that will connect to the `"/en"` namespace. We will assume
    that this is the default connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Reserve two connections for namespaces `"/en"` and `"/es"`. A reserved connection
    will allow us to switch to a different namespace without the need of to create
    a new TCP connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener that, once the socket is connected, will emit a `getData`
    event to request data from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `data` event that will get triggered when the
    client received data from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `button`. When it gets clicked, switch to a different
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the web browser, navigate to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Let's test it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see your previous work in action, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you navigate to `http://localhost:1337/` in your web browser, click on
    the `"Get Content in Spanish"` button to switch to the Spanish namespace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `"Get Content in English"` button to switch back to the English
    namespace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is what happens on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined two namespaces, `"/en"` and `"/es"`, then added a new event listener,
    `getData`, to the **socket object.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `getData` event is fired in any of the two defined namespaces, it will
    emit a data event and send an object, that contains a title and a message property,
    to the client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the client side, inside the script tag in our HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, a new socket is created for the namespace `"/en"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, we created two new **sockets** for the namespaces `"/en"`
    and `"/es"`. They will act as reserved connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After, an event listener connect was added that sends a request to the server
    on connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, another event listener data was added that is fired when data is received
    from the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the event listener that handles onclick events for our button, we change
    the nsp property to switch to a different namespace. However, for this to happen,
    we had to disconnect the **socket** first, and call the open method to make a
    new connection again using the new namespace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see one of the confusing parts about reserved connections. When you
    create one or more **sockets** in the same namespace, the first connection is
    reused, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: On the client side, if there were no reserved connections, then switching to
    a namespace that was not used before would result in a new connection being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious, remove these two lines from the `nsp-client.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Afterwards, restart or run the Socket.IO server again. You will notice that
    there is a slow response when switching to a different namespace because a new
    connection is created instead of being reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative way of achieving the same goal. We could have created
    two sockets that point to two different namespaces, `"/en"` and `"/es"`. Then,
    we could have added two event listeners connect and data to each socket. However,
    because the first and second socket would contain the same event names and receive
    data in the same format from the server, we would have gotten repeated code. Imagine
    the case if we had to do the same for five different namespaces that have the
    same event names and receive data in the same format, there would be too many
    repeated lines of code. This is where switching namespaces and reusing the same
    socket object is helpful. However, there may be cases were two or more different
    namespaces have different event names for different kinds of event, in that case,
    it is better to add event listeners for each of the namespaces separately. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the client side, you have probably noticed one thing that we didn't use before,
    `io.Manager`.
  prefs: []
  type: TYPE_NORMAL
- en: io.Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This allows us predefine or configure how new connections will be created. The
    options defined in a `Manager`, as the URL, will be passed to the socket on initiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTML file, inside a `script` tag, we created a new instance of `io.Manager`
    and passed two arguments; the server URL and an options object including a `path`
    property which indicates where new connections will be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the `io.Manager` API visit the official documentation
    Website offer for Socket.IO [https://socket.io/docs/client-api/#manager](https://socket.io/docs/client-api/#manager).
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we used the `socket` method to initialize and create a new Socket for
    the provided namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This way, it is easier to work with several namespaces at the same time without
    having to configure each one of them with the same options.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and joining Socket.IO rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within namespaces, you can define rooms or channels that a socket can join and
    leave.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a room is created with a random un-guessable ID for the connected
    **socket**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'On connection, when emitting an event, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens underneath is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `join` method was used to include the socket inside a room. In this case,
    the socket ID is the joint room, and the only client connected to that room is
    the socket itself.
  prefs: []
  type: TYPE_NORMAL
- en: Because a socket ID represents a unique connection with a client and, by default,
    a room with the same ID is created; all data sent by the server to that room will
    be received only by that client. However, if several clients or socket IDs join
    a room with the same name and the server sends data; all clients could be able
    to receive it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how to join a room and broadcast a message to
    all clients connected to that specific room. Before you start, create a new `package.json`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Socket.IO server that will notify all the connected clients to the `"commonRoom"`
    room when a new socket is connected.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `rooms-server.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO NPM module and initialize a new HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the path where new connections will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the root namespace to listen for events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a method that will be used to emit an `updateClientCount` event to all
    socket clients connected to the `"commonRoom"` providing as an argument the number
    of connected clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'On connection, all newly connected Socket clients will join the `commonRoom`.
    Then, the server will emit a `welcome` event. After this, notify all connected
    sockets to update the number of connected clients and also do the same operation
    once a client is disconnected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the HTTP
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build a Socket.IO client that will connect to the Socket.IO server
    and populate the HTML content with received data:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `rooms-client.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Inside the script tag, add code in the following steps, starting from step 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define two constants that will make a reference to two HTML elements that we
    will update according to the data sent by the Socket.IO Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Socket.IO Client Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the root namespace which is the one used in the Socket.IO Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `welcome` event that expects an argument that
    will contain a welcome message sent by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `updateClientCount` event that expects an argument
    that will contain the number of connected clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new Terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'On the web browser, navigate to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Without closing the previous tab or window, on the web browser, navigate once
    again to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The number of connected clients in both tabs or windows should have increased
    to `2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending the same message or data, to more than one client, is called broadcasting.
    The method we have seen broadcasts a message to all clients, including the client
    that generated the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other several methods to broadcast a message. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Which will emit an `updateClientCount` event to all clients in `commonRoom`
    expect to the sender or the socket that originated the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list check the official documentation of Socket.IO emit cheatsheet:
    [https://socket.io/docs/emit-cheatsheet/](https://socket.io/docs/emit-cheatsheet/)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing middleware for Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket.IO allows us to define two kinds of middleware functions in the server
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace middleware**: Registers a function that gets executed for every
    new connected Socket and has the following signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**Socket middleware**: Registers a function that gets executed for every incoming
    Packet and has the following signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It works similarly to how ExpressJS middleware functions do. We can add new
    properties to the `socket` or `packet` objects. Then, we can call `next` to pass
    the control to the next middleware in the chain. If `next` is not called, then
    the `socket` won't be connected, or the `packet` received.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will build a Socket.IO server application where you will
    define middleware functions to restrict access to a certain namespace as well
    as restricting access to a certain socket based on some criteria. Before you start,
    create a new `package.json` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Socket.IO server application will expect the users to be logged-in in order
    for them to be able to connect to the `/home` namespace. Using socket middleware,
    we will also restrict access to `/home` namespace to a certain user:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `middleware-server.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the Socket.IO library and initialize a new HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the path where new connections will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an array of users that we will use as an in-memory database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a method to verify if the provided username and password exist in the
    users array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a namespace middleware function that will check whether the user is
    already logged-in. A client won''t be able to connect to a specific namespace
    using this middleware if they are not logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two namespaces, one for `/login` and another for `/home`. The `/home`
    namespace will use our previously defined middleware function to check whether
    the user is logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new socket is connected to `/login` namespace, first we will define
    a socket middleware function for checking all incoming packages and ban access
    to the `johntm` username. Then, we will add an event listener for the enter event
    that will expect to receive a plain object containing a username and password,
    and if they exist in the users array, then we set a session object which will
    tell whether the user is logged in. Otherwise, we will send a `loginError` event
    with an error message to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen on port 1337 for new connections and attach Socket.IO to the HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build a Socket.IO client application that will connect to our Socket.IO
    Server and allow us to attempt to log in and test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `middleware-cli.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Inside the script tag, add the code in the following steps, starting from step
    4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define three constant that will make a reference to the HTML elements that
    we will use to get input or display output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Socket.IO Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a namespace constant that will contain an object containing the
    Socket.IO namespaces `/home` and `/login`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the connect event to the `/home` namespace. It will
    get triggered only when the `/home` namespace successfully connects to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `loginSuccess` event to the `/login` namespace.
    It will ask the `/home` namespace to connect to the server again. If the user
    is logged in, then the server will allow this connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `loginError` event to the `/login` namespace.
    It will display error messages sent by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the submit event for the login form. It will emit
    the enter event providing an object containing the username and password filled
    in the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's test it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see our previous work in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Socket.IO server first. Open a new terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'On your web browser, navigate to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: You will see a login form with two fields, `username` and `password`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to log in with random invalid credentials. The following error is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try to log in with `johntm` as `username` and any `password`. The following
    error is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, log in with any of the two other valid credentials. For instance,
    using `jingxuan` as username and `qscwdvb` as password. The following title is
    displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Integrating Socket.IO with ExpressJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO works well with ExpressJS. In fact, it's possible to run an ExpressJS
    application and a Socket.IO server using the same port or HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how to integrate Socket.IO with ExpressJS. You
    will build an ExpressJS application that will serve an HTML file containing a
    Socket.IO client application. Before you start, create a new `package.json` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Socket.IO client application that will connect to the Socket.IO server,
    that you will build next, and display a welcome message sent by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-view.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, build an ExpressJS application and a Socket.IO server. The ExpressJS
    application will serve the previously created HTML file on the root path `"/"`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-server.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize a new Socket.IO server application and an ExpressJS application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the URL path where new connections will be made to the Socket.IO server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a route method to serve our HTML file containing our Socket.IO client
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a namespace `"/"` and emit a `welcome` event with welcome message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the Socket.IO to ExpressJS Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'In your browser, visit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO's `attach` method expects to receive a HTTP server as a parameter
    in order to attach the Socket.IO server application to it. The reason why we can
    attach Socket.IO to an ExpressJS server application is because the `listen` method
    returns the underlying HTTP server to which ExpressJS is connected.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, the `listen` method returns the underlying HTTP server. Then, it
    is passed as a parameter to the `attach` method. This way, we can share the same
    connection with ExpressJS.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that we can share the same underlying HTTP server between
    ExpressJS and Socket.IO. However, that is not all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we define a Socket.IO path is actually useful when working with
    ExpressJS. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the same URL path for Socket.IO and ExpressJS.
    We accept new connections to the Socket.IO server on the `/socket.io` path, but
    we also send content for `/socket.io` using the GET route method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though this preceding example won''t actually break your application,
    make sure to never use the same URL path to serve content from ExpressJS and accept
    new connections for Socket.IO at the same time. For instance, changing the previous
    code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'While you may expect your browser, when visiting `http://localhost:1337/socket.io/message`,
    to display `message`, that won''t be the case and you will see the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: That is because Socket.IO will interpret the incoming data first and it won't
    understand the data you just sent. In addition, your route handler will never
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, the Socket.IO server also serves, by default, its own Socket.IO
    Client under the defined URL path. For example, try visiting [http://localhost:1337/socket.io/socket.io.js](http://localhost:1337/socket.io/socket.io.js)
    and you will be able to see the minimized JavaScript code of the Socket.IO client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to server your own version of Socket.IO client or if it is included
    in the bundle of your application, you can disable the default behavior in your
    Socket.IO server application with the `serveClient` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Using Express.js'' built-in middleware function for
    serving static assets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ExpressJS middleware in Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket.IO namespace middleware works pretty similar to how ExpressJS middleware
    does. In fact, the Socket Object also contains a `request` and a `response` object
    that we can use to store other properties in the same manner as we do with ExpressJS
    middleware functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Because ExpressJS middleware functions have the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We can safely execute the same function in a Socket.IO namespace middleware
    passing the necessary arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: However, that doesn't mean that all ExpressJS middleware functions will work
    out of the box. For example, if an ExpressJS middleware function uses methods
    only available within ExpressJS, it may fail or have an unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how to integrate the ExpressJS `express-session`
    middleware to share the session object between Socket.IO and ExpressJS. Before
    you start, create a new `package.json` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the dependencies by opening a Terminal and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build a Socket.IO client application that will connect to a Socket.IO server
    you will build next. Include a form where the user can type a username and a password
    to attempt to log in. The Socket.IO client will only be able to connect to the
    `/home` namespace after the user is logged-in:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-cli.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following HTML content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Inside the script tag add the code in the next steps, starting from step 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define constants that make a reference to the HTML elements that we will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Socket.IO Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two namespaces, one for `/login` and another one for `/home`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for the `welcome` event that will be triggered by the
    server side once a connection is allowed to the `/home` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for `loginSuccess` event that, when triggered, will ask
    the `/home` namespace to try and reconnect to the Socket.IO Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for `loginError` event that will display an error when
    invalid credentials are provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener for `submit` event that will get triggered when submitting
    the form. It will emit an `enter` event with data containing the provided `username`
    and `password`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, build an ExpressJS application that will serve the Socket.IO client
    on the root path `"/"` and a Socket.IO server that will include the logic for
    logging the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `io-express-srv.js`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize a new ExpressJS application and a Socket.IO server application.
    Also, include the `express-session` NPM module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the path where new connections to Socket.IO server will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an ExpressJS session middleware function with the given options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Socket.IO namespace middleware that will use the previously created
    session middleware to generate a session object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two namespaces, one for `/home` and another for `/login`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an in-memory database or array of objects that will contain `username`
    and `password` properties. These define which users are allowed to login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the session middleware in ExpressJS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a route method for `/home` path that will serve our previously created
    HTML document containing the Socket.IO client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the session middleware in `/home` Socket.IO namespace. Then, check for
    every new socket if the user is logged in. If not, forbid the user to connect
    to this namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a connection is made to the `/home` namespace, meaning that the user can
    log in, emits a `welcome` event with a welcome message that will be displayed
    to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the Session Middleware in the `/login` Socket.IO namespace. Then, when
    the client emits an `enter` event with the provided username and password, it
    verifies the profile exists in the `users` array. If the user exists, set the
    `isLogged` property to `true` and the `username` property to the current user
    that has logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen on port `1337` for new connections and attach the Socket.IO server to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Save the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new Terminal and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'In your browser, visit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Login with valid credentials. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: If you logged in successfully, after refreshing the page, your Socket.IO client
    application will still be able to connect to `/home` and you will see a welcome
    message every time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the session middleware is used inside ExpressJS, after modifying the session
    object, the `save` method is automatically called at the end of the response.
    However, that is not the case when using the session middleware in Socket.IO namespaces,
    that is why we call the `save` method manually to save the session back to the
    store. In our case, the store is the memory where the sessions are kept until
    the server stops.
  prefs: []
  type: TYPE_NORMAL
- en: Forbidding access to certain namespaces based on specific conditions is possible
    thanks to Socket.IO namespace middleware. If the control is not passed to the
    `next` handler, then the connection is not made. That's why after the login is
    successful, we ask the `/home` namespace to attempt to connect again.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Writing middleware functions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
