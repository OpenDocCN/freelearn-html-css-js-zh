- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing a Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned a bit about Node.js and its internal modules. We also
    started to write our own modules, but we have either avoided or worked around
    using third-party packages.
  prefs: []
  type: TYPE_NORMAL
- en: One of the big advantages of Node.js is that using other people’s code is actually
    quite easy. The path to doing so leads us directly to package managers. A package
    manager helps us to handle the life cycle of packages containing modules that
    can be used in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn how Node.js’s de facto standard package manager
    **npm** works. We will then go on to learn about other package managers, such
    as **Yarn** and **pnpm**. They all promise some advantages in terms of usability,
    performance, or reliability. We will take a deeper look at them to understand
    these advantages and who might benefit from using each of the different package
    managers. Finally, we’ll also look at alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you to use third-party libraries in your code. Third-party
    dependencies will make you more productive and focused, and a package manager
    will be useful for installing and updating third-party dependencies. By the end
    of the chapter, you’ll know the most important package managers and which one
    you want to pick in the context of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Yarn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pnpm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some code examples for this chapter are available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [http://bit.ly/3TmZr22](http://bit.ly/3TmZr22).
  prefs: []
  type: TYPE_NORMAL
- en: Using npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install Node.js from the official sources, you get a bit more than
    just Node.js. For convenience, Node.js will also add a few more programs and settings
    to your system. One of the most important additions is a tool called npm. Originally,
    npm was intended to stand for *Node.js Package Manager*, but today, it is essentially
    its own standalone name.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of npm is to allow developers to manage third-party dependencies. This
    includes installing and updating packages, as well as handling their versioning
    and transitive dependencies. A transitive dependency is established when dependencies
    that are installed also include dependencies, which therefore need to be installed,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: For `npm` to know what dependencies exist and what their dependencies are, the
    npm registry was created. It is a web service that hosts all packages on a file
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the used npm registry
  prefs: []
  type: TYPE_NORMAL
- en: Today, many npm registries exist – but only the official one located at [https://registry.npmjs.org/](https://registry.npmjs.org/)
    is used by default. To change the registry consistently, a special file, `.npmrc`,
    needs to be created. If the file is created in the home directory, then the change
    applies to all usages. Otherwise, this file could also be created next to a `package.json`
    – only being applied to the designated project. Finally, to only temporarily use
    another registry, the `--registry` command-line flag can be used. The format of
    the `.npmrc` file is outlined at [https://docs.npmjs.com/cli/v8/configuring-npm/npmrc](https://docs.npmjs.com/cli/v8/configuring-npm/npmrc).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use packages from the npm registry, we’ll need to use the `npm` command-line
    utility. In fact, the first thing we should do when we copy or clone the source
    code of a Node.js project is to run `npm install` in the directory of the project’s
    `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will install all packages that are mentioned as runtime and development
    dependencies in the `package.json`. The packages are downloaded from the configured
    npm registry and then stored in the `node_modules` directory. It is good practice
    to avoid adding the `node_modules` directory to your source control. For instance,
    for Git, you should add `node_modules` to your repository’s `.gitignore` file.
    There are several reasons for this – for example, the installation might be platform-specific
    or the installation may be reproducible anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `npm` command-line utility comes with a set of integrated commands – such
    as the previously shown `install` command. To see what commands are available
    to you, the utility can be used with the `--``help` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--help` flag also works in combination with a specific command. If you
    want to know which options exist for the `install` command, you can just type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The principle of getting context-specific help is vital to many command-line
    utilities. All of the package managers that we’ll look at in this chapter feature
    this approach. In the end, for us as users, this has some advantages. Instead
    of needing to look up the online documentation, other books, or tutorials to see
    the syntax for a command every time, we can just get all the required information
    directly in the command line which is tailored to the specific version that we
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A command that is highly useful is `init`. While `install` is great to use
    for existing projects, `init` can be used to create a new project. When you run
    `npm init`, you’ll be guided through all the options in a kind of survey. The
    result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An alternative would be to specify the `-y` flag. This way, all the defaults
    will be taken – a much quicker alternative if you just want to initialize a new
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The initializer function of npm can even be extended. If you provide another
    name after `npm init`, then npm will try to look for a package using the `create-`
    prefix. For instance, when you run `npm init react-app`, npm will look for a package
    called `create-react-app` and run it. Running a package refers to looking for
    a `bin` field in the package’s `package.json` file and using the given reference
    to start a new process.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add dependencies to your project instead, you can use `npm install`,
    too. For instance, adding React as a dependency is `npm` `install react`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency life cycle also requires us to know when dependencies are outdated.
    For this purpose, npm offers the `npm` `outdated` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The command only shows packages that have a more recent release than the currently
    installed version. In some cases, that is fine – that is, when the current version
    matches the wanted version. In other cases, running `npm update` will actually
    update the installed version.
  prefs: []
  type: TYPE_NORMAL
- en: Using different versions of npm
  prefs: []
  type: TYPE_NORMAL
- en: npm is already packaged together with Node.js. Therefore, each release of Node.js
    also selects a version of npm. For instance, Node.js 14 was bundled with npm 6\.
    In Node.js 15, npm 7 was included. With Node.js 16 onward, you’ll get npm 8\.
    One way to stay flexible is to use **nvm** instead. nvm is a small tool that allows
    you to select the version of Node.js to use. It can also be used to change the
    default version and quickly update and install new versions of Node.js and npm.
    More information is available at [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).
  prefs: []
  type: TYPE_NORMAL
- en: npm also provides a lot of useful, convenient features – for example, to improve
    security. The `npm audit` command checks the currently installed packages against
    an online database containing security vulnerabilities. Quite often, a fix in
    vulnerable packages is just one call of `npm audit --fix` flag away. Furthermore,
    using a command such as `npm view` – for example, in `npm view react` – we can
    directly interact with the npm registry containing most of the publicly available
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: While the npm registry is a great source for packages, the `npm` command-line
    utility is not the only way to use it. In fact, the API of the web service is
    public and could be used by anyone – or any program for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first companies to use a public API of the npm registry was Facebook.
    They suffered from slow installation times in their large projects and wanted
    to improve on this by providing a better algorithm to actually resolve the dependencies
    of a project – especially transitive dependencies. The result was a new package
    manager named **Yarn**.
  prefs: []
  type: TYPE_NORMAL
- en: Using Yarn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The issue with the original npm package resolution algorithm was that it was
    created in a resilient but naïve way. This does not mean that the algorithm was
    simple. Rather, here, we refer to the fact that no exotic tricks or experience
    optimizations have been considered. Instead of trying to optimize (that is, lower)
    the number of packages available on the local disk, it was designed to put the
    packages into the same hierarchy as they were declared in. This results in a filesystem
    view as shown in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Example filesystem snapshot after installing packages using
    npm ](img/Figure_3.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Example filesystem snapshot after installing packages using npm
  prefs: []
  type: TYPE_NORMAL
- en: The naïve way of handling package installations is certainly a great way to
    ensure that everything is installed correctly, but not ideal in terms of performance.
    Looking at *Figure 3**.1*, there may be some optimizations possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some example package names and versions to *Figure 3**.1* to see
    the opportunities for optimization. In *Figure 3**.2*, the same snapshot is shown
    – just with example package names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Filesystem snapshot with example package names after npm installation
    ](img/Figure_3.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Filesystem snapshot with example package names after npm installation
  prefs: []
  type: TYPE_NORMAL
- en: Instead of duplicating the `bar` dependency, it could be just used once. The
    `foo` dependency, on the other hand, has to be duplicated due to conflicting versions.
    Other transitive dependencies, such as `abc` or `def`, can be brought to the top
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting image is shown in *Figure 3**.3*. This flattens the structure
    where possible. This optimization was key to the first version of Yarn. Actually,
    it was so successful that npm improved its algorithm, too. Today, npm resolves
    the packages in a similar way to the sketch shown in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Filesystem snapshot with example package names after installation
    using Yarn ](img/Figure_3.3_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Filesystem snapshot with example package names after installation
    using Yarn
  prefs: []
  type: TYPE_NORMAL
- en: For the team at Yarn, the optimizations gained were not enough. They started
    to look for different ways to improve even further. However, the more they looked,
    the more they were convinced that something completely new was needed to make
    any further enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The result was introduced with `node_modules` directory. Instead, a special
    file called `.pnp.cjs` is created to give information on how the dependencies
    can be resolved. With the `.pnp.cjs` file, every package can be resolved – just
    as with `node_modules` beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The specific location of the packages depends on the project’s settings. With
    Yarn 2, a new concept called *zero-installs* has been introduced. This way, each
    dependency will be available within the project – just in a `.yarn/cache` subfolder.
    To actually achieve zero-installs, the `.yarn` folder should be checked into source
    control. Now, when the project is cloned, no installation needs to be performed.
    The dependencies are already part of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'While most commands are very similar, Yarn takes a different approach to adding
    new dependencies. Here, dependencies are added using `yarn add` – for example,
    `yarn add react`. The installation of packages using the `yarn` command-line utility
    is quite similar to the previous usage with `npm`, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In *Figure 3**.4*, the new PnP mechanism is shown using the previous example.
    By using fully qualified names consisting of the package name and version, unique
    identifiers are created, allowing multiple versions of the same package to be
    located in a flat structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of the PnP mechanism is the custom resolution method, which requires
    some patching in Node.js. The standard resolution mechanism of Node.js uses `node_modules`
    to actually find modules within packages. The custom resolution method teaches
    Node.js to use a different directory with a different structure to find modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Filesystem snapshot with example package names after installation
    using Yarn PnP ](img/Figure_3.4_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Filesystem snapshot with example package names after installation
    using Yarn PnP
  prefs: []
  type: TYPE_NORMAL
- en: While using a custom resolution method is not a problem for many packages, some
    may depend on the classic structure involving `node_modules` with packages just
    resolving to directories and files. In PnP, however, the structure is flat, with
    each package being a zip archive.
  prefs: []
  type: TYPE_NORMAL
- en: As of today, many plugins and patches are available for packages to be compatible
    with PnP. Many – especially less popular – packages are still not usable with
    PnP. Luckily, Yarn 3 fixed many of these issues, providing a compatibility mode
    that works for most of these problematic packages. At the end of the day, it’s,
    unfortunately, mostly a matter of trial and error. Luckily, Yarn PnP is not the
    only solution that exists for speeding up npm even more.
  prefs: []
  type: TYPE_NORMAL
- en: Even before Yarn 2 with PnP was released, other developers started thinking
    of alternative strategies to speed up installation times and preserve network
    bandwidth and storage capacity. The best-known attempt is a utility called pnpm.
  prefs: []
  type: TYPE_NORMAL
- en: Using pnpm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach of pnpm feels a bit like the original package resolution of npm.
    Here, each package is essentially isolated and puts its own dependencies into
    a local `node_modules` subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one crucial difference: instead of having a hard copy of
    each dependency, the different dependencies are made available through symbolic
    links. The advantage of this approach is that every dependency only needs to be
    resolved once per system.'
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage is that for most packages everything is as it should be.
    There is nothing hiding behind an archive or via some custom mapping defined by
    a module that would run in the beginning. The whole package resolution just works.
    The exception to this rule is packages that use their path to find other packages
    or work against a root directory. Since the physical location of the packages
    is global, and therefore different from the project’s location, these approaches
    do not work with pnpm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing packages with the `pnpm` command-line utility works very similarly
    to `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Overall, most commands of the `pnpm` command-line utility have either the same
    or a very similar name to their `npm` counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'On installation, `pnpm` adds the unavailable packages to a local store. A local
    store is just a special directory from `pnpm` that is not bound to your project,
    but rather your user account. It is pnpm’s package storage that is actually the
    source of its miraculous performance. Afterward, `pnpm` creates all the symbolic
    links to wire everything together. The result looks similar to *Figure 3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Filesystem snapshot with example package names after installation
    using pnpm ](img/Figure_3.5_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Filesystem snapshot with example package names after installation
    using pnpm
  prefs: []
  type: TYPE_NORMAL
- en: Only direct dependencies are listed in the `node_modules` folder. The content
    of each subfolder is not available in the original `node_modules` – rather, in
    the global `.pnpm` cache. The same is then applied to all sub-dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a massive performance boost. Already, on a clean install, `pnpm`
    is faster than the competition. However, in other scenarios, the relative gap
    may be even larger. In *Figure 3**.6*, the performance of `pnpm` is compared against
    other package managers. Lower bars refer to better performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and
    Yarn with PnP (source: https://pnpm.io/benchmarks)](img/Figure_3.6_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and Yarn
    with PnP (source: https://pnpm.io/benchmarks)'
  prefs: []
  type: TYPE_NORMAL
- en: Only in the case of an up-to-date installation can npm be considered the fastest
    option. In other cases, pnpm and sometimes Yarn PnP can be considered faster.
    With this in mind, the key question is whether there are other alternatives to
    consider. Let’s see what else we can do to simplify dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: More alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no strict requirement when using a package manager. Theoretically,
    it does not matter where the code comes from. You could, for instance, download
    the packages directly, extract them, and refer to them via their local path.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a system such as **Deno** could be interesting. On the surface,
    Deno is quite similar to Node.js. However, there are a few crucial differences
    under the hood. The most striking one is that there is no package manager for
    Deno. Instead, packages are just URLs that are resolved once needed. This way,
    the package installation is just a download – which happens to run when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Deno in a nutshell
  prefs: []
  type: TYPE_NORMAL
- en: Deno was created by Ryan Dahl – the creator of Node.js. As such, Deno shares
    many features with Node.js but deviates in some aspects. Deno aims to be a lot
    more compatible with JavaScript running in the browser than Node.js. Deno also
    tries to be secure by default. When running a script with Deno, the provided security
    context has to be defined by the user. Otherwise, access to the network or the
    filesystem may be impossible for the code running. You can get more information
    at [https://deno.land/](https://deno.land/).
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use a tool that actually leverages one of the existing
    package managers underneath but in a more efficient or user-friendly fashion.
    One example in this category is **Turborepo**.
  prefs: []
  type: TYPE_NORMAL
- en: Turborepo works with any of the popular package managers and claims to provide
    improved performance for many tasks, including package installation and updates.
    The most efficient way, however, to utilize Turborepo is to use it for a so-called
    monorepo, which will be discussed in greater length in [*Chapter 9*](B18989_09.xhtml#_idTextAnchor088),
    *Structuring Code* *in Monorepos*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the question of how the packages can be installed, updated, and published,
    the other part of package management is the package registry. In this space, you
    can choose from many commercial offerings to open source projects such as **Verdaccio**.
    Having your own package registry can be great for larger projects, where missing
    dependencies or downtimes of the public npm registry may be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there are not many alternatives to the established package managers
    npm, Yarn, and pnpm. While optimizing the use of package managers or using cached
    registries instead might be appealing, they are certainly not worth the effort
    for most projects. Right now, npm and Yarn seem to be most appealing in the broadest
    range of scenarios, whereas pnpm could be considered the desired choice for really
    big repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use a package manager to handle everything
    related to packages. You’ve leveraged the default `npm` command-line utility.
    You got in touch with the most important alternatives, Yarn and pnpm. You should
    know what Yarn brings to the table – after all, PnP and zero-installs are neat
    features. Furthermore, you checked out some alternatives and learned about custom
    registries and repository task runners such as Turborepo.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have everything to clone and run existing Node.js projects.
    You can install new dependencies, check for outdated dependencies, and update
    them. This gives you the power to integrate all of the over-a-million packages
    that have been published over the years in the npm registry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how different flavors of JavaScript, such
    as more modern specifications or languages that use JavaScript as a compilation
    target, can be used in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Tooling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you’ll strengthen your knowledge of the Node.js ecosystem by getting
    in touch with a variety of tools and utilities. You’ll learn how you can use different
    flavors of JavaScript in Node.js. Examples here include TypeScript and Flow. You’ll
    also see which code verification and style checkers exist and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of this part is to enable you to set up and maintain a new web
    development project from scratch. This also includes knowledge about quality assurance.
    As part of these topics, utilities such as Jest or Playwright are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18989_04.xhtml#_idTextAnchor042), *Using Different Flavors of
    JavaScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18989_05.xhtml#_idTextAnchor049), *Enhancing Code Quality with
    Linters and Formatters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18989_06.xhtml#_idTextAnchor057), *Building Web Apps with Bundlers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18989_07.xhtml#_idTextAnchor067), *Improving Reliability with
    Testing Tools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
