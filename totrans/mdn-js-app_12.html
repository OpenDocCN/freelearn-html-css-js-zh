<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;New Features of Angular 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. New Features of Angular 2</h1></div></div></div><p>Angular 1 was based on the MVC architecture whereas Angular 2 is based on a components-and-services architecture. Angular 1 and Angular 2 are completely different in terms of architecture and APIs, so previous knowledge of Angular 1 is unlikely to help you much in learning Angular 2. In this chapter, we will learn Angular 2 without comparing it with Angular 1 as doing that will create confusion and is unnecessary. Even if you don't have knowledge about Angular 1, you can continue with this chapter.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Web components</li><li class="listitem" style="list-style-type: disc">The Angular 2 architecture</li><li class="listitem" style="list-style-type: disc">Template language</li><li class="listitem" style="list-style-type: disc">Component inputs and outputs</li><li class="listitem" style="list-style-type: disc">The component life cycle</li><li class="listitem" style="list-style-type: disc">Events</li><li class="listitem" style="list-style-type: disc">Forms</li><li class="listitem" style="list-style-type: disc">Services</li></ul></div><p>And much more...</p><div class="section" title="The Angular 2 architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec85"/>The Angular 2 architecture</h1></div></div></div><p>Angular 2 is <a id="id537" class="indexterm"/>a framework for building the client side of web applications, based on a services-and-components architecture.</p><p>An Angular 2 application is composed of a view and various services. Services are simple JavaScript objects that hold application logic and state. Services should be reusable. Views consume services, and services can also interact with each other.</p><p>Views and services are loosely coupled so that an Angular 2 view can be used with any other architecture, such as Flux. Similarly, services can be used with any other view, such as React.</p><p>Angular 2 <a id="id538" class="indexterm"/>views are based on component-oriented architecture. In component-oriented architecture, the application UI is divided into reusable components. A component has a UI with code to update the UI and handle user actions on the UI. A custom tag is associated with a component, and whenever the custom tag appears, a new instance of the component is created and rendered. So, we can say that component-oriented architecture is architecture for the view of an application. Actually, the components consume the services.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>In the previous two chapters, we studied React, which is also based on component-oriented architecture, since with React, we build an application as a set of components.</p></div></div><p>Here is a diagram from the official Angular 2 <a id="id539" class="indexterm"/>website (<a class="ulink" href="https://angular.io">https://angular.io</a>) that shows the complete architecture of Angular 2:</p><div class="mediaobject"><img src="graphics/B05154_12_02.jpg" alt="The Angular 2 architecture"/></div><p>Here, you can see that the UI <a id="id540" class="indexterm"/>of a <span class="strong"><strong>Component</strong></span> is <a id="id541" class="indexterm"/>defined using a <span class="strong"><strong>Template</strong></span>. Templates are written using template HTML, that is, a combination of HTML and many other tokens. A component also holds the UI state and event handlers of the UI.</p><p>We shouldn't store application <a id="id542" class="indexterm"/>logic and state inside a component, as it will have an impact on code reusability and cause issues while developing large and complex apps. Application state and logic should be stored in services.</p><p>Angular 2 only implements one-way data binding. This makes large and complex apps easier to debug.</p><p>Services are injected into specific components that need them, and not all the components.</p></div></div>
<div class="section" title="Introducing web components"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Introducing web components</h1></div></div></div><p>Before we <a id="id543" class="indexterm"/>get into web components, you need to know why we are learning about them. Well, we are learning about web components because Angular 2 components utilize shadow DOM and templates, which are a part of web components.</p><p>In a nutshell, web components are a collection of four different browser specifications that enable <a id="id544" class="indexterm"/>the creation <a id="id545" class="indexterm"/>of reusable <a id="id546" class="indexterm"/>components in web pages. These four specifications are <span class="strong"><strong>HTML imports</strong></span>, <span class="strong"><strong>shadow DOM</strong></span>, <span class="strong"><strong>templates</strong></span>, and <span class="strong"><strong>custom elements</strong></span>. They can be used together or separately.</p><p>Web components provide native implementation of component-oriented architecture. A component created using web components is called a web component as well.</p><p>Before we learn about web components, let's consider a project for demonstration purposes. Create a directory named <code class="literal">web-components</code>, and then create a file named <code class="literal">index.html</code> in it. Web components have pretty poor browser support, so let's download <code class="literal">webcomponents.js polyfill</code>. Download <a id="id547" class="indexterm"/>the <code class="literal">webcomponents.js</code> file from <a class="ulink" href="https://github.com/webcomponents/webcomponentsjs">https://github.com/webcomponents/webcomponentsjs</a> and place it in the <code class="literal">web-components</code> directory.</p><p>Now, place this code in the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Web Components Demo&lt;/title&gt;
    &lt;script src="webcomponents.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      //place JavaScript code here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Let's now look at an overview of shadow DOM, templates, and custom elements by building a component to display a card that has an image, title, and description.</p><div class="section" title="Templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec84"/>Templates</h2></div></div></div><p>
<span class="strong"><strong>Templates</strong></span> are <a id="id548" class="indexterm"/>used to define reusable code. A template is defined using the <code class="literal">&lt;template&gt;</code> tag. Code for the template is placed inside this tag. We can place any tag, such as <code class="literal">&lt;script&gt;</code> and <code class="literal">&lt;style&gt;</code>.</p><p>The code inside the <code class="literal">&lt;template&gt;</code> tag is only parsed, not rendered.</p><p>Here is an example of how to create a template. Place this code in the <code class="literal">body</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;template id="cardTemplate"&gt;
  &lt;style type="text/css"&gt;
    .container
    {
      width: 250px;
      float: left;
      margin-right: 10px;
    }

    img
    {
      width: 100%;
    }
  &lt;/style&gt;
  &lt;div class="container"&gt;
    &lt;img src="" /&gt;
    &lt;div&gt;
      &lt;h3&gt;&lt;/h3&gt;
      &lt;p&gt;&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre></div><p>Here, the template holds the UI code for the card component. Now, if you open the <code class="literal">index.html</code> file in a browser, you won't see anything because the <code class="literal">&lt;template&gt;</code> tag is only parsed, not rendered.</p></div><div class="section" title="Custom elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec85"/>Custom elements</h2></div></div></div><p>
<span class="strong"><strong>Custom elements</strong></span> let <a id="id549" class="indexterm"/>us define new types of HTML elements (that is, new types of HTML tags). When we use a tag name that's not recognized by the browser, the browser simply treats it like a <code class="literal">&lt;span&gt;</code> tag. But when we register a <code class="literal">custom</code> tag, it gets recognized by the browser. It can inherit other elements, lets us perform different operations on different stages of the element lifecycle, and much more.</p><p>Let's create a <code class="literal">custom</code> element for our component. Wherever the tag appears, a new instance of the component will be displayed.</p><p>Here is the code to display the <code class="literal">custom</code> element. Place it in the <code class="literal">&lt;body&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;custom-card data-img="http://placehold.it/250x250" data-title="Title 1" data-description="Description 1" is="custom-card"&gt;&lt;/custom-card&gt;
&lt;custom-card data-img="http://placehold.it/250x250" data-
title="Title 2" data-description="Description 2"&gt;&lt;/custom-card&gt;</pre></div><p>We have to use the <code class="literal">-</code> character in the custom element name. This is compulsory because this restriction allows the parser to distinguish custom elements from regular elements and ensures forward compatibility when new tags are added to HTML. Here, we are passing properties of the component as data attributes.</p><p>Now, let's define <code class="literal">&lt;custom-card&gt;</code> as a custom element and place the template code inside the tag whenever a new instance of <code class="literal">&lt;custom-card&gt;</code> is created. To do that, place this code in the <code class="literal">&lt;script&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">var customCardProto = Object.create(HTMLElement.prototype);
customCardProto.createdCallback = function(){
  var template = document.querySelector("#cardTemplate");
  template.content.querySelector("img").src = this.getAttribute("data-img");
  template.content.querySelector("h3").innerHTML = this.getAttribute("data-title");
  template.content.querySelector("p").innerHTML = this.getAttribute("data-description");

  var clone = document.importNode(template.content, true);
  this.appendChild(clone)
}
var customCard = document.registerElement("custom-card", {
  prototype: customCardProto
});</pre></div><p>Here is how the code works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By default, custom elements inherit methods and properties of <code class="literal">HTMLElement</code>.</li><li class="listitem" style="list-style-type: disc">To <a id="id550" class="indexterm"/>register a custom element, we need to use the <code class="literal">document.registerElement</code> method. The first argument is the custom tag name and the second argument is an optional object. This optional object can take a property <a id="id551" class="indexterm"/>called <span class="strong"><strong>prototype</strong></span>. The <code class="literal">prototype</code> property defines the HTML element it inherits, that is, the properties and methods of the HTML element it inherits. By default, it's assigned to <code class="literal">Object.create(HTMLElement.prototype)</code>.</li><li class="listitem" style="list-style-type: disc">We can also add new properties and methods to our custom element by adding new properties and methods to the object assigned to the <code class="literal">prototype</code> property.</li><li class="listitem" style="list-style-type: disc">Here, we've added a method called <code class="literal">createdCallback</code>, which is invoked whenever an instance of a custom element is created, that is, either an instance created using JavaScript or HTML.</li><li class="listitem" style="list-style-type: disc">Inside <code class="literal">createdCallback</code>, we are retrieving our template and setting the image source, title, and description and then appending it to the custom element by creating a clone of it, as many custom elements will share the same template.</li></ul></div><p>Now, if you open <code class="literal">index.html</code> in a browser, you will see this output:</p><div class="mediaobject"><img src="graphics/B05154_12_01.jpg" alt="Custom elements"/></div></div><div class="section" title="Shadow DOM"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec86"/>Shadow DOM</h2></div></div></div><p>
<span class="strong"><strong>Shadow DOM</strong></span> allows <a id="id552" class="indexterm"/>HTML elements to get a new kind of node called a shadow root associated with them. An element that has a shadow root associated with it is called a shadow host. The content of a shadow host isn't rendered; the content of the shadow root is rendered instead. A shadow root can have another shadow root below it.</p><p>The benefit of shadow DOM is that CSS styles defined inside a shadow root won't affect its parent document, and CSS styles defined outside the shadow root will not affect the elements inside the shadow root. This is useful to define styles specific to the components. In short, we can say that shadow DOM provides style encapsulation.</p><p>Style encapsulation is not the only benefit of shadow DOM. The HTML inside the shadow root is protected from accidental modification from JavaScript. We can still inspect the shadow root in browser developer tools.</p><p>Many native element, such as <code class="literal">&lt;video&gt;</code> and <code class="literal">&lt;audio&gt;</code>, have a shadow root, but when you inspect it, you won't see the shadow root. Browsers by default hide the shadow roots of these elements. To see their shadow roots, you need to change browser-specific settings.</p><p>Let's modify <a id="id553" class="indexterm"/>the previous custom element code to render the template inside shadow DOM. Replace the previous <code class="literal">createdCallback</code> method with this one:</p><div class="informalexample"><pre class="programlisting">customCardProto.createdCallback = function(){
  var template = document.querySelector("#cardTemplate");
  template.content.querySelector("img").src = this.getAttribute("data-img");
  template.content.querySelector("h3").innerHTML = this.getAttribute("data-title");
  template.content.querySelector("p").innerHTML = this.getAttribute("data-description");

  var clone = document.importNode(template.content, true);

  var shadow = this.createShadowRoot();

  shadow.appendChild(clone);
}</pre></div><p>Here, instead of appending the template code directly to the custom element, we created a shadow root using <code class="literal">createShadowRoot</code> and appended the template code to it.</p></div></div>
<div class="section" title="Setting up an Angular 2 project"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec87"/>Setting up an Angular 2 project</h1></div></div></div><p>Angular 2 code <a id="id554" class="indexterm"/>can be written in JavaScript, TypeScript, or Dart. In case you are writing Angular 2 code in TypeScript or Dart, you will need to transpile the code to JavaScript before serving to the client. We will use JavaScript to write Angular 2 code.</p><p>Create a directory named <code class="literal">angular2-demo</code>. Then, inside the directory, create the <code class="literal">app.js</code> and <code class="literal">package.json</code> files. Then, create a directory named <code class="literal">public</code>, and inside the directory, create four more directories named <code class="literal">html</code>, <code class="literal">js</code>, <code class="literal">componentTemplates</code>, and <code class="literal">componentStyles</code>. Now, create a file named <code class="literal">index.html</code> and place it in the <code class="literal">html</code> directory.</p><p>Then, download <a id="id555" class="indexterm"/>
<code class="literal">angular2-polyfills.js</code>, <code class="literal">Rx.umd.js</code>, and <a id="id556" class="indexterm"/>
<code class="literal">angular2-all.umd.js</code> from <a class="ulink" href="https://cdnjs.com/libraries/angular.js/">https://cdnjs.com/libraries/angular.js/</a> and place them in the <code class="literal">angular2-demo/js</code> directory. These files are what they sound like. You can also enqueue the CDN links directly if you want to.</p><p>Inside the <code class="literal">index.html</code> file, place this starting code:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Angular 2 Demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;script src="/js/angular2-polyfills.js"&gt;&lt;/script&gt;
    &lt;script src="/js/Rx.umd. js"&gt;&lt;/script&gt;
    &lt;script src="/js/angular2-all.umdn.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      //App code here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Inside <a id="id557" class="indexterm"/>the <code class="literal">app.js</code> file, place this code:</p><div class="informalexample"><pre class="programlisting">var express = require("express");
var app = express();

app.use(express.static(__dirname + "/public"));

app.get("/", function(httpRequest, httpResponse, next){
  httpResponse.sendFile(__dirname + "/public/html/index.html");
})

app.listen(8080);</pre></div><p>This is the server-side code. It's self-explanatory.</p><p>Now, in the <code class="literal">package.json</code> file, place this code and run <code class="literal">npm install</code> to download the <code class="literal">express</code> package:</p><div class="informalexample"><pre class="programlisting">{
  "name": "Angular2-Demo",
  "dependencies": {
    "express": "4.13.3"
  }
}</pre></div><p>To start the server, run <code class="literal">node app.js</code>. Then, open the app using <code class="literal">localhost:8080</code> as the address in a browser.</p></div>
<div class="section" title="Angular 2 fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec88"/>Angular 2 fundamentals</h1></div></div></div><p>An Angular 2 <a id="id558" class="indexterm"/>application is completely split into components. Technically, an Angular 2 component is a reusable <code class="literal">custom</code> tag that is mutable and encapsulated with an embedded state, that is, changes to the state or properties will mutate the UI.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>Remember that Angular 2 doesn't register the custom tag name as a custom element.</p></div></div><p>All the components of the application are arranged in a tree structure, with a component as the root node.</p><p>Here is an example of how to create a component. It creates a card component that displays an image, title, and description. Place this code in the <code class="literal">&lt;script&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">var Card = ng.core.Component({
  selector: "card",
  inputs: ["src", "title", "desc"],
  templateUrl: "templates/card-template.html",
  styleUrls: ["templateStyles/card-style.css"]
})
.Class({
  constructor: function(){
  }
})</pre></div><p>Then, create a file named <code class="literal">card-template.html</code>, and place it in the <code class="literal">componentTemplates</code> directory. Place this code in the file:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
  .container
  {
    width: 250px;
    float: left;
    margin-right: 10px;
  }

  img
  {
    width: 100%;
  }
&lt;/style&gt;
&lt;div class="container"&gt;
  &lt;img src="{{src}}" /&gt;
  &lt;div&gt;
    &lt;h3&gt;{{title}}&lt;/h3&gt;
    &lt;p&gt;{{desc}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>After that, create a file named <code class="literal">card-style.css</code> and place it in the <code class="literal">componentStyles</code> directory. Place this code in the file:</p><div class="informalexample"><pre class="programlisting">.container
{
  width: 250px;
  float: left;
  margin-right: 10px;
}

img
{
  width: 100%;
}</pre></div><p>This is <a id="id559" class="indexterm"/>how these three code snippets work:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A component needs to be created by chaining <code class="literal">Component</code> and <code class="literal">Class</code> methods that belong to an <code class="literal">ng.core</code> object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Component</code> method takes a configuration object with various properties, whereas the <code class="literal">Class</code> method takes an object with component lifecycle methods, constructors, and UI action handlers.</li><li class="listitem" style="list-style-type: disc">Here, the configuration properties we've provided are <code class="literal">selector</code>, <code class="literal">inputs</code>, <code class="literal">templateUrl</code>, and <code class="literal">styleUrls</code>. The <code class="literal">selector</code> property is used to define the custom tag for the component. The <code class="literal">inputs</code> property is used to define the attributes that the custom tag takes. The <code class="literal">templateUrl</code> property is used to define the file containing the template of the component. You can also use <code class="literal">template</code> if you want to inline the template code. Finally, <code class="literal">styleUrls</code> is used to define the CSS files containing the style for the component. You can also use the <code class="literal">styles</code> property to inline CSS code, or you can define CSS using a <code class="literal">&lt;style&gt;</code> tag inside the template itself. CSS defined in any of these three ways won't affect other components, that is, it's encapsulated to the component itself.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">Class</code> method, we will have to provide the <code class="literal">constructor</code> method even if it does nothing. It's invoked during the construction of a new instance of the component. By construction of the component, I mean the construction of the component in memory—not resolving attributes, resolving its children, rendering its view, and so on. The primary use of the <code class="literal">constructor</code> method is to inject services into the component. Services cannot be injected automatically as we may sometimes need to initialize services for every component, and Angular is unaware of how to do this. The <code class="literal">constructor</code> method has access to the state of the component but not its properties. Here, we shouldn't do any heavy work or something else that would slow down or cause the construction of the component to fail. <code class="literal">constructor</code> is not a component lifecycle method.</li><li class="listitem" style="list-style-type: disc">Then, we have the component template code. In this template file, we are simply rendering the properties passed to the component. To render anything that's in the component state, we need to use the <code class="literal">{{}}</code> token.</li></ul></div><p>Let's create <a id="id560" class="indexterm"/>another component called <code class="literal">Cards</code>, which displays a list of cards. It gets information about cards from a service.</p><p>Place this code in the <code class="literal">&lt;script&gt;</code> tag of the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">var CardsService = ng.core.Class({
  constructor: function() {
  },
  getCards: function() {
    return [{
      src: "http://placehold.it/350x150",
      title: "Title 1",
      desc: "Description 1"
    },
    {
      src: "http://placehold.it/350x150",
      title: "Title 2",
      desc: "Description 2"
    },
    {
      src: "http://placehold.it/350x150",
      title: "Title 3",
      desc: "Description 3"
    }]
  }
});

var Cards = ng.core.Component({
  selector: "cards",
  viewProviders: [CardsService],
  directives: [Card],
  templateUrl: "componentTemplates/cards-template.html"
}).Class({
  constructor: [CardsService, function(cardsService){
    this.getCards = cardsService.getCards;
}],
  ngOnInit: function(){
    this.cards = this.getCards();
  }
})

var App = ng.core.Component({
  selector: "app",
  directives: [Cards],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){

  }
})

ng.platform.browser.bootstrap(App);</pre></div><p>Now, create <a id="id561" class="indexterm"/>a file named <code class="literal">cards-template.html</code> in the <code class="literal">componentTemplates</code> directory and place this code in it:</p><div class="informalexample"><pre class="programlisting">&lt;card *ngFor="#card of cards" title="{{card.title}}" src="{{card.src}}" desc="{{card.desc}}"&gt;&lt;/card&gt;</pre></div><p>Now, create a file named <code class="literal">app-template.html</code> in the <code class="literal">componentTemplates</code> directory  and place this code in it:</p><div class="informalexample"><pre class="programlisting">&lt;cards&gt;&lt;/cards&gt;</pre></div><p>Now, in the <code class="literal">&lt;body&gt;</code> tag of the <code class="literal">index.html</code> file, place this code:</p><div class="informalexample"><pre class="programlisting">&lt;app&gt;&lt;/app&gt;</pre></div><p>Here is how these four code snippets work:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To create a service, we need to use the <code class="literal">ng.core.Class</code> method. It takes an object with the <code class="literal">constructor</code> method and other methods or properties that the service exposes. While injecting the service into other services or components, a new instance of the service is created and injected. While creating a new instance of a service, the <code class="literal">constructor</code> method is called. We have to provide this method even if it doesn't do anything. The primary purpose of this method is to inject services that this service depends on. Here, our <code class="literal">CardsService</code> method is not dependent on any other service, so we have no code inside the <code class="literal">constructor</code> method. Then, we defined a <code class="literal">getCards</code> method, which returns data of three different cards to display.</li><li class="listitem" style="list-style-type: disc">Then, we created a <code class="literal">Cards</code> component. It takes the data from <code class="literal">CardsService</code> and renders a <code class="literal">Card</code> component for each card data. While creating the <code class="literal">Cards</code> component, we provide <code class="literal">viewProviders</code> and <code class="literal">directives</code> properties to the configuration object. <code class="literal">viewProviders</code> is the list of services the component is dependent on, and <code class="literal">directives</code> is the list of other components this component renders. Here, you can see that instead of directly assigning a function <a id="id562" class="indexterm"/>to the <code class="literal">constructor</code> property, we are assigning an array with a list of services the component depends upon and the last array item as the actual function. This is the format of injecting services into components. Inside the <code class="literal">constructor</code> method, we store references to the methods or properties of the service that the component needs, that is, we can use services inside the <code class="literal">constructor</code> method. We will learn more about <code class="literal">viewProviders</code> later on. The <code class="literal">this</code> keyword in any of the methods passed to the <code class="literal">Class</code> method points to the state of the component. After a component instance has been created, whenever the component state changes, the template bindings are updated. We have another method here, called <code class="literal">ngOnInit</code>. It's a lifecycle method that's invoked after a new instance of the component has been created and its attributes resolved. Inside this, we call the <code class="literal">getCards</code> method and store the returned value inside the <code class="literal">cards</code> property of the state. Note that the attributes passed to a component tag are accessible using the <code class="literal">this</code> keyword after the component instance has been created.</li><li class="listitem" style="list-style-type: disc">Inside the template of <code class="literal">CardsComponent</code>, we are using the <code class="literal">*ngFor</code> directive to display the cards. We will learn more about directives later.</li><li class="listitem" style="list-style-type: disc">Then, we create an <code class="literal">App</code> component, which acts as the root of our component. Inside this component, we are displaying the <code class="literal">Cards</code> component.</li><li class="listitem" style="list-style-type: disc">Finally, we initialize the application. An Angular 2 application is initialized explicitly. While initializing it, we need to provide a reference to the root component. This is done to ensure that applications are composed of nested components all the way down. The root component is the one that's added to the <code class="literal">&lt;body&gt;</code> tag. Adding tags of other components to the body tag will not do anything.</li></ul></div><p>Now, if you refresh your <code class="literal">localhost:8080</code> page in your browser, you will see this output:</p><div class="mediaobject"><img src="graphics/B05154_12_03.jpg" alt="Angular 2 fundamentals"/></div></div>
<div class="section" title="Styling components and shadow DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec89"/>Styling components and shadow DOM</h1></div></div></div><p>Earlier, we <a id="id563" class="indexterm"/>saw that there are three ways of defining <a id="id564" class="indexterm"/>styles specific to components (styles encapsulated in the component template scope). A component's CSS doesn't even affect the components it owns.</p><p>Angular 2 doesn't use shadow DOM by default; instead, it uses a different technique to achieve style encapsulation. This is due to the lack of browser support.</p><p>By default, Angular 2 modifies the CSS selector in such a way that it only targets the elements in the component, and it then places the CSS in the <code class="literal">&lt;head&gt;</code> tag of the page. If you inspect our current app using browser developer tools, you will see this:</p><div class="mediaobject"><img src="graphics/B05154_12_04.jpg" alt="Styling components and shadow DOM"/></div><p>Here, you <a id="id565" class="indexterm"/>can <a id="id566" class="indexterm"/>see that the CSS has been modified and inserted into the <code class="literal">&lt;head&gt;</code> tag.</p><p>To force Angular 2 to use shadow DOM, we need to assign the encapsulation property of the component configuration object to <code class="literal">ng.core.ViewEncapsulation.Native</code>. By default, it's assigned to <code class="literal">ng.core.ViewEncapsulation.Emulated</code>.</p><p>When <a id="id567" class="indexterm"/>you <a id="id568" class="indexterm"/>inspect the app after assigning the encapsulation property of the <code class="literal">Card</code> and <code class="literal">Cards</code> components to <code class="literal">ng.core.ViewEncapsulation.Native</code>, you will see something like this:</p><div class="mediaobject"><img src="graphics/B05154_12_05.jpg" alt="Styling components and shadow DOM"/></div><p>Here, you can see that shadow DOM was used to achieve style encapsulation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>In case you don't want style encapsulation for a component, you can assign the encapsulation property to <code class="literal">ng.core.ViewEncapsulation.None</code>. In this case, all of the CSS will be placed directly in the <code class="literal">&lt;head&gt;</code> tag.</p></div></div></div>
<div class="section" title="Angular 2 change detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec90"/>Angular 2 change detection</h1></div></div></div><p>
<span class="strong"><strong>Change detection</strong></span> <a id="id569" class="indexterm"/>is the process of detecting component state change. The state of a component is stored and manipulated using the <code class="literal">this</code> keyword. Therefore, there <a id="id570" class="indexterm"/>is no direct way for Angular 2 to detect when the state changes. So, Angular 2 uses complex algorithms and third-party libraries to detect state changes.</p><p>The first thing Angular 2 does for detecting state changes is that it pretends that all the changes happen asynchronously. Then, it uses the <code class="literal">zone.js</code> library to monitor browser events, timers, AJAX requests, WebSockets, and other asynchronous things that are supported by <code class="literal">zone.js</code>.</p><p>Now, whenever any of these asynchronous activities takes place, it checks everything that could change, including object properties and array elements of the <code class="literal">this</code> keyword of all the components from the root node; if any change is detected, then the template bindings of the component are updated. Angular 2 doesn't simply re-render the whole component. Instead, it checks for the bindings that have changed and selects and updates them specifically.</p><p>Some components can have a lot of state data, and checking the state for every asynchronous operation will unnecessarily impact app performance if their state has not changed. Therefore, Angular 2 provides an option to mark such kinds of components so that it does not check their states unless the component itself tells Angular 2 to check its state during the next detection cycle, that is, when the next asynchronous activity occurs. Let's look at an example to demonstrate this.</p><p>Place this code above the <code class="literal">App</code> component code in the <code class="literal">&lt;script&gt;</code> tag of the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">var SampleComponent1 = ng.core.Component({
  selector: "sampleone",
  template: "{{value}}",
  viewProviders: [ng.core.ChangeDetectorRef],
  changeDetection: ng.core.ChangeDetectionStrategy.Detached
}).Class({
  constructor: [ng.core.ChangeDetectorRef, function(cd){
    this.cd = cd;
  }],
  ngOnInit: function(){
    this.value = 1;
    setInterval(function(){
      this.value++;
      this.cd.markForCheck();
    }.bind(this), 2000)
  }
})</pre></div><p>Then, add <code class="literal">SampleComponent1</code> to the <code class="literal">directives</code> array of the <code class="literal">App</code> component. So now, the <code class="literal">App</code> component's code should be this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){
  }
})</pre></div><p>Now, add <a id="id571" class="indexterm"/>this code to the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;br style="clear: both"&gt;
&lt;sampleone&gt;&lt;/sampleone&gt;</pre></div><p>Here is how these three code snippets work:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In this example, we are displaying a value that gets incremented every 2 seconds and the template is re-rendered to display the updated value.</li><li class="listitem">At first, we create a component called <code class="literal">SampleComponent1</code>. It simply displays <code class="literal">value</code>. We have set the <code class="literal">changeDetection</code> property to <code class="literal">ng.core.ChangeDetectionStrategy.Detached</code>, which tells Angular 2 to not check its state change. By default, the <code class="literal">changeDetection</code> property is assigned to <code class="literal">ng.core.ChangeDetectionStrategy.Default</code>, which tells Angular 2 to check its state change during every change-detection cycle. We then inject the <code class="literal">ng.core.ChangeDetectorRef</code> service into the component, which provides various APIs related to change detection. And then, in the <code class="literal">ngOnInit</code> method, we increment the value of <code class="literal">value</code> every 2 seconds, after which we call the <code class="literal">markForCheck</code> method of <code class="literal">ng.core.ChangeDetectorRef</code>, which tells Angular 2 to check for changes in the state of the component during the next change-detection cycle. <code class="literal">markForCheck</code> will make Angular 2 check for a change in state for the next detection cycle only, not for the ones after that.</li><li class="listitem">Then, we simply display <code class="literal">SampleComponent1</code> in the <code class="literal">App</code> component.</li></ol></div><p>If a <a id="id572" class="indexterm"/>component depends only on its inputs and/or UI events or if you want a component's state change, check only whether its inputs have changed or events have been fired; then, you can assign <code class="literal">changeDetection</code> to <code class="literal">ng.core.ChangeDetectionStrategy.OnPush</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>If at any time you want to force a change-detection cycle instead of waiting for an asynchronous operation to happen, you can call the <code class="literal">detectChanges</code> method of the <code class="literal">ng.core.ChangeDetectorRef</code> service.</p></div></div></div>
<div class="section" title="Understanding view children and content children"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec91"/>Understanding view children and content children</h1></div></div></div><p>Elements present inside the tags of a component are <a id="id573" class="indexterm"/>called <span class="strong"><strong>content children</strong></span>, and <a id="id574" class="indexterm"/>elements present inside the template of a component are called <span class="strong"><strong>view children</strong></span>.</p><p>To display the content children of a component in the component's view, we need to use the <code class="literal">&lt;ng-content&gt;</code> tag. Let's look at an example of this.</p><p>Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var ListItem = ng.core.Component({
  selector: "item",
  inputs: ["title"],
  template: "&lt;li&gt;{{title}} | &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/li&gt;",
}).Class({
  constructor: function(){}
})

var List = ng.core.Component({
  selector: "list",
  template: "&lt;ul&gt;&lt;ng-content select='item'&gt;&lt;/ng-content&gt;&lt;/ul&gt;"
}).Class({
  constructor: function(){}
})</pre></div><p>Now, change the <code class="literal">App</code> component's code to this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>To the end of the <code class="literal">app-template.html</code> file, add this code:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;
&lt;list&gt;
  &lt;item title="first"&gt;first&lt;/item&gt;
  &lt;item title="second"&gt;second&lt;/item&gt;
&lt;/list&gt;</pre></div><p>The <a id="id575" class="indexterm"/>output of this code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_06.jpg" alt="Understanding view children and content children"/></div><p>This is <a id="id576" class="indexterm"/>how these three code snippets work:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">App</code> component's template file, we add a <code class="literal">&lt;list&gt;</code> tag, which displays a list. And inside its opening and closing tags, we define the individual list items that it should display.</li><li class="listitem">We create <code class="literal">ListItem</code> and <code class="literal">List</code> components that are bound to <code class="literal">&lt;list&gt;</code> and <code class="literal">&lt;item&gt;</code> tags, respectively.</li><li class="listitem">We add <code class="literal">List</code> component to the <code class="literal">directives</code> property of the <code class="literal">App</code> component, not <code class="literal">List</code>, because the <code class="literal">&lt;list&gt;</code> tag is present in the template of the <code class="literal">App</code> component, and the <code class="literal">App</code> component is responsible for creating its instances.</li><li class="listitem">The<code class="literal"> App</code> component looks for the <code class="literal">&lt;ng-content&gt;</code> tag in the template of the <code class="literal">List</code> component and renders the <code class="literal">List</code> component instances there.</li><li class="listitem"><code class="literal">&lt;ng-content&gt;</code> takes an optional <code class="literal">select</code> attribute that's assigned to a CSS selector that indicates which elements of the content children we want to display. There can be multiple <code class="literal">&lt;ng-content&gt;</code> tags in a template. If the <code class="literal">select</code> attribute has not been provided, then all the content children will be rendered. Here, the <code class="literal">select</code> attribute is not required; we are using it just for demonstration.</li></ol></div><div class="section" title="Getting the reference of components of content children and view children"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec87"/>Getting the reference of components of content children and view children</h2></div></div></div><p>To get <a id="id577" class="indexterm"/>access to the reference of <a id="id578" class="indexterm"/>components of view children or content children, we can use the <code class="literal">ng.core.ContentChildren</code>, <code class="literal">ng.coreViewChildren</code>, <code class="literal">ng.core.ContentChild</code>, and <code class="literal">ng.core.ViewChild</code> constructors. The difference between <code class="literal">ng.core.ContentChildren</code> and <code class="literal">ng.core.ContentChild</code> is <a id="id579" class="indexterm"/>that <a id="id580" class="indexterm"/>the first one returns all the references of a given component whereas the second one returns the reference of the first occurrence. The same difference also stands for <code class="literal">ng.core.ViewChild</code> and <code class="literal">ng.core.ViewChildren</code>.</p><p>Here is an example to demonstrate <code class="literal">ng.core.ContentChildren</code>. Replace the code for the <code class="literal">List</code> component with this:</p><div class="informalexample"><pre class="programlisting">var List = ng.core.Component({
  selector: "list",
  template: "&lt;ul&gt;&lt;ng-content select='item'&gt;&lt;/ng-content&gt;&lt;/ul&gt;",
  queries: {
    list_items: new ng.core.ContentChildren(ListItem)
  }
}).Class({
  constructor: function(){},
  ngAfterContentInit: function(){
    this.list_items._results.forEach(function(e){
      console.log(e.title);
    })
  }
})</pre></div><p>The output of this code in the console is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>first</strong></span>
<span class="strong"><strong>second</strong></span>
</pre></div><p>Most of this code is self-explanatory. What's new is the <code class="literal">ngAfterContentInit</code> lifecycle method. It's triggered after the content children have been initialized. Similarly, if we want to access the view children, we need to use the <code class="literal">ngAfterViewInit</code> lifecycle method.</p><p>Note that we only have access to the state of the components—nothing else.</p></div><div class="section" title="Local template variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec88"/>Local template variables</h2></div></div></div><p>We can <a id="id581" class="indexterm"/>assign a local template variable to a content child or view child. Local template variables let us get the reference of any element <a id="id582" class="indexterm"/>of the content children or view children, that is, component references or HTML element references.</p><p>To assign a local template variable to an element of the view children or content children, we need to place <code class="literal">#variable_name</code> in the opening tag.</p><p>Here is <a id="id583" class="indexterm"/>an example to demonstrate how local <a id="id584" class="indexterm"/>template variables work. Place this code above the <code class="literal">App</code> component:</p><div class="informalexample"><pre class="programlisting">var SampleComponent2 = ng.core.Component({
  selector: "sampletwo",
  template: "&lt;input type='text' #input /&gt;",
  queries: {
    input_element: new ng.core.ViewChild("input")
  }
}).Class({
  constructor: function(){},
  ngAfterViewInit: function(){
    this.input_element.nativeElement.value = "Hi";
  }
})</pre></div><p>Change the <code class="literal">App</code> component's code to this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem,
  SampleComponent2],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>And then, add this code to the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;sampletwo&gt;&lt;/sampletwo&gt;</pre></div><p>The output of this code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_07.jpg" alt="Local template variables"/></div><p>Here is how these three code snippets work:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new component named <code class="literal">SampleComponent2</code>, which displays an HTML input text element. We assign the input element to a local template variable named <code class="literal">input</code>.</li><li class="listitem">Then, we use the <code class="literal">ng.core.ViewChild</code> to get a reference to the element. If we pass a string to <code class="literal">ng.core.ViewChild</code>, <code class="literal">ng.core.ViewChildren</code>, <code class="literal">ng.core.ContentChild</code>, and <code class="literal">ng.core.ContentChildren</code>, then they will look for the elements with the <a id="id585" class="indexterm"/>same <a id="id586" class="indexterm"/>local variable name as the string, and if we pass a component, they will look for the component, like we saw before.</li><li class="listitem">The reference of the components we get from the local template variable is of the same interface we got before. But for HTML element references, we can access the real DOM of the element by using the <code class="literal">nativeElement</code> property.</li></ol></div></div></div>
<div class="section" title="Component lifecycle methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec92"/>Component lifecycle methods</h1></div></div></div><p>When a <a id="id587" class="indexterm"/>
<code class="literal">component</code> tag appears, Angular 2 creates an instance of a component, renders it, checks for changes in attributes, checks for changes in state, and destroys it when it's no longer needed. These steps together form the lifecycle of a component.</p><p>Angular 2 lets us register methods that are called at various stages of the component lifecycle.</p><p>Here are the various lifecycle methods provided by Angular 2; lifecycle hooks are explained in the order they occur:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ngOnChanges</code>: This is <a id="id588" class="indexterm"/>invoked whenever the attributes of a component change. It's also invoked after the attributes of a component are resolved for the first time after the creation of a new instance of the component. It's invoked after the state has been changed due to the attributes but before the view is updated. This method receives the current and previous values of the attributes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngOnInit</code>: This is <a id="id589" class="indexterm"/>invoked after the first instance of <code class="literal">ngOnChanges</code>. It states that the component has been successfully created and attributes have been read.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngDoCheck</code>: This is <a id="id590" class="indexterm"/>called during every change-detection cycle and right after <code class="literal">ngOnInit</code>. We can detect and act upon changes that Angular 2 can't or won't detect on its own. This is invoked after Angular 2 is done checking state changes for the component and has updated the state if there was any change in the attributes but before the component view is updated. After this call is over, the view is rendered, and while rendering it, <code class="literal">ngAfterContentInit</code>, <code class="literal">ngAfterContentChecked</code>, <code class="literal">ngAfterViewInit</code>, and <code class="literal">ngAfterViewChecked</code> are invoked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngAfterContentInit</code>: This is <a id="id591" class="indexterm"/>invoked after content children have been initialized but not yet rendered, that is, after the <code class="literal">ngOnChanges</code>, <code class="literal">ngOnInit</code>, <code class="literal">ngDoCheck</code>, <code class="literal">ngAfterContentInit</code>, and <code class="literal">ngAfterContentChecked</code> methods of the content children have been called.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngAfterContentChecked</code>: This is <a id="id592" class="indexterm"/>invoked whenever the change-detection cycle checks whether the content children have changed as well as right after <code class="literal">ngAfterContentInit</code>. If there is a change, it's invoked before the views of the content children are updated. Before invoking it, the query results of <code class="literal">ng.core.ViewChildren</code>, <code class="literal">ng.core.ContentChildren</code>, and so on are updated, that is, it's invoked after <code class="literal">ngAfterContentChecked</code> of the content children has been invoked. After this call, the content children views are updated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngAfterViewInit</code>: This is <a id="id593" class="indexterm"/>invoked after view children have been initialized but not yet rendered, that is, after the <code class="literal">ngOnChanges</code>, <code class="literal">ngOnInit</code>, <code class="literal">ngDoCheck</code>, <code class="literal">ngAfterContentInit</code>, <code class="literal">ngAfterContentChecked</code>, <code class="literal">ngAfterViewInit</code>, and <code class="literal">ngAfterViewChecked</code> methods of the view children have been called.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngAfterViewChecked</code>: This is <a id="id594" class="indexterm"/>invoked whenever the change-detection cycle checks whether the view children have changed as well as right after <code class="literal">ngAfterViewInit</code>. If there is a change, it's invoked before the views of the view children are updated but after the <code class="literal">ngAfterViewChecked</code> methods of the view children have been invoked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngOnDestroy</code>: This is <a id="id595" class="indexterm"/>invoked before a component is destroyed. The <code class="literal">ngOnDestroy</code> method of a component is invoked before the <code class="literal">ngOnDestroy</code> methods of its content children and view children.</li></ul></div></div>
<div class="section" title="Writing templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec93"/>Writing templates</h1></div></div></div><p>We need <a id="id596" class="indexterm"/>to use template language to write component templates. Template language is composed of HTML along with the <code class="literal">{}</code>, <code class="literal">[]</code>, <code class="literal">()</code>, <code class="literal">[()]</code>, <code class="literal">*</code>, <code class="literal">|</code>, and <code class="literal">#</code> tokens. Let's see what each of these is used for and how to use them.</p><div class="section" title="Rendering a value"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec89"/>Rendering a value</h2></div></div></div><p>To simply <a id="id597" class="indexterm"/>render a property of the <code class="literal">this</code> keyword, we need to use the <code class="literal">{{}}</code> token. Inside these braces, we can simply place the property name.</p><p>We can only place expressions inside braces. The expressions we place inside them look like JavaScript. But there are a few JavaScript expressions that we are not allowed to use inside these braces. Here they are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assignments (<code class="literal">=</code>, <code class="literal">+=</code>, <code class="literal">-=</code>)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">new</code> operator</li><li class="listitem" style="list-style-type: disc">Chaining expressions with <code class="literal">;</code> or <code class="literal">,</code></li><li class="listitem" style="list-style-type: disc">Increment and decrement operators (<code class="literal">++</code> and <code class="literal">--</code>)</li><li class="listitem" style="list-style-type: disc">The bitwise operators <code class="literal">|</code> and <code class="literal">&amp;</code></li></ul></div><div class="section" title="Pipes"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec25"/>Pipes</h3></div></div></div><p>We can <a id="id598" class="indexterm"/>also place <code class="literal">pipes</code> in braces. A pipe is a function that accepts an input value and returns a transformed value. A pipe is represented by the <code class="literal">|</code> operator. The final result of expressions <a id="id599" class="indexterm"/>inside braces can be transformed using pipes. There can be as many pipes in the braces as we want. A pipe can also take parameters.</p><p>Angular 2 provides some built-in pipes: <code class="literal">date</code>, <code class="literal">uppercase</code>, <code class="literal">lowercase</code>, <code class="literal">currency</code>, and <code class="literal">percent</code>. We can also create our own pipes.</p><p>Here is an example of using <code class="literal">{{}}</code>. Place this code above the <code class="literal">App</code> component:</p><div class="informalexample"><pre class="programlisting">var SampleComponent3 = ng.core.Component({
  selector: "samplethree",
  template: "{{info.firstname + info.lastname | uppercase}}"
}).Class({
  constructor: function(){
    this.info = {
      firstname: "firstname",
      lastname: " lastname"
    }
  }
})</pre></div><p>Replace the <code class="literal">App</code> component code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem,
  SampleComponent2, SampleComponent3],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>And then, place this in the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;&lt;br&gt;
&lt;samplethree&gt;&lt;/samplethree&gt;</pre></div><p>The output of the code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_08.jpg" alt="Pipes"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Note that the final result of the expression inside the braces is converted into a string if the final value is not a string.</p></div></div></div></div><div class="section" title="Handling events"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec90"/>Handling events</h2></div></div></div><p>To handle <a id="id600" class="indexterm"/>events of elements in a template, we need to <a id="id601" class="indexterm"/>use the <code class="literal">()</code> operator. Here is an example of how to handle events. Place this code above the <code class="literal">App</code> component code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent4 = ng.core.Component({
  selector: "samplefour",
  template: "&lt;input (click)='clicked($event)' (mouseover)='mouseover($event)' type='button'value='Click Me!!!' /&gt;"
}).Class({
  constructor: function(){
    this.clicked = function(e){
      alert("Hi from SampleComponent4");
    };

    this.mouseover = function(e){
      console.log("Mouse over event");
    }

  }
})</pre></div><p>Replace the <code class="literal">App</code> component code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem,
  SampleComponent2, SampleComponent3, SampleComponent4],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Place this code in <code class="literal">app-template.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;&lt;br&gt;
&lt;samplefour&gt;&lt;/samplefour&gt;</pre></div><p>The preceding code is self-explanatory.</p></div><div class="section" title="Binding state to element attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec91"/>Binding state to element attributes</h2></div></div></div><p>To bind <a id="id602" class="indexterm"/>the value of a property of the <code class="literal">this</code> keyword to the attribute of an element in a template, we can simply use <code class="literal">{{}}</code>, like this, for example:</p><div class="informalexample"><pre class="programlisting">&lt;component title="{{title}}"&gt;&lt;/component&gt;</pre></div><p>But if <a id="id603" class="indexterm"/>you want to pass an object, this method will <a id="id604" class="indexterm"/>not work, as the expression inside the <code class="literal">{{}}</code> token is always converted to a string. Therefore, Angular 2 provides the <code class="literal">[]</code> operator, which enables a component to pass an object through attributes to a component in its template.</p><p>Here is an example to demonstrate this. Place this code above the <code class="literal">App</code> component code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent5 = ng.core.Component({
  selector: "samplefive",
  inputs: ["info"],
  template: "{{info.name}}"
}).Class({
  constructor: function(){}
})

var SampleComponent6 = ng.core.Component({
  selector: "samplesix",
  directives: [SampleComponent5],
  template: "&lt;samplefive [info]='myInfo'&gt;&lt;/samplefive&gt;"
}).Class({
  constructor: function(){
    this.myInfo = {
      name: "Name"
    }
  }
})</pre></div><p>Replace the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Place <a id="id605" class="indexterm"/>this code at the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;&lt;br&gt;
&lt;samplesix&gt;&lt;/samplesix&gt;</pre></div><p>The output of this code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_09.jpg" alt="Binding state to element attributes"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>Note that while assigning attributes to an HTML tag, if we assign an attribute that's not native to the element, we need to prefix the attribute name using <code class="literal">attr.</code>. For example, to assign a <code class="literal">value</code> attribute to a <code class="literal">&lt;span&gt;</code> tag, we need to name the attribute <code class="literal">attr.value</code>, not simply <code class="literal">value</code>. Otherwise, Angular 2 will throw an error. This is because while interpreting a template and creating its DOM, Angular 2 sets the attributes by assigning the values to the properties of DOM elements. So when we use the <code class="literal">attr.</code> prefix, it signals Angular 2 to use <code class="literal">setAttribute</code> instead.</p></div></div></div><div class="section" title="Two-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec92"/>Two-way data binding</h2></div></div></div><p>By default, Angular 2 <a id="id606" class="indexterm"/>doesn't use two-way data binding. It uses unidirectional binding but offers the <code class="literal">[()]</code> operator for two-way data binding, if needed.</p><p>Here is <a id="id607" class="indexterm"/>an example to demonstrate <code class="literal">[()]</code>. Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent7 = ng.core.Component({
  selector: "sampleseven",
  template: "&lt;input [(ngModel)]='name' /&gt;&lt;input (click)='clicked()' value='Click here' type='submit' /&gt;"
}).Class({
  constructor: function(){},
  clicked: function(){
    alert(this.name);
  }
})</pre></div><p>Replace <a id="id608" class="indexterm"/>the <code class="literal">App</code> component code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4,SampleComponent6, SampleComponent7],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Place <a id="id609" class="indexterm"/>this code in the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;&lt;br&gt;
&lt;sampleseven&gt;&lt;/sampleseven&gt;</pre></div><p>The output of this code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_10.jpg" alt="Two-way data binding"/></div><p>Here, enter something in the text field and click on the button. You will see an alert box with the text field's value.</p><p>To capture the value of HTML form elements, we need to place <code class="literal">ngModel</code> inside the <code class="literal">[()]</code> brackets. We can place an attribute name if we are setting up two-way data binding between inputs and outputs. We will learn more about outputs later.</p></div><div class="section" title="Directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec93"/>Directives</h2></div></div></div><p>
<span class="strong"><strong>Directives</strong></span> <a id="id610" class="indexterm"/>are used to change the DOM based on the <a id="id611" class="indexterm"/>state. There are two types of directives: attribute directives and structural directives. Let's look at each of them.</p><div class="section" title="Attribute directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec26"/>Attribute directives</h3></div></div></div><p>An <span class="strong"><strong>attribute directive</strong></span> <a id="id612" class="indexterm"/>changes the appearance or behavior <a id="id613" class="indexterm"/>of a DOM element based on a change in state. <code class="literal">ngClass</code> and <code class="literal">ngStyle</code> are the built-in attribute directives. We can also create our own attribute directives.</p><p>The<code class="literal"> ngClass</code> directive is used to add or remove CSS classes from an element whereas the <code class="literal">ngStyle</code> directive is used to set inline styles.</p><p>Here is <a id="id614" class="indexterm"/>an example of how to use the <code class="literal">ngClass</code> and <code class="literal">ngStyle</code> directives. Place <a id="id615" class="indexterm"/>this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent8 = ng.core.Component({
  selector: "sampleeight",
  template: "&lt;div [ngStyle]='styles' [ngClass]='classes'&gt;&lt;/div&gt;"
}).Class({
  constructor: function(){
    this.styles = {
      "font-size": "20px",
      "font-weight": "bold"
    }

    this.classes = {
      a: true,
      b: true,
      c: false
    };
  }
})</pre></div><p>Replace the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>And then, place this code at the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;sampleeight&gt;&lt;/sampleeight&gt;</pre></div><p>Now, if you inspect the <code class="literal">&lt;sampleeight&gt;</code> tag in browser developer tools, you will see this:</p><div class="mediaobject"><img src="graphics/B05154_12_11.jpg" alt="Attribute directives"/></div><p>Most <a id="id616" class="indexterm"/>of this code is self-explanatory. You can see that <a id="id617" class="indexterm"/>the same <code class="literal">[]</code> token is also used for attribute directives. When the <code class="literal">[]</code> token is used, Angular 2 first checks to see whether a built-in attribute directive or custom directive is present with that name, and if not, it treats it as an attribute.</p></div><div class="section" title="Structural directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec27"/>Structural directives</h3></div></div></div><p>A <span class="strong"><strong>structural directive</strong></span> <a id="id618" class="indexterm"/>changes the DOM layout by <a id="id619" class="indexterm"/>adding or removing DOM elements. <code class="literal">ngIf</code>, <code class="literal">ngSwitch</code>, and <code class="literal">ngFor</code> are the three built-in structural directives. We can also create our own custom structural directives.</p><p>Here is an example to demonstrate <code class="literal">ngIf</code> and <code class="literal">ngSwitch</code>. We have already seen an example of <code class="literal">ngFor</code> previously. Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent9 = ng.core.Component({
  selector: "samplenine",
  templateUrl: "componentTemplates/samplecomponent9-template.html"
}).Class({
  constructor: function(){
    this.display1 = true;
    this.display2 = false;
    this.switchOption = 'A';
  }
})</pre></div><p>Create a file named <code class="literal">samplecomponent9-template.html</code>, and place it in the <code class="literal">componentTemplates</code> directory. Place this code in that file:</p><div class="informalexample"><pre class="programlisting">&lt;br&gt;&lt;br&gt;

&lt;div *ngIf="display1"&gt;Hello&lt;/div&gt;
&lt;div *ngIf="display2"&gt;Hi&lt;/div&gt;

&lt;span [ngSwitch]="switchOption"&gt;
  &lt;span *ngSwitchWhen="'A'"&gt;A&lt;/span&gt;
  &lt;span *ngSwitchWhen="'B'"&gt;B&lt;/span&gt;
  &lt;span *ngSwitchWhen="'C'"&gt;C&lt;/span&gt;
  &lt;span *ngSwitchWhen="'D'"&gt;D&lt;/span&gt;
  &lt;span *ngSwitchDefault&gt;other&lt;/span&gt;
&lt;/span&gt;</pre></div><p>Replace the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8, SampleComponent9],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Finally, place <a id="id620" class="indexterm"/>this code in the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;samplenine&gt;&lt;/samplenine&gt;</pre></div><p>The <a id="id621" class="indexterm"/>output of this code is as follows:</p><div class="mediaobject"><img src="graphics/B05154_12_13.jpg" alt="Structural directives"/></div><p>Most of this code is self-explanatory. You can see that we are using the <code class="literal">*</code> token for structural directives. The <code class="literal">*</code> token treats the element as a template, that is, it doesn't render the element but uses it as a template to create the DOM.</p><p>Actually, both attribute and structural directives are written using the <code class="literal">[]</code> token, but writing code using structural directives with the <code class="literal">[]</code> token makes the code longer. Therefore, Angular 2 introduced the <code class="literal">*</code> token, which makes it easy to write code using structural directives. Internally, Angular 2 translates the code that uses the <code class="literal">*</code> token to use the <code class="literal">[]</code> token. Learn <a id="id622" class="indexterm"/>more about it here:</p><p>
<a class="ulink" href="https://angular.io/docs/ts/latest/guide/template-syntax.html#">https://angular.io/docs/ts/latest/guide/template-syntax.html#</a>
</p></div></div></div>
<div class="section" title="Outputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec94"/>Outputs</h1></div></div></div><p>
<span class="strong"><strong>Outputs</strong></span> allow <a id="id623" class="indexterm"/>components to emit custom events. For example, if we have a component that displays a button and we want the parent component to be able to add an event handler for the click event of the child component, we can achieve this using outputs.</p><p>Here is an example of how to integrate outputs. Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent10 = ng.core.Component({
  selector: "sampleten",
  outputs: ["click"],
  template: ""
}).Class({
  constructor: function(){
    this.click = new ng.core.EventEmitter();
    setInterval(function(){
      this.click.next({});
    }.bind(this), 10000)
  }
})

var SampleComponent11 = ng.core.Component({
  selector: "sampleeleven",
  directives: [SampleComponent10],
  template: "&lt;br&gt;&lt;sampleten
  (click)='clicked($event)'&gt;&lt;/sampleten&gt;{{value}}"
}).Class({
  constructor: function(){
    this.value = 1;
    this.clicked = function(e){
      this.value++;
    }
  }
})</pre></div><p>Replace <a id="id624" class="indexterm"/>the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8, SampleComponent9, SampleComponent11],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Finally, place this code at the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;sampleeleven&gt;&lt;/sampleeleven&gt;</pre></div><p>Now, you will start seeing a counter appear on the page.</p><p>The <code class="literal">outputs</code> property is used to define the events the component emits. We need to create <a id="id625" class="indexterm"/>a property in this keyword with the same name as the output and assign it to a new instance of <code class="literal">ng.core.EventEmitter</code> so that it can emit events. <code class="literal">ng.core.EventEmitter</code> provides observer patterns to objects.</p><p>To capture events, we need to use the <code class="literal">()</code> token, just like we used it to capture native UI events.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>Note that we need to assign output to a new instance of <code class="literal">ng.core.EventEmitter</code> inside the constructor property, that is, during the creation of a new instance of the component.</p></div></div><div class="section" title="Two-way data binding with inputs and outputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec94"/>Two-way data binding with inputs and outputs</h2></div></div></div><p>You can <a id="id626" class="indexterm"/>implement two-way data binding between inputs and outputs. For example, if a parent component passes an attribute to a component of the view children and the child component notifies the parent component whenever the input value changes, then instead of using <code class="literal">()</code> and <code class="literal">[]</code> separately, we can use <code class="literal">[()]</code>.</p><p>Here is an example to demonstrate this. Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var SampleComponent12 = ng.core.Component({
  selector: "sampletwelve",
  inputs: ["count"],
  outputs: ["countChange"],
  template: ""
}).Class({
  constructor: function(){
    this.countChange = new ng.core.EventEmitter();
    setInterval(function(){
      this.count++;
      this.countChange.next(this.count);
    }.bind(this), 10000);
  }
})

var SampleComponent13 = ng.core.Component({
  selector: "samplethirteen",
  directives: [SampleComponent12],
  template: "&lt;br&gt;&lt;sampletwelve
  [(count)]='count'&gt;&lt;/sampletwelve&gt;{{count}}"
}).Class({
  constructor: function(){
    this.count = 1;
  }
})</pre></div><p>Replace the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8, SampleComponent9, SampleComponent11, SampleComponent13],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Finally, add <a id="id627" class="indexterm"/>this code to the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;samplethirteen&gt;&lt;/samplethirteen&gt;</pre></div><p>Here, the output is same as the previous example. Most of the things are self-explanatory. The only thing you need to know is that both these code snippets do the same thing:</p><div class="informalexample"><pre class="programlisting">&lt;sampletwelve [(count)]='count'&gt;&lt;/sampletwelve&gt;
&lt;sampletwelve [count]='count' (countChange)= 'count=$event'&gt;&lt;/sampletwelve&gt;</pre></div></div></div>
<div class="section" title="Understanding providers"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec95"/>Understanding providers</h1></div></div></div><p>A <span class="strong"><strong>provider</strong></span> tells <a id="id628" class="indexterm"/>Angular 2 how to create an instance of a service while injecting it. A provider is set using the <code class="literal">providers</code> or <code class="literal">viewProviders</code> properties of a component.</p><p>Let's look at an example of how to create providers. Place this code above the <code class="literal">App</code> component's code:</p><div class="informalexample"><pre class="programlisting">var Service1 = ng.core.Class({
  constructor: function() {
  },
  getValue: function() {
    return "xyz"
  }
});

var Service2 = ng.core.Class({
  constructor: function() {
  },
  getValue: function() {
    return "def"
  }
});

var Service3 = ng.core.Class({
  constructor: function() {
  },
  getValue: function() {
    return "mno"
  }
});

var Service4 = ng.core.Class({
  constructor: [Service2, Service3, function(s2, s3) {
    console.log(s2);
    console.log(s3);
  }],
  getValue: function() {
    return "abc"
  }
});

var ServiceTest1 = ng.core.Component({
  selector: "st1",
  viewProviders: [
    ng.core.provide(Service1, {useClass: Service4}),
    ng.core.provide(Service2, {useValue: "def"}),
    ng.core.provide(Service3, {useFactory: function(){
      return "mno";
    }})
  ],
  template: ""
}).Class({
  constructor: [Service1, function(s1){
    console.log(s1.getValue());
  }]
})</pre></div><p>Replace <a id="id629" class="indexterm"/>the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8,
  SampleComponent9, SampleComponent11, SampleComponent13, ServiceTest1],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Finally, add this to the end of the <code class="literal">app-template.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;st1&gt;&lt;/st1&gt;</pre></div><p>This is the console output of the code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def</strong></span>
<span class="strong"><strong>mno</strong></span>
<span class="strong"><strong>abc</strong></span>
</pre></div><p>This is <a id="id630" class="indexterm"/>how it works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we create four services: <code class="literal">Service1</code>, <code class="literal">Service2</code>, <code class="literal">Service3</code>, and <code class="literal">Service4</code>. They all have a <code class="literal">getValue</code> method, which returns a string. <code class="literal">Service4</code> is dependent on <code class="literal">Service2</code> and <code class="literal">Service3</code>.</li><li class="listitem" style="list-style-type: disc">Then, we create a component called <code class="literal">ServiceTest1</code>. It's dependent on <code class="literal">Service1</code>. In the <code class="literal">viewProviders</code> property, we passed an array of providers. A provider is created using the <code class="literal">ng.core.provide</code> method. It takes two arguments; the first one is the service name, and the second one is the configuration object, which states how to create an instance of this service. The <code class="literal">useClass</code> property tells Angular 2 to create a instance of this service when an instance of the service in the first argument is requested. So here, when an instance of <code class="literal">Service1</code> is required, an instance of <code class="literal">Service4</code> is what is actually created. Similarly, <code class="literal">useValue</code> is used to provide a value, and <code class="literal">useFactory</code> is used to pass control to a function to decide what to return when a new instance is requested. So here, when an instance of <code class="literal">Service2</code> is requested, we get the <code class="literal">def</code> string, and when <code class="literal">Service3</code> is requested, we get the <code class="literal">mno</code> string.</li></ul></div><p>Earlier in this chapter, we were simply assigning <code class="literal">viewProviders</code> to the services themselves. A service also implements the interface of a provider such that it creates the instance of the service itself.</p><p>If there are multiple providers matching a service, then the latest one overrides the previous one.</p></div>
<div class="section" title="The difference between providers and the viewProviders property"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec96"/>The difference between providers and the viewProviders property</h1></div></div></div><p>The <code class="literal">viewProviders</code> property <a id="id631" class="indexterm"/>allows us to make providers available to the component's view only, whereas the <code class="literal">providers</code> property makes a provider available to its content children and view children.</p><p>The <code class="literal">providers</code> property creates a service instance only once and provides the same to whichever <a id="id632" class="indexterm"/>component asks for it. We have already seen how <code class="literal">viewProviders</code> works. Let's look at an example of how <code class="literal">providers</code> works. Place this code above the App component's code:</p><div class="informalexample"><pre class="programlisting">var counter = 1;

var Service5 = ng.core.Class({
  constructor: function(){}
})

var ServiceTest2 = ng.core.Component({
  selector: "st2",
  template: ""
}).Class({
  constructor: [Service5, function(s5){
    console.log(s5);
  }]
})

var ServiceTest3 = ng.core.Component({
  selector: "st3",
  providers: [ng.core.provide(Service5, {useFactory: function(){
    counter++;
    return counter;
  }})],
  directives: [ServiceTest2],
  template: "&lt;st2&gt;&lt;/st2&gt;"
}).Class({
  constructor: [Service5, function(s5){
    console.log(s5);
  }]
})</pre></div><p>Replace the <code class="literal">App</code> component's code with this:</p><div class="informalexample"><pre class="programlisting">var App = ng.core.Component({
  selector: "app",
  directives: [Cards, SampleComponent1, List, ListItem, SampleComponent2, SampleComponent3, SampleComponent4, SampleComponent6, SampleComponent7, SampleComponent8, SampleComponent9, SampleComponent11, SampleComponent13,
  ServiceTest1, ServiceTest3],
  templateUrl: "componentTemplates/app-template.html"
}).Class({
  constructor: function(){}
})</pre></div><p>Finally, at the end of the <code class="literal">app-template.html</code> file, place this code:</p><div class="informalexample"><pre class="programlisting">&lt;st3&gt;&lt;/st3&gt;</pre></div><p>The <a id="id633" class="indexterm"/>console output of this code is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>2</strong></span>
</pre></div><p>Most of the things in this code are self-explanatory. We are using <code class="literal">providers</code> instead of <code class="literal">viewProviders</code>. The <code class="literal">ServiceTest2</code> component is dependent on <code class="literal">Service5</code>, but it doesn't have a provider for <code class="literal">Service5</code>, so Angular 2 uses the provider provided by <code class="literal">ServiceTest3</code>, as <code class="literal">ServiceTest3</code> is its parent. If <code class="literal">ServiceTest3</code> hadn't had a provider for <code class="literal">Service5</code>, Angular 2 would have gone further above and looked for the provider in the <code class="literal">App</code> component.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>The <code class="literal">ng.platform.browser.bootstrap</code> method also takes a second argument, which is a list of providers that is available to all the components. So, instead of passing providers in the <code class="literal">App</code> component, we can pass them through the <code class="literal">ng.platform.browser.bootstrap</code> method.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec97"/>Summary</h1></div></div></div><p>In this chapter, we learned about Angular 2. We saw what components are, how to write templates, how to create services, and so on. We also learned about web components and how Angular 2 takes advantage of them. You should now be comfortable with building Angular 2 applications.</p><p>In the next chapter, we will learn how to build an SPA using Angular 2 by building a complete app.</p></div></body></html>