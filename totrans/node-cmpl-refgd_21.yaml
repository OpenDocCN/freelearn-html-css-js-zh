- en: Building a Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen some examples of building microservices using some tools,
    let's dig deeper and create a microservice from scratch using these tools. To
    accomplish our goal, we'll first use Hydra, and then, we'll create our microservice
    using the Seneca approach.
  prefs: []
  type: TYPE_NORMAL
- en: There are many microservices we could create, but some are more interesting
    than others. More specifically, a microservice that you can use in several applications
    is obviously more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an image processing microservice. We''ll start with a simple
    thumbnail service, and then we''ll evolve to make some simple image transformations.
    We''ll be covering how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use external modules to manipulate images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build our microservice in Hydra and Seneca
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice name is very important, as it gives identity. Let's name it
    *imagini*, the Latin name for image.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hydra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may remember, Hydra has a scaffolding command that helps to bootstrap
    our service quickly. Let''s use it, and prepare our base layout. Run `yo fwsp-hydra`
    and answer the questions. You can leave most of them as default. Depending on
    the versions you''ll use, you should get something similar to the lines shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, let''s do just that. Let''s enter our service folder and install dependencies.
    If you then start it using `npm start`, and open the browser and point it to our
    service, you should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/672ee99e-88f7-492b-8fb9-51911bb98bd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not surprising, because Hydra created a different base route. To enable versioning
    and having different services running on the same HTTP backend, Hydra scaffolding
    created a route under the `/v1/imagini` prefix. Remember, we scaffolded Hydra
    with Express integration, so many of the terms we discussed earlier will be the
    same here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d30631d7-7ea1-42aa-a7d7-d7631ed28220.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we pick our previous code and integrate into Hydra, we need to add our
    Sharp dependency to `package.json`. Look up the `dependencies` property and add
    `sharp`. You should end up with something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, run `npm install` to install Sharp. Then, open the `imagini-v1-routes.js`
    file, which is under the `routes` folder. Basically, what it does is get a handler
    for Hydra and Express, prepare a generic JSON server response (that's what the
    `fwsp-server-response` module is), create an Express router, attach the `/` route,
    and then export it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll keep this structure for now. I refactored the file as I''m a bit picky
    about indentation and quotes. I added our image route parameter and added the
    image upload route. I changed our previous route code to drop the `/uploads` route
    prefix, and use the new `sendOk` and `sendError` functions you see in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we restart our microservice, create the `uploads` folder under the `imagini-service`
    folder, and try to upload an image. Like before, I used `curl` to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, I received a JSON response with our `size` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have our uploaded file in our `uploads` folder. We''re getting there;
    just two more routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our check route is very similar. We just changed the return methods to use
    the methods  defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our image download method is equally similar. For this route, we''re not using
    the JSON responses, and instead just return our image directly. This allows us
    to try it out on our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51b105b0-6312-4f0c-993d-f8f9a716acdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We just migrated our service from Express to Hydra. Not much of a difference,
    but Hydra gives you a more robust layout, about which we''ll find out more later
    on. Let''s take a look at our third framework: Seneca.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Seneca
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that routing on this framework is all about patterns. Let's keep it
    simple for now and use a role property to indicate what we want to do (upload,
    check, or download).
  prefs: []
  type: TYPE_NORMAL
- en: By default, every message should be JSON-encoded, so we'll encode the image
    in `base64` to pass it as a string inside the JSON messages to upload and download.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder for our Seneca service, and then create a child folder called
    `uploads`. Then, install `seneca` and `sharp` on that folder by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a file called `imagini.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What this does is initiate a simple service with a route for uploading. Since
    we're receiving all the image content directly on an object property, I used `fs.writeFile`.
    It's a simpler method and gives me an error whether something incorrect happens,
    which we can pass on to the route response.
  prefs: []
  type: TYPE_NORMAL
- en: I also used `Buffer.from` to convert our image data, which we'll be uploading
    in `base64`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's just start it as we did with the others. I included the same `example.png`
    image and used `curl` to test this out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Seneca promptly replied with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the image size. Notice I''m taking advantage of bash interpolation (variable
    substitution) to directly convert the image file to `base64` and pass it to `curl`,
    which then sends that JSON piece of data to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our check route is very similar. Instead of just replying with an HTTP 404 response
    code, we reply with a stringified JSON object with a boolean property exists,
    which will indicate if the image was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are checking for our image using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you change the image name, it will respond with `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our downloaded route has some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of query parameters, we check directly on `msg`. One noticeable advantage
    is that we have types and not just strings, so we can use Boolean and numbers
    directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of returning the image in binary, so that we could just open in the
    browser, we convert it to `base64` and pass it on the JSON response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need some tools to test this on the command line. Since I use JSON a lot,
    I have `jq` installed. I strongly recommend you install it too and take a look
    at the tutorials. It will make your life easier. Using the `base64` command we
    previously used to encode, we can decode the content and pipe the data to a local
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56304604-8a9b-4348-aa91-aabae4cea60d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then open the folder and see the image is there. Notice I added `greyscale`
    and resized the image just by passing two more JSON parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bab2ee8-a612-4623-81f9-a264129362f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the spirit of Seneca, we should make a plugin for our `imagini` service.
    Let''s split our code into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `imagini` plugin, a service that manipulates images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Seneca microservice, which exposes the `imagini` plugin, and possibly others
    later on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's lot of room for improvement on our code, starting with code we repeated
    constantly. It's important to detect repetitions while our service is still very
    small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most repeated part is the local filename. This is actually something you
    might want to configure when starting the service, so let''s change that to a
    function. Start by changing our `imagini.js` file to be a plugin. Clear all content
    and write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the basis of our plugin. We're loading the modules we need, but not
    Seneca, because our plugin will have access to the service directly. Seneca itself
    will load the plugin by calling our exported function. Following the idea of being
    able to configure the local image folder, we define an optional `settings` parameter,
    which will default to an object with the property `path` equal to `uploads`, which
    is the folder we've been using so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the content of our plugin, inside the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining a function that will convert our image parameter to the
    local path. We can actually reduce the function to be written in one single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create another function that will check whether we have access
    to a local file, and return a Boolean (if it exists or not) and the filename we
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this for our image check, and for our image download. This way,
    we can improve or even cache the results for greater performance, avoiding excessive
    filesystem hits. Our image check route can now be written in a very concise way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we''re referring to the `this` object. Our Seneca service will
    call our plugin function and reference itself to `this`. Again, we can write it
    in a more concise way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our upload route is fairly simple and has no changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The download route uses our previously created helper functions to avoid storing
    our local filename. We also made some tweaks to how `width` and `height` were
    treated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually a lot of variables we''re using where we could just check
    the message parameter instead. We can rewrite our download function and get one-third
    reduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, you should have an `imagini.js` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to create our Seneca service and use our plugin. This is actually
    very straightforward. Create a file called `seneca.js`, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What the code does, line by line, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loads the `seneca` module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a Seneca `service`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loads the `imagini.js` plugin and passes our desired path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starts `service` on port `3000`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it, our service is now a plugin and could be used by any Seneca service!
    You should now start our `service` by running the new file and not `imagini.js`
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, writing a service does not change much between frameworks. Our
    code is very similar, with minor changes. Seneca is stricter about message format
    and content, so we used `base64` to encode our image inside the JSON message.
    Other than that, everything is the same.
  prefs: []
  type: TYPE_NORMAL
- en: You get the advantage of being able to choose everything about the service,
    but you need to write a lot of code. To facilitate the task, Hydra might be a
    good start for an initial set of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: For other tools such as Seneca, some aspects of the microservice (for instance,
    the communication using JSON messages and service composition) are already packed.
    This comes at the price of a stricter service definition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the security of our three service versions,
    and how we can store state.
  prefs: []
  type: TYPE_NORMAL
