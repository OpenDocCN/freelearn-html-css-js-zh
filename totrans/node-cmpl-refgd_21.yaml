- en: Building a Microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务
- en: Now that we've seen some examples of building microservices using some tools,
    let's dig deeper and create a microservice from scratch using these tools. To
    accomplish our goal, we'll first use Hydra, and then, we'll create our microservice
    using the Seneca approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用一些工具构建微服务的示例，让我们更深入地挖掘，并使用这些工具从头开始创建一个微服务。为了实现我们的目标，我们首先将使用 Hydra，然后，我们将使用
    Seneca 方法创建我们的微服务。
- en: There are many microservices we could create, but some are more interesting
    than others. More specifically, a microservice that you can use in several applications
    is obviously more useful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建许多微服务，但其中一些比其他更有趣。更具体地说，一个可以在多个应用程序中使用的微服务显然更有用。
- en: 'Let''s create an image processing microservice. We''ll start with a simple
    thumbnail service, and then we''ll evolve to make some simple image transformations.
    We''ll be covering how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个图像处理微服务。我们将从一个简单的缩略图服务开始，然后我们将逐步发展到进行一些简单的图像转换。我们将涵盖如何：
- en: Use external modules to manipulate images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部模块来操作图像
- en: Build our microservice in Hydra and Seneca
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Hydra 和 Seneca 中构建我们的微服务
- en: The microservice name is very important, as it gives identity. Let's name it
    *imagini*, the Latin name for image.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务名称非常重要，因为它提供了身份。让我们将其命名为 *imagini*，这是图像的拉丁名称。
- en: Using Hydra
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hydra
- en: 'As you may remember, Hydra has a scaffolding command that helps to bootstrap
    our service quickly. Let''s use it, and prepare our base layout. Run `yo fwsp-hydra`
    and answer the questions. You can leave most of them as default. Depending on
    the versions you''ll use, you should get something similar to the lines shown
    here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，Hydra 有一个框架命令，可以帮助我们快速启动服务。让我们使用它，并准备我们的基本布局。运行 `yo fwsp-hydra` 并回答问题。您可以将大多数问题保留为默认值。根据您使用的版本，您应该得到类似以下行所示的内容：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Well, let''s do just that. Let''s enter our service folder and install dependencies.
    If you then start it using `npm start`, and open the browser and point it to our
    service, you should get something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们就这样做。让我们进入我们的服务文件夹并安装依赖项。如果您然后使用 `npm start` 启动它，并在浏览器中指向我们的服务，您应该会得到类似以下内容：
- en: '![](img/672ee99e-88f7-492b-8fb9-51911bb98bd6.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/672ee99e-88f7-492b-8fb9-51911bb98bd6.png)'
- en: 'Not surprising, because Hydra created a different base route. To enable versioning
    and having different services running on the same HTTP backend, Hydra scaffolding
    created a route under the `/v1/imagini` prefix. Remember, we scaffolded Hydra
    with Express integration, so many of the terms we discussed earlier will be the
    same here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并不令人惊讶，因为 Hydra 创建了一个不同的基本路由。为了启用版本控制和让不同的服务在同一个 HTTP 后端上运行，Hydra 框架在 `/v1/imagini`
    前缀下创建了一个路由。记住，我们使用 Express 集成构建了 Hydra，所以许多我们之前讨论过的术语在这里也将是相同的：
- en: '![](img/d30631d7-7ea1-42aa-a7d7-d7631ed28220.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d30631d7-7ea1-42aa-a7d7-d7631ed28220.png)'
- en: 'Before we pick our previous code and integrate into Hydra, we need to add our
    Sharp dependency to `package.json`. Look up the `dependencies` property and add
    `sharp`. You should end up with something along these lines:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将之前的代码选择并集成到 Hydra 之前，我们需要将我们的 Sharp 依赖项添加到 `package.json` 中。查找 `dependencies`
    属性并添加 `sharp`。你应该得到类似以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, run `npm install` to install Sharp. Then, open the `imagini-v1-routes.js`
    file, which is under the `routes` folder. Basically, what it does is get a handler
    for Hydra and Express, prepare a generic JSON server response (that's what the
    `fwsp-server-response` module is), create an Express router, attach the `/` route,
    and then export it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `npm install` 来安装 Sharp。然后，打开位于 `routes` 文件夹下的 `imagini-v1-routes.js`
    文件。基本上，它的作用是获取 Hydra 和 Express 的处理器，准备一个通用的 JSON 服务器响应（这就是 `fwsp-server-response`
    模块的作用），创建一个 Express 路由器，附加 `/` 路由，然后导出它。
- en: 'We''ll keep this structure for now. I refactored the file as I''m a bit picky
    about indentation and quotes. I added our image route parameter and added the
    image upload route. I changed our previous route code to drop the `/uploads` route
    prefix, and use the new `sendOk` and `sendError` functions you see in the preceding
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在保持这个结构。由于我对缩进和引号有点挑剔，所以我重构了文件。我添加了我们的图像路由参数并添加了图像上传路由。我将我们之前的路由代码更改为删除 `/uploads`
    路由前缀，并使用前面代码中看到的 `sendOk` 和 `sendError` 函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we restart our microservice, create the `uploads` folder under the `imagini-service`
    folder, and try to upload an image. Like before, I used `curl` to test it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重新启动我们的微服务，在 `imagini-service` 文件夹下创建 `uploads` 文件夹，并尝试上传一个图像。像之前一样，我使用了
    `curl` 来测试它：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As expected, I received a JSON response with our `size` property:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我收到了一个包含我们的 `size` 属性的 JSON 响应：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can have our uploaded file in our `uploads` folder. We''re getting there;
    just two more routes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上传的文件放在我们的`uploads`文件夹中。我们正在接近目标；只需再添加两个路由：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our check route is very similar. We just changed the return methods to use
    the methods  defined previously:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的检查路由非常相似。我们只是将返回方法更改为使用之前定义的方法：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our image download method is equally similar. For this route, we''re not using
    the JSON responses, and instead just return our image directly. This allows us
    to try it out on our browser:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下载数据方法同样相似。对于这个路由，我们不使用JSON响应，而是直接返回我们的图像。这允许我们在浏览器中尝试它：
- en: '![](img/51b105b0-6312-4f0c-993d-f8f9a716acdb.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51b105b0-6312-4f0c-993d-f8f9a716acdb.png)'
- en: 'We just migrated our service from Express to Hydra. Not much of a difference,
    but Hydra gives you a more robust layout, about which we''ll find out more later
    on. Let''s take a look at our third framework: Seneca.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将我们的服务从Express迁移到Hydra。变化不大，但Hydra提供了一个更健壮的布局，我们稍后会了解更多。让我们看看我们的第三个框架：Seneca。
- en: Using Seneca
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seneca
- en: Remember that routing on this framework is all about patterns. Let's keep it
    simple for now and use a role property to indicate what we want to do (upload,
    check, or download).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这个框架上路由一切都是关于模式的。现在让我们保持简单，并使用一个角色属性来指示我们想要做什么（上传、检查或下载）。
- en: By default, every message should be JSON-encoded, so we'll encode the image
    in `base64` to pass it as a string inside the JSON messages to upload and download.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每条消息都应该进行JSON编码，因此我们将图像编码为`base64`，然后在JSON消息中将其作为字符串传递以上传和下载。
- en: 'Create a folder for our Seneca service, and then create a child folder called
    `uploads`. Then, install `seneca` and `sharp` on that folder by running the following
    command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的Seneca服务创建一个文件夹，然后在该文件夹中创建一个名为`uploads`的子文件夹。然后，通过运行以下命令在该文件夹中安装`seneca`和`sharp`：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, create a file called `imagini.js` with the following content:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`imagini.js`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What this does is initiate a simple service with a route for uploading. Since
    we're receiving all the image content directly on an object property, I used `fs.writeFile`.
    It's a simpler method and gives me an error whether something incorrect happens,
    which we can pass on to the route response.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是启动一个简单的服务，有一个上传的路由。由于我们直接在对象属性上接收所有图像内容，我使用了`fs.writeFile`。这是一个更简单的方法，如果发生错误，它会给我一个错误，我们可以将其传递给路由响应。
- en: I also used `Buffer.from` to convert our image data, which we'll be uploading
    in `base64`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还使用了`Buffer.from`来转换我们的图像数据，这些数据将以`base64`格式上传。
- en: So, let's just start it as we did with the others. I included the same `example.png`
    image and used `curl` to test this out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们就像对待其他服务一样启动它。我包含了相同的`example.png`图像，并使用`curl`进行测试。
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Seneca promptly replied with the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca迅速回复如下：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the image size. Notice I''m taking advantage of bash interpolation (variable
    substitution) to directly convert the image file to `base64` and pass it to `curl`,
    which then sends that JSON piece of data to our service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指图像的大小。请注意，我正在利用bash插值（变量替换）直接将图像文件转换为`base64`，然后传递给`curl`，然后`curl`将这个JSON数据块发送到我们的服务：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our check route is very similar. Instead of just replying with an HTTP 404 response
    code, we reply with a stringified JSON object with a boolean property exists,
    which will indicate if the image was found.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的检查路由非常相似。我们不是只回复HTTP 404响应代码，而是回复一个包含布尔属性`exists`的字符串化JSON对象，这将指示图像是否被找到。
- en: 'Here, we are checking for our image using `curl`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在使用`curl`检查我们的图像：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will respond with the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将响应如下：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you change the image name, it will respond with `false`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改图像名称，它将响应`false`：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our downloaded route has some changes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下载数据路由有一些变化：
- en: Instead of query parameters, we check directly on `msg`. One noticeable advantage
    is that we have types and not just strings, so we can use Boolean and numbers
    directly.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是查询参数，我们直接在`msg`上进行检查。一个明显的优势是我们有类型而不是只有字符串，因此我们可以直接使用布尔值和数字。
- en: Instead of returning the image in binary, so that we could just open in the
    browser, we convert it to `base64` and pass it on the JSON response.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是以二进制形式返回图像，以便我们可以在浏览器中打开，我们将其转换为`base64`，并在JSON响应中传递。
- en: 'We need some tools to test this on the command line. Since I use JSON a lot,
    I have `jq` installed. I strongly recommend you install it too and take a look
    at the tutorials. It will make your life easier. Using the `base64` command we
    previously used to encode, we can decode the content and pipe the data to a local
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些工具在命令行上测试这个功能。由于我经常使用JSON，我已经安装了`jq`。我强烈推荐你也安装它并查看教程，这将使你的生活更轻松。使用我们之前用来编码的`base64`命令，我们可以解码内容并将数据管道传输到本地文件：
- en: '![](img/56304604-8a9b-4348-aa91-aabae4cea60d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56304604-8a9b-4348-aa91-aabae4cea60d.png)'
- en: 'We can then open the folder and see the image is there. Notice I added `greyscale`
    and resized the image just by passing two more JSON parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开文件夹并看到图像已经存在。注意，我添加了`greyscale`和通过传递两个额外的JSON参数来调整图像大小：
- en: '![](img/4bab2ee8-a612-4623-81f9-a264129362f7.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bab2ee8-a612-4623-81f9-a264129362f7.png)'
- en: Plugins
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: 'In the spirit of Seneca, we should make a plugin for our `imagini` service.
    Let''s split our code into two parts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在塞涅卡的精神下，我们应该为我们的`imagini`服务创建一个插件。让我们将我们的代码分成两部分：
- en: The `imagini` plugin, a service that manipulates images
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagini`插件，一个处理图像的服务'
- en: A Seneca microservice, which exposes the `imagini` plugin, and possibly others
    later on
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Seneca微服务，它公开了`imagini`插件，以及可能以后的其他插件
- en: There's lot of room for improvement on our code, starting with code we repeated
    constantly. It's important to detect repetitions while our service is still very
    small.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码有很多改进的空间，从我们不断重复的代码开始。当我们的服务仍然非常小的时候，检测重复是很重要的。
- en: 'The most repeated part is the local filename. This is actually something you
    might want to configure when starting the service, so let''s change that to a
    function. Start by changing our `imagini.js` file to be a plugin. Clear all content
    and write this code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最常重复的部分是本地文件名。这实际上是在启动服务时你可能想要配置的东西，所以让我们将其改为一个函数。首先，将我们的`imagini.js`文件改为插件。清空所有内容并写入以下代码：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the basis of our plugin. We're loading the modules we need, but not
    Seneca, because our plugin will have access to the service directly. Seneca itself
    will load the plugin by calling our exported function. Following the idea of being
    able to configure the local image folder, we define an optional `settings` parameter,
    which will default to an object with the property `path` equal to `uploads`, which
    is the folder we've been using so far.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的插件的基础。我们正在加载所需的模块，但不加载Seneca，因为我们的插件将直接访问服务。Seneca本身将通过调用我们的导出函数来加载插件。遵循能够配置本地图像文件夹的想法，我们定义了一个可选的`settings`参数，它默认为一个具有`path`属性的对象，其值为`uploads`，这是我们迄今为止一直在使用的文件夹。
- en: 'Now, let''s add the content of our plugin, inside the preceding function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在先前的函数中添加插件的内容：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by defining a function that will convert our image parameter to the
    local path. We can actually reduce the function to be written in one single line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，将我们的图像参数转换为本地路径。实际上，我们可以将这个函数简化为单行代码：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, let''s create another function that will check whether we have access
    to a local file, and return a Boolean (if it exists or not) and the filename we
    provided:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建另一个函数来检查我们是否有权访问本地文件，并返回一个布尔值（如果存在或不存在）以及我们提供的文件名：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use this for our image check, and for our image download. This way,
    we can improve or even cache the results for greater performance, avoiding excessive
    filesystem hits. Our image check route can now be written in a very concise way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来检查图像，以及下载图像。这样，我们可以提高性能或甚至缓存结果，避免过多的文件系统访问。我们的图像检查路由现在可以非常简洁地编写：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that we''re referring to the `this` object. Our Seneca service will
    call our plugin function and reference itself to `this`. Again, we can write it
    in a more concise way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在引用`this`对象。我们的Seneca服务将调用我们的插件函数，并将自身引用到`this`。我们还可以以更简洁的方式编写它：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our upload route is fairly simple and has no changes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的上传路由相当简单，没有变化：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The download route uses our previously created helper functions to avoid storing
    our local filename. We also made some tweaks to how `width` and `height` were
    treated:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下载路由使用我们之前创建的辅助函数来避免存储我们的本地文件名。我们还对`width`和`height`的处理方式做了一些调整：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are actually a lot of variables we''re using where we could just check
    the message parameter instead. We can rewrite our download function and get one-third
    reduction:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们使用了很多变量，我们只需检查消息参数即可。我们可以重写我们的下载函数并减少三分之一的代码：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the end, you should have an `imagini.js` file with the following content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该有一个包含以下内容的`imagini.js`文件：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We just need to create our Seneca service and use our plugin. This is actually
    very straightforward. Create a file called `seneca.js`, and add the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要创建我们的 Seneca 服务并使用我们的插件。这实际上非常简单。创建一个名为 `seneca.js` 的文件，并添加以下内容：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What the code does, line by line, is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码逐行执行的功能如下：
- en: Loads the `seneca` module
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `seneca` 模块
- en: Creates a Seneca `service`
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Seneca `service`
- en: Loads the `imagini.js` plugin and passes our desired path
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `imagini.js` 插件并传递我们想要的路径
- en: Starts `service` on port `3000`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 `3000` 上启动 `service`
- en: 'That''s it, our service is now a plugin and could be used by any Seneca service!
    You should now start our `service` by running the new file and not `imagini.js`
    directly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的服务现在已经成为了一个插件，可以被任何 Seneca 服务使用！你现在应该通过运行新文件而不是直接运行 `imagini.js` 来启动
    `service`：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, writing a service does not change much between frameworks. Our
    code is very similar, with minor changes. Seneca is stricter about message format
    and content, so we used `base64` to encode our image inside the JSON message.
    Other than that, everything is the same.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编写服务在不同的框架之间变化不大。我们的代码非常相似，只有一些小的变化。Seneca 对消息格式和内容的要求更严格，所以我们使用 `base64`
    对 JSON 消息中的图像进行编码。除此之外，一切照旧。
- en: You get the advantage of being able to choose everything about the service,
    but you need to write a lot of code. To facilitate the task, Hydra might be a
    good start for an initial set of plugins.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由选择关于服务的一切，但你需要编写大量的代码。为了方便这项任务，Hydra 可能是一个好的起点，用于一组初始插件。
- en: For other tools such as Seneca, some aspects of the microservice (for instance,
    the communication using JSON messages and service composition) are already packed.
    This comes at the price of a stricter service definition.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他工具，如 Seneca，微服务的某些方面（例如，使用 JSON 消息的通信和服务组合）已经打包。这需要以更严格的服务定义作为代价。
- en: In the next chapter, we will discuss the security of our three service versions,
    and how we can store state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论我们三个服务版本的安全性，以及我们如何存储状态。
