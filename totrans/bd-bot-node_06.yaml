- en: Chapter 6. BotKit – Document Manager Agent for Slack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. BotKit – Slack的文档管理代理
- en: In [Chapter 4](part0032.xhtml#aid-UGI01 "Chapter 4.  A Slack Quote Bot") , *A
    Slack Quote Bot*, we saw how Slack is a great collaboration platform. While collaborating,
    teams can get the inspirational quotes from *They Said So* services right in their
    Slack channels. In this chapter, we will see a use case for Slack that's a little
    more complex than just getting quotes. Here, we will be building a Slack bot called
    DocMan bot with the help of **Howdy BotKit**. DocMan bot should be able to search
    document(s) and also provide a link to download them, based on team members' requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0032.xhtml#aid-UGI01 "第4章. Slack引言机器人")，*Slack引言机器人*，我们看到了Slack是如何成为一个优秀的协作平台。在协作过程中，团队可以直接在Slack频道中获取来自*They
    Said So*服务的励志引言。在本章中，我们将看到一个比仅仅获取引言更为复杂的Slack应用案例。在这里，我们将借助**Howdy BotKit**构建一个名为DocMan机器人的Slack机器人。DocMan机器人应该能够根据团队成员的请求搜索文档，并提供下载链接。
- en: Our Slack bot, DocMan, will be built using MongoDB for data storage and Amazon
    S3 for research document or file storage. Details about MongoDB and Amazon S3
    storage will be detailed in the following sections of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Slack机器人，DocMan，将使用MongoDB进行数据存储，并使用Amazon S3进行研究文档或文件存储。关于MongoDB和Amazon
    S3存储的详细信息将在本章后续部分详细说明。
- en: Awesome!! Let's Slack now.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们开始使用Slack吧。
- en: Setting up a Slack for your team
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的团队设置Slack
- en: In this section, we will start setting up Slack for a team.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始为团队设置Slack。
- en: 'Open the browser window and enter the URL-- [https://slack.com](https://slack.com)
    . This will launch the Slack home page as shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器窗口并输入URL-- [https://slack.com](https://slack.com) 。这将启动如以下截图所示的Slack主页：
- en: '![Setting up a Slack for your team](img/image00278.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00278.jpeg)'
- en: For users who are accessing Slack for the first time, you will first have to
    create your Slack account and then you can create your team. Users who are already
    on Slack can click on the **Sign in** link. Let's look at how to create our own
    account.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于首次访问Slack的用户，您首先需要创建您的Slack账户，然后才能创建您的团队。已经在Slack上的用户可以点击**登录**链接。让我们看看如何创建我们自己的账户。
- en: Provide your e-mail address at **Email address**. Click on the **Create New
    Team** link to launch the next step, as shown in the following screenshot. Slack
    will send a confirmation code to your e-mail id. Enter the received code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在**电子邮件地址**处输入您的电子邮件地址。点击**创建新团队**链接，启动下一步，如以下截图所示。Slack将向您的电子邮件地址发送确认码。输入收到的代码。
- en: '![Setting up a Slack for your team](img/image00279.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00279.jpeg)'
- en: 'Enter your confirmation code. The code will be verified by Slack and then the
    following screen will be launched:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的确认码。Slack将验证该代码，然后启动以下屏幕：
- en: '![Setting up a Slack for your team](img/image00280.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00280.jpeg)'
- en: 'Provide your name and username in the fields **Your name** and **Username,**
    and click on the **Continue to Password** button to launch the following screen:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在**您的姓名**和**用户名**字段中提供您的姓名和用户名，然后点击**继续到密码**按钮，启动以下屏幕：
- en: '![Setting up a Slack for your team](img/image00281.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00281.jpeg)'
- en: 'Provide your password at **Password** and click on the **Continue to Team Info**
    button to launch the following screen:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在**密码**处输入您的密码，然后点击**继续到团队信息**按钮，启动以下屏幕：
- en: '![Setting up a Slack for your team](img/image00282.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00282.jpeg)'
- en: 'Choose the options that match your team''s purposes and intentions in the **What
    will your team use Slack for?** and **How big is your shared interest group?**
    dropdowns. Click on the **Continue to Group Name** button to launch the following
    screen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在**您的团队将如何使用Slack？**和**您的共享兴趣小组有多大？**的下拉菜单中选择符合您团队目的和意图的选项。点击**继续到团队名称**按钮，启动以下屏幕：
- en: '![Setting up a Slack for your team](img/image00283.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00283.jpeg)'
- en: 'I wanted to name my team Bot Researchers, so I entered the name as **Bot Researchers**
    in the **Group Name** entry field and clicked on the **Continue to Team Domain**
    button to launch the following screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将我的团队命名为Bot Researchers，因此我在**组名称**输入字段中输入了**Bot Researchers**，然后点击**继续到团队域名**按钮，启动以下屏幕：
- en: '![Setting up a Slack for your team](img/image00284.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00284.jpeg)'
- en: Slack verifies the domain name availability for your team. If it is available,
    then it shows a message saying so, as shown in the preceding screenshot. Now click
    on the **Create Team** button.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Slack会验证您团队域名名的可用性。如果可用，则会显示一条消息说明这一点，如前一张截图所示。现在点击**创建团队**按钮。
- en: 'The next screen is **Send Invitations**, which I will be skipping for now,
    going straight to the welcome screen for the Bot Researchers Slack team. The screen
    will appear as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕是**发送邀请**，我现在将跳过这一步，直接进入Bot Researchers Slack团队的欢迎屏幕。屏幕将如以下截图所示：
- en: '![Setting up a Slack for your team](img/image00285.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![为您的团队设置Slack](img/image00285.jpeg)'
- en: In the preceding screenshot, you might have noticed the name **slackbot**. Slack
    uses a bot named slackbot to greet us and help us in case of any questions. This
    is a wonderful use of bots to educate users in the chatting window itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张截图中，您可能已经注意到名称**slackbot**。Slack使用名为slackbot的机器人来问候我们，并在有任何问题时帮助我们。这是在聊天窗口本身教育用户的一个很好的机器人应用。
- en: We have now signed up with Slack and created our own team. Now we will develop
    our bot for this team.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已在Slack上注册并创建了自己的团队。现在我们将为这个团队开发我们的机器人。
- en: Setting up a Slack bot
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Slack机器人
- en: As a botresearcher group member, I would like my bot to provide information
    about all bot-related documents. This bot is called **DocMan**. Now, to create
    a new bot in Slack, just visit the website found at [https://botresearchers.slack.com/services/new/bot](https://botresearchers.slack.com/services/new/bot)
    .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为botresearcher群组成员，我希望我的机器人提供所有与机器人相关的文档信息。这个机器人被称为**DocMan**。现在，要创建Slack中的新机器人，只需访问位于[https://botresearchers.slack.com/services/new/bot](https://botresearchers.slack.com/services/new/bot)
    的网站。
- en: 'Make sure you are already logged in to your Slack group. Here I have logged
    in to my group, [https://botresearchers.slack.com](https://botresearchers.slack.com)
    . Since you are already logged in, this will navigate to the **Bots** | **New
    Configuration** screen, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经登录到您的Slack群组。这里我已经登录到我的群组，[https://botresearchers.slack.com](https://botresearchers.slack.com)
    。由于您已经登录，这将导航到**机器人** | **新配置**屏幕，如以下截图所示：
- en: '![Setting up a Slack bot](img/image00286.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![设置Slack机器人](img/image00286.jpeg)'
- en: 'Let''s enter the **Username** as `@docman` and then click on the **Add bot
    integration** button. Slack will ask for additional configuration information
    for this bot, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入**用户名**为`@docman`，然后点击**添加机器人集成**按钮。Slack将要求为此机器人提供额外的配置信息，如以下截图所示：
- en: '![Setting up a Slack bot](img/image00287.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![设置Slack机器人](img/image00287.jpeg)'
- en: Look at the **API Token** section, under **Integration Settings**. Our bot will
    use this token to communicate with APIs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下**集成设置**下的**API令牌**部分。我们的机器人将使用此令牌与API通信。
- en: The bot user token can connect to real-time streaming APIs and can perform activities,
    such as posting messages, so the distribution of this token should be avoided
    in public code repositories.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人用户令牌可以连接到实时流式API并执行活动，例如发布消息，因此应避免在公共代码仓库中分发此令牌。
- en: 'Refer to the following screenshot. You can enter the parameters of this bot''s
    behavior within Slack channels in the **What this bot does** entry field:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图。您可以在**此机器人做什么**输入字段中输入此机器人的行为参数：
- en: '![Setting up a Slack bot](img/image00288.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设置Slack机器人](img/image00288.jpeg)'
- en: Here, I have entered **Provides Information and Documents about Bot Research**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我已输入**提供有关机器人研究的信息和文档**。
- en: Now click the **Save Integration** button to save the configuration information
    of our bot. The information will be saved and the user will be notified at the
    top of the screen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击**保存集成**按钮以保存我们的机器人的配置信息。信息将被保存，用户将在屏幕顶部收到通知。
- en: 'Now let''s go back to our group by using the URL [https://botresearchers.slack.com/messages](https://botresearchers.slack.com/messages)
    . You will see **docman** under the **DIRECT MESSAGES** section. Click on the
    name **docman** to see a chat message screen, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过URL [https://botresearchers.slack.com/messages](https://botresearchers.slack.com/messages)
    返回我们的群组。您将在**直接消息**部分看到**docman**。点击名称**docman**以查看聊天消息屏幕，如以下截图所示：
- en: '![Setting up a Slack bot](img/image00289.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![设置Slack机器人](img/image00289.jpeg)'
- en: Now, our bot is showing its username as **@docman** and the description as **Provides
    Information and Documents about Bot Research**. We provided this information during
    its configuration. At the moment, this bot will not respond to any of our messages
    as it is not programmed yet. Also, the status of the bot is set to **away**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的机器人正在显示其用户名为 **@docman**，描述为 **提供有关机器人研究的信息和文档**。我们是在配置时提供这些信息的。目前，这个机器人不会对我们的任何消息做出响应，因为它还没有被编程。此外，机器人的状态设置为
    **离线**。
- en: To summarize so far, we have created our own Slack group and created our own
    Slack bot. We also looked at how to configure this bot. In the next section, we
    will see how we can wire up some intelligence to our bare bones bot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结到目前为止，我们已经创建了我们的 Slack 群组，并创建了我们的 Slack 机器人。我们还了解了如何配置这个机器人。在下一节中，我们将看到如何将一些智能连接到我们的裸机机器人。
- en: Botkit and Slack
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Botkit 和 Slack
- en: '**Botkit** is a free to use, open source toolkit from **Howdy** ([https://howdy.ai/botkit](https://howdy.ai/botkit))
    for integrating bots with messaging platforms such as Slack. Botkit comes with
    lots of features that help developers build both types of bot integrations, for
    individual teams as well as for other teams using *Slack Button*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Botkit** 是一个来自 **Howdy** ([https://howdy.ai/botkit](https://howdy.ai/botkit))
    的免费开源工具包，用于将机器人与 Slack 等消息平台集成。Botkit 提供了许多功能，帮助开发者构建两种类型的机器人集成，既适用于个人团队，也适用于使用
    *Slack Button* 的其他团队。'
- en: Creating our first Slack bot using Botkit and Node.js
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人
- en: Let's start wiring up our bot in Node.js by first installing Botkit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Botkit 开始，在 Node.js 中连接我们的机器人。
- en: 'Let''s start by creating a folder in our local drive in order to store our
    Bot from the Command Prompt:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地驱动器中创建一个文件夹，以便从命令提示符存储我们的机器人：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assuming we have Node.js and NPM installed, let''s create and initialize our
    `package.json`, which will store our Bot''s dependencies and definitions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经安装了 Node.js 和 NPM，让我们创建并初始化我们的 `package.json`，它将存储我们的机器人依赖项和定义：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you go through the `npm init` options (which are very easy to follow),
    you''ll see something similar to the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过了 `npm init` 选项（这些选项非常容易遵循），你将看到以下截图类似的内容：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00290.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00290.jpeg)'
- en: 'You''ll see the result in your project folder; this is your `package.json`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你的项目文件夹中看到结果；这是你的 `package.json` 文件：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00291.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00291.jpeg)'
- en: Let's install the `botkit` package from NPM. This can be located at [https://www.npmjs.com/package/botkit](https://www.npmjs.com/package/botkit)
    .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 NPM 安装 `botkit` 包。这个包可以在 [https://www.npmjs.com/package/botkit](https://www.npmjs.com/package/botkit)
    找到。
- en: 'In order to install it, run this `npm` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装它，运行以下 `npm` 命令：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should then see something similar to this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00292.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00292.jpeg)'
- en: 'Having done this, the next thing to do is to update your `package.json` in
    order to include the `"engines"` attribute. Open the `package.json` file with
    a text editor and update it as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，下一步是更新你的 `package.json` 以包括 `"engines"` 属性。使用文本编辑器打开 `package.json` 文件，并按以下方式更新它：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your `package.json` should then look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的 `package.json` 应该看起来像这样：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00293.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00293.jpeg)'
- en: Let's create our `app.js` file, which will be the entry point for our bot, as
    mentioned while setting up our node package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `app.js` 文件，这是我们机器人的入口点，正如在设置节点包时提到的。
- en: 'Our `app.js` should like the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `app.js` 应该像以下代码片段所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember, our bot DocMan is still not active, and its status is away, which
    we have seen in our Slack group.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的机器人 DocMan 仍然处于非活动状态，其状态为离线，这是我们已经在 Slack 群组中看到的。
- en: 'Now let''s run our Node.js program to see how it looks in Slack, and start
    our basic conversations with our bot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的 Node.js 程序，看看它在 Slack 中的样子，并开始与我们的机器人进行基本对话：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00294.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00294.jpeg)'
- en: Now, if you look at the console, you will see, with the help of the token, that
    our bot has started communicating with Real-Time Messaging APIs through a websocket.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看控制台，你将看到，借助令牌，我们的机器人已经开始通过 WebSocket 与实时消息 API 进行通信。
- en: 'Let''s look at our Slack group now. Our Slack group will now show our bot **@docman**
    under **DIRECT MESSAGES** with an active status, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的 Slack 群组。现在，我们的 Slack 群组将显示我们的机器人 **@docman** 在 **直接消息** 下，状态为活跃，如下面的截图所示：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00295.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00295.jpeg)'
- en: 'Now our bot is ready for conversation. Let''s say `Hello` to our bot and see
    what it says:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的机器人已经准备好进行对话了。让我们对机器人说“Hello”并看看它会说什么：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00296.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00296.jpeg)'
- en: Our bot has responded to our message with **Hello there!** So the wiring up
    of our bot within Node.js and Botkit with Real-Time Messaging APIs has worked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人对我们的消息做出了“Hello there!”的回应。所以，我们的机器人在 Node.js 和 Botkit 中使用实时消息 API 的连接是成功的。
- en: 'Now I want my bot to be part of the #general channel, which is the default
    for our group. Enter the name `@docman` in the messaging box and hit enter. Immediately
    **slackbot** will guide us to invite `@docman` in the #general channel, as shown
    in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我希望我的机器人成为 #general 通道的一部分，这是我们组的默认通道。在消息框中输入名称 `@docman` 并按回车键。立即 **slackbot**
    将引导我们邀请 `@docman` 加入 #general 通道，如下面的截图所示：'
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00297.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00297.jpeg)'
- en: 'Click on the **invite them to join** link to join our bot in this channel.
    On the popup, just click on the **Yes, invite** them button. Refer to the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **邀请他们加入** 链接以将我们的机器人加入此通道。在弹出的窗口中，只需点击 **是的，邀请** 他们按钮。参考以下截图：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00298.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00298.jpeg)'
- en: 'After inviting them, the Slack channel **#general** will show a notification
    that our bot has joined the group, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在邀请他们之后，Slack 通道 **#general** 将显示一个通知，说明我们的机器人已加入该组，如下面的截图所示：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00299.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00299.jpeg)'
- en: 'This way you can invite our bot to any of the channels, and you can also start
    conversations with our bot in that channel just by mentioning the name of our
    bot. I mentioned the name of our bot with a message reading **@docman Hello**
    in the **#general** channel. Our bot''s reply can be seen as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以将我们的机器人邀请到任何通道中，你还可以通过提及机器人的名称在该通道中与机器人开始对话。我在 **#general** 通道中通过一条信息读取
    **@docman Hello** 的消息提及了机器人的名称。我们的机器人的回复如下所示：
- en: '![Creating our first Slack bot using Botkit and Node.js](img/image00300.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Botkit 和 Node.js 创建我们的第一个 Slack 机器人](img/image00300.jpeg)'
- en: Enhancing our DocMan bot
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强我们的 DocMan 机器人
- en: Having built a very basic Slack bot, let's enhance our **DocMan** bot. Say that,
    following a team member's request, DocMan bot should be able to search a particular
    document and also be able to provide a link to download.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个非常基础的 Slack 机器人之后，让我们来增强我们的 **DocMan** 机器人。假设，根据团队成员的请求，DocMan 机器人应该能够搜索特定的文档，并且能够提供下载链接。
- en: Let me explain how this will work. The Bot Researchers Slack team members will
    be communicating within their respective Slack channels. Now let's assume that
    one of them needs information about a research planning checklist document. The
    team member will enter some keywords like `Research Planning` or `Checklist` or
    `Template` by mentioning our bot's name. DocMan will do a keyword search within
    the MongoDB database and will present the searched documents. MongoDB will only
    have links to these documents and other metadata or attributes for the documents
    that will be searched. Actual documents will be stored in Amazon S3 storage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释一下这将如何工作。Bot Researchers Slack 团队的成员将在各自的 Slack 通道内进行沟通。现在让我们假设其中一位成员需要关于研究计划清单文档的信息。该团队成员将通过提及我们的机器人名称输入一些关键词，如
    `Research Planning` 或 `Checklist` 或 `Template`。DocMan 将在 MongoDB 数据库中进行关键词搜索，并展示搜索到的文档。MongoDB
    将只包含这些文档的链接以及其他将被搜索的文档的元数据或属性。实际的文档将存储在 Amazon S3 存储中。
- en: Before going into the details, let me explain a little about MongoDB and Amazon
    S3 storage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我简单介绍一下 MongoDB 和 Amazon S3 存储的相关信息。
- en: What is MongoDB?
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 MongoDB？
- en: Day by day, the use of NoSQLs is skyrocketing. MongoDB is one such NoSQL. There
    are various NoSQL database types, such as `Document Store`, `Key-Value Store`,
    `Column Store`, and `Graph Store`, to name but a few,.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 日复一日，NoSQL 的使用正在飞速增长。MongoDB 就是其中之一。NoSQL 数据库类型有很多，例如 `文档存储`、`键值存储`、`列存储` 和
    `图存储`，仅举几例。
- en: MongoDB is of the Document Store type of NoSQLs, where data is stored in JSON
    documents. In short, MongoDB is an open source, highly scalable, high-performance
    NoSQL database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是 NoSQL 中的文档存储类型，其中数据以 JSON 文档的形式存储。简而言之，MongoDB 是一个开源的、高度可扩展的、高性能的
    NoSQL 数据库。
- en: The reason I am using MongoDB is because I wanted to show you how we can use
    a NoSQL database like MongoDB to search and store the document links using their
    metadata or attribute values. However, don't get confused between the documents
    or files that we are searching and the material that MongoDB is storing. What
    MongoDB is storing is just like a single record which is in JSON format. Just
    like our relational databases where data is stored in tables and records, MongoDB
    stores data in collections and JSON documents. Actual documents or files will
    be stored on Amazon S3, and only the link will be stored in MongoDB.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 MongoDB 的原因是因为我想向你展示我们如何使用 MongoDB 这样的 NoSQL 数据库来通过元数据或属性值搜索和存储文档链接。然而，不要混淆我们正在搜索的文档或文件与
    MongoDB 存储的材料。MongoDB 存储的就像一个单独的记录，格式为 JSON。就像我们的关系型数据库中数据存储在表和记录中一样，MongoDB 在集合和
    JSON 文档中存储数据。实际的文档或文件将存储在 Amazon S3 上，而只有链接将存储在 MongoDB 中。
- en: For our DocMan bot's enhancements, make sure you have installed MongoDB on your
    machine based on your machine's version (32 bit or 64 bit). Detailed installation
    steps can be obtained from [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)
    .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的 DocMan 机器人的增强，确保你根据你的机器版本（32 位或 64 位）在你的机器上安装了 MongoDB。详细的安装步骤可以从 [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)
    获取。
- en: MongoDB database for our DocMan bot
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们为 DocMan 机器人使用 MongoDB 数据库
- en: Assuming you have MongoDB up and running on your machine, let's set up a database
    with sample data for our bot using the following steps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在你的机器上已经安装并运行了 MongoDB，让我们按照以下步骤为我们的机器人设置一个带有示例数据的数据库。
- en: MongoDB shell
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MongoDB shell
- en: 'Locate the `bin` directory of your MongoDB installation using the Command Prompt
    and run the MongoDB shell using `mongo.exe`. If everything goes well, you will
    see the following screen:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令提示符定位你的 MongoDB 安装中的 `bin` 目录，并使用 `mongo.exe` 运行 MongoDB shell。如果一切顺利，你将看到以下屏幕：
- en: '![MongoDB shell](img/image00301.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB shell](img/image00301.jpeg)'
- en: Create a database
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'Let''s create a new database called `BotDB` using the command shown in the
    following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下截图所示的命令创建一个名为 `BotDB` 的新数据库：
- en: '![Create a database](img/image00302.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/image00302.jpeg)'
- en: 'Now, to verify whether or not the database has been created, use the `show
    dbs` command. You will see the name `BotDB` in the list, as shown in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证数据库是否已创建，使用 `show dbs` 命令。你将在列表中看到 `BotDB` 的名称，如下面的截图所示：
- en: '![Create a database](img/image00303.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/image00303.jpeg)'
- en: Create a reference documents collection
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个参考文档集合
- en: 'To store documents, metadata, and attributes, let''s create a collection called
    `ReferenceDocuments` using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储文档、元数据和属性，让我们使用以下命令创建一个名为 `ReferenceDocuments` 的集合：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can verify a newly created collection with the help of the `show collections`
    command, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `show collections` 命令来验证新创建的集合，如下面的截图所示：
- en: '![Create a reference documents collection](img/image00304.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![创建参考文档集合](img/image00304.jpeg)'
- en: Create data for our DocMan bot
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为我们的 DocMan 机器人创建数据
- en: 'Our `BotResearcher` group needs some documents and templates for their day
    to day use. These documents can be seen in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BotResearcher` 组需要一些文档和模板用于日常使用。这些文档可以在以下截图中看到：
- en: '![Create data for our DocMan bot](img/image00305.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![为我们的 DocMan 机器人创建数据](img/image00305.jpeg)'
- en: 'As a sample, I will use the `Research Planning Checklist` to show how we will
    store the metadata for this document in a MongoDB collection. Refer to the following
    JSON code for the metadata of this document:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我将使用 `Research Planning Checklist` 来展示我们将如何在一个 MongoDB 集合中存储该文档的元数据。请参考以下
    JSON 代码以获取该文档的元数据：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will be storing the `title`, `description`, `version`, `url`, and keywords
    in our `ReferenceDocuments` collection using the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令在 `ReferenceDocuments` 集合中存储 `title`、`description`、`version`、`url`
    和关键词：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After inserting the preceding record, you will see the following message as
    `WriteResult({"nInserted":1})`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入前面的记录后，你将看到以下消息作为 `WriteResult({"nInserted":1})`：
- en: '![Create data for our DocMan bot](img/image00306.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![为我们的 DocMan 机器人创建数据](img/image00306.jpeg)'
- en: This way, we can create all the records in MongoDB for all our documents.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以为所有我们的文档在 MongoDB 中创建所有记录。
- en: Indexing for search
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索索引
- en: 'Since a document can be searched using multiple keywords, we are storing keywords
    in an array for a document. When team members search documents, they will use
    keywords. We will apply an index to these keywords using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档可以通过多个关键词进行搜索，因此我们为每个文档存储关键词在一个数组中。当团队成员搜索文档时，他们将使用关键词。我们将使用以下命令对这些关键词应用索引：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running a command, you will see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，您将看到以下输出：
- en: '![Indexing for search](img/image00307.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![搜索索引](img/image00307.jpeg)'
- en: Search query
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索查询
- en: 'Once our index has been created, let''s verify whether or not our search is
    working based on the keywords we enter. Let''s fire the following command on the
    MongoDB shell:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的索引创建完成，让我们根据我们输入的关键词验证我们的搜索是否工作。让我们在 MongoDB shell 上执行以下命令：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After executing the `search` query, you should see the following result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `search` 查询后，您应该看到以下结果：
- en: '![Search query](img/image00308.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![搜索查询](img/image00308.jpeg)'
- en: To summarize, we created a new database for our bot to store the metadata of
    the documents that it searches. We added a new collection and added some sample
    documents. We also applied a text index to the keywords column so as to enable
    a search using keywords.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们为我们的机器人创建了一个新的数据库来存储它搜索的文档的元数据。我们添加了一个新的集合并添加了一些示例文档。我们还对关键词列应用了文本索引，以便能够使用关键词进行搜索。
- en: Now let's look at how we can wire up our database with Node.js.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何将数据库与 Node.js 连接起来。
- en: What is MongoJS?
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 MongoJS？
- en: MongoJS is a Node.JS library used to connect to MongoDB APIs. Using this library,
    we will establish a connection with our MongoDB database and query documents based
    on input keywords.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MongoJS 是一个用于连接到 MongoDB API 的 Node.JS 库。使用这个库，我们将与我们的 MongoDB 数据库建立连接并根据输入的关键词查询文档。
- en: Wiring up DocMan bot with MongoDB
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 DocMan 机器人连接到 MongoDB
- en: Let's go back to our `Slackbot` directory and install the `mongojs` package
    from NPM. This can be located at [https://www.npmjs.com/package/mongojs](https://www.npmjs.com/package/mongojs)
    .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `Slackbot` 目录并从 NPM 安装 `mongojs` 包。这个包可以在 [https://www.npmjs.com/package/mongojs](https://www.npmjs.com/package/mongojs)
    找到。
- en: 'In order to install it, run this `npm` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装它，运行以下 `npm` 命令：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should then see something similar to this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的内容：
- en: '![Wiring up DocMan bot with MongoDB](img/image00309.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![将 DocMan 机器人连接到 MongoDB](img/image00309.jpeg)'
- en: Let's modify our `app.js` file so that we can access MongoDB APIs through the
    `Mongojs` library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的 `app.js` 文件，以便我们可以通过 `Mongojs` 库访问 MongoDB API。
- en: 'Our `app.js` should be like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `app.js` 应该是这样的：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at this basic code with `mongojs` wired up as shown in the preceding
    code snippet. We connect to the MongoDB database through `mongojs` using the following
    lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个基本的代码，其中 `mongojs` 如前代码片段所示连接。我们通过以下行通过 `mongojs` 连接到 MongoDB 数据库：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, MongoDB is hosted locally on my machine, so the host used is named as
    `127.0.0.1` and it listens to port `27017`. This IP address and port can be different
    for your machine, so while implementing your bots, make sure you use your machine's
    IP address and port for MongoDB. Within MongoDB, we connect to the `BotDB` database
    and a collection called `ReferenceDocuments`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，MongoDB 在我的机器上本地托管，所以使用的名称是 `127.0.0.1`，它监听端口 `27017`。这个 IP 地址和端口对于您的机器可能不同，所以在实现您的机器人时，请确保您使用您机器的
    IP 地址和端口用于 MongoDB。在 MongoDB 中，我们连接到 `BotDB` 数据库和一个名为 `ReferenceDocuments` 的集合。
- en: 'To query one of the documents from `ReferenceDocuments`, the following code
    is used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询 `ReferenceDocuments` 中的一个文档，以下代码被使用：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s run the modified code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行修改后的代码：
- en: '![Wiring up DocMan bot with MongoDB](img/image00310.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![将 DocMan 机器人连接到 MongoDB](img/image00310.jpeg)'
- en: Go back to our Bot Researchers Slack group and say `hello` to our modified docman
    using direct messaging. You can also send mentions to docman as well, but this
    time I will use direct messaging.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 Bot Researchers Slack 群组，通过直接消息对我们的修改后的 docman 说 `hello`。您也可以向 docman
    发送提及，但这次我将使用直接消息。
- en: 'When I messaged the `hello` directly to **docman**, docman queried the `BotDB`
    database and returned the title of one of the documents from the `ReferenceDocuments`
    collection. Refer to the following screenshot for further details:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我直接向 `hello` 发送消息到 **docman** 时，docman 查询了 `BotDB` 数据库，并从 `ReferenceDocuments`
    集合中返回了一个文档的标题。有关更多详细信息，请参考以下截图：
- en: '![Wiring up DocMan bot with MongoDB](img/image00311.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![连接DocMan机器人与MongoDB](img/image00311.jpeg)'
- en: This shows how we can establish a MongoDB connectivity and query the data using
    `mongojs`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们可以如何建立MongoDB连接并使用`mongojs`查询数据。
- en: Amazon S3 storage
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Amazon S3存储
- en: '**Amazon Simple Storage Service** (**Amazon S3**) is a cloud-based data storage
    system from **Amazon Web Services** (**AWS**). We can use Amazon S3 to store any
    amount of data. Amazon S3 stores data as objects within buckets. An object can
    be a document or a file. In our DocMan context, all the actual documents or files
    that are searched by Bot Researchers team members are stored in Amazon S3\. In
    future, these files or documents can be of any types, such as media or office
    files of any size. Also, every bucket can have access control to decide who can
    access, delete, and create objects from the buckets. Given these requirements,
    Amazon S3 is suitable for our DocMan documents storage.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon简单存储服务**（**Amazon S3**）是来自**Amazon Web Services**（**AWS**）的基于云的数据存储系统。我们可以使用Amazon
    S3存储任何数量的数据。Amazon S3将数据作为对象存储在桶中。一个对象可以是一个文档或文件。在我们的DocMan环境中，所有由Bot Researchers团队成员搜索的实际文档或文件都存储在Amazon
    S3中。在未来，这些文件或文档可以是任何类型，例如媒体或任何大小的办公文件。此外，每个桶都可以有访问控制，以决定谁可以访问、删除和从桶中创建对象。考虑到这些要求，Amazon
    S3非常适合我们的DocMan文档存储。'
- en: Amazon S3 console
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Amazon S3控制台
- en: 'I have my Amazon AWS account. Using that account, I have logged in to my Amazon
    S3 console. This console can be seen in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我有我的Amazon AWS账户。使用该账户，我已登录到我的Amazon S3控制台。此控制台在以下截图中可见：
- en: '![Amazon S3 console](img/image00312.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Amazon S3控制台](img/image00312.jpeg)'
- en: Those who are new to AWS can refer to the information at [https://aws.amazon.com/](https://aws.amazon.com/)
    .
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AWS新手，可以参考[https://aws.amazon.com/](https://aws.amazon.com/)的信息。
- en: Create buckets
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建桶
- en: 'From the preceding Amazon S3 console, click on the **Create Bucket** button
    to launch a **Create a Bucket** screen, as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的Amazon S3控制台，点击**创建桶**按钮以启动**创建桶**界面，如下截图所示：
- en: '![Create buckets](img/image00313.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![创建桶](img/image00313.jpeg)'
- en: In creating my bucket, I have given the **Bucket Name** as **botdocuments**
    and selected the **Region** as **Oregon**. Make sure you are entering the **Bucket
    Name** in lowercase letters. Click on the **Create** button to create your bucket.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我的桶时，我将其**桶名**设置为**botdocuments**，并将**区域**选为**俄勒冈州**。确保你使用的是小写字母输入**桶名**。点击**创建**按钮来创建你的桶。
- en: 'Your bucket will be shown under the **All Buckets** table:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的桶将在**所有桶**表中显示：
- en: '![Create buckets](img/image00314.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![创建桶](img/image00314.jpeg)'
- en: Now click on the bucket name shown under the **Name** column so that we can
    display a bucket view to upload and manage documents inside this bucket.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击**名称**列下显示的桶名，这样我们就可以显示一个桶视图来上传和管理此桶内的文档。
- en: Store documents in the bucket
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将文档存储在桶中
- en: 'Once you select the bucket name from the **All Buckets** view, you will see
    the following screen:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从**所有桶**视图中选择桶名，你将看到以下屏幕：
- en: '![Store documents in the bucket](img/image00315.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![将文档存储在桶中](img/image00315.jpeg)'
- en: 'Now, to upload documents in this bucket, click on the **Upload** button and
    upload documents with the help of the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要上传此桶中的文档，点击**上传**按钮，并使用以下截图来上传文档：
- en: '![Store documents in the bucket](img/image00316.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![将文档存储在桶中](img/image00316.jpeg)'
- en: 'I will use the drag and drop function to upload my files. Once you have dragged
    and dropped all the files that you want to upload, click on **Start Upload** to
    upload your files. Once all the files are uploaded, the bucket will show all the
    files as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用拖放功能上传我的文件。一旦你拖放了你想要上传的所有文件，点击**开始上传**来上传你的文件。一旦所有文件都上传完毕，桶将显示如下：
- en: '![Store documents in the bucket](img/image00317.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![将文档存储在桶中](img/image00317.jpeg)'
- en: Mark documents as public
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记文档为公开
- en: Just for demonstration purposes, we will be marking these documents as public.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了演示目的，我们将将这些文档标记为公开。
- en: This way, our `BotResearchers` group can access and download these documents
    from Amazon S3 storage easily. Let's go through the following steps to mark one
    of these documents as public. .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的`BotResearchers`小组可以轻松访问和从Amazon S3存储中下载这些文档。让我们按照以下步骤标记其中一份文档为公开。
- en: 'Select a document and, from **Actions**, select the **Make Public** option
    in the menu:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个文档，从**操作**中，在菜单中选择**公开**选项：
- en: '![Mark documents as public](img/image00318.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![标记文档为公开](img/image00318.jpeg)'
- en: This option will mark the selected document as public. Now we need a public
    URL so that we can update this URL in our MongoDB database for this document.
    To get the public URL again, select a document and, from the **Actions** menu,
    select the **Properties** menu item.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将所选文档标记为公开。现在我们需要一个公开的URL，以便我们可以在MongoDB数据库中更新此文档的URL。要再次获取公开URL，请选择一个文档，然后从**操作**菜单中选择**属性**菜单项。
- en: 'This will bring up all the properties for the selected document, as shown in
    the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所选文档的所有属性，如下面的截图所示：
- en: '![Mark documents as public](img/image00319.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![标记文档为公开](img/image00319.jpeg)'
- en: From the properties, refer to the **Link** property. This is our public URL
    for the document.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从属性中，参考**链接**属性。这是文档的公开URL。
- en: In this way, mark all the documents as public and copy their URLs. Update these
    URLs to our MongoDB database.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，将所有文档标记为公开并复制它们的URL。将这些URL更新到我们的MongoDB数据库中。
- en: Update MongoDB data with Amazon S3 document links
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Amazon S3文档链接更新MongoDB数据
- en: 'Let''s open up our Mongo shell again and select `BotDB` again using the following
    command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开Mongo shell，并使用以下命令选择`BotDB`：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once successfully updated, you will see the number of records updated on the
    mongo shell. Follow the same steps to update all the rest of your documents' URL
    columns for their Amazon S3 public URLs. With this, we are all set with our bot
    docman, from a backend data perspective.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 更新成功后，您将在mongo shell中看到已更新的记录数。按照相同的步骤更新所有其他文档的URL列，以更新它们的Amazon S3公开URL。这样，从后端数据的角度来看，我们的bot
    docman就准备就绪了。
- en: Wiring it all up together
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有这些连接起来
- en: 'To wire all the things up together, let''s modify our earlier `app.js` as shown
    in the following code snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些连接起来，让我们修改之前的`app.js`，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Code understanding
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码理解
- en: 'I have already explained how we can connect to MongoDB using `mongojs.` Now
    let''s focus on how we have implemented the conversational experience within docman:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经解释了如何使用`mongojs`连接到MongoDB。现在让我们关注如何在docman中实现对话体验：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code snippet, the user can start the conversations with docman
    using the keywords `'docs'`,`'template'`,`'research documentation'`, and `'documents'`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，用户可以使用关键字`'docs'`、`'template'`、`'research documentation'`和`'documents'`与docman开始对话。
- en: Upon receiving a direct message or mention, the bot will start a conversation
    using `bot.startConversation()`. This function will call a related conversation
    sub-function `askForKeywords` `()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 收到直接消息或提及后，机器人将使用`bot.startConversation()`开始对话。此函数将调用相关的对话子函数`askForKeywords()`。
- en: 'The bot will ask us to provide keywords based on which documents need to be
    searched, and will also call the sub-function to actually search the document
    within MongoDB. The implementation for `askForKeywords` `()` can be seen as shown
    in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人将要求我们提供基于哪些文档需要搜索的关键字，并将调用子函数在MongoDB中实际搜索文档。`askForKeywords()`的实现可以参考以下代码片段：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the `convo.next()`function tells our called bot to continue
    the conversation. This step is required, or, our conversation will hang.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`convo.next()`函数告诉我们的被调用机器人继续对话。这一步是必需的，否则我们的对话将会中断。
- en: There is a final sub-function `searchDocuments()` that actually does the searching
    of documents within MongoDB and returns the top three documents as a part of the
    conversation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个最终的子函数`searchDocuments()`，它实际上在MongoDB中搜索文档，并将前三个文档作为对话的一部分返回。
- en: 'Refer to the following code implementation for `searchDocuments()`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码实现`searchDocuments()`：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, once the search query returns data, there can be single
    or multiple documents, so we are iterating the results and then combining them
    into a JSON format. Once JSON formatting is done, the bot calls the `convo.say()`
    function to send the message along with the searched documents.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一旦搜索查询返回数据，可能会有单个或多个文档，因此我们正在迭代结果并将它们组合成JSON格式。一旦完成JSON格式化，机器人将调用`convo.say()`函数来发送带有搜索文档的消息。
- en: Slack has some guidelines concerning the composing of messages and attachments.
    These guidelines can be referred to at [https://api.slack.com/docs/messages](https://api.slack.com/docs/messages)
    .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Slack有一些关于消息和附件编写的指南。这些指南可以在[https://api.slack.com/docs/messages](https://api.slack.com/docs/messages)中查阅。
- en: Now let's begin our great conversation experience with our enhanced Slack bot,
    docman.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们与增强的Slack机器人docman的伟大对话体验。
- en: 'Firstly, start a communication in the **# general** channel by mentioning `@docman`,
    and type the word `docs` as shown in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 **# general** 频道中提及 `@docman` 并输入单词 `docs`，如下截图所示：
- en: '![Code understanding](img/image00320.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![代码理解](img/image00320.jpeg)'
- en: Once we entered `docs`, docman asked to type the word or keywords for the document
    search.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入了 `docs`，docman 就会要求我们输入文档搜索的单词或关键词。
- en: 'Enter the word as `template` and see what **docman** returns:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输入单词作为 `template` 并查看 **docman** 返回的内容：
- en: '![Code understanding](img/image00321.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![代码理解](img/image00321.jpeg)'
- en: 'When I entered the `template` keyword, **docman** replied saying:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我输入了 `template` 关键词时，**docman** 回复说：
- en: '![Code understanding](img/image00322.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![代码理解](img/image00322.jpeg)'
- en: 'It also replied with the searched documents in a nice elegant format using
    the Slack messaging guidelines shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它还以 Slack 消息指南中所示的美好优雅的格式回复了搜索到的文档：
- en: '![Code understanding](img/image00323.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![代码理解](img/image00323.jpeg)'
- en: Now, select one of the documents from the search results-I selected a document
    titled **Timeline Document**, and `Timeline+Document.docx` was downloaded through
    our docman bot.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从搜索结果中选择一份文档——我选择了一份标题为 **时间线文档** 的文档，并通过我们的 docman 机器人下载了 `Timeline+Document.docx`。
- en: 'Refer to the following screenshot to see the downloaded document:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图查看下载的文档：
- en: '![Code understanding](img/image00324.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![代码理解](img/image00324.jpeg)'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, with Slack, we built a bot and enhanced our team's collaborative experience
    by building intelligence into it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 Slack，我们构建了一个机器人，并通过将其智能化来增强了我们团队的协作体验。
- en: To summarize, we saw how to create a Slack group from scratch. We also created
    a basic bot wired up in Node.js using Botkit, and had a basic conversation as
    a direct message as well as within a group by inviting the bot.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们看到了如何从头创建一个 Slack 群组。我们还创建了一个基本的由 Botkit 连接的 Node.js 机器人，并通过邀请机器人进行了基本的直接消息和群组对话。
- en: Finally, we made our bot search some of the documents based on keywords, and
    also provided a link to download the same document.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的机器人根据关键词搜索了一些文档，并提供了下载相同文档的链接。
- en: Our DocMan bot used MongoDB to store document attributes along with keywords
    with which the document can be searched. Also, DocMan retrieved actual documents
    from Amazon S3 storage upon a user's request to download them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DocMan 机器人使用 MongoDB 存储文档属性以及可以用于搜索文档的关键词。此外，当用户请求下载文档时，DocMan 会从 Amazon
    S3 存储中检索实际文档。
- en: Hopefully this chapter has given you an end-to-end solution overview of how
    your bot searches and locates documents, as well as how it downloads them from
    storage locations or document repositories. You should now be aware of NoSQL technologies
    like MongoDB and how we can utilize them for keyword searches, and how we can
    wire up with storage locations like Amazon S3 in Node.js. Above all, you should
    now be fully aware of how we can bring everything together in messaging platforms
    like Slack.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章能为你提供一个端到端解决方案的概述，了解你的机器人如何搜索和定位文档，以及如何从存储位置或文档库中下载它们。你现在应该已经了解到了像MongoDB这样的NoSQL技术，以及我们如何利用它们进行关键词搜索，以及如何在Node.js中与像Amazon
    S3这样的存储位置连接。最重要的是，你现在应该完全清楚我们如何在Slack这样的消息平台上将所有这些整合在一起。
- en: Amazing!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: In the next chapter, we will explore how to develop IRC bots and how we can
    wire up within Node.js and help our developers use it for bug tracking purposes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何开发IRC机器人，以及我们如何在Node.js中连接它们，并帮助我们的开发者将其用于错误跟踪目的。
