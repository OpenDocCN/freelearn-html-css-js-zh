- en: Chapter 1. Why JavaScript Concurrency?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 为什么需要JavaScript并发？
- en: JavaScript is not a language associated with concurrency. In fact, it's frequently
    associated with the exact opposite—concurrency challenges. This has changed a
    lot over the past few years, especially with new language features in ES 2015\.
    Promises have been used in JavaScript for many years; only now, they're a native
    type. Generators are another addition to the language that changes the way we
    think about concurrency in JavaScript. Web workers have been in browsers for several
    years, and yet, we don't see them used that often. Perhaps, it has less to do
    with workers and more about our understanding of the role that concurrency plays
    in our applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并不是一个与并发相关的语言。实际上，它通常与完全相反的并发挑战相关联。然而，在过去的几年里，这种情况发生了很大的变化，尤其是在ES
    2015中引入了新的语言特性。Promise在JavaScript中已经使用了多年；而现在，它们已经成为了一种原生类型。Generators是语言中的另一个补充，它改变了我们思考JavaScript中并发方式的方式。Web
    workers已经在浏览器中存在了几年，但我们很少看到它们被使用。也许，这更多与workers无关，而与我们对于并发在我们应用程序中扮演的角色理解有关。
- en: The aim of this chapter is to explore some general concurrency ideas, starting
    with what, exactly, concurrency is. If you don't have any sort of concurrent programming
    in your background, it's fine because this chapter is a perfect starting point
    for you. If you've done concurrent programming in the past using JavaScript or
    some other language, think of this chapter as a refresher, only with JavaScript
    as the context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是探讨一些通用的并发思想，从并发究竟是什么开始。如果你没有任何形式的并发编程背景，那没关系，因为本章是你完美的起点。如果你过去使用JavaScript或其他语言进行过并发编程，那么将本章视为一个复习，只是以JavaScript为背景。
- en: We'll wrap up this chapter with some overarching concurrency principles. These
    are valuable programming tools that we should keep in the back of our heads while
    writing concurrent code. Once we have learned to apply these principles, they'll
    tell us whether we're on the right track with our concurrency design, or that
    we need to take a step back and ask ourselves what we're really trying to achieve.
    These principles take a top-down approach to the design of our application. This
    means that they're applicable from the very start, even before we've started writing
    any code. Throughout the book, we'll be referring to these principles, so if you
    only read one section in this chapter, make sure it's *Concurrency principles*
    at the end.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章总结为一些基本的并发原则。这些是有价值的编程工具，我们在编写并发代码时应该将其放在心中。一旦我们学会了应用这些原则，它们将告诉我们我们的并发设计是否正确，或者我们需要退一步，问问自己我们真正想要实现什么。这些原则采用自上而下的方法来设计我们的应用程序。这意味着它们适用于从开始到结束的整个过程。在整个书中，我们将参考这些原则，所以如果你只阅读本章的一个部分，确保是最后的*并发原则*。
- en: Synchronous JavaScript
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步JavaScript
- en: Before we start conjuring large-scale concurrent JavaScript architectures, let's
    shift our attention to the good old synchronous JavaScript code that we're all
    familiar with. These are the blocks of JavaScript code that are called as the
    result of a click event, or run as the result of loading a webpage. Once they
    start, they don't stop. That is to say, they're **run-to-completion**. We'll dig
    into run-to-completion a little more in the following chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建大规模并发JavaScript架构之前，让我们将注意力转向我们所有人都熟悉的经典同步JavaScript代码。这些是作为点击事件的结果而被调用的JavaScript代码块，或者作为加载网页的结果而运行。一旦开始，它们就不会停止。也就是说，它们是**运行至完成**的。我们将在下一章更深入地探讨运行至完成的概念。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll occasionally see the term **synchronous** and **serial** used interchangeably
    throughout the chapters. They're both referring to code statements that run one
    after another until there's nothing more to run.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在章节中偶尔看到**同步**和**串行**这两个术语被交替使用。它们都指的是依次运行的代码语句，直到没有更多可运行的内容为止。
- en: Despite JavaScript being designed as a single-threaded, run-to-completion environment,
    the nature of the web complicates this. Think about the web browser, and all it's
    moving parts. There's the **Document Object Model** (**DOM**) for rendering user
    interfaces and **XMLHttpRequest** (**XHR**) objects for fetching remote data sources,
    to name a couple. Let's take a look at the synchronous nature of JavaScript and
    the asynchronous nature of the web.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript被设计为单线程、运行至完成的环境，但网络的本质使得这一点变得复杂。想想看网络浏览器及其所有移动部件。有用于渲染用户界面的**文档对象模型**（**DOM**）和用于获取远程数据源的**XMLHttpRequest**（**XHR**）对象，仅举两例。让我们来看看JavaScript的同步特性和网络的异步特性。
- en: Synchronicity is easy to understand
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步性容易理解
- en: 'When code is synchronous, it''s easier to understand. It''s easier to mentally
    map the instructions that we''re seeing on the screen to sequential steps in our
    heads; do this, then do that; check this, if `true`, do that, and so on. This
    type of serial processing is easy enough to understand, because there aren''t
    any surprises, assuming the code isn''t completely horrible. Here''s an example
    of how we might visualize a chunk of synchronous code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码是同步的，它更容易理解。它更容易将我们在屏幕上看到的指令映射到我们头脑中的顺序步骤；这样做，然后那样做；检查这个，如果为`true`，则那样做，等等。这种串行处理类型足够容易理解，因为没有惊喜，假设代码不是完全糟糕。以下是我们可能如何可视化一段同步代码的示例：
- en: '![Synchronicity is easy to understand](img/B05133_01_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![同步性容易理解](img/B05133_01_01.jpg)'
- en: 'Concurrent programming, on the other hand, isn''t so easy to grasp. This is
    because there''s no linear logic for us to follow in our code editors. Instead,
    we constantly jump around, trying to map what this piece of code is doing relative
    to that piece of code. Time is an important factor with concurrent designs; it
    is something that goes against the brain''s natural way of comprehending code.
    When we read code, we naturally execute it in our heads. This is how we figure
    out what it''s doing. This approach falls apart when the actual execution doesn''t
    line up with what''s in our head. Normally, code reads like a book—concurrent
    code is like a book where the pages are numbered, but out of order. Let''s take
    a look at some trivial pseudo JavaScript code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，并发编程并不容易掌握。这是因为我们的代码编辑器中没有线性逻辑可以遵循。相反，我们不断地跳来跳去，试图将这段代码相对于那段代码的行为映射出来。时间是在并发设计中一个重要的因素；这是与大脑自然理解代码的方式相悖的。当我们阅读代码时，我们自然会将其在脑海中执行。这就是我们弄清楚它在做什么的方式。当实际执行与我们在脑海中想象的不一致时，这种方法就会失效。通常，代码读起来像一本书——并发代码就像一本页码编号但顺序混乱的书。让我们看看一些简单的伪JavaScript代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In traditional multi-threading environments, a thread is something that runs
    asynchronously with other threads. We use threads to take advantage of multiple
    CPUs found on most systems today, resulting in better performance. However, this
    comes at a cost because it forces us to rethink how our code is executed at runtime.
    It's no longer the usual step by step execution. This code could be running alongside
    other code in another CPU, or it could be competing with other threads for time
    on the same CPU.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的多线程环境中，线程是与其他线程异步运行的某个东西。我们使用线程来利用大多数系统上找到的多个CPU，从而提高性能。然而，这也有代价，因为它迫使我们重新思考代码在运行时的执行方式。不再是通常的逐步执行。这段代码可能在与另一个CPU上的其他代码并行运行，或者它可能在与同一CPU上的其他线程争夺时间。
- en: 'A lot of simplicity goes away when we introduce concurrency to synchronous
    code—it''s the code equivalent of *brain freeze*. This is why we write concurrent
    code: code that makes an upfront assumption of concurrency. We''ll elaborate on
    this concept as we progress through the book. With JavaScript, it''s important
    to assume a concurrent design, because that''s the way the web works.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将并发引入同步代码时，很多简单性都会消失——这是代码中的“大脑冻结”。这就是我们编写并发代码的原因：代码预先假设并发。随着我们通过本书的进展，我们将详细阐述这个概念。对于JavaScript来说，假设并发设计很重要，因为这就是网络的工作方式。
- en: Asynchronous is inevitable
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步性是不可避免的
- en: The reason that concurrency in JavaScript is such an important idea is because
    the web is a concurrent place, both from a very high level and an implementation
    detail level. In other words, the web is concurrent because at any given point
    in time, there's oodles of data flowing over the miles of fiber, which encase
    the globe. It has to do with the applications themselves that are deployed to
    web browsers, and how the back-end servers handle the litany of requests for data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的并发之所以如此重要，是因为网络在非常高的层次和实现细节层面上都是并发的。换句话说，网络之所以是并发的，是因为在任何给定的时间点，都有大量的数据在跨越全球的纤维中流动。这与部署到网络浏览器的应用程序本身有关，以及后端服务器如何处理对数据的请求清单。
- en: Asynchronous browsers
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步浏览器
- en: Let's take a closer look at the browser and the kinds of asynchronous actions
    found there. When a user loads a webpage, one of the first actions that the page
    will perform is to download and evaluate our JavaScript code that goes with the
    page. This in itself is an asynchronous action, because while our code downloads,
    the browser will continue doing other things, such as rendering page elements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看浏览器和其中发现的异步操作类型。当用户加载网页时，页面将执行的第一项操作之一是下载并评估与页面一起的JavaScript代码。这本身就是一个异步操作，因为当我们的代码下载时，浏览器将继续执行其他任务，例如渲染页面元素。
- en: 'Another asynchronous data source that arrives over the network is the application
    data itself. Once our page has loaded and our JavaScript code starts running,
    we''ll need to display some data for the user. This is actually one of the first
    things that our code will do so that the user has something to look at right away.
    Again, while we''re waiting on this data to arrive, the JavaScript engine will
    move our code right along to it''s next set of instructions. Here''s a request
    for remote data that doesn''t wait for the response before continuing on with
    executing code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通过网络到达的异步数据源是应用程序数据本身。一旦我们的页面加载完成并且我们的JavaScript代码开始运行，我们就需要向用户展示一些数据。这实际上是我们的代码要做的第一件事，以便用户可以立即看到一些内容。同样，当我们等待这些数据到达时，JavaScript引擎会继续执行我们的代码，直到到达下一组指令。以下是一个请求远程数据但不等待响应就继续执行代码的示例：
- en: '![Asynchronous browsers](img/B05133_01_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![异步浏览器](img/B05133_01_02.jpg)'
- en: After the page elements have all been rendered and populated with data, the
    user starts interacting with our page. This means events are dispatched—clicking
    an element dispatches a click event. The DOM environment, where these events are
    dispatched from, is a sand-boxed environment. This means that within the browser,
    the DOM is a subsystem, separate from the JavaScript interpreter, which runs our
    code. This separation makes certain JavaScript concurrency scenarios especially
    difficult. We'll cover these in depth in the next chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面元素全部渲染并填充数据后，用户开始与我们的页面交互。这意味着会触发事件——点击一个元素会触发点击事件。触发这些事件的DOM环境是一个沙盒环境。这意味着在浏览器中，DOM是一个子系统，与运行我们代码的JavaScript解释器分开。这种分离使得某些JavaScript并发场景特别困难。我们将在下一章深入探讨这些问题。
- en: With all these sources of asynchronicity, it's no wonder that our pages can
    become bloated with special case handling to deal with the edge cases that inevitably
    pop up. Thinking asynchronously isn't natural, so this type of monkey-patching
    is the likely result of thinking synchronously. It's best to embrace the asynchronous
    nature of the web. After all, a synchronous web can lead to unbearable user experiences.
    Now, let's dig a little further into the types of concurrency we're likely to
    face in our JavaScript architectures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些异步源的影响下，我们的页面可能会因为处理不可避免出现的边缘情况而变得臃肿。异步思考并不自然，因此这种同步思维的结果很可能是这种猴子补丁式的修改。最好接受网络的异步本质。毕竟，同步的网络可能导致无法忍受的用户体验。现在，让我们进一步探讨我们可能在JavaScript架构中遇到的并发类型。
- en: Types of concurrency
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发类型
- en: JavaScript is a run-to-completion language. There's no getting around it, despite
    any concurrency mechanisms that are thrown on top of it. In other words, our JavaScript
    code isn't going to yield control to another thread in the middle of an `if` statement.
    The reason this matters is so that we can pick a level of abstraction that makes
    sense in helping us think about JavaScript concurrency. Let's look at the two
    types of concurrent actions found in our JavaScript code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种运行至完成的语言。这一点无法避免，尽管在其之上可能添加了任何并发机制。换句话说，我们的 JavaScript 代码在 `if`
    语句的中间不会将控制权交给另一个线程。这一点之所以重要，是因为我们可以选择一个合理的抽象层次，帮助我们思考 JavaScript 并发。让我们看看在 JavaScript
    代码中发现的两种并发动作类型。
- en: Asynchronous actions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步动作
- en: A defining characteristic of asynchronous actions is that they do not block
    other actions that follow. Asynchronous actions don't necessarily mean *fire-and-forget*.
    Rather, when the part of the action we're waiting on completes, we run a callback
    function. This callback function falls out of sync with the rest of our code;
    hence, the term asynchronous.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 异步动作的一个定义特征是它们不会阻塞后续的其他动作。异步动作并不一定意味着“触发并忘记”。相反，当我们等待的动作部分完成时，我们运行一个回调函数。这个回调函数与我们的代码的其他部分不同步；因此，术语异步。
- en: In web front-ends, this generally means fetching data from a remote service.
    These fetching actions are relatively slow, because they have to traverse the
    network connection. It makes sense for these actions to be asynchronous, just
    because our code is waiting on some data to return so that it can fire a callback
    function, doesn't mean the user should have to sit around and wait too. Furthermore,
    it's unlikely that any screen that the user is currently looking at depends on
    only one remote resource. So, serially processing multiple remote fetch requests
    would have a detrimental effect on the user experience.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络前端，这通常意味着从远程服务获取数据。这些获取动作相对较慢，因为它们必须穿越网络连接。这些动作异步进行是有意义的，仅仅因为我们的代码正在等待某些数据返回以便触发回调函数，并不意味着用户必须坐着等待。此外，用户当前查看的任何屏幕都不太可能只依赖于一个远程资源。因此，顺序处理多个远程获取请求会对用户体验产生不利影响。
- en: 'Here''s a general idea of what asynchronous code looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于异步代码的一般概念：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取您购买的所有
    Packt 出版物的所有示例代码。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: We're not limited to fetching remote data, as the single source of asynchronous
    actions. When we make network requests, these asynchronous control flows actually
    leave the browser. But what about asynchronous actions that are confined within
    the browser? Take the `setTimeout()` function as an example. It follows the same
    callback pattern that's used with network fetch requests. The function is passed
    a callback, which is executed at a later point. However, nothing ever leaves the
    browser. Instead, the action is queued behind any number of other actions. This
    is because asynchronous actions are still just one thread of control, executed
    by one CPU. This means that as our applications grow in size and complexity, we're
    faced with a concurrency scaling issue. But then, maybe asynchronous actions weren't
    meant to solve the single CPU problem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于从远程数据源获取数据，作为异步动作的唯一来源。当我们发起网络请求时，这些异步控制流实际上离开了浏览器。但是，关于限制在浏览器内的异步动作怎么办？以
    `setTimeout()` 函数为例。它遵循与网络获取请求相同的回调模式。函数传递一个回调，该回调在稍后执行。然而，没有任何东西离开浏览器。相反，动作被排队在任意数量的其他动作之后。这是因为异步动作仍然只是由一个
    CPU 执行的一个控制线程。这意味着随着我们的应用程序规模和复杂性的增长，我们面临着并发扩展问题。但是，也许异步动作并不是为了解决单 CPU 问题而设计的。
- en: 'Perhaps a better way to think about asynchronous actions performed on a single
    CPU is to picture a juggler. The juggler''s brain is the CPU, coordinating his
    motor actions. The balls that get tossed around is the data our actions operate
    on. There''s only two fundamental actions we care about—*toss* and *catch*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好地思考在单个CPU上执行的异步操作的方式是将它们想象成一个杂技演员。杂技演员的大脑是CPU，协调他的动作。被抛来抛去的球是我们操作的数据。我们只关心两种基本动作——*抛*和*接*：
- en: '![Asynchronous actions](img/B05133_01_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![异步操作](img/B05133_01_03.jpg)'
- en: Since the juggler only has one brain, he can't possibly devote his mental capacity
    to perform more than one task at a time. However, the juggler is experienced and
    knows he doesn't need more than a tiny fraction of attention given to the toss
    or catch actions. Once the ball is in the air, he's free to return his attention
    to catching the ball that's about to land.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于杂技演员只有一个大脑，他不可能一次集中精力完成多个任务。然而，杂技演员经验丰富，他知道他不需要将太多的注意力集中在抛或接的动作上。一旦球被抛起，他就可以将注意力转移到即将落下的球上。
- en: To anyone observing this juggler in action, it appears as though he's paying
    full attention to all six balls, when in reality, he's ignoring five of them at
    any point in time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何观察这个正在表演的杂技演员的人来说，他似乎在全心全意地关注着所有的六个球，但实际上，他在任何时刻都在忽略其中的五个球。
- en: Parallel actions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行操作
- en: Like asynchronicity, parallelism allows control flow to continue without waiting
    on actions to complete. Unlike asynchronicity, parallelism depends on hardware.
    This is because we can't have two or more flows of control taking place in parallel
    on a single CPU. However, the main aspect that sets parallelism apart from asynchronicity
    is the rationale for using it. The two approaches to concurrency solve different
    problems, and both require different design principles.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像异步性一样，并行性允许控制流在等待操作完成之前继续进行。与异步性不同，并行性依赖于硬件。这是因为我们无法在单个CPU上同时进行两个或更多控制流的并行操作。然而，将并行性与异步性区分开来的主要方面是使用它的理由。这两种并发方法解决不同的问题，并且都需要不同的设计原则。
- en: At the end of the day, we want to perform actions in parallel that would otherwise
    be time prohibitive, if performed synchronously. Think about a user who is awaiting
    three expensive actions to complete. If each takes 10 seconds to complete (an
    eternity on a UX timescale), then this means the user will have to wait for 30
    seconds. If we're able to perform these tasks in parallel, we can bring the aggregate
    wait time closer to 10 seconds. We get more for less, leading to a performant
    user interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望执行原本如果同步进行将耗时过长的并行操作。想象一下，一个用户正在等待三个昂贵的操作完成。如果每个操作需要10秒钟完成（在用户体验的时间尺度上仿佛是永恒），那么这意味着用户将不得不等待30秒钟。如果我们能够并行执行这些任务，我们可以将总等待时间缩短至接近10秒。以更少的代价获得更多，从而实现性能良好的用户界面。
- en: 'None of this is free. Like asynchronous actions, parallel actions lead to callbacks
    as a communication mechanism. In general, designing for parallelism is hard, because
    in addition to communicating with worker threads, we have to worry about the task
    at hand, that is, what are we hoping to achieve by using worker threads? And how
    do we break down our problem into smaller actions? The following is a rough idea
    of what our code starts to look like when we introduce parallelism:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都不是免费的。就像异步操作一样，并行操作会导致回调作为通信机制。一般来说，设计并行性是困难的，因为除了与工作线程通信外，我们还要担心手头上的任务，即我们希望通过使用工作线程实现什么？以及我们如何将问题分解成更小的操作？以下是我们引入并行性后代码的大致样子：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't worry about the mechanics of what's happening with this code, as they'll
    all be covered in depth later on. The takeaway is that as we throw workers into
    the mix, we add more callbacks to an environment that's already polluted with
    them. This is why we have to design for parallelism in our code, which is a major
    focus of this book, starting in [Chapter 5](ch05.html "Chapter 5. Working with
    Workers"), *Working with Workers*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这段代码的机制，因为它们将在后面的章节中深入探讨。重要的是，当我们把工作线程加入进来时，我们向已经充斥着回调的环境中添加了更多的回调。这就是为什么我们必须在代码中设计并行性，这是本书的一个主要焦点，从第五章[Chapter
    5](ch05.html "第五章。与工作线程一起工作") *与工作线程一起工作*开始。
- en: 'Let''s think about the juggler analogy from the preceding section. The toss
    and catch actions are performed asynchronously by the juggler; that is, he has
    only one brain/CPU. But suppose the environment around us is constantly changing.
    There''s a growing audience for our juggling act and a single juggler can''t possibly
    keep them all entertained:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下上一节中的杂技演员类比。抛接动作是由杂技演员异步执行的；也就是说，他只有一个大脑/CPU。但是假设我们周围的环境不断变化。我们的抛接表演的观众越来越多，一个杂技演员不可能让所有的人都保持愉快：
- en: '![Parallel actions](img/B05133_01_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![并行动作](img/B05133_01_04.jpg)'
- en: The solution is to introduce more jugglers to the act. This way we add more
    computing power capable, of performing multiple toss and catch actions in the
    same instant. This simply isn't possible with a single juggler running asynchronously.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是引入更多的杂技演员。这样我们就能增加更多的计算能力，能够在同一瞬间执行多个抛接动作。这对于单个异步运行的杂技演员来说是不可能的。
- en: We're not out of the woods yet, because we can't just have the newly-added jugglers
    stand in one place, and perform their act the same way our single juggler did.
    The audience is larger, more diverse, and needs to be entertained. The jugglers
    need to be able to handle different items. They need to move around on the floor
    so that the various sections of the audience are kept happy. They might even start
    juggling with each other. It's up to us to produce a design that's capable of
    orchestrating this juggling act.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有走出困境，因为我们不能让新增加的杂技演员站在一个地方，像我们的单个杂技演员那样表演。观众更多，更多样化，需要娱乐。杂技演员需要能够处理不同的物品。他们需要在地板上移动，以便让观众的不同部分都保持愉快。他们甚至可能开始相互抛接。这取决于我们能否设计出一个能够协调这种抛接表演的设计。
- en: 'JavaScript concurrency principles: Parallelize, Synchronize, Conserve'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript并发原则：并行化、同步、节约
- en: Now that we've been through the basics of what concurrency is, and its role
    in front-end web development, let's look at some fundamental concurrency principles
    of JavaScript development. These principles are merely tools that inform our design
    choices when we write concurrent JavaScript code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了并发的概念及其在前端Web开发中的作用，让我们来看看JavaScript开发的一些基本并发原则。这些原则仅仅是工具，在我们编写并发JavaScript代码时，它们会指导我们的设计选择。
- en: 'When we apply these principles, they force us to step back and ask the appropriate
    questions before we move forward with implementation. In particular, they''re
    the why and how questions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这些原则时，它们迫使我们退后一步，在实施之前提出适当的问题。特别是，它们是关于为什么和如何的问题：
- en: Why are we implementing this concurrent design?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要实施这种并发设计？
- en: What do we hope to get out of it that we couldn't otherwise get out of a simpler
    synchronous approach?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望通过它得到什么，而无法通过更简单的同步方法得到？
- en: How do we implement concurrency in a way that's unobtrusive to the features
    of our applications?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何实现并发，同时又不影响我们应用程序的功能？
- en: 'Here''s a reference visualization of each concurrency principle, feeding on
    one another during the development process. And with that, we''ll turn our attention
    to each principle for further exploration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每个并发原则的参考可视化，它们在开发过程中相互依赖。有了这个，我们将转向每个原则进行进一步探索：
- en: '![JavaScript concurrency principles: Parallelize, Synchronize, Conserve](img/B05133_01_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript并发原则：并行化、同步、节约](img/B05133_01_05.jpg)'
- en: Parallelize
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化
- en: 'The parallelize principle means taking advantage of modern CPU capabilities
    to compute results in less time. This is now possible in any modern browser or
    NodeJS environment. In the browser, we can achieve true parallelism using web
    workers. In Node, we can achieve true parallelism by spawning new processes. Here''s
    what the CPU looks like from the browser''s perspective:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化原则意味着利用现代CPU的能力，在更短的时间内计算结果。这在任何现代浏览器或NodeJS环境中都是可能的。在浏览器中，我们可以通过使用web workers实现真正的并行性。在Node中，我们可以通过启动新进程来实现真正的并行性。以下是浏览器视角下的CPU样子：
- en: '![Parallelize](img/B05133_01_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![并行化](img/B05133_01_06.jpg)'
- en: With the goal being more computations in less time, we must now ask ourselves
    why we want to do this? Besides the fact that raw performance is super cool in
    it's own right, there has to be some tangible impact for the user. This principle
    makes us look at our parallel code and ask—what does the user get out of this?
    The answer is that we can compute using larger data sets as input, and have a
    smaller opportunity of an unresponsive user experience due to long-running JavaScript.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是在更短的时间内进行更多计算，我们现在必须问自己为什么要这样做？除了原始性能本身非常酷之外，用户必须能够感受到一些实际的影响。这个原则让我们审视我们的并行代码，并问——用户从这能得到什么？答案是，我们可以使用更大的数据集作为输入进行计算，并且由于长时间运行的JavaScript，用户无响应体验的机会更小。
- en: 'It''s important to scrutinize the tangible benefit of going parallel because
    when we do so, we add complexity to our code that wouldn''t otherwise be there.
    So if the user sees the same result no matter what we do, the parallelize principle
    probably isn''t applicable. On the other hand, if scalability is important and
    there''s a strong possibility of growing data set sizes, the trade off of code
    simplicity for parallelism is probably worthwhile. Here''s a checklist to follow
    when thinking about the parallelize principle:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细审查并行化的实际收益很重要，因为当我们这样做时，我们给代码增加了不必要的复杂性。所以如果用户无论我们做什么都能看到相同的结果，那么并行化原则可能不适用。另一方面，如果可扩展性很重要，并且有很强的可能性数据集大小会增长，那么为了并行化而牺牲代码简单性的代价可能是值得的。以下是在考虑并行化原则时需要遵循的清单：
- en: Does our application perform expensive computations against large data sets?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序是否对大型数据集执行昂贵的计算？
- en: As our data sets grow in size, is there potential for processing bottlenecks
    that negatively impact the user experience?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们的数据集增长，是否存在潜在的瓶颈，这会负面影响用户体验？
- en: Do our users currently experience bottlenecks in our application's performance?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户目前是否在我们的应用程序性能中遇到瓶颈？
- en: How feasible is parallelism in our design, given other constraints? What are
    the trade-offs?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在其他约束条件下，我们的设计中并行化有多可行？有哪些权衡？ '
- en: Do the benefits of our concurrency implementation outweigh the overhead costs,
    either in terms of user-perceived latency or in terms of code maintainability?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们并发实现的收益是否超过了开销成本，无论是从用户感知的延迟还是从代码可维护性的角度来看？
- en: Synchronize
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: The synchronize principle is about the mechanisms used to coordinate concurrent
    actions and the abstractions of those mechanisms. Callback functions are a JavaScript
    notion with deep roots. It's the obvious tool of choice when we need to run some
    code, but we don't want to run it now. We want to run it when some condition becomes
    true. By and large, there's nothing inherently wrong with this approach. Used
    in isolation, the callback pattern is probably the most succinct, readable concurrency
    pattern that we can use. Callbacks fall apart when there are plenty them, and
    lots of dependencies between them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原则是关于协调并发动作的机制及其抽象。回调函数是JavaScript的一个概念，有着深厚的根源。当我们需要运行一些代码，但又不想立即运行时，它是显而易见的选择工具。总的来说，这种方法本身并没有什么固有的错误。单独使用回调模式可能是我们能够使用的最简洁、最易读的并发模式。当回调很多，并且它们之间有很多依赖关系时，回调就会崩溃。
- en: The Promise API
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise API
- en: 'The Promise API is the core JavaScript language construct, introduced in ECMAScript
    6 to address the synchronization woes faced by every application on the planet.
    It''s a simple API that actually makes use of callbacks (yes, we''re fighting
    callbacks with callbacks). The aim of promises isn''t to eliminate callbacks,
    it''s to remove the unnecessary callbacks. Here''s what a promise that''s used
    to synchronize two network fetch calls looks like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Promise API是核心JavaScript语言结构，在ECMAScript 6中引入，以解决地球上每个应用程序面临的同步难题。这是一个简单的API，实际上使用了回调（是的，我们正在用回调对抗回调）。Promise的目标不是消除回调，而是移除不必要的回调。以下是一个用于同步两个网络fetch调用的Promise示例：
- en: '![The Promise API](img/B05133_01_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Promise API](img/B05133_01_07.jpg)'
- en: 'What''s crucial about promises is that they''re a generic synchronization mechanism.
    This means that they''re not specifically made for network requests, web workers,
    or DOM events. We, the programmers, have to wrap our asynchronous actions with
    promises and resolve them as necessary. The reason why this is a good thing is
    because the callers that rely on the promise interface don''t care about what''s
    going on inside the promise. As the name implies, it''s a promise to resolve a
    value at some point. This could be in 5 seconds or immediately. The data can come
    from a network resource or a web worker. The caller doesn''t care, because it
    makes an assumption of concurrency, which means we can fulfill it any in way we
    like without breaking the application. Here''s a modified version of the preceding
    diagram, which will give us a taste of what promises make possible:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于承诺（promises）的关键之处在于它们是一种通用的同步机制。这意味着它们并不是专门为网络请求、Web Workers 或 DOM 事件而设计的。我们，程序员，必须将我们的异步操作用承诺包裹起来，并在必要时解决它们。这样做的好处是，依赖于承诺接口的调用者并不关心承诺内部正在发生什么。正如其名所示，它承诺在某个时刻解决一个值。这可能是在5秒后或立即发生。数据可以来自网络资源或Web
    Worker。调用者并不关心，因为它假设并发，这意味着我们可以以任何我们喜欢的方式实现它，而不会破坏应用程序。以下是对前面图表的修改版本，这将让我们尝到承诺能实现什么：
- en: '![The Promise API](img/B05133_01_08.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Promise API](img/B05133_01_08.jpg)'
- en: 'When we learn to treat values as values at some point in the future, concurrent
    code is suddenly much more approachable. Promises, and similar mechanisms, can
    be used to synchronize just network requests, or just web worker events. But they''re
    real power is using them to write concurrent applications, where concurrency is
    the default. Here''s a checklist to reference when thinking about the synchronize
    principle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学会在未来某个时刻将值视为值时，并发代码突然变得更容易接近。承诺和类似机制可以用来同步仅网络请求或仅Web Worker事件。但它们的真正力量在于使用它们来编写并发应用程序，其中并发是默认的。以下是一个清单，当思考同步原则时可以参考：
- en: Does our application heavily rely on callback functions as a synchronization
    mechanism?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序是否严重依赖于回调函数作为同步机制？
- en: Do we often have to synchronize more than one asynchronous event such as network
    requests?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否经常需要同步多个异步事件，如网络请求？
- en: Do our callback functions contain more synchronization boilerplate code than
    application code?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的回调函数是否包含比应用程序代码更多的同步样板代码？
- en: What kind of assumptions does our code make about the concurrency mechanisms
    that drive asynchronous events?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码对驱动异步事件的并发机制有什么样的假设？
- en: If we had a magic *kill concurrency* button, would our application still behave
    as expected?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个神奇的**终止并发**按钮，我们的应用程序是否还会按预期运行？
- en: Conserve
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存
- en: The conserve principle is about saving on compute and memory resources. This
    is done by using lazy evaluation techniques. The name *lazy* stems from the idea
    that we don't actually compute a new value until we're sure we actually need it.
    Imagine an application component that renders page elements. We can pass this
    component the exact data that it needs to render. This means that several computations
    take place before the component actually needs it. It also means that the data
    that's used needs to be allocated into memory, so that we can pass it to the component.
    There's nothing wrong with this approach. In fact, it's the standard way to pass
    data around in our JavaScript components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 保存原则是关于节省计算和内存资源。这是通过使用懒加载技术来实现的。名称“懒”来源于这样的想法：我们只有在确定确实需要它时才会计算新的值。想象一个渲染页面元素的组件。我们可以向这个组件传递它需要渲染的确切数据。这意味着在组件实际需要之前会有几个计算发生。这也意味着需要将使用的数据分配到内存中，以便我们可以将其传递给组件。这种方法没有问题。事实上，这是我们JavaScript组件中传递数据的标准方式。
- en: The alternative approach uses lazy evaluation to achieve the same result. Rather
    than computing the values to be rendered, then allocating them in a structure
    to be passed, we compute one item, and then render it. Think of this as a kind
    of cooperative multi-tasking, where the larger action is broken down into smaller
    tasks that pass the focus of control back and forth.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法使用懒加载（lazy evaluation）来实现相同的结果。我们不是先计算要渲染的值，然后在结构中分配它们以传递，而是计算一个项目，然后渲染它。把这想象成一种合作多任务处理，其中较大的操作被分解成更小的任务，控制焦点在它们之间来回传递。
- en: 'Here''s an eager approach to compute data and pass it to the component that
    renders UI elements:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个急切的方法来计算数据并将其传递给渲染UI元素的组件：
- en: '![Conserve](img/B05133_01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![节省](img/B05133_01_09.jpg)'
- en: 'There''s two undesirable aspects to this approach. First, the transformation
    happens up-front, which could be a costly computation. What happens if the component
    is unable to render it for whatever reason—due to some constraint? Then we''ve
    performed this computation to transform data that wasn''t needed. As a corollary,
    we''ve allocated a new data structure for the transformed data so that we could
    pass it to our component. This transient memory structure doesn''t really serve
    any purpose, as it''s garbage-collected immediately. Let''s take a look at what
    the lazy approach might look like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个不理想的地方。首先，转换操作是在一开始就发生的，这可能会是一个昂贵的计算。如果由于某种约束，组件无法渲染它，会发生什么——比如因为某些限制？那么我们就进行了这个计算来转换不需要的数据。作为推论，我们为转换后的数据分配了一个新的数据结构，以便我们可以将其传递给我们的组件。这个短暂的内存结构实际上并没有任何作用，因为它会被立即回收。让我们看看懒惰方法可能是什么样子：
- en: '![Conserve](img/B05133_01_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![节省](img/B05133_01_10.jpg)'
- en: Using the lazy approach, we're able to remove the expensive transform computation
    that happens up-front. Instead, we transform only one item at a time. We're also
    able to remove the up-front allocation of the transformed data structure. Instead,
    only the transformed item is passed into the component. Then, the component can
    ask for another item or stop. The conserve principle uses concurrency as a means
    to only compute what's needed and only allocate memory that's needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用懒惰方法，我们能够移除一开始发生的昂贵转换计算。相反，我们一次只转换一个项目。我们也能够移除转换数据结构的提前分配。相反，只有转换后的项目被传递到组件中。然后，组件可以请求另一个项目或停止。节省原则使用并发作为仅计算所需内容并仅分配所需内存的手段。
- en: 'The following checklist will help us think about the conserve principle when
    writing concurrent code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单将帮助我们思考在编写并发代码时考虑节省原则：
- en: Are we computing values that are never used?
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否在计算永远不会使用的值？
- en: Do we only allocate data structures as a means to pass them from one component
    to the next?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否仅仅将数据结构作为传递给下一个组件的手段？
- en: Do we chain-together data transformation actions?
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否将数据转换操作链式连接起来？
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced some motivations for concurrency in JavaScript.
    While synchronous JavaScript is easy to maintain and understand, asynchronous
    JavaScript code is inevitable on the web. So it's important to make concurrency
    our default assumption when writing JavaScript applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些在JavaScript中使用并发的动机。虽然同步JavaScript易于维护和理解，但在网络上异步JavaScript代码是不可避免的。因此，在编写JavaScript应用程序时，将并发作为我们的默认假设是很重要的。
- en: There's two main types of concurrency we're interested in—asynchronous actions
    and parallel actions. Asynchronicity is about the time ordering of actions, which
    gives the impression that things are happening at the same time. Without this
    type of concurrency, the user experience would suffer greatly, because it would
    constantly be waiting on other actions to complete. Parallelism is another type
    of concurrency that solves a different type of problem, where we want to increase
    performance by computing results faster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对两种主要的并发类型感兴趣——异步操作和并行操作。异步性是关于操作的时间顺序，这给人一种事情同时发生的印象。没有这种类型的并发，用户体验会大大受损，因为用户会不断等待其他操作完成。并行性是另一种类型的并发，它解决不同类型的问题，我们希望通过更快地计算结果来提高性能。
- en: Finally, we looked at the three principles of concurrency in JavaScript programming.
    The parallelize principle is about leveraging the multi-core CPUs found in modern
    systems. The synchronize principle is about creating abstractions that enable
    us to write concurrent code, hiding the concurrency mechanisms from our feature
    code. The conserve principle uses lazy evaluation to only compute what is needed
    and to avoid unnecessary memory allocations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了JavaScript编程中的三个并发原则。并行化原则是关于利用现代系统中发现的多个核心CPU。同步原则是关于创建抽象，使我们能够编写并发代码，隐藏并发机制从我们的功能代码中。节省原则使用懒惰评估来仅计算所需内容，并避免不必要的内存分配。
- en: In the next chapter, we'll turn our attention to the JavaScript execution environment.
    To be effective with JavaScript concurrency, we need a sound understanding of
    what's actually happening when our code is run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注JavaScript执行环境。为了有效地使用JavaScript并发，我们需要了解代码运行时实际发生的事情。
