<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Best Practices"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Best Practices</h1></div></div></div><p class="calibre8">Up until now, all the coding recommendations have been interspersed with Knockout techniques as they were introduced. In order to go into more detail about these patterns and why they are useful as well as to provide a consolidated reference, we are going to review them in this chapter. As JavaScript is a very flexible language, enjoys one of the largest online developer communities, and is in use at all levels of development on the hobbyist-enterprise spectrum, it is difficult to talk about good or useful patterns without becoming opinionated. These practices should be taken as advice and shouldn't be considered dogma. Many of these recommendations are applicable to programming in general and not just Knockout development.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Best Practices">
<div class="book" title="Sticking to MVVM"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec51" class="calibre1"/>Sticking to MVVM</h1></div></div></div><p class="calibre8">Knockout was designed with the<a id="id569" class="calibre1"/> <span class="strong"><strong class="calibre9">Model-View-ViewModel</strong></span> (<span class="strong"><strong class="calibre9">MVVM</strong></span>) pattern in mind. While it is possible to develop applications using Knockout and other design patterns, sticking to MVVM will produce a natural alignment between Knockout and your own code.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Best Practices">
<div class="book" title="Sticking to MVVM">
<div class="book" title="The view and the viewmodel"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec111" class="calibre1"/>The view and the viewmodel</h2></div></div></div><p class="calibre8">The separation of concerns<a id="id570" class="calibre1"/> is the key here. Don't introduce view concepts such as DOM<a id="id571" class="calibre1"/> elements or CSS classes into your viewmodel; these <a id="id572" class="calibre1"/>belong in the HTML. Limit or avoid business logic <a id="id573" class="calibre1"/>and inline binding functions in your view; these belong as properties or functions in your viewmodel. Keeping these two separated makes it possible for the work to be divided and parallelized, allows the viewmodel to be reusable, and makes it possible to unit test the viewmodel.</p><div class="book" title="Cluttering the viewmodel"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec44" class="calibre1"/>Cluttering the viewmodel</h3></div></div></div><p class="calibre8">Animation handlers<a id="id574" class="calibre1"/> are a <a id="id575" class="calibre1"/>good example of view logic that often ends <a id="id576" class="calibre1"/>up in the viewmodel. The <code class="literal">foreach</code> binding handler has several postprocessing hooks (such as <code class="literal">afteradd</code>, <code class="literal">afterrender</code>, and <code class="literal">beforeremove</code>) that are intended to allow animations to be used. It might seem natural to use viewmodel functions, as they are specified in a binding, which normally takes viewmodel properties:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind='template: { foreach: planetsToShow,
                            beforeRemove: hidePlanetElement,
                            afterAdd: showPlanetElement }'&gt;
    &lt;div data-bind='attr: { "class": "planet " + type }, text: name'&gt;&lt;/div&gt;
&lt;/div&gt;

var PlanetsModel = function() {
    //Viewmodel properties
    this.planets = ko.observableArray();
    
    // Animation callbacks for the planets list
    this.showPlanetElement = function(elem) {
        if (elem.nodeType === 1) {
$(elem).hide().slideDown() ;
}
    }
    this.hidePlanetElement = function(elem) {
    	if (elem.nodeType === 1) {
$(elem).slideUp(function() { $(elem).remove(); });
}
    }
};</pre></div><p class="calibre8">Unfortunately, this tightly couples the viewmodel to the view and makes both the viewmodel and the animation less reusable. A better solution would be to store the animations somewhere globally accessible, such as <code class="literal">ko.animations</code>, and reference them in the binding:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind='template: { foreach: planetsToShow,
                            beforeRemove: ko.animations.slideHide,
                            afterAdd: ko.animations.slideShow }'&gt;
    &lt;div data-bind='attr: { "class": "planet " + type }, text: name'&gt;&lt;/div&gt;
&lt;/div&gt;

ko.animations = {};
ko.animations.slideShow = function(elem) {
    if (elem.nodeType === 1) {
$(elem).hide().slideDown();
}
};
ko.animations.slideHide =  function(elem) {
    if (elem.nodeType === 1) {
$(elem).slideUp(function() { $(elem).remove(); });
   }
};

var PlanetsModel = function() {
    //Viewmodel properties
    this.planets = ko.observableArray();
};</pre></div><p class="calibre8">Now, the same<a id="id577" class="calibre1"/> animations can be reused in other lists, and the <a id="id578" class="calibre1"/>viewmodel doesn't contain logic that controls the DOM.</p></div><div class="book" title="Cluttering the view"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec45" class="calibre1"/>Cluttering the view</h3></div></div></div><p class="calibre8">While keeping the <a id="id579" class="calibre1"/>viewmodel agnostic of the view tends to be very clear cut (don't reference HTML types), keeping<a id="id580" class="calibre1"/> inline code out of the view tends to merit more consideration. This is partially because logic related to the presentation might belong in the view, or at least a binding handler, and partially because there is a balancing act when many small, one-off properties are required.</p><p class="calibre8">An example of inline logic that does not belong in the view is a button-disabling expression:</p><div class="informalexample"><pre class="programlisting">&lt;button data-bind="disable: items().length &gt; 3, click: submitOrder"&gt;Submit&lt;/button&gt;</pre></div><p class="calibre8">Consider the case where this value needs to change: do you really want to hunt through the HTML for the rule that controls this? What about when this value is variable and is determined by other factors? This should absolutely be <code class="literal">canSubmit</code> (or similarly named) that is computed in the viewmodel, because the maximum number of items is business logic, which is not the view's domain.</p><p class="calibre8">A less clear-cut example is a warning display based on similar logic. Let's say disabling the button isn't enough of a visual cue, and you also want the button to turn red:</p><div class="informalexample"><pre class="programlisting">&lt;form data-bind="submit: submitOrder, css: { 'invalid-form': items().length &gt; maxItems }"&gt;
    //Irrelevant form code…
&lt;/form&gt;</pre></div><p class="calibre8">This isn't a perfect example, and you might want to add an <code class="literal">overMaxItemLimit</code> computed to your viewmodel anyway; and it does not directly express the business logic either. <span class="strong"><em class="calibre12">If the form has too many items, highlight the form</em></span> is presentation logic, and if you have enough of these one-off computed properties, which just contain a simple expression against a single observable, your viewmodel will get cluttered quickly. In cases like these, forcing the<a id="id581" class="calibre1"/> viewmodel to represent this logic might not offer any value, and you should use<a id="id582" class="calibre1"/> discretion when deciding where to put it.</p></div></div></div></div>
<div class="book" title="Using service modules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec52" class="calibre1"/>Using service modules</h1></div></div></div><p class="calibre8">Viewmodels should not<a id="id583" class="calibre1"/> contain all of your application code even in small applications. When possible, code should be broken out into non-viewmodel modules that encapsulate the work and can be reused. These modules are often called services.</p><p class="calibre8">For example, a viewmodel that gets data from the server doesn't need to know how that operation is handled, whether it uses jQuery's AJAX method, a websocket, or some other retrieval method. Putting this logic into a data service module not only makes it reusable by other viewmodels, it makes unit testing easier by limiting the scope of each object to its own work. The driving philosophy here is the single responsibility principle.</p></div>
<div class="book" title="Creating small modules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec53" class="calibre1"/>Creating small modules</h1></div></div></div><p class="calibre8">Creating smaller modules <a id="id584" class="calibre1"/>makes unit testing simpler and reduces the effort required to understand the code for others who have to read it. When deciding whether or not to add functionalities to a module or split it off into a new one, keep the single responsibility principle in mind.</p><p class="calibre8">This is a bit of a balancing act. If you have a RESTful API for your JavaScript application, then creating modules to abstract away the individual URLs by providing methods for them is a good idea. Having a single dataService module that contains all of the URLs for the whole application, though, will result in a very large module in even medium-sized applications. On the other hand, having a service module for each individual route will produce an even larger number of files. This will make unit testing and maintenance harder, it won't make it easier. The best course is to group the routes into modules by functionality. In the case of REST URLs, grouping them by resource produces a very natural organization.</p></div>
<div class="book" title="Writing unit tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec54" class="calibre1"/>Writing unit tests</h1></div></div></div><p class="calibre8">If you follow all the<a id="id585" class="calibre1"/> previous recommendations, then your code will be in a good position to be unit tested. The primary consideration while writing unit testable code is mockability: code whose external dependencies are loosely coupled. Loosely coupled dependencies can be replaced in a unit test with a fake, stub, mock, spy, or other form of replacement whose behavior can be controlled by the test. This challenge is solved by keeping DOM and binding the code out of your viewmodel, keeping the modules small and avoiding tight coupling to other viewmodels through practices such as dependency injection.</p><p class="calibre8">There are several frameworks that are available for unit testing in JavaScript, and they all offer similar benefits and workflows. The important thing is not what tools you use to unit test, only that you write unit tests. The value of unit testing really can't be overstated. It is even more important in dynamic languages such as JavaScript that do not offer compile-time checking.</p></div>
<div class="book" title="Singleton versus instance"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec55" class="calibre1"/>Singleton versus instance</h1></div></div></div><p class="calibre8">When you have a <a id="id586" class="calibre1"/>viewmodel that is actually used multiple times, such as the<a id="id587" class="calibre1"/> one backing a <code class="literal">foreach</code> loop, using an instance is the only option. When there is only one instance of the viewmodel, such as the one backing an entry form or a page in an SPA, the choice might not be as simple.</p><p class="calibre8">A good rule of thumb is to think about the lifetime of the object. If the object's lifetime doesn't end, such as the viewmodel for an ever-present navigation bar, using a singleton is appropriate. If the object's lifetime is short, such as a page viewmodel in an SPA, then using a singleton means that the object cannot be garbage collected even after it is no longer being actively used. In this situation, a disposable instance is recommended.</p><p class="calibre8">Another rule of thumb is to consider whether or not it has an internal state. Without an internal state that needs to be managed, there is little danger that multiple uses of the object or its methods will result in errors. If an object has no internal state, such as a service that abstracts AJAX requests or cookie access, a singleton is appropriate even if the object has a limited lifetime. This is not true for a viewmodel whose state is important, such as one backing an entry form; this is because with each use, it should have a fresh state. The need for a fresh state is there even if the object has a long lifetime, such as the login viewmodel in a navigation bar. Reconstructing the viewmodel after a logout will ensure that no information from a previous use remains.</p></div>
<div class="book" title="Calling ko.applyBindings once (per root)"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec56" class="calibre1"/>Calling ko.applyBindings once (per root)</h1></div></div></div><p class="calibre8">I can't tell you <a id="id588" class="calibre1"/>how many times I've come across questions on Stack Overflow regarding problems that come from developers calling <code class="literal">ko.applyBindings</code> multiple times, thinking that it is responsible for syncing the DOM and the observable data. This is more of a <span class="strong"><em class="calibre12">warning</em></span> than a <span class="strong"><em class="calibre12">best practice</em></span>, but I would feel remiss if I left it out entirely. For any given root element in your HTML, you should have one call to <code class="literal">ko.applyBindings</code> at most.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Performance concerns"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec57" class="calibre1"/>Performance concerns</h1></div></div></div><p class="calibre8">Knockout's performance<a id="id589" class="calibre1"/> has improved several times since its initial release, but it is still possible to encounter issues in apps with a large number of operations or objects. While some decrease in performance should be expected as the work being done increases, there are ways to ease the burden on the CPU.</p></div>

<div class="book" title="Performance concerns">
<div class="book" title="Observable loops"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec112" class="calibre1"/>Observable loops</h2></div></div></div><p class="calibre8">Changing observable<a id="id590" class="calibre1"/> arrays inside loops causes them to publish change notifications multiple times. The cost of these changes is proportional to the size of the array. You might need to add several items to an array and use a loop to do this:</p><div class="informalexample"><pre class="programlisting">var contacts = ko.observableArray();
for (var i = 0, j = newContacts.length; i &lt; j; i++) {
    contacts.push(new Contact(newContacts[i]);
}</pre></div><p class="calibre8">The problem here is that <code class="literal">push</code> gets called multiple times, which causes the array to send out multiple change notifications. It's much easier for the subscribers of the array if all of the changes are sent at once. This can be done by collecting all of the changes in the loop and then applying them to the observable array at the end with <code class="literal">push.apply</code>:</p><div class="informalexample"><pre class="programlisting">var contacts = ko.observableArray();
for (var i = 0, j = newContacts.length, newItems = []; i &lt; j; i++) {
    newItems.push(new Contact(newContacts[i]);
}
contacts.push.apply(contacts, newItems);</pre></div><p class="calibre8">The preceding method ensures that only a single call to <code class="literal">valueHasMutated</code> happens for the observable array. A popular solution to this common problem is to add this into a function on the <code class="literal">observableArray.fn</code> object, making it available to all observable arrays:</p><div class="informalexample"><pre class="programlisting">ko.observableArray.fn.pushAll = function (items) {
    this.push.apply(this, items);
};</pre></div><p class="calibre8">The following method can be<a id="id591" class="calibre1"/> used to add an array of items:</p><div class="informalexample"><pre class="programlisting">var contacts = ko.observableArray();
for (var i = 0, j = newContacts.length, newItems = []; i &lt; j; i++) {
    newItems.push(new Contact(newContacts[i]);
}

contacts.pushAll(newitems);</pre></div></div></div>

<div class="book" title="Performance concerns">
<div class="book" title="Limit active bindings"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec113" class="calibre1"/>Limit active bindings</h2></div></div></div><p class="calibre8">A large number<a id="id592" class="calibre1"/> of bindings, especially those that register event handlers such as value and click can quickly lead to poor browser performance. Managing this takes careful consideration about how to best reduce the number of changes that need to happen simultaneously.</p><p class="calibre8">One method is to use control flow bindings to remove bound sections that are not required. Limiting the amount of content on the screen helps performance and also has the incidental benefit of reducing the clutter that users need to parse. Techniques such as pagination can be used for more than just long lists, such as breaking up a long form or activity into several screens. Of course, this method is limited to activities that can be broken up.</p><p class="calibre8">A more broadly applicable method is to use delegated events, which are otherwise known as <a id="id593" class="calibre1"/>
<span class="strong"><strong class="calibre9">unobtrusive event handlers</strong></span>.</p></div></div>

<div class="book" title="Performance concerns">
<div class="book" title="Delegated events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec114" class="calibre1"/>Delegated events</h2></div></div></div><p class="calibre8">Unobtrusive event handlers, such <a id="id594" class="calibre1"/>as jQuery's <code class="literal">on</code>, can use a single event handler to respond to events on any number of DOM elements that are inside the registered element. This is especially useful in large or recursive lists where registering a single event handler per element would be too expensive. Knockout provides two utility methods to connect these handlers with the appropriate data from the binding context in a manner that's similar to the how Knockout's click binding provides the context as the first parameter:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">ko.dataFor</code> (element): This <a id="id595" class="calibre1"/>returns the data that is available to the element</li><li class="listitem"><code class="literal">ko.contextFor</code> (element): This <a id="id596" class="calibre1"/>returns the binding context for the element (includes binding context properties such as <code class="literal">$parent</code> and <code class="literal">$root</code>)</li></ul></div><p class="calibre8">This can be combined with a binding handler that provides the event delegation:</p><div class="informalexample"><pre class="programlisting">ko.bindingHandlers.on = {
   init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
      var options = valueAccessor();
      var handler = function() {
         options.method.call(bindingContext.$rawData, ko.dataFor(this));
      };

      $(element).on(options.event, options.selector, handler);

      ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
         $(element).off(options.event, options.selector, handler);
      });
   }
};

&lt;ul class="list-unstyled" data-bind="foreach: displayContacts, on: { event: 'click', selector: '.remove-btn', method: deleteContact }"&gt;
  &lt;li data-bind="compose: { model: $data, mode: 'templated' }"&gt;
  &lt;div data-part="btn-container" class="inline"&gt;
    &lt;button class="btn btn-sm btn-default"  data-bind="click: edit"&gt;Edit&lt;/button&gt;
    &lt;button class="btn btn-sm btn-danger remove-btn"&gt;Delete&lt;/button&gt;
  &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">The preceding <a id="id597" class="calibre1"/>example can be seen in the <code class="literal">cp7-unobtrusive</code> branch.</p><p class="calibre8">The preceding technique is not required everywhere, but when dealing with large numbers of handlers, it can lead to a noticeable impact on performance.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec58" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Again, these are guidelines and not rules, and some of them are opinions that will lead to disagreement among coworkers. Sometimes, breaking the pattern produces cleaner and clearer code and is the only way to get something working while sometimes, breaking the pattern is the only way to compromise with colleagues. If it's getting in your way without giving you any benefits, don't do it. There is no one right way to develop software.</p><p class="calibre8">The next chapter will cover some popular Knockout plugins maintained by the community.</p></div></body></html>