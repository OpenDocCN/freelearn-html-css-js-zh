<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Advanced Durandal"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Advanced Durandal</h1></div></div></div><p class="calibre8">In the previous chapter, we covered most of the basic uses of the Durandal framework. By now, you should feel comfortable starting an application with it. In this chapter, we will continue to look at Durandal by covering some more advanced framework features as well as looking at some useful patterns that will help us solve common challenges encountered in the SPA development.</p><div class="book"><ul class="itemizedlist"><li class="listitem">Publishing and subscribing with events</li><li class="listitem">Application login scenarios</li><li class="listitem">Advanced composition</li><li class="listitem">Nested routers</li><li class="listitem">Custom modal dialogs</li><li class="listitem">Binding to plain JavaScript objects</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Advanced Durandal">
<div class="book" title="Publishing and subscribing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec42" class="calibre1"/>Publishing and subscribing</h1></div></div></div><p class="calibre8">A very common<a id="id497" class="calibre1"/> problem new developers face when they start using Knockout is how to <a id="id498" class="calibre1"/>communicate between viewmodels without establishing a single hierarchy with a master viewmodel or any other form of direct reference between viewmodel objects. These kind of hard dependencies are generally considered bad practice, but the need to send messages between different viewmodels is unavoidable.</p><p class="calibre8">The publish-subscribe (pub/sub) pattern<a id="id499" class="calibre1"/> is a popular solution to this problem. Durandal offers you a simple pub/sub implementation via the <code class="literal">Events</code> module. There are two ways in which you can use the events system: with the events included on the <code class="literal">durandal/app</code> object by default or by adding events to your own objects.</p></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Advanced Durandal">
<div class="book" title="Publishing and subscribing">
<div class="book" title="The events module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec96" class="calibre1"/>The events module</h2></div></div></div><p class="calibre8">The <a id="id500" class="calibre1"/>events system includes the <code class="literal">events</code> module and the <code class="literal">subscription</code> class. The <code class="literal">events</code> module, required by <code class="literal">durandal/events</code>, provides you with the <code class="literal">includeIn</code> method to add events to an object. When <code class="literal">Events.includeIn(obj)</code> is called, the following functions are added to <code class="literal">obj</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">on</code>: This is used to subscribe to events on the object</li><li class="listitem"><code class="literal">off</code>: This is used to unsubscribe to events</li><li class="listitem"><code class="literal">trigger</code>: This is used to raise events</li><li class="listitem"><code class="literal">proxy</code>: This returns a function that can be called to raise events</li></ul></div><div class="book" title="Subscribing to events"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec40" class="calibre1"/>Subscribing to events</h3></div></div></div><p class="calibre8">The <code class="literal">on</code> method can be<a id="id501" class="calibre1"/> used in two different ways. To provide a callback and an optional context (a <code class="literal">this</code> value for the callback), pass them in as parameters. From <code class="literal">on</code>, <code class="literal">obj</code> will be returned so that chained subscriptions can be added:</p><div class="informalexample"><pre class="programlisting">obj.on('contact:added', self.contacts.push, self.contacts)
.on('contact:deleted', self.contacts.remove, self.contacts);</pre></div><p class="calibre8">To get a subscription object, provide only the event name to <code class="literal">on</code>. What is returned from <code class="literal">on</code> will be a subscription object, which provides a <code class="literal">then</code> and an <code class="literal">off</code> method. The <code class="literal">then</code> method can be used to attach a callback:</p><div class="informalexample"><pre class="programlisting">obj.on('contact:added').then(function(newContact) {
  self.contacts.push(newContact);
});</pre></div><p class="calibre8">The <code class="literal">then</code> method also returns the subscription that allows you to store the subscription reference.</p><p class="calibre8">You can subscribe to multiple events simultaneously using a space-delimited list of names for the event name parameter. You can also subscribe to all events on the object using the <code class="literal">all</code> event name.</p><div class="book" title="Unsubscribing from events"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec01" class="calibre1"/>Unsubscribing from events</h4></div></div></div><p class="calibre8">Removing a callback is done<a id="id502" class="calibre1"/> in a manner that is similar to adding callbacks, and it depends on whether you added the callback with <code class="literal">on</code> or by using <code class="literal">then</code> on a subscription.</p><p class="calibre8">If you subscribed with <code class="literal">on</code>, you can unsubscribe by calling <code class="literal">off</code> with the same event name and callback. To remove all callbacks for that event name (or names), do not provide a callback to the second parameter. To remove all callbacks with a specific context, provide a context to the third parameter:</p><div class="informalexample"><pre class="programlisting">//Remove a specific callback on an event
obj.off('contact:added', self.contacts.push);

//Remove all callbacks for a context (will remove both added and deleted from above example)
obj.off(undefined, undefined, self.contacts);

//Remove all callbacks
obj.off();</pre></div><p class="calibre8">If you used a subscription<a id="id503" class="calibre1"/> object, just call <code class="literal">off</code> on the subscription:</p><div class="informalexample"><pre class="programlisting">var subscription = obj.on('contact:added').then(self.contacts.push);
//unsubscribe
sSubscription.off();</pre></div></div></div><div class="book" title="Raising events"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec41" class="calibre1"/>Raising events</h3></div></div></div><p class="calibre8">Triggering events on an <a id="id504" class="calibre1"/>object is similar to subscribing to them. You can use a single event name, multiple space-delimited event names, or trigger all events using the special <code class="literal">all</code> event name.</p><p class="calibre8">When events are triggered, they can pass along parameters to the callbacks of subscribing events. Though triggered events can use any number of parameters, it is much easier to work with callbacks when they always use a single parameter:</p><div class="informalexample"><pre class="programlisting">obj.trigger('contact:added', newContact);
obj.trigger('contact:added contact:approved', newApprovedContact);
obj.trigger('all', superImportantEventData);</pre></div></div><div class="book" title="Proxying events"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec42" class="calibre1"/>Proxying events</h3></div></div></div><p class="calibre8">An event proxy is a <a id="id505" class="calibre1"/>method that will raise a preselected event (or a list of events), passing along its arguments as the event parameters. The following two methods are equivalent:</p><div class="informalexample"><pre class="programlisting">obj.trigger('contact:added', newContact);
//
var contactAdded = obj.proxy('contact:added');
contactAdded(newContact);</pre></div><p class="calibre8">The benefit of proxies is that they are reusable, and they can be stored or passed around. This is useful in order to share the proxy with other systems or just have a single event-raising function in several places. This practice of creating a function to represent another function with a fixed parameter is known as <a id="id506" class="calibre1"/>
<span class="strong"><strong class="calibre9">currying</strong></span>.</p><p class="calibre8">The event name of a proxy can be any string that <code class="literal">trigger</code> can use, including <code class="literal">all</code>.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Advanced Durandal">
<div class="book" title="Publishing and subscribing">
<div class="book" title="Application events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec97" class="calibre1"/>Application events</h2></div></div></div><p class="calibre8">As the <code class="literal">app</code> object is a singleton that has<a id="id507" class="calibre1"/> events included out of the box, its events are useful for application-wide messaging. Communication between independent top-level components, such as page viewmodels, is a good candidate for app-wide messaging.</p><p class="calibre8">Let's say we wanted to reduce load on the server by raising an event when a new contact was added so that the list page could get the new contact without going to the server to refresh the whole list. To stop loading the list during it's <code class="literal">activate</code> method, it will be converted into a singleton that reuses the same loading promise:</p><div class="informalexample"><pre class="programlisting">function ContactListVM() {
  // ...
  var singleActivate = dataService.getContacts()
  .then(function(contacts) {
    self.contacts(contacts);
  });

  self.activate = function() {
    return singleActivate;
  };
  //...
};

return new ContactListVM();</pre></div><p class="calibre8">As the promise that is returned to <code class="literal">activate</code> is only run once, the list will not be reloaded when the page is navigated multiple times.</p><p class="calibre8">The list page's viewmodel now needs to create an event subscription in order to receive new contacts. Durandal's convention for event names is to specify the source(s) and event type, separated by colons. This convention is recommended but not required; Durandal does not treat colons as delimiters for event names. For example, these are two events raised by the router during the navigation:</p><div class="informalexample"><pre class="programlisting">router:navigation:complete
router:navigation:cancelled</pre></div><p class="calibre8">To subscribe to an event for a new contact, the list page can use the following subscription:</p><div class="informalexample"><pre class="programlisting">app.on('contact:added').then(function(newContact) {
  self.contacts.push(newContact);
});</pre></div><p class="calibre8">However, because the only action being taken is to send the <code class="literal">newContact</code> parameter to <code class="literal">contacts.push</code>, it would be shorter to write it as a callback with a context:</p><div class="informalexample"><pre class="programlisting">app.on('contact:added', self.contacts.push, self.contacts);</pre></div><p class="calibre8">These two methods are equivalent. It should be noted that the third parameter that defines the context is necessary; otherwise, the <code class="literal">push</code> function will be called and will fail without being in the context of the contacts array.</p><p class="calibre8">The new/edit page can now publish this event using the <code class="literal">contact:added</code> event after it creates a contact:</p><div class="informalexample"><pre class="programlisting">self.saveEntry = function() {
  if (self.contact().id() === 0) {
    dataService.createContact(self.contact())
    .then(function(contact) {
      app.trigger('contact:added', contact);
    });
  } else {
    //Edit
  }
};</pre></div><p class="calibre8">This will send you the contact <a id="id508" class="calibre1"/>returned from the <code class="literal">createContact</code> promise as the data for the triggered event. However, as this is another case of sending a parameter to another single function, it can be written using a proxy:</p><div class="informalexample"><pre class="programlisting">var contactAdded = app.proxy('contact:added');
self.saveEntry = function() {
  if (self.contact().id() === 0) {
  dataService.createContact(self.contact())
    .then(contactAdded)
  } else {
    //edit
  }
};</pre></div><p class="calibre8">You can see an example of this in the <code class="literal">cp6-pubsub</code> branch.</p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Advanced Durandal">
<div class="book" title="Publishing and subscribing">
<div class="book" title="Module-scoped events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec98" class="calibre1"/>Module-scoped events</h2></div></div></div><p class="calibre8">In addition to <a id="id509" class="calibre1"/>application-wide pub/sub, Durandal provides a simple method to add the events methods to any object, allowing events to be scoped. Calling <code class="literal">Events.includeIn(obj)</code> will create the same event handling methods that the <code class="literal">app</code> object has by default: <code class="literal">on</code>, <code class="literal">off</code>, <code class="literal">trigger</code>, and <code class="literal">proxy</code>.</p><p class="calibre8">The data service is a good candidate for events related to contacts being added (or modified), as only the modules that already have a reference to it will be interested in these events. Moving the <code class="literal">contact:added</code> event out of the new/edit page into the data service also ensures that the event will still go off if another module tries to add a contact:</p><div class="informalexample"><pre class="programlisting">var dataService = {};
Events.includeIn(dataService);
//other methods omitted
dataService.createContact = function(contact) {
  contact.id(UUID.generate());
  contacts[contact.id()] = ko.toJS(contact);
  saveAllContacts();
  return getTimeoutPromise(contact).then(function() {
    dataService.trigger('contact:added', contact);
    return contact;
  });
};</pre></div><p class="calibre8">This will add the <a id="id510" class="calibre1"/>event methods to the <code class="literal">dataService</code> object and raise the <code class="literal">contact:added</code> event in the return promise for the <code class="literal">createContact</code> method.</p><p class="calibre8">The change to the list page viewmodel is just referencing the <code class="literal">dataService</code> object instead of <code class="literal">app</code> for the event subscription:</p><div class="informalexample"><pre class="programlisting">dataService.on('contact:added', self.contacts.push, self.contacts);</pre></div><p class="calibre8">That's all that needs to be done. The <code class="literal">dataService</code> object is now acting as an event scope for contacts. You can see this example in the <code class="literal">cp6-event</code> branch.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Handling logins"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Handling logins</h1></div></div></div><p class="calibre8">Handling logins can be tricky for<a id="id511" class="calibre1"/> a variety of reasons, and there are hundreds of different techniques out there. Web application login generally falls in one of two categories: either your site is free to browse without being logged in (anytime login), or it uses and requires the user to log in first (gated login). The challenges presented by each category are different, and so are the best solutions.</p></div>

<div class="book" title="Handling logins">
<div class="book" title="Gated login"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec99" class="calibre1"/>Gated login</h2></div></div></div><p class="calibre8">Until fairly recently, almost all <a id="id512" class="calibre1"/>gated login sites used some redirection pattern to present a login <a id="id513" class="calibre1"/>page to users, which was usually an unpleasant experience. Beyond the issue of page load time, getting back to the originally requested URL generally meant query string parameters that contained the original URL. If the original URL had query strings itself, they were either lost or appended to the URL query value.</p><p class="calibre8">SPAs can sidestep the redirection problem by just showing a login page at the current URL; no redirection means the whole process is faster, there is no hassle with the query string, and the user isn't jarred by the URL changing. They have a different challenge, though: what do you do with the shell? You can place the login form alongside the shell and switch between them with bindings, but this clutters the shell with login markup. You can use a modal dialog to show the login form so that the shell is untouched, but then the shell is either blank or shows information that should be login-gated.</p><p class="calibre8">Durandal's <code class="literal">setRoot</code> method <a id="id514" class="calibre1"/>really simplifies this problem. If the user needs to log in, setting<a id="id515" class="calibre1"/> the login form as the root means the shell is never even loaded. After the login finishes, the shell can then be set as the root; the shell's markup is left untouched, and the user never sees anything they shouldn't:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, our application startup in <code class="literal">main.js</code> will use <code class="literal">setRoot</code> to go to either the login or the shell, depending on whether the user is already logged in (say, from a cookie):<div class="informalexample"><pre class="programlisting">define(['durandal/system', 'durandal/app', 'common/extensions', 'services/mock'],
function(system, app, extensions, dataService) {

  ///Same as before

  app.title = 'Mastering Knockout';
  app.start().then(function () {
    app.setRoot(dataService.isLoggedIn() ? 'shell/shell' : 'login/page');
  });
});</pre></div></li><li class="listitem" value="2">This relies on the <code class="literal">dataService</code> object, performing a synchronous check  to see if <code class="literal">isLoggedIn</code> is <code class="literal">true</code>, but it can easily support an asynchronous one that's just hooking into the <code class="literal">app.start</code> promise:<div class="informalexample"><pre class="programlisting">app.start()
.then(dataService.isLoggedIn)
.then(function (isLoggedIn) {
  app.setRoot(isLoggedIn ? 'shell/shell' : 'login/page');
});</pre></div></li></ol><div class="calibre14"/></div><p class="calibre8">Once the login process is complete, the login viewmodel can just call <code class="literal">setRoot</code> for the shell. That's it! In fact, the only other properties in the login viewmodel are the ones for <code class="literal">username</code>, <code class="literal">password</code>, and a failed sign-in flag. After the login completes, the shell will start up just like it did previously, activate the router, and compose the correct page. There is no need to worry about managing an empty state while the login happens, as the shell is never loaded until <code class="literal">setRoot</code> is called on it.</p><p class="calibre8">You can see an example of this in the <code class="literal">cp6-login</code> branch. The login module contains a standard viewmodel and view. To log in, use any login details where the username and password are the same. Obviously, in a real application, you would want to create a server request.</p><p class="calibre8">One thing that is important to note is the logout function. It's in the shell in the sample, but in a real application, it should be refactored into an external service—probably the same one that holds the methods used to get and set the login cookie in order to centralize the login behaviors. In SPAs, because navigation isn't occurring, it can be a challenge to clean up all of the data a logged-in user has in the application state, especially when you have singletons. Trying to create a cleanup method that removes all of this data is prone to<a id="id516" class="calibre1"/> errors; it's easy to miss out on important bits of data, and it requires <a id="id517" class="calibre1"/>constant maintenance as the application grows. Instead, it's much safer to just reload the browser. Navigation, even if it's a refresh, completely resets the JavaScript state, guaranteeing that nothing from the previously logged-in user is left in the memory. The <code class="literal">location.reload</code> method is a simple way to do this, but it might not be the best approach if the user is on a page with a sensitive URL. A safer approach would be to set the location to the domain root:</p><div class="informalexample"><pre class="programlisting">location.href = '/';</pre></div></div></div>

<div class="book" title="Handling logins">
<div class="book" title="Anytime login"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec100" class="calibre1"/>Anytime login</h2></div></div></div><p class="calibre8">Sites that allow users to browse and <a id="id518" class="calibre1"/>optionally log in have different challenges compared to <a id="id519" class="calibre1"/>gated login sites. Some sites that allow optional login still have a separate login page and still use redirection parameters to get the user back to their original location, but this experience is even more unpleasant for the user, as it seems unnecessary. Of course, it might be required if you allow browsing over HTTP and require a redirect for HTTPS to perform the login, but this is all the more reason to always require HTTPS! If you take the redirection route to get to an HTTPS page, then even the preceding method will not work for you, as the preceding method doesn't use browser navigation to change the page.</p><p class="calibre8">If you always require HTTPS for normal browsing, then you can allow the user to log in without interfering with the current page. You can use the same technique that gated login uses, but without the need to hide post-login information, there are less intrusive methods.</p><p class="calibre8">A common method, and one of the least intrusive, is to include an inline login form in the navigation bar.</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Anytime login" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Once logged in, the navigation bar would<a id="id520" class="calibre1"/> appear the same as the previous navigation bar with the login <a id="id521" class="calibre1"/>name and the logout button. This small section of the navigation bar can be backed by a login viewmodel that is composed into the shell, which keeps the login implementation details separate:</p><div class="informalexample"><pre class="programlisting">&lt;nav role="navigation" class="collapse navbar-collapse" id="navbar-collapse-group"&gt;
  &lt;ul class="nav navbar-nav" data-bind="foreach: router.navigationModel"&gt;
    &lt;li data-bind="css: { active: isActive }"&gt;
      &lt;a class="" data-bind="attr: { href: hash }, text: title"&gt;&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class="nav navbar-nav navbar-right"&gt;
    &lt;!-- ko compose: login --&gt;&lt;!-- /ko --&gt;
  &lt;/div&gt;
&lt;/nav&gt;</pre></div><p class="calibre8">The login viewmodel doesn't need to change much for this, but the logout functionality can be moved into it as it no longer is controlled by the shell. You can see an example of this in the <code class="literal">cp6-login-nav</code> branch. Try logging in and notice how the navigation bar changes.</p><div class="book" title="Responding to the user's login changes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl4sec02" class="calibre1"/>Responding to the user's login changes</h3></div></div></div><p class="calibre8">The inline login form works, but it is <a id="id522" class="calibre1"/>likely that your application will need to respond to the newly logged-in user in some way, for example, letting only logged in users create, edit, or delete contacts. There are two ways to handle this: either use some combination of events and Knockout observables to update the page, or reload the page when the user logs in.</p><p class="calibre8">It might be simpler to take the page reload route, but it really depends on your application. If you use anytime login and allow users to see most pages without being logged in, you might not be maintaining two separate versions of each page. Instead, you might have <code class="literal">if/visible</code> bindings hiding the logged-in-only content. If that is the case, then updating these observables won't be too much effort.</p><p class="calibre8">However, if you are maintaining two separate versions of each page because they are different enough for logged-in users, the page reload method is a better bet. As the reload route doesn't take much explaining, let's look at the first case.</p><p class="calibre8">For the simple case of hiding the edit controls, Knockout observables are perfectly sufficient. The login-checking function in the data service is a good place to put observables that multiple viewmodels will depend on, as it is already a shared component. In a larger<a id="id523" class="calibre1"/> application, you might want to separate the data service into multiple services in order to serve specific roles such as login and contact CRUD:</p><div class="informalexample"><pre class="programlisting">dataService.loginName = ko.observable(storage.get('loginToken'));
dataService.isLoggedIn = ko.computed(function() {
  return dataService.loginName() != null;
});
dataService.tryLogin = function(username, password) {
  var success = username === password;
  if (success) {
    storage.set('loginToken', username);
    dataService.loginName(username);
  }

  return getTimeoutPromise(success);
};
dataService.logout = function() {
  dataService.loginName(null);
  storage.remove('loginToken');
};</pre></div><p class="calibre8">Here, <code class="literal">loginName</code> determines whether or not <code class="literal">isLoggedIn</code> is <code class="literal">true</code>. The <code class="literal">loginName</code> parameter is set initially if storage has a saved token, and it is updated when the user logs in or out. There are three places that need to use one of these fields: the list page, the list items, and the shell. The list page will use it to expose whether or not a user can edit contacts:</p><div class="informalexample"><pre class="programlisting">self.canEdit = ko.computed(function() {
  return dataService.isLoggedIn();
});</pre></div><p class="calibre8">This property is used by the list of items in order to hide or show the buttons:</p><div class="informalexample"><pre class="programlisting">&lt;!-- ko if: $parent.canEdit --&gt;
  &lt;button class="btn btn-sm btn-default" data-part="edit-btn" data-bind="click: $parent.editContact"&gt;Edit&lt;/button&gt;
  &lt;button class="btn btn-sm btn-danger" data-bind="click: $parent.deleteContact"&gt;Delete&lt;/button&gt;
&lt;!-- /ko --&gt;</pre></div><p class="calibre8">For additional safety, the methods backing these buttons should also check the <code class="literal">canEdit</code> property. The <code class="literal">delete</code> button is not shown, but it uses the same check as what is shown in the following code:</p><div class="informalexample"><pre class="programlisting">self.editContact = function(contact) {
  if (!self.canEdit()) {
    return;
  }
  router.navigate('contacts/' + contact.id());
};</pre></div><p class="calibre8">Likewise, to ensure that the user cannot get to the edit page by manually entering the URL, it should use a <code class="literal">canActivate</code> check to block navigation for anonymous users:</p><div class="informalexample"><pre class="programlisting">self.canActivate = function() {
  return dataService.isLoggedIn();
};</pre></div><p class="calibre8">Finally, the shell will <a id="id524" class="calibre1"/>want to remove the route from the navigation bar when the user is not logged in. One way to do this is to create a computed observable array on the shell that filters out routes when the user isn't logged in:</p><div class="informalexample"><pre class="programlisting">router.map([
  { route: '', moduleId: 'contacts/list', title: 'Contacts', nav: true },
  { route: 'contacts/new', moduleId: 'contacts/edit', title: 'New Contact', nav: true, auth: true },
  { route: 'contacts/:id', moduleId: 'contacts/edit', title: 'Contact Details', nav: false }
])
.buildNavigationModel()
.mapUnknownRoutes('shell/error', 'not-found');

this.navigationModel = ko.computed(function() {
  var navigationModel = router.navigationModel();
  if (dataService.isLoggedIn()) {
    return navigationModel;
  } else
  return navigationModel.filter(function(route) {
    return !route.auth;
  });
});</pre></div><p class="calibre8">This model will remove any route with an <code class="literal">auth: true</code> property when the user is not logged in, which makes it easy to add pages that require login in the future.</p><p class="calibre8">This example can be <a id="id525" class="calibre1"/>seen in the <code class="literal">cp6-login-event</code> branch. To make it easy to see the logout transition, this branch does not reload the page when the user logs out; instead, it just clears storage and updates the observables on the data service.</p></div></div></div>
<div class="book" title="Guarded routes"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Guarded routes</h1></div></div></div><p class="calibre8">In the previous section, we <a id="id526" class="calibre1"/>used a <code class="literal">canActivate</code> check on a page viewmodel to ensure that users could only get to the page when they were logged in. This works, but if multiple pages need to be gated, or we need to use logic that the page might not have, it is possible to add this logic to the router.</p><p class="calibre8">The <code class="literal">guardRoute</code> method is an optional method that the router will use to screen every attempted navigation. It receives the module being activated and the route instruction as parameters. If <code class="literal">true</code>, or a promise for true, is returned from <code class="literal">guardRoute</code>, then navigation continues normally. If a string or a promise for a string is returned, it will be used as a redirection route. If <code class="literal">false</code> or a promise for false is returned, then navigation is cancelled:</p><div class="informalexample"><pre class="programlisting">router.guardRoute = function(model, instruction) {
  return !(instruction.config.auth &amp;&amp; !dataService.isLoggedIn());
};</pre></div><p class="calibre8">This router guard can replace the <code class="literal">canActivate</code> method on the edit page, as it will cancel navigation when the route has <code class="literal">auth:true</code> and the user is not logged in. However, canceling navigation can sometimes appear to users as the application not responding, such as when the back button is pressed. It can be improved by redirecting the current page to the error page instead:</p><div class="informalexample"><pre class="programlisting">router.guardRoute = function(model, instruction) {
  return !(instruction.config.auth &amp;&amp; !dataService.isLoggedIn()) || 'shell/error';
};</pre></div><p class="calibre8">This example can be seen in the <code class="literal">cp6-guard-route</code> branch.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Advanced composition"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Advanced composition</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 5. Durandal – the Knockout Framework" href="part0041_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre12">Durandal – the Knockout Framework</em></span>, we covered the basic and common uses of Durandal's composition<a id="id527" class="calibre1"/> system. This section will cover further composition techniques such as caching, transitions, and composition mode.</p></div>

<div class="book" title="Advanced composition">
<div class="book" title="View caching"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec101" class="calibre1"/>View caching</h2></div></div></div><p class="calibre8">By default, the view rendered by<a id="id528" class="calibre1"/> the composition binding is discarded<a id="id529" class="calibre1"/> when the composed module is changed. This results in the DOM contents of the composition binding always being only the current module's view. The <code class="literal">cacheView</code> option on the composed binding will change this behavior so that Durandal can keep any view composed. If a module is reactivated using the same object that is already bound to a view, it will not be recreated. Both the <code class="literal">compose</code> and <code class="literal">router</code> bindings have this option:</p><div class="informalexample"><pre class="programlisting">&lt;div class="page-host"&gt;
  &lt;!-- ko router: { cacheViews: false }--&gt; &lt;!-- /ko --&gt;
&lt;/div&gt;</pre></div><p class="calibre8">You can see an example of this in the <code class="literal">cp6-cache</code> branch. If you open the console, you can see that the attaching and binding events are no longer being raised when revisiting the list or edit pages. You can also see, with a debugger breakpoint, that the viewmodels are only being constructed the first time.</p><p class="calibre8">When working with cached views, extra caution is required. As the module is a singleton and is only constructed once, the <code class="literal">activate</code> method is responsible for setting up data or clearing old data out. For example, previously, the edit page only set its <code class="literal">contact</code> property to a new instance during the construction. The <code class="literal">activate</code> method needs to reset the contact if the page is being loaded in a new entry mode (without an ID):</p><div class="informalexample"><pre class="programlisting">self.activate = function(id) {
  //Id is only present when editing
  if (id) {
    return dataService.getContact(id).then(self.contact);
  }
  else
  self.contact(new Contact());
};</pre></div><p class="calibre8">If this isn't done, users will not see an empty form if they tried to create a contact after creating or editing a previous one.</p><p class="calibre8">Even if the <code class="literal">cacheViews</code> property is set to <code class="literal">true</code>, Durandal will not cache a DOM view if the model instance has changed. In the <code class="literal">cp6-cache2</code> branch, the constructor is returned from the list page, and you can see that a new instance is constructed and attached to the DOM despite <code class="literal">cacheViews</code> being set.</p></div></div>

<div class="book" title="Advanced composition">
<div class="book" title="Transitions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec102" class="calibre1"/>Transitions</h2></div></div></div><p class="calibre8">Durandal's <code class="literal">router</code> and <code class="literal">compose</code> bindings<a id="id530" class="calibre1"/> have a hook that allows the composed <a id="id531" class="calibre1"/>view to transition with an animation. To use it, provide a value to the <code class="literal">transition</code> property on the binding:</p><div class="informalexample"><pre class="programlisting">&lt;!-- ko router: { 
  cacheViews: false, 
  transition: 'entrance' 
}--&gt; &lt;!-- /ko --&gt;</pre></div><p class="calibre8">The <code class="literal">entrance</code> transition is provided by default; it fades the current view out and fades in the next view with a small slide effect. You can see it in the <code class="literal">cp6-entrance</code> branch. Note that for this animation to work, the composition needs to occur in an element with the CSS <code class="literal">position: relative</code> property, as the animation uses absolute positioning.</p><p class="calibre8">The <code class="literal">durandal/composition</code> module also has a <code class="literal">defaultTransitionName</code> property that will use the supplied transition for all compositions that do not specify their own transitions.</p><p class="calibre8">To create your own transition, you need a module that returns a function that Durandal can call in order to run the transition. The transition function will receive the composition settings and needs to return a promise for its completion. There are a lot of values on the settings object but the two that are most useful are <code class="literal">activeView</code>, which is the view being transition out, and <code class="literal">child</code>, which is the view being transitioned to.</p><p class="calibre8">Here is an example of a <a id="id532" class="calibre1"/>custom transition that uses the jQuery UI's slide <a id="id533" class="calibre1"/>effects. It assumes that jQueryUI has already been set up in RequireJS:</p><div class="informalexample"><pre class="programlisting">define(['durandal/system', 'jquery', 'jquery-ui'], function(system, $) {

  var outDuration = 400,
  outDirection = 'down'
  inDuration = 400,
  inDirection = 'up',
  easing = 'swing';

  return function slideAnimation(settings) {

    var currentView = settings.activeView,
    newView = settings.child;

    return system.defer(function(defer) {
      function endTransition() {
        defer.resolve();
      }

      function slideIn() {
        $(newView).show('slide', { direction: inDirection, easing: easing }, inDuration, endTransition);
      }

      if (currentView) {
        $(currentView).hide('slide', { direction: outDirection, easing: easing }, outDuration, newView ? slideIn : endTransition);
      } else {
        $(newView).show();
        endTransition();
      }

    }).promise();
  };
});</pre></div><p class="calibre8">The module returns the <a id="id534" class="calibre1"/>animation function, which itself returns a promise<a id="id535" class="calibre1"/> for the animation. The animation function pulls out the current and next view and then sets up callbacks in order to end the view and slide in the new view with jQuery. The <code class="literal">if</code> block at the end ensures that the current view is only acted upon when it exists. If it doesn't, then no animation is created (as there is nothing to slide out), and the view is just shown.</p><p class="calibre8">By default, Durandal looks for transitions by appending <code class="literal">'transitions/'</code> to their name in order to get a RequireJS path. This is why the standard Durandal RequireJS configuration has a transitions path defined. You can map the path in RequireJS to another folder if you want to keep transitions somewhere else—such as your <code class="literal">app</code> folder—or you can override the composition module's <code class="literal">convertTransitionToModuleId</code> function to provide your own lookup logic.</p><p class="calibre8">This example can be seen in the <code class="literal">cp6-transition</code> branch. This branch uses a RequireJS path for a <code class="literal">transitions</code> folder in the <code class="literal">app</code> directory, which contains the preceding slide animation.</p></div></div>

<div class="book" title="Advanced composition">
<div class="book" title="The templated mode"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec103" class="calibre1"/>The templated mode</h2></div></div></div><p class="calibre8">In the previous <a id="id536" class="calibre1"/>chapter, we covered<a id="id537" class="calibre1"/> widgets, which offer us the ability to override sections of the composed element with <code class="literal">data-part</code> attributes. This feature is also available in viewmodel composition using the binding <code class="literal">mode: 'templated'</code> option.</p><p class="calibre8">The example widget that was used was a bit contrived, as the list of contacts isn't really a reusable widget. A more common technique with lists, especially with complex items, is to create a module for the list item and compose it with a <code class="literal">foreach</code> binding.</p><p class="calibre8">Separating complex list items from the page they are shown in keeps properties and methods specific to the list item that is not on the page. This is the same modularization logic that drives the separation of viewmodels and modules. It lets the page viewmodel focus more on the actions the page takes as a whole and lets the item focus on itself. The contact list items aren't complex enough to warrant this, but I'm sure you can imagine such a case.</p><p class="calibre8">Replacing the contact list widget with a <code class="literal">compose/foreach</code> binding is simple:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="list-unstyled" data-bind="foreach: displayContacts"&gt;
  &lt;li data-bind="compose: $data"&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">This allows the item itself to be moved into its own file, which is <code class="literal">listItem.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h3 data-bind="with: contact"&gt;
  &lt;span data-bind="text: displayName"&gt;&lt;/span&gt;
  &lt;small data-bind="text: phoneNumber" data-part="phone"&gt;&lt;/small&gt;
  &lt;div class="inline" data-part="btn-container"&gt;"
    &lt;button class="btn btn-sm btn-default" data-part="edit-btn" data-bind="click: edit"&gt;Edit&lt;/button&gt;
  &lt;/div&gt;
&lt;/h3&gt;</pre></div><p class="calibre8">This is the same template that <a id="id538" class="calibre1"/>was used previously, minus the delete <a id="id539" class="calibre1"/>button. The viewmodel for the list item is simple, containing just a <code class="literal">contact </code>object and an <code class="literal">edit</code> function:</p><div class="informalexample"><pre class="programlisting">define(['knockout', 'plugins/router'], function(ko, router) {
  return function ListItem(contact) {
    var self = this;

    self.contact = contact;

    self.edit = function() {
      router.navigate('contacts/' + self.contact.id());
   };
  };
});</pre></div><p class="calibre8">The last thing to do is construct the list item on the list page instead of just using the bare contact model:</p><div class="informalexample"><pre class="programlisting">self.activate = function() {
  return dataService.getContacts()
  .then(function(contacts) {
    var listItems = contacts.map(function(contact) {
      return new ListItem(contact);
    })
    self.contacts(listItems);
  });;
};</pre></div><p class="calibre8">You can see this example in the <code class="literal">cp6-list-item</code> branch. This is just the setup, though; what we are really after is overriding the list item view with <code class="literal">data-part</code> attributes. Data-part overriding works the same way with compositions as it works with widgets:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="list-unstyled" data-bind="foreach: displayContacts"&gt;
  &lt;li data-bind="compose: { model: $data, mode: 'templated' }"&gt;
    &lt;div data-part="btn-container" class="inline"&gt;
      &lt;button class="btn btn-sm btn-default" data-bind="click: edit"&gt;Edit&lt;/button&gt;
      &lt;button data-bind="click: $root.deleteContact" class="btn btn-sm btn-danger"&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">Here, the entire <code class="literal">btn-container</code> element is being <a id="id540" class="calibre1"/>overridden so that a delete button can be <a id="id541" class="calibre1"/>added. Remember, the scope of <code class="literal">data-part</code> attributes is the view they will be placed into, which is <code class="literal">listItem</code> in this case. The <code class="literal">edit</code> function is already in this scope, but the <code class="literal">deleteContact</code> function is in the parent of <code class="literal">listItem</code>, which can be accessed using the <code class="literal">$root</code> property of the templated elements.</p><p class="calibre8">This example can be seen in the <code class="literal">cp6-template-compose</code> branch.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Child routers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Child routers</h1></div></div></div><p class="calibre8">Another common scenario is the <a id="id542" class="calibre1"/>need to support routes within routes; this is sometimes called <span class="strong"><strong class="calibre9">nested</strong></span>
<a id="id543" class="calibre1"/> or<a id="id544" class="calibre1"/> <span class="strong"><strong class="calibre9">child</strong></span> routes. For example, you might have multiple pages under the parent <code class="literal">/about</code> route that are represented by the <code class="literal">/about/author</code> and <code class="literal">/about/publisher</code> URLs, which are displayed as different subsections of the main <code class="literal">/about</code> page.</p><p class="calibre8">To do this, the parent route has to capture child routes. It can do this with a splat route or with the <code class="literal">hasChildRoutes</code> property:</p><div class="informalexample"><pre class="programlisting">router.map([
  { route: 'about', moduleId: 'about/index', title: 'About', nav: true, hasChildRoutes: true }
  //OR
  { route: 'about*children', moduleId: 'about/index', title: 'About', nav: true }
]);</pre></div><p class="calibre8">Either way is fine, but note that the <code class="literal">about*children</code> splat route requires at least one character after the asterisk (<code class="literal">*</code>); the <code class="literal">about*</code> route will not capture the children properly. Personally, I think the <code class="literal">hasChildRoutes</code> property has a clearer intention.</p><p class="calibre8">Next, the viewmodel that exposes child routes creates a child router:</p><div class="informalexample"><pre class="programlisting">define(['plugins/router'], function(router) {
  var childRouter = router.createChildRouter()
  .makeRelative({
    moduleId: 'about',
    fromParent: true
  }).map([
  { route: ['author', ''], moduleId: 'author', title: 'Author', nav: true },
  { route: 'publisher', moduleId: 'publisher', title: 'Publisher', nav: true }
  ]).buildNavigationModel();

  return {
    router:childRouter
  };
});</pre></div><p class="calibre8">The <code class="literal">createChildRouter</code> function returns the child router of the root router. You can only have one root router, but it can have any number of children, and children routers can have children routers as well.</p><p class="calibre8">The <code class="literal">makeRelative</code> function takes an<a id="id545" class="calibre1"/> optional object. The <code class="literal">moduleId</code> option instructs all the modules of children routes to be prefixed with the supplied module, essentially making the routes relative to a folder. This is not required, but it keeps the routes shorter. The <code class="literal">fromParent</code> option causes children routes to inherit their parent's URL from the <code class="literal">route</code> property.</p><p class="calibre8">Finally, the module exposes <code class="literal">childRouter</code> as the router so that its view can bind to it using the same syntax that was used by the shell. This is the view for the <code class="literal">about</code> parent page:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;About&lt;/h1&gt;
//Text removed for clarity
&lt;ul class="nav nav-tabs" role="tablist" data-bind="foreach: router.navigationModel"&gt;
  &lt;li data-bind="css: { active: isActive }"&gt;
    &lt;a class="" data-bind="attr: { href: hash }, text: title"&gt;&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="page-sub-host"&gt;
  &lt;!-- ko router: { cacheViews: false }--&gt; &lt;!-- /ko --&gt;
&lt;/div&gt;</pre></div><p class="calibre8">This example can be seen in the <code class="literal">cp6-child-router</code> branch. The about page and its child routes are in the <code class="literal">app/about</code> folder, and the route has been added to the navigation bar.</p></div>

<div class="book" title="Child routers">
<div class="book" title="Dynamic child routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec104" class="calibre1"/>Dynamic child routes</h2></div></div></div><p class="calibre8">When creating child <a id="id546" class="calibre1"/>routes for a parent route with a parameter, such as <code class="literal">/contacts/23/bio</code>, additional configuration is required in order to allow the child routes to be<a id="id547" class="calibre1"/> relative to the <code class="literal">/contacts/:id</code> dynamic parent. To see an example of this, we are going to add a biography and location section to our contact pages.</p><p class="calibre8">The contact edit route needs to indicate that it has child routes. The same options are available, but there is a caveat for splat routes—you must specify a <code class="literal">hash</code> manually:</p><div class="informalexample"><pre class="programlisting">{ route: 'contacts/:id', moduleId: 'contacts/edit', title: 'Contact Details', nav: false, hasChildRoutes: true },
//OR
{ route: 'contacts/:id*children', moduleId: 'contacts/edit', title: 'Contact Details', nav: false, hash: 'contacts/:id' },</pre></div><p class="calibre8">The children routers will not be able to create a proper URL from a splat route if the hash is not specified manually. This does not need to be done if you're using the <code class="literal">hasChildRoutes</code> flag.</p><p class="calibre8">The child router definition is almost identical, except for the <code class="literal">dynamicHash</code> property:</p><div class="informalexample"><pre class="programlisting">var childRouter = router.createChildRouter()
.makeRelative({
  moduleId: 'contacts/edit',
  fromParent: true,
  dynamicHash: ':id'
}).map([
  { route: ['details', ''], moduleId: 'details', title: 'Details', nav: true },
  { route: 'bio', moduleId: 'bio', title: 'Biography', nav: true },
  { route: 'location', moduleId: 'location', title: 'Location', nav: true }
]).buildNavigationModel();</pre></div><p class="calibre8">The <code class="literal">dynamicHash</code> property controls how the URLs for child routes are created, as they need to include the <code class="literal">route</code> parameter. That's all it takes, though! After this, the routes can be used on the parameterized URL.</p><p class="calibre8">You can see an example<a id="id548" class="calibre1"/> of this in the <code class="literal">cp6-dynamic-child-routes</code> branch. The<a id="id549" class="calibre1"/> edit page's child routes have been placed for organization in the <code class="literal">contacts/edit</code> folder. Also, the biography and location pages just contain dummy text.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Custom modal dialogs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec47" class="calibre1"/>Custom modal dialogs</h1></div></div></div><p class="calibre8">In Durandal, a dialog context<a id="id550" class="calibre1"/> is the viewmodel that controls a modal dialog. It has a method used to add the modal dialog host, which is the DOM node inside which the modal content will be placed.</p><p class="calibre8">Durandal offers two modal dialogs out of the box: message boxes and the default context. The message box that Durandal offers adds some simple DOM elements to the default context and is very useful in order to show short messages to the user. The default dialog context can host any composable module, including message boxes. If you want to use your own dialog box, such as the one included in Twitter Bootstrap, it is possible to add it as a dialog context.</p><p class="calibre8">A dialog context is an object that can create a dialog in the DOM to which the composition can add content. A custom context uses the following APIs:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">addHost(dialog)</code>: This <a id="id551" class="calibre1"/>function is responsible for creating the dialog itself, by adding it to the DOM. It must assign the <code class="literal">dialog.host</code> property on the parameter to this DOM node, which will be used by composition as the parent for the composing module.</li><li class="listitem"><code class="literal">removeHost(dialog)</code>: This<a id="id552" class="calibre1"/> function removes the DOM for the dialog and performs any cleanup.</li><li class="listitem"><code class="literal">compositionComplete(child, parent, context)</code>: This is a composition hook that the context can use <a id="id553" class="calibre1"/>to perform any setup. To get the <code class="literal">dialog</code> object (the parameter from the other two functions), call <code class="literal">dialog.getDialog(context.model)</code>.</li></ul></div><p class="calibre8">Custom dialog contexts are useful when you have different needs for modal windows. The Twitter Bootstrap dialog, for example, uses the same responsive CSS system that the rest of the Bootstrap framework uses, making it perfect for dialogs that need to be usable on desktops and phones. You might also want some of your dialogs to be displayed in a circular pop up in order to differentiate them from other modals your application is using.</p><p class="calibre8">Working with custom dialogs is done using the <code class="literal">dialog</code> module, which is injected using <code class="literal">'plugins/dialog'</code>. You can add a custom dialog context with the <code class="literal">dialog.addContext</code> function, which takes a context that matches the preceding API. The first parameter is the name of the new context, and the second is the context object:</p><div class="informalexample"><pre class="programlisting">dialog.addContext('bootstrap', {
  addHost: function (dialogInstance) {
    //Create dialog, add to DOM
  },
  removeHost: function (dialogInstance) {
    //Remove dialog from DOM
  },
  compositionComplete: function (child, parent, context) {
    //Perform setup
  }
});</pre></div><p class="calibre8">This setup needs to be done <a id="id554" class="calibre1"/>before the dialog can be used, so it is good to do it with any app setup. In the upcoming example, this will be in the <code class="literal">common/extensions</code> module.</p><p class="calibre8">The actual setup logic for each of the context methods depends on the dialog you are adding. This is what the Bootstrap modal setup will look like:</p><div class="informalexample"><pre class="programlisting">addHost: function (dialogInstance) {
  var body = $('body'),
  host = $('&lt;div class="modal fade"&gt;&lt;div class="modal-dialog"&gt;&lt;div class="modal-content"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;');
  host.appendTo(body);
  dialogInstance.host = host.find('.modal-content').get(0);
  dialogInstance.modalHost = host;
}</pre></div><p class="calibre8">Unlike the Durandal modal, where the content container and the dialog element are the same, the Bootstrap modal expects the content container to be inside the dialog element. The content's DOM element is placed in the <code class="literal">dialogInstance.host</code> property, which Durandal will use to compose the module. The outer modal element is stored in the <code class="literal">modalHost</code> property, which will only be used by functions on our custom Bootstrap context:</p><div class="informalexample"><pre class="programlisting">compositionComplete: function (child, parent, context) {
  var dialogInstance = dialog.getDialog(context.model),
  $child = $(child);
  $(dialogInstance.modalHost).modal({ backdrop: 'static', keyboard: false, show: true });

  //Setting a short timeout is need in IE8, otherwise we could do this straight away
  setTimeout(function () {
    $child.find('.autofocus').first().focus();
  }, 1);

  if ($child.hasClass('autoclose') || context.model.autoclose) {
    $(dialogInstance.blockout).click(function () {
      dialogInstance.close();
    });
  }
}</pre></div><p class="calibre8">This is where the actual <a id="id555" class="calibre1"/>Bootstrap <code class="literal">$.modal()</code> code is run from, as the sizing and placement of the modal will need to have a fully composed module that already exists. It uses the <code class="literal">modalHost</code> property and not the <code class="literal">host</code> property, as Bootstrap is expecting the modal container. Additionally, the handler is set up to support the standard Durandal autofocus and autoclose classes:</p><div class="informalexample"><pre class="programlisting">removeHost: function (dialogInstance) {
  $(dialogInstance.modalHost).modal('hide');''''''
}</pre></div><p class="calibre8">The <code class="literal">removeHost</code> function takes the steps that are required to hide the modal and the backdrop.</p><p class="calibre8">Finally, we use this new modal by specifying the context parameter on <code class="literal">dialog.show</code> in the edit contact viewmodel:</p><div class="informalexample"><pre class="programlisting">self.show = function() {
  return dialog.show(self, null, ''bootstrap'');
};</pre></div><p class="calibre8">If you look in the <code class="literal">cp6-bootstrap-dialog</code> branch, this context will be added. The modal dialog from <a class="calibre1" title="Chapter 5. Durandal – the Knockout Framework" href="part0041_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre12">Durandal – the Knockout Framework</em></span>, that opens when the <span class="strong"><strong class="calibre9">Add Contact</strong></span> button on the list page is pressed has been restored. You can see that this new dialog has the Bootstrap sliding entrance animation, and the content is responsive.</p><p class="calibre8">There is another method that can be used to show custom dialogs. The <code class="literal">addContext</code> method automatically creates a helper method using the context name. For the Bootstrap context, the method is <code class="literal">dialog.showBootrap</code>:</p><div class="informalexample"><pre class="programlisting">self.show = function() {
  return dialog.showBootstrap(self);
};</pre></div><p class="calibre8">You can see this example in the <code class="literal">cp6-bootstrap-dialog2</code> branch.</p></div>

<div class="book" title="Custom modal dialogs">
<div class="book" title="Replacing the default context"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec105" class="calibre1"/>Replacing the default context</h2></div></div></div><p class="calibre8">Having multiple dialog<a id="id556" class="calibre1"/> contexts is certainly useful, but if you are adding a custom dialog context, chances are you want it to be the default dialog context. Having a Bootstrap modal dialog is great, but the standard message boxes are still using the nonresponse Durandal context. To change this, just replace the <code class="literal">dialog.show</code> method with one that specifies your context when one isn't explicitly provided:</p><div class="informalexample"><pre class="programlisting">var oldShow = dialog.show;
dialog.show = function(obj, data, context) {
  return oldShow.call(dialog, obj, data, context || 'bootstrap');
};</pre></div><p class="calibre8">This will cause all regular calls to the dialog module to use this context without affecting the ability of the code to manually control which dialog context is used for special scenarios:</p><div class="informalexample"><pre class="programlisting">//Shows using the Bootstrap dialog
app.showMessage('Are you sure you want to delete ' + contact.displayName() + '?', 'Delete Contact?', ['No', 'Yes']);
//Shows using the Bootstrap dialog
self.show = function() {
  return dialog.show(self);
};
//Uses the bubble context, equivalent to calling dialog.showBubble();
self.show = function() {
  return dialog.show(self, null, 'bubble');
};</pre></div><p class="calibre8">In the <code class="literal">cp6-bootstrap-dailog3</code> branch, you can see that the delete confirmation message box as well as the add contact modal uses the Bootstrap dialog context.</p><p class="calibre8">If you still need access to the default context, consider adding a conventional helper to the dialog object, such as <code class="literal">dialog.showDefault</code> or <code class="literal">dialog.showOld</code>:</p><div class="informalexample"><pre class="programlisting">var oldShow = dialog.show;
dialog.show = function(obj, data, context) {
  return oldShow.call(dialog, obj, data, context || 'bootstrap');
};
dialog.showDefault = oldShow;</pre></div></div></div>
<div class="book" title="Using activators"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec48" class="calibre1"/>Using activators</h1></div></div></div><p class="calibre8">The activation<a id="id557" class="calibre1"/> life cycle is automatically used by the router, but sometimes, you want to use it without tying the work to the URL, which turns out to be quite easy. An activator is just a computed observable whose write function enforces the life cycle. An activator can be created by calling <code class="literal">activator.create()</code> using the <code class="literal">durandal/activator</code> module.</p><p class="calibre8">For this example, we are going to add an inline <span class="strong"><em class="calibre12">quick edit</em></span> to the list page that will allow contacts to be edited without navigating to another page. It will leverage the existing edit page viewmodel with some minor changes, as it already has a <code class="literal">canDeactivate</code> method that prompts the user with a confirmation modal when unsaved changes are present. The list page activator will hook into the same logic automatically.</p><p class="calibre8">This example is in the <code class="literal">cp6-activator</code> branch. You might want to play with it a bit before we go into how it works. Just use the quick edit button on the list page, and the contact will be loaded into an edit form just below the search box.</p><p class="calibre8">The list page needs an activator and a function to set the activator:</p><div class="informalexample"><pre class="programlisting">self.editContact = activator.create();
self.quickEdit = function(listItem) {
  self.editContact(new ContactVM(listItem.contact, function() {
    self.editContact(null);
  }));
};</pre></div><p class="calibre8">The <code class="literal">quickEdit</code> function, which will be bound to a button on the list item, sets the <code class="literal">editContact</code> activator to a new instance of the edit page viewmodel. It provides the contact-to-edit to the new viewmodel and a callback to clear the <code class="literal">editContact</code> object. The HTML just needs a button to call it:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="list-unstyled" data-bind="foreach: displayContacts"&gt;
  &lt;li data-bind="compose: { model: $data, mode: 'templated' }"&gt;
    &lt;div data-part="btn-container" class="inline"&gt;
      &lt;button class="btn btn-sm btn-default" data-bind="click: edit"&gt;Edit&lt;/button&gt;
      &lt;button class="btn btn-sm btn-default" data-bind="click: $root.quickEdit"&gt;Quick Edit&lt;/button&gt;
      &lt;button data-bind="click: $root.deleteContact" class="btn btn-sm btn-danger"&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;/ul&gt;</pre></div><p class="calibre8">To use this, the edit page viewmodel will need to call the close callback—the second constructor parameter—when saving or canceling in a manner that is similar to how it handled closing the dialog:</p><div class="informalexample"><pre class="programlisting">function EditContactVm(initContact, closeCallback) {

  ///...

  self.close = function(result) {
    if (closeCallback) {
      closeCallback();
    } else if (dialog.getDialog(self)) {
      dialog.close(self, result);
    } else {
      router.navigate('''');
    }
  };</pre></div><p class="calibre8">Actually, this is all we<a id="id558" class="calibre1"/> need in order to take advantage of the deactivation guard, which is already on the edit viewmodel. There is some additional logic that handles saving changes, but it isn't strictly related to the activator use. If you try to use quick edit, make some changes, hit <span class="strong"><strong class="calibre9">Cancel</strong></span>, and you will be prompted. If you hit <span class="strong"><strong class="calibre9">No</strong></span>, the item will not be deactivated. You will also be prompted if you try to use a different quick edit while unsaved changes are present. All of this guard logic is handled for you by virtue of <code class="literal">editContact</code> being an activator observable.</p><p class="calibre8">In addition to being writeable with the normal observable pattern by calling <code class="literal">editContact(newValue)</code>, activators have an <code class="literal">activateItem</code> method. The first parameter to <code class="literal">activateItem</code> is <code class="literal">newValue</code>, and the second option is <code class="literal">activationData</code>, which allows you to send a property bag to the <code class="literal">activate</code> method of the new value being set. This will be used as <code class="literal">editContact.activateItem(newValue, data)</code>.</p><p class="calibre8">This example, more than most examples in this book, is extremely contrived for the sake of brevity. Overloading the edit page viewmodel so that it is internally aware of being used in three different contexts is not a good design, and is not recommended for real-world use.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Binding to plain JavaScript objects"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec49" class="calibre1"/>Binding to plain JavaScript objects</h1></div></div></div><p class="calibre8">The last part of <a id="id559" class="calibre1"/>Durandal that we are going to cover is the observable plugin, which <a id="id560" class="calibre1"/>allows data binding to use normal viewmodel properties as observable objects by converting them under the hood.</p><p class="calibre8">The observable plugin uses JavaScript getters and setters created with <code class="literal">defineProperty</code>, which is part of the ECMAScript 5 specification. Only modern browsers support this feature, so if your application needs to work in Internet Explorer 8, the observable plugin will not work.</p><p class="calibre8">Using the observable plugin removes one of the most common complaints from Knockout's syntax: the parentheses. All of the property access is executed using plain syntax, whether reading or assigning values:</p><div class="informalexample"><pre class="programlisting">function Contact() {
  var self = this;
  self.firstName = '';
  self.lastName = '';
  self.reset = function() {
    self.firstName = '';
    self.lastName = ''
  };
};

var viewmodel = new Contact();

//HTML
&lt;input data-bind="value: firstName" /&gt;
&lt;input data-bind="value: lastName" /&gt;
&lt;button data-bind="click: reset"&gt;Reset&lt;/button&gt;</pre></div><p class="calibre8">Everything is <a id="id561" class="calibre1"/>converted into observables by the observable plugin during data binding. Knockout observables can still be created with <code class="literal">ko.observable</code>, but it should not be necessary.</p><p class="calibre8">This does have an impact on all of your code, though, as using the parentheses to access properties will no longer work; they are not functions anymore! Using the observable plugin means a total conversion of your application code.</p></div>

<div class="book" title="Binding to plain JavaScript objects">
<div class="book" title="Observable plugin setup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec106" class="calibre1"/>Observable plugin setup</h2></div></div></div><p class="calibre8">Using the observable plugin, like <a id="id562" class="calibre1"/>any plugin, requires it to be installed before the <code class="literal">app.start</code> call:</p><div class="informalexample"><pre class="programlisting">app.configurePlugins({
  router:true,
  dialog: true,
  observable: true
});
app.start().then(function () {
  app.setRoot('shell/shell');
});</pre></div><p class="calibre8">If you need to use the plugin manually, it is required into a module with <code class="literal">plugins/observable</code>.</p></div></div>

<div class="book" title="Binding to plain JavaScript objects">
<div class="book" title="Subscribing and extending"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec107" class="calibre1"/>Subscribing and extending</h2></div></div></div><p class="calibre8">When you are no longer creating observables manually, you will have to use the observable plugin to get access to the underlying observable to set up subscriptions<a id="id563" class="calibre1"/> or add <a id="id564" class="calibre1"/>extenders. This can be done by calling the observable module as a function with <code class="literal">observable(object, 'property')</code>. The observable module is injected with <code class="literal">'plugins/observable'</code>:</p><div class="informalexample"><pre class="programlisting">function Contact() {
  //Same as before

  observable(self, 'firstName').subscribe(function(value){
    console.log('First name changed.');
  });

  observable(self, 'firstName').extend({
    rateLimit: {
      timeout: 100,
      method: 'notifyWhenChangesStop'
    }
  });
};</pre></div><p class="calibre8">This can be done at any time, even if the property hasn't yet been converted into an observable, as calling the observable module will convert the property immediately.</p></div></div>

<div class="book" title="Binding to plain JavaScript objects">
<div class="book" title="Computed observables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec108" class="calibre1"/>Computed observables</h2></div></div></div><p class="calibre8">Computed observables are <a id="id565" class="calibre1"/>created using <code class="literal">observable.defineProperty</code>:</p><div class="informalexample"><pre class="programlisting">observable.defineProperty(self, 'displayName', function() {
  var nickname = self.nickname || '';
  if (nickname.length &gt; 0) {
    return nickname;
  } else if ((self.firstName || '').length &gt; 0) {
    return self.firstName + ' ' + self.lastName;
  } else {
    return 'New Contact';
  }
});</pre></div><p class="calibre8">The <code class="literal">defineProperty</code> method also returns the underlying computed observables so that it can be extended or subscribed to.</p><p class="calibre8">There is a caveat with computed observables, though. If anything tries to access the computed value before its dependencies have been converted into observables, then the computed value will not be able to register these dependencies; its value will never update:</p><div class="informalexample"><pre class="programlisting">return function Contact(init) {
  var self = this;

  self.id = 0;
  self.firstName = '';
  self.lastName = '';
  self.nickname = '';
  self.phoneNumber = '';

  observable.defineProperty(self, 'displayName', function() {
    var nickname = self.nickname || '';
    if (nickname.length &gt; 0)
    return nickname;
    else if ((self.firstName || '').length &gt; 0)
    return self.firstName + ' ' + self.lastName;
    else
    return 'New Contact';
  });

  //This will break the display name property
  var name = self.displayName;
}</pre></div><p class="calibre8">To stop this from <a id="id566" class="calibre1"/>happening, the dependencies <code class="literal">firstName</code>, <code class="literal">lastName</code>, and <code class="literal">nickname</code> need to be made observables manually. This can be done by calling <code class="literal">convertObject</code> on the observable module:</p><div class="informalexample"><pre class="programlisting">observable.convertObject(self);
observable.defineProperty(self, 'displayName', function() {
  //
});</pre></div><p class="calibre8">This ensures that the first time <code class="literal">displayName</code> is accessed, it reads observable properties and not normal properties.</p><p class="calibre8">Because this <span class="strong"><em class="calibre12">bug</em></span> can be difficult to track down when it happens, it can be a good practice to always call <code class="literal">convertObjec</code>t in viewmodel constructors. It does not incur any performance penalty, as it's the same method the observable plugin uses when it gets to data binding. If you need finer-grained control over conversion, properties can be converted one at a time using <code class="literal">observable.convertProperty(object, 'propertyName')</code>.</p></div></div>

<div class="book" title="Binding to plain JavaScript objects">
<div class="book" title="Promises"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec109" class="calibre1"/>Promises</h2></div></div></div><p class="calibre8">In addition to treating normal<a id="id567" class="calibre1"/> JavaScript properties as observables, the observables plugin also allows promises to be bound against by converting the property into an observable and setting a callback to update it when the promise is resolved:</p><div class="informalexample"><pre class="programlisting">self.contacts = dataService.getContacts()
.then(function(contacts) {
  return contacts.map(function(contact) {
    return new ListItem(contact);
  });
});</pre></div><p class="calibre8">After being converted into an observable, the contacts array can still be bound against normally. In fact, making this change requires no HTML changes in the sample code.</p></div></div>

<div class="book" title="Binding to plain JavaScript objects">
<div class="book" title="Sample"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec110" class="calibre1"/>Sample</h2></div></div></div><p class="calibre8">You can see an example of all of <a id="id568" class="calibre1"/>these binding methods in the <code class="literal">cp6-observable</code> branch. All of the code has been converted to using plain JavaScript properties with the observable plugin.</p><p class="calibre8">The parentheses have been removed from all of the application code, including the mock data service. It should be a bit easier to read now.</p><p class="calibre8">On the list viewmodel, the preceding contacts' promise example is used, which replaces the <code class="literal">activate</code> method. The <code class="literal">displayContacts</code> computed value is created with the observable plugin and still has the <code class="literal">rateLimit</code> extender applied.</p><p class="calibre8">The <code class="literal">Contact</code> model uses the <code class="literal">convertObject</code> method to manually convert to observables, as the dirty flag on <code class="literal">state</code> will try to read the <code class="literal">displayName</code> computed value.</p><p class="calibre8">The only changes on the edit page are the removal of parentheses.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec50" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Durandal aims to compliment Knockout's MVVM philosophy by providing a view-viewmodel-centric framework that focuses on composition. If you love Knockout (and you should; you're reading this book, after all!), you should hopefully see Durandal as a natural extension. The tools Durandal provides go a long way in simplifying the development of SPAs.</p><p class="calibre8">In the next chapter, we will be leaving Durandal and deep diving into Knockout's inner workings.</p></div></body></html>