- en: The Animation Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servos are great tools for creating movement in our robotics projects but we
    need more control in order to create truly mobile walking robots. Each servo is
    different; for example, each servo moves at slightly different max speeds. If
    you want a bot to walk, you need timing control, and the ability to know when
    a servo has finished its movement. Enter the animation library; this powerful
    tool inside Johnny-Five allows you to fine-tune your servo movements to allow
    you more in-depth control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terminology of the animation library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The construction of the animation object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing into your servo animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more about queuing and playing animation segments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation object events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need your two-servo setup from the previous chapter, and that's it for
    hardware for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Animating movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animation library makes many things possible with servos that are otherwise
    anywhere from difficult to downright implausible. Before we explore the *how*
    of the animation library, however, we should more thoroughly explain the *why*.
  prefs: []
  type: TYPE_NORMAL
- en: Why we need the animation library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about the movement of your leg as you take a step. You don't normally
    have to, but when you do, there's a lot going on in your joints! Your hip extends
    your leg out, and your knee extends your leg without usually locking it. And your
    back leg is doing things too; your hip is allowing the leg to move back, and your
    ankle is flexing. This is a massive oversimplification, but it's still really
    complicated!
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine each of your joints as a servo, and you have to program taking a
    step. You cannot control the timing of each movement, because each servo will
    get to where you tell it to go as fast as you can. You also can't tell when a
    joint is done moving, so you have to hard-code timings and hope it holds up.
  prefs: []
  type: TYPE_NORMAL
- en: This exact kind of issue is what the animation library was made to alleviate.
    By giving you more control, you have more precision. But what do we mean by precision?
  prefs: []
  type: TYPE_NORMAL
- en: Moving servos with true precision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True precision, in the context of moving servos, means being able to control
    the timing, position, and speed of the servos being used. This level of precision
    is vital when building meticulous movements that require multiple movements happening
    in sync to avoid physical collisions. A great example of this is a hexapod robot:
    each joint needs to move in time with the other joints in the leg, and each leg
    needs to move at a precise time during a step in order to avoid colliding with
    each other or throwing the hexapod off balance.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving servos with true precision is a daunting task if you are hard-coding
    it; imagine setting 60 calls to `servo.to()` in order to create an animation that
    you *hope* takes one second. Or hard-coding each movement with `servo.to()`, timing
    it with the exact servo you've placed in the leg of your bot, and everything works...until
    the servo strips (it inevitably will), and you have to replace it and repeat the
    entire calibration process.
  prefs: []
  type: TYPE_NORMAL
- en: The animation library in Johnny-Five makes this process much simpler by allowing
    you to define your movements as segments of a larger design, that design being
    the animation itself. It does all of the math and works out all of the timings
    to ensure that your servos are where they need to be when they need to be there.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit use of the animation library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you don't even need to create an animation object in order to create
    an animation for your servos. Before we really break into the animation object,
    let's write some code that uses the animation library implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Using servo.to() to implicitly create an animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a `project` folder for this chapter, create a file called `implicit-animations.js`.
    We''ll set up this file to use the REPL to demonstrate animations created without
    explicitly creating an animation object. Start with the normal boilerplate: bring
    in `johnny-five` and `raspi-io`, set up your board and `board.ready()` handler
    as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `board.on(''ready'')` handler, construct a `Servo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, while still inside the `board.on('ready')` handler, we're going to create
    the same motion three times—each time with a different set of specifications.
    Two of these will create an animation behind-the-scenes, and one is the default
    movement, so you can see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be a little hard to spot the differences in the servo movements if you''re
    looking at a micro servo horn. I taped a Popsicle stick to my servo horns for
    this chapter, to make the differences easier to see. I also taped it to stand
    up on my desk so it wouldn''t tip over, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc252dec-e458-49c8-a00c-3ef579fee832.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First movement function, still inside your `board.on(''ready'')` handler, will
    be called `normalFullSwing()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function will move the servo to `0` degrees as quickly as it can, then
    bring the servo to `180` degrees as fast as it can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a parameter to `servo.to()` in our next function that will change
    how long the servo takes to get there. We''ll set it to take in a time parameter
    that we''ll pass through when we experiment in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function will take the number of milliseconds passed to it to go from `0`
    to `180` degrees. It will still start by going to `0` degrees as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll write a function that takes in a time and a steps parameter
    that will move the servo from `0` to `180` in the time given, using the number
    of steps given. We''ll call this function `timedFullSwingWithSteps()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function will, as the others, still go to `0` as fast as possible first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll give ourselves access to these functions from the REPL using
    `board.repl.inject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And we're ready to roll (or swing, as it were)!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with implicit animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load the folder onto your Pi, navigate into it using your Pi SSH session, and
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re all set up, we run the code using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you see `Board Initialized`, we can run our functions and see the differences.
    Here are just a few to try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You may be noticing something is up by now. At most, you might see a twitch
    or two, but it's certainly not working as intended!
  prefs: []
  type: TYPE_NORMAL
- en: That's because of a very important thing with timing, and that's that **if you
    don't wait for servo movements to finish, they'll just override each other, causing
    unstable results**.
  prefs: []
  type: TYPE_NORMAL
- en: That's part of why the animation library is so important! It has the ability
    for you to queue animations, meaning that the servo will let each movement finish
    before moving on to the next, preventing the need for you to program the waiting
    in yourself (especially icky considering the asynchronous nature of JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to use a few more implicit animations, and some `setTimeout()`
    calls, to make these functions work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with implicit animations, take two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fix your `normalFullSwing()` function, we''ll set the `servo.to(0)` call
    to take 250 milliseconds, and `call servo.to(180)` after 255 milliseconds (just
    to be sure it''s completely done getting to `0` first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll do the same to the `timedFullSwing()` and `timedFullSwingWithSteps()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve made these changes, reload your `project` folder and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you're using the book code directly instead of following along, `implicit-animations-fixed.js`
    contains the timeouts so you should run that file instead of running `implicit-animations.js`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the code is running as intended, let''s play around a little more
    with these implicit animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Make a mental note of what changing the timing and steps does to the servo's
    movements, it'll come in handy for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand some of the underlying effects of the animation library,
    and why it's so crucial when dealing with complex servo movements, let's dig into
    the animation library in detail. We'll start with the terminology, unless you
    have a strong background with animation (as in animated imagery), you have some
    vocabulary to learn!
  prefs: []
  type: TYPE_NORMAL
- en: The terminology of the animation library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animation library was named the way it was quite intentionally; the vocabulary
    of the animation object very closely matches the vocabulary of animating images.
    Let's look at a few of the terms we'll be using heavily throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame**: A frame of an animation is, in this context, the state of the servo
    at a given instance in time. As you can imagine, programming each and every frame
    of servo movement for a complex group of servos, such as a limb, would be a nightmare.
    Luckily, technology is on our side here, and we won''t have to write each and
    every frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyframe**: A keyframe is a point in an animation that serves as an anchor
    unless you''re drawing (or programming) every frame of an animation by hand; you
    establish a set of keyframes that establish the major points of movement for the
    animation. For example, in our full sweep we were doing earlier, a good set of
    keyframes would be something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start at any degree
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be at `0` degrees
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End at `180` degrees
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler animations have fewer keyframes, but you always need at least two to
    create an animation. Note that keyframes themselves do not have any concept of
    time attached; they must be coupled with cue points to create an animation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cue point**: A cue point is a point in the context of the sequence between
    0 and 1, and a set of cue points paired with an equally-sized set of keyframes
    and an overall duration creates a full animation. For instance, when we care the
    keyframes above with the set of cue points containing 0 seconds, 1 second, and
    2 seconds, you get what starts to sound like an animation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start at any degree at 0%
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be at `0` degrees at 50%
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End at `180` degrees at 100%
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**:Duration is the amount of time the animation sequence will run,
    and completes an animation when paired with keyframes and cue points. Take the
    above example with a duration of 2000 millseconds and you get:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start at any degree at 0 ms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be at `0` degrees at 1000 ms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End at `180` degrees at 2000 ms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tweening**: Tweening is the idea of your software creating the necessary
    frames between your keyframes. You establish the keyframes, and tweening figures
    out what to do in between those frames. The time between each frame (exhibited
    by our `timedFullSwing()` function) and the number of steps (frames) between keyframes
    (exhibited by our `timedFullSwingWithSteps()` function) allow us to fine-tune
    the tweening process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easing**:Another part of the tweening process is easing. Without easing,
    all tweening is done linearly, with the same amount of movement in each tweened
    frame. This does not look smooth at all if you''re building anything trying to
    walk. There are several forms of tweening; one of the most common form is ease-in
    or ease-out easing, which either starts slowly and ramps up to a fast ending,
    or starts fast and ramps down to a slow ending, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've discussed the terminology of an animation, we can start coding
    our first (explicit) animation object with Johnny-Five!
  prefs: []
  type: TYPE_NORMAL
- en: The construction of the animation object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To construct an animation object, we need to create the object itself, create
    a set of keyframes and a set of cue points, then enqueue those keyframes and cue
    points as an animation to run on our servos.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the animation object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file in your `project` folder called `my-first-animation.js` and
    create the normal boilerplate: `require` in Johnny-Five and Raspi-IO, create your
    `Board` object, and create the `board.on(''ready'')` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `board.on(''ready'')` handler, construct our two `Servo` objects
    on pin `0` and pin `1` of our PWM hat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And create a `Servos` object containing our servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a group of servos, we can create an animation object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our animation object, it's time to plan out our animation sequence,
    set keyframes and cue points, and queue them to animate.
  prefs: []
  type: TYPE_NORMAL
- en: Planning out the animation sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s plan a simple enough animation for our first go-round: let''s allow
    the servos to start anywhere, then `servoOne` will move to `0` degrees while `servoTwo`
    will move to `180`. Then, `servoOne` will sweep to `180` while `servoTwo` starts
    moving to `90` degrees, then both servos will end at `90` degrees. Let''s have
    each of these positions happen two seconds apart. So our keyframes will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with `servoOne` at any degree, start with `servoTwo` at any degree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move `servoOne` to `0` degrees, move `servoTwo` to `180` degrees
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`servoOne` stays at its last known position, `servoTwo` is moving towards `90`
    degrees'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move `servoOne` to `180` degrees, `servoTwo` is moving towards `90` degrees
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move `servoOne` to `90` degrees, move `servoTwo` to `90` degrees completed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our cue points will be (in terms of `0`-`1`): `0`, `.25`, `.5`, `.75`, `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've planned out our sequence, we can start programming our keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating keyframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to make a keyframe array for each servo in our servos group, for each
    cue point: two arrays of five keyframes each.'
  prefs: []
  type: TYPE_NORMAL
- en: That sounds simple enough, but how do we tell the animation to let the servos
    start wherever they happen to be? And how do we tween `servoTwo` across two cue
    points in its move to `90` degrees? The answer lies in the way Johnny-Five parses
    null and false as servo positions in keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: Using null and false as positions in keyframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Null and false are used by Johnny-Five to allow us to create complex segments
    where we can tween between multiple cue points or use the last known position
    of a servo as a keyframe position.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of null depends on where it is used, if it is used in the first keyframe,
    it uses the position of the servo as the animation begins as that keyframe's position.
    This is exactly what we need to start our animation sequence, as we want both
    servos to start at wherever they happen to be. If null is used in a keyframe that
    is not the first, then the keyframe will essentially be ignored at that cue point;
    if you have 30 in one keyframe, null in the next, and 120 in the third, the servo
    will move `90` degrees over the two cue points. We will use this to allow `servoTwo`
    to move from `180` to `90` over two cue points.
  prefs: []
  type: TYPE_NORMAL
- en: When you use false as a keyframe position, it will use the position set in the
    last keyframe. We will use this on `servoOne` when the keyframe calls for the
    servo to remain in its last known position, instead of hard-coding a second 180-degree
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how null and false affect our positioning in keyframes, let's
    program our keyframes for our planned animation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Programming our keyframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So based on the information we''ve been given, the values we need for each
    keyframe are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`servoOne null`, `servoTwo null` (start wherever the servos happen to be)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servoOne 0`, `servoTwo 180`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servoOne 180`, `servoTwo null` (`servoTwo` starts moving towards `90` degrees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servoOne false`, `servoTwo null` (`servoOne` stays put, `servoTwo` still moving
    to `90` degrees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servoOne 90`, `servoTwo 90`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each position needs to be an object with a property `degrees` for each keyframe. Let''s
    translate that into JavaScript, right under the construction of our animation
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our keyframes programmed, let's get started on our cue points.
  prefs: []
  type: TYPE_NORMAL
- en: Setting cue points and duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cue points, no matter how many servos you have, will always be a one-dimensional
    array of times to match each keyframe in the array of keyframes you pass in.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the cue points in this animation are evenly spaced, that is
    absolutely optional your cue points can vary wildly in distance from each other
    without breaking anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath our keyframes object, let''s set up our cue points array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We want our animation to take 8 seconds overall, so add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have all the data we need, let's make an animation!
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together to make an animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run our animation sequence, we have to place it in the queue using
    the `Animation.enqueue()` function. We''ll need to pass in the duration, keyframes,
    and cue points together. In your `my-first-animation.js`, after the duration,
    add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The object containing the duration, `keyFrames`, and `cuePoints` properties
    is known within the animation library as a `Segment` object.
  prefs: []
  type: TYPE_NORMAL
- en: The animation segment will immediately begin to play upon queuing, so we're
    ready to load our project in and see some animated servos!
  prefs: []
  type: TYPE_NORMAL
- en: Watching your animation at work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load your `project` folder onto the Pi, navigate into the folder in your Pi
    SSH session, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see the animation play out with the two servos as we described it.
  prefs: []
  type: TYPE_NORMAL
- en: This is really powerful, but when you think of a walking hexapod, these linear
    movements wouldn't make for a realistic or pretty gait. Let's add some easing
    into our animation sequence in order to create some more organic-looking movement.
  prefs: []
  type: TYPE_NORMAL
- en: Easing into your servo animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you want any of your future walking bots to be very firmly in the uncanny
    valley, you'll need to use easing to create a more fluid, natural motion with
    your animation segments.
  prefs: []
  type: TYPE_NORMAL
- en: How easing fits into an animation segment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Easing functions are added into the `keyframes` of a servo; so not only are
    we saying what position we want the servo to be, but how it gets there. For example,
    these `keyframes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Will take a servo starting at any position and move it to `180`, starting out
    slow, speeding up in the middle, and slowing down again towards the end.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different options for easing, and they are documented in the
    ease-component ([https://www.npmjs.com/package/ease-component](https://www.npmjs.com/package/ease-component))
    `npm` module included as a dependency to Johnny-Five. We'll be using `incirc`,
    `outcirc`, and `inoutcirc` to start.
  prefs: []
  type: TYPE_NORMAL
- en: Adding easing to our first animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy the contents of `my-first-animation.js` into a new file called `easing-animations.js`. Next,
    we''ll modify the `keyframes` array to include some easing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also increase the duration of the animation segment so we can really
    see the difference easing makes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, load it onto the Pi, navigate to the folder in your Pi SSH session, and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Really watch how `inCirc`, `outCirc`, and `inOutCirc` affect your animation.
  prefs: []
  type: TYPE_NORMAL
- en: Easing an entire animation segment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to easily set all keyframes in an animation segment to have the same
    easing, you can pass an `easing` property when you enqueue your segment. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will override the keyframes and all of them will use `inOutCirc`
    easing. Now that we've fully explored easing our animation segments, let's take
    a look at the animation queue and how we can affect our segments when we queue
    them and when they're playing.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about queuing and playing animation segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we queue an animation segment, we pass it a duration, cue points, and keyframes.
    But we can also pass in other options that affect the playback of the animation
    segment. We can also call methods on the animation object that affect animation
    segments currently playing and in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start messing with these, copy the content of `easing-animations.js`
    into a new file called `playing-with-the-queue.js`. Remove the call to `myFirstAnimation.enqueue()`
    at the end; we want a little control when we get into the REPL this time around.
  prefs: []
  type: TYPE_NORMAL
- en: Looping animation segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add a function that will enqueue our animation normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you want the animation segment you are enqueuing to run on a loop.
    Let''s create a function in our `board.on(''ready'')` handler that will enqueue
    our animation segment on a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can also add the `loopBackTo` property, and set it to the index of a cue
    point; the animation will start its loop from the designated cue point.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want the animation to play forward, then back to the start, and
    repeat? Let''s write a function that will set the `metronomic` property to do
    just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to loop and metronome our animation segments, let's explore
    changing the speed of animation segments using the animation object.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the speed of animation segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can call `Animation.speed()` with a numeric multiplier to change the speed
    of the current animation segment. For instance, calling `Animation.speed(.5)`
    will halve the speed, and `Animation.speed(2)` will double it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some functions to half, double, and normalize our animation segment
    speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add these to the loop and metronome functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to adjust the speed of animation functions, as well as
    how to loop them, let's talk about pausing, playing, and stopping animations.
  prefs: []
  type: TYPE_NORMAL
- en: Playing, pausing, and stopping animation segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If left alone, the animation segments will be played until there is nothing
    left in the queue to play (meaning if there is a looped or metronome segment,
    it will stay on that segment).
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can move to the next animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can pause the current segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start it up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or stop the current segment and clear out the entire queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's use these, along with the REPL, to play with our animation and our new-found
    powers to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together in the REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following to the end of the `board.on(''ready'')` handler in `playing-with-the-queue.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, load your `project` folder onto your Pi, navigate to the `project` folder
    in your Pi SSH session, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you see `Board Initialized`, try a few commands to experiment with how
    your animation plays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into the animation library with servos. We learned
    the key terminology for the animation library, how to construct an animation segment,
    how to queue it, and how to manipulate playback, both when queuing the segments
    or by calling methods of the animation object.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are animations necessary for complex movements with multiple servos?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a keyframe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a cue point?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the three pieces of an animation segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does easing do to our animation keyframes and segments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the animation object stops the current segment and clears the
    animation queue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does calling `Animation.speed(.25)` do to the current animation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
