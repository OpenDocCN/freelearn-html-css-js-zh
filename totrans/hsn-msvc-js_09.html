<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor147"/>9</h1>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Securing Microservices</h1>
			<p>In today’s digital world, many applications are built from smaller, independent services working together. These <em class="italic">microservices</em> offer flexibility and scalability, but keeping them secure is crucial. Imagine a microservice as a small shop on a busy street. You want to ensure that only authorized customers can enter (authentication) and only those with permission can access specific areas (authorization). Likewise, you’d encrypt sensitive information such as credit card details (data encryption). By constantly monitoring for suspicious activity and keeping the shops updated (patching), you can maintain a safe and secure shopping experience. This chapter will guide you through securing your microservices using similar practical strategies and more!</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li> Security, authentication, and authorization in microservices</li>
				<li>Getting started with JSON Web Tokens</li>
				<li>Implementing an Authentication Microservice</li>
			</ul>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Technical requirements</h1>
			<p>To follow along in the chapter, you need to have installed an IDE (we prefer Visual Studio Code), Postman, Docker, and a browser of your choice.</p>
			<p>It is preferable to download our repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09</a> to easily follow our code snippets.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Security, authentication, and authorization in microservices</h1>
			<p>In a microservices architecture, ensuring robust security, authentication, and authorization is crucial due to the distributed nature of the system. Implementing these mechanisms properly protects microservices from unauthorized access, ensuring data integrity and confidentiality across the system.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Understanding security</h2>
			<p>In microservices, <strong class="bold">security</strong> refers<a id="_idIndexMarker643"/> to the measures and practices used to protect<a id="_idIndexMarker644"/> the system’s components, data, and communication channels from unauthorized access, breaches, and attacks. It involves securing each service individually, as well as the interactions between services, ensuring data is safe both in transit and at rest. Security in microservices typically includes mechanisms such as encryption, authentication, authorization, and monitoring to safeguard the system against vulnerabilities.</p>
			<p>Microservices, while offering advantages in flexibility and scalability, introduce unique security challenges. Unlike monolithic applications with a single attack surface, microservices create a distributed system with many potential entry points for attackers. That is why security becomes even more important compared to monolithic applications. A security breach in one microservice can quickly compromise the entire system. Before deploying our services, we should provide a properly tested and fully functional security layer over our microservices.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Exploring authentication</h2>
			<p><strong class="bold">Authentication</strong> is a process <a id="_idIndexMarker645"/>of verifying a user’s or service’s<a id="_idIndexMarker646"/> identity, and it plays a critical role in securing microservice applications. In a world of distributed systems with numerous access points, authentication ensures that only authorized users and services can interact with your microservices.</p>
			<p>But why is authentication valuable in microservices? Let’s answer this question here:</p>
			<ul>
				<li><strong class="bold">Enhanced security</strong>: Microservices create a distributed attack surface. Robust authentication acts as a gatekeeper, preventing unauthorized access and potential breaches.</li>
				<li><strong class="bold">Granular control</strong>: Authentication allows you to define access levels for different users and services. This ensures that only authorized entities can perform specific actions within each microservice.</li>
				<li><strong class="bold">Improved trust</strong>: By implementing strong authentication, you build trust with users and external systems relying on your microservices. They can be confident their data is secure.</li>
				<li><strong class="bold">Microservice communication security</strong>: Authentication secures communication between microservices themselves. This prevents unauthorized services from impersonating legitimate ones and gaining access to sensitive data.</li>
			</ul>
			<p>Applying authentication is not hard thanks to the packages of Node.js but there are some microservice and authentication challenges you should consider before starting to apply it. We will discuss two of them in this section.</p>
			<p>The first challenge is choosing <a id="_idIndexMarker647"/>either a <strong class="bold">centralized</strong> or <strong class="bold">decentralized</strong> authentication<a id="_idIndexMarker648"/> service. Deciding on a centralized authentication service or embedding it within each microservice can be a challenge. There’s a trade-off between simplicity and potential bottlenecks. Let’s<a id="_idIndexMarker649"/> look<a id="_idIndexMarker650"/> at both of these types of services here:</p>
			<ul>
				<li>A centralized authentication service, also known <a id="_idIndexMarker651"/>as an <strong class="bold">Identity Provider</strong> (<strong class="bold">IdP</strong>), is a trusted third-party system that manages the authentication process for users across multiple applications or microservices. Instead of each microservice handling authentication independently, the IdP takes on this responsibility, offering a consistent, secure, and streamlined authentication mechanism.</li>
				<li>A decentralized authentication service involves each microservice independently managing its own authentication process. Unlike a centralized system where a single IdP handles authentication, decentralized services allow each microservice to have its own embedded authentication logic, providing greater autonomy and flexibility to each service but introducing complexity in maintaining consistency.</li>
			</ul>
			<p>When choosing between centralized and decentralized authentication, consider factors such as application complexity, scalability needs, security tolerance, and development resources, as a centralized IdP simplifies security enforcement but adds complexity, while decentralized options require more development effort per microservice.</p>
			<p>If you cannot pick one or the other, a <em class="italic">hybrid</em> approach might be more suited for your case. A hybrid approach can be a good option in some cases. A central IdP can handle user authentication and issue tokens, while individual microservices validate those tokens independently. This offers a balance between security, flexibility, and resilience. As we mentioned before, there’s no one-size-fits-all solution. Evaluate your specific requirements and choose the approach that best aligns with your security goals and development needs.</p>
			<p>The second challenge can be session management. Traditional session management techniques might<a id="_idIndexMarker652"/> not be ideal for the stateless nature of microservices. Alternatives such as <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) are <a id="_idIndexMarker653"/>often preferred. We <a id="_idIndexMarker654"/>will talk about JWTs in more detail later in this chapter.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Defining authorization</h2>
			<p><strong class="bold">Authorization</strong> in microservices<a id="_idIndexMarker655"/> is critical for several reasons, primarily <a id="_idIndexMarker656"/>focusing on security, resource management, and compliance. It ensures that only users or services with the appropriate permissions can access or perform actions on specific resources or data. This prevents unauthorized access and potential misuse. By <em class="italic">enforcing</em> strict access controls, the potential attack surface is minimized. Unauthorized users are restricted from accessing sensitive parts of the system, reducing the risk of data breaches and other malicious activities.</p>
			<p>Microservices often deal with a wide range of functionalities and data. Authorization allows for granular control over who can access which service and what operations they can perform, ensuring resources are used appropriately. By <em class="italic">defining</em> clear access controls, resources are allocated and utilized more efficiently, preventing unauthorized consumption of resources that could degrade system performance.</p>
			<p>In a microservice architecture, each microservice is designed to perform a specific function. Authorization ensures that each service has access only to the data and operations it requires, promoting the principle of least privilege. This minimizes potential security risks and helps to maintain a secure, efficient system.</p>
			<p>Centralized authorization management can further streamline this process by defining and enforcing access policies uniformly across all services. This approach simplifies the maintenance and updating of access controls, making it easier to ensure consistency across the microservices ecosystem.</p>
			<p>There are various ways to implement authorization, such as <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>), <strong class="bold">Attribute-Based Access Control</strong> (<strong class="bold">ABAC</strong>), and <strong class="bold">Policy-Based Access Control</strong> (<strong class="bold">PBAC</strong>). While<a id="_idIndexMarker657"/> these are out of<a id="_idIndexMarker658"/> the scope of this book, by adopting the appropriate method, you<a id="_idIndexMarker659"/> can ensure that your system’s security policies are both robust and <a id="_idIndexMarker660"/>adaptable <a id="_idIndexMarker661"/>to your specific requirements.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Best practices for authorization</h2>
			<p>Best practices are <a id="_idIndexMarker662"/>essential to ensure robust security, consistency, and<a id="_idIndexMarker663"/> efficiency in managing access controls and authorization across microservices. Let’s look at some of these best practices here:</p>
			<ul>
				<li><strong class="bold">Least privilege principle</strong>: Give only the permissions that users or services need to do their jobs, which helps reduce the chance of unauthorized access.</li>
				<li><strong class="bold">Centralized authorization management</strong>: Use a single system to manage who can access what across all microservices, making it easier to maintain and ensure security.</li>
				<li><strong class="bold">Regular audits and reviews</strong>: Check and review who has access to what regularly to make sure everything is safe and up to date.</li>
				<li><strong class="bold">Reserve access</strong>: Set permissions based on roles so users and services only have access to what matches their responsibilities.</li>
				<li><strong class="bold">Token expiration and revocation</strong>: Use tokens that expire quickly and have a way to cancel them if needed, to lower the risk if a token is compromised.</li>
			</ul>
			<p>We delved into the critical importance of authorization in microservices and its role in maintaining security, resource management, and compliance. Now, let’s differentiate between authorization and authentication.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Difference between authentication and authorization</h2>
			<p>In microservices<a id="_idIndexMarker664"/> architectures, authorization <a id="_idIndexMarker665"/>plays a critical role in securing access to resources and data. Before diving into details, we need to understand and differentiate between the terms <strong class="bold">authentication</strong> and <strong class="bold">authorization</strong>. Authentication verifies the identity of a user or service trying to access the system. It typically involves checking credentials such as usernames and passwords, API keys, or tokens issued by an authorization server. It is similar to checking your ID at the entrance of a building.</p>
			<p>On the other hand, authorization determines what actions a verified user or service can perform within the system. It Involves enforcing predefined rules based on user roles, permissions, or attributes associated with the request. It is similar to how, once you’re verified to enter the building (authentication), your access card determines which floors or areas you <a id="_idIndexMarker666"/>can enter (authorization).</p>
			<p>Here are the key differences between authentication and authorization:</p>
			<ul>
				<li><strong class="bold">Objective</strong>: Authentication answers <em class="italic">Who are you?</em>, while authorization answers <em class="italic">What can </em><em class="italic">you do?</em>.</li>
				<li><strong class="bold">Timing</strong>: Authentication typically happens first, followed by authorization checks on specific actions.</li>
				<li><strong class="bold">Focus</strong>: Authentication deals with identity verification, while authorization focuses on access control.</li>
			</ul>
			<p class="callout-heading"><strong class="bold">Microservices and authorization</strong>: </p>
			<p class="callout">In monolithic systems, authorization is often centralized. But microservices, with their distributed nature, require a more distributed approach to authorization. Here are some common strategies:</p>
			<p class="callout"><strong class="bold">•  Per-service authorization</strong>: Each microservice manages authorization for its resources and data.</p>
			<p class="callout"><strong class="bold">•  API gateway</strong>: A central API gateway can handle authorization checks before routing requests to individual services</p>
			<p class="callout"><strong class="bold">•  Dedicated authorization service</strong>: A separate service manages authorization policies and enforces them across all microservices</p>
			<p>Which one to select? Well, choosing the right approach depends on factors such as the complexity of your system, security requirements, and scalability needs. As we mentioned before, let’s learn about the JWT together. A JWT is widely used for authentication and <a id="_idIndexMarker667"/>authorization <a id="_idIndexMarker668"/>purposes in distributed systems such as microservices because it is stateless, meaning the server does not need to store session data.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor156"/>Getting started with JWTs</h1>
			<p>The real world is constantly<a id="_idIndexMarker669"/> changing, and programs need to be adaptable to handle different situations. The elements of programs are also evaluated. The technique you used 10 years ago may not be valid nowadays.</p>
			<p>Years ago, we used to <a id="_idIndexMarker670"/>use <strong class="bold">session-based authorization</strong>, which was simple, popular, easy to grasp, and easy to adapt. It is still a topic for discussion but we mostly prefer to use different types of authentication techniques that are more secure. Before switching to JWT, it is helpful to talk about session-based authentication.</p>
			<p>In this type of authentication, you enter your username and password. The server checks whether your credentials are valid. If valid, the server creates a session with a unique identifier (session ID). This session ID might be stored in a cookie on your browser. With each request to the website during that session, your browser sends the session ID back to the server. The server checks the session ID and grants access if it’s valid, allowing you to stay logged in. The session expires after a period of inactivity (e.g., 30 minutes) or when you log out. This invalidates the session ID.</p>
			<p>On the other <a id="_idIndexMarker671"/>hand, <strong class="bold">token-based authentication</strong> offers several advantages over session-based authentication. Your sessions rely on the server storing information about each active user. This can become burdensome for applications with a large user base. Tokens, stored on the client side, alleviate this pressure on the server.</p>
			<p>The second important difference is that session-based authentication requires the server to maintain session data for each user. Token-based authentication is stateless, meaning the server only verifies the token itself, not referencing any stored user data. This simplifies server architecture and potentially improves performance.</p>
			<p>From the security perspective, tokens can be self-contained, including information such as expiry time and user roles. This reduces reliance on cookies, which can be vulnerable to theft. Additionally, tokens can be configured for short lifespans, minimizing the window of opportunity if compromised.</p>
			<p>Another important feature of tokens is flexibility. Tokens, such as JWTs, can embed additional data beyond just user identity. This allows for more granular control over access and simplifies authorization processes. Tokens can also be used for API calls between different services, whereas sessions are typically tied to a specific web application. JWTs are a compact, URL-safe means of representing claims to be transferred between two parties. It is commonly used for authorization purposes. A JWT is composed of three parts: header, payload, and signature. These parts are separated by dots (<code>.</code>) and encoded in Base64 URL format.</p>
			<p>The <strong class="bold">header</strong> typically <a id="_idIndexMarker672"/>consists of two parts: the type of <a id="_idIndexMarker673"/>token (JWT) and the signing algorithm being used, such as <em class="italic">HMAC</em>-<em class="italic">SHA256</em> or <em class="italic">RSA</em>. Here is an example of a header:</p>
			<pre class="source-code">
{
  "alg": "HS256",
  "typ": "JWT"
}</pre>			<p>The <strong class="bold">payload</strong> contains <a id="_idIndexMarker674"/>the claims. <strong class="bold">Claims</strong> are <a id="_idIndexMarker675"/>statements about an entity (typically, the user) and additional data. There are three types of claims:</p>
			<ul>
				<li><code>iss</code> (issuer), <code>exp</code> (expiration time), <code>sub</code> (subject), and <code>aud</code> (audience).</li>
				<li><strong class="bold">Public claims</strong>: Custom claims that can be defined by users. They should be collision-resistant names, such as using a URI or a namespace to avoid conflicts.</li>
				<li><strong class="bold">Private claims</strong>: Custom claims are created to share information between parties that agree to use them.</li>
			</ul>
			<p>Here is an example of a payload:</p>
			<pre class="source-code">
{
  "sub": "1234567890",
  "name": "David West",
  "admin": true,
  "iat": 1516239022
}</pre>			<p>The last element is <a id="_idIndexMarker676"/>the <strong class="bold">signature</strong>. To create the signature part, you have to take the encoded header, the encoded payload, a secret, and the algorithm specified in the header. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn’t changed along the way.</p>
			<p>For example, if you<a id="_idIndexMarker677"/> use the <em class="italic">HMAC-SHA256</em> algorithm, the signature will be created as follows:</p>
			<pre class="source-code">
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)</pre>			<p>The output of the algorithm is three Base64-URL strings joined by dots that can be easily passed in HTML and HTTP environments.</p>
			<p>Here is an example of <em class="italic">HMAC-SHA256</em> output:</p>
			<pre class="console">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibm FtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.SflKxw RJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</pre>			<p>Now that we have understood the various components of a JWT, let’s look at how it works in authentication with the help of the preceding example. A user logs in using their credentials. The server verifies the credentials and issues a JWT signed with a secret key. The client (usually a browser) stores the JWT (typically in local storage or a cookie).</p>
			<p>The client sends the JWT in the <code>Authorization</code> header of each subsequent request to access protected resources:</p>
			<pre class="source-code">
Authorization: Bearer &lt;token&gt;</pre>			<p>Then, it does token verification where the server verifies the token’s signature and checks its validity (expiration, issuer, etc.). If the token is valid, the server processes the request. Before moving on, it’s important to note that JWTs are stateless, compact, and self-contained, making them efficient for securely transmitting user information without server-side session storage. When using JWTs, ensure the secret key is secure, always transmit tokens over HTTPS, and use short-lived tokens with periodic refreshes to mitigate security risks. Now we know that JWTs are a powerful and flexible way to handle authentication and authorization in modern web applications, providing both security and convenience.</p>
			<p>Now that we’ve <a id="_idIndexMarker678"/>covered the theory, let’s move on to the practical part and implement the authentication microservice together.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor157"/>Implementing an Authentication microservice</h1>
			<p>In microservices<a id="_idIndexMarker679"/> development, it’s a common practice to develop a separate microservice for authentication and authorization (often referred to as an Auth service). Here’s why it’s valuable:</p>
			<ul>
				<li><strong class="bold">Centralized security management</strong>: Having a dedicated Auth service allows us to manage authentication and authorization logic in one place. This simplifies updates and security audits and ensures consistent rules across all microservices.</li>
				<li><strong class="bold">Scalability</strong>: The Auth service can be scaled independently based on its load, separate from other microservices with different resource requirements.</li>
				<li><strong class="bold">Reusability</strong>: The Auth service can be reused by all your other microservices, reducing code duplication and promoting consistency.</li>
				<li><strong class="bold">Improved maintainability</strong>: Isolating authentication logic makes it easier to maintain and update the security aspects of your system.</li>
				<li><strong class="bold">Separation of concerns</strong>: Decoupling authentication and authorization from other microservices keeps their responsibilities focused, promoting cleaner code and better maintainability.</li>
				<li><strong class="bold">Flexibility</strong>: A dedicated Auth service can be designed to support different authentication flows (e.g., OAuth, JWT) and authorization strategies (e.g., RBAC), providing a flexible foundation for your microservices architecture.</li>
			</ul>
			<p>Let’s implement our Auth microservice together. We will use a classical approach to develop our new microservice via ExpressJS as we did before. Most of the things are the same. You should open/create a new folder anywhere you want on your computer and type <code>npm init -y</code> to initialize start our project. Throughout our development process, we will use the following libraries: <code>bcryptjs</code>, <code>dotenv</code>, <code>express</code>, <code>joi</code>, <code>jsonwebtoken</code>, and <code>mongoose</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>npm init -y</code> command does not automatically generate the scripts section in <code>package.json</code>. You’ll need to add it manually to simplify running the application.</p>
			<p>Let’s walk through<a id="_idIndexMarker680"/> our <code>package.json</code> file:</p>
			<ul>
				<li><code>bcryptjs</code>: This library provides secure password hashing and comparison functionalities. It allows you to store passwords securely in your database and verify user login attempts against the hashed passwords.</li>
				<li><code>dotenv</code>: This library helps you load environment variables from a <code>.env</code> file. This is a secure way to store sensitive information such as API keys, database credentials, and your JWT secret key, keeping them out of your code.</li>
				<li><code>express</code>: This is a popular Node.js web framework that helps you build web applications and APIs. It provides a structured approach for handling requests, routing, middleware, and responses.</li>
				<li><code>joi</code>: This library offers schema validation for data coming into your application. You can define validation rules for request bodies and ensure that the data received adheres to your expected format and structure, improving data integrity and preventing potential errors.</li>
				<li><code>jsonwebtoken</code> (JWT): This library helps you work with JWTs. It allows you to generate tokens for authentication purposes, containing user information in a secure and verifiable format. You can use JWTs to authorize users for access to protected resources in your microservices.</li>
				<li><code>mongoose</code>: This is <a id="_idIndexMarker681"/>an <strong class="bold">Object Data Modeling</strong> (<strong class="bold">ODM</strong>) library for MongoDB in Node.js. It provides a convenient way to interact with your MongoDB database by mapping your application data models to MongoDB documents. It simplifies data manipulation and retrieval.</li>
			</ul>
			<p>We need a secure way to store user information, and a database is commonly used for this purpose. The <code>mongoose</code> package will help us to work with the database. To connect and disconnect from the database, create a new file called <code>index.js</code> under the <code>src/db</code> folder with the same<a id="_idIndexMarker682"/> content as we have in <a href="B09148_05.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a>.</p>
			<p>Under the <code>src/models</code> folder, create a new file called <code>user.js</code> with the following code block:</p>
			<pre class="source-code">
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const userSchema = new mongoose.Schema({
    email: {
        type: String,
        required: true,
        unique: true
    },
    password: {
        type: String,
        required: true
    }
});
// Hash password before saving
userSchema.pre('save', async function (next) {
    if (this.isModified('password')) {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
    }
    next();
});
module.exports = mongoose.model('User', userSchema);</pre>			<p>You can extend this schema with additional information but to demo authentication and authorization, we need only these fields.</p>
			<p>We have already talked about <code>mongoose</code> in our previous chapters and that is why we will bypass already known details. The only new logic here is working with a hash password. When we<a id="_idIndexMarker683"/> create a user via API, we will provide an email and password. For security reasons, we need to hash passwords before storing them in our database.</p>
			<p>The code that starts with <code>userSchema.pre("…")</code> is a <code>mongoose</code> middleware function that is executed before a user document is saved to the database. This middleware ensures that passwords are never stored in plain text in our database. It securely hashes passwords before saving them, making it computationally infeasible to recover the original password from the stored hash.</p>
			<p>Now, we need to provide a service layer that interacts with the database. For simplicity, you can bypass this layer, but to provide a full picture, we will have it. Under the <code>src/services</code> folder, create a new file called <code>user.js</code> with the following code block:</p>
			<pre class="source-code">
const User = require('../models/user');
const createUser = async (userData) =&gt; {
    const user = new User(userData);
    await user.save();
    return user;
};
const getUserById = async (userId) =&gt; {
    return await User.findById(userId);
};
const getUserByEmail = async (email) =&gt; {
    return await User.findOne({ email: email });
};
// ... Add methods for other user operations (e.g., update, delete)
module.exports = { createUser, getUserById, getUserByEmail };</pre>			<p>To make things <a id="_idIndexMarker684"/>simple, we haven’t implemented full CRUD operations. To demo our functionality, we only need a few of them such as <code>create</code> and <code>get user</code>.</p>
			<p>Now, let’s switch to our controller and see how we create a user. Under the <code>src/controllers</code> folder, create a new file called <code>user.js</code> with the following code block:</p>
			<pre class="source-code">
const userService = require('../services/user');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const path = require('path');
const { createConfig } = require('../config/config');
// Register a new user
const createUser = async (req, res) =&gt; {
    try {
        const { email, password } = req.body;
        const existingUser = await userService.getUserByEmail(email);
        if (existingUser) {
            return res.status(400).json({ message: 'Email already 
              exists' });
        }
        const user = await userService.createUser({ email, password 
          });
        res.status(201).json({ message: 'User created successfully', 
          user: user });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>This code snippet defines <a id="_idIndexMarker685"/>an asynchronous function named <code>createUser</code> that handles user registration in your Node.js application. Here are the details:</p>
			<ul>
				<li><code>const createUser = async (req, res) =&gt; { ... }</code>: This defines an asynchronous function named <code>createUser</code> that takes two arguments, <code>req</code> (request object) and <code>res</code> (response object).</li>
				<li><code>const { email, password } = req.body;</code>: This extracts the <code>email</code> and <code>password</code> properties from the request body (<code>req.body</code>). These are assumed to be sent by the client in the registration request.</li>
				<li><code>const existingUser = await userService.getUserByEmail(email);</code>: This calls a function from <code>userService</code> (to check whether a user with the provided email already exists. It awaits the result (<code>existingUser</code>).</li>
				<li><code>if (existingUser) { ... }</code>: If <code>existingUser</code> is not <code>null</code> (meaning a user with the email exists), it returns a <code>400 Bad Request</code> response with a message indicating the email conflict.</li>
				<li><code>const user = await userService.createUser({ email, password });</code>: If the email is unique, it calls another function from <code>userService</code> (likely<a id="_idIndexMarker686"/> for user creation) with an object containing the extracted email and password. It awaits the result (<code>user</code>), which is the newly created user document.</li>
				<li><code>.status(201).json({ message: 'User created successfully', user: user });</code>: If user creation is successful, it sends a <code>201 Created</code> response with a message and the newly created user object (<code>user</code>) in the response body.</li>
				<li>A <code>try...catch</code> block: This wraps the core logic in a <code>try</code>-<code>catch</code> block to handle any potential errors during the registration process.</li>
				<li><code>res.status(500).json({ message: 'Server error' });</code>: This sends a generic <code>500 Internal Server Error</code> response in case of any errors.</li>
				<li><code>createUser</code>: This function provides a basic structure for user registration in our application. It checks for email conflicts, delegates user creation logic to a separate service, and handles successful and error scenarios with appropriate responses.</li>
			</ul>
			<p>But creating a user is not enough. We need to implement sign-in/log-in functionality. In the same file, we <a id="_idIndexMarker687"/>have the following code to log in:</p>
			<pre class="source-code">
const loginUser = async (req, res) =&gt; {
    try {
        const { email, password } = req.body;
        // Fetch user by email
        const user = await userService.getUserByEmail(email);
        if (!user) {
            return res.status(401).json({ message: 'Invalid email or 
              password' }); // Use 401 for unauthorized
        }
        // Compare password hashes securely using bcrypt
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(401).json({ message: 'Invalid email or 
              password' });
        }
        const configPath = path.join(__dirname, '../../configs/.env');
        const appConfig = createConfig(configPath);
        const payload = { userId: user._id }; // Include only essential user data
        const jwtSecret = appConfig.jwt.access_token; // Replace with your secret from an environment variable
        const accessToken = await jwt.sign(payload, jwtSecret, { 
          expiresIn: '1h' }); // Set appropriate expiration time
        // Send successful login response
        res.status(200).json({ accessToken: accessToken });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>The code defines an asynchronous function named <code>loginUser</code> that handles user login in your Express.js <a id="_idIndexMarker688"/>application. Here’s a breakdown of what it does:</p>
			<ul>
				<li><code>const loginUser = async (req, res) =&gt; { ... }</code>: This defines an asynchronous function named <code>loginUser</code> that takes two arguments, <code>req</code> (request object) and <code>res</code> (response object).</li>
				<li><code>const { email, password } = req.body;</code>: This extracts the <code>email</code> and <code>password</code> properties from the request body (<code>req.body</code>). These are assumed to be sent by the client in the login request.</li>
				<li><code>const user = await userService.getUserByEmail(email);</code>: This calls a function from <code>userService</code> (likely another module) to fetch a user with the provided email. It awaits the result (<code>user</code>).</li>
				<li><code>if (!user) { ... }</code>: If <code>user</code> is <code>null</code> (meaning no user found with the email), it returns a <code>401 Unauthorized</code> response with a message indicating invalid credentials.</li>
				<li><code>const isMatch = await bcrypt.compare(password, user.password);</code>: This uses <code>bcrypt.compare</code> to compare the provided password with the hashed password stored in the fetched user document (<code>user.password</code>). It awaits the result (<code>isMatch</code>), which is a boolean indicating whether the passwords match.</li>
				<li><code>if (!isMatch) { ... }</code>: If <code>isMatch</code> is <code>false</code> (meaning passwords don’t match), it returns a <code>401 Unauthorized</code> response with a message indicating invalid credentials.</li>
				<li><code>const configPath = path.join(__dirname, '../../configs/.env');</code>: This constructs the path to the environment variable file (assuming it’s located four folders above the current file).</li>
				<li><code>const appConfig = createConfig(configPath);</code>: This calls a function to read and parse the environment variables from the <code>.</code><code>env</code> file.</li>
				<li><code>const payload = { userId: user._id };</code>: This creates a payload object for the JWT containing the user’s ID. Include only essential user data here.</li>
				<li><code>const jwtSecret = appConfig.jwt.access_token;</code>: This retrieves the JWT access token secret from the parsed environment configuration.</li>
				<li><code>const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: '1h' });</code>: This uses <code>jsonwebtoken</code> to sign the JWT with the payload, secret, and an expiration time of one hour (<code>expiresIn: '1h'</code>). It awaits the generated token (<code>accessToken</code>).</li>
				<li><code>res.status(200).json({ accessToken: accessToken });</code>: If login is successful, it sends a <code>200 OK </code>response with the generated <code>accessToken</code> in the response body.</li>
			</ul>
			<p>Overall, the login function <a id="_idIndexMarker689"/>provides a secure login flow using JWT authentication. It fetches the user, validates credentials, generates a JWT with a secret key, and sends it back to the client for subsequent authorized access.</p>
			<p>In order to have a fully functional login functionality, we need to provide the secret access token. In JWT, the secret access token plays a vital role in ensuring the integrity and authenticity of the token. When a JWT is created, a cryptographic hash algorithm (e.g., HMAC-SHA256) signs the header and payload (containing user information) using a secret access token. This secret key is like a password known only to the server that issued the JWT and the party verifying it. When a client sends a JWT in an authorization header to access a protected resource, the server receives the token.</p>
			<p>The server uses the same secret access token to verify the signature of the received JWT. This verification process ensures the following:</p>
			<ul>
				<li>The token has not been tampered with in transit.</li>
				<li>The token was indeed issued by a trusted source (the server that knows the secret).</li>
			</ul>
			<p>If the secret access token is compromised (e.g., leaked or stolen), anyone with the secret can forge valid-looking JWTs, potentially impersonating legitimate users and gaining unauthorized<a id="_idIndexMarker690"/> access to resources. Therefore, the secret access token is critical for maintaining the security of JWT-based authentication. Never store the secret access token in your code or within the application itself. Use environment variables or a dedicated secret management service to keep it confidential. Choose a cryptographically strong random string (ideally, at least 256 bits) for your secret access token to make it difficult to guess or crack. Consider rotating your secret access token periodically to mitigate the impact of a potential compromise. By following these practices, you can leverage the benefits of JWTs for secure authentication in your application while minimizing the risks associated with secret access tokens.</p>
			<p>When implementing access tokens, be careful to not to generate long-lived access tokens. Long-lived access tokens pose security risks because, if stolen, they allow attackers prolonged access, and revoking them is difficult. In contrast, refresh tokens offer better security by allowing short-lived access tokens to be issued, limiting potential damage. They also enable more granular control, as compromised tokens can be individually blacklisted without affecting other tokens, reducing the need for frequent authentication and lowering server load.</p>
			<p>Refresh tokens provide a good balance between user convenience (avoiding frequent logins) and security. Even though they have longer expirations compared to access tokens, their use is limited to obtaining new, short-lived access tokens.</p>
			<p>Before implementing our refresh token, consider providing limited time for access tokens as short-lived access tokens reduce the risk of misuse if they are compromised, minimizing the window of opportunity for attackers. In this example, we set it to <code>5</code> minutes. After five minutes, the given access token will expire and we should send our refresh token to a new endpoint to obtain a new short-lived access token. First of all, let’s modify our login <a id="_idIndexMarker691"/>endpoint to return a refresh token:</p>
			<pre class="source-code">
const jwtRefreshTokenSecret = appConfig.jwt.refresh_token;
        const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: '5m' }); // Set appropriate expiration time
        const refreshToken = await jwt.sign(payload, jwtRefreshTokenSecret, { expiresIn: '7d' });
        // Send successful login response
        res.status(200).json({ accessToken: accessToken, refreshToken: refreshToken });</pre>			<p>We use the same method to get both tokens. For refresh tokens, we set a bit longer period such as such as seven days. We will create a new endpoint to return new access tokens and that is why we need a new functionality in our controller:</p>
			<pre class="source-code">
const getAccessTokenbyRefreshToken = async (req, res) =&gt; {
    try {
        const refreshToken = req.body.refreshToken;
        if (!refreshToken) {
            return res.status(400).json({ message: 'Missing refresh 
              token' });
        }
        const configPath = path.join(__dirname, '../../configs/.env');
        const appConfig = createConfig(configPath);
        const refreshTokenSecret = appConfig.jwt.refresh_token;
        // Verify the refresh token
        jwt.verify(refreshToken, refreshTokenSecret, (err, decoded) =&gt; 
          {
            if (err) {
                return res.status(401).json({ message: 'Invalid 
                  refresh token' });
            }
            const userId = decoded.userId;
            // Generate a new access token
            const newAccessTokenPayload = { userId };
            const newAccessToken = jwt.sign(newAccessTokenPayload,
              appConfig.jwt.access_token,
              { expiresIn: '5m' });
            res.status(200).json({ accessToken: newAccessToken });
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>This function lets users get a new access token (key to access resources) by providing a refresh token (like a spare key). It checks whether the refresh token is valid using a secret key. If valid, it can generate a new, short-lived access token (with a 5-minute expiration by default) for the user. This way, users don’t need to log in frequently but still maintain security with short-lived access tokens.</p>
			<p>The best practice for <a id="_idIndexMarker692"/>storing refresh tokens involves a balance between security and user convenience. Here is what you need to know:</p>
			<ul>
				<li>Refresh tokens should not be stored in browser cookies due to their accessibility to JavaScript and potential theft through XSS attacks.</li>
				<li>If using cookies, opt for <code>HttpOnly</code> cookies with the <code>Secure</code> flag set. This prevents JavaScript access and mitigates XSS attacks. However, this approach has limitations (e.g., not supported by all browsers in cross-site context).</li>
				<li>On the other hand, local storage is a viable option, but implement security measures such as encryption at rest and in transit to protect the token if compromised. Evaluate libraries or frameworks that provide secure local storage mechanisms.</li>
				<li>In some scenarios, you might consider storing refresh tokens on the server side (e.g., database) for added security or centralized management. However, this is not always necessary and adds complexity.</li>
				<li>While refresh tokens have longer expirations than access tokens (e.g., days or weeks), avoid excessively long durations to minimize potential damage if compromised.</li>
				<li>Implement a mechanism to blacklist refresh tokens after a period of inactivity (e.g., a week) or upon user logout. This prevents attackers from using stolen tokens indefinitely.</li>
				<li>Consider refresh token rotation. When a new access token is issued using a refresh token, generate a new refresh token and store it. This reduces the risk of a single refresh token being compromised for an extended period.</li>
				<li>If performance and fast access are top priorities, consider using Redis for its speed and automatic handling of expiration times. However, address potential persistence concerns if necessary.</li>
				<li>If data durability and integration with your existing database are crucial, storing refresh tokens in a database can be an option. However, evaluate potential performance impacts compared to Redis.</li>
			</ul>
			<p>To access our new controller functionality, let provide a route for it. Open the <code>routes/v1/users/index.js</code> file and add the following line:</p>
			<pre class="source-code">
router.post('/token', validate(loginSchema),userController.getAccessTokenbyRefreshToken);</pre>			<p>That is all. Now we have<a id="_idIndexMarker693"/> endpoints to register, log in, and retrieve a new access token.</p>
			<p>We store secret tokens and refresh tokens in an <code>.env</code> file. Create a <code>configs</code> folder on the same level as the <code>src</code> folder and add an <code>.env</code> file with the following content:</p>
			<pre class="source-code">
PORT=3006
MONGODB_URL=mongodb://localhost:27017/auth-microservice #provide your MONGO_URL
SECRET_ACCESS_TOKEN={YOUR_SECRET_KEY}
SECRET_REFRESH_TOKEN={YOUR_REFRESH_TOKEN}</pre>			<p>In order to generate refresh and secret tokens, do the following operations:</p>
			<ol>
				<li>Open the terminal and type <code>node</code>.</li>
				<li>In the given input window, type <code>require('crypto').randomBytes(64).toString('hex')</code>.</li>
			</ol>
			<p>The following figure show how easily you can do it:</p>
			<div><div><img alt="Figure 9.1: Generating secret tokens" src="img/B09148_09_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Generating secret tokens</p>
			<p>You will get a different generated result every time you call the last command. Just copy the value and paste it to the <code>.env</code> file to be paired with <code>SECRET_ACCESS_TOKEN</code>. Try the same comment a second time to get a completely different value and paste it for <code>SECRET_REFRESH_TOKEN</code>. The refresh token and secret token must have different values.</p>
			<p>As you already know, we have the <code>src/config</code> folder with <code>config.js</code> that can read <code>.env</code> files <a id="_idIndexMarker694"/>programmatically. We add token reading functionality to it.</p>
			<p>Here is what it looks like:</p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        PORT: Joi.number().default(3006),
        MONGODB_URL: Joi.string().required().description('Mongo DB url'),
        SECRET_ACCESS_TOKEN: Joi.string().hex().required(),
        SECRET_REFRESH_TOKEN: Joi.string().hex().required(),
    })
    .unknown();
function createConfig(configPath) {
    dotenv.config({ path: configPath });
    const { value: envVars, error } = envVarsSchema
        .prefs({ errors: { label: 'key' } })
        .validate(process.env);
    if (error) {
        throw new Error(`Config validation error: ${error.message}`);
    }
    return {
        port: envVars.PORT,
        mongo: {
            url: envVars.MONGODB_URL,
        },
        jwt: {
            access_token: envVars.SECRET_ACCESS_TOKEN,
            refresh_token: envVars.SECRET_REFRESH_TOKEN
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>This code provides an<a id="_idIndexMarker695"/> object called <code>jwt</code> to access refresh and secret tokens.</p>
			<p>As you might guess, we haven’t validated user-provided data directly. We need to validate the data, and that is why we plan to use the same structure that we used for the account microservice. Under the <code>src/middlewares</code> folder, we have the same <code>validate.js</code> file to validate our schema. That is the main reason why we haven’t implemented validation per endpoint. It is time to provide rules for email and password validation. Create <code>user.js</code> under <a id="_idIndexMarker696"/>the <code>src/validation</code> folder with the following code block:</p>
			<pre class="source-code">
const Joi = require('joi');
const loginSchema = Joi.object({
    body: Joi.object().keys({
        email: Joi.string()
            .required()
            .error(errors =&gt; {
                if (errors[0].code === 'any.required') {
                    return new Error('Email is required');
                }
                if (errors[0].code === 'string.email') {
                    return new Error('Invalid email format');
                }
                return errors;
            }),
        password: Joi.string()
            .min(6) // Minimum password length
            .required()
            .error(errors =&gt; {
                if (errors[0].code === 'any.required') {
                    return new Error('Password is required');
                }
                if (errors[0].code === 'string.min') {
                    return new Error('Password must be at least 6 characters long');
                }
                return errors;
            })
    })
});
module.exports = { loginSchema };</pre>			<p>This code snippet uses <code>Joi</code> to define a validation schema specifically for login requests in your application. It focuses on the request body, ensuring it contains a valid email address and password<a id="_idIndexMarker697"/> that meets the minimum length requirement (defined as six characters in this example). The schema also provides informative custom error messages for missing or invalid email and password, improving the user experience by guiding them toward proper credential format. By implementing this validation, you can prevent malformed login requests from reaching your backend logic and enhance the overall security of your application.</p>
			<p>We can directly provide routing in our controllers but we will follow the same convention we did before when we implemented the account microservice. So, under the <code>routes/v1/users</code> folder, create an <code>index.js</code> file with the following content:</p>
			<pre class="source-code">
const { Router } = require('express');
const userController = require('../../../controllers/user');
const { loginSchema } = require('../../../validation/user');
const validate = require('../../../middlewares/validate');
const router = Router();
router.post('/register', validate(loginSchema), userController.createUser);
router.post('/login', validate(loginSchema), userController.loginUser);
module.exports = router;</pre>			<p>The code defines two endpoints. One for registration (<code>/register</code>) and the other for the login (<code>/login</code>) functionality. The <code>routes/v1</code> folder also contains the <code>index.js</code> file with the following content:</p>
			<pre class="source-code">
const { Router } = require('express');
const userRouter = require('./users');
const router = Router();
router.use('/users', userRouter);
module.exports = router;</pre>			<p>As you can see, we use<a id="_idIndexMarker698"/> the same code we used in our account microservice. We just changed the route to <code>users</code>. Now, users can access our endpoints using <code>v1/user/{endpoint_name}</code>. The last elements in our microservice are <code>app.js</code> and the root <code>index.js</code> file, which are the same as our already implemented account microservice.</p>
			<p>Let’s test our Auth microservice’s endpoints. Run <code>npm start</code> from the terminal and let’s prepare our <code>POST</code> request to create a user:</p>
			<ol>
				<li>Open the Postman application.</li>
				<li>Create a new Postman request window.</li>
				<li>Change <strong class="bold">GET</strong> to <strong class="bold">POST</strong>.</li>
				<li>Provide the endpoint URL (it is <code>http://localhost:3006/v1/users/register</code> for us).</li>
				<li>Go to <strong class="bold">Body</strong>, select <strong class="bold">raw</strong>, and select <strong class="bold">JSON</strong>.</li>
				<li>Provide a payload and click <strong class="bold">Send</strong> (<em class="italic">Figure 9</em><em class="italic">.2</em>).</li>
			</ol>
			<div><div><img alt="Figure 9.2: Successful registration" src="img/B09148_09_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Successful registration</p>
			<p>The user is ready. Now, we<a id="_idIndexMarker699"/> can get a JWT. Here are the steps to get a JWT:</p>
			<ol>
				<li>Create a new Postman request window.</li>
				<li>Change <strong class="bold">GET</strong> to <strong class="bold">POST</strong>.</li>
				<li>Provide the endpoint URL (it is <code>http://localhost:3006/v1/users/login</code> for us).</li>
				<li>Go to <strong class="bold">Body</strong>, select <strong class="bold">raw</strong>, and select <strong class="bold">JSON</strong>.</li>
				<li>Provide a payload and click <strong class="bold">Send</strong> (<em class="italic">Figure 9</em><em class="italic">.3</em>).</li>
			</ol>
			<div><div><img alt="Figure 9.3: Successful login" src="img/B09148_09_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Successful login</p>
			<p>The generated access token will expire in a given time slot (<em class="italic">Figure 9</em><em class="italic">.4</em>). After expiration, we do not <a id="_idIndexMarker700"/>need to provide an email and password to get a new access token. We can simply use a refresh token to refresh and to get a new access token.</p>
			<div><div><img alt="Figure 9.4: Message about expired token" src="img/B09148_09_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: Message about expired token</p>
			<p>But what if you want a new access token based on a refresh token? That is easy. Here’s how:</p>
			<ol>
				<li>Open a new window on Postman and set the request type to <code>v1/users/token</code> endpoint.</li>
				<li>Open the <strong class="bold">Body</strong> section and provide a refresh token. Click the <strong class="bold">Send</strong> button (<em class="italic">Figure 9</em><em class="italic">.5</em>).</li>
			</ol>
			<div><div><img alt="Figure 9.5: Getting a new access token based on the refresh token" src="img/B09148_09_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: Getting a new access token based on the refresh token</p>
			<p>Now you can use this<a id="_idIndexMarker701"/> access token to access our account microservice resources. Well, that is simply it. It is time to test the JWT in our account microservice.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Integrating token-based authentication for the account microservice</h2>
			<p>The microservices we <a id="_idIndexMarker702"/>implemented <a id="_idIndexMarker703"/>so far don’t have authentication and authorization functionalities. As homework, you can start to integrate these into them, and for learning purposes, we will implement JWT for the account microservice. Open the account microservice we developed so far. To use the same access token from the Auth microservice, the account microservice should use the same secret token. Open the <code>configs/.env</code> file and add the following line:</p>
			<pre class="source-code">
SECRET_ACCESS_TOKEN={USE_THE_SAME_TOKEN_YOU_USED_IN_AUTH_MICROSERVICE}</pre>			<p>Open the <code>config/config.js</code> file and make the following changes in order to read the secret token configuration field:</p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        ....
        SECRET_ACCESS_TOKEN: Joi.string().hex().required(),
       .....
    })
    .unknown();
function createConfig(configPath) {
    .............
    return {
        ..............
        jwt: {
            access_token: envVars.SECRET_ACCESS_TOKEN
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>The only real <a id="_idIndexMarker704"/>functionality<a id="_idIndexMarker705"/> we need to add to the account microservice is a middleware to verify our token.</p>
			<p>Under the <code>src/middlewares</code> folder, create a file called <code>verify.js</code> with the following content:</p>
			<pre class="source-code">
const jwt = require('jsonwebtoken');
const path = require('path');
const { createConfig } = require('../config/config');
const verifyJWT = (req, res, next) =&gt; {
    const authHeader = req.headers.authorization;
    // Check for presence and format of Authorization header
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        message: 'Unauthorized: Missing JWT token',});
    }
    const token = authHeader.split(' ')[1];
    const configPath = path.join(__dirname, '../../configs/.env');
    const appConfig = createConfig(configPath);
    // Verify the JWT token
    jwt.verify(token, appConfig.jwt.access_token, (err, decoded) =&gt; {
      if (err) {
        // Handle JWT verification errors
        if (err.name === 'JsonWebTokenError') {
          return res.status(401).json({
            message: 'Unauthorized: Invalid JWT token format',
          });
        } else if (err.name === 'TokenExpiredError') {
            return res.status(401).json({
              message: 'Unauthorized: JWT token expired',
            });
          } else {
              // Handle other errors (e.g., signature verification failure)
              console.error('JWT verification error:', err);
              return res.status(500).json({
                message: 'Internal Server Error',});
          }
      }
      // Attach decoded user information to the request object
      req.user = decoded;
      next(); // Allow the request to proceed
    });
};
module.exports = verifyJWT;</pre>			<p>This code defines <a id="_idIndexMarker706"/>a <a id="_idIndexMarker707"/>middleware function named <code>verifyJWT</code> for Express.js applications. It handles JWT verification for incoming requests. It checks if the authorization header exists in the request and starts with <code>Bearer</code>. If not, it returns a <code>401 Unauthorized</code> response indicating a missing JWT.</p>
			<p>If the header is present and formatted correctly, it extracts the JWT itself from the authorization header. Our middleware constructs the path to the environment variable file containing the JWT secret key. It calls a function (likely from a separate <code>config</code> module) to read and parse the configuration.</p>
			<p>Then, we use <code>jsonwebtoken.verify()</code> to verify the extracted token against the secret key retrieved from the configuration. If verification fails (<code>err</code>), it checks the error type:</p>
			<ul>
				<li><code>JsonWebTokenError</code>: Indicates invalid token format, returning <code>401</code> with a specific message</li>
				<li><code>TokenExpiredError</code>: Indicates an expired token, returning <code>401</code> with a specific message</li>
				<li>Other errors (e.g., signature verification failure) are logged and a generic <code>500 Internal Server Error</code> response is sent for security reasons</li>
			</ul>
			<p>If verification is successful (<code>!err</code>), it attaches the decoded user information from the JWT to the <code>req.user</code> object for further access within your application logic.</p>
			<p>Finally, it calls <code>next()</code> to allow the request to proceed to the intended route handler.</p>
			<p>Overall, this middleware <a id="_idIndexMarker708"/>acts <a id="_idIndexMarker709"/>as a gatekeeper, ensuring that only requests with valid JWTs can access protected resources in your application.</p>
			<p>In order to use our middleware, we import it in our <code>app.js</code> file and use it:</p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const consumerModule = require('./modules/kafkamodule');
const morganMiddleware = require('./middlewares/morganmiddleware');
const jwtVerifyMiddleware = require('./middlewares/verify');
const app = express();
app.use(jwtVerifyMiddleware);
app.use(morganMiddleware);
consumerModule();
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>The code imports our middleware and uses it. Now, let’s run the account microservice and try to get all <a id="_idIndexMarker710"/>account<a id="_idIndexMarker711"/> information. Do the following operations:</p>
			<ol>
				<li>Navigate to the <code>Ch09/accountservice</code> folder.</li>
				<li>To run the account microservice properly, you also need to run the <code>docker-compose</code> file from the root folder using the <code>docker-compose up -</code><code>d</code> command.</li>
				<li>After executing both <code>docker-compose</code> setups, start the account microservice by running the <code>npm </code><code>start</code> command.</li>
				<li>Open Postman and send a <code>GET</code> request to <code>v1/accounts</code> (in our case, it is <code>http://localhost:3001/v1/accounts</code>).</li>
				<li>You will get a message about an unauthorized request (<em class="italic">Figure 9</em><em class="italic">.6</em>).</li>
			</ol>
			<div><div><img alt="Figure 9.6: Unauthorized access" src="img/B09148_09_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: Unauthorized access</p>
			<ol>
				<li value="6">Now, run our Authentication microservice and do the steps we mentioned in the Auth microservice to get an access token (<em class="italic">Figure 9</em><em class="italic">.3</em>). For the same query for the <a id="_idIndexMarker712"/>account <a id="_idIndexMarker713"/>microservice, just open the <strong class="bold">Authorization</strong> section from Postman, change the type of authorization to <strong class="bold">Bearer Token</strong>, and paste the token you get from the Authentication service into the input (<em class="italic">Figure 9</em><em class="italic">.7</em>).</li>
			</ol>
			<div><div><img alt="Figure 9.7: Accessing the account microservice" src="img/B09148_09_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: Accessing the account microservice</p>
			<ol>
				<li value="7">Press the <strong class="bold">Send</strong> button and here we are:</li>
			</ol>
			<div><div><img alt="Figure 9.8: Getting account microservice resources" src="img/B09148_09_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: Getting account microservice resources</p>
			<p>If you’ve followed the steps correctly, you should now be able to retrieve account data. In the next <a id="_idIndexMarker714"/>chapter, we’ll <a id="_idIndexMarker715"/>dive into observability and explore how to implement it using the ELK stack.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Summary</h1>
			<p>This chapter explored the fundamental security concepts of authentication, authorization, and their role in securing microservices. We clarified the importance of verifying user identities (authentication) and determining access permissions (authorization) for robust system protection.</p>
			<p>To achieve this, we implemented a dedicated microservice for issuing access tokens (JWTs) and refresh tokens. JWTs grant temporary access, while refresh tokens allow users to obtain new access tokens without re-entering credentials. A practical demonstration showcased how this microservice interacts with another microservice, the account microservice.</p>
			<p>In our next chapter, we will explore the monitoring of microservices and its significance in microservice architectures. We will implement logging functionality within the account microservice and integrate it with the <strong class="bold">Elasticsearch, Logstash, and Kibana</strong> (<strong class="bold">ELK</strong>) stack. This will establish a centralized logging system, enabling efficient log collection, analysis, and visualization.</p>
		</div>
	</body></html>