<html><head></head><body>
		<div id="_idContainer097">
			<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor147"/>9</h1>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Securing Microservices</h1>
			<p>In today’s digital world, many applications are built from smaller, independent services working together. These <em class="italic">microservices</em> offer flexibility and scalability, but keeping them secure is crucial. Imagine a microservice as a small shop on a busy street. You want to ensure that only authorized customers can enter (authentication) and only those with permission can access specific areas (authorization). Likewise, you’d encrypt sensitive information such as credit card details (data encryption). By constantly monitoring for suspicious activity and keeping the shops updated (patching), you can maintain a safe and secure shopping experience. This chapter will guide you through securing your microservices using similar practical strategies <span class="No-Break">and more!</span></p>
			<p>This chapter covers the <span class="No-Break">following topics:</span></p>
			<ul>
				<li> Security, authentication, and authorization <span class="No-Break">in microservices</span></li>
				<li>Getting started with JSON <span class="No-Break">Web Tokens</span></li>
				<li>Implementing an <span class="No-Break">Authentication Microservice</span></li>
			</ul>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Technical requirements</h1>
			<p>To follow along in the chapter, you need to have installed an IDE (we prefer Visual Studio Code), Postman, Docker, and a browser of <span class="No-Break">your choice.</span></p>
			<p>It is preferable to download our repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09</a> to easily follow our <span class="No-Break">code snippets.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Security, authentication, and authorization in microservices</h1>
			<p>In a microservices architecture, ensuring robust security, authentication, and authorization is crucial due to the distributed nature of the system. Implementing these mechanisms properly protects microservices from unauthorized access, ensuring data integrity and confidentiality across <span class="No-Break">the system.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Understanding security</h2>
			<p>In microservices, <strong class="bold">security</strong> refers<a id="_idIndexMarker643"/> to the measures and practices used to protect<a id="_idIndexMarker644"/> the system’s components, data, and communication channels from unauthorized access, breaches, and attacks. It involves securing each service individually, as well as the interactions between services, ensuring data is safe both in transit and at rest. Security in microservices typically includes mechanisms such as encryption, authentication, authorization, and monitoring to safeguard the system <span class="No-Break">against vulnerabilities.</span></p>
			<p>Microservices, while offering advantages in flexibility and scalability, introduce unique security challenges. Unlike monolithic applications with a single attack surface, microservices create a distributed system with many potential entry points for attackers. That is why security becomes even more important compared to monolithic applications. A security breach in one microservice can quickly compromise the entire system. Before deploying our services, we should provide a properly tested and fully functional security layer over <span class="No-Break">our microservices.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Exploring authentication</h2>
			<p><strong class="bold">Authentication</strong> is a process <a id="_idIndexMarker645"/>of verifying a user’s or service’s<a id="_idIndexMarker646"/> identity, and it plays a critical role in securing microservice applications. In a world of distributed systems with numerous access points, authentication ensures that only authorized users and services can interact with <span class="No-Break">your microservices.</span></p>
			<p>But why is authentication valuable in microservices? Let’s answer this <span class="No-Break">question here:</span></p>
			<ul>
				<li><strong class="bold">Enhanced security</strong>: Microservices create a distributed attack surface. Robust authentication acts as a gatekeeper, preventing unauthorized access and <span class="No-Break">potential breaches.</span></li>
				<li><strong class="bold">Granular control</strong>: Authentication allows you to define access levels for different users and services. This ensures that only authorized entities can perform specific actions within <span class="No-Break">each microservice.</span></li>
				<li><strong class="bold">Improved trust</strong>: By implementing strong authentication, you build trust with users and external systems relying on your microservices. They can be confident their data <span class="No-Break">is secure.</span></li>
				<li><strong class="bold">Microservice communication security</strong>: Authentication secures communication between microservices themselves. This prevents unauthorized services from impersonating legitimate ones and gaining access to <span class="No-Break">sensitive data.</span></li>
			</ul>
			<p>Applying authentication is not hard thanks to the packages of Node.js but there are some microservice and authentication challenges you should consider before starting to apply it. We will discuss two of them in <span class="No-Break">this section.</span></p>
			<p>The first challenge is choosing <a id="_idIndexMarker647"/>either a <strong class="bold">centralized</strong> or <strong class="bold">decentralized</strong> authentication<a id="_idIndexMarker648"/> service. Deciding on a centralized authentication service or embedding it within each microservice can be a challenge. There’s a trade-off between simplicity and potential bottlenecks. Let’s<a id="_idIndexMarker649"/> look<a id="_idIndexMarker650"/> at both of these types of <span class="No-Break">services here:</span></p>
			<ul>
				<li>A centralized authentication service, also known <a id="_idIndexMarker651"/>as an <strong class="bold">Identity Provider</strong> (<strong class="bold">IdP</strong>), is a trusted third-party system that manages the authentication process for users across multiple applications or microservices. Instead of each microservice handling authentication independently, the IdP takes on this responsibility, offering a consistent, secure, and streamlined <span class="No-Break">authentication mechanism.</span></li>
				<li>A decentralized authentication service involves each microservice independently managing its own authentication process. Unlike a centralized system where a single IdP handles authentication, decentralized services allow each microservice to have its own embedded authentication logic, providing greater autonomy and flexibility to each service but introducing complexity in <span class="No-Break">maintaining consistency.</span></li>
			</ul>
			<p>When choosing between centralized and decentralized authentication, consider factors such as application complexity, scalability needs, security tolerance, and development resources, as a centralized IdP simplifies security enforcement but adds complexity, while decentralized options require more development effort <span class="No-Break">per microservice.</span></p>
			<p>If you cannot pick one or the other, a <em class="italic">hybrid</em> approach might be more suited for your case. A hybrid approach can be a good option in some cases. A central IdP can handle user authentication and issue tokens, while individual microservices validate those tokens independently. This offers a balance between security, flexibility, and resilience. As we mentioned before, there’s no one-size-fits-all solution. Evaluate your specific requirements and choose the approach that best aligns with your security goals and <span class="No-Break">development needs.</span></p>
			<p>The second challenge can be session management. Traditional session management techniques might<a id="_idIndexMarker652"/> not be ideal for the stateless nature of microservices. Alternatives such as <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) are <a id="_idIndexMarker653"/>often preferred. We <a id="_idIndexMarker654"/>will talk about JWTs in more detail later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Defining authorization</h2>
			<p><strong class="bold">Authorization</strong> in microservices<a id="_idIndexMarker655"/> is critical for several reasons, primarily <a id="_idIndexMarker656"/>focusing on security, resource management, and compliance. It ensures that only users or services with the appropriate permissions can access or perform actions on specific resources or data. This prevents unauthorized access and potential misuse. By <em class="italic">enforcing</em> strict access controls, the potential attack surface is minimized. Unauthorized users are restricted from accessing sensitive parts of the system, reducing the risk of data breaches and other <span class="No-Break">malicious activities.</span></p>
			<p>Microservices often deal with a wide range of functionalities and data. Authorization allows for granular control over who can access which service and what operations they can perform, ensuring resources are used appropriately. By <em class="italic">defining</em> clear access controls, resources are allocated and utilized more efficiently, preventing unauthorized consumption of resources that could degrade <span class="No-Break">system performance.</span></p>
			<p>In a microservice architecture, each microservice is designed to perform a specific function. Authorization ensures that each service has access only to the data and operations it requires, promoting the principle of least privilege. This minimizes potential security risks and helps to maintain a secure, <span class="No-Break">efficient system.</span></p>
			<p>Centralized authorization management can further streamline this process by defining and enforcing access policies uniformly across all services. This approach simplifies the maintenance and updating of access controls, making it easier to ensure consistency across the <span class="No-Break">microservices ecosystem.</span></p>
			<p>There are various ways to implement authorization, such as <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>), <strong class="bold">Attribute-Based Access Control</strong> (<strong class="bold">ABAC</strong>), and <strong class="bold">Policy-Based Access Control</strong> (<strong class="bold">PBAC</strong>). While<a id="_idIndexMarker657"/> these are out of<a id="_idIndexMarker658"/> the scope of this book, by adopting the appropriate method, you<a id="_idIndexMarker659"/> can ensure that your system’s security policies are both robust and <a id="_idIndexMarker660"/>adaptable <a id="_idIndexMarker661"/>to your <span class="No-Break">specific requirements.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Best practices for authorization</h2>
			<p>Best practices are <a id="_idIndexMarker662"/>essential to ensure robust security, consistency, and<a id="_idIndexMarker663"/> efficiency in managing access controls and authorization across microservices. Let’s look at some of these best <span class="No-Break">practices here:</span></p>
			<ul>
				<li><strong class="bold">Least privilege principle</strong>: Give only the permissions that users or services need to do their jobs, which helps reduce the chance of <span class="No-Break">unauthorized access.</span></li>
				<li><strong class="bold">Centralized authorization management</strong>: Use a single system to manage who can access what across all microservices, making it easier to maintain and <span class="No-Break">ensure security.</span></li>
				<li><strong class="bold">Regular audits and reviews</strong>: Check and review who has access to what regularly to make sure everything is safe and up <span class="No-Break">to date.</span></li>
				<li><strong class="bold">Reserve access</strong>: Set permissions based on roles so users and services only have access to what matches <span class="No-Break">their responsibilities.</span></li>
				<li><strong class="bold">Token expiration and revocation</strong>: Use tokens that expire quickly and have a way to cancel them if needed, to lower the risk if a token <span class="No-Break">is compromised.</span></li>
			</ul>
			<p>We delved into the critical importance of authorization in microservices and its role in maintaining security, resource management, and compliance. Now, let’s differentiate between authorization <span class="No-Break">and authentication.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Difference between authentication and authorization</h2>
			<p>In microservices<a id="_idIndexMarker664"/> architectures, authorization <a id="_idIndexMarker665"/>plays a critical role in securing access to resources and data. Before diving into details, we need to understand and differentiate between the terms <strong class="bold">authentication</strong> and <strong class="bold">authorization</strong>. Authentication verifies the identity of a user or service trying to access the system. It typically involves checking credentials such as usernames and passwords, API keys, or tokens issued by an authorization server. It is similar to checking your ID at the entrance of <span class="No-Break">a building.</span></p>
			<p>On the other hand, authorization determines what actions a verified user or service can perform within the system. It Involves enforcing predefined rules based on user roles, permissions, or attributes associated with the request. It is similar to how, once you’re verified to enter the building (authentication), your access card determines which floors or areas you <a id="_idIndexMarker666"/>can <span class="No-Break">enter (authorization).</span></p>
			<p>Here are the key differences between authentication <span class="No-Break">and authorization:</span></p>
			<ul>
				<li><strong class="bold">Objective</strong>: Authentication answers <em class="italic">Who are you?</em>, while authorization answers <em class="italic">What can </em><span class="No-Break"><em class="italic">you do?</em></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Timing</strong>: Authentication typically happens first, followed by authorization checks on <span class="No-Break">specific actions.</span></li>
				<li><strong class="bold">Focus</strong>: Authentication deals with identity verification, while authorization focuses on <span class="No-Break">access control.</span></li>
			</ul>
			<p class="callout-heading"><strong class="bold">Microservices and authorization</strong>: </p>
			<p class="callout">In monolithic systems, authorization is often centralized. But microservices, with their distributed nature, require a more distributed approach to authorization. Here are some <span class="No-Break">common strategies:</span></p>
			<p class="callout"><strong class="bold">•  Per-service authorization</strong>: Each microservice manages authorization for its resources <span class="No-Break">and data.</span></p>
			<p class="callout"><strong class="bold">•  API gateway</strong>: A central API gateway can handle authorization checks before routing requests to <span class="No-Break">individual services</span></p>
			<p class="callout"><strong class="bold">•  Dedicated authorization service</strong>: A separate service manages authorization policies and enforces them across <span class="No-Break">all microservices</span></p>
			<p>Which one to select? Well, choosing the right approach depends on factors such as the complexity of your system, security requirements, and scalability needs. As we mentioned before, let’s learn about the JWT together. A JWT is widely used for authentication and <a id="_idIndexMarker667"/>authorization <a id="_idIndexMarker668"/>purposes in distributed systems such as microservices because it is stateless, meaning the server does not need to store <span class="No-Break">session data.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor156"/>Getting started with JWTs</h1>
			<p>The real world is constantly<a id="_idIndexMarker669"/> changing, and programs need to be adaptable to handle different situations. The elements of programs are also evaluated. The technique you used 10 years ago may not be <span class="No-Break">valid nowadays.</span></p>
			<p>Years ago, we used to <a id="_idIndexMarker670"/>use <strong class="bold">session-based authorization</strong>, which was simple, popular, easy to grasp, and easy to adapt. It is still a topic for discussion but we mostly prefer to use different types of authentication techniques that are more secure. Before switching to JWT, it is helpful to talk about <span class="No-Break">session-based authentication.</span></p>
			<p>In this type of authentication, you enter your username and password. The server checks whether your credentials are valid. If valid, the server creates a session with a unique identifier (session ID). This session ID might be stored in a cookie on your browser. With each request to the website during that session, your browser sends the session ID back to the server. The server checks the session ID and grants access if it’s valid, allowing you to stay logged in. The session expires after a period of inactivity (e.g., 30 minutes) or when you log out. This invalidates the <span class="No-Break">session ID.</span></p>
			<p>On the other <a id="_idIndexMarker671"/>hand, <strong class="bold">token-based authentication</strong> offers several advantages over session-based authentication. Your sessions rely on the server storing information about each active user. This can become burdensome for applications with a large user base. Tokens, stored on the client side, alleviate this pressure on <span class="No-Break">the server.</span></p>
			<p>The second important difference is that session-based authentication requires the server to maintain session data for each user. Token-based authentication is stateless, meaning the server only verifies the token itself, not referencing any stored user data. This simplifies server architecture and potentially <span class="No-Break">improves performance.</span></p>
			<p>From the security perspective, tokens can be self-contained, including information such as expiry time and user roles. This reduces reliance on cookies, which can be vulnerable to theft. Additionally, tokens can be configured for short lifespans, minimizing the window of opportunity <span class="No-Break">if compromised.</span></p>
			<p>Another important feature of tokens is flexibility. Tokens, such as JWTs, can embed additional data beyond just user identity. This allows for more granular control over access and simplifies authorization processes. Tokens can also be used for API calls between different services, whereas sessions are typically tied to a specific web application. JWTs are a compact, URL-safe means of representing claims to be transferred between two parties. It is commonly used for authorization purposes. A JWT is composed of three parts: header, payload, and signature. These parts are separated by dots (<strong class="source-inline">.</strong>) and encoded in Base64 <span class="No-Break">URL format.</span></p>
			<p>The <strong class="bold">header</strong> typically <a id="_idIndexMarker672"/>consists of two parts: the type of <a id="_idIndexMarker673"/>token (JWT) and the signing algorithm being used, such as <em class="italic">HMAC</em>-<em class="italic">SHA256</em> or <em class="italic">RSA</em>. Here is an example of <span class="No-Break">a header:</span></p>
			<pre class="source-code">
{
  "alg": "HS256",
  "typ": "JWT"
}</pre>			<p>The <strong class="bold">payload</strong> contains <a id="_idIndexMarker674"/>the claims. <strong class="bold">Claims</strong> are <a id="_idIndexMarker675"/>statements about an entity (typically, the user) and additional data. There are three types <span class="No-Break">of claims:</span></p>
			<ul>
				<li><strong class="bold">Registered claims</strong>: Predefined claims that are not mandatory but recommended, such as <strong class="source-inline">iss</strong> (issuer), <strong class="source-inline">exp</strong> (expiration time), <strong class="source-inline">sub</strong> (subject), and <span class="No-Break"><strong class="source-inline">aud</strong></span><span class="No-Break"> (audience).</span></li>
				<li><strong class="bold">Public claims</strong>: Custom claims that can be defined by users. They should be collision-resistant names, such as using a URI or a namespace to <span class="No-Break">avoid conflicts.</span></li>
				<li><strong class="bold">Private claims</strong>: Custom claims are created to share information between parties that agree to <span class="No-Break">use them.</span></li>
			</ul>
			<p>Here is an example of <span class="No-Break">a payload:</span></p>
			<pre class="source-code">
{
  "sub": "1234567890",
  "name": "David West",
  "admin": true,
  "iat": 1516239022
}</pre>			<p>The last element is <a id="_idIndexMarker676"/>the <strong class="bold">signature</strong>. To create the signature part, you have to take the encoded header, the encoded payload, a secret, and the algorithm specified in the header. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn’t changed along <span class="No-Break">the way.</span></p>
			<p>For example, if you<a id="_idIndexMarker677"/> use the <em class="italic">HMAC-SHA256</em> algorithm, the signature will be created <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)</pre>			<p>The output of the algorithm is three Base64-URL strings joined by dots that can be easily passed in HTML and <span class="No-Break">HTTP environments.</span></p>
			<p>Here is an example of <span class="No-Break"><em class="italic">HMAC-SHA256</em></span><span class="No-Break"> output:</span></p>
			<pre class="console">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibm FtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.SflKxw RJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</pre>			<p>Now that we have understood the various components of a JWT, let’s look at how it works in authentication with the help of the preceding example. A user logs in using their credentials. The server verifies the credentials and issues a JWT signed with a secret key. The client (usually a browser) stores the JWT (typically in local storage or <span class="No-Break">a cookie).</span></p>
			<p>The client sends the JWT in the <strong class="source-inline">Authorization</strong> header of each subsequent request to access <span class="No-Break">protected resources:</span></p>
			<pre class="source-code">
Authorization: Bearer &lt;token&gt;</pre>			<p>Then, it does token verification where the server verifies the token’s signature and checks its validity (expiration, issuer, etc.). If the token is valid, the server processes the request. Before moving on, it’s important to note that JWTs are stateless, compact, and self-contained, making them efficient for securely transmitting user information without server-side session storage. When using JWTs, ensure the secret key is secure, always transmit tokens over HTTPS, and use short-lived tokens with periodic refreshes to mitigate security risks. Now we know that JWTs are a powerful and flexible way to handle authentication and authorization in modern web applications, providing both security <span class="No-Break">and convenience.</span></p>
			<p>Now that we’ve <a id="_idIndexMarker678"/>covered the theory, let’s move on to the practical part and implement the authentication <span class="No-Break">microservice together.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor157"/>Implementing an Authentication microservice</h1>
			<p>In microservices<a id="_idIndexMarker679"/> development, it’s a common practice to develop a separate microservice for authentication and authorization (often referred to as an Auth service). Here’s why <span class="No-Break">it’s valuable:</span></p>
			<ul>
				<li><strong class="bold">Centralized security management</strong>: Having a dedicated Auth service allows us to manage authentication and authorization logic in one place. This simplifies updates and security audits and ensures consistent rules across <span class="No-Break">all microservices.</span></li>
				<li><strong class="bold">Scalability</strong>: The Auth service can be scaled independently based on its load, separate from other microservices with different <span class="No-Break">resource requirements.</span></li>
				<li><strong class="bold">Reusability</strong>: The Auth service can be reused by all your other microservices, reducing code duplication and <span class="No-Break">promoting consistency.</span></li>
				<li><strong class="bold">Improved maintainability</strong>: Isolating authentication logic makes it easier to maintain and update the security aspects of <span class="No-Break">your system.</span></li>
				<li><strong class="bold">Separation of concerns</strong>: Decoupling authentication and authorization from other microservices keeps their responsibilities focused, promoting cleaner code and <span class="No-Break">better maintainability.</span></li>
				<li><strong class="bold">Flexibility</strong>: A dedicated Auth service can be designed to support different authentication flows (e.g., OAuth, JWT) and authorization strategies (e.g., RBAC), providing a flexible foundation for your <span class="No-Break">microservices architecture.</span></li>
			</ul>
			<p>Let’s implement our Auth microservice together. We will use a classical approach to develop our new microservice via ExpressJS as we did before. Most of the things are the same. You should open/create a new folder anywhere you want on your computer and type <strong class="source-inline">npm init -y</strong> to initialize start our project. Throughout our development process, we will use the following libraries: <strong class="source-inline">bcryptjs</strong>, <strong class="source-inline">dotenv</strong>, <strong class="source-inline">express</strong>, <strong class="source-inline">joi</strong>, <strong class="source-inline">jsonwebtoken</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">mongoose</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">npm init -y</strong> command does not automatically generate the scripts section in <strong class="source-inline">package.json</strong>. You’ll need to add it manually to simplify running <span class="No-Break">the application.</span></p>
			<p>Let’s walk through<a id="_idIndexMarker680"/> our <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<ul>
				<li><strong class="source-inline">bcryptjs</strong>: This library provides secure password hashing and comparison functionalities. It allows you to store passwords securely in your database and verify user login attempts against the <span class="No-Break">hashed passwords.</span></li>
				<li><strong class="source-inline">dotenv</strong>: This library helps you load environment variables from a <strong class="source-inline">.env</strong> file. This is a secure way to store sensitive information such as API keys, database credentials, and your JWT secret key, keeping them out of <span class="No-Break">your code.</span></li>
				<li><strong class="source-inline">express</strong>: This is a popular Node.js web framework that helps you build web applications and APIs. It provides a structured approach for handling requests, routing, middleware, <span class="No-Break">and responses.</span></li>
				<li><strong class="source-inline">joi</strong>: This library offers schema validation for data coming into your application. You can define validation rules for request bodies and ensure that the data received adheres to your expected format and structure, improving data integrity and preventing <span class="No-Break">potential errors.</span></li>
				<li><strong class="source-inline">jsonwebtoken</strong> (JWT): This library helps you work with JWTs. It allows you to generate tokens for authentication purposes, containing user information in a secure and verifiable format. You can use JWTs to authorize users for access to protected resources in <span class="No-Break">your microservices.</span></li>
				<li><strong class="source-inline">mongoose</strong>: This is <a id="_idIndexMarker681"/>an <strong class="bold">Object Data Modeling</strong> (<strong class="bold">ODM</strong>) library for MongoDB in Node.js. It provides a convenient way to interact with your MongoDB database by mapping your application data models to MongoDB documents. It simplifies data manipulation <span class="No-Break">and retrieval.</span></li>
			</ul>
			<p>We need a secure way to store user information, and a database is commonly used for this purpose. The <strong class="source-inline">mongoose</strong> package will help us to work with the database. To connect and disconnect from the database, create a new file called <strong class="source-inline">index.js</strong> under the <strong class="source-inline">src/db</strong> folder with the same<a id="_idIndexMarker682"/> content as we have in <a href="B09148_05.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
			<p>Under the <strong class="source-inline">src/models</strong> folder, create a new file called <strong class="source-inline">user.js</strong> with the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const userSchema = new mongoose.Schema({
    email: {
        type: String,
        required: true,
        unique: true
    },
    password: {
        type: String,
        required: true
    }
});
// Hash password before saving
userSchema.pre('save', async function (next) {
    if (this.isModified('password')) {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
    }
    next();
});
module.exports = mongoose.model('User', userSchema);</pre>			<p>You can extend this schema with additional information but to demo authentication and authorization, we need only <span class="No-Break">these fields.</span></p>
			<p>We have already talked about <strong class="source-inline">mongoose</strong> in our previous chapters and that is why we will bypass already known details. The only new logic here is working with a hash password. When we<a id="_idIndexMarker683"/> create a user via API, we will provide an email and password. For security reasons, we need to hash passwords before storing them in <span class="No-Break">our database.</span></p>
			<p>The code that starts with <strong class="source-inline">userSchema.pre("…")</strong> is a <strong class="source-inline">mongoose</strong> middleware function that is executed before a user document is saved to the database. This middleware ensures that passwords are never stored in plain text in our database. It securely hashes passwords before saving them, making it computationally infeasible to recover the original password from the <span class="No-Break">stored hash.</span></p>
			<p>Now, we need to provide a service layer that interacts with the database. For simplicity, you can bypass this layer, but to provide a full picture, we will have it. Under the <strong class="source-inline">src/services</strong> folder, create a new file called <strong class="source-inline">user.js</strong> with the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
const User = require('../models/user');
const createUser = async (userData) =&gt; {
    const user = new User(userData);
    await user.save();
    return user;
};
const getUserById = async (userId) =&gt; {
    return await User.findById(userId);
};
const getUserByEmail = async (email) =&gt; {
    return await User.findOne({ email: email });
};
// ... Add methods for other user operations (e.g., update, delete)
module.exports = { createUser, getUserById, getUserByEmail };</pre>			<p>To make things <a id="_idIndexMarker684"/>simple, we haven’t implemented full CRUD operations. To demo our functionality, we only need a few of them such as <strong class="source-inline">create</strong> and <span class="No-Break"><strong class="source-inline">get user</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s switch to our controller and see how we create a user. Under the <strong class="source-inline">src/controllers</strong> folder, create a new file called <strong class="source-inline">user.js</strong> with the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
const userService = require('../services/user');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const path = require('path');
const { createConfig } = require('../config/config');
// Register a new user
const createUser = async (req, res) =&gt; {
    try {
        const { email, password } = req.body;
        const existingUser = await userService.getUserByEmail(email);
        if (existingUser) {
            return res.status(400).json({ message: 'Email already 
              exists' });
        }
        const user = await userService.createUser({ email, password 
          });
        res.status(201).json({ message: 'User created successfully', 
          user: user });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>This code snippet defines <a id="_idIndexMarker685"/>an asynchronous function named <strong class="source-inline">createUser</strong> that handles user registration in your Node.js application. Here are <span class="No-Break">the details:</span></p>
			<ul>
				<li><strong class="source-inline">const createUser = async (req, res) =&gt; { ... }</strong>: This defines an asynchronous function named <strong class="source-inline">createUser</strong> that takes two arguments, <strong class="source-inline">req</strong> (request object) and <strong class="source-inline">res</strong> (<span class="No-Break">response object).</span></li>
				<li><strong class="source-inline">const { email, password } = req.body;</strong>: This extracts the <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> properties from the request body (<strong class="source-inline">req.body</strong>). These are assumed to be sent by the client in the <span class="No-Break">registration request.</span></li>
				<li><strong class="source-inline">const existingUser = await userService.getUserByEmail(email);</strong>: This calls a function from <strong class="source-inline">userService</strong> (to check whether a user with the provided email already exists. It awaits the <span class="No-Break">result (</span><span class="No-Break"><strong class="source-inline">existingUser</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">if (existingUser) { ... }</strong>: If <strong class="source-inline">existingUser</strong> is not <strong class="source-inline">null</strong> (meaning a user with the email exists), it returns a <strong class="source-inline">400 Bad Request</strong> response with a message indicating the <span class="No-Break">email conflict.</span></li>
				<li><strong class="source-inline">const user = await userService.createUser({ email, password });</strong>: If the email is unique, it calls another function from <strong class="source-inline">userService</strong> (likely<a id="_idIndexMarker686"/> for user creation) with an object containing the extracted email and password. It awaits the result (<strong class="source-inline">user</strong>), which is the newly created <span class="No-Break">user document.</span></li>
				<li><strong class="source-inline">.status(201).json({ message: 'User created successfully', user: user });</strong>: If user creation is successful, it sends a <strong class="source-inline">201 Created</strong> response with a message and the newly created user object (<strong class="source-inline">user</strong>) in the <span class="No-Break">response body.</span></li>
				<li>A <strong class="source-inline">try...catch</strong> block: This wraps the core logic in a <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> block to handle any potential errors during the <span class="No-Break">registration process.</span></li>
				<li><strong class="source-inline">res.status(500).json({ message: 'Server error' });</strong>: This sends a generic <strong class="source-inline">500 Internal Server Error</strong> response in case of <span class="No-Break">any errors.</span></li>
				<li><strong class="source-inline">createUser</strong>: This function provides a basic structure for user registration in our application. It checks for email conflicts, delegates user creation logic to a separate service, and handles successful and error scenarios with <span class="No-Break">appropriate responses.</span></li>
			</ul>
			<p>But creating a user is not enough. We need to implement sign-in/log-in functionality. In the same file, we <a id="_idIndexMarker687"/>have the following code to <span class="No-Break">log in:</span></p>
			<pre class="source-code">
const loginUser = async (req, res) =&gt; {
    try {
        const { email, password } = req.body;
        // Fetch user by email
        const user = await userService.getUserByEmail(email);
        if (!user) {
            return res.status(401).json({ message: 'Invalid email or 
              password' }); // Use 401 for unauthorized
        }
        // Compare password hashes securely using bcrypt
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(401).json({ message: 'Invalid email or 
              password' });
        }
        const configPath = path.join(__dirname, '../../configs/.env');
        const appConfig = createConfig(configPath);
        const payload = { userId: user._id }; // Include only essential user data
        const jwtSecret = appConfig.jwt.access_token; // Replace with your secret from an environment variable
        const accessToken = await jwt.sign(payload, jwtSecret, { 
          expiresIn: '1h' }); // Set appropriate expiration time
        // Send successful login response
        res.status(200).json({ accessToken: accessToken });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>The code defines an asynchronous function named <strong class="source-inline">loginUser</strong> that handles user login in your Express.js <a id="_idIndexMarker688"/>application. Here’s a breakdown of what <span class="No-Break">it does:</span></p>
			<ul>
				<li><strong class="source-inline">const loginUser = async (req, res) =&gt; { ... }</strong>: This defines an asynchronous function named <strong class="source-inline">loginUser</strong> that takes two arguments, <strong class="source-inline">req</strong> (request object) and <strong class="source-inline">res</strong> (<span class="No-Break">response object).</span></li>
				<li><strong class="source-inline">const { email, password } = req.body;</strong>: This extracts the <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> properties from the request body (<strong class="source-inline">req.body</strong>). These are assumed to be sent by the client in the <span class="No-Break">login request.</span></li>
				<li><strong class="source-inline">const user = await userService.getUserByEmail(email);</strong>: This calls a function from <strong class="source-inline">userService</strong> (likely another module) to fetch a user with the provided email. It awaits the <span class="No-Break">result (</span><span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">if (!user) { ... }</strong>: If <strong class="source-inline">user</strong> is <strong class="source-inline">null</strong> (meaning no user found with the email), it returns a <strong class="source-inline">401 Unauthorized</strong> response with a message indicating <span class="No-Break">invalid credentials.</span></li>
				<li><strong class="source-inline">const isMatch = await bcrypt.compare(password, user.password);</strong>: This uses <strong class="source-inline">bcrypt.compare</strong> to compare the provided password with the hashed password stored in the fetched user document (<strong class="source-inline">user.password</strong>). It awaits the result (<strong class="source-inline">isMatch</strong>), which is a boolean indicating whether the <span class="No-Break">passwords match.</span></li>
				<li><strong class="source-inline">if (!isMatch) { ... }</strong>: If <strong class="source-inline">isMatch</strong> is <strong class="source-inline">false</strong> (meaning passwords don’t match), it returns a <strong class="source-inline">401 Unauthorized</strong> response with a message indicating <span class="No-Break">invalid credentials.</span></li>
				<li><strong class="source-inline">const configPath = path.join(__dirname, '../../configs/.env');</strong>: This constructs the path to the environment variable file (assuming it’s located four folders above the <span class="No-Break">current file).</span></li>
				<li><strong class="source-inline">const appConfig = createConfig(configPath);</strong>: This calls a function to read and parse the environment variables from the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">env</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="source-inline">const payload = { userId: user._id };</strong>: This creates a payload object for the JWT containing the user’s ID. Include only essential user <span class="No-Break">data here.</span></li>
				<li><strong class="source-inline">const jwtSecret = appConfig.jwt.access_token;</strong>: This retrieves the JWT access token secret from the parsed <span class="No-Break">environment configuration.</span></li>
				<li><strong class="source-inline">const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: '1h' });</strong>: This uses <strong class="source-inline">jsonwebtoken</strong> to sign the JWT with the payload, secret, and an expiration time of one hour (<strong class="source-inline">expiresIn: '1h'</strong>). It awaits the generated <span class="No-Break">token (</span><span class="No-Break"><strong class="source-inline">accessToken</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">res.status(200).json({ accessToken: accessToken });</strong>: If login is successful, it sends a <strong class="source-inline">200 OK </strong>response with the generated <strong class="source-inline">accessToken</strong> in the <span class="No-Break">response body.</span></li>
			</ul>
			<p>Overall, the login function <a id="_idIndexMarker689"/>provides a secure login flow using JWT authentication. It fetches the user, validates credentials, generates a JWT with a secret key, and sends it back to the client for subsequent <span class="No-Break">authorized access.</span></p>
			<p>In order to have a fully functional login functionality, we need to provide the secret access token. In JWT, the secret access token plays a vital role in ensuring the integrity and authenticity of the token. When a JWT is created, a cryptographic hash algorithm (e.g., HMAC-SHA256) signs the header and payload (containing user information) using a secret access token. This secret key is like a password known only to the server that issued the JWT and the party verifying it. When a client sends a JWT in an authorization header to access a protected resource, the server receives <span class="No-Break">the token.</span></p>
			<p>The server uses the same secret access token to verify the signature of the received JWT. This verification process ensures <span class="No-Break">the following:</span></p>
			<ul>
				<li>The token has not been tampered with <span class="No-Break">in transit.</span></li>
				<li>The token was indeed issued by a trusted source (the server that knows <span class="No-Break">the secret).</span></li>
			</ul>
			<p>If the secret access token is compromised (e.g., leaked or stolen), anyone with the secret can forge valid-looking JWTs, potentially impersonating legitimate users and gaining unauthorized<a id="_idIndexMarker690"/> access to resources. Therefore, the secret access token is critical for maintaining the security of JWT-based authentication. Never store the secret access token in your code or within the application itself. Use environment variables or a dedicated secret management service to keep it confidential. Choose a cryptographically strong random string (ideally, at least 256 bits) for your secret access token to make it difficult to guess or crack. Consider rotating your secret access token periodically to mitigate the impact of a potential compromise. By following these practices, you can leverage the benefits of JWTs for secure authentication in your application while minimizing the risks associated with secret <span class="No-Break">access tokens.</span></p>
			<p>When implementing access tokens, be careful to not to generate long-lived access tokens. Long-lived access tokens pose security risks because, if stolen, they allow attackers prolonged access, and revoking them is difficult. In contrast, refresh tokens offer better security by allowing short-lived access tokens to be issued, limiting potential damage. They also enable more granular control, as compromised tokens can be individually blacklisted without affecting other tokens, reducing the need for frequent authentication and lowering <span class="No-Break">server load.</span></p>
			<p>Refresh tokens provide a good balance between user convenience (avoiding frequent logins) and security. Even though they have longer expirations compared to access tokens, their use is limited to obtaining new, short-lived <span class="No-Break">access tokens.</span></p>
			<p>Before implementing our refresh token, consider providing limited time for access tokens as short-lived access tokens reduce the risk of misuse if they are compromised, minimizing the window of opportunity for attackers. In this example, we set it to <strong class="source-inline">5</strong> minutes. After five minutes, the given access token will expire and we should send our refresh token to a new endpoint to obtain a new short-lived access token. First of all, let’s modify our login <a id="_idIndexMarker691"/>endpoint to return a <span class="No-Break">refresh token:</span></p>
			<pre class="source-code">
const jwtRefreshTokenSecret = appConfig.jwt.refresh_token;
        const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: '5m' }); // Set appropriate expiration time
        const refreshToken = await jwt.sign(payload, jwtRefreshTokenSecret, { expiresIn: '7d' });
        // Send successful login response
        res.status(200).json({ accessToken: accessToken, refreshToken: refreshToken });</pre>			<p>We use the same method to get both tokens. For refresh tokens, we set a bit longer period such as such as seven days. We will create a new endpoint to return new access tokens and that is why we need a new functionality in <span class="No-Break">our controller:</span></p>
			<pre class="source-code">
const getAccessTokenbyRefreshToken = async (req, res) =&gt; {
    try {
        const refreshToken = req.body.refreshToken;
        if (!refreshToken) {
            return res.status(400).json({ message: 'Missing refresh 
              token' });
        }
        const configPath = path.join(__dirname, '../../configs/.env');
        const appConfig = createConfig(configPath);
        const refreshTokenSecret = appConfig.jwt.refresh_token;
        // Verify the refresh token
        jwt.verify(refreshToken, refreshTokenSecret, (err, decoded) =&gt; 
          {
            if (err) {
                return res.status(401).json({ message: 'Invalid 
                  refresh token' });
            }
            const userId = decoded.userId;
            // Generate a new access token
            const newAccessTokenPayload = { userId };
            const newAccessToken = jwt.sign(newAccessTokenPayload,
              appConfig.jwt.access_token,
              { expiresIn: '5m' });
            res.status(200).json({ accessToken: newAccessToken });
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Server error' });
    }
};</pre>			<p>This function lets users get a new access token (key to access resources) by providing a refresh token (like a spare key). It checks whether the refresh token is valid using a secret key. If valid, it can generate a new, short-lived access token (with a 5-minute expiration by default) for the user. This way, users don’t need to log in frequently but still maintain security with short-lived <span class="No-Break">access tokens.</span></p>
			<p>The best practice for <a id="_idIndexMarker692"/>storing refresh tokens involves a balance between security and user convenience. Here is what you need <span class="No-Break">to know:</span></p>
			<ul>
				<li>Refresh tokens should not be stored in browser cookies due to their accessibility to JavaScript and potential theft through <span class="No-Break">XSS attacks.</span></li>
				<li>If using cookies, opt for <strong class="source-inline">HttpOnly</strong> cookies with the <strong class="source-inline">Secure</strong> flag set. This prevents JavaScript access and mitigates XSS attacks. However, this approach has limitations (e.g., not supported by all browsers in <span class="No-Break">cross-site context).</span></li>
				<li>On the other hand, local storage is a viable option, but implement security measures such as encryption at rest and in transit to protect the token if compromised. Evaluate libraries or frameworks that provide secure local <span class="No-Break">storage mechanisms.</span></li>
				<li>In some scenarios, you might consider storing refresh tokens on the server side (e.g., database) for added security or centralized management. However, this is not always necessary and <span class="No-Break">adds complexity.</span></li>
				<li>While refresh tokens have longer expirations than access tokens (e.g., days or weeks), avoid excessively long durations to minimize potential damage <span class="No-Break">if compromised.</span></li>
				<li>Implement a mechanism to blacklist refresh tokens after a period of inactivity (e.g., a week) or upon user logout. This prevents attackers from using stolen <span class="No-Break">tokens indefinitely.</span></li>
				<li>Consider refresh token rotation. When a new access token is issued using a refresh token, generate a new refresh token and store it. This reduces the risk of a single refresh token being compromised for an <span class="No-Break">extended period.</span></li>
				<li>If performance and fast access are top priorities, consider using Redis for its speed and automatic handling of expiration times. However, address potential persistence concerns <span class="No-Break">if necessary.</span></li>
				<li>If data durability and integration with your existing database are crucial, storing refresh tokens in a database can be an option. However, evaluate potential performance impacts compared <span class="No-Break">to Redis.</span></li>
			</ul>
			<p>To access our new controller functionality, let provide a route for it. Open the <strong class="source-inline">routes/v1/users/index.js</strong> file and add the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
router.post('/token', validate(loginSchema),userController.getAccessTokenbyRefreshToken);</pre>			<p>That is all. Now we have<a id="_idIndexMarker693"/> endpoints to register, log in, and retrieve a new <span class="No-Break">access token.</span></p>
			<p>We store secret tokens and refresh tokens in an <strong class="source-inline">.env</strong> file. Create a <strong class="source-inline">configs</strong> folder on the same level as the <strong class="source-inline">src</strong> folder and add an <strong class="source-inline">.env</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
PORT=3006
MONGODB_URL=mongodb://localhost:27017/auth-microservice #provide your MONGO_URL
SECRET_ACCESS_TOKEN={YOUR_SECRET_KEY}
SECRET_REFRESH_TOKEN={YOUR_REFRESH_TOKEN}</pre>			<p>In order to generate refresh and secret tokens, do the <span class="No-Break">following operations:</span></p>
			<ol>
				<li>Open the terminal and <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">node</strong></span><span class="No-Break">.</span></li>
				<li>In the given input window, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">require('crypto').randomBytes(64).toString('hex')</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The following figure show how easily you can <span class="No-Break">do it:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer089">
					<img alt="Figure 9.1: Generating secret tokens" src="image/B09148_09_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Generating secret tokens</p>
			<p>You will get a different generated result every time you call the last command. Just copy the value and paste it to the <strong class="source-inline">.env</strong> file to be paired with <strong class="source-inline">SECRET_ACCESS_TOKEN</strong>. Try the same comment a second time to get a completely different value and paste it for <strong class="source-inline">SECRET_REFRESH_TOKEN</strong>. The refresh token and secret token must have <span class="No-Break">different values.</span></p>
			<p>As you already know, we have the <strong class="source-inline">src/config</strong> folder with <strong class="source-inline">config.js</strong> that can read <strong class="source-inline">.env</strong> files <a id="_idIndexMarker694"/>programmatically. We add token reading functionality <span class="No-Break">to it.</span></p>
			<p>Here is what it <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        PORT: Joi.number().default(3006),
        MONGODB_URL: Joi.string().required().description('Mongo DB url'),
        SECRET_ACCESS_TOKEN: Joi.string().hex().required(),
        SECRET_REFRESH_TOKEN: Joi.string().hex().required(),
    })
    .unknown();
function createConfig(configPath) {
    dotenv.config({ path: configPath });
    const { value: envVars, error } = envVarsSchema
        .prefs({ errors: { label: 'key' } })
        .validate(process.env);
    if (error) {
        throw new Error(`Config validation error: ${error.message}`);
    }
    return {
        port: envVars.PORT,
        mongo: {
            url: envVars.MONGODB_URL,
        },
        jwt: {
            access_token: envVars.SECRET_ACCESS_TOKEN,
            refresh_token: envVars.SECRET_REFRESH_TOKEN
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>This code provides an<a id="_idIndexMarker695"/> object called <strong class="source-inline">jwt</strong> to access refresh and <span class="No-Break">secret tokens.</span></p>
			<p>As you might guess, we haven’t validated user-provided data directly. We need to validate the data, and that is why we plan to use the same structure that we used for the account microservice. Under the <strong class="source-inline">src/middlewares</strong> folder, we have the same <strong class="source-inline">validate.js</strong> file to validate our schema. That is the main reason why we haven’t implemented validation per endpoint. It is time to provide rules for email and password validation. Create <strong class="source-inline">user.js</strong> under <a id="_idIndexMarker696"/>the <strong class="source-inline">src/validation</strong> folder with the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
const Joi = require('joi');
const loginSchema = Joi.object({
    body: Joi.object().keys({
        email: Joi.string()
            .required()
            .error(errors =&gt; {
                if (errors[0].code === 'any.required') {
                    return new Error('Email is required');
                }
                if (errors[0].code === 'string.email') {
                    return new Error('Invalid email format');
                }
                return errors;
            }),
        password: Joi.string()
            .min(6) // Minimum password length
            .required()
            .error(errors =&gt; {
                if (errors[0].code === 'any.required') {
                    return new Error('Password is required');
                }
                if (errors[0].code === 'string.min') {
                    return new Error('Password must be at least 6 characters long');
                }
                return errors;
            })
    })
});
module.exports = { loginSchema };</pre>			<p>This code snippet uses <strong class="source-inline">Joi</strong> to define a validation schema specifically for login requests in your application. It focuses on the request body, ensuring it contains a valid email address and password<a id="_idIndexMarker697"/> that meets the minimum length requirement (defined as six characters in this example). The schema also provides informative custom error messages for missing or invalid email and password, improving the user experience by guiding them toward proper credential format. By implementing this validation, you can prevent malformed login requests from reaching your backend logic and enhance the overall security of <span class="No-Break">your application.</span></p>
			<p>We can directly provide routing in our controllers but we will follow the same convention we did before when we implemented the account microservice. So, under the <strong class="source-inline">routes/v1/users</strong> folder, create an <strong class="source-inline">index.js</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const { Router } = require('express');
const userController = require('../../../controllers/user');
const { loginSchema } = require('../../../validation/user');
const validate = require('../../../middlewares/validate');
const router = Router();
router.post('/register', validate(loginSchema), userController.createUser);
router.post('/login', validate(loginSchema), userController.loginUser);
module.exports = router;</pre>			<p>The code defines two endpoints. One for registration (<strong class="source-inline">/register</strong>) and the other for the login (<strong class="source-inline">/login</strong>) functionality. The <strong class="source-inline">routes/v1</strong> folder also contains the <strong class="source-inline">index.js</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const { Router } = require('express');
const userRouter = require('./users');
const router = Router();
router.use('/users', userRouter);
module.exports = router;</pre>			<p>As you can see, we use<a id="_idIndexMarker698"/> the same code we used in our account microservice. We just changed the route to <strong class="source-inline">users</strong>. Now, users can access our endpoints using <strong class="source-inline">v1/user/{endpoint_name}</strong>. The last elements in our microservice are <strong class="source-inline">app.js</strong> and the root <strong class="source-inline">index.js</strong> file, which are the same as our already implemented <span class="No-Break">account microservice.</span></p>
			<p>Let’s test our Auth microservice’s endpoints. Run <strong class="source-inline">npm start</strong> from the terminal and let’s prepare our <strong class="source-inline">POST</strong> request to create <span class="No-Break">a user:</span></p>
			<ol>
				<li>Open the <span class="No-Break">Postman application.</span></li>
				<li>Create a new Postman <span class="No-Break">request window.</span></li>
				<li>Change <strong class="bold">GET</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">POST</strong></span><span class="No-Break">.</span></li>
				<li>Provide the endpoint URL (it is <strong class="source-inline">http://localhost:3006/v1/users/register</strong> <span class="No-Break">for us).</span></li>
				<li>Go to <strong class="bold">Body</strong>, select <strong class="bold">raw</strong>, and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">JSON</strong></span><span class="No-Break">.</span></li>
				<li>Provide a payload and click <strong class="bold">Send</strong> (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer090">
					<img alt="Figure 9.2: Successful registration" src="image/B09148_09_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Successful registration</p>
			<p>The user is ready. Now, we<a id="_idIndexMarker699"/> can get a JWT. Here are the steps to get <span class="No-Break">a JWT:</span></p>
			<ol>
				<li>Create a new Postman <span class="No-Break">request window.</span></li>
				<li>Change <strong class="bold">GET</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">POST</strong></span><span class="No-Break">.</span></li>
				<li>Provide the endpoint URL (it is <strong class="source-inline">http://localhost:3006/v1/users/login</strong> <span class="No-Break">for us).</span></li>
				<li>Go to <strong class="bold">Body</strong>, select <strong class="bold">raw</strong>, and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">JSON</strong></span><span class="No-Break">.</span></li>
				<li>Provide a payload and click <strong class="bold">Send</strong> (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 9.3: Successful login" src="image/B09148_09_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Successful login</p>
			<p>The generated access token will expire in a given time slot (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em>). After expiration, we do not <a id="_idIndexMarker700"/>need to provide an email and password to get a new access token. We can simply use a refresh token to refresh and to get a new <span class="No-Break">access token.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 9.4: Message about expired token" src="image/B09148_09_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: Message about expired token</p>
			<p>But what if you want a new access token based on a refresh token? That is easy. <span class="No-Break">Here’s how:</span></p>
			<ol>
				<li>Open a new window on Postman and set the request type to <strong class="bold">POST</strong> for the <span class="No-Break"><strong class="source-inline">v1/users/token</strong></span><span class="No-Break"> endpoint.</span></li>
				<li>Open the <strong class="bold">Body</strong> section and provide a refresh token. Click the <strong class="bold">Send</strong> button (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 9.5: Getting a new access token based on the refresh token" src="image/B09148_09_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: Getting a new access token based on the refresh token</p>
			<p>Now you can use this<a id="_idIndexMarker701"/> access token to access our account microservice resources. Well, that is simply it. It is time to test the JWT in our <span class="No-Break">account microservice.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Integrating token-based authentication for the account microservice</h2>
			<p>The microservices we <a id="_idIndexMarker702"/>implemented <a id="_idIndexMarker703"/>so far don’t have authentication and authorization functionalities. As homework, you can start to integrate these into them, and for learning purposes, we will implement JWT for the account microservice. Open the account microservice we developed so far. To use the same access token from the Auth microservice, the account microservice should use the same secret token. Open the <strong class="source-inline">configs/.env</strong> file and add the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
SECRET_ACCESS_TOKEN={USE_THE_SAME_TOKEN_YOU_USED_IN_AUTH_MICROSERVICE}</pre>			<p>Open the <strong class="source-inline">config/config.js</strong> file and make the following changes in order to read the secret token <span class="No-Break">configuration field:</span></p>
			<pre class="source-code">
const dotenv = require('dotenv');
const Joi = require('joi');
const envVarsSchema = Joi.object()
    .keys({
        ....
        SECRET_ACCESS_TOKEN: Joi.string().hex().required(),
       .....
    })
    .unknown();
function createConfig(configPath) {
    .............
    return {
        ..............
        jwt: {
            access_token: envVars.SECRET_ACCESS_TOKEN
        }
    };
}
module.exports = {
    createConfig,
};</pre>			<p>The only real <a id="_idIndexMarker704"/>functionality<a id="_idIndexMarker705"/> we need to add to the account microservice is a middleware to verify <span class="No-Break">our token.</span></p>
			<p>Under the <strong class="source-inline">src/middlewares</strong> folder, create a file called <strong class="source-inline">verify.js</strong> with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const jwt = require('jsonwebtoken');
const path = require('path');
const { createConfig } = require('../config/config');
const verifyJWT = (req, res, next) =&gt; {
    const authHeader = req.headers.authorization;
    // Check for presence and format of Authorization header
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        message: 'Unauthorized: Missing JWT token',});
    }
    const token = authHeader.split(' ')[1];
    const configPath = path.join(__dirname, '../../configs/.env');
    const appConfig = createConfig(configPath);
    // Verify the JWT token
    jwt.verify(token, appConfig.jwt.access_token, (err, decoded) =&gt; {
      if (err) {
        // Handle JWT verification errors
        if (err.name === 'JsonWebTokenError') {
          return res.status(401).json({
            message: 'Unauthorized: Invalid JWT token format',
          });
        } else if (err.name === 'TokenExpiredError') {
            return res.status(401).json({
              message: 'Unauthorized: JWT token expired',
            });
          } else {
              // Handle other errors (e.g., signature verification failure)
              console.error('JWT verification error:', err);
              return res.status(500).json({
                message: 'Internal Server Error',});
          }
      }
      // Attach decoded user information to the request object
      req.user = decoded;
      next(); // Allow the request to proceed
    });
};
module.exports = verifyJWT;</pre>			<p>This code defines <a id="_idIndexMarker706"/>a <a id="_idIndexMarker707"/>middleware function named <strong class="source-inline">verifyJWT</strong> for Express.js applications. It handles JWT verification for incoming requests. It checks if the authorization header exists in the request and starts with <strong class="source-inline">Bearer</strong>. If not, it returns a <strong class="source-inline">401 Unauthorized</strong> response indicating a <span class="No-Break">missing JWT.</span></p>
			<p>If the header is present and formatted correctly, it extracts the JWT itself from the authorization header. Our middleware constructs the path to the environment variable file containing the JWT secret key. It calls a function (likely from a separate <strong class="source-inline">config</strong> module) to read and parse <span class="No-Break">the configuration.</span></p>
			<p>Then, we use <strong class="source-inline">jsonwebtoken.verify()</strong> to verify the extracted token against the secret key retrieved from the configuration. If verification fails (<strong class="source-inline">err</strong>), it checks the <span class="No-Break">error type:</span></p>
			<ul>
				<li><strong class="source-inline">JsonWebTokenError</strong>: Indicates invalid token format, returning <strong class="source-inline">401</strong> with a <span class="No-Break">specific message</span></li>
				<li><strong class="source-inline">TokenExpiredError</strong>: Indicates an expired token, returning <strong class="source-inline">401</strong> with a <span class="No-Break">specific message</span></li>
				<li>Other errors (e.g., signature verification failure) are logged and a generic <strong class="source-inline">500 Internal Server Error</strong> response is sent for <span class="No-Break">security reasons</span></li>
			</ul>
			<p>If verification is successful (<strong class="source-inline">!err</strong>), it attaches the decoded user information from the JWT to the <strong class="source-inline">req.user</strong> object for further access within your <span class="No-Break">application logic.</span></p>
			<p>Finally, it calls <strong class="source-inline">next()</strong> to allow the request to proceed to the intended <span class="No-Break">route handler.</span></p>
			<p>Overall, this middleware <a id="_idIndexMarker708"/>acts <a id="_idIndexMarker709"/>as a gatekeeper, ensuring that only requests with valid JWTs can access protected resources in <span class="No-Break">your application.</span></p>
			<p>In order to use our middleware, we import it in our <strong class="source-inline">app.js</strong> file and <span class="No-Break">use it:</span></p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const consumerModule = require('./modules/kafkamodule');
const morganMiddleware = require('./middlewares/morganmiddleware');
const jwtVerifyMiddleware = require('./middlewares/verify');
const app = express();
app.use(jwtVerifyMiddleware);
app.use(morganMiddleware);
consumerModule();
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>The code imports our middleware and uses it. Now, let’s run the account microservice and try to get all <a id="_idIndexMarker710"/>account<a id="_idIndexMarker711"/> information. Do the <span class="No-Break">following operations:</span></p>
			<ol>
				<li>Navigate to the <span class="No-Break"><strong class="source-inline">Ch09/accountservice</strong></span><span class="No-Break"> folder.</span></li>
				<li>To run the account microservice properly, you also need to run the <strong class="source-inline">docker-compose</strong> file from the root folder using the <strong class="source-inline">docker-compose up -</strong><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break"> command.</span></li>
				<li>After executing both <strong class="source-inline">docker-compose</strong> setups, start the account microservice by running the <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">start</strong></span><span class="No-Break"> command.</span></li>
				<li>Open Postman and send a <strong class="source-inline">GET</strong> request to <strong class="source-inline">v1/accounts</strong> (in our case, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">http://localhost:3001/v1/accounts</strong></span><span class="No-Break">).</span></li>
				<li>You will get a message about an unauthorized request (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 9.6: Unauthorized access" src="image/B09148_09_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: Unauthorized access</p>
			<ol>
				<li value="6">Now, run our Authentication microservice and do the steps we mentioned in the Auth microservice to get an access token (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em>). For the same query for the <a id="_idIndexMarker712"/>account <a id="_idIndexMarker713"/>microservice, just open the <strong class="bold">Authorization</strong> section from Postman, change the type of authorization to <strong class="bold">Bearer Token</strong>, and paste the token you get from the Authentication service into the input (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 9.7: Accessing the account microservice" src="image/B09148_09_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: Accessing the account microservice</p>
			<ol>
				<li value="7">Press the <strong class="bold">Send</strong> button and here <span class="No-Break">we are:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 9.8: Getting account microservice resources" src="image/B09148_09_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: Getting account microservice resources</p>
			<p>If you’ve followed the steps correctly, you should now be able to retrieve account data. In the next <a id="_idIndexMarker714"/>chapter, we’ll <a id="_idIndexMarker715"/>dive into observability and explore how to implement it using the <span class="No-Break">ELK stack.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Summary</h1>
			<p>This chapter explored the fundamental security concepts of authentication, authorization, and their role in securing microservices. We clarified the importance of verifying user identities (authentication) and determining access permissions (authorization) for robust <span class="No-Break">system protection.</span></p>
			<p>To achieve this, we implemented a dedicated microservice for issuing access tokens (JWTs) and refresh tokens. JWTs grant temporary access, while refresh tokens allow users to obtain new access tokens without re-entering credentials. A practical demonstration showcased how this microservice interacts with another microservice, the <span class="No-Break">account microservice.</span></p>
			<p>In our next chapter, we will explore the monitoring of microservices and its significance in microservice architectures. We will implement logging functionality within the account microservice and integrate it with the <strong class="bold">Elasticsearch, Logstash, and Kibana</strong> (<strong class="bold">ELK</strong>) stack. This will establish a centralized logging system, enabling efficient log collection, analysis, <span class="No-Break">and visualization.</span></p>
		</div>
	</body></html>