- en: Modularizing Our Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化我们的代码
- en: In the previous chapter, we followed a TDD workflow and implemented the first
    endpoint of our API—the Create User endpoint. We wrote our End-to-End (E2E) tests
    in Gherkin, ran them using the *Cucumber* test runner, and used them to drive
    development. Everything works, but all the code is contained within a single, monolithic
    file (`src/index.js`); this is not modular and makes our project hard to maintain,
    especially as we add more endpoints. Therefore, in this chapter, we will be separating
    our application code into smaller modules. This will allow us to write **unit** and **integration
    tests** for them in [Chapter 8](38b85b06-d091-4751-a2ac-32ca0f98f26b.xhtml), *Writing
    Unit/Integration Tests*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们遵循了 TDD 工作流程并实现了我们 API 的第一个端点——创建用户端点。我们使用 Gherkin 编写了端到端（E2E）测试，使用
    *Cucumber* 测试运行器运行它们，并使用它们来驱动开发。一切正常，但所有代码都包含在一个单一的、单体文件（`src/index.js`）中；这不是模块化的，使得我们的项目难以维护，尤其是在我们添加更多端点时。因此，在本章中，我们将把我们的应用程序代码分解成更小的模块。这将允许我们在第
    8 章 [编写单元/集成测试](38b85b06-d091-4751-a2ac-32ca0f98f26b.xhtml)中为它们编写 **单元** 和 **集成**
    测试。
- en: 'By following this chapter, you will be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章，你将能够做到以下几件事：
- en: Break down large blocks of code into smaller modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大块代码分解成更小的模块
- en: Define and validate JavaScript objects with **JSON Schema** and Ajv
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **JSON Schema** 和 Ajv 定义和验证 JavaScript 对象
- en: Modularizing our code
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化我们的代码
- en: If you take a look inside the `src/index.js` file, you'll see that there are
    three top-level middleware functions—`checkEmptyPayload`, `checkContentTypeIsSet`,
    and `checkContentTypeIsJson`—as well as an anonymous error handler function. These
    are prime candidates that we can extract into their own modules. So, let's get
    started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `src/index.js` 文件，你会看到有三个顶级中间件函数——`checkEmptyPayload`、`checkContentTypeIsSet`
    和 `checkContentTypeIsJson`——以及一个匿名错误处理函数。这些都是我们可以提取到它们自己的模块中的理想候选者。所以，让我们开始吧！
- en: Modularizing our middleware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化我们的中间件
- en: 'Let''s carry out this refactoring process in a new branch called `create-user/refactor-modules`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为 `create-user/refactor-modules` 的新分支中执行这个重构过程：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create a directory at `src/middlewares`; this is where we will store
    all of our middleware modules. Inside it, create four files—one for each middleware
    function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/middlewares` 中创建一个目录；这是我们存储所有中间件模块的地方。在其内部，创建四个文件——每个中间件函数一个：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, move the middleware functions from `src/index.js` into their corresponding
    file. For example, the `checkEmptyPayload` function should be moved to `src/middlewares/check-empty-payload.js`.
    Then, at the end of each module, export the function as the default export. For
    example, the `error-handler.js` file would look like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将中间件函数从 `src/index.js` 移动到它们对应的文件中。例如，`checkEmptyPayload` 函数应该移动到 `src/middlewares/check-empty-payload.js`。然后，在每个模块的末尾，将函数作为默认导出导出。例如，`error-handler.js`
    文件将看起来像这样：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, go back to `src/index.js` and import these modules to restore the previous
    behavior:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `src/index.js` 并导入这些模块以恢复之前的行为：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, run our E2E tests again to make sure that we haven't broken anything. Also,
    don't forget to commit your code!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行我们的 E2E 测试，以确保我们没有破坏任何东西。同时，别忘了提交你的代码！
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By pulling out the middleware functions, we've improved the readability of our `src/index.js` file.
    The intention and flow of our code is apparent because we've named our functions
    properly—you understand what the functions do from their names. Next, let's do
    the same with our request handler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提取中间件函数，我们提高了 `src/index.js` 文件的可读性。由于我们正确地命名了函数，代码的意图和流程一目了然——你可以从函数名中理解函数的功能。接下来，让我们对请求处理器也做同样的处理。
- en: Modularizing our request handlers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化我们的请求处理器
- en: 'At the moment, we only have one request handler for our `POST /users` endpoint,
    but by the end of this chapter, we will have implemented many more. Defining them
    all inside the `src/index.js` file would lead to a huge, unreadable mess. Therefore,
    let''s define each request handler as its own module. Let''s begin by creating
    a file at `src/handlers/users/create.js` and extract the Create User request handler
    into it. Previously, the request handler was an anonymous arrow function; now
    that it''s in its own module, let''s give it a name of `createUser`. Lastly, `export` the
    function in the same manner as we did with the middleware. You should end up with
    something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只为`POST /users`端点有一个请求处理程序，但到本章结束时，我们将实现更多。将它们全部定义在`src/index.js`文件中会导致一个庞大且难以阅读的混乱。因此，让我们将每个请求处理程序定义为其自己的模块。让我们首先在`src/handlers/users/create.js`中创建一个文件，并将创建用户请求处理程序提取到其中。之前，请求处理程序是一个匿名箭头函数；现在它在自己的模块中，让我们给它命名为`createUser`。最后，以与我们处理中间件相同的方式`export`函数。你应该得到类似以下内容：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, import the `createUser` handler back into `src/index.js` and use it inside `app.post`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`createUser`处理程序重新导入到`src/index.js`中，并在`app.post`内部使用它：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, our request handler requires an Elasticsearch client to work. One
    way to resolve this would be to move the following lines to the top of the `src/handlers/users/create.js` module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的请求处理程序需要一个Elasticsearch客户端才能工作。解决这一问题的方法之一是将以下行移动到`src/handlers/users/create.js`模块的顶部：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, thinking ahead, since we will have many request handlers, we shouldn't
    instantiate a separate instance of the client for each handler. Instead, we should
    create one Elasticsearch client instance and pass it by reference into each request
    handler.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从长远来看，由于我们将有许多请求处理程序，我们不应该为每个处理程序实例化一个单独的客户端实例。相反，我们应该创建一个Elasticsearch客户端实例，并将其通过引用传递给每个请求处理程序。
- en: 'To do this, let''s create a utility function at `src/utils/inject-handler-dependencies.js` that
    takes in a request handler function and the Elasticsearch client, and returns
    a new function that will call the request handler, passing in the client as one
    of the parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们在`src/utils/inject-handler-dependencies.js`中创建一个实用函数，它接受一个请求处理程序函数和Elasticsearch客户端，并返回一个新的函数，该函数将调用请求处理程序，并将客户端作为参数之一传递：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is an example of a **higher-order function**, which is a function that
    operates on, or returns, other functions. This is possible because functions are
    a type of object in JavaScript, and thus are treated as **first-class citizens**.
    This means you can pass a function around just like any other object, even as
    function parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**高阶函数**的例子，它操作其他函数或返回其他函数。这是可能的，因为函数是JavaScript中的一种对象类型，因此被视为**一等公民**。这意味着你可以像传递任何其他对象一样传递函数，甚至作为函数参数。
- en: 'To use it, import it into our `src/index.js` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，将其导入我们的`src/index.js`文件：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, instead of using the `createUser` request handler directly, pass in the
    handler returned from `injectHandlerDependencies`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，而不是直接使用`createUser`请求处理程序，传递`injectHandlerDependencies`返回的处理程序：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, update the request handler itself to make use of the client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新请求处理程序本身以使用客户端：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once again, run the E2E tests to make sure we have not introduced a bug, and
    then commit our changes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行端到端测试，以确保我们没有引入任何错误，然后提交我们的更改：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The single responsibility principle
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'We have pulled out the request handler and migrated it into its own module.
    However, it is not as modular as it could be; at the moment, the handler serves
    three functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提取了请求处理程序并将其迁移到自己的模块中。然而，它并不像它本可以的那样模块化；目前，处理程序执行三个功能：
- en: Validates the request
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证请求
- en: Writes to the database
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入数据库
- en: Generates the response
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成响应
- en: If you have studied object-orientated design principles, you will undoubtedly
    have come across the **SOLID** principle, which is a mnemonic acronym for **single
    responsibility**, **open/closed**, **Liskov substitution**, **interface segregation**,
    and **dependency inversion**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经学习过面向对象的设计原则，你无疑会遇到**SOLID**原则，这是一个代表**单一职责**、**开闭原则**、**里氏替换原则**、**接口隔离原则**和**依赖倒置原则**的记忆法缩写。
- en: The single responsibility principle states that a module should perform one,
    and only one, function. Therefore, we should pull out the validation and database
    logic into their own dedicated modules.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则指出，一个模块应该执行一个，并且只有一个，功能。因此，我们应该将验证和数据库逻辑提取到它们自己的专用模块中。
- en: Decoupling our validation logic
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦我们的验证逻辑
- en: However, we cannot directly copy our existing validation code from `src/handlers/users/create.js` without
    modification. This is because the validation code directly modifies the response
    object, `res`, which means that the validation logic and response logic are **tightly
    coupled** to each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能直接从`src/handlers/users/create.js`复制现有的验证代码而不做修改。这是因为验证代码直接修改了响应对象`res`，这意味着验证逻辑和响应逻辑是**紧密耦合**的。
- en: To resolve this, we must define a common **interface** between our validation
    logic and our response handler. Instead of modifying the response directly, the
    validation logic will produce an object that conforms to this interface, and the
    response handler will consume this object to produce an appropriate response.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须在验证逻辑和响应处理器之间定义一个公共的**接口**。而不是直接修改响应，验证逻辑将生成一个符合此接口的对象，响应处理器将消费此对象以生成适当的响应。
- en: When a request fails validation, we can consider it as a type of error, because
    the client provided an incorrect payload. Therefore, we can extend the native `Error` object
    to create a new `ValidationError` object, which will act as the interface. We
    don't have to provide the status or set the headers, as that's the job of our
    request handlers. We just need to make sure an instance of `ValidationError` will
    contain the `message` property. Since this is the default behavior of `Error`,
    we don't need to do much else.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求验证失败时，我们可以将其视为一种错误，因为客户端提供了错误的数据负载。因此，我们可以扩展原生的`Error`对象来创建一个新的`ValidationError`对象，该对象将作为接口。我们不需要提供状态或设置头信息，因为那是请求处理器的工作。我们只需要确保`ValidationError`实例将包含`message`属性。由于这是`Error`的默认行为，我们不需要做太多其他的事情。
- en: Creating the ValidationError interface
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`ValidationError`接口
- en: 'Create a new file at `src/validators/errors/validation-error.js` and add a
    class definition for `ValidationError`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/validators/errors/validation-error.js`中创建一个新的文件，并添加`ValidationError`类的定义：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code extends the `Error` class to create its own class. We need
    to do this in order to distinguish between validation errors (which should return
    a `400` response) and errors in our code (which should return a `500` response).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码扩展了`Error`类以创建自己的类。我们需要这样做，以便区分验证错误（应返回`400`响应）和代码中的错误（应返回`500`响应）。
- en: Modularizing our validation logic
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将验证逻辑模块化
- en: 'Next, create a new file at `src/validators/users/create.js` and copy the validation
    blocks from our request handlers into the file, wrapping it inside its own function
    and exporting that function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/validators/users/create.js`中创建一个新的文件，并将请求处理器中的验证块复制到该文件中，将其包裹在其自己的函数内并导出该函数：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, import the `ValidationError` class from `src/validators/errors/validation-error.js`.
    Then, instead of modifying the `res` object (which is not in scope), return instances
    of `ValidationError` instead. The final `src/validators/users/create.js` file may
    look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`src/validators/errors/validation-error.js`导入`ValidationError`类。然后，而不是修改`res`对象（它不在作用域内），返回`ValidationError`实例。最终的`src/validators/users/create.js`文件可能看起来像这样：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to import this function into our request handler and use it to
    validate our Create User request payload. If the validation result is an instance
    of `ValidationError`, then generate the `400` response; otherwise, carry on with
    indexing the user document:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此函数导入到请求处理器中，并使用它来验证创建用户请求的数据负载。如果验证结果是`ValidationError`的实例，则生成`400`响应；否则，继续索引用户文档：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By providing a common interface, we have successfully decoupled our validation
    logic from the rest of the code. Now, run the E2E tests, and if they're green,
    commit our changes!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供公共接口，我们已经成功地将验证逻辑从其他代码中解耦。现在，运行端到端测试，如果它们是绿色的，提交我们的更改！
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating engines
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建引擎
- en: Although the bulk of the validation logic has been abstracted into a separate
    module, the request handler is still processing the results of the validator,
    interacting with the database, and sending back the response; it still does not
    comply with the single responsibility principle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分验证逻辑已经被抽象成一个独立的模块，但请求处理器仍然在处理验证器的结果，与数据库交互，并发送响应；它仍然没有遵循单一职责原则。
- en: The request handler's only job should be to pass the request to an *engine*,
    which will process the request, and respond with the result of the operation.
    Based on the result of the operation, the request handler should then issue an
    appropriate response to the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理器的唯一任务应该是将请求传递给一个 *引擎*，该引擎将处理请求，并使用操作的结果进行响应。根据操作的结果，请求处理器应随后向客户端发出适当的响应。
- en: So, let's create a new directory at `src/engines/users` and add a `create.js` file;
    inside, define a `create` function and `export` it. This `create` function will
    validate our request and write to the database, returning the result of the operation
    back to the request handler. Since writing to the database is an asynchronous
    operation, our `create` function should return a promise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 `src/engines/users` 中创建一个新的目录并添加一个 `create.js` 文件；在内部，定义一个 `create` 函数并将其导出。这个 `create` 函数将验证我们的请求并将写入数据库，将操作的结果返回给请求处理器。由于写入数据库是一个异步操作，我们的 `create` 函数应该返回一个承诺。
- en: 'Try implementing the `create` function yourself, and check back here for our
    implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己实现 `create` 函数，并在此处查看我们的实现：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in `src/handlers/users/create.js`, import the engine module and use the
    result to generate the response. The final file should look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/handlers/users/create.js` 中，导入引擎模块并使用结果生成响应。最终的文件应该看起来像这样：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the tests to make sure that they all still pass, and then commit these
    changes to Git:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确保它们仍然通过，然后将这些更改提交到 Git：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Fantastic! We have now refactored our code to be more modular and ensured that
    each module is decoupled from the others!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经重构了代码，使其更加模块化，并确保每个模块与其他模块解耦！
- en: Adding a user profile
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户配置文件
- en: If we look back at our requirements for creating a user, there's one that is
    still unfinished – "The user may optionally provide a profile; otherwise, an empty
    profile will be created for them". So, let's implement this requirement!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾创建用户的必要条件，有一个仍然未完成——“用户可以可选地提供配置文件；否则，将为他们创建一个空配置文件”。所以，让我们实现这个要求！
- en: Writing a specification as a test
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将规范作为测试来编写
- en: We will begin development by first writing E2E tests. In the previous chapter,
    we already tested a scenario where the profile is not supplied. In these new E2E
    tests, we will add two more scenarios where the client provides a profile object—one
    using an invalid profile, the other a valid one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写端到端测试开始开发。在前一章中，我们已经测试了一个未提供配置文件的场景。在这些新的端到端测试中，我们将添加两个更多场景，其中客户端提供了一个配置文件对象——一个使用无效配置文件，另一个使用有效配置文件。
- en: 'Therefore, we must first decide what constitutes a valid profile; in other
    words, what should the structure of our profile object be? There are no right
    or wrong answers, but for this book, we will use the following structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须首先决定什么构成了一个有效的配置文件；换句话说，我们的配置文件对象的结构应该是什么？没有正确或错误答案，但为了这本书，我们将使用以下结构：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of the fields are optional, but if they are provided, they must be of the
    correct type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段都是可选的，但如果提供了，它们必须是正确的类型。
- en: 'Let''s start with testing for the invalid profile scenario. In `spec/cucumber/features/users/create/main.feature`,
    add the following scenario outline:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试无效配置文件场景开始。在 `spec/cucumber/features/users/create/main.feature` 中添加以下场景概述：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These examples cover the cases where properties have the incorrect type, and/or
    unsupported properties were provided.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例涵盖了属性类型不正确的情况，以及/或者提供了不受支持的属性。
- en: 'When we run these tests, the `And attaches <payload> as the payload` shows
    up as undefined. This step definition should allow us to attach any arbitrary
    payload to the request. Try implementing this inside `spec/cucumber/steps/index.js`,
    and check your solution against the following one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些测试时，`And attaches <payload> as the payload` 显示为未定义。这个步骤定义应该允许我们将任何任意有效负载附加到请求上。尝试在 `spec/cucumber/steps/index.js` 中实现这一点，并对照以下解决方案检查你的解决方案：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the E2E tests again, and this time, the newly defined tests should fail. Red.
    Green. Refactor. We have now written a failing test; the next step is to implement
    the feature so that it passes the tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行端到端测试，这次，新定义的测试应该会失败。红-绿-重构。我们现在已经编写了一个失败的测试；下一步是实现功能，使其通过测试。
- en: Schema-based validation
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模式的验证
- en: Our tests are failing because our API is actually writing the (invalid) profile
    objects into the database; conversely, we expect our API to respond with a `400` error.
    Therefore, we must implement additional validation steps for the `profile` subdocument.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试失败是因为我们的 API 实际上正在将（无效的）配置文件对象写入数据库；相反，我们期望我们的 API 返回一个 `400` 错误。因此，我们必须为
    `profile` 子文档实现额外的验证步骤。
- en: Currently, we are using `if` conditional blocks to validate the email and password
    fields. If we use the same approach for our new user object, we'd have to write
    a very long list of `if` statements, which is bad for readability. One may also
    argue that our current implementation of the `validation` function is already
    quite unreadable, because it's not immediately obvious what the user object should
    look like. Therefore, we need to find a better approach.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用 `if` 条件块来验证电子邮件和密码字段。如果我们对我们的新用户对象使用相同的方法，我们就必须编写一个非常长的 `if` 语句列表，这对可读性很不利。有人也可能认为我们当前的
    `validation` 函数实现已经相当难以阅读，因为它并不立即明显地表明用户对象应该是什么样子。因此，我们需要找到更好的方法。
- en: A more declarative way of validating is to use a **schema**, which is just a
    formal way of describing a data structure. After a schema is defined, we can use
    validation libraries to test the request payload against the schema, and respond
    with an appropriate error message if it does not pass.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更声明性的验证方式是使用 **模式**，它只是描述数据结构的一种正式方式。定义了模式之后，我们可以使用验证库来测试请求负载与模式是否匹配，如果不匹配，则返回适当的错误消息。
- en: Therefore, in this section, we are going to use a schema to validate our profile
    object, and then refactor all of our existing validation code to use schema-based
    validation as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们将使用模式来验证我们的配置文件对象，然后重构我们现有的所有验证代码以使用基于模式的验证。
- en: Types of schema
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式类型
- en: The most common schema used in JavaScript is **JSON Schema** ([json-schema.org](http://json-schema.org/)).
    To use it, you first define a schema written in JSON, and then use a schema validation
    library to compare the object of interest with the schema to see if they match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中最常用的模式是 **JSON Schema** ([json-schema.org](http://json-schema.org/))。要使用它，你首先定义一个用
    JSON 编写的模式，然后使用模式验证库将感兴趣的对象与模式进行比较，以查看它们是否匹配。
- en: 'But before we explain the syntax of JSON Schema, let''s take a look at two
    major JavaScript libraries that support schema validation while not using JSON
    Schema:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们解释 JSON Schema 的语法之前，让我们看看两个主要的 JavaScript 库，它们支持模式验证但不使用 JSON Schema：
- en: '`joi` ([https://github.com/hapijs/joi](https://github.com/hapijs/joi)) allows
    you to define requirements in a composable, chainable manner, which means that
    the code is very readable. It has over 9,000 stars on GitHub and is depended on
    by over 94,000 repositories and 3,300 packages:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joi` ([https://github.com/hapijs/joi](https://github.com/hapijs/joi)) 允许你以可组合、可链式的方式定义要求，这意味着代码非常易于阅读。它在
    GitHub 上有超过 9,000 个星标，并且被超过 94,000 个存储库和 3,300 个包所依赖：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`validate.js` ([https://validatejs.org/](https://validatejs.org/)) is another
    very expressive validation library, and allows you to define your own custom validation
    function. It has 1,700 stars on GitHub, and is depended on by over 2,700 repositories
    and 290 packages:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate.js` ([https://validatejs.org/](https://validatejs.org/)) 是另一个非常表达式的验证库，它允许你定义自己的自定义验证函数。它在
    GitHub 上有 1,700 个星标，并且被超过 2,700 个存储库和 290 个包所依赖：'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Picking an object schema and validation library
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择对象模式和验证库
- en: So out of the three options, which one should we use? To answer this question,
    we should first consider their **interoperability** and **expressiveness**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在三个选项中，我们应该使用哪一个？为了回答这个问题，我们首先应该考虑它们的 **互操作性** 和 **表达性**。
- en: Interoperability
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: Interoperability has to do with how easy is it for different frameworks, libraries,
    and languages to consume the schema. In this criterion, JSON Schema wins hands
    down.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性涉及到不同框架、库和语言消费模式有多容易。在这个标准下，JSON Schema 无疑是赢家。
- en: The benefits of using a standardized schema such as JSON Schema is that the
    same schema file may be used by multiple code bases. For example, as our platform
    grows, we may have multiple internal services that each need to validate user
    data; some may even be written in another language (for example, Python).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准化模式（如 JSON Schema）的好处是，同一个模式文件可以被多个代码库使用。例如，随着我们平台的增长，我们可能有多个内部服务，每个服务都需要验证用户数据；其中一些甚至可能用另一种语言（例如
    Python）编写。
- en: 'Instead of having multiple definitions of the user schema in different languages,
    we can use the same schema file, as there are JSON Schema validators for all major
    languages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与在不同语言中拥有多个用户模式定义相比，我们可以使用相同的模式文件，因为所有主要语言都有 JSON Schema 验证器：
- en: Swift: `JSONSchema.swift` ([https://github.com/kylef-archive/JSONSchema.swift](https://github.com/kylef-archive/JSONSchema.swift))
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Swift: `JSONSchema.swift` ([https://github.com/kylef-archive/JSONSchema.swift](https://github.com/kylef-archive/JSONSchema.swift))'
- en: Java: `json-schema-validator` ([github.com/java-json-tools/json-schema-validator](https://github.com/java-json-tools/json-schema-validator))
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Java: `json-schema-validator` ([github.com/java-json-tools/json-schema-validator](https://github.com/java-json-tools/json-schema-validator))'
- en: Python: `jsonschema` ([pypi.python.org/pypi/jsonschema](https://pypi.python.org/pypi/jsonschema))
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Python: `jsonschema` ([pypi.python.org/pypi/jsonschema](https://pypi.python.org/pypi/jsonschema))'
- en: Go: `gojsonschema` ([github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema))
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Go: `gojsonschema` ([github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema))'
- en: You can view the full list of validators at [json-schema.org/implementations.html](http://json-schema.org/implementations.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [json-schema.org/implementations.html](http://json-schema.org/implementations.html)
    查看完整的验证器列表。
- en: Expressiveness
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达能力
- en: 'JSON Schema supports many validation keywords and data formats, as defined
    in the IETF memo *JSON Schema Validation: A Vocabulary for Structu**ral Validation
    of JSON* ([json-schema.org/latest/json-schema-validation.html](http://json-schema.org/latest/json-schema-validation.html));
    however, due to the restrictions of JSON itself, JSON Schema lacks the ability
    to define custom validation logic in the form of functions.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON Schema 支持许多验证关键词和数据格式，如 IETF 记忆录 *JSON Schema Validation: A Vocabulary
    for Structural Validation of JSON* 所定义（[json-schema.org/latest/json-schema-validation.html](http://json-schema.org/latest/json-schema-validation.html)）；然而，由于
    JSON 本身的限制，JSON Schema 缺乏以函数形式定义自定义验证逻辑的能力。'
- en: 'For example, JSON Schema does not provide a way to express the following logic:
    "if the `age` property is below `18`, then the `hasParentalConsent` property must
    be set to `true`." Thus, if you want to perform more complicated checks, these
    must be done as a separate function in JavaScript. Alternatively, some JSON Schema-based
    validation libraries extend the JSON Schema syntax and allow developers to implement
    custom validation logic. For instance, the `ajv` validation library supports defining
    custom keywords.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JSON Schema 不提供表达以下逻辑的方法：“如果 `age` 属性小于 `18`，则 `hasParentalConsent` 属性必须设置为
    `true`。” 因此，如果您想执行更复杂的检查，这些必须在 JavaScript 中的单独函数中完成。或者，一些基于 JSON Schema 的验证库扩展了
    JSON Schema 语法，并允许开发者实现自定义验证逻辑。例如，`ajv` 验证库支持定义自定义关键词。
- en: For non-JSON Schema validation libraries, both `joi` and `validate.js` allow
    you to define custom validation functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非 JSON Schema 验证库，`joi` 和 `validate.js` 都允许您定义自定义验证函数。
- en: Therefore, although JSON Schema is less expressive in theory, in practice, all
    solutions have the same level of expressiveness and flexibility. Because JSON
    Schema is a well-established standard and also more interoperable, that's the
    solution we will use to validate our payloads.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管在理论上 JSON Schema 的表达能力较弱，但在实践中，所有解决方案的表达能力和灵活性都是相同的。因为 JSON Schema 是一个成熟的行业标准，并且具有更好的互操作性，所以我们将使用它来验证我们的有效载荷。
- en: At the time of writing this book, the JSON Schema specification is still in
    draft (specifically draft-07, which can be found at [tools.ietf.org/html/draft-handrews-json-schema-00](https://tools.ietf.org/html/draft-handrews-json-schema-00)).
    It is likely that the final specification will be slightly different to the one
    described here. Please refer to the latest version at [json-schema.org](http://json-schema.org/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，JSON Schema 规范仍处于草案阶段（具体为 draft-07，可在 [tools.ietf.org/html/draft-handrews-json-schema-00](https://tools.ietf.org/html/draft-handrews-json-schema-00)
    找到）。最终规范可能与此处描述的略有不同。请参考 [json-schema.org](http://json-schema.org/) 上的最新版本。
- en: Creating our profile schema
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的配置文件模式
- en: So, let's construct the schema for our user profile object using JSON Schema.
    To do that, we must first understand its syntax.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用 JSON Schema 构建我们的用户配置对象模式。为此，我们首先必须理解其语法。
- en: 'The first thing to note is that a JSON Schema is itself a JSON object. Therefore,
    the simplest JSON Schema is simply an empty object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，一个 JSON Schema 本身就是一个 JSON 对象。因此，最简单的 JSON Schema 只是一个空对象：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This empty object schema will allow any type of data, so it is pretty much useless.
    For it to be useful, we must describe the type of data we expect. This can be
    done through the `type` keyword. The `type` keyword expects its value to be either
    a string, where only one type is allowed, or an array, where any types specified
    in the array are allowed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空对象模式将允许任何类型的数据，所以它几乎毫无用处。为了使其有用，我们必须描述我们期望的数据类型。这可以通过`type`关键字来完成。`type`关键字期望其值要么是一个字符串，其中只允许一个类型，要么是一个数组，其中允许数组中指定的任何类型。
- en: 'We expect our input for the user profile object to only be objects, and so
    we can specify a `type` of `"object"`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望用户个人资料对象的输入仅是对象，因此我们可以指定一个`"object"`类型的`type`：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`type` is the most basic keyword. There are many other common keywords that
    are applicable to all types, such as `title`; there are also type-specific keywords,
    such as `maximum`, which only applies to data of type `number`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`是最基本的关键字。还有许多其他适用于所有类型的常见关键字，例如`title`；也有特定于类型的关键字，例如`maximum`，它仅适用于`number`类型的数据。'
- en: 'For object types, we can use the type-specific keyword `properties` to describe
    what properties we expect our object to contain. The value of `properties` must
    be an object, with property names as the key and another valid JSON Schema, called
    a **sub-schema**, as the value. In our case, we expect the `bio` and `summary` properties
    to be of type `string`, and the `name` property to have an `object` type, so our
    schema would look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象类型，我们可以使用特定于类型的`properties`关键字来描述我们期望我们的对象包含哪些属性。`properties`的值必须是一个对象，其中属性名作为键，另一个有效的JSON
    Schema作为值，称为**子模式**。在我们的例子中，我们期望`bio`和`summary`属性是`string`类型，而`name`属性是`object`类型，因此我们的模式看起来像这样：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rejecting additional properties
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝额外属性
- en: 'Lastly, we will set the object-specific `additionalProperties` keyword to `false`.
    This will reject objects that contain keys not already defined under `properties` (for
    example, `isAdmin`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置对象特定的`additionalProperties`关键字为`false`。这将拒绝包含在`properties`下未定义的键的对象（例如，`isAdmin`）：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Having `additionalProperties` set to `false` is really important, especially
    for Elasticsearch. This is because Elasticsearch uses a technique called **dynamic
    mapping** to infer the data types of its documents, and uses it to generate its
    indexes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将`additionalProperties`设置为`false`非常重要，尤其是在Elasticsearch中。这是因为Elasticsearch使用一种称为**动态映射**的技术来推断其文档的数据类型，并使用它来生成其索引。
- en: Dynamic mapping in Elasticsearch
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch中的动态映射
- en: To create a table inside a relational database, you must specify a **model**,
    which stores information about the name and data type of each column. This information
    must be supplied before any data is inserted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在关系型数据库中创建一个表，你必须指定一个**模型**，该模型存储有关每个列的名称和数据类型的信息。在插入任何数据之前，必须提供这些信息。
- en: Elasticsearch has a similar concept called **type mapping**, which stores information
    about the name and data type of each property in the document. The difference
    is that we don't have to supply the type mapping before we insert any data; in
    fact, we don't have to supply it *at all*! This is because when Elasticsearch
    tries to infer the data type from the documents being indexed, it will add it
    to the type mapping. This automatic detection of data types and addition to type
    mapping is what we refer to as dynamic mapping.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch有一个类似的概念称为**类型映射**，它存储有关文档中每个属性名称和数据类型的信息。区别在于我们不需要在插入任何数据之前提供类型映射；事实上，我们根本不需要提供它！这是因为当Elasticsearch尝试从正在索引的文档中推断数据类型时，它将将其添加到类型映射中。这种自动检测数据类型并将其添加到类型映射的过程就是我们所说的动态映射。
- en: Dynamic mapping is a convenience provided by Elasticsearch, but it also means
    we must sanitize and validate our data before indexing it into Elasticsearch.
    If we allow users to add arbitrary fields to their documents, the type mapping
    may infer the wrong data type, or become littered with irrelevant fields. Moreover,
    since Elasticsearch indexes every field by default, this can lead to many irrelevant
    indices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 动态映射是Elasticsearch提供的一种便利，但也意味着我们必须在将其索引到Elasticsearch之前对数据进行清理和验证。如果我们允许用户向他们的文档添加任意字段，类型映射可能会推断出错误的数据类型，或者被无关字段充斥。此外，由于Elasticsearch默认索引每个字段，这可能导致许多无关的索引。
- en: You can read more about dynamic mapping at [https://www.elastic.co/guide/en/elasticsearch/guide/current/dynamic-mapping.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/dynamic-mapping.html).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.elastic.co/guide/en/elasticsearch/guide/current/dynamic-mapping.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/dynamic-mapping.html)了解更多关于动态映射的信息。
- en: Adding specificity to a sub-schema
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为子模式添加具体性
- en: 'At the moment, the only constraint we placed on the `name` property is that
    it must be an object. This is not specific enough. Because the value of each property
    is just another valid JSON Schema, we can define a more specific schema for the `name` property:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们对`name`属性施加的唯一约束是它必须是一个对象。这还不够具体。因为每个属性的值都是另一个有效的JSON Schema，我们可以为`name`属性定义一个更具体的模式：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This JSON Schema satisfies every constraint we want to impose on our Create
    User request payload. However, it looks just like an arbitrary JSON object; someone
    looking at it won't immediately understand that it is a schema. Therefore, to
    make our intentions more clear, we should add a title, description, and some metadata
    to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此JSON Schema满足我们对创建用户请求负载施加的每一个约束。然而，它看起来就像一个任意的JSON对象；查看它的人不会立即理解它是一个模式。因此，为了使我们的意图更加明确，我们应该向其中添加标题、描述和一些元数据。
- en: Adding a title and description
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标题和描述
- en: 'First, we should provide the `title` and `description` keywords for the schema
    and for each property that may require clarification. These keywords are not used
    in validation and exist only to provide context for the users of your schema:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该为模式和每个可能需要澄清的属性提供`title`和`description`关键字。这些关键字不在验证中使用，仅用于为您的模式用户提供上下文：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Specifying a meta-schema
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定元模式
- en: 'Next, we should include the `$schema` keyword, which declares that the JSON
    object is a JSON Schema. It points to a URL that defines the meta-schema that
    the current JSON Schema must conform to. We chose [http://json-schema.org/schema#](http://json-schema.org/schema#), which
    points to the latest draft of the JSON Schema specification:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该包括`$schema`关键字，它声明JSON对象是一个JSON Schema。它指向一个URL，该URL定义了当前JSON Schema必须遵守的元模式。我们选择了[http://json-schema.org/schema#](http://json-schema.org/schema#)，它指向JSON
    Schema规范的最新草案：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Specifying a unique ID
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个唯一标识符
- en: 'Lastly, we should include the `$id` keyword, which defines a unique URI for
    our schema. This URI can be used by other schemas to reference our schema, for
    example, when using our schema as a sub-schema. For now, just set it to a valid
    URL, preferably using a domain that you control:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该包括`$id`关键字，它定义了我们模式的唯一URI。这个URI可以被其他模式用来引用我们的模式，例如，当使用我们的模式作为子模式时。目前，只需将其设置为有效的URL，最好使用你控制的域名：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you don't know how to purchase a domain, we will show you in [Chapter 10](673a49d6-f4c5-47b4-afec-af3ff031f150.xhtml), *Deploying
    Your Application on a VPS*. For now, just use a dummy domain like `example.com`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道如何购买域名，我们将在第10章[部署您的应用程序到VPS](673a49d6-f4c5-47b4-afec-af3ff031f150.xhtml)中向您展示。现在，只需使用一个虚拟域名，如`example.com`。
- en: 'Our finished JSON Schema should look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的JSON Schema应该看起来像这样：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save this file to `/src/schema/users/profile.json`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存到`/src/schema/users/profile.json`。
- en: Creating a schema for the Create User request payload
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为创建用户请求负载创建一个模式
- en: At the moment, our existing code still uses custom-defined `if` statements to
    validate the email and password fields of the Create User request payload object.
    Since we will be using a JSON Schema validation library for our profile object,
    we should also migrate our existing validation logic to a JSON Schema to remain
    consistent. Therefore, let's create a schema for the entire Create User request
    payload object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们现有的代码仍然使用自定义定义的`if`语句来验证创建用户请求负载对象的电子邮件和密码字段。由于我们将为我们的配置文件对象使用JSON Schema验证库，因此我们也应该将现有的验证逻辑迁移到JSON
    Schema以保持一致性。因此，让我们为整个创建用户请求负载对象创建一个模式。
- en: 'Create a new file at `src/schema/users/create.json`, and insert the following
    schema:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/schema/users/create.json`中创建一个新文件，并插入以下模式：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are a few things to note here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方：
- en: We are using the `format` property to ensure that the email property is a valid
    email, as defined by RFC 5322, section 3.4.1 ([https://tools.ietf.org/html/rfc5322#section-3.4.1](https://tools.ietf.org/html/rfc5322#section-3.4.1)). However,
    we also want to exclude certain syntactically-valid emails like `daniel@127.0.0.1`,
    which are likely to be spam. Later in this chapter, we will show you how to override
    this default format.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`format`属性来确保电子邮件属性是一个有效的电子邮件，如RFC 5322第3.4.1节定义。然而，我们还想排除某些语法上有效的电子邮件，如`daniel@127.0.0.1`，这些很可能是垃圾邮件。在本章的后面部分，我们将向您展示如何覆盖此默认格式。
- en: We have used a JSON reference (`$ref`) to reference the profile schema we defined
    earlier. The `$ref` syntax was specified in [https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03) and
    allows us to compose more complex schema from existing ones, removing the need
    for duplication.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个JSON引用(`$ref`)来引用我们之前定义的配置文件模式。`$ref`语法在[https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)中指定，它允许我们从现有的模式中组合出更复杂的模式，从而消除了重复的需求。
- en: We have marked the `email` and `password` properties as required.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将`email`和`password`属性标记为必填。
- en: Picking a JSON Schema validation library
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择JSON Schema验证库
- en: 'The next step is to pick a JSON Schema validation library. The json-schema.org
    ([https://json-schema.org/](https://json-schema.org/)) provides a list of validators
    which you can read at [json-schema.org/implementations.html](http://json-schema.org/implementations.html). When
    choosing a schema validation library, we are looking for two things: performance
    (how quick it is) and conformity (how closely it conforms to the specification).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择一个JSON Schema验证库。json-schema.org ([https://json-schema.org/](https://json-schema.org/))提供了一个验证器列表，您可以在[json-schema.org/implementations.html](http://json-schema.org/implementations.html)上阅读。在选择模式验证库时，我们寻找两个东西：性能（有多快）和一致性（与规范有多接近）。
- en: 'An open-source developer from Denmark, Allan Ebdrup, has created a set of benchmarks
    that compare these libraries. You can find it at [github.com/ebdrup/json-schema-benchmark](https://github.com/ebdrup/json-schema-benchmark).
    The benchmark shows that the *Dynamic JSON Schema Validator* (djv, [github.com/korzio/djv](https://github.com/korzio/djv))
    is the fastest and also has fewest failing tests (only 1). The second fastest
    library is *Another JSON Schema Validator* (ajv, [github.com/epoberezkin/ajv](https://github.com/epoberezkin/ajv)),
    which also only has a single failing test:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 来自丹麦的开源开发者Allan Ebdrup创建了一套基准测试，用于比较这些库。您可以在[github.com/ebdrup/json-schema-benchmark](https://github.com/ebdrup/json-schema-benchmark)找到它。基准测试显示，*动态JSON
    Schema验证器*（djv，[github.com/korzio/djv](https://github.com/korzio/djv)）是最快的，并且失败测试最少（只有1个）。第二快的库是*另一个JSON
    Schema验证器*（ajv，[github.com/epoberezkin/ajv](https://github.com/epoberezkin/ajv)），它也只有单个失败测试：
- en: '| Library | Relative Speed | Number of failing tests |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 相对速度 | 失败测试数量 |'
- en: '| `djv v2.0.0` (fastest) | 100% | 1 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `djv v2.0.0` (最快) | 100% | 1 |'
- en: '| `ajv v5.5.1` | 98% | 1 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ajv v5.5.1` | 98% | 1 |'
- en: '| `is-my-json-valid v2.16.1` | 50.1% | 14 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `is-my-json-valid v2.16.1` | 50.1% | 14 |'
- en: '| `tv4 v1.3.0` | 0.2% | 33 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `tv4 v1.3.0` | 0.2% | 33 |'
- en: 'Therefore, djv seems like an obvious choice. However, developer and community
    support are also important factors to consider. So, let''s take some of the most
    popular libraries and examine their number of GitHub stars, the number of weekly
    downloads from [npmjs.com](https://www.npmjs.com), and the number of dependent
    repositories and packages*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，djv似乎是一个明显的选择。然而，开发者和社区支持也是需要考虑的重要因素。所以，让我们看看一些最受欢迎的库，并检查它们的GitHub星标数量、从[npmjs.com](https://www.npmjs.com)每周的下载量以及依赖的仓库和包数量*：
- en: '| **Library** | **GitHub Repository** | **Version** | **GitHub stars** | **Weekly
    downloads** | **Number of Contributors** | **Dependent** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **库** | **GitHub 仓库** | **版本** | **GitHub 星标** | **每周下载量** | **贡献者数量** |
    **依赖** |'
- en: '| **Repositories** | **Packages** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | **包** |'
- en: '| `ajv` | [epoberezkin/ajv](https://github.com/epoberezkin/ajv) | 6.5.3 | 4,117
    | 12,324,991 | 74 | 1,256,690 | 2,117 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `ajv` | [epoberezkin/ajv](https://github.com/epoberezkin/ajv) | 6.5.3 | 4,117
    | 12,324,991 | 74 | 1,256,690 | 2,117 |'
- en: '| `tv4` | [geraintluff/tv4](https://github.com/geraintluff/tv4) | 1.3.0 | 1,001
    | 342,094 | 22 | 8,276 | 486 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `tv4` | [geraintluff/tv4](https://github.com/geraintluff/tv4) | 1.3.0 | 1,001
    | 342,094 | 22 | 8,276 | 486 |'
- en: '| `jsonschema` | [tdegrunt/jsonschema](https://github.com/tdegrunt/jsonschema)
    | 1.2.4 | 889 | 214,902 | 39 | 18,636 | 727 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `jsonschema` | [tdegrunt/jsonschema](https://github.com/tdegrunt/jsonschema)
    | 1.2.4 | 889 | 214,902 | 39 | 18,636 | 727 |'
- en: '| `is-my-json-valid` | [mafintosh/is-my-json-valid](https://github.com/mafintosh/is-my-json-valid)
    | 2.19.0 | 837 | 2,497,926 | 23 | 463,005 | 267 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `is-my-json-valid` | [mafintosh/is-my-json-valid](https://github.com/mafintosh/is-my-json-valid)
    | 2.19.0 | 837 | 2,497,926 | 23 | 463,005 | 267 |'
- en: '| `JSV` | [garycourt/JSV](https://github.com/garycourt/JSV) | 4.0.2 | 597 |
    211,573 | 6 | 9,475 | 71 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `JSV` | [garycourt/JSV](https://github.com/garycourt/JSV) | 4.0.2 | 597 |
    211,573 | 6 | 9,475 | 71 |'
- en: '| `djv` | [korzio/djv](https://github.com/korzio/djv) | 2.1.1 | 134 | 1,036
    | 6 | 36 | 10 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `djv` | [korzio/djv](https://github.com/korzio/djv) | 2.1.1 | 134 | 1,036
    | 6 | 36 | 10 |'
- en: '* These figures are correct as of 6 September, 2018.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* 这些数据截至2018年9月6日是正确的。'
- en: As you can see, although djv is the best solution technically, Ajv has the most
    downloads and number of contributors—signs that the project is well-supported
    by the community.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，虽然djv在技术上是最优解决方案，但Ajv拥有最多的下载量和贡献者数量——这是项目得到社区广泛支持的迹象。
- en: 'Apart from these metrics, you may also want to examine the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些指标之外，您还可能想检查以下内容：
- en: The date of its last meaningful commit to the `master` branch (this excludes
    version bump and formatting changes)—for instance, the last commit to the `JSV` library
    was on 11 Jul 2012; therefore, although it may still have a lot of active users,
    we should not use a library that's no longer maintained
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对`master`分支的最后一次有意义的提交日期（这排除了版本升级和格式更改）——例如，`JSV`库的最后提交是在2012年7月11日；因此，尽管它可能仍然有大量的活跃用户，但我们不应使用不再维护的库
- en: The number of open issues
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放问题的数量
- en: The frequency of releases
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布频率
- en: All of these factors will give you an indication of whether the tool is being
    actively developed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素都将为您提供有关工具是否正在积极开发的指示。
- en: Taking everything into account, it seems like Ajv is the obvious choice, as
    it has the right balance between performance, conformity, and community support.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，Ajv似乎是显而易见的选择，因为它在性能、一致性和社区支持之间取得了正确的平衡。
- en: Validating against JSON Schema with Ajv
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ajv对JSON Schema进行验证
- en: 'So, let''s start by adding Ajv to our project''s dependencies:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先将Ajv添加到我们项目的依赖项中：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in `src/validators/users/create.js`, import the `ajv` library as well
    as our two JSON Schemas:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`src/validators/users/create.js`中，导入`ajv`库以及我们的两个JSON模式：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We need to import both schemas because our Create User schema is referencing
    the Profile schema, and Ajv requires both schemas in order to resolve this reference.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入这两个模式，因为我们的创建用户模式引用了配置文件模式，而Ajv需要这两个模式才能解析此引用。
- en: 'Then, gut out the entire `validate` function, and replace it with the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，移除整个`validate`函数，并用以下内容替换它：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we will create an instance of Ajv and run the `addFormat` method to override
    the default validation function for the `email` format; the `validate` function
    will now use the regular expression we provided to validate any properties with
    the `email` format.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个Ajv实例，并运行`addFormat`方法来覆盖`email`格式的默认验证函数；现在，`validate`函数将使用我们提供的正则表达式来验证任何具有`email`格式的属性。
- en: Next, we use the `addSchema` method to supply Ajv with any referenced sub-schemas.
    This allows Ajv to follow the references and produce a dereferenced, flattened
    schema, which will be used for the validation operation. Lastly, we run the `compile` method
    to return the actual validation function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`addSchema`方法向Ajv提供任何引用的子模式。这允许Ajv跟踪引用并生成一个非引用的扁平化模式，该模式将用于验证操作。最后，我们运行`compile`方法以返回实际的验证函数。
- en: 'When we run the validate function, it will return either `true` (if it is valid)
    or `false` (if it is invalid). If invalid, `ajvValidate.errors` will be populated with
    an array of errors, which looks something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行验证函数时，它将返回`true`（如果它是有效的）或`false`（如果它是无效的）。如果无效，`ajvValidate.errors`将填充一个包含错误数组的数组，其外观可能如下所示：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By default, Ajv works in a short-circuit manner and will return `false` as
    soon as it encounters the first error. Therefore, the `ajvValidate.errors` array
    is, by default, a single-item array containing the details of the first error.
    To instruct Ajv to return all errors, you must set the `allErrors` option in the Ajv constructor,
    for example, `new Ajv({allErrors: true})`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Ajv以短路方式工作，并在遇到第一个错误时立即返回`false`。因此，`ajvValidate.errors`数组默认是一个包含第一个错误详细信息的单元素数组。要指示Ajv返回所有错误，您必须在Ajv构造函数中设置`allErrors`选项，例如，`new
    Ajv({allErrors: true})`。'
- en: Generating validation error messages
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成验证错误消息
- en: 'When our object fails validation, we should generate the same human-readable
    error messages as we did before. To do this, we must process the errors stored
    at `ajvValidate.errors`, and use them to generate human-readable messages. Thus,
    create a new module at `src/validators/errors/messages.js`, and copy the following
    message generator:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的对象验证失败时，我们应该生成与之前相同的人类可读错误消息。为此，我们必须处理存储在`ajvValidate.errors`中的错误，并使用它们来生成人类可读的消息。因此，在`src/validators/errors/messages.js`中创建一个新的模块，并复制以下消息生成器：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `generateValidationErrorMessage` function extracts the first error object
    from the `ajvValidate.errors` array, and use it to generate the appropriate error
    message. There's also a generic, default error message in case none of the conditionals
    apply.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateValidationErrorMessage`函数从`ajvValidate.errors`数组中提取第一个错误对象，并使用它来生成适当的错误消息。如果没有条件适用，还有一个通用的默认错误消息。'
- en: Generalizing functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数泛化
- en: At the moment, the `generateValidationErrorMessage` function produces messages
    that are specific to the Create User operations. This means that although the
    code is separated, the logic is still highly coupled to the Create User endpoint.
    This coupling defeats the purpose of modules; it is a code smell that should be
    eliminated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`generateValidationErrorMessage`函数产生的是针对创建用户操作的特定消息。这意味着尽管代码是分离的，但逻辑仍然高度耦合到创建用户端点。这种耦合破坏了模块的目的；这是一个应该被消除的代码异味。
- en: Instead, we should program the `generateValidationErrorMessage` function to
    be able to generate error messages for all validation errors. Doing so also provides local
    consistency, because all validators will now have a consistent structure/format
    for their error messages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该编程`generateValidationErrorMessage`函数，使其能够为所有验证错误生成错误消息。这样做也提供了本地一致性，因为所有验证器现在都将有它们错误消息的一致结构/格式。
- en: 'So, let''s make the change by replacing our `generateValidationErrorMessage` function with
    the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过替换我们的`generateValidationErrorMessage`函数来做出更改：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Because this change will break our current implementation and tests, we must
    obtain approval from the product manager. If they approve, we must then update
    the E2E tests to reflect this change:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个更改将破坏我们的当前实现和测试，我们必须获得产品经理的批准。如果他们批准，我们必须然后更新E2E测试以反映这个更改：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, import the `generateValidationErrorMessage` function into our `src/validators/users/create.js` file and
    update the `validateRequest` function so that we can use it to return an object
    containing an error message if validation fails:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`generateValidationErrorMessage`函数导入到我们的`src/validators/users/create.js`文件中，并更新`validateRequest`函数，以便我们可以使用它来返回一个包含错误消息的对象，如果验证失败：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Updating the npm build script
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新npm构建脚本
- en: 'Everything looks good, but if we run the tests, they will return with the following
    error:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很顺利，但如果运行测试，它们将返回以下错误：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is because Babel, by default, only processes `.js` files. Therefore, our `.json` schema
    files were not processed or copied over to the `dist/` directory, which leads
    to the preceding error. To fix this, we can update our `build` npm script to use
    Babel''s `--copy-files` flag, which will copy over any non-compilable files to
    the `dist/` directory:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Babel默认只处理`.js`文件。因此，我们的`.json`模式文件没有被处理或复制到`dist/`目录，这导致了前面的错误。为了修复这个问题，我们可以更新我们的`build`npm脚本来使用Babel的`--copy-files`标志，这将把任何不可编译的文件复制到`dist/`目录：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, if we run our tests again, they should all pass.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行我们的测试，它们应该都能通过。
- en: Testing the success scenario
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试成功场景
- en: 'Since we added the validation steps, we now need to ensure that requests carrying
    valid user payloads will get added to the database, just like before. Therefore,
    at the end of `spec/cucumber/features/users/create/main.feature`, add the following
    scenario outline:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了验证步骤，我们现在需要确保携带有效用户负载的请求将被添加到数据库中，就像以前一样。因此，在`spec/cucumber/features/users/create/main.feature`的末尾添加以下场景概述：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run your tests again to make sure that they pass.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试以确保它们通过。
- en: Resetting our test index
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置我们的测试索引
- en: At the moment, our test index on Elasticsearch is filled with dummy users. Although
    this is not an issue right now, it may become an issue in the future (for example,
    if we decide to change the schema). In any case, it's always a good practice to
    clean up side effects after the tests have finished in order to leave a blank
    slate for subsequent test runs. Therefore, at the end of each test, we should
    delete the Elasticsearch index. This is not a problem because the index will be
    recreated automatically by the test code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的Elasticsearch测试索引中充满了虚拟用户。尽管现在这并不是一个问题，但将来可能会成为问题（例如，如果我们决定更改模式）。无论如何，在测试完成后清理副作用始终是一个好习惯，以便为后续的测试运行留下空白。因此，在每个测试结束时，我们应该删除Elasticsearch索引。这不是问题，因为索引将由测试代码自动重新创建。
- en: 'Therefore, add the following lines below into our `e2e.test.sh` script; this
    will clean up the test index (you should place it after Elasticsearch is responsive,
    but before you run the API server):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将以下行添加到我们的`e2e.test.sh`脚本中；这将清理测试索引（你应该在Elasticsearch响应后，但在运行API服务器之前放置它）：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the tests again and they should still pass. Now, we can commit our changes
    to Git:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，它们应该仍然通过。现在，我们可以将我们的更改提交到Git：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have broken up our monolithic application into many smaller
    modules, and implemented all the requirements for our Create User feature. We
    integrated JSON Schema and Ajv into our validation modules, which forced us to
    be more consistent with the structure of our error messages. This, in turn, improves
    the experience of our end users.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的单体应用程序拆分成许多更小的模块，并实现了我们创建用户功能的所有要求。我们将JSON Schema和Ajv集成到我们的验证模块中，这迫使我们更一致地处理错误消息的结构。这反过来又提高了我们最终用户的使用体验。
- en: In the next chapter, we will use Mocha and Sinon to write unit and integration
    tests, which will strengthen the confidence we have in our code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Mocha和Sinon编写单元和集成测试，这将增强我们对代码的信心。
