- en: Making Types That Can Slot into Any Other Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how to express types for values that have the
    potential to be one of several different things at runtime. At certain times in
    the last chapter, and throughout the book so far, we came up against types that
    Reason marked as *to be filled in later*. In this chapter, we will cover these
    types more in more detail, specifically the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reason's generic type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are type parameters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common parameterized types such as lists, options, and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding parameters to sum and product types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference restrictions on parameterized mutable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference and generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a few interesting examples of Reason''s type inference and how
    it decides what types need to be *filled in later*, as illustrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples all have something in common: the compiler doesn''t have quite
    enough information to infer their *concrete* types. Instead, it infers what it
    can about their general shape but leaves some parts as *generic*. We can observe
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In (1), the type is inferred as `'a => ('a, 'a, 'a)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In (2), the type is inferred as ``'a => [> `wrap('a)]``.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In (3), the type is inferred as `''a => {. x: ''a}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In (4), the type is inferred as `'a => unit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each of these cases, the compiler infers some of the types as `'a`, or in
    other words, *I don't know yet*. Let's look at the first case, the `triple` function,
    to try to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `triple`, the function parameter is `x` and the function body is `(x, x,
    x)`. Given these two facts, the compiler tries to infer (that is, narrow down)
    the type of `triple` by working its way up from each part of the function parameter
    and body. Let''s look at what we can infer from each part of `triple`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `x` parameter: Nothing, so we mark its type as (a generic type) `''a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the body, `(x, x, x)`: We already marked the type of `x` as `''a`, so
    we mark the type of the body as `(''a, ''a, ''a)`, that is, a tuple type consisting
    of three elements all of the same type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the overall function: We marked the parameter as type `''a`, and the body
    as type `(''a, ''a, ''a)`, so we infer the function as a whole to have type `''a
    => (''a, ''a, ''a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that, if anything, this seems like a process of elimination, or a process
    of solving a Sudoku puzzle. We narrow down the types as much as we can based on
    what we know until we can't narrow them down any further. This is the same inference
    and unification process we're familiar with from previous chapters where we encountered
    various type errors, but with generic types we see a new dimension to the type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Reason's type inference process is a famous one, known as **Hindley-Milner (H-M)**
    type inference*;* it's a mathematics-specific way of examining any given expression
    to try to deduce the most general type that will fit the expression. We won't
    delve into the theory here, but we will cover the practicalities of working with
    H-M type inference.
  prefs: []
  type: TYPE_NORMAL
- en: By examining the type inference process for `triple`, we can see how the inference
    works for `wrap`, `makeObj`, and `greet`. The key point to understand is that
    each of these functions has a body expression that doesn't use any specific property
    of its input parameter; instead, the body composes the input parameter inside
    a larger expression that uses the value in a generic way that doesn't expose any
    information about the type itself. For example, imagine being given some object
    (you don't know what) and immediately putting it inside a box; you still don't
    know what the object is, you just know you now have a box that contains some object.
    This is how generic type inference works for structural types.
  prefs: []
  type: TYPE_NORMAL
- en: The special case of interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the functions we've mentioned, `greet` is a bit special because type
    inference doesn't work in quite the same way as it does for the others. For the
    first three functions, inference arrives at a generic type because the parameters
    are used in structurally-typed expressions. For `greet` though, the `x` parameter
     is interpolated into a string; however, strings aren't structurally typed! What's
    going on is that string interpolation is a special escape hatch provided by the
    BuckleScript compiler that allows you to turn any value into a string, but only
    when targeting JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is turning any value into a string. We can think of this
    behavior as a function, `'a => string`. Since we then print the string with `print_endline`,
    the final result type is `unit`; so the overall type is `'a => unit`.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that type checking goes through an algorithmic process of working
    out the most general possible type of any given expression, and when the expression
    is structurally typed, such as `let pair(x) = (x, x)`, it can infer types that
    are parameterized (such as `'a => ('a, 'a)`) because it doesn't know, or doesn't
    need to know, exactly what they are.
  prefs: []
  type: TYPE_NORMAL
- en: A **type parameter** is an as-yet-unknown type that will be specified later
    in use. Reason supports type parameters on all types, including nominal types.
    This gives record and variant types a new dimension (literally) of data modeling
    power. Let's now explore a few of the most basic but also important parameterized
    data types in Reason.
  prefs: []
  type: TYPE_NORMAL
- en: The list – modeling more than one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen how to model a list of person records in [Chapter 5](d3723975-7a3c-4369-84fe-272b67870234.xhtml),
    *Putting Alternative Values in Types,* but that data structure was limited to
    holding only values of person records. Ideally, we want a data structure that
    can hold values of *any* type, so that we don''t have to re-implement the type
    and its operations for every possible element type. We can accomplish this by
    parameterizing the list type by the element type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example shows how to generically hold objects of any given type,
    as well as do something specific with them. It is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we parameterize a nominal type (a variant type to be precise), `list`,
    with an explicit type parameter, `'a` (pronounced 'alpha'). Here we have only
    one, but types can have multiple type parameters. The syntax for declaring type
    parameters is `type typeName('param1, 'param2, ..., 'paramN)`. Note that type
    parameters must always start with the tick (`'`) character to distinguish them
    from regular types. Type parameters are also known as type variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We construct a list made up of `person` records we defined in a previous module.
    The compiler can infer its type to be `list(Ch04_RecordLiterals.person)`, because
    we slotted in the person type at the exact places where we declared the type parameter, `'a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define how to greet a single person. This operation doesn't make use of type
    parameters in any way, but it is a building block for a later operation that does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `greetAll`, we have an interesting pattern match on `people`. With the
    `Cons(person, people)` and `Empty` branches, the compiler infers that `people`
    has type `list('a)`, and with `greetOne(person)`, it infers that `'a = person`;
    overall the function has the type `list(person) => unit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we reach the end of the list, we don't want to do anything else, so we
    just return `()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how to build and operate on a polymorphic data type, let''s
    look at Reason''s built-in implementation of the `list` type. The built-in implementation
    works in much the same way as the one mentioned earlier, except Reason provides
    some nice syntactic sugar to make it easier to work with lists. Let''s take a
    look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First of all, notice that we got rid of the type declaration, since the Reason
    `list('a)` type is already built in and accessible from every module. To be precise,
    it's defined in the `Pervasives` module, whose contents are by default accessible
    from every module.
  prefs: []
  type: TYPE_NORMAL
- en: We use the list construction syntactic sugar, which is `[elem1, elem2, ... elemN]`,
    to construct a list that is essentially like our previous one `Cons(elem1, Cons(elem2,
    ... Cons(elemN, Empty) ... ))`. The brackets-and-commas syntax is flatter and
    easier to understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pattern matching on a list now looks like `[elem, ...restElems]` to bind to
    the first element and the list of remaining elements. The `...` is called the
    **spread operator** and is designed to look like JavaScript's array spread feature,
    which works similarly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We reuse the `greetOne` function we already defined since it doesn't depend
    on the specific list type—it just greets a single person.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty list pattern now looks like `[]` instead of `Empty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how succinct the list syntax is overall. It's designed for everyday use
    because lists are one of the most important data types in Reason, and in functional
    programming in general.
  prefs: []
  type: TYPE_NORMAL
- en: The option – modeling either none or one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a similar way to `list(''a)`, the `Pervasives` module also provides a data
    type, `option(''a)`. This time let''s look at its real definition, because there''s
    no syntactic sugar for it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In some ways, this is a simpler data type than the list. Its real utility comes
    from the meaning we give to the variant cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some(''a)`: Represents a value that is present and that is known'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`: Represents a value that is absent and is unknown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Reason, and some other languages, there is no concept of a null value, so
    this option type is used to represent that a value is present or absent. Whenever
    we'd use null, we can use options instead, with the benefit that optionality(the
    property that some value may be present or not) is captured in the type system,
    instead of behind the scenes. Because the `option` type is a variant, the compiler
    helps us to handle possible missing values through exhaustivity checking. There's
    no danger of forgetting to handle a null value and crashing at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Present and absent may still be somewhat vague concepts, so the following code
    is a more concrete example where we try to find a matching value in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define how to find an item in a list and safely handle
    the case of a missing item:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass in a list to search (called `haystack`) and a tester function (called
    `needle`) that tells us if we've found the value we're looking for. Since `haystack`
    is a list, we can pattern match on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first pattern looks at the first element of the list to see if it's the
    one we want, as determined by `needle`. We don't want to bind the rest of the
    elements, so we prefix the `_items` name with an underscore to tell Reason to
    ignore it. Notice that we're using the `when` clause here, as introduced in [Chapter
    5](d3723975-7a3c-4369-84fe-272b67870234.xhtml), *Putting Alternative Values in
    Types*. This is equivalent to using an `if` expression inside the body of the
    branch, but is slightly more succinct. If the first element matches the needle,
    we put it inside a `Some` constructor and evaluate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second pattern, we match against the remaining list of items after ignoring
    the first item, and recursively try to find the element we want in that. But this
    branch is only reached if the first branch doesn't match, meaning that the element
    wasn't the first item in the list. The branch itself evaluates to the result of
    `tryFind`, meaning either `Some(person)` or `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the final branch, we must handle the other possible state of the `haystack`
    list: being empty. If it is, we either started with an empty list or ended up
    with one by recursion. In either case, we didn''t find the element we wanted in
    the list, so we return `None`, which in this case means not found*.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we describe how to greet a person who may or may not be there. The compiler
    forces handling both `Some(person)` and `None` cases—we can't forget to handle
    a missing value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define two different `needle` functions, which test whether a given person's
    record has the ID 1 or 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the payoff: we can optionally greet a person, but only if we found
    the person with the given ID in our `people` list. We can run the following output
    script to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we find and greet the person (`Bob`) with `ID 1`, but not the one
    with `ID 4` because there is no such person.
  prefs: []
  type: TYPE_NORMAL
- en: In the output JavaScript, BuckleScript again converts the tail-recursive `tryFind`
    function into a simple imperative loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see two sides of using the `option` type: we may need to represent
    the presence or absence of a value during the normal course of our operation,
    and if we use a variant type such as `option`, we get the benefit of its exhaustivity
    checking.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable parameterized types – ref and array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason also provides two important parameterized types that allow their values
    to be mutated in place. This mutability brings efficiency gains for certain types
    of algorithms, but generally needs to be used carefully because, as we'll see,
    it may be a source of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a reference to a value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen an example of mutability, in the *Mutable record fields*
    section of [Chapter 4](ba37505a-f222-4238-a13c-259160ca582d.xhtml), *Grouping
    Values Together in Types*. Sometimes, we need to manage just one or two mutable
    values, and we might not want to go through the ceremony of declaring a new record
    type with mutable fields. For these situations, we can take advantage of the built-in
    `ref` type. The `ref` type essentially gives us a box, a ref, that lets us swap
    values in and out. The values themselves need not be mutable, just the box itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code listing shows the complete API of the `ref` type, explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's implemented as a record type with just a single mutable record field, but
    this field is parameterized by a type parameter, `'a`, letting us reuse it for
    any type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `ref` function to box a value of any type and put it inside
    a ref: `let count = ref(0);`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assignment operator `(:=)` is implemented as a function and can be used
    in the infix position: `count := 1;`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The dereference operator, `(^)`, is also implemented as a function, but Reason
    allows us to use it in postfix position: `let countVal = count^;`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`incr` and `decr` are convenience functions for incrementing and decrementing
    integers, as we often need to update counts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The huge benefit of using the `ref` type to manage mutation is that mutability
    is captured at the type level. We can tell from looking at any type signature
    that contains `ref(something)` that something of the `something` type is changing.
    By contrast, when we're using a mutable record field directly, we have no type-level
    indication of mutability, just the record definition itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using a `ref`: redefining the `tryGreet` function
    to use a more imperative style of walking through its input list and trying to
    find the required item. We''ll need three refs: the remaining portion of the haystack
    list, whether we should stop searching or not, and an optional found item. As
    long as we haven''t found the item yet, we''ll keep searching, but as soon as
    we find it, we''ll return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we use Reason''s imperative features (mutation and
    looping), explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We continuously loop until we explicitly say we should stop. Notice that an
    imperative `while` loop looks exactly as we might expect from other imperative
    languages such as JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pattern matching on the input `haystack list` is still the most convenient way
    to walk through it item by item, so we keep doing that here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we find the item we're looking for, we need to make sure that we set the
    stop indicator to `true`, and also set the found item so we can return it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we haven't found it yet but the list isn't empty, set the current haystack
    to be the remainder of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the list is empty, we obviously haven't found the item, so we need to stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whatever we've found (or haven't) so far, we finally need to dereference and
    return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing to notice about this imperative version is that it's more verbose.
    Keeping track of the mutable state involves some ceremony at the code level. It's
    not that imperative style in Reason is especially cumbersome; it would look much
    the same in any imperative language. It's just that functional style with recursion
    is, in general, more succinct because the recursive call effectively keeps track
    of the current state so we don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing to note is that we''ve preserved the same function signature
    (`(''a => bool, list(''a)) => option(''a)`) for this implementation, just without
    recursion. If we needed to, we could swap out this implementation for the recursive
    one, and our client code wouldn''t need a recompilation to use it. This is a property
    of many static type systems: if we preserve type signatures, we can freely swap
    out implementations. Reason''s type system in particular uses signatures to decide
    whether entire modules are compatible. This helps us pinpoint compatibility issues
    early, at build time, rather than find an incompatibility when running the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing an array of values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to efficiently manage and change many values of the same
    type. Reason provides the `array` type to help with this. We can think of an array
    as a single contiguous line of boxes of the same size, each of which can hold
    a value of the same type. Formally, it''s a polymorphic type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `array` data structure is characteristically similar to what you might
    have seen in other languages, in which:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows random access to its elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't allow recursive traversal of elements like `list` does with the spread
    (`[item, ...items]`) operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it does allow basic pattern matching on its elements. The following
    is an example of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we see the following simple use of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create an empty array, as well as arrays with one or more elements. The
    array delimiters are `[|` and `|]` and are used to distinguish them from lists
    which are more frequently used in Reason.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can assign to any valid index in the array (assigning to an out-of-bounds
    index will cause a runtime exception).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can read the value at any valid index (reading from an out-of-bounds index
    will also cause a runtime exception).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For arrays, the concept of indexing is important, as we can see here. Index-based
    random access is constant-time, but in return we have to take care to access only
    valid indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better sense of how arrays are useful, let''s try to implement a tic-tac-toe
    board using an array and a couple of functions that update and check the board,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interesting example of designing an array so we can pattern match
    it literally, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new game board by creating a new array filled with `Empty` slots,
    using the `Array.make` library function. This function gives us an array of the
    required length and is filled with a single value in all the indexes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we accept a one-indexed board coordinate, we convert it to a zero-indexed
    array index by simply subtracting one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can pattern match against the exact structure of the array. In this case,
    our nine-element array can look exactly like a tic-tac-toe board if we break it
    up into three rows purely for presentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `or` patterns to capture all the cases in which player X wins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return `true` for all of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, we return `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, the fact that we can easily set any position on the board when
    a player makes a move suits the random-access capability of an array. Setting
    random positions in a list would be an inefficient operation by comparison because
    the only way to do that is to traverse each element of the list and then perform
    several list-breaking and joining operations until we create the final output
    list.
  prefs: []
  type: TYPE_NORMAL
- en: In general, an array is very useful when we need to perform frequent updates
    over multiple elements. Common scenarios are pixel buffers and manually managed
    memory regions. Fortunately, Reason makes these scenarios relatively easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation and type inference restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, the compiler happily infers all sorts of types for us, but it does
    have some limitations. Sometimes, we need to give it a little nudge to help it
    get to the correct inference result, for example. The main case we need to be
    aware of is called **value restriction.** Value restriction basically means that
    mutable values can''t be generic, the compiler must know their types fully. The
    following is an example error you will get if you uncomment the code in the file
    `src/Ch06/Ch06_ValueRestrictionError.re`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the inferred type for `optionArr: array(option(''_a))`. The underscore
    prefix in front of the type variable name is the compiler''s way of saying that
    it ran into the value restriction. A type variable named `''_a` is called a **weak
    type variable** (in the sense that its actual type might change later).'
  prefs: []
  type: TYPE_NORMAL
- en: Having a type that might change after it's inferred at compilation is a bad
    idea. For example, let's think about what would happen if the compiler inferred
    the type as `array(option('a))`. Later in the code, we could set that index to
    `Some(1)`, then later still we could set it to `Some(false)`. This would defeat
    the type system entirely and leave us uncertain of what the exact type is at any
    point in the code. The compiler designers decided to prevent this from happening.
    This is just one of the type soundness decisions that they've made over the years
    to prevent runtime type errors from creeping into programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a valid code, we could precise the type using `array(option(string))`, as
    you can see in the alternative code file (`src/Ch06/Ch06_ValueRestrictionErrorFixed.re`)
    which compiles correctly. It''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at another value restriction error. Again, uncomment the code in
    the file `src/Ch06/Ch06_ValueRestrictionOtherError.re`, and you will get a compilation
    error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This one is slightly trickier as there's no obvious mutation. The `pairAll`
    function is supposed to convert a list of items into a list of pairs (2-tuples)
    of those items. The problem is that the `pair` function is generic; the compiler
    can't figure out if it might be mutating anything. If we'd had a monomorphic (that
    is, not generic) function instead, such as `let pair(x) = (x + 1, x - 1);`, then
    the compiler would be able to figure out that the inputs and outputs are just
    `int` and there's no mutation involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is another way to solve this particular error; remember that
    it''s called the *value* restriction. In other words, only values are restricted
    like this. If we expand `pairAll` into an explicit function, then the error goes
    away, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our fixed code can be found in `src/Ch06/Ch06_ValueRestrictionErrorFixed.re`.
  prefs: []
  type: TYPE_NORMAL
- en: This funny solution convinces the compiler that yes, this is really a function,
    so the value restriction doesn't apply.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing a difference with phantom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we can declare types that can slot in *any* type parameters, that includes
    type parameters that the types don't actually use. These are called phantom type
    parameters, or more informally **phantom types.**
  prefs: []
  type: TYPE_NORMAL
- en: A common use case for phantom types is in a kind of type-safe **builder pattern.**
    (The builder pattern is a piece of code that helps us to construct an object according
    to specific rules.) For example, we might want to construct syntactically valid
    SQL statements. One way to do that is to have a validator function that takes
    an input SQL statement and decides whether it follows SQL syntax rules or not
    at runtime. This function might try to parse the input statement and build an
    expression tree. If the tree can be built, the statement is valid. Otherwise,
    it's invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to approach this is to provide a set of functions that statically
    enforce that only syntactically valid statements can be created. The magic part
    of this is that we can tell the compiler exactly what the type parameter should
    be when it's not actually used in the type body. There's nothing in the type definition
    to contradict what we say, so the compiler must accept it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simplified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of simplicity, we''re dealing with only the `select` and `from`
    clauses in this SQL builder module, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We alias a couple of types to serve as documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the type with the phantom type parameter; to the module consumer, it
    looks like a normal parameterized type. Internally, it doesn't contain, or otherwise
    use, any values of its parameter type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function is the entry point into the build: it takes a column list and
    returns a partially constructed SQL statement. We can''t do anything with this
    returned value except feed it into the next function, `from`. Notice that the
    type parameters are literally the types of polymorphic variants named appropriately;
    they just act as tags.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementations of `select` and `from` are very simple: they just build
    normal strings in the form of syntactically valid SQL statements. The most interesting
    thing about them is that their types are enforced to take parameters such that
    they can only be called in a particular order: `select`, `from`, `print`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `print` function is strikingly simple in that it just returns the built
    string. We can examine that and then pass it into an SQL engine to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We build a syntactically valid SQL statement by calling the functions in the
    right order, enforced by the type system, and we then output them to the terminal.
    Note that the `|>` operator is called **pipe-forward**, and it's used to feed
    the output of one function as the input of the next one. We'll cover common operators
    in the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is the error we would have gotten if we''d tried to print
    an invalid SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This type error is saying that the `print` function expects a complete `ok`
    SQL statement, but has received only a `select` clause. The type parameters, working
    together with the module's functions, ensure that the SQL is constructed in the
    right way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into Reason's parameterized types, learning about
    type parameters and how they expand types to become generic, some common parameterized
    types that we use in Reason, the compiler's restrictions on using parameterized
    types and mutation together, and how to force the same underlying type to look
    different to the compiler using phantom type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw some instances of passing in functions as arguments to other functions,
    for example, `tryFind` and `List.map`. In the next chapter, we'll thoroughly cover
    functions and how Reason lets us treat them as first-class objects that we can
    pass around to allow our code to behave flexibly.
  prefs: []
  type: TYPE_NORMAL
