<html><head></head><body><div><h1 class="header-title">REST – What You Did Not Know</h1>
                
            
            
                
<p>Over the last few years, we have started taking for granted that data sources feeding for content, mobile device service feeds, or cloud computing are all driven by modern technologies, such as RESTful web services. Everybody has been talking about how their stateless model allows applications to scale easily and how it emphasizes on clear decoupling between data provisioning and data consumption. Nowadays, architects have started introducing the concept of microservices, aiming to reduce the complexity in systems by splitting their core components into small independent pieces that simply do a single task. So, enterprise-grade software is about to become a composite of such microservices. This makes it easy to maintain, and allows better life cycle management when new parts need to be introduced. Unsurprisingly, most of the microservices are serviced by RESTful frameworks. This fact may leave the impression that REST was invented sometime in the last decade, but that is far from the truth. In fact, REST has been around since the last decade of the previous century!</p>
<p>This chapter will walk you through the foundation of <strong>Representational State Transfer</strong> (<strong>REST</strong>) and will explain how REST couples with the HTTP protocol. You will look into five key principles that have to be considered while turning any HTTP application into a RESTful service-enabled application. You will also look at the differences between describing RESTful and classic <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>)-based web services. Finally, you will learn how to utilize already-existing infrastructure for your benefit.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>REST fundamentals</li>
<li>REST with HTTP</li>
<li>Essential differences in the description, discovery, and documentation of RESTful services compared to classical SOAP-based services</li>
<li>Taking advantage of existing infrastructure</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">REST fundamentals</h1>
                
            
            
                
<p>It actually happened back in 1999, when a request for comments was submitted to the <strong>Internet Engineering Task Force (IETF;</strong> <a href="http://www.ietf.org/" target="_blank">http://www.ietf.org/</a>) via RFC 2616: <em>Hypertext Transfer Protocol-HTTP/1.1</em>. One of its authors, Roy Fielding, later defined a set of principles built around the HTTP and URI standards. This gave birth to REST as we know it today.</p>
<p>These definitions were given in <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf </a>in the fifth chapter, <em>Representational State Transfer (REST)</em>, of Fielding's dissertation called <em>Architectural Styles and the Design of Network-Based Software Architectures</em>. The dissertation is still available at <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>.</p>
<p>Let's look at the key principles around the HTTP and URI standards, sticking to which will make your HTTP application a RESTful service-enabled application:</p>
<ol>
<li>Everything is a resource</li>
<li>Each resource is identifiable by a <strong>unique identifier</strong> (<strong>URI</strong>)</li>
<li>Resources are manipulated via standard HTTP methods</li>
<li>Resources can have multiple representations</li>
<li>Communicate with resources in a stateless manner</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Principle 1 – Everything is a resource</h1>
                
            
            
                
<p>To understand this principle, one must conceive of the idea of representing data by a specific format and not by a physical file containing a bunch of bytes. Each piece of data available on the internet has a format that describes it, known as the content type; for example, JPEG images, MPEG videos, HTML, XML, text documents, and binary data are all resources with the following content types: image/jpeg, video/mpeg, text/html, text/xml, and application/octet-stream.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Principle 2 – Each resource is identifiable by a unique identifier</h1>
                
            
            
                
<p>Since the internet contains so many different resources, they all should be accessible via URIs and should be identified uniquely. Furthermore, the URIs can be in a human-readable format, despite the fact that their consumers are more likely to be software programs rather than ordinary humans.</p>
<p>Human-readable URIs keep data self-descriptive and ease further development against it. This helps you to keep the risk of logical errors in your programs to a minimum.</p>
<p>Here are a few sample examples of such URIs representing different resources in a catalog application:</p>
<ul>
<li><a href="http://www.mycatalog.com/categories/watches" target="_blank">http://www.mycatalog.com/categories/watches</a></li>
<li><a href="http://www.mycatalog.com/categories/watches?collection=2018">http://www.mycatalog.com/categories/watches?collection=2018</a></li>
<li><a href="http://www.mycatalog.com/categories/watches/model-xyz/image">http://www.mycatalog.com/categories/watches/model-xyz/image</a></li>
<li><a href="http://www.mycatalog.com/categories/watches/model-xyz/video">http://www.mycatalog.com/categories/watches/model-xyz/video</a></li>
<li><a href="http://www.mycatalog.com/archives/2017/categories/watches.zip">http://www.mycatalog.com/archives/2017/categories/watches.zip</a></li>
</ul>
<p>These human-readable URIs expose different types of resources in a straightforward manner. In the preceding example URIs, it is quite clear the data is items in a catalog, which are categorized watches. The first link shows all the items in the category. The second shows only the ones that are part of the 2018 collection. Next is a link pointing to the image of the item, followed by a link to a sample video. The last link points to a resource containing items from the previous collection in a ZIP archive. The media types served per each URI are rather easy to identify, with the assumption that the data format of an item is either JSON or XML, so we can easily map the media type of a self-described URL to one of the following:</p>
<ul>
<li>JSON or XML documents describing the items</li>
<li>Images</li>
<li>Videos</li>
<li>Binary archive documents</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Principle 3 – Manipulate resources via standard HTTP methods</h1>
                
            
            
                
<p>The native HTTP protocol (RFC 2616) defines eight actions, also known as HTTP verbs:</p>
<ul>
<li><kbd>GET</kbd></li>
<li><kbd>POST</kbd></li>
<li><kbd>PUT</kbd></li>
<li><kbd>DELETE</kbd></li>
<li><kbd>HEAD</kbd></li>
<li><kbd>OPTIONS</kbd></li>
</ul>
<ul>
<li><kbd>TRACE</kbd></li>
<li><kbd>CONNECT</kbd></li>
</ul>
<p>The first four of them just feel natural in the context of resources, especially when defining actions for data manipulation. Let's make a parallel with relative SQL databases where the native language for data manipulation is <strong>CRUD</strong> (short for <strong>Create, Read, Update, and Delete</strong>), originating from the different types of SQL statements, <kbd>INSERT</kbd>, <kbd>SELECT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd>, respectively. In the same manner, if you apply the REST principles correctly, the HTTP verbs should be used as shown here:</p>
<table style="border-collapse: collapse" class="table" border="1">
<tbody>
<tr>
<td><strong>HTTP verb</strong></td>
<td><strong>Action</strong></td>
<td><strong>HTTP response status code</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td>Retrieves an existing resource.</td>
<td><kbd>200 OK</kbd> if the resource exists, <kbd>404 Not Found</kbd> if it does not exist, and <kbd>500 Internal Server Error</kbd> for other errors.</td>
</tr>
<tr>
<td><kbd>PUT</kbd></td>
<td>Updates a resource. If the resource does not exist, the server can either decide to create it with the provided identifer or return the appropriate status code.</td>
<td>
<p class="mce-root"><kbd>200 OK</kbd> if successfully updated, <kbd>201 Created</kbd> if a new resource is created, <kbd>404 Not found</kbd> if the resource to be updated does not exist, and <kbd>500 Internal Server Error</kbd> for other unexpected errors.</p>
</td>
</tr>
<tr>
<td><kbd>POST</kbd></td>
<td>Creates a resource with an identifier generated at server side or updates a resource with an existing identifier provided from the client. If this verb is to be used only for creating but not for updating, return the appropriate status code.</td>
<td><kbd>201 CREATED</kbd> if a new resource is created, <kbd>200 OK</kbd> if the resource has been updated successfully, <kbd>409 Conflict</kbd> if the resource already exists and update is not allowed, <kbd>404 Not Found</kbd> if the resource to be updated does not exist, and <kbd>500 Internal Server Error</kbd> for other errors.</td>
</tr>
<tr>
<td><kbd>DELETE</kbd></td>
<td>Deletes a resource.</td>
<td><kbd>200 OK</kbd> or <kbd>204 No Content</kbd> if the resource has been deleted successfully, <kbd>404 Not Found</kbd> if the resource to be deleted does not exist, and <kbd>500 Internal Server Error</kbd> for other errors.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Note that a resource might be created by either the <kbd>POST</kbd> or <kbd>PUT</kbd> HTTP verbs, based on the policy of an application. However, if a resource has to be created under a specific URI with an identifier provided by the client, then <kbd>PUT</kbd> is the appropriate action:</p>
<pre>PUT /categories/watches/model-abc HTTP/1.1
Content-Type: text/xml
Host: www.mycatalog.com

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Item category="watch"&gt;<br/>    &lt;Brand&gt;...&lt;/Brand&gt;<br/>    &lt;/Price&gt;&lt;/Price&gt;
&lt;/Item&gt;<br/><br/>HTTP/1.1 201 Created <br/>Content-Type: text/xml <br/>Location: http://www.mycatalog.com/categories/watches/model-abc<br/><br/></pre>
<p>However, in your application, you may want to leave it up to the backend RESTful service to decide where to expose the newly created resource, and thus create it under an appropriate but still unknown or non-existent location.</p>
<p>For instance, in our example, we might want the server to define the identifier of newly created items. In such cases, just use the <kbd>POST</kbd> verb to a URL without providing an identifier parameter. Then it is up to the service itself to provide a new unique and valid identifier for the new resource and to expose back this URL via the <kbd>Location</kbd> header of the response:</p>
<pre>POST /categories/watches HTTP/1.1
Content-Type: text/xml
Host: www.mycatalog.com

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Item category="watch"&gt;<br/>    &lt;Brand&gt;...&lt;/Brand&gt;<br/>    &lt;/Price&gt;&lt;/Price&gt;
&lt;/Item&gt;<br/><br/>HTTP/1.1 201 Created <br/>Content-Type: text/xml <br/>Location: http://www.mycatalog.com/categories/watches/model-abc</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Principle 4 – Resources can have multiple representations</h1>
                
            
            
                
<p>A key feature of a resource is that it may be represented in a different format from the one in which it is stored. Thus, it can be requested or created in different representations. As long as the specified format is supported, the REST-enabled endpoint should use it. In the preceding example, we posted an XML representation of a watch item, but if the server had supported the JSON format, the following request would have been valid as well:</p>
<pre>POST /categories/watches HTTP/1.1
Content-Type: application/json
Host: www.mycatalog.com

{
  "watch": {
    "id": ""watch-abc"",
    "brand": "...",
    "price": {
      "-currency": "EUR",
      "#text": "100"
    }
  }
}
HTTP/1.1 201 Created
Content-Type: application/json
Location: http://mycatalog.com/categories/watches/watch-abc   </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Principle 5 – Communicate with resources in a stateless manner</h1>
                
            
            
                
<p>Resource manipulation operations through HTTP requests should always be considered atomic. All modifications of a resource should be carried out within an HTTP request in an isolated manner. After the request execution, the resource is left in a final state; this implicitly means that partial resource updates are not supported. You should always send the complete state of the resource.</p>
<p>Back to our catalog example, updating the price field of a given item would mean making a PUT request with a complete document (JSON or XML) that contains the entire data, including the updated price field. Posting only the updated price is not stateless, as it implies that the application is aware that the resource has a price field, that is, it knows its state.</p>
<p>Another requirement for your RESTful application to be stateless is that once the service gets deployed on a production environment, it is likely that incoming requests are served by a load balancer, ensuring scalability and high availability. Once exposed via a load balancer, the idea of keeping your application state at server side gets compromised. This doesn't mean that you are not allowed to keep the state of your application. It just means that you should keep it in a RESTful way. For example, keep a part of the state within the URI, or use HTTP headers to provide additional state-related data</p>
<p>The statelessness of your RESTful API isolates the caller against changes at the server side. Thus, the caller is not expected to communicate with the same server in consecutive requests. This allows easy application of changes within the server infrastructure, such as adding or removing nodes.</p>
<p>Remember that it is your responsibility to keep your RESTful APIs stateless, as the consumers of the APIs would expect them to be.</p>
<p>Now that you know that REST is around 18 years old, a sensible question would be, "Why has it become so popular just quite recently?" Well, we the developers usually reject simple, straightforward approaches and, most of the time, prefer spending more time on turning already-complex solutions into even more complex and sophisticated ones.</p>
<p>Take classical SOAP web services, for example. Their various WS-* specifications are so many, and sometimes so loosely defined, that in order to make different solutions from different vendors interoperable, a separate specification, WS-Basic Profile, has been introduced. It defines extra interoperability rules in order to ensure that all WS-* specifications in SOAP-based web services can work together.</p>
<p>When it comes to transporting binary data with classical web services over HTTP, things get even more complex, as SOAP-based web services provide different ways of transporting binary data. Each way is defined in other sets of specifications, such as <strong>SOAP with</strong> <strong>Attachment References</strong> (<strong>SwaRef</strong>) and <strong>Message Transmission</strong> <strong>Optimization Mechanism (MTOM).</strong> All this complexity was caused mainly because the initial idea of the web service was to execute business logic remotely, not to transport large amounts of data.</p>
<p>The real world has shown us that, when it comes to data transfer, things should not be that complex. This is where REST fits into the big picture—by introducing the concept of resources and a standard means for manipulating them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The REST goals</h1>
                
            
            
                
<p>Now that we've covered the main REST principles, it is time to dive deeper into what can be achieved when they are followed:</p>
<ul>
<li>Separation of the representation and the resource</li>
<li>Visibility</li>
<li>Reliability</li>
<li>Scalability</li>
<li>Performance</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Separation of the representation and the resource</h1>
                
            
            
                
<p>A resource is just a set of information, and as defined by principle 4, it can have multiple representations; however, its state is atomic. It is up to the caller to specify the desired media type with the <kbd>Accept</kbd> header in the HTTP request, and then it is up to the server application to handle the representation accordingly, returning the appropriate content type of the resource together with a relevant HTTP status code:</p>
<p class="mce-root"/>
<ul>
<li><kbd>HTTP 200 OK</kbd> in the case of success</li>
<li><kbd>HTTP 400 Bad Request</kbd> if an unsupported format is given or for any other invalid request information</li>
<li><kbd>HTTP 406 Not Acceptable</kbd> if an unsupported media type is requested</li>
</ul>
<ul>
<li><kbd>HTTP 500 Internal Server Error</kbd> when something unexpected happens during the request processing</li>
</ul>
<p>Let's assume that, at server side, we have items resources stored in an XML format. We can have an API that allows a consumer to request the item resources in various formats, such as <kbd>application/xml</kbd>, <kbd>application/json</kbd>, <kbd>application/zip</kbd>, <kbd>application/octet-stream</kbd>, and so on.</p>
<p>It would be up to the API itself to load the requested resource, transform it into the requested type (for example, JSON or XML), and either use ZIP to compress it or directly flush it to the HTTP response output.</p>
<p>The caller would make use of the <kbd>Accept</kbd> HTTP header to specify the media type of the response they expect. So, if we want to request our item data inserted in the previous section in XML format, the following request should be executed:</p>
<pre>GET /category/watches/watch-abc HTTP/1.1 
Host: my-computer-hostname 
Accept: text/xml 
 
HTTP/1.1 200 OK 
Content-Type: text/xml 
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Item category="watch"&gt;<br/>    &lt;Brand&gt;...&lt;/Brand&gt;<br/>    &lt;/Price&gt;&lt;/Price&gt;
&lt;/Item&gt;</pre>
<p>To request the same item in JSON format, the <kbd>Accept</kbd> header needs to be set to <kbd>application/json</kbd>:</p>
<pre>GET /categoery/watches/watch-abc HTTP/1.1 
Host: my-computer-hostname 
Accept: application/json 
 
HTTP/1.1 200 OK 
Content-Type: application/json 
{
  "watch": {
    "id": ""watch-abc"",
    "brand": "...",
    "price": {
      "-currency": "EUR",
      "#text": "100"
    }
  }
}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Visibility</h1>
                
            
            
                
<p>REST is designed to be visible and simple. Visibility of the service means that every aspect of it should self-descriptive and follow the natural HTTP language according to principles 3, 4, and 5.</p>
<p>Visibility in the context of the outer world would mean that monitoring applications would be interested only in the HTTP communication between the REST service and the caller. Since the requests and responses are stateless and atomic, nothing more is needed to flow the behavior of the application and to understand whether anything has gone wrong.</p>
<p>Remember that caching reduces the visibility of your RESTful applications and in general should be avoided, unless needed for serving resources subject to large amounts of callers. In such cases, caching may be an option, after carefully evaluating the possible consequences of serving obsolete data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reliability</h1>
                
            
            
                
<p>Before talking about reliability, we need to define which HTTP methods are safe and which are idempotent in the REST context. So, let's first define what safe and idempotent methods are:</p>
<ul>
<li>An HTTP method is considered to be safe provided that, when requested, it does not modify or cause any side effects on the state of the resource</li>
<li>An HTTP method is considered to be idempotent if its response stays the same, regardless of the number of times it is requested, am idempotent request always gives back the same request, if repeated identically.</li>
</ul>
<p>The following table lists which HTTP methods are safe and which are idempotent:</p>
<table style="border-collapse: collapse" class="table" border="1">
<tbody>
<tr>
<td><strong>HTTP method</strong></td>
<td><strong>Safe</strong></td>
<td><strong>Idempotent</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><kbd>POST</kbd></td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><kbd>PUT</kbd></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><kbd>DELETE</kbd></td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Consumers should consider operation's safety and the idempotence features in order to be served reliably.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Scalability and performance</h1>
                
            
            
                
<p>So far, we stressed the importance of having stateless behavior for a RESTful web application. The <strong>World Wide Web</strong> (<strong>WWW</strong>) is an enormous universe, containing huge amount of data and a lot of users, eager to get that data. The evolution of the WWW has brought the requirement that applications should scale easily as their load increases. Scaling applications that have a state is difficult to achieve, especially when zero or close-to-zero operational downtime is expected.</p>
<p>That's why staying stateless is crucial for any application that needs to scale. In the best-case scenario, scaling your application would require you to put another piece of hardware for a load balancer, or bring another instance in your cloud environment. There would be no need for the different nodes to sync between each other, as they should not care about the state at all. Scalability is all about serving all your clients in an acceptable amount of time. Its main idea is to keep your application running and to prevent <strong>Denial of Service</strong> (<strong>DoS</strong>) caused by a huge amount of incoming requests.</p>
<p>Scalability should not be confused with the performance of an application. Performance is measured by the time needed for a single request to be processed, not by the total number of requests that the application can handle. The asynchronous non-blocking architecture and event-driven design of Node.js make it a logical choice for implementing an application that scales and performs well.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with WADL</h1>
                
            
            
                
<p>If you are familiar with SOAP web services, you may have heard of the <strong>Web Service Definition Language</strong> (<strong>WSDL</strong>). It is an XML description of the interface of the service and defines an endpoint URL for invocation. It is mandatory for a SOAP web service to be described by such a WSDL definition.</p>
<p>Similar to SOAP web services, RESTful services can also make use of a description language, called WADL. <strong>WADL</strong> stands for <strong>Web Application Definition Language</strong>. Unlike WSDL for SOAP web services, a WADL description of a RESTful service is optional, that is, consuming the service has nothing to do with its description.</p>
<p>Here is a sample part of a WADL file that describes the <kbd>GET</kbd> operation of our catalog service:</p>
<div><p> </p>
<pre class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02" xmlns:service="http://localhost:8080/catalog/" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;grammer&gt;
    &lt;include href="items.xsd" /&gt;
    &lt;include href="error.xsd" /&gt;
  &lt;/grammer&gt;
  &lt;resources base="http://localhost:8080/catalog/categories"&gt;
    &lt;resource path="{category}"&gt;
      &lt;method name="GET"&gt;
        &lt;request&gt;
          &lt;param name="category" type="xsd:string" style="template" /&gt;
        &lt;/request&gt;
        &lt;response status="200"&gt;
          &lt;representation mediaType="application/xml" element="service:item" /&gt;
          &lt;representation mediaType="application/json" /&gt;
        &lt;/response&gt;
        &lt;response status="404"&gt;
          &lt;representation mediaType="application/xml" element="service:item" /&gt;
        &lt;/response&gt;
      &lt;/method&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/application&gt;</pre></div>
<p>This extract of a WADL file shows how application, exposing resources is described. Briefly, each resource must be part of an application. The resource provides a, where it is located with the <kbd>base</kbd> attribute, and describes each of its supported HTTP methods in a method. Additionally, an optional <kbd>doc</kbd> element can be used at resource and application to provide additional documentation about the service and its operations.</p>
<p>Though WADL is optional, it significantly reduces the efforts of discovering RESTful services.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Documenting RESTful APIs with Swagger</h1>
                
            
            
                
<p>Public APIs exposed on the web should be well documented, otherwise it would be difficult for developers to use them in their applications. While WADL definitions might be considered a source of documentation, they address a different problem—the discovery of the service. They serve metadata for the services to machines, not to humans. The Swagger project (<a href="https://swagger.io/">https://swagger.io/</a>) addresses the need for neat documentation of RESTful APIs. It defines a meta description of an API from an almost human-readable JSON format. The following is a sample <kbd>swagger.json</kbd> file, partially describing the catalog service:</p>
<pre>{<br/>  "swagger": "2.0",<br/>  "info": {<br/>    "title": "Catalog API Documentation",<br/>    "version": "v1"<br/>  },<br/>  "paths": {<br/>    "/categories/{id}" : {<br/>      "get": {<br/>        "operationId": "getCategoryV1",<br/>        "summary": "Get a specific category ",<br/>        "produces": [<br/>          "application/json"<br/>        ],<br/>        "responses": {<br/>          "200": {<br/>            "description": "200 OK",<br/>            "examples": <br/>              {"application/json": {                <br/>                "id": 1,<br/>                "name": "Watches",<br/>                "itemsCount": 550<br/>                }                <br/>              } <br/>          },<br/>          "404": {"description" : "404 Not Found"},<br/>          "500": {"description": "500 Internal Server Error"}<br/>        }<br/>      }<br/>    }<br/>  },<br/>  "consumes": ["application/json"]<br/>}</pre>
<p>The <kbd>swagger.json</kbd> file is really straightforward: it defines a name and version of your API and gives a brief description of each operation it exposes, nicely coupled with a sample payload. But the real benefit from it comes in another subproject of Swagger, called <kbd>swagger-ui</kbd> (<a href="https://swagger.io/swagger-ui/">https://swagger.io/swagger-ui/</a>), which actually renders this data from <kbd>swagger.json</kbd> nicely into an interactive web page that only provides documentation, but also allows interaction with the service:</p>
<div><img src="img/44bb4441-4f88-4d96-93a8-76305dcfac7c.png" width="1666" height="946"/></div>
<p>We will have a look at and utilize the <kbd>swagger-ui</kbd> Node.js module to provide the API that we will develop later in the book, with up-to-date documentation.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Taking advantage of the existing infrastructure</h1>
                
            
            
                
<p>The best part of developing and distributing RESTful applications is that the infrastructure needed is already out there, available to you. As RESTful applications use the existing web space heavily, you need to do nothing more than follow the REST principles when developing. In addition, there are plenty of libraries available out there for any platform, and I do mean any platform. This eases the development of RESTful applications, so you just need to choose your preferred platform and start developing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned about foundation of a REST, looking at five key principles that transform a web application into a REST-enabled application. We made a brief comparison between RESTful services and classical SOAP web services, and finally took a look at how RESTful services are documented and how we can simplify the discovery of the services we develop.</p>
<p>Now that you know the basics, we are ready to dive into the Node.js way of implementing RESTful services. In the next chapter, you will learn about the essentials of Node.js and the accompanying tools that it is necessary to use and understand in order to build a real-life fully-fledged web service.</p>


            

            
        
    </div>



  </body></html>