<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor108"/>7</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor109"/>Progressive Enhancement with Actions</h1>
<p>Progressive enhancement is a design philosophy in web development that emphasizes providing content and core functionality to everyone while delivering an enhanced experience to users who can afford it.</p>
<p>In this chapter, we will start with a more in-depth discussion of what progressive enhancement is. There are many ways to achieve progressive enhancement in your application; we will explore one of them by using Svelte actions. I will explain my reasoning as to why I think Svelte actions are designed for this use case.</p>
<p>Toward the end of the chapter, we will go through a few examples of using Svelte actions to progressively enhance our application.</p>
<p>By the end of this chapter, you will be able to build an application that follows the principles of progressive enhancement and supports as many user devices as possible.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>What is progressive enhancement?</li>
<li>Why use Svelte actions for progressive enhancement?</li>
<li>Examples of progressive enhancements using Svelte actions</li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Technical requirements</h1>
<p>You can find the examples and code for this chapter here: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>What is progressive enhancement?</h1>
<p>The most important thing in <em class="italic">progressive enhancement</em> is missing from the phrase itself. Something that is implied here is where are we progressively enhancing from.</p>
<p>The main <a id="_idIndexMarker258"/>idea of progressive enhancement is to provide a great baseline of essential content and core functionality to everyone, regardless of the browser software, device hardware, or the quality of the internet connection. Older browser software may not support newer JavaScript syntaxes and CSS features; older device hardware may take up more time to process and render your web page; a slower internet connection may take longer to load the resources needed to display your web page.</p>
<p>How do we ensure our web page stays usable for as many users as possible? Think about this for a while—I will come back to it later.</p>
<p>For users who can afford better browsers, more powerful hardware, and higher internet bandwidth, we progressively provide an enhanced experience to them. We leverage the power of JavaScript and CSS to surprise and delight our users.</p>
<p>How do we differentiate between the users and decide when to deliver an enhanced experience?</p>
<p>There is another term that is often used to compare with progressive enhancement, and that is <em class="italic">graceful degradation</em>. Graceful degradation <a id="_idIndexMarker259"/>starts from a feature-rich baseline and gracefully handles the situation when the user browser can no longer support the feature by replacing it with a simpler alternate experience. A lot of the time, these features start with a more complex assumption, and so execution-wise, it is much harder to gracefully degrade to all kinds of users.</p>
<p>Progressive enhancement, on the other hand, starts from a baseline that works for most users and slowly works its way up by adding more features. So, we can be sure that when a new feature is not loaded or does not work, users will still have a basic working web page.</p>
<p>So, let’s get back to our question: <em class="italic">How do we make sure that our web page is usable to all users?</em> We’ll uncover that in the following section.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Progressively enhancing the web experience</h2>
<p>One <a id="_idIndexMarker260"/>of the ways is to make sure that we follow the standards. HTML, CSS, and JavaScript are the main languages of the web. We make sure we only use language features that are part of the standard specifications. Features that have been part of the specifications for longer have a higher probability of being implemented by all browsers. The latest and hottest features are less likely to be available in all browsers.</p>
<p>So, build your web pages with standard HTML, CSS, and JavaScript.</p>
<p>This then leads to the next question: <em class="italic">How do we deliver a differentiating experience to users based on their browser, device, and </em><em class="italic">network capabilities?</em></p>
<p>There are many ways to do this.</p>
<p>One key idea for<a id="_idIndexMarker261"/> most approaches is to build your application layer by layer. Start with the first layer of core functionality and make sure everything works. Then, add subsequent layers to enhance the experience.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Building web pages in layers</h2>
<p>One example <a id="_idIndexMarker262"/>of building web pages in layers is to build the base content and functionality in HTML as the base layer, then add styles, transitions, and animations using CSS as the next layer. Finally, complex interactivity is added using JavaScript as the final layer.</p>
<p>This aligns with how the browser loads your website.</p>
<p>Whenever a user visits your website, the first thing the browser downloads from your website is HTML. HTML describes your content. HTML tags such as <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, and <code>&lt;table&gt;</code> describe how your content should be laid out on the screen. HTML tags such as <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, and <code>&lt;a&gt;</code> describe how users can submit data and interact with your content.</p>
<p>With HTML, your website should already provide basic content and functionality to the user.</p>
<p>And if you have <code>&lt;link rel="stylesheet"&gt;</code> within the HTML, with reference to external CSS files, the browser will then make separate requests to download the CSS resource and parse and apply the CSS styles to your document. This will, in turn, enhance the look and feel of the default browser styles. HTML can offer basic layouts, but with CSS, you can have advanced layouts, such as flex layouts, grid layouts, and so on.</p>
<p>On the other hand, if you have <code>&lt;script&gt;</code> tags in your HTML, the browser will seek them out and load the referenced JavaScript files, and as soon as the JavaScript files are downloaded, the browser will parse them and execute them. JavaScript can be used to dynamically make changes to the DOM, perform computations, and add interactivity to the website.</p>
<p>Without JavaScript, HTML forms alone allow users to submit data; however, upon submission, the browser will navigate to a new location based on the form action. With JavaScript, you can make an asynchronous HTTP request to send data to the server while the user can continue browsing on the same page.</p>
<p>So, as you <a id="_idIndexMarker263"/>can see, serving HTML as a base experience layer and adding CSS and JavaScript on top for an enhanced experience is progressive enhancement.</p>
<p>Users with older browsers, slower hardware, and lower internet bandwidth can still view and interact with your website with just HTML while waiting for CSS and JavaScript to be downloaded and executed for a more enhanced experience.</p>
<p>Hopefully, you are now convinced about the first HTML approach. But what if your website content is dynamic? How do you generate dynamic HTML for the user? Do you need to write separate code to generate dynamic HTML?</p>
<p>No, you don’t.</p>
<p>Svelte <a id="_idIndexMarker264"/>supports <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>). What that means is that the same Svelte component can be used to render content on the browser as well as generate HTML on the server side.</p>
<p>You can set it up yourself (however, that’s beyond the scope of this book), or you can use meta frameworks such as SvelteKit, which comprehensively sets out how everything should work.</p>
<p>One thing to take away from here is that no matter your setup, it is possible to write your Svelte component as is and have the same Svelte component code that you write used in both generating HTML on the server side and rendering content on the browser side.</p>
<p>This begs the question: Does all the code work the same way on both the server side and the browser side? Is there code that only runs on the server but not on the browser, or the other way around?</p>
<p>Well, not all code runs both on the server side and on the browser. Svelte actions, along with <code>bind:</code> directives and <code>on:</code> event listeners, are Svelte features that do not run on both the server side and the browser side. Svelte actions only run on the browser side and not on the server side. That’s because Svelte actions run after an element is added to the DOM. Since there’s no DOM when generating HTML strings on the server side, Svelte actions do not run on the server side.</p>
<p>This makes Svelte actions the perfect candidate for progressive enhancements.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Svelte actions for progressive enhancements</h2>
<p>In the <a id="_idIndexMarker265"/>previous section, we learned about progressive enhancements and the concept of building web pages in layers to achieve progressive enhancements.</p>
<p>In this section, we will delve deeper into the role of Svelte actions, which enable us to add an extra layer of interactivity to existing HTML elements, making them a natural fit for creating progressive enhancements.</p>
<p>Let’s begin by examining a code example in Svelte to understand how Svelte actions fit into this approach.</p>
<p>Now, imagine the following code:</p>
<pre class="source-code">
&lt;button use:enhance /&gt;</pre> <p>When rendered from the server side, you get HTML that looks like this:</p>
<pre class="source-code">
&lt;button&gt;&lt;/button&gt;</pre> <p>The HTML <code>button</code> element alone should be able to do what a button element is supposed to do: be clickable and able to submit forms.</p>
<p>But as JavaScript is loaded and the Svelte component code is executed, the <code>enhance</code> action is run with the <code>button</code> element, allowing the action code to enhance the <code>button</code> element.</p>
<p>Here are some examples of what the action could do: show a helpful tooltip upon hovering, provide a loading indicator when pressed, and so on.</p>
<p>Users with older browsers that are having trouble running the Svelte component code on the client side might still be able to use and interact with just the default HTML button element and experience an unenhanced version of the web page.</p>
<p>As we have gathered from this section, Svelte actions allow us to add another layer of interactivity to existing HTML elements. They are a naturally good candidate for designing progressive enhancements.</p>
<p>With that, let’s look at a few examples of using actions to progressively enhance HTML elements.</p>
<p>The first example we are going to look at is progressively enhancing the <code>&lt;</code><code>a&gt;</code> element.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Example – previewing a link with a &lt;a&gt; element</h1>
<p>In our<a id="_idIndexMarker266"/> first example, we will explore how to progressively <a id="_idIndexMarker267"/>enhance a <code>&lt;a&gt;</code> element to display a preview when hovered upon.</p>
<p>Here, the browser receives HTML that contains a <code>&lt;a&gt;</code> tag with a <code>href</code> attribute, like this:</p>
<pre class="source-code">
&lt;a href="..." /&gt;</pre> <p>It then creates a hyperlink. When you click on the hyperlink, the browser will navigate to the destination specified in the <code>href</code> attribute.</p>
<p>This is the default behavior of the <code>&lt;</code><code>a&gt;</code> element.</p>
<p>As the user loads the JavaScript, we want to make the <code>&lt;a&gt;</code> element do more than just navigate to a new location.</p>
<p>We are going to enhance the <code>&lt;a&gt;</code> element by having it show the destination location when hovering over it.</p>
<p>To do that, we are going to create a <code>preview</code> action and use it on the <code>&lt;</code><code>a&gt;</code> element:</p>
<pre class="source-code">
&lt;script&gt;
  function preview(element) {
  }
&lt;/script&gt;
&lt;a href="..." use:preview&gt;Hello&lt;/a&gt;</pre> <p>Regardless of how the <code>preview</code> action is implemented when rendering the preceding code on the server side, Svelte will generate the following HTML:</p>
<pre class="source-code">
&lt;a href="..." /&gt;Hello&lt;/a&gt;</pre> <p>This is because Svelte actions never run on the server side.</p>
<p>As soon as your user receives the HTML response, they can start clicking on the link and navigating to new locations. You now have a workable application with just the HTML.</p>
<p>Depending <a id="_idIndexMarker268"/>on the user’s network condition, your JavaScript code, compiled from your Svelte component, may take a longer time to arrive. But that does not stop the user from using the hyperlinks to navigate away.</p>
<p>Only when the<a id="_idIndexMarker269"/> JavaScript is loaded and executed does Svelte run the <code>preview</code> action with the <code>&lt;a&gt;</code> element that is on the DOM and enhances the <code>&lt;a&gt;</code> element’s behavior.</p>
<p>The point here is that, as much as possible, we make the core functionality of our application workable with just the HTML, and we add a layer of enhancement with JavaScript, which may come at a much later time depending on the user’s network condition.</p>
<p>Enough with the progressive enhancement philosophy. Let’s look at how we can implement this <code>preview</code> action.</p>
<p>We want the <code>preview</code> action to show a floating popup containing the content of the link when we move our mouse cursor over the link and hide it as we move our mouse cursor away.</p>
<p>We can achieve that with <code>'mouseover'</code> and <code>'mouseout'</code> events. Here’s how:</p>
<pre class="source-code">
function preview(element) {
  element.addEventListener('mouseover', onMouseOver);
  element.addEventListener('mouseout', onMouseOut);
  return {
    destroy() {
          element.removeEventListener('mouseover', onMouseOver);
          element.removeEventListener('mouseout', onMouseOut);
        }
  };
}</pre> <p>In the preceding code snippet, we add <code>'mouseover'</code> and <code>'mouseout'</code> event listeners at the beginning of the <code>preview</code> action. Additionally, we ensure proper cleanup by removing both the <code>'mouseover'</code> and <code>'mouseout'</code> event listeners in the <code>destroy</code> method. Before we figure out how to implement <code>onMouseOver</code> and <code>onMouseOut</code>, we need to first decide what the floating popup would look like and how would we lay it out in the DOM.</p>
<p>To show the <a id="_idIndexMarker270"/>content of the link target, we are going to use the <code>&lt;iframe&gt;</code> element, which allows us to embed another HTML page into the current one:</p>
<pre class="source-code">
&lt;iframe src="img/..." /&gt;</pre> <p>To make<a id="_idIndexMarker271"/> the <code>&lt;iframe&gt;</code> element float above other content instead of being part of the document flow, we will need to modify the CSS <code>position</code> property of the <code>&lt;iframe&gt;</code> element by using either <code>position: fixed</code> or <code>position: absolute</code>.</p>
<p>If we used <code>position: fixed</code> on the <code>&lt;iframe&gt;</code> element, then the <code>&lt;iframe&gt;</code> element would be positioned relative to the viewport. To place the <code>&lt;iframe&gt;</code> element right next to the <code>&lt;a&gt;</code> element, we will have to figure out the position of the <code>&lt;a&gt;</code> element relative to the viewport and calculate the top and left values to place our <code>&lt;</code><code>iframe&gt;</code> element.</p>
<p>On the other hand, if we used <code>position: absolute</code>, then the <code>&lt;iframe&gt;</code> element would be positioned relative to the nearest positioned parent element. We could place the <code>&lt;iframe&gt;</code> element inside the <code>&lt;a&gt;</code> element and make the <code>&lt;a&gt;</code> element a positioned parent element by specifying <code>position: relative</code> on the <code>&lt;a&gt;</code> element (the <code>position: relative</code> CSS property is to be positioned relative to its current position). The <code>&lt;iframe&gt;</code> element would then be positioned relative to its parent, the <code>&lt;</code><code>a&gt;</code> element.</p>
<p>Either approach has its pros and cons. I am going to use the second approach here, which is to use <code>position: absolute</code>. I will have to modify the content and the <code>position</code> CSS property of the <code>&lt;a&gt;</code> element, but I could get away from needing to perform calculations if I use <code>position: absolute</code> instead of <code>position: fixed</code>.</p>
<p>Here’s what the DOM will look like after we place the <code>&lt;iframe&gt;</code> element inside the <code>&lt;</code><code>a&gt;</code> element:</p>
<pre class="source-code">
&lt;a href="..." style="position: relative"&gt;Hello&lt;iframe src="img/..." style="position: absolute"/&gt;&lt;/a&gt;</pre> <p>Our task now is to <a id="_idIndexMarker272"/>programmatically create and insert the <code>&lt;iframe&gt;</code> element in the <code>onMouseOver</code> function. The following code snippet <a id="_idIndexMarker273"/>illustrates how to do this:</p>
<pre class="source-code">
function preview(element) {
  // make the &lt;a&gt; element position relative
  element.style.position = 'relative';
  let iframe;
  function onMouseOver() {
    iframe = document.createElement('iframe');
    iframe.src = element.getAttribute('href');
    iframe.style.position = 'absolute';
    iframe.style.left = 0;
    iframe.style.top = '100%';
    element.appendChild(iframe);
  }
  // ...
}</pre> <p>In the preceding code snippet, we set the CSS <code>position</code> property of the <code>&lt;a&gt;</code> element to <code>'relative'</code>. In the <code>onMouseOver</code> function, which will be called when the mouse is hovered over the <code>&lt;a&gt;</code> element, we programmatically create a <code>&lt;iframe&gt;</code> element, style it, and insert it into the <code>&lt;</code><code>a&gt;</code> element.</p>
<p>In the previous code, we are using the DOM API such as <code>document.createElement()</code> and <code>element.appendChild()</code>. Since the <code>&lt;iframe&gt;</code> element is programmatically created, we are also programmatically modifying its <code>style</code> attribute.</p>
<p>Luckily, in this example, we are only creating one element, but you can imagine how this could easily grow messy if we were to create more elements.</p>
<p>Since we<a id="_idIndexMarker274"/> are learning Svelte here and Svelte is designed to <a id="_idIndexMarker275"/>abstract out these imperative DOM instructions into declarative Svelte syntax, why not leverage Svelte in our action?</p>
<p>We can replace the previous imperative code with a Svelte component, like so:</p>
<pre class="source-code">
&lt;!-- IframePopup.svelte --&gt;
&lt;script&gt;
  export let src;
&lt;/script&gt;
&lt;iframe {src} /&gt;
&lt;style&gt;
  iframe {
    position: absolute;
    left: 0;
    top: 100%;
  }
&lt;/style&gt;</pre> <p>The preceding code snippet shows a Svelte component that contains a <code>&lt;iframe&gt;</code> element. This <code>&lt;iframe&gt;</code> element is equivalent to the one we created programmatically in the previous code snippet. It has the same CSS styles applied.</p>
<p>The Svelte component exposes a prop called <code>src</code>, and the value of the <code>src</code> prop will be used to set the value of the <code>src</code> attribute of the <code>&lt;iframe&gt;</code> element. Now, instead of calling the DOM APIs to create the <code>&lt;iframe&gt;</code> element, we can instantiate our Svelte component and pass the desired <code>src</code> value as the <code>src</code> prop to the component. In Svelte, you can instantiate a component by using the <code>new</code> keyword along with the component’s constructor, passing in any required props as part of the constructor arguments. The Svelte component will then render the <code>&lt;iframe&gt;</code> element with the specified <code>src</code> attribute value based on the passed prop. This simplifies the process of creating and managing a <code>&lt;iframe&gt;</code> element within our Svelte application:</p>
<pre class="source-code">
import IframePopup from './IframePopup.svelte';
function preview(element) {
  // ...
  function onMouseOver() {
<strong class="bold">    iframe = new IframePopup({</strong>
<strong class="bold">      // target specifies where we want the component</strong>
<strong class="bold">      // to be inserted into</strong>
<strong class="bold">      target: element,</strong>
<strong class="bold">      // we are passing the href value into the</strong>
<strong class="bold">      // component through props</strong>
<strong class="bold">      props: { src: element.getAttribute('href') },</strong>
<strong class="bold">    });</strong>
  }
  // ...
}</pre> <p>In the preceding <a id="_idIndexMarker276"/>code snippet, we’ve replaced the DOM operations<a id="_idIndexMarker277"/> in the <code>onMouseOver</code> function to instantiate the <code>IframePopup</code> Svelte component.</p>
<p>We need to remember to remove the popup when we move our mouse away from the link. Here’s how we can do that:</p>
<pre class="source-code">
function onMouseOut() {
  iframe.$destroy();
}</pre> <p>Although we are only inserting one HTML element into the DOM through Svelte actions, we’ve seen that it’s much more manageable to encapsulate that into a Svelte component and instantiate the Svelte component instead of manually creating HTML elements.</p>
<p>We can then leverage Svelte to create scoped styles, as well as add other interactive logic to the elements we are going to create.</p>
<p>We could also<a id="_idIndexMarker278"/> add transitions to elements; instead of appearing <a id="_idIndexMarker279"/>abruptly upon hovering, we can make the popup fade by using a <code>fade</code> transition, like so:</p>
<pre class="source-code">
&lt;!-- IframePopup.svelte --&gt;
&lt;script&gt;
  import { fade } from 'svelte/transition';
  // ...
&lt;/script&gt;
&lt;iframe {src} transition:fade /&gt;</pre> <p>By default, transitions are not played when the component is first created. So, we need to pass in the <code>intro: true</code> option to play the transition:</p>
<pre class="source-code">
iframe = new IframePopup({
  target: element,
  props: { src: element.getAttribute('href') },
  // play transition when created
  <strong class="bold">intro: true,</strong>
});</pre> <p>In the preceding code snippet, we pass in <code>intro: true</code> to the <code>IframePopup</code> constructor.</p>
<p>We now have a link that shows a preview in a popup that fades in upon hovering. Try simulating loading the page with a slow network. Most browsers provide developer tools to simulate network speed. For example, if you are using Google Chrome, then you can open the <strong class="bold">Developer Tools</strong>, find the <strong class="bold">Network conditions</strong> tab, look for the <strong class="bold">Network throttling</strong> section, and choose the <strong class="bold">Slow </strong><strong class="bold">3G</strong> preset.</p>
<p>Try reloading your page, and you’ll find that once you see the link (albeit the JavaScript file is still loading), the link is immediately working; clicking it will navigate you to the destination. As <a id="_idIndexMarker280"/>the JavaScript is finally loaded into the<a id="_idIndexMarker281"/> browser, your link is now enhanced, and you are now able to hover over the link and see a preview.</p>
<p>With our link preview action done, let’s look at another common component in a web app, forms, and see how we can progressively enhance a form element.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/>Example – progressively enhancing a form</h1>
<p>A <code>&lt;form&gt;</code> element is a <a id="_idIndexMarker282"/>section of a document that can contain inputs that will be used to submit information.</p>
<p>By default, when<a id="_idIndexMarker283"/> you submit a form, the browser will navigate to a URL to process the form submission. This means that the user will lose the state they are in as they navigate away from the current page when they submit the form.</p>
<p>However, with the ability to make asynchronous requests through the browser <code>fetch</code> API, we can now submit data through API requests without leaving the current page, and stay where we are.</p>
<p>This means that if the site is playing music, video, or animation, they will still be playing while we make asynchronous API calls.</p>
<p>Our task now is to create an action to enhance the form element so that the enhanced form will not navigate to a new location, but rather submit the form data asynchronously.</p>
<p>For lack of a better name, I am going to call this enhancing action <code>enhance</code>.</p>
<p>Before we proceed to implement the <code>enhance</code> action, let’s recap on the default form behavior.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>The default form behavior</h2>
<p>When<a id="_idIndexMarker284"/> you have a <code>&lt;form&gt;</code> element, by default when you hit the <code>action</code> attribute, carrying along with it the value filled in the <code>&lt;input&gt;</code> elements within the <code>&lt;</code><code>form&gt;</code> element.</p>
<p>For example, imagine you have the following form:</p>
<pre class="source-code">
&lt;form action="/foo"&gt;
  &lt;input name="name" /&gt;
  &lt;input name="address" /&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre> <p>When you hit the <code>/foo?name=xxx&amp;address=yyy</code>, carrying the form data via query parameters.</p>
<p>A <code>&lt;form&gt;</code> element <a id="_idIndexMarker285"/>can define the HTTP method to use to submit the form, by specifying the <code>method</code> attribute.</p>
<p>For example, the following form will navigate to <code>/foo</code> via a <code>POST</code> request:</p>
<pre class="source-code">
&lt;form action="/foo" method="post"&gt;...&lt;/form&gt;</pre> <p>Form data will be sent as a request body for the <code>POST</code> request.</p>
<p>Depending on the server’s implementation for the <code>/foo</code> endpoint, the server can choose how to process the data and what to show on the <code>/foo</code> page. Sometimes, the server may decide to redirect back to the current page after processing the data. In that case, having an action that can replace the default form action and submit the form data asynchronously instead would be very useful, since we will eventually come back to the same page.</p>
<p>Now we know the default form behavior, let’s figure out what we need to implement the <code>enhance</code> action.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Implementing the enhance action</h2>
<p>Let’s break the problem down.</p>
<p>First, we<a id="_idIndexMarker286"/> need to figure out how to know when a user submits a form. Then, we need to prevent the default form behavior and then make an asynchronous API call to submit the form asynchronously, and finally reset the form to the initial state, similar to what you would see after the server redirects back to the same page.</p>
<p>To figure out when the user submits a form, we could listen to the <code>'submit'</code> event on the <code>&lt;</code><code>form&gt;</code> element:</p>
<pre class="source-code">
form.addEventListener('submit', handleSubmit);</pre> <p>To prevent <a id="_idIndexMarker287"/>the default form behavior, we call <code>event.preventDefault()</code> on the <code>'submit'</code> event listener to prevent the default submit behavior:</p>
<pre class="source-code">
function handleSubmit(event) {
  event.preventDefault();
}</pre> <p>To make the API call to submit the form asynchronously, we need to first find out where we are submitting the form. We can get this information from reading the <code>action</code> property of the <code>form</code> instance:</p>
<pre class="source-code">
form.action; // "https://domain/foo"</pre> <p>We can also determine the preferred HTTP request method from the <code>form</code> instance:</p>
<pre class="source-code">
form.method // "post"</pre> <p>To get the form data submitted, we can use the <code>FormData</code> interface:</p>
<pre class="source-code">
const data = new FormData(form);</pre> <p>With the URL, request method, and data, we can use the <code>fetch</code> API to submit the form:</p>
<pre class="source-code">
fetch(form.action, {
  method: form.method,
  body: new FormData(form),
});</pre> <p>Finally, to reset the form, we can use the <code>reset()</code> method:</p>
<pre class="source-code">
form.reset()</pre> <p>Putting everything together, we have the following:</p>
<pre class="source-code">
&lt;script&gt;
  function enhance(form) {
    async function handleSubmit(event) {
      event.preventDefault();
      const response = await fetch(form.action, {
        method: form.method,
        body: new FormData(form),
      });
      form.reset();
    }
    form.addEventListener('submit', handleSubmit);
    return {
      destroy() {
        form.removeEventListener('submit', handleSubmit);
      }
    };
  }
&lt;/script&gt;
&lt;form action="/foo" method="post" use:enhance&gt;...&lt;/form&gt;</pre> <p>Now, try to<a id="_idIndexMarker288"/> submit the form after the JavaScript is loaded. You’ll notice that a network request is made to submit the form, while you remain on the same page without navigating away.</p>
<p>Try to disable the JavaScript or simulate a slow network speed. You’ll notice that you can still submit the form, while the JavaScript is still being loaded. However, this time round, you submit through the default browser behavior, which will navigate you away from the page.</p>
<p>Here we have it—a workable form by default, but progressively enhanced to submit form data without leaving the page if the JavaScript is being loaded.</p>
<p>There’s a lot that <a id="_idIndexMarker289"/>can be improved on the <code>enhance</code> action. I’ll leave that as an exercise:</p>
<ul>
<li>Modify the <code>enhance</code> action to allow passing in a callback function that will be called after the form submission is successfully made.</li>
<li>What happens if the form submission fails? How should you handle such a case?</li>
<li>Right now, the <code>enhance</code> action submits the form data through the request body; however, when the form method is <code>"get"</code>, form data should be passed through query parameters. Modify the <code>enhance</code> action to handle the <code>"get"</code> form method.</li>
</ul>
<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Summary</h1>
<p>In this chapter, we explained what progressive enhancement is and why it is important. Following up on that, we learned how we can use Svelte actions to progressively enhance our elements.</p>
<p>We went through two different examples of progressive enhancements—enhancing a link to make it show a preview popup, and enhancing form elements to submit a form asynchronously.</p>
<p>In the past three chapters, we’ve seen three different patterns and use cases of Svelte actions, creating custom events, integrating UI libraries, and progressive enhancements. What you can do with Svelte actions is not limited to the three different use cases that we’ve discussed so far, but hopefully, these patterns have opened your imagination and made you see what is possible with Svelte actions.</p>
<p>With that, we are moving on to the next part of the book. We will be exploring Svelte context and stores from <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a> to <a href="B18887_12.xhtml#_idTextAnchor175"><em class="italic">Chapter 12</em></a>, exploring their various use cases, such as in state management, creating renderless components, and using them for animations. We will start by defining and comparing Svelte contexts and Svelte stores in the next chapter.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-119" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor120"/>Part 3: Context and Stores</h1>
<p>In this part, we will dive deep into Svelte’s two core features, Svelte context and Svelte stores. Over the five chapters, we will explore different scenarios for using Svelte context and stores. We’ll start our exploration by defining Svelte context and stores. This will be followed by a deep dive into implementing custom stores and strategies for managing application state using Svelte stores. Following that, we will learn how to use Svelte context to create a renderless component. Finally, we will learn how to create animations using Svelte stores.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a><em class="italic">, Context versus Stores</em></li>
<li><a href="B18887_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a><em class="italic">, Implementing Custom Stores</em></li>
<li><a href="B18887_10.xhtml#_idTextAnchor152"><em class="italic">Chapter 10</em></a><em class="italic">, State Management with Svelte Stores</em></li>
<li><a href="B18887_11.xhtml#_idTextAnchor163"><em class="italic">Chapter 11</em></a><em class="italic">, Renderless Components</em></li>
<li><a href="B18887_12.xhtml#_idTextAnchor175"><em class="italic">Chapter 12</em></a><em class="italic">, Stores and Animation</em>s</li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>