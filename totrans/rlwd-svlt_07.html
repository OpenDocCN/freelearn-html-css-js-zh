<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor108"/>7</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor109"/>Progressive Enhancement with Actions</h1>
<p>Progressive enhancement is a design philosophy in web development that emphasizes providing content and core functionality to everyone while delivering an enhanced experience to users who can <span class="No-Break">afford it.</span></p>
<p>In this chapter, we will start with a more in-depth discussion of what progressive enhancement is. There are many ways to achieve progressive enhancement in your application; we will explore one of them by using Svelte actions. I will explain my reasoning as to why I think Svelte actions are designed for this <span class="No-Break">use case.</span></p>
<p>Toward the end of the chapter, we will go through a few examples of using Svelte actions to progressively enhance <span class="No-Break">our application.</span></p>
<p>By the end of this chapter, you will be able to build an application that follows the principles of progressive enhancement and supports as many user devices <span class="No-Break">as possible.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>What is <span class="No-Break">progressive enhancement?</span></li>
<li>Why use Svelte actions for <span class="No-Break">progressive enhancement?</span></li>
<li>Examples of progressive enhancements using <span class="No-Break">Svelte actions</span></li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Technical requirements</h1>
<p>You can find the examples and code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>What is progressive enhancement?</h1>
<p>The most important thing in <em class="italic">progressive enhancement</em> is missing from the phrase itself. Something that is implied here is where are we progressively <span class="No-Break">enhancing from.</span></p>
<p>The main <a id="_idIndexMarker258"/>idea of progressive enhancement is to provide a great baseline of essential content and core functionality to everyone, regardless of the browser software, device hardware, or the quality of the internet connection. Older browser software may not support newer JavaScript syntaxes and CSS features; older device hardware may take up more time to process and render your web page; a slower internet connection may take longer to load the resources needed to display your <span class="No-Break">web page.</span></p>
<p>How do we ensure our web page stays usable for as many users as possible? Think about this for a while—I will come back to <span class="No-Break">it later.</span></p>
<p>For users who can afford better browsers, more powerful hardware, and higher internet bandwidth, we progressively provide an enhanced experience to them. We leverage the power of JavaScript and CSS to surprise and delight <span class="No-Break">our users.</span></p>
<p>How do we differentiate between the users and decide when to deliver an <span class="No-Break">enhanced experience?</span></p>
<p>There is another term that is often used to compare with progressive enhancement, and that is <em class="italic">graceful degradation</em>. Graceful degradation <a id="_idIndexMarker259"/>starts from a feature-rich baseline and gracefully handles the situation when the user browser can no longer support the feature by replacing it with a simpler alternate experience. A lot of the time, these features start with a more complex assumption, and so execution-wise, it is much harder to gracefully degrade to all kinds <span class="No-Break">of users.</span></p>
<p>Progressive enhancement, on the other hand, starts from a baseline that works for most users and slowly works its way up by adding more features. So, we can be sure that when a new feature is not loaded or does not work, users will still have a basic working <span class="No-Break">web page.</span></p>
<p>So, let’s get back to our question: <em class="italic">How do we make sure that our web page is usable to all users?</em> We’ll uncover that in the <span class="No-Break">following section.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Progressively enhancing the web experience</h2>
<p>One <a id="_idIndexMarker260"/>of the ways is to make sure that we follow the standards. HTML, CSS, and JavaScript are the main languages of the web. We make sure we only use language features that are part of the standard specifications. Features that have been part of the specifications for longer have a higher probability of being implemented by all browsers. The latest and hottest features are less likely to be available in <span class="No-Break">all browsers.</span></p>
<p>So, build your web pages with standard HTML, CSS, <span class="No-Break">and JavaScript.</span></p>
<p>This then leads to the next question: <em class="italic">How do we deliver a differentiating experience to users based on their browser, device, and </em><span class="No-Break"><em class="italic">network capabilities?</em></span></p>
<p>There are many ways to <span class="No-Break">do this.</span></p>
<p>One key idea for<a id="_idIndexMarker261"/> most approaches is to build your application layer by layer. Start with the first layer of core functionality and make sure everything works. Then, add subsequent layers to enhance <span class="No-Break">the experience.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Building web pages in layers</h2>
<p>One example <a id="_idIndexMarker262"/>of building web pages in layers is to build the base content and functionality in HTML as the base layer, then add styles, transitions, and animations using CSS as the next layer. Finally, complex interactivity is added using JavaScript as the <span class="No-Break">final layer.</span></p>
<p>This aligns with how the browser loads <span class="No-Break">your website.</span></p>
<p>Whenever a user visits your website, the first thing the browser downloads from your website is HTML. HTML describes your content. HTML tags such as <strong class="source-inline">&lt;p&gt;</strong>, <strong class="source-inline">&lt;div&gt;</strong>, and <strong class="source-inline">&lt;table&gt;</strong> describe how your content should be laid out on the screen. HTML tags such as <strong class="source-inline">&lt;form&gt;</strong>, <strong class="source-inline">&lt;input&gt;</strong>, and <strong class="source-inline">&lt;a&gt;</strong> describe how users can submit data and interact with <span class="No-Break">your content.</span></p>
<p>With HTML, your website should already provide basic content and functionality to <span class="No-Break">the user.</span></p>
<p>And if you have <strong class="source-inline">&lt;link rel="stylesheet"&gt;</strong> within the HTML, with reference to external CSS files, the browser will then make separate requests to download the CSS resource and parse and apply the CSS styles to your document. This will, in turn, enhance the look and feel of the default browser styles. HTML can offer basic layouts, but with CSS, you can have advanced layouts, such as flex layouts, grid layouts, and <span class="No-Break">so on.</span></p>
<p>On the other hand, if you have <strong class="source-inline">&lt;script&gt;</strong> tags in your HTML, the browser will seek them out and load the referenced JavaScript files, and as soon as the JavaScript files are downloaded, the browser will parse them and execute them. JavaScript can be used to dynamically make changes to the DOM, perform computations, and add interactivity to <span class="No-Break">the website.</span></p>
<p>Without JavaScript, HTML forms alone allow users to submit data; however, upon submission, the browser will navigate to a new location based on the form action. With JavaScript, you can make an asynchronous HTTP request to send data to the server while the user can continue browsing on the <span class="No-Break">same page.</span></p>
<p>So, as you <a id="_idIndexMarker263"/>can see, serving HTML as a base experience layer and adding CSS and JavaScript on top for an enhanced experience is <span class="No-Break">progressive enhancement.</span></p>
<p>Users with older browsers, slower hardware, and lower internet bandwidth can still view and interact with your website with just HTML while waiting for CSS and JavaScript to be downloaded and executed for a more <span class="No-Break">enhanced experience.</span></p>
<p>Hopefully, you are now convinced about the first HTML approach. But what if your website content is dynamic? How do you generate dynamic HTML for the user? Do you need to write separate code to generate <span class="No-Break">dynamic HTML?</span></p>
<p>No, <span class="No-Break">you don’t.</span></p>
<p>Svelte <a id="_idIndexMarker264"/>supports <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>). What that means is that the same Svelte component can be used to render content on the browser as well as generate HTML on the <span class="No-Break">server side.</span></p>
<p>You can set it up yourself (however, that’s beyond the scope of this book), or you can use meta frameworks such as SvelteKit, which comprehensively sets out how everything <span class="No-Break">should work.</span></p>
<p>One thing to take away from here is that no matter your setup, it is possible to write your Svelte component as is and have the same Svelte component code that you write used in both generating HTML on the server side and rendering content on the <span class="No-Break">browser side.</span></p>
<p>This begs the question: Does all the code work the same way on both the server side and the browser side? Is there code that only runs on the server but not on the browser, or the other <span class="No-Break">way around?</span></p>
<p>Well, not all code runs both on the server side and on the browser. Svelte actions, along with <strong class="source-inline">bind:</strong> directives and <strong class="source-inline">on:</strong> event listeners, are Svelte features that do not run on both the server side and the browser side. Svelte actions only run on the browser side and not on the server side. That’s because Svelte actions run after an element is added to the DOM. Since there’s no DOM when generating HTML strings on the server side, Svelte actions do not run on the <span class="No-Break">server side.</span></p>
<p>This makes Svelte actions the perfect candidate for <span class="No-Break">progressive enhancements.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Svelte actions for progressive enhancements</h2>
<p>In the <a id="_idIndexMarker265"/>previous section, we learned about progressive enhancements and the concept of building web pages in layers to achieve <span class="No-Break">progressive enhancements.</span></p>
<p>In this section, we will delve deeper into the role of Svelte actions, which enable us to add an extra layer of interactivity to existing HTML elements, making them a natural fit for creating <span class="No-Break">progressive enhancements.</span></p>
<p>Let’s begin by examining a code example in Svelte to understand how Svelte actions fit into <span class="No-Break">this approach.</span></p>
<p>Now, imagine the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;button use:enhance /&gt;</pre> <p>When rendered from the server side, you get HTML that looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;button&gt;&lt;/button&gt;</pre> <p>The HTML <strong class="source-inline">button</strong> element alone should be able to do what a button element is supposed to do: be clickable and able to <span class="No-Break">submit forms.</span></p>
<p>But as JavaScript is loaded and the Svelte component code is executed, the <strong class="source-inline">enhance</strong> action is run with the <strong class="source-inline">button</strong> element, allowing the action code to enhance the <span class="No-Break"><strong class="source-inline">button</strong></span><span class="No-Break"> element.</span></p>
<p>Here are some examples of what the action could do: show a helpful tooltip upon hovering, provide a loading indicator when pressed, and <span class="No-Break">so on.</span></p>
<p>Users with older browsers that are having trouble running the Svelte component code on the client side might still be able to use and interact with just the default HTML button element and experience an unenhanced version of the <span class="No-Break">web page.</span></p>
<p>As we have gathered from this section, Svelte actions allow us to add another layer of interactivity to existing HTML elements. They are a naturally good candidate for designing <span class="No-Break">progressive enhancements.</span></p>
<p>With that, let’s look at a few examples of using actions to progressively enhance <span class="No-Break">HTML elements.</span></p>
<p>The first example we are going to look at is progressively enhancing the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Example – previewing a link with a &lt;a&gt; element</h1>
<p>In our<a id="_idIndexMarker266"/> first example, we will explore how to progressively <a id="_idIndexMarker267"/>enhance a <strong class="source-inline">&lt;a&gt;</strong> element to display a preview when <span class="No-Break">hovered upon.</span></p>
<p>Here, the browser receives HTML that contains a <strong class="source-inline">&lt;a&gt;</strong> tag with a <strong class="source-inline">href</strong> attribute, <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;a href="..." /&gt;</pre> <p>It then creates a hyperlink. When you click on the hyperlink, the browser will navigate to the destination specified in the <span class="No-Break"><strong class="source-inline">href</strong></span><span class="No-Break"> attribute.</span></p>
<p>This is the default behavior of the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>As the user loads the JavaScript, we want to make the <strong class="source-inline">&lt;a&gt;</strong> element do more than just navigate to a <span class="No-Break">new location.</span></p>
<p>We are going to enhance the <strong class="source-inline">&lt;a&gt;</strong> element by having it show the destination location when hovering <span class="No-Break">over it.</span></p>
<p>To do that, we are going to create a <strong class="source-inline">preview</strong> action and use it on the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
&lt;script&gt;
  function preview(element) {
  }
&lt;/script&gt;
&lt;a href="..." use:preview&gt;Hello&lt;/a&gt;</pre> <p>Regardless of how the <strong class="source-inline">preview</strong> action is implemented when rendering the preceding code on the server side, Svelte will generate the <span class="No-Break">following HTML:</span></p>
<pre class="source-code">
&lt;a href="..." /&gt;Hello&lt;/a&gt;</pre> <p>This is because Svelte actions never run on the <span class="No-Break">server side.</span></p>
<p>As soon as your user receives the HTML response, they can start clicking on the link and navigating to new locations. You now have a workable application with just <span class="No-Break">the HTML.</span></p>
<p>Depending <a id="_idIndexMarker268"/>on the user’s network condition, your JavaScript code, compiled from your Svelte component, may take a longer time to arrive. But that does not stop the user from using the hyperlinks to <span class="No-Break">navigate away.</span></p>
<p>Only when the<a id="_idIndexMarker269"/> JavaScript is loaded and executed does Svelte run the <strong class="source-inline">preview</strong> action with the <strong class="source-inline">&lt;a&gt;</strong> element that is on the DOM and enhances the <strong class="source-inline">&lt;a&gt;</strong> <span class="No-Break">element’s behavior.</span></p>
<p>The point here is that, as much as possible, we make the core functionality of our application workable with just the HTML, and we add a layer of enhancement with JavaScript, which may come at a much later time depending on the user’s <span class="No-Break">network condition.</span></p>
<p>Enough with the progressive enhancement philosophy. Let’s look at how we can implement this <span class="No-Break"><strong class="source-inline">preview</strong></span><span class="No-Break"> action.</span></p>
<p>We want the <strong class="source-inline">preview</strong> action to show a floating popup containing the content of the link when we move our mouse cursor over the link and hide it as we move our mouse <span class="No-Break">cursor away.</span></p>
<p>We can achieve that with <strong class="source-inline">'mouseover'</strong> and <strong class="source-inline">'mouseout'</strong> events. <span class="No-Break">Here’s how:</span></p>
<pre class="source-code">
function preview(element) {
  element.addEventListener('mouseover', onMouseOver);
  element.addEventListener('mouseout', onMouseOut);
  return {
    destroy() {
          element.removeEventListener('mouseover', onMouseOver);
          element.removeEventListener('mouseout', onMouseOut);
        }
  };
}</pre> <p>In the preceding code snippet, we add <strong class="source-inline">'mouseover'</strong> and <strong class="source-inline">'mouseout'</strong> event listeners at the beginning of the <strong class="source-inline">preview</strong> action. Additionally, we ensure proper cleanup by removing both the <strong class="source-inline">'mouseover'</strong> and <strong class="source-inline">'mouseout'</strong> event listeners in the <strong class="source-inline">destroy</strong> method. Before we figure out how to implement <strong class="source-inline">onMouseOver</strong> and <strong class="source-inline">onMouseOut</strong>, we need to first decide what the floating popup would look like and how would we lay it out in <span class="No-Break">the DOM.</span></p>
<p>To show the <a id="_idIndexMarker270"/>content of the link target, we are going to use the <strong class="source-inline">&lt;iframe&gt;</strong> element, which allows us to embed another HTML page into the <span class="No-Break">current one:</span></p>
<pre class="source-code">
&lt;iframe src="..." /&gt;</pre> <p>To make<a id="_idIndexMarker271"/> the <strong class="source-inline">&lt;iframe&gt;</strong> element float above other content instead of being part of the document flow, we will need to modify the CSS <strong class="source-inline">position</strong> property of the <strong class="source-inline">&lt;iframe&gt;</strong> element by using either <strong class="source-inline">position: fixed</strong> or <span class="No-Break"><strong class="source-inline">position: absolute</strong></span><span class="No-Break">.</span></p>
<p>If we used <strong class="source-inline">position: fixed</strong> on the <strong class="source-inline">&lt;iframe&gt;</strong> element, then the <strong class="source-inline">&lt;iframe&gt;</strong> element would be positioned relative to the viewport. To place the <strong class="source-inline">&lt;iframe&gt;</strong> element right next to the <strong class="source-inline">&lt;a&gt;</strong> element, we will have to figure out the position of the <strong class="source-inline">&lt;a&gt;</strong> element relative to the viewport and calculate the top and left values to place our <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">iframe&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>On the other hand, if we used <strong class="source-inline">position: absolute</strong>, then the <strong class="source-inline">&lt;iframe&gt;</strong> element would be positioned relative to the nearest positioned parent element. We could place the <strong class="source-inline">&lt;iframe&gt;</strong> element inside the <strong class="source-inline">&lt;a&gt;</strong> element and make the <strong class="source-inline">&lt;a&gt;</strong> element a positioned parent element by specifying <strong class="source-inline">position: relative</strong> on the <strong class="source-inline">&lt;a&gt;</strong> element (the <strong class="source-inline">position: relative</strong> CSS property is to be positioned relative to its current position). The <strong class="source-inline">&lt;iframe&gt;</strong> element would then be positioned relative to its parent, the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>Either approach has its pros and cons. I am going to use the second approach here, which is to use <strong class="source-inline">position: absolute</strong>. I will have to modify the content and the <strong class="source-inline">position</strong> CSS property of the <strong class="source-inline">&lt;a&gt;</strong> element, but I could get away from needing to perform calculations if I use <strong class="source-inline">position: absolute</strong> instead of <span class="No-Break"><strong class="source-inline">position: fixed</strong></span><span class="No-Break">.</span></p>
<p>Here’s what the DOM will look like after we place the <strong class="source-inline">&lt;iframe&gt;</strong> element inside the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
&lt;a href="..." style="position: relative"&gt;Hello&lt;iframe src="..." style="position: absolute"/&gt;&lt;/a&gt;</pre> <p>Our task now is to <a id="_idIndexMarker272"/>programmatically create and insert the <strong class="source-inline">&lt;iframe&gt;</strong> element in the <strong class="source-inline">onMouseOver</strong> function. The following code snippet <a id="_idIndexMarker273"/>illustrates how to <span class="No-Break">do this:</span></p>
<pre class="source-code">
function preview(element) {
  // make the &lt;a&gt; element position relative
  element.style.position = 'relative';
  let iframe;
  function onMouseOver() {
    iframe = document.createElement('iframe');
    iframe.src = element.getAttribute('href');
    iframe.style.position = 'absolute';
    iframe.style.left = 0;
    iframe.style.top = '100%';
    element.appendChild(iframe);
  }
  // ...
}</pre> <p>In the preceding code snippet, we set the CSS <strong class="source-inline">position</strong> property of the <strong class="source-inline">&lt;a&gt;</strong> element to <strong class="source-inline">'relative'</strong>. In the <strong class="source-inline">onMouseOver</strong> function, which will be called when the mouse is hovered over the <strong class="source-inline">&lt;a&gt;</strong> element, we programmatically create a <strong class="source-inline">&lt;iframe&gt;</strong> element, style it, and insert it into the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">a&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>In the previous code, we are using the DOM API such as <strong class="source-inline">document.createElement()</strong> and <strong class="source-inline">element.appendChild()</strong>. Since the <strong class="source-inline">&lt;iframe&gt;</strong> element is programmatically created, we are also programmatically modifying its <span class="No-Break"><strong class="source-inline">style</strong></span><span class="No-Break"> attribute.</span></p>
<p>Luckily, in this example, we are only creating one element, but you can imagine how this could easily grow messy if we were to create <span class="No-Break">more elements.</span></p>
<p>Since we<a id="_idIndexMarker274"/> are learning Svelte here and Svelte is designed to <a id="_idIndexMarker275"/>abstract out these imperative DOM instructions into declarative Svelte syntax, why not leverage Svelte in <span class="No-Break">our action?</span></p>
<p>We can replace the previous imperative code with a Svelte component, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;!-- IframePopup.svelte --&gt;
&lt;script&gt;
  export let src;
&lt;/script&gt;
&lt;iframe {src} /&gt;
&lt;style&gt;
  iframe {
    position: absolute;
    left: 0;
    top: 100%;
  }
&lt;/style&gt;</pre> <p>The preceding code snippet shows a Svelte component that contains a <strong class="source-inline">&lt;iframe&gt;</strong> element. This <strong class="source-inline">&lt;iframe&gt;</strong> element is equivalent to the one we created programmatically in the previous code snippet. It has the same CSS <span class="No-Break">styles applied.</span></p>
<p>The Svelte component exposes a prop called <strong class="source-inline">src</strong>, and the value of the <strong class="source-inline">src</strong> prop will be used to set the value of the <strong class="source-inline">src</strong> attribute of the <strong class="source-inline">&lt;iframe&gt;</strong> element. Now, instead of calling the DOM APIs to create the <strong class="source-inline">&lt;iframe&gt;</strong> element, we can instantiate our Svelte component and pass the desired <strong class="source-inline">src</strong> value as the <strong class="source-inline">src</strong> prop to the component. In Svelte, you can instantiate a component by using the <strong class="source-inline">new</strong> keyword along with the component’s constructor, passing in any required props as part of the constructor arguments. The Svelte component will then render the <strong class="source-inline">&lt;iframe&gt;</strong> element with the specified <strong class="source-inline">src</strong> attribute value based on the passed prop. This simplifies the process of creating and managing a <strong class="source-inline">&lt;iframe&gt;</strong> element within our <span class="No-Break">Svelte application:</span></p>
<pre class="source-code">
import IframePopup from './IframePopup.svelte';
function preview(element) {
  // ...
  function onMouseOver() {
<strong class="bold">    iframe = new IframePopup({</strong>
<strong class="bold">      // target specifies where we want the component</strong>
<strong class="bold">      // to be inserted into</strong>
<strong class="bold">      target: element,</strong>
<strong class="bold">      // we are passing the href value into the</strong>
<strong class="bold">      // component through props</strong>
<strong class="bold">      props: { src: element.getAttribute('href') },</strong>
<strong class="bold">    });</strong>
  }
  // ...
}</pre> <p>In the preceding <a id="_idIndexMarker276"/>code snippet, we’ve replaced the DOM operations<a id="_idIndexMarker277"/> in the <strong class="source-inline">onMouseOver</strong> function to instantiate the <strong class="source-inline">IframePopup</strong> <span class="No-Break">Svelte component.</span></p>
<p>We need to remember to remove the popup when we move our mouse away from the link. Here’s how we can <span class="No-Break">do that:</span></p>
<pre class="source-code">
function onMouseOut() {
  iframe.$destroy();
}</pre> <p>Although we are only inserting one HTML element into the DOM through Svelte actions, we’ve seen that it’s much more manageable to encapsulate that into a Svelte component and instantiate the Svelte component instead of manually creating <span class="No-Break">HTML elements.</span></p>
<p>We can then leverage Svelte to create scoped styles, as well as add other interactive logic to the elements we are going <span class="No-Break">to create.</span></p>
<p>We could also<a id="_idIndexMarker278"/> add transitions to elements; instead of appearing <a id="_idIndexMarker279"/>abruptly upon hovering, we can make the popup fade by using a <strong class="source-inline">fade</strong> transition, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;!-- IframePopup.svelte --&gt;
&lt;script&gt;
  import { fade } from 'svelte/transition';
  // ...
&lt;/script&gt;
&lt;iframe {src} transition:fade /&gt;</pre> <p>By default, transitions are not played when the component is first created. So, we need to pass in the <strong class="source-inline">intro: true</strong> option to play <span class="No-Break">the transition:</span></p>
<pre class="source-code">
iframe = new IframePopup({
  target: element,
  props: { src: element.getAttribute('href') },
  // play transition when created
  <strong class="bold">intro: true,</strong>
});</pre> <p>In the preceding code snippet, we pass in <strong class="source-inline">intro: true</strong> to the <span class="No-Break"><strong class="source-inline">IframePopup</strong></span><span class="No-Break"> constructor.</span></p>
<p>We now have a link that shows a preview in a popup that fades in upon hovering. Try simulating loading the page with a slow network. Most browsers provide developer tools to simulate network speed. For example, if you are using Google Chrome, then you can open the <strong class="bold">Developer Tools</strong>, find the <strong class="bold">Network conditions</strong> tab, look for the <strong class="bold">Network throttling</strong> section, and choose the <strong class="bold">Slow </strong><span class="No-Break"><strong class="bold">3G</strong></span><span class="No-Break"> preset.</span></p>
<p>Try reloading your page, and you’ll find that once you see the link (albeit the JavaScript file is still loading), the link is immediately working; clicking it will navigate you to the destination. As <a id="_idIndexMarker280"/>the JavaScript is finally loaded into the<a id="_idIndexMarker281"/> browser, your link is now enhanced, and you are now able to hover over the link and see <span class="No-Break">a preview.</span></p>
<p>With our link preview action done, let’s look at another common component in a web app, forms, and see how we can progressively enhance a <span class="No-Break">form element.</span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/>Example – progressively enhancing a form</h1>
<p>A <strong class="source-inline">&lt;form&gt;</strong> element is a <a id="_idIndexMarker282"/>section of a document that can contain inputs that will be used to <span class="No-Break">submit information.</span></p>
<p>By default, when<a id="_idIndexMarker283"/> you submit a form, the browser will navigate to a URL to process the form submission. This means that the user will lose the state they are in as they navigate away from the current page when they submit <span class="No-Break">the form.</span></p>
<p>However, with the ability to make asynchronous requests through the browser <strong class="source-inline">fetch</strong> API, we can now submit data through API requests without leaving the current page, and stay where <span class="No-Break">we are.</span></p>
<p>This means that if the site is playing music, video, or animation, they will still be playing while we make asynchronous <span class="No-Break">API calls.</span></p>
<p>Our task now is to create an action to enhance the form element so that the enhanced form will not navigate to a new location, but rather submit the form <span class="No-Break">data asynchronously.</span></p>
<p>For lack of a better name, I am going to call this enhancing <span class="No-Break">action </span><span class="No-Break"><strong class="source-inline">enhance</strong></span><span class="No-Break">.</span></p>
<p>Before we proceed to implement the <strong class="source-inline">enhance</strong> action, let’s recap on the default <span class="No-Break">form behavior.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>The default form behavior</h2>
<p>When<a id="_idIndexMarker284"/> you have a <strong class="source-inline">&lt;form&gt;</strong> element, by default when you hit the <strong class="bold">Submit</strong> button, it will navigate to the location indicated by the <strong class="source-inline">action</strong> attribute, carrying along with it the value filled in the <strong class="source-inline">&lt;input&gt;</strong> elements within the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">form&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>For example, imagine you have the <span class="No-Break">following form:</span></p>
<pre class="source-code">
&lt;form action="/foo"&gt;
  &lt;input name="name" /&gt;
  &lt;input name="address" /&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre> <p>When you hit the <strong class="bold">Submit</strong> button, the browser will navigate to <strong class="source-inline">/foo?name=xxx&amp;address=yyy</strong>, carrying the form data via <span class="No-Break">query parameters.</span></p>
<p>A <strong class="source-inline">&lt;form&gt;</strong> element <a id="_idIndexMarker285"/>can define the HTTP method to use to submit the form, by specifying the <span class="No-Break"><strong class="source-inline">method</strong></span><span class="No-Break"> attribute.</span></p>
<p>For example, the following form will navigate to <strong class="source-inline">/foo</strong> via a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request:</span></p>
<pre class="source-code">
&lt;form action="/foo" method="post"&gt;...&lt;/form&gt;</pre> <p>Form data will be sent as a request body for the <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request.</span></p>
<p>Depending on the server’s implementation for the <strong class="source-inline">/foo</strong> endpoint, the server can choose how to process the data and what to show on the <strong class="source-inline">/foo</strong> page. Sometimes, the server may decide to redirect back to the current page after processing the data. In that case, having an action that can replace the default form action and submit the form data asynchronously instead would be very useful, since we will eventually come back to the <span class="No-Break">same page.</span></p>
<p>Now we know the default form behavior, let’s figure out what we need to implement the <span class="No-Break"><strong class="source-inline">enhance</strong></span><span class="No-Break"> action.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Implementing the enhance action</h2>
<p>Let’s break the <span class="No-Break">problem down.</span></p>
<p>First, we<a id="_idIndexMarker286"/> need to figure out how to know when a user submits a form. Then, we need to prevent the default form behavior and then make an asynchronous API call to submit the form asynchronously, and finally reset the form to the initial state, similar to what you would see after the server redirects back to the <span class="No-Break">same page.</span></p>
<p>To figure out when the user submits a form, we could listen to the <strong class="source-inline">'submit'</strong> event on the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">form&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
form.addEventListener('submit', handleSubmit);</pre> <p>To prevent <a id="_idIndexMarker287"/>the default form behavior, we call <strong class="source-inline">event.preventDefault()</strong> on the <strong class="source-inline">'submit'</strong> event listener to prevent the default <span class="No-Break">submit behavior:</span></p>
<pre class="source-code">
function handleSubmit(event) {
  event.preventDefault();
}</pre> <p>To make the API call to submit the form asynchronously, we need to first find out where we are submitting the form. We can get this information from reading the <strong class="source-inline">action</strong> property of the <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> instance:</span></p>
<pre class="source-code">
form.action; // "https://domain/foo"</pre> <p>We can also determine the preferred HTTP request method from the <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> instance:</span></p>
<pre class="source-code">
form.method // "post"</pre> <p>To get the form data submitted, we can use the <span class="No-Break"><strong class="source-inline">FormData</strong></span><span class="No-Break"> interface:</span></p>
<pre class="source-code">
const data = new FormData(form);</pre> <p>With the URL, request method, and data, we can use the <strong class="source-inline">fetch</strong> API to submit <span class="No-Break">the form:</span></p>
<pre class="source-code">
fetch(form.action, {
  method: form.method,
  body: new FormData(form),
});</pre> <p>Finally, to reset the form, we can use the <span class="No-Break"><strong class="source-inline">reset()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
form.reset()</pre> <p>Putting everything together, we have <span class="No-Break">the following:</span></p>
<pre class="source-code">
&lt;script&gt;
  function enhance(form) {
    async function handleSubmit(event) {
      event.preventDefault();
      const response = await fetch(form.action, {
        method: form.method,
        body: new FormData(form),
      });
      form.reset();
    }
    form.addEventListener('submit', handleSubmit);
    return {
      destroy() {
        form.removeEventListener('submit', handleSubmit);
      }
    };
  }
&lt;/script&gt;
&lt;form action="/foo" method="post" use:enhance&gt;...&lt;/form&gt;</pre> <p>Now, try to<a id="_idIndexMarker288"/> submit the form after the JavaScript is loaded. You’ll notice that a network request is made to submit the form, while you remain on the same page without <span class="No-Break">navigating away.</span></p>
<p>Try to disable the JavaScript or simulate a slow network speed. You’ll notice that you can still submit the form, while the JavaScript is still being loaded. However, this time round, you submit through the default browser behavior, which will navigate you away from <span class="No-Break">the page.</span></p>
<p>Here we have it—a workable form by default, but progressively enhanced to submit form data without leaving the page if the JavaScript is <span class="No-Break">being loaded.</span></p>
<p>There’s a lot that <a id="_idIndexMarker289"/>can be improved on the <strong class="source-inline">enhance</strong> action. I’ll leave that as <span class="No-Break">an exercise:</span></p>
<ul>
<li>Modify the <strong class="source-inline">enhance</strong> action to allow passing in a callback function that will be called after the form submission is <span class="No-Break">successfully made.</span></li>
<li>What happens if the form submission fails? How should you handle such <span class="No-Break">a case?</span></li>
<li>Right now, the <strong class="source-inline">enhance</strong> action submits the form data through the request body; however, when the form method is <strong class="source-inline">"get"</strong>, form data should be passed through query parameters. Modify the <strong class="source-inline">enhance</strong> action to handle the <strong class="source-inline">"get"</strong> <span class="No-Break">form method.</span></li>
</ul>
<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Summary</h1>
<p>In this chapter, we explained what progressive enhancement is and why it is important. Following up on that, we learned how we can use Svelte actions to progressively enhance <span class="No-Break">our elements.</span></p>
<p>We went through two different examples of progressive enhancements—enhancing a link to make it show a preview popup, and enhancing form elements to submit a <span class="No-Break">form asynchronously.</span></p>
<p>In the past three chapters, we’ve seen three different patterns and use cases of Svelte actions, creating custom events, integrating UI libraries, and progressive enhancements. What you can do with Svelte actions is not limited to the three different use cases that we’ve discussed so far, but hopefully, these patterns have opened your imagination and made you see what is possible with <span class="No-Break">Svelte actions.</span></p>
<p>With that, we are moving on to the next part of the book. We will be exploring Svelte context and stores from <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> to <a href="B18887_12.xhtml#_idTextAnchor175"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, exploring their various use cases, such as in state management, creating renderless components, and using them for animations. We will start by defining and comparing Svelte contexts and Svelte stores in the <span class="No-Break">next chapter.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer025">
<h1 id="_idParaDest-119" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor120"/>Part 3: Context and Stores</h1>
<p>In this part, we will dive deep into Svelte’s two core features, Svelte context and Svelte stores. Over the five chapters, we will explore different scenarios for using Svelte context and stores. We’ll start our exploration by defining Svelte context and stores. This will be followed by a deep dive into implementing custom stores and strategies for managing application state using Svelte stores. Following that, we will learn how to use Svelte context to create a renderless component. Finally, we will learn how to create animations using <span class="No-Break">Svelte stores.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a><em class="italic">, Context versus Stores</em></li>
<li><a href="B18887_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a><em class="italic">, Implementing Custom Stores</em></li>
<li><a href="B18887_10.xhtml#_idTextAnchor152"><em class="italic">Chapter 10</em></a><em class="italic">, State Management with Svelte Stores</em></li>
<li><a href="B18887_11.xhtml#_idTextAnchor163"><em class="italic">Chapter 11</em></a><em class="italic">, Renderless Components</em></li>
<li><a href="B18887_12.xhtml#_idTextAnchor175"><em class="italic">Chapter 12</em></a><em class="italic">, Stores and Animation</em>s</li>
</ul>
</div>
<div>
<div id="_idContainer026">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer027">
</div>
</div>
</div></body></html>