["```js\n// Returns the \"name\" of the given user object,\n// but only if it's \"enabled\". This means that\n// the function is referentially-transparent if\n// the user passed to it never update the\n// \"enabled\" property.\nfunction getName(user) {\n    if (user.enabled) {\n        return user.name;\n    }\n}\n\n// Toggles the value of the passed-in \"user.enabled\"\n// property. Functions like these that change the\n// state of objects make referential transparency\n// difficult to achieve.\nfunction updateUser(user) {\n    user.enabled = !user.enabled;\n}\n\n// Our user object.\nvar user = {\n    name: 'ES6',\n    enabled: false\n};\n\nconsole.log('name when disabled', `\"${getName(user)}\"`);\n// → name when disabled \"undefined\"\n\n// Mutates the user state. Now passing this object\n// to functions means that they're no longer\n// referentially-transparent, because they could\n// produce different output based on this update.\nupdateUser(user);\n\nconsole.log('name when enabled', `\"${getName(user)}\"`);\n// → name when enabled \"ES6\"\n```", "```js\n// The referentially-transparent version of \"updateUser()\",\n// which doesn't actually update anything. It creates a\n// new object with all the same property values as the\n// object that was passed in, except for the \"enabled\"\n// property value we're changing.\nfunction updateUserRT(user) {\n    return Object.assign({}, user, {\n        enabled: !user.enabled\n    });\n}\n\n// This approach doesn't change anything about \"user\",\n// meaning that any functions that use \"user\" as input,\n// remain referentially-transparent.\nvar updatedUser = updateUserRT(user);\n\n// We can call referentially-transparent functions at\n// any time, and expect to get the same result. When\n// there's no side-effects on our data, concurrency gets\n// much easier.\nsetTimeout(() => {\n    console.log('still enabled', `\"${getName(user)}\"`);\n    // → still enabled \"ES6\"\n}, 1000);\n\nconsole.log('updated user', `\"${getName(updatedUser)}\"`);\n// → updated user \"undefined\"\n```", "```js\n// This function determines whether or not an\n// operation should be performed in parallel.\n// It takes as arguments - the data to process,\n// and a boolean flag, indicating that the task\n// performed on each item in the data is expensive\n// or not.\nfunction isConcurrent(data, expensiveTask) {\n    var size,\n        isSet = data instanceof Set,\n        isMap = data instanceof Map;\n\n    // Figures out the size of the data, depending\n    // on the type of \"data\".\n    if (Array.isArray(data)) {\n        size = data.length\n    } else if (isSet || isMap) {\n        size = data.size;\n    } else {        \n        size = Object.keys(data).length;\n    }\n\n    // Determine whether or not the size of the\n    // data surpasses a the parallel processing\n    // threshold. The threshold depends on the\n    // \"expensiveTask\" value.\n    return size >= (expensiveTask ? 100 : 1000);\n}\n\nvar data = new Array(138);\n\nconsole.log('array with expensive task',\n    isConcurrent(data, true));\n// → array with expensive task true\n\nconsole.log('array with inexpensive task',\n    isConcurrent(data, false));\n// → array with inexpensive task false\n\ndata = new Set(new Array(100000)\n    .fill(null)\n    .map((x, i) => i));\n\nconsole.log('huge set with inexpensive task',\n    isConcurrent(data, false));\n// → huge set with inexpensive task true\n```", "```js\n// Returns the the ideal number of web workers\n// to create.\nfunction getConcurrency(defaultLevel = 4) {\n\n    // If the \"navigator.hardwareConcurrency\" property\n    // exists, we use that. Otherwise, we return the\n    // \"defaultLevel\" value, which is a sane guess\n    // at the actual hardware concurrency level.\n    return Number.isInteger(navigator.hardwareConcurrency) ?\n        navigator.hardwareConcurrency : defaultLevel;\n}\n\nconsole.log('concurrency level', getConcurrency());\n// → concurrency level 8\n```", "```js\n// Simple function that returns the sum\n// of the provided arguments.\nfunction sum(...numbers) {\n    return numbers\n        .reduce((result, item) => result + item);\n}\n```", "```js\n// Loads the generic task that's executed by\n// this worker.\nimportScripts('task.js') if (chunk.length) {;\n\naddEventListener('message', (e) => {\n\n    // If we get a message for a \"sum\" task,\n    // then we call our \"sum()\" task, and post\n    // the result, along with the operation ID.\n    if (e.data.task === 'sum') {\n        postMessage({\n            id: e.data.id,\n            value: sum(...e.data.chunk)\n        });\n    }\n});\n```", "```js\n// This generator creates a set of workers that match\n// the concurrency level of the system. Then, as the\n// caller iterates over the generator, the next worker\n// is yielded, until the end is reached, then we start\n// again from the beginning. It's like a round-robin\n// for selecting workers to send messages to.\nfunction* genWorkers() {\n    var concurrency = getConcurrency();\n    var workers = new Array(concurrency);\n    var index = 0;\n\n    // Creates the workers, storing each in the \"workers\"\n    // array.\n    for (let i = 0; i < concurrency; i++) {\n        workers[i] = new Worker('worker.js');\n\n        // When we get a result back from a worker, we\n        // place it in the appropriate response, based\n        // on ID.\n        workers[i].addEventListener('message', (e) => {\n            var result = results[e.data.id];\n\n            result.values.push(e.data.value);\n\n            // If we've received the expected number of\n            // responses, we can call the operation\n            // callback, passing the responses as arguments.\n            // We can also delete the response, since we're\n            // done with it now.\n            if (result.values.length === result.size) {\n                result.done(...result.values);\n                delete results[e.data.id];\n            }\n        });\n    }\n\n    // Continue yielding workers as long as they're\n    // asked for.\n    while (true) {\n        yield workers[index] ?\n            workers[index++] : workers[index = 0];\n    }\n}\n\n// Creates the global \"workers\" generator.\nvar workers = genWorkers();\n\n// This will generate unique IDs. We need them to\n// map tasks executed by web workers to the larger\n// operation that created them.\nfunction* genID() {\n    var id = 0;\n\n    while (true) {\n        yield id++;\n    }\n}\n\n// Creates the global \"id\" generator.\nvar id = genID();\n```", "```js\n// Builds a function that when called, runs the given task\n// in workers by splitting up the data into chunks.\nfunction parallel(expensive, taskName, taskFunc, doneFunc) {\n\n    // The function that's returned takes the data to \n    // process as an argument, as well as the chunk size,\n    // which has a default value.\n    return function(data, size=250) {\n\n        // If the data isn't large enough, and the\n        // function isn't expensive, just run it in the\n        // main thread.\n        if (!isConcurrent(data, expensive)) {\n            if (typeof taskFunc === 'function') {\n                return taskFunc(data);\n            } else {\n                throw new Error('missing task function');\n            }\n        else {\n            // A unique identifier for this call. Used\n            // when reconciling the worker results.\n            var operationID = id.next().value;\n\n            // Used to track the position of the data\n            // as we slice it into chunks.\n            var index = 0;\n            var chunk;\n\n            // The global \"results\" object gets an\n            // object with data about this operation.\n            // The \"size\" property represents the\n            // number of results we can expect back.\n            // The \"done\" property is the callback\n            // function that all the results are\n            // passed to. And \"values\" holds the\n            // results as they come in from the\n            // workers.\n            results[operationID] = {\n                size: 0,\n                done: doneFunc,\n                values: []\n            };\n\n            while(true) {\n                // Gets the next worker.\n                let worker = workers.next().value;\n\n                // Slice a chunk off the input data.\n                chunk = data.slice(index, \n                    index + size);\n                index += size;\n\n                // If there's a chunk to process, we\n                // can increment the size of the\n                // expected results and post a\n                // message to the worker. If there's\n                // no chunk, we're done.\n                if (chunk.length) {\n                    results[operationID].size++;\n\n                    worker.postMessage({\n                        id: operationID,\n                        task: taskName,\n                        chunk: chunk\n                    });\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n}\n\n// Creates an array to process, filled with integers.\nvar array = new Array(2000)\n    .fill(null)\n    .map((v, i) => i);\n\n// Creates a \"sumConcurrent()\" function that when called,\n// will process the input data in workers.\nvar sumConcurrent = parallel(true, 'sum', sum,\n    function(...results) {\n        console.log('results', \n            results.reduce((r, v) => r + v));\n    });\n\nsumConcurrent(array);\n```", "```js\n// Counts the number of times \"item\" appears in \n// \"collection\".\nfunction count(collection, item) {\n    var index = 0,\n        occurrences = 0;\n\n    while(true) {\n\n        // Find the first index.\n        index = collection.indexOf(item, index);\n\n        // If we found something, increment the count, and\n        // increment the starting index for the next\n        // iteration. If nothing is found, break the loop.\n        if (index > -1) {\n            occurrences += 1;\n            index += 1;\n        } else {\n            break;\n        }\n    }\n\n    // Returns the number of occurrences found.\n    return occurrences;\n}\n```", "```js\n// Unstructured text where we might need to find patterns.\nvar string = `\nLorem ipsum dolor sit amet, mei zril aperiam sanctus id, duo wisi\naeque molestiae ex. Utinam pertinacia ne nam, eu sed cibo senserit.\nTe eius timeam docendi quo, vel aeque prompta philosophia id, nec\nut nibh accusamus vituperata. Id fuisset qualisque cotidieque sed,\neu verterem recusabo eam, te agam legimus interpretaris nam. Eos\ngraeco vivendo et, at vis simul primis.`;\n\n// Constucts a new function - \"stringCount()\" using our \n// \"parallel()\" utility. Logs the number of string \n// occurrances by reducing the worker counts into a result.\nvar stringCount = parallel(true, 'count', count, \n    function(...results) {\n        console.log('string',\n            results.reduce((r, v) => r + v));\n    });\n\n// Kicks off the substring counting operation.\nstringCount(string, 20, 'en');\n```", "```js\n// Creates an array of 10,000 integers between 1 and 5.\nvar array = new Array(10000)\n    .fill(null)\n    .map(() => {\n        return Math.floor(Math.random() * (5 - 1)) + 1;\n    });\n\n// Creates a parallel function that uess the \"count\" task,\n// to count the number of occurances in the array.\nvar arrayCount = parallel(true, 'count', count, function(...results) {\n    console.log('array', results.reduce((r, v) => r + v));\n    });\n\n// We're looking for the number 2 - there's probably lots of\n//these.\narrayCount(array, 1000, 2);\n```", "```js\n// A basic mapping that \"plucks\" the given\n// \"prop\" from each item in the array.\nfunction pluck(array, prop) {\n    return array.map((x) => x[prop]);\n}\n\n// Returns the result of reducing the sum\n// of the array items.\nfunction sum(array) {\n    return array.reduce((r, v) => r + v);\n}\n```", "```js\n// Creates an array of 75,000 objects.\nvar array = new Array(75000)\n    .fill(null)\n    .map((v, i) => {\n        return {\n            id: i,\n            enabled: true\n        };\n    });\n\n// Creates a concurrent version of the \"sum()\"\n// function.\nvar sumConcurrent = parallel(true, 'sum', sum,\n    function(...results) {\n        console.log('total', sum(results));\n    });\n\n// Creates a concurrent version of the \"pluck()\"\n// function. When the parallel jobs complete, we\n// pass the results to \"sumConcurrent()\".\nvar pluckConcurrent = parallel(true, 'pluck', pluck, \n    function(...results) {\n        sumConcurrent([].concat(...results));\n    });\n\n// Kicks off the concurrent pluck operation.\npluckConcurrent(array, 1000, 'id');\n```", "```js\n// Keeps track of how many list items we've rendered\n// so far.\nvar counter = 0;\n\n// Sends a message to the main thread with all the\n// necessary DOM manipulation data.\nfunction appendChild(settings) {\n    postMessage(settings);\n\n    // We've rendered all our items, we're done.\n    if (counter === 3) {\n        return;\n    }\n\n    // Schedule the next \"appendChild()\" message.\n    setTimeout(() => {\n        appendChild({\n            action: 'appendChild',\n            node: 'ul',\n            type: 'li',\n            content: `Item ${++counter}`\n        });\n    }, 1000);\n}\n\n// Schedules the first \"appendChild()\" message. This\n// includes the data necessary to simply render the\n// DOM in the main thread.\nsetTimeout(() => {\n    appendChild({\n        action: 'appendChild',\n        node: 'ul',\n        type: 'li',\n        content: `Item ${++counter}`\n    });\n}, 1000);\n```", "```js\n// Starts the worker (the bottom-half).\nvar worker = new Worker('worker.js');\n\nworker.addEventListener('message', (e) => {\n\n    // If we get a message for the \"appendChild\" action,\n    // then we create the new element and append it to the\n    // appropriate parent - all this information is found\n    // in the message data. This handler does absolutely\n    // nothing but talk to the DOM.\n    if (e.data.action === 'appendChild') {\n        let child = document.createElement(e.data.type);\n        child.textContent = e.data.content;\n\n        document.querySelector(e.data.node)\n            .appendChild(child);\n            }\n});\n```", "```js\n// Tell the main thread that we want to be notified\n// when the \"input\" event is triggered on \"input\n// elements.\npostMessage({\n    action: 'addEventListener',\n    selector: 'input',\n    event: 'input'\n});\n\n// Tell the main thread that we want to be notified\n// when the \"click\" event is triggered on \"button\"\n// elements.\npostMessage({\n    action: 'addEventListener',\n    selector: 'button',\n    event: 'click'\n});\n\n// A DOM event was triggered.\naddEventListener('message', (e) => {\n    var data = e.data;\n\n    // Log the event differently, depending on where\n    // the event was triggered from.\n    if (data.selector === 'input') {\n        console.log('worker', `typed \"${data.value}\"`);\n    } else if (data.selector === 'button') {\n        console.log('worker', 'clicked');\n    }\n});\n```", "```js\n// Starts the worker...\nvar worker = new Worker('worker.js');\n\n// When we get a message, that means the worker wants\n// to listen to a DOM event, so we have to setup\n// the proxying.\nworker.addEventListener('message', (msg) => {\n    var data = msg.data;\n\n    if (data.action === 'addEventListener') {\n        // Find the nodes the worker is looking for.\n        var nodes = \n            document.querySelectorAll(data.selector);\n\n        // Add a new event handler for the given \"event\" to\n        // each node we just found. When that event is\n        // triggered, we simply post a message back to \n        // the worker containing relevant event data.\n        for (let node of nodes) {\n            node.addEventListener(data.event, (e) => {\n                worker.postMessage({\n                    selector: data.selector,\n                    value: e.target.value\n                });\n            });\n        }\n    }\n});\n```"]