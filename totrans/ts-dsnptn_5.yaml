- en: Chapter 7. Patterns and Architectures in JavaScript and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous four chapters, we've walked through common and classical design
    patterns and discussed some of their variants in JavaScript or TypeScript. In
    this chapter, we'll continue with some architecture and patterns closely related
    to the language and their common applications. We don't have many pages to expand
    and certainly cannot cover everything in a single chapter, so please take it as
    an appetizer and feel free to explore more.
  prefs: []
  type: TYPE_NORMAL
- en: Many topics in this chapter are related to asynchronous programming. We'll start
    with a web architecture for Node.js that's based on Promise. This is a larger
    topic that has interesting ideas involved, including abstractions of responses
    and permissions, as well as error handling tips. Then we'll talk about how to
    organize modules with **ECMAScript** (**ES**) module syntax. And this chapter
    will end with several useful asynchronous techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we''ll have the following topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture and techniques related to Promise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction of responses and permissions in a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing a project to scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other useful asynchronous techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, due to the limited length, some of the related code is aggressively simplified
    and nothing more than the idea itself can be applied practically.
  prefs: []
  type: TYPE_NORMAL
- en: Promise-based web architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have a better understanding of the differences between Promises and traditional
    callbacks, consider an asynchronous task like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write preceding above in Promise style, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As in the preceding example, Promise makes it easy and *natural* to write asynchronous
    operations with a flat chain instead of nested callbacks. But the most exciting
    thing about Promise might be the benefits it brings to error handling. In a Promise-based
    architecture, throwing an error can be safe and pleasant. You don't have to explicitly
    handle errors when chaining asynchronous operations, and this makes mistakes less
    likely to happen.
  prefs: []
  type: TYPE_NORMAL
- en: With the growing usage with ES6 compatible runtimes, Promise is already there
    out of the box. And we actually have plenty of polyfills for Promises (including
    my `*ThenFail*` written in TypeScript), as people who write JavaScript roughly
    refer to the same group of people who created wheels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Promises work well with other Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: A *Promises/A+* -compatible implementation should work with other *Promises/A+*
    -compatible implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises work best in a Promise-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are new to Promise, you might be complaining about using Promises with
    a callback-based project. Using asynchronous helpers such as `Promise.each` (non-standard)
    provided by Promise libraries is a common reason for people to try out Promise,
    but it turns out they have better alternatives (for a callback-based project)
    such as the popular `async` library.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that makes you decide to switch should not be these helpers (as there
    are a lot of them for old-school callbacks as well), but an easier way to handle
    errors or to take advantage of the ES `async`/`await` feature, which is based
    on Promise.
  prefs: []
  type: TYPE_NORMAL
- en: Promisifying existing modules or libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though Promises do best in a Promise-based architecture, it is still possible
    to begin using Promise with a smaller scope by promisifying existing modules or
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take Node.js style callbacks as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You may expect a promisified version of the `readFile` function to look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the promisified function `readFile` can be easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am using the type `any` here for parameter options to reduce the size of the
    code example, but I would suggest not using `any` whenever possible in practice.
  prefs: []
  type: TYPE_NORMAL
- en: There are libraries that are able to promisify methods automatically. Though,
    unfortunately, you might need to write declaration files yourself for the promisified
    methods if there are no promisified version available.
  prefs: []
  type: TYPE_NORMAL
- en: Views and controllers in Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of us may have already worked with frameworks such as **Express**. And
    this is how we render a view or response with JSON in Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will usually separate controllers from the routing configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus we may have a better idea of existing routes, and have controllers managed
    more easily. Furthermore, automated routing could be introduced so that we don''t
    always need to update routing manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation above is certainly too simple to cover daily use, but it
    shows a rough idea of how automated routing could work: via conventions based
    on file structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we are working with asynchronous code written in Promises, an action
    in the controller could be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are destructuring  an array within a parameter. `Promise.all` returns a Promise
    of an array with elements corresponding to the values of the resolvables passed
    in. (A resolvable means a normal value or a Promise-like object that may resolve
    to a normal value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s not enough; we still need to handle errors properly, or in some
    Promise implementations, the preceding code may fail in silence because the Promise
    chain is not handled by a rejection handler (which is terrible). In Express, when
    an error occurs, you should call `next` (the third argument passed into the callback)
    with the error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are fine with the correctness of this approach, but that''s simply
    not how Promises work. Explicit error handling with callbacks could be eliminated
    in the scope of controllers, and the easiest way is to return the Promise chain
    and hand over to code that was previously doing routing logic. So the controller
    could be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But, could we make it even better?
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already been returning a Promise to tell whether an error occurs. So
    now the returned Promise indicates the status of the response: success or failure.
    But why we are still calling `res.render()` for rendering the view? The returned
    promise object could be the response itself rather than just an error indicator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about the controller again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The response object returned could vary for different response outputs. For
    example, it could be either a `PageResponse` like it is in the preceding example,
    a `JSONResponse`, a `StreamResponse`, or even a simple `Redirection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As, in most cases, `PageResponse` or `JSONResponse` is applied, and the view
    of a `PageResponse` can usually be implied by the controller path and action name,
    it is useful to have those two responses automatically generated from a plain
    data object with a proper view to render with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s how a Promise-based controller should respond. With this idea,
    let''s update the routing code with the abstraction of responses. Previously,
    we were passing controller actions directly as Express request handlers. Now we
    need to do some wrapping up with the actions by resolving the return value, and
    applying operations based on the resolved result:'
  prefs: []
  type: TYPE_NORMAL
- en: If it fulfils and it's an instance of `Response`, apply it to the `res` object
    passed in by Express.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it fulfils and it's a plain object, construct a `PageResponse` or a `JSONResponse`
    if no view found and apply it to the `res` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it rejects, call the `next` function with the reason.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Previously, it was like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it gets a few more lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, so far we can handle only `GET` requests as we hardcoded `app.get()`
    in our router implementation. The poor view-matching logic can hardly be used
    in practice either. We need to make the actions configurable, and ES decorators
    could do nice work here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I'll leave the implementation to you, and feel free to make it awesome.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions play an important role in a project, especially in systems that
    have different user groups, for example, a forum. The abstraction of permissions
    should be extendable to satisfy changing requirements, and it should be easy to
    use as well.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to talk about the abstraction of permission in the level
    of controller actions. Consider the legibility of performing one or more actions
    as a  ***privilege**.* The permission of a user may consist of several privileges and
    usually most users at the same level would have the same set of privileges. So
    we may have a larger concept, namely ***groups**.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The abstraction could either work based on both groups and privileges or based
    on privileges only (groups are then just aliases to sets of privileges):'
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions that validate based on privileges and groups at the same time is
    easier to build. You do not need to create a large list of which actions can be
    performed for a certain group of users; granular privileges are only required
    when necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions that validate based on privileges have better control and more
    flexibility for describing the permission. For example, you can remove a small
    set of privileges from the permission of a user easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, both approaches have similar upper-level abstractions and differ mostly
    in implementation. The general structure of the permission abstractions we''ve
    talked about is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstraction of permissions](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The participants include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privilege**: Describes detailed privileges corresponding to specific actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: Defines a set of privileges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permission**: Describes what a user is capable of doing; consists of groups
    the user belongs to and privileges the user has'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permission descriptor**: Describes how the permission of a user would be
    sufficient; consists of *possible* groups and privileges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expected errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great concern wiped away by using Promises is that we do not need to worry
    about throwing an error in a `callback` would crash the application most of the
    time. The error will flow through the Promises chain and, if not caught, will
    be handled by our router. Errors can be roughly divided into **expected errors**
    and **unexpected errors**. Expected errors are usually caused by incorrect input
    or foreseeable exceptions, and unexpected errors are usually caused by bugs or
    other libraries the project relies on.
  prefs: []
  type: TYPE_NORMAL
- en: For expected errors, we usually want to give user-friendly responses with readable
    error messages and codes, so that users can help themselves to find solutions
    or report to us with useful context. For unexpected errors, we would also want
    reasonable responses (usually messages described as unknown errors), a detailed
    server-side log (including the real error name, message, stack information, and
    so on), and even alarms for getting the team notified as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and throwing expected errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The router will need to handle different types of errors, and an easy way to
    achieve that is to subclass a universal `ExpectedError` class and throw its instances
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extendable-error` is a package of mine that handles stack trace and the
    `message` property. You can directly extend the `Error` class as well.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when receiving an expected error, we can safely output its message as
    part of the response. And if it's not an instance of `ExpectedError`, we can then
    output predefined `unknown` error messages and have detailed error information
    logged.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some errors, such as those caused by unstable networks or remote services, are
    expected; we may want to catch those errors and throw them out again as expected
    errors. But it is rather trivial to actually do that. A centralized error-transforming
    process can then be applied to reduce the efforts required to manage those errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transforming process includes two parts: filtering (or matching) and transforming.
    There are many approaches to filter errors, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter by error class**: Many third-party libraries throw errors of certain
    classes. Taking Sequelize (a popular Node.js ORM) as an example, it throws `DatabaseError`,
    `ConnectionError`, `ValidationError`, and so on. By filtering errors by checking
    whether they are instances of a certain error class, we may easily pick up target
    errors from the pile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter by string or regular expression**: Sometimes a library might be throwing
    errors that are instances of an `Error` class itself instead of its subclasses;
    this makes those errors harder to distinguish from others. In this situation,
    we may filter those errors by their message, with keywords or regular expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter by scope**: It''s possible that instances of the same error class
    with the same error message should result in different responses. One of the reasons
    might be that the operation that throws a certain error is at a lower level, but
    is being used by upper structures within different scopes. Thus, a `scope` mark
    could be added for those errors and make them easier to be filtered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be more ways to filter errors, and they are usually able to cooperate
    as well. By properly applying those filters and transforming errors, we can reduce
    noise for analyzing what's going on within a system and locate problems faster
    if they show up.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ES6, there were a lot of module solutions for JavaScript that worked.
    The two most famous of them are AMD and commonjs. AMD is designed for asynchronous
    module loading, which is mostly applied in browsers, while commonjs does module
    loading synchronously, and that's the way the Node.js module system works.
  prefs: []
  type: TYPE_NORMAL
- en: To make it work asynchronously, writing an AMD module takes more characters.
    And due to the popularity of tools such as browserify and webpack, commonjs becomes
    popular even for browser projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper granularity of internal modules could help a project keep its structure
    healthy. Consider a project structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we are writing a controller file that''s going to import a module defined
    by the `core/product/order.ts` file. Previously, with the commonjs `require` style, we
    would want to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the new ES `import` syntax, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, isn''t that essentially the same? Sort of. But you may have noticed several
    `index.ts` files I''ve put into folders. Now, in the file `core/product/index.ts`,
    we can have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What's the difference? The ideas behind those two approaches of **re-exporting**
    modules can vary. The first style works better when we treat `Order` and `Shipping`
    as namespaces, under which the entity names may not be easy to distinguish from
    one group to another. With this style, the files are the natural boundaries of
    building those namespaces. The second style weakens the namespace property of
    two files and uses them as tools to organize objects and classes under the same
    larger category.
  prefs: []
  type: TYPE_NORMAL
- en: A good thing about using those files as namespaces is that multiple-level re-exporting
    is fine while weakening namespaces makes it harder to understand different identifier
    names as the number of re-exporting levels grows.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are writing JavaScript with network or file system I/O, there is a 95%
    chance that we are doing it asynchronously. However, an asynchronous code may
    tremendously decrease the determinability at the dimension of time. But we are
    so lucky that JavaScript is usually single-threaded; this makes it possible for
    us to write predictable code without mechanisms such as locks most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Writing predictable code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The predictable code relies on predictable tools (if you are using any). Consider
    a helper like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This module exports a `ready` function, which will invoke the callbacks passed
    in when "ready". It will assure that callbacks will be called even if added after
    that. However, you cannot say for sure whether the callback will be called in
    the current event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `i` could either be 0 or `1` when the callback gets
    called. Again, this is not wrong, or even bad, it just makes the code less predictable.
    When someone else reads this piece of code, he or she will need to consider two
    possibilities of how this program would run. To avoid this issue, we can simply
    wrap up the synchronous invocation with `setImmediate` (it may fallback to `setTimeout`
    in older browsers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing predictable code is actually more than writing predictable asynchronous
    code. The highlighted line above can also be written as `setImmediate(callback)`,
    but that would make people who read your code think twice: how will `callback`
    get called and what are the `arguments`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the line of code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s the value of the array `results`? Certainly not `[1, 2, 3]`. Because
    the callback passed to the method `map` receives several arguments: value of current
    item, index of current item, and the whole array, while the function `parseInt`
    accepts two arguments: string to parse, and radix. So `results` are actually the
    results of the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, it is actually okay to write `setImmediate(callback)` directly, as
    the APIs of those functions (including `setTimeout`, `setInterval`, `process.nextTick`,
    and so on) are designed to be used in this way. And it is fair to assume people
    who are going to maintain this project know that as well. But for other asynchronous
    functions whose signatures are not well known, it is recommended to call them
    with explicit arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous creational patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about many creational patterns in [Chapter 3](ch03.html "Chapter 3. Creational
    Design Patterns"), *Creational Design Patterns*. While a constructor cannot be
    asynchronous, some of those patterns may have problems applying to asynchronous
    scenarios. But others need only slight modifications for asynchronous use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Structural Design Patterns"), *Structural
    Design Patterns* we walked through the Adapter Pattern with a storage example
    that opens the database and creates a storage object asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the Proxy Pattern, we made the storage object immediately available
    from its constructor. When a method of the object is called, it waits for the
    initialization to complete and finishes the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A drawback of this approach is that all members that rely on initialization
    have to be asynchronous, though most of the time they just are asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous middleware and hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of middleware is widely used in frameworks such as Express. Middleware
    usually processes its target in serial. In Express, middleware is applied roughly
    in the order it is added while there are not different phases. Some other frameworks,
    however, provide hooks for different phases in time. For example, there are hooks
    that will be triggered *before install*, *after install*, *after uninstall*, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The middleware mechanism of Express is actually a variant of the Chain of Responsibility
    Pattern. And depending on the specific middleware to be used, it can act more
    or less like hooks instead of a responsibility chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons to implement middleware or hooks vary. They may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility**: Most of the time, they are applied due to the requirement
    of extensibility. New rules and processes could be easily added by new middleware
    or hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupling interactions with business logic**: A module that should only
    care about business logic could need potential interactions with an interface.
    For example, we might expect to be able to either enter or update credentials
    while processing an operation, without restarting everything. Thus we can create
    a middleware or a hook, so that we don''t need to have them tightly coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of asynchronous middleware could be interesting. Take the
    Promise version as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using `reduce` to do the trick. We passed in a Promise fulfilled
    with undefined as the initial value, and chained it with the result of `middleware(this)`.
    And this is actually how the `Promise.each` helper is implemented in many Promise
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Event-based stream parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating an application relies on socket, we usually need a lightweight
    "protocol" for the client and server to communicate. Unlike XHR that already handles
    everything, by using socket, you will need to define the boundaries so data won't
    be mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data transferred through a socket might be concatenated or split, but TCP connection
    ensures the order and correctness of bytes gets transferred. Consider a tiny protocol
    that consists of only two parts: a 4-byte unsigned integer followed by a JSON
    string with byte length that matches the 4-byte unsigned integer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for JSON `"{}"`, the data packet would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To build such a data packet, we just need to convert the JSON string to `Buffer`
    (with encoding such as `utf-8`, which is default encoding for Node.js), and then
    prepend its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A socket client emits a `data` event when it receives new buffers. Assume we
    are going to send the following JSON strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We may be receiving them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Get two buffers separately; each of them is a complete packet with length and
    JSON bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get one single buffer with two buffers concatenated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get two, or more than two, buffers; at least one of the previously sent packets
    gets split into several ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The entire process is happening asynchronously. But just like the socket client
    emits a `data` event, the parser can just emit its own `data` event when a complete
    packet gets parsed. The parser for parsing our tiny protocol may have only two
    states, corresponding to header (JSON byte length) and body (JSON bytes), and
    the emitting of the `data` event happens after successfully parsing the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Due to the limitation of length, I'm not going to put the complete implementation
    of the parser here. For the complete code, please refer to the file `src/event-based-parser.ts`
    in the code bundle of [Chapter 7](ch07.html "Chapter 7. Patterns and Architectures
    in JavaScript and TypeScript"), *Patterns and Architectures in JavaScript and
    TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus the use of such a parser could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some interesting ideas and an architecture formed
    by those ideas. Most of the topics focus on a small scope and do their own job,
    but there are also ideas about putting a whole system together.
  prefs: []
  type: TYPE_NORMAL
- en: The code that implements techniques such as expected error and the approach
    to managing modules in a project is not hard to apply. But with proper application,
    it can bring notable convenience to the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: However, as I have already mentioned at the beginning of this chapter, there
    are too many beautiful things in JavaScript and TypeScript to be covered or even
    mentioned in a single chapter. Please don't stop here, and keep exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Many patterns and architectures are the result of some fundamental principles
    in software engineering. Those principles might not always be applicable in every
    scenario, but they may help when you feel confused. In the next chapter, we are
    going to talk about SOLID principles in object-oriented design and find out how
    those principles may help form a useful pattern.
  prefs: []
  type: TYPE_NORMAL
