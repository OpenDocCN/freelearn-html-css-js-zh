<html><head></head><body>
        

                            
                    <h1 class="header-title">WebGL 2 Highlights</h1>
                
            
            
                
<p>In this book, we have covered the foundations of computer graphics with WebGL 2, the web-based 3D Graphics API that ships with all modern browsers. We learned that WebGL 1 is based on OpenGL ES 2.0, while WebGL 2 is based on OpenGL ES 3.0, which guarantees many features that are offered in WebGL 1 as <em>optional</em> extensions, along with many other powerful methods. Although we’ve used WebGL 2 to learn a wide range of computer graphics topics, almost all that knowledge and all of those skills translate to other graphics APIs. That being said, let’s take a moment to cover the key features that WebGL 2 provides over WebGL 1, along with a strategy for migration from WebGL 1 to WebGL 2.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>A more extensive look at the WebGL 2 API</li>
<li>New additions to the WebGL 2 core specification</li>
<li>A strategy for migrating 3D applications from WebGL 1 to WebGL 2</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What's New in WebGL 2?</h1>
                
            
            
                
<p>As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome. This means that you will automatically have access to WebGL 2 without any additional dependencies, as long as you use one of the following browsers:</p>
<ul>
<li>Firefox 51 or above</li>
<li>Google Chrome 56 or above</li>
<li>Chrome for Android 64 or above</li>
</ul>
<p>WebGL 2 Support<br/>
<br/>
For an updated list of the browsers that support WebGL 2, please visit the Khronos Group web page by following this link: <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">http://www.khronos.org/WebGL/wiki/Getting_a_WebGL_Implementation</a>. Or, you can visit the well-known <strong>CanIUse.com</strong> resource at: <a href="https://caniuse.com/#search=webgl2">https://caniuse.com/#search=WebGL 2</a>.<a href="https://caniuse.com/#search=webgl2"/></p>
<p>As described in <a href="48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started</em>, WebGL 1 is based on OpenGL ES 2.0; therefore, it doesn’t expose features like query timers, compute shaders, uniform buffers, and so on. That being said, with WebGL 2 (based on OpenGL ES 3.0), we are getting access to more GPU features like instancing and multiple render targets. Since WebGL 2 is a considerable upgrade from WebGL 1, let’s highlight some of its important features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vertex Array Objects</h1>
                
            
            
                
<p>As described in <a href="d2019a49-9e84-448c-8799-e296187476d1.xhtml">Chapter 2</a>, <em>Rendering</em>, we can implement <strong>vertex array objects</strong> in WebGL 1 by using the <kbd>OES_vertex_array_object</kbd> extension. That being said, they are available by default in WebGL 2. This is an important feature that should always<em> </em>be used, since it significantly reduces rendering times. When not using vertex array objects, all attributes data is in a global WebGL state, which means that calling functions such as <kbd>gl.vertexAttribPointer</kbd>, <kbd>gl.enableVertexAttribArray</kbd>, and <kbd>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)</kbd> manipulates the global state. This leads to performance loss, because before any draw call, we would need to set up all vertex attributes and set the <kbd>ELEMENT_ARRAY_BUFFER</kbd> where indexed data is being used. On the other hand, with vertex array objects, we would set up all attributes during our application's initialization and simply bind the data during rendering, yielding much better performance. </p>
<p>This is very similar to the <kbd>IDirect3DVertexDeclaration9</kbd>/<kbd>ID3D11InputLayout</kbd> interfaces in DirectX land.</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<thead>
<tr>
<th class="CDPAlignLeft CDPAlign">WebGL 1 with Extension</th>
<th class="CDPAlignLeft CDPAlign">WebGL 2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>createVertexArrayOES</kbd></td>
<td class="CDPAlignLeft CDPAlign"><kbd>createVertexArray</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>deleteVertexArrayOES</kbd></td>
<td class="CDPAlignLeft CDPAlign"><kbd>deleteVertexArray</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>isVertexArrayOES</kbd></td>
<td class="CDPAlignLeft CDPAlign"><kbd>isVertexArray</kbd></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>bindVertexArrayOES</kbd></td>
<td class="CDPAlignLeft CDPAlign">
<p class="mce-root"><kbd>bindVertexArray</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">An example of this is as follows:</p>
<div><pre>// Create a VAO instance<br/>var vertexArray = gl.createVertexArray();<br/><br/>// Bind the VAO
gl.bindVertexArray(vertexArray);

// Set vertex array states
<br/>// Set with GLSL layout qualifier<br/>const vertexPositionLocation = 0;<br/>// Enable the attribute
gl.enableVertexAttribArray(vertexPositionLocation);<br/>// Bind Buffer 
gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);<br/>// ...<br/>// Configure instructions for VAO
gl.vertexAttribPointer(vertexPositionLocation, 2, gl.FLOAT, false, 0, 0);

// Clean
gl.bindVertexArray(null);<br/>gl.bindBuffer(gl.ARRAY_BUFFER, null);

// ...

// Render
gl.bindVertexArray(vertexArray);
gl.drawArrays(gl.TRIANGLES, 0, 6);</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Wider Range of Texture Formats</h1>
                
            
            
                
<p>While WebGL 1 had a limited set of texture formats, WebGL 2 provides a much larger set, some of which are listed here: </p>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA32I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG8</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB16UI</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA32UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG8I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB8_SNORM</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA16I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG8UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB8I</kbd></td>
</tr>
<tr style="height: 33.25px">
<td class="CDPAlignLeft CDPAlign" style="height: 33.25px"><kbd>RGBA16UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 33.25px"><kbd>R32I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 33.25px"><kbd>RGB8UI</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA8</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R32UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>SRGB8</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA8I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R16I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R11F_G11F_B10F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA8UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R16UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB9_E5</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>SRGB8_ALPHA8</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R8</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG32F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB10_A2</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R8I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG16F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB10_A2UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R8UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG8_SNORM</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA4</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA32F</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R32F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB5_A1</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA16F</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R16F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB8</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGBA8_SNORM</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>R8_SNORM</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB565</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB32F</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>DEPTH_COMPONENT32F</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG32I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB32I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>DEPTH_COMPONENT24</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG32UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB32UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>DEPTH_COMPONENT16</kbd></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG16I</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB16F</kbd></td>
<td class="CDPAlignLeft CDPAlign"/>
</tr>
<tr style="height: 32px">
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RG16UI</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px"><kbd>RGB16I</kbd></td>
<td class="CDPAlignLeft CDPAlign"/>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">3D Textures</h1>
                
            
            
                
<p>A <strong>3D texture </strong>is a texture in which each mipmap level contains a single three-dimensional image. A 3D texture is essentially just a stack of 2D textures that can be sampled with <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> coordinates in the shader. This functionality allows us to have multiple 2D textures in a single object so that shaders can seamlessly select which image to use for each object.</p>
<p> This is useful for visualizing volumetric data (like medical scans), 3D effects like smoke, storing lookup tables, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Texture Arrays</h1>
                
            
            
                
<p><strong>Texture arrays</strong>, similar to 3D textures, are a great feature for reducing complexity, improving code maintainability, and increasing the number of textures that can be used. By ensuring that all texture slices in a texture array are the same size, shaders can have access to many textures with a smaller footprint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Instanced Rendering</h1>
                
            
            
                
<p>In WebGL 2, <strong>instancing</strong> or <strong>instanced rendering</strong> is available by default<em>. </em>Instance rendering is a way to execute the same drawing commands many times in a row, with each producing a slightly different result. This can be a very efficient method for rendering a large amount of geometry with very few API calls.</p>
<p>Instancing is a great performance booster for certain types of geometry, especially objects with many instances but without many vertices. Good examples are grass and fur. Instancing avoids the overhead of an individual API call per object, while minimizing memory costs by avoiding storing geometric data for each separate instance.</p>
<p>Here's a quick example:</p>
<div><pre>gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 2);</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-Power of 2 Texture Support</h1>
                
            
            
                
<p>As we saw in <a href="1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml" target="_blank">Chapter 7</a>, <em>Textures</em><em>,</em><strong><em> </em></strong>mipmaps are a powerful feature in which pre-calculated, optimized sequences of images, each of which is a progressively lower-resolution representation of the same image, allow for more optimized rendering. While in WebGL 1 the height and width of each image, or level, in the mipmap is a power of two smaller than the previous level, in WebGL 2, that limit is removed. That is, <strong>non-power of 2 textures</strong> work the same as power of 2 textures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fragment Depth</h1>
                
            
            
                
<p>In WebGL 2, we can manually set our own custom values to the depth buffer (z-buffer). This feature allows you to manipulate the depth of a fragment from the fragment shader. This can be expensive, because it forces the GPU to bypass a lot of it's normal fragment discard behavior, but can also allow for some interesting effects that would be difficult to accomplish without having incredibly high poly geometry.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Texture Size in Shaders</h1>
                
            
            
                
<p>In WebGL 2, you can look up the size of any texture within ESSL shaders using <kbd>textureSize</kbd>. With WebGL 1, you'd need to create a uniform and pass the data into the shader manually.</p>
<p>For example:</p>
<pre>vec2 size = textureSize(sampler, lod);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Sync Objects</h1>
                
            
            
                
<p>With WebGL 1, the path from Javascript to GPU to screen is fairly opaque to developers. That is, you dispatch draw commands and at some undefined point in the future, the results show up on the screen. In WebGL 2, <strong>sync objects</strong> allow the developer to gain a little more insight into when the GPU has completed it's work. Using <kbd>gl.fenceSync</kbd>, you can place a marker at some point in the GPU command stream and then later call <kbd>gl.clientWaitSync</kbd> to pause Javascript execution until the GPU has completed all commands up to the fence. Obviously blocking execution isn't desirable for applications that want to render fast, but this can be very beneficial for getting accurate benchmarks. It may also possibly be used in the future for synchronizing between workers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Direct Texel Lookup</h1>
                
            
            
                
<p>It's often convenient to store large arrays of data in a texture. This is possible in WebGL 1, but you can only address textures with texture coordinates inside a range spanning from <kbd>0.0</kbd> to <kbd>1.0</kbd>. In WebGL 2, accessing this sort of data is considerably easier, as you can easily look up values from a texture with pixel/texel coordinates.</p>
<p>For example:</p>
<pre>vec4 values = texelFetch(sampler, ivec2Position, lod);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Flexible Shader Loops</h1>
                
            
            
                
<p>In WebGL 1, loops in the shader had to use a constant integer expression. However, since WebGL 2 is based on OpenGL ES 3.0, this limit no longer exists.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader Matrix Functions</h1>
                
            
            
                
<p>Given that WebGL 2's shading language is much more feature-rich than WebGL 1's, we now have many more matrix math operations at our fingertips. For example, if an <kbd>inverse</kbd> or <kbd>transpose</kbd> of a matrix is needed, we would need to pass it in as a uniform. However, in WebGL 2, functions such as <kbd>inverse</kbd><em> </em>and <kbd>transpose</kbd> are functions directly built into shaders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common Compressed Textures</h1>
                
            
            
                
<p>In WebGL 1, there are various compressed texture formats that are hardware-dependent. For example, formats such as <kbd>S3TC</kbd> and <kbd>PVTC</kbd> are desktop and iOS only, respectively. However, in WebGL 2, the following formats are much more flexible by being hardware independent:</p>
<ul>
<li><kbd>COMPRESSED_R11_EAC RED</kbd></li>
<li><kbd>COMPRESSED_SIGNED_R11_EAC RED</kbd></li>
<li><kbd>COMPRESSED_RG11_EAC RG</kbd></li>
<li><kbd>COMPRESSED_SIGNED_RG11_EAC RG</kbd></li>
<li><kbd>COMPRESSED_RGB8_ETC2 RGB</kbd></li>
<li><kbd>COMPRESSED_SRGB8_ETC2 RGB</kbd></li>
<li><kbd>COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</kbd></li>
<li><kbd>COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</kbd></li>
<li><kbd>COMPRESSED_RGBA8_ETC2_EAC RGBA</kbd></li>
<li><kbd>COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Uniform Buffer Objects</h1>
                
            
            
                
<p>Setting shader program uniforms is a huge part of almost any WebGL/OpenGL draw loop. This can make your draw calls fairly chatty as they make hundreds or thousands of <kbd>gl.uniform</kbd> calls. </p>
<p>In WebGL 1, if we have <kbd>n</kbd> number of uniforms that need to be updated, then it would require <kbd>n</kbd> number of calls with the appropriate uniform method—this can be quite slow. However, with WebGL 2, we can use <strong>uniform buffer objects</strong><strong>, </strong>which allow us to specify a large number of uniforms from a single buffer. This is a major boost in performance, since we can manipulate uniforms in the buffer outside of WebGL by using JavaScript-typed arrays and updating a set of uniforms with a single call. Additionally, uniform buffers can be bound to multiple programs at the same time, so it's possible to update global data (like projection or view matrices) once and all programs that use them will automatically see the changed values.</p>
<div><strong>Heterogeneous Uniform Buffer Objects<br/>
<br/></strong> It's important to note that, in a given application, you can leverage a diverse set of uniform buffer objects to fit your application's needs.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Integer Textures and Attributes</h1>
                
            
            
                
<p>While in WebGL 1 textures and attributes are represented as floating-point values, regardless of their original type, in WebGL 2, textures and attributes are provided integer representation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transform Feedback</h1>
                
            
            
                
<p>A powerful technique offered in WebGL 2 is that vertex shaders can write their results back into a buffer. This can be very useful in situations where we want to leverage the GPU's computational power to perform complex computations so that we are able to read them within our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sampler Objects</h1>
                
            
            
                
<p>While in WebGL 1 all texture parameters are <em>per texture</em>, in WebGL 2, we can optionally use <strong>sampler objects</strong>. By using samplers, we can move all texture parameters to a sampler, allowing a single texture to be sampled in different ways.</p>
<p>In WebGL 1, texture image data and sampling information (which tells GPU how to read the image data) are both stored in texture objects. It can be painful when we want to read from the same texture twice but with a different method (say, linear filtering vs nearest filtering) because we need to have two texture objects. With sampler objects, we can separate these two concepts. We can have one texture object and two different sampler objects. This will result in a change in how our engine organize textures.</p>
<p>Here’s an example:</p>
<div><pre>const samplerA = gl.createSampler();
gl.samplerParameteri(samplerA, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
gl.samplerParameteri(samplerA, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.samplerParameteri(samplerA, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.samplerParameteri(samplerA, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

const samplerB = gl.createSampler();
gl.samplerParameteri(samplerB, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.samplerParameteri(samplerB, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.samplerParameteri(samplerB, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
gl.samplerParameteri(samplerB, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);

// ...

gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.bindSampler(0, samplerA);

gl.activeTexture(gl.TEXTURE1);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.bindSampler(1, samplerB);</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Depth Textures</h1>
                
            
            
                
<p>A major drawback to WebGL 1 is the lack of support for <strong>depth textures</strong>. In WebGL 2, they are available by default.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard Derivatives</h1>
                
            
            
                
<p>While in WebGL 1 you'd need to compute normal and pass them to shaders, in WebGL 2, you can compute them within shaders by using a larger set of mathematical operations that are available by default.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">UNSIGNED_INT Indices</h1>
                
            
            
                
<p>In WebGL 2, there isn't a practical size limit for indexed geometries since we can use 32-bit <kbd>int</kbd> for indices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Blend Equation MIN / MAX</h1>
                
            
            
                
<p>In WebGL, you can easily take the <kbd>MIN</kbd> or <kbd>MAX</kbd> of two colors when blending using these added functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiple Render Targets (MRT)</h1>
                
            
            
                
<p>In WebGL 2, you can draw to multiple buffers at once from a shader. This can be quite powerful for various deferred rendering techniques. This is "the big one" for many developers, because it makes many of the modern deferred rendering techniques that have become such a core part of modern realtime 3D practical for WebGL. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Texture Access in Vertex Shaders</h1>
                
            
            
                
<p>While accessing textures within vertex shaders is possible in WebGL 1, you would need to count how many textures you could access, and that could equal zero. In WebGL 2, texture access is much more streamlined, and the texture access count is required to be at least <kbd>16</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multi-Sampled Renderbuffers</h1>
                
            
            
                
<p>While in WebGL 1 we could only use the GPU's built in multi-sample system to anti-alias our <kbd>canvas</kbd>, in WebGL 2, there is support to perform our own custom multi-sampling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Query Objects</h1>
                
            
            
                
<p><strong>Query objects</strong> give developers another, more explicit way to peek at the inner workings of the GPU. A query wraps a set of GL commands for the GPU to asynchronously report some sort of statistic about. For example, occlusion queries are done in the following way: performing a <kbd>gl.ANY_SAMPLES_PASSED</kbd> query around a set of draw calls will let you detect if any of the geometry passed the depth test. If not, you know that the object wasn't visible and may choose not to draw that geometry in future frames until something happens (object moved, camera moved, and so on) that indicates that the geometry might have become visible again.</p>
<p class="mce-root">It should be noted that these queries are asynchronous, which means that a queries' results may not be ready for many frames after the query was originally issued! This makes them tricky to use, but it can be worth it in the right circumstances.</p>
<p>Here's an example:</p>
<div><pre>gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);<br/>gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 2);<br/>gl.endQuery(gl.ANY_SAMPLES_PASSED);<br/><br/>//...<br/><br/>(function tick() {<br/>  if (!gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {<br/>    // A query's result is never available in the same frame<br/>    // the query was issued.  Try in the next frame.<br/>    requestAnimationFrame(tick);<br/>    return;<br/>  }<br/><br/>  var samplesPassed = gl.getQueryParameter(query, gl.QUERY_RESULT);<br/>  gl.deleteQuery(query);<br/>})();</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Texture LOD</h1>
                
            
            
                
<p>The <strong>texture LOD</strong> parameter is used to determine which mipmap to fetch from. This allows for mipmap streaming, that is, loading only the mipmap levels currently needed. This is very useful for a WebGL environment, where textures are downloaded via a network.</p>
<div><pre>gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_LOD, 0.0);
gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAX_LOD, 10.0);</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader Texture LOD</h1>
                
            
            
                
<p>The <strong>Shader Texture LOD</strong> bias control makes mipmap level control simpler for glossy environment effects in physically-based rendering. Now as part of the WebGL 2 core, the <kbd>lodBias</kbd> can be passed as an optional parameter to texture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Floating Point Textures Always Available</h1>
                
            
            
                
<p>While in WebGL 1, floating point textures are optional<em>,</em> but in WebGL 2, they are available by default.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Migrating to WebGL 2</h1>
                
            
            
                
<p>As we described previously, WebGL 2 is nearly 100 percent backward compatible with WebGL 1.</p>
<p>Backward Compatibility<br/>
<br/>
All exceptions to backward compatibility are recorded at the following link: <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY">https://www.khronos.org/registry/WebGL/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY</a>.</p>
<p>That being said, let's cover some key components of migrating a WebGL 1 application to WebGL 2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaining context</h1>
                
            
            
                
<p>In WebGL 1, you'd attain a WebGL context with something that looks like the following:</p>
<div><pre>const names = ['WebGL', 'experimental-WebGL', 'webkit-3d', 'moz-WebGL'];<br/><br/>for (let i = 0; i &lt; names.length; ++i) {<br/>  try {<br/>    const context = canvas.getContext(names[i]);<br/>    // work with context<br/>  } catch (e) {<br/>    console.log('Error attaining WebGL context', e);<br/>  }<br/>}</pre></div>
<p>In WebGL 2, you'd simply attain the context with a single line, as follows:</p>
<div><pre>const context = canvas.getContext('WebGL 2');<br/></pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Extensions</h1>
                
            
            
                
<p>While in WebGL many optional<em> </em>extensions were <em>required</em> for more advanced functionality, in WebGL 2 you can remove most of those extensions, because they are available by <em>default</em>. Some of these include the following:</p>
<ul>
<li>Depth textures: <a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">https://www.khronos.org/registry/WebGL/extensions/WebGL_depth_texture</a></li>
<li>Floating point textures:
<ul>
<li><a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float">https://www.khronos.org/registry/WebGL/extensions/OES_texture_float</a></li>
<li><a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear">https://www.khronos.org/registry/WebGL/extensions/OES_texture_float_linear</a></li>
</ul>
</li>
<li>Vertex array objects: <a href="https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object">https://www.khronos.org/registry/WebGL/extensions/OES_vertex_array_object</a></li>
<li>Standard derivatives: <a href="https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives">https://www.khronos.org/registry/WebGL/extensions/OES_standard_derivatives</a></li>
<li>Instanced drawing: <a href="https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays">https://www.khronos.org/registry/WebGL/extensions/ANGLE_instanced_arrays</a></li>
<li><kbd>UNSIGNED_INT</kbd> indices: <a href="https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint">https://www.khronos.org/registry/WebGL/extensions/OES_element_index_uint</a></li>
<li>Setting gl_FragDepth: <a href="https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth">https://www.khronos.org/registry/WebGL/extensions/EXT_frag_depth</a></li>
<li>Blend equation <kbd>MIN</kbd>/<kbd>MAX</kbd>: <a href="https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax">https://www.khronos.org/registry/WebGL/extensions/EXT_blend_minmax</a></li>
<li>Direct texture LOD access: <a href="https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod">https://www.khronos.org/registry/WebGL/extensions/EXT_shader_texture_lod</a></li>
<li>Multiple draw buffers: <a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers">https://www.khronos.org/registry/WebGL/extensions/WebGL_draw_buffers</a></li>
<li>Texture access in vertex shaders</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader Updates</h1>
                
            
            
                
<p>While WebGL 2's shader language, based on GLSL 300, is backward compatible with WebGL 1's shader language, we need to make a few changes to ensure that our shaders compile. Let's cover them now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shader Definitions</h1>
                
            
            
                
<p>With WebGL 2's shaders, we have to prepend all shaders with the following line of code: <kbd>#version 300 es</kbd>. It’s important to note that this <em>must </em>be the very first line in the shader, otherwise the shader will not compile.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attribute Definitions</h1>
                
            
            
                
<p>Given that attributes are <em>provided as inputs </em>to shaders, in GLSL 300 ES, the <kbd>attribute</kbd> qualifier is removed. For example, with WebGL's GLSL 100, you might have the following:</p>
<div><pre>attribute vec3 aVertexNormal;<br/>attribute vec4 aVertexPosition;</pre></div>
<p>In GLSL 300 ES, this would be as follows:</p>
<div><pre>in vec3 aVertexNormal;<br/>in vec4 aVertexPosition;</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Varying Definitions</h1>
                
            
            
                
<p>While in GLSL 100, varyings are often defined in both the vertex and fragment shaders, the <kbd>varying</kbd> qualifier has been removed in GLSL 300 ES. That is, varying qualifiers are updated with their appropriate <kbd>in</kbd> and <kbd>out</kbd> qualifiers, depending on whether the values are provided as <em>inputs</em> or returned as <em>outputs</em>. For example, consider the following from GLSL 100:</p>
<div><pre>// inside of the vertex shader<br/>varying vec2 vTexcoord;<br/>varying vec3 vNormal;<br/><br/>// inside of the fragment shader<br/>varying vec2 vTexcoord;<br/>varying vec3 vNormal;</pre></div>
<p>This would be changed to the following in GLSL 300 ES:</p>
<div><pre>// inside of the vertex shader<br/>out vec2 vTexcoord;<br/>out vec3 vNormal;<br/><br/>// inside of the fragment shader<br/>in vec2 vTexcoord;<br/>in vec3 vNormal;</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">No More gl_FragColor</h1>
                
            
            
                
<p>While in GLSL 100 you'd ultimately render the color of the pixel by setting the <kbd>gl_FragColor</kbd> inside of the fragment shader, in GLSL 300 ES, you simply expose a value from your fragment shader. Consider, for example, the following in GLSL 100:</p>
<div><pre>void main(void) {<br/>  gl_FragColor = vec4(1.0, 0.2, 0.3, 1.0);<br/>}</pre></div>
<p>This would be updated by setting a defined custom output variable, as follows:</p>
<div><pre>out vec4 fragColor;<br/> <br/>void main(void) {<br/>  fragColor = vec4(1.0, 0.2, 0.3, 1.0);<br/>}</pre></div>
<p>It's important to note that even though we declared a variable called <kbd>fragColor</kbd>, you can choose any name not starting with the prefix <kbd>gl_</kbd>, due to ambiguity. Throughout this book, we have defined this custom variable as <kbd>fragColor</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Automatic Texture Type Detection</h1>
                
            
            
                
<p>While in GLSL 100 you'd get a color from a texture by using the appropriate methods, such as <kbd>texture2D</kbd>, in GLSL 300 ES, shaders automatically detect the type based on the sampler type in use. For example, consider the following in GLSL 100:</p>
<div><pre>uniform sampler2D uSome2DTexture;<br/>uniform samplerCube uSomeCubeTexture;<br/><br/>void main(void) {<br/>  vec4 color1 = texture2D(uSome2DTexture, ...);<br/>  vec4 color2 = textureCube(uSomeCubeTexture, ...);<br/>}</pre></div>
<p>This would be updated to the following in GLSL 300 ES:</p>
<div><pre>uniform sampler2D uSome2DTexture;<br/>uniform samplerCube uSomeCubeTexture;<br/><br/>void main(void) {<br/>  vec4 color1 = texture(uSome2DTexture, ...);<br/>  vec4 color2 = texture(uSomeCubeTexture, ...);<br/>}</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-Power of 2 Texture Support</h1>
                
            
            
                
<p>As demonstrated in <a href="1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml" target="_blank">Chapter 7</a>, <em>Textures</em>, in WebGL 1, mipmaps don't exist for textures that don't conform to the <em>power of 2</em> restriction. In WebGL 2, however, non-power of 2 textures work exactly the same as power of 2 textures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Floating Point Framebuffer Attachments</h1>
                
            
            
                
<p>While in WebGL 1 a strange hack is required to check whether there is support for rendering to a floating point texture, in WebGL 2, this involves a simple check via standard methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vertex Array Objects</h1>
                
            
            
                
<p>While using vertex array objects is not a <em>necessary </em>requirement, it's a highly <em>recommended </em>feature to use in your migration. By using vertex array objects, you can improve both the overall structure of your code and the performance of your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Let’s summarize what we’ve learned in this chapter:</p>
<ul>
<li>We covered many of the core methods available only in the WebGL 2 specification.</li>
<li>We learned some of the key differences between WebGL 1 and WebGL 2.</li>
<li>We discussed migration strategies for converting a WebGL 1 application to WebGL 2.</li>
</ul>
<p>We're nearly done! Can you believe it? Up next, in the final chapter, <em>Journey Ahead</em>, we will conclude this book by laying out a roadmap of concepts, resources, and other useful pieces of information that are both inspiring and empowering, to help you continue down the path of mastering real-time computer graphics.</p>


            

            
        
    </body></html>