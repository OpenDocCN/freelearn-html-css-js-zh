- en: Chapter 5. AngularJS, React, Express, and Meteor – Developing Your Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the ways in which WebStorm helps us when
    working with the package manager and build tools, and about the workflow for modern
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to deal with a couple of the most essential and
    progressively developing web frameworks and platforms, and then learn how indispensable
    WebStorm can be when working with them. We will get acquainted with the following
    technologies in relation to WebStorm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AngularJS: a client-only framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React: a library for building user interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Express: a minimalist web framework for Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Meteor: a full-stack framework running on top of Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Superheroic JavaScript MVW Framework AngularJS is what HTML would have
    been, had it been designed for building web-apps. Declarative templates with databinding,
    MVW, MVVM, MVC, dependency injection and great testability story all implemented
    with pure client-side JavaScript!"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --[https://angularjs.org](https://angularjs.org) |'
  prefs: []
  type: TYPE_TB
- en: As presented on the developer's website, AngularJS is a client-only framework
    for building single-page web applications aimed to simplify the development and
    testing of web applications. In this section, we are we are going to learn about
    the considerable assistance that WebStorm can provide when using AngularJS, by
    creating a very simple blog application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will be a simple blog CMS that will perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Display a list of entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a single entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, using the steps from the previous chapters, create a new **Empty Project**.
    When creating a new project, you will notice that there is a project type named
    **AngularJS**. You can use it in your development activities; it already comprises
    of all the necessary libraries and setting files. However, for now we are creating
    a blog from scratch so that you can see the multiple ways in which the various
    actions can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: '![AngularJS](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing the tools and libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created our project, we need to install all the dependencies of
    our app. We will use the AngularJS library, a routing library named Angular Route,
    and a styling library like Bootstrap. For the installation process, we will use
    Bower.
  prefs: []
  type: TYPE_NORMAL
- en: 'I don''t like it when Bower installs the components to the default in `bower_components`
    directory. So, let us create a `.bowerrc` file and indicate that we want our packages
    to be installed into the `vendor` directory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the tools and libraries](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can install all the necessary packages. First of all, we need AngularJS.
    Type and execute the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download AngularJS inside our `vendor` folder, but we still need
    to include it in the `index.html` file. With this file open at the end of the
    `body` section, add a `<script>` tag and then start simply typing, for example,
    `ang`. Use autocomplete to let WebStorm find the necessary `.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the tools and libraries](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: WebStorm will know from now on that our application is based on Angular, and
    the `ng-` autocomplete and others will work inside your project.
  prefs: []
  type: TYPE_NORMAL
- en: After this, add another `<script>` tag, and in the `src` attribute, type `"app/app.js"`;
    this will be the core of our application. This file doesn't exist yet, but you
    can automatically create it. Select the file name in the `src` attribute and click
    on *Alt* + *Enter* . Then, click on the **Create File app.js** item, and WebStorm
    will create the missing file for you in the newly opened tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the tools and libraries](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let us install Bootstrap. To do so, you can use Bower from the Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, just like we did with angular sources, include the Bootstrap `.css` and
    `.js` files into your project (using the link and `<script>` tags, respectively).
    As Bootstrap uses jQuery and this will be installed too, don't forget to add a
    `<script>` tag for jQuery as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another library that we are going to use in our project is the angular-route
    library. So, we need to use bower again to install it and then add it to the `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All the manipulations that we have performed so far should result in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Immersing in AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can start building our application. Open the `app.js` file, declare
    a new module called `app`, and then add `ngRoute` as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Immersing in AngularJS](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use autocomplete so that all the code that you write next is automatically
    suggested by WebStorm. This not only reduces development time by removing the
    necessity to write everything manually, but also helps you to better realize and
    decide what is more appropriate in the current context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Immersing in AngularJS](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, this is not the only assistance that WebStorm provides you with. WebStorm
    supplies so-called quick templates, which enable you to quickly write some standard
    code. For instance, in our case, we will need to indicate three routes—to the
    entries list, entry page, and the page to add a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is performed with the `$routeProvider` construction, which can comprise
    certain parameters. We need just two, `templateUrl` and controller, inside a `when`
    condition. So instead of typing this manually, you can simply type `ngrw` and
    press *Tab*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Immersing in AngularJS](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will replace `ngrw` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, the cursor will be placed directly between the two single quotes right
    after the word `when`. This may seem trifling but you needn't perform any unnecessary
    manipulations with your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final code for the `app.js` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the new app module is created, we can bind it to the `index.html`
    page by adding `ng-app="app"` to the `<body>` tag, of course, by using the autocomplete.
    The final `<body>` opening tag should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also add a special container where Angular can render our templates.
    Insert the following code after the opening `<body>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have created a container `<div>` for styling purposes as well. With this
    final change, we can move to creating the features of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the initial entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application will have a list of predefined topics that will be displayed
    on the first load. So, the first thing we need to do is to make sure that the
    data is loaded in the application. We are not going to use any backend so as not
    to complicate our application. We will simulate the server response with static
    JSON files that will be kept in the data folder. For the list of topics, create
    the `entries.json` file inside the `data` folder and fill it with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create the service that stores the data. In the `app.js` file,
    create a new `app.services` module, and fill it with the following code. We will
    use a service so that our data is available in multiple controllers and views.
    You can see that we have already created the `add` method, because we want to
    be able to create new entries in our blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to modify the `app.module` to include the new dependency; so
    after the `ngRoute`, we need add the new module `app.services`. We also need to
    create a new run block that will load the initial data when the application is
    started. The final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a list of entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our list, we will need a controller for the data and a view that will display
    it. Moreover, since we want to display only a short summary in the main page,
    we also have to create a filter that creates the summary text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with this filter so we can use it later in the view. In the `app.js`
    file, add the following module for the filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This filter takes the full content of the entry and displays only the first
    five words. Actually, this filter is agnostic and it doesn't care what it receives;
    it will take any string, and return the first five words from it. Again, after
    we have created this new module, we need to add it as a dependency on the app
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can move to the first controller, create a new module `app.controllers`,
    and add the first controller of our application, `EntriesController`. The only
    thing that this controller does is take the data from the store and pass it to
    the view. After you create this module, don''t forget to add it as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step that we need to implement is the view. Create the `entries.html`
    file in the `views` folder, and fill in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Displaying entry details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created the list of entries, we also have to create the page
    that displays each entry detail. We will again need a controller, a view and,
    a new route definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the new definition after the route definition for the list page.
    The final code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new controller in the `app.controllers` module that reads the
    index from the route parameters and loads the specified entry, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have to create the `entry.html` file, and fill it with the view for
    our entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This view displays the entry title and a full content text. With this view,
    we have finished the entry detail functionality; and, as you can see, you can
    already navigate between the list and the details pages. The only thing that we
    have to create now is the page where we add a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we even start on this feature, we need to add a menu that will allow
    us to navigate to this page. So, open the `index.html` file, and add the following
    code before the container `<div>` of your application. This code will add a header
    menu with the link to this page. For this menu, we are going to use the familiar
    Bootstrap syntax from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the menu for navigating to the page for adding a new entry,
    we need to create a new route definition for this. Following the same steps as
    we did for the previous routes, and add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the controller and the view. Again, in the `app.controllers`
    module, add the new controller. In this controller, we only need to define two
    functions: one to add the entry to our blog, and one to clear the form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the view in the `new-entry.html` file. We will again use
    the Bootstrap syntax for styling. You might also notice the `ng-model` that binds
    the inputs with the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created all the features for our application, we can move to
    the final step of styling our application, and add the final touches.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first things that we can do is add the footer for our application.
    In the `index.html` file, add the following after the `app` container `<div>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You may remember that we have included the `app.css` file in our `index.html`;
    so, go ahead, create this file in the `css` folder, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once again, since we have used the Bootstrap syntax and the helper classes,
    the amount of styling code that we have to write is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: With these final steps, we have finished our blogging application. As you just
    saw, it is very easy to create a complex application with the help of WebStorm
    and Angular. One thing to keep in mind is that this application is just an example,
    and there are a lot of improvements and changes that we can make; but that is
    well beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we are going to recreate the same application with the same features in
    another advanced JavaScript framework: React.'
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"A JavaScript library for building user interfaces"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --[http://facebook.github.io/react/](http://facebook.github.io/react/)
    |'
  prefs: []
  type: TYPE_TB
- en: React is a UI framework developed by Facebook that has a different approach
    to building web applications. It uses a virtual DOM to give the developers a simpler
    programming model and better performance. Moreover, the data flow in React applications
    is a one-way reactive, which reduces the Boilerplate and makes it easier to reason
    about the state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal for this section is to recreate the blog application that we have created
    previously, but using React as the UI framework. We will keep the same features
    that we had in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step that we need to take is to create a new **Empty Project** for
    our application. Next, we need to install all the dependencies. Using the steps
    described earlier in the chapter, create the `.bowerrc` file and the `vendor`
    folder. Then install `react`, `react-router`, and `bootstrap`. You can do that
    by running the following single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the dependencies installed, we have to include them in
    the `index.html` file. Again, use the steps previously described, and include
    the navigation and footer that we did in the Angular example. The final code should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: One thing that might seem out of place in this code is the `text/jsx` type used
    for the `app` file. React uses a special syntax for its files called JSX. This
    syntax is similar to XML and it help us write the markup inside the component
    files.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we have our `index.html` file ready, we can create the `app.jsx`
    file in the `app` folder, and start filling in the code for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fist thing that we have to add is the supporting code for our router. To
    keep our application simpler, we are not going to use any module system. But keep
    in mind that this is a not good as a regular practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To keep things simple, we will skip the loading of entries from an external
    JSON file and, instead, create a variable to keep our initial data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can now move to creating the features of our application. The first one will
    be the entries list. As you can see, in React, all the functionality, including
    the template, is created in JavaScript with the JSX syntax. It might seem odd
    at first, but later on, it will prove to be a very efficient system for keeping
    all things together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, as WebStorm analyzes your code, it will see that you are using
    the JSX syntax and prompt you to switch the language level to JSX Harmony. So
    make sure you click **Switch** at this prompt, or go to the **Preferences** |
    **Languages & Frameworks** | **JavaScript**, and change the language version there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![React](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Entries` class relies on the `EntryItem` that we need to create. It is
    very common in React to compose elements using multiple child elements. You can
    see that the data is passed from the parent to the child as properties on the
    props object in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this class, we have completed the `Entry` items feature, so we can now
    move to create the `Entry` detail features. Again, this will just be a simple
    render method that will display the details for a specific entry. The ID of the
    entry will be read from the route as a property on the `pros.params` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last feature that we need to create is the new entry page feature. For this,
    we will also need to create two special methods that will handle the save and
    clear functionality. Another thing worth mentioning in this class is the `Router.Navigation`
    mixin that we are using. Mixins bring functionality from other classes into our
    own classes. In our example, we need to be able to navigate programmatically from
    within the submit method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you might have noticed, WebStorm is really useful when writing the JSX syntax,
    since it allows for code completion and checking in a way similar to writing plain
    HTML or JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component class that we need to create is the main `App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So far we have created all the components for our application; now we can move
    to create the route definitions for the features of our application: the entries
    list (this will also be the default list), the entry details, and the new entry
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step before we can test our application is to wire up the router,
    which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to test our application. So, we will go to the `index.html`
    file and click the browser icon to run the application. As you can see, the functionality
    is the same as in the Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: I must point out again that the code that we have created here is just for the
    functionality and features of WebStorm, when working with the React framework;
    it is not optimized and it doesn't respect all the best practices when working
    with this framework.
  prefs: []
  type: TYPE_NORMAL
- en: Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Fast, unopinionated, minimalist web framework for Node.js"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --[http://expressjs.com/](http://expressjs.com/) |'
  prefs: []
  type: TYPE_TB
- en: In this section, we are going to look at building some apps using JavaScript
    in the server. We are first going to look at one of the most popular framework
    builds on top of Node.js, that is, Express. This is one of the most popular frameworks
    that provides a robust set of features for both, web and mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to create a new project based on the **Node.js Express
    App** template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Express](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: WebStorm will create the project, and install all the required dependencies.
    At some point, you will also be prompted to download and install the Node.js core
    module sources. This will be required for providing autocompletion and analysis
    for the Node.js core methods, so make sure you select Configure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Express](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the completion of all these steps, WebStorm will create a Run/Debug configuration,
    so you can quickly preview your project. If you select **''bin/www''** to be executed
    from the **Run** menu or the toolbar, your application will start, and you can
    preview it in your browser at the address: `http://localhost:3000/`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is easy to start a Node.js/Express project, including all
    the dependencies and configurations, with the help of WebStorm. We will not go
    any deeper in this chapter, but this project is an excellent foundation for any
    Express application.
  prefs: []
  type: TYPE_NORMAL
- en: Meteor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meteor is an open source, real-time platform for building web applications.
    It runs on top of Node.js and uses MongoDB. The framework is rather young—Meteor
    1.0 came out, not very long ago, on the 28 October, 2014—but it has already proved
    itself to be a powerful tool. WebStorm added support for Meteor in version 9,
    so you can utilize all the techniques that WebStorm suggests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start building a Meteor application, you need to have Meteor installed
    on your machine. Linux and OS X, being command line-centric systems, enable you
    to install Meteor in one click with following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Windows users will need to visit [http://win.meteor.com/](http://win.meteor.com/)
    and download the `.exe` file, which is stable, although not the latest version.
    Alternatively, you may check the website, [https://github.com/meteor/meteor/wiki/Preview-of-Meteor-on-Windows](https://github.com/meteor/meteor/wiki/Preview-of-Meteor-on-Windows)
    and try an RC version.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Meteor environment is ready, so let us move from words to deeds and create
    a small application to observe where and how WebStorm can assist us in using Meteor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first create a new project called `MyMeteorApp`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next window, you will be prompted to select the location of the Meteor
    executable. WebStorm first tries to locate it automatically, and then, if you
    need to specify another location, you can do it here. Also, you can use several
    templates, which are applications that have already been implemented. Let us examine
    how WebStorm handles Meteor with the help of of the **todos** application example.
    This is a simple application for tracking what is to be done and what has already
    been done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'WebStorm needs some time for performing a couple of preparations, such as initializing
    a new application; then you will see the typical structure of a Meteor project,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For technical purposes, any JetBrains' IDEA-based IDE creates a special directory
    called `.idea`, for its own use. The IDE contains information related to the current
    project, such as the list of all the files, configurations, and even the cursor
    positions in each of the open files. So, after generating the Meteor project,
    WebStorm will need some more time to analyze its structure. The nuance in case
    of Meteor applications is that Meteor has a directory for itself, called—`.meteor`,
    where it stores information like details about the required packages and their
    versions. This directory is not controlled by WebStorm, because the contents of
    this directory can change very often and even grow to a very large size. This
    can badly affect WebStorm's efficiency. Therefore, the `.meteor` directory is
    usually under the control of a VCS.
  prefs: []
  type: TYPE_NORMAL
- en: The application is now ready to be opened and run. If you open any `.js` file,
    you can see that WebStorm understands the Meteor-specific JavaScript and highlights
    it appropriately. This is because WebStorm automatically uses the Meteor library.
    You can check this by right-clicking on **Use JavaScript Library** and selecting
    **Meteor project library**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This library not only highlights the syntax, but also provides you with a full-fledged
    autocomplete. If you start typing (for example, `Meteor.st`), you will see that
    WebStorm, as usual, performs an internal analysis of the content and suggests
    the most appropriate methods to use in each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we are not creating an application from scratch and it is already implemented,
    we can run it. In a standard case, to run the Meteor applications, you just need
    to use the command-line interface, and type the `meteor` command. What can WebStorm
    suggest for this if we can simply use the Terminal?
  prefs: []
  type: TYPE_NORMAL
- en: WebStorm provides a very sophisticated, yet convenient, interface for customizing
    the run and debug configurations to automate the most frequently performed actions.
    It is especially useful when you have a lot of parameters that you want to run
    your application with. So, you won't need to indicate them in the Terminal every
    time you need them; you will just use the preconfigured cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new usage case, go to **Run** | **Edit Configurations…**. This will
    open a **Run/Debug Configurations** dialog. Click on the plus button, and choose
    the technology to which you are going to add a usage case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see two tabs. On the **Configuration** tab, you can specify the Meteor
    version to execute your application, program arguments, and environment variables
    (if needed), and so on. On the **Browser / Live Edit** tab, you are provided with
    secondary yet useful features, such as the automatic launching of a specific browser
    when you are running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you finish setting up all the parameters that you need for a certain case,
    you can run your application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Press the green **Play** button on the **Menu** panel of WebStorm (or the green
    bug button for debugging).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Run** | **Run**, and then choose the configuration that you are going
    to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Run** and run `MyMeteorApp`, which will instantly run your application
    with the last used configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can just press *Ctrl* + *R* on Mac or *Shift* + *F10* on
    Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your application is running! You can see the console output in the **Run**
    box, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a new project](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how WebStorm can speed up the development process
    with the most advanced and popular JavaScript frameworks and platforms. We implemented
    a mini-blog in both AngularJS and React, and tested the usage of predefined application
    skeletons for Express and Meteor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will immerse ourselves in the world of mobile development
    using JavaScript and HTML5.
  prefs: []
  type: TYPE_NORMAL
