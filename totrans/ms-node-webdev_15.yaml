- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Creating RESTful Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RESTful Web 服务
- en: This chapter explains how Node.js can be used to create web services that provide
    access to data over HTTP requests, which is a key enabler for **single-page applications**
    (**SPAs**). The chapter begins with a basic web service and then incorporates
    more complex features, such as partial updates and data validation. *Table 14.1*
    puts this chapter in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何使用 Node.js 创建通过 HTTP 请求提供数据访问的 Web 服务，这是单页应用（**SPAs**）的关键推动力。本章从基本的 Web
    服务开始，然后引入更复杂的功能，如部分更新和数据验证。*表 14.1* 将本章置于上下文中。
- en: 'Table 14.1: Putting RESTful web services in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1：将 RESTful Web 服务置于上下文中
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | RESTful web services provide access to data over HTTP requests.
    Instead of sending data embedded in HTML content, the server responds with “raw”
    data, usually in JSON format. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | RESTful Web 服务通过 HTTP 请求提供对数据的访问。服务器不是在 HTML 内容中嵌入数据，而是以“原始”数据的形式响应，通常为
    JSON 格式。|'
- en: '| Why are they useful? | Web services allow clients to perform data operations,
    such as querying or updating data, using HTTP requests. This is most often used
    by JavaScript code executing in the browser, although any type of client can consume
    a web service. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | Web 服务允许客户端使用 HTTP 请求执行数据操作，如查询或更新数据。这通常用于在浏览器中执行的 JavaScript
    代码，尽管任何类型的客户端都可以消费 Web 服务。|'
- en: '| How are they used? | The HTTP request method/verb is used to denote an operation
    and the request URL identifies the data on which the operations should be performed.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用它们？ | HTTP 请求方法/动词用于表示操作，而请求 URL 识别应执行操作的数据。|'
- en: '| Are there any pitfalls or limitations? | There is no standard way to create
    a web service, which leads to significant variations in how they are designed.
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 是否有陷阱或限制？ | 没有创建 Web 服务的标准方式，这导致它们的设计存在显著差异。|'
- en: '| Are there any alternatives? | Most modern web applications require some form
    of web service to deliver data to client-side JavaScript applications. That said,
    web services are not required for applications that are purely round-trip and
    that do not need to support clients. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 是否有替代方案？ | 大多数现代 Web 应用程序都需要某种形式的 Web 服务来向客户端 JavaScript 应用程序交付数据。尽管如此，对于纯粹往返且不需要支持客户端的应用程序，Web
    服务不是必需的。|'
- en: '*Table 14.2* summarizes the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 14.2* 总结了本章内容。'
- en: 'Table 14.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2：本章总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Define a web service | Use the standard request handlers and return JSON
    data instead of HTML. | *9-15* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 定义 Web 服务 | 使用标准请求处理程序并返回 JSON 数据而不是 HTML。 | *9-15* |'
- en: '| Consolidate the code required to create a web service | Separate the code
    that handles HTTP requests so that the data-handling code can be isolated. | *16-18,
    43-45* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 整合创建 Web 服务所需的代码 | 将处理 HTTP 请求的代码分离，以便可以将数据处理代码隔离。 | *16-18, 43-45* |'
- en: '| Update data with a web service | Handle `PUT` and `PATCH` requests. | *19-26*
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 使用 Web 服务更新数据 | 处理 `PUT` 和 `PATCH` 请求。 | *19-26* |'
- en: '| Describe complex data changes | Use the JSON Patch specification. | *27-30*
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 描述复杂的数据更改 | 使用 JSON Patch 规范。 | *27-30* |'
- en: '| Validate the data values received by the web service | Perform validation
    before passing the data to the code that processes data. | *31-37* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 验证 Web 服务接收到的数据值 | 在将数据传递给处理数据的代码之前执行验证。 | *31-37* |'
- en: '| Validate the combinations of data received by the web service | Perform model
    validation. | *38-41* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 验证通过 Web 服务接收到的数据组合 | 执行模型验证。 | *38-41* |'
- en: Preparing for this chapter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: This chapter uses the `part2app` project from *Chapter 13*. The examples in
    this chapter are easier to understand with a simple command-line client application
    that sends HTTP requests and displays the responses that are received. To prepare,
    run the commands shown in *Listing 14.1* in the `part2app` folder to install the
    `Inquirer` package ([https://github.com/SBoudrias/Inquirer.js](https://github.com/SBoudrias/Inquirer.js)),
    which provides features for prompting the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了 *第 13 章* 中的 `part2app` 项目。本章的示例与一个简单的命令行客户端应用程序更容易理解，该应用程序发送 HTTP 请求并显示接收到的响应。为了准备，请在
    `part2app` 文件夹中运行 *列表 14.1* 中显示的命令以安装 `Inquirer` 包 ([https://github.com/SBoudrias/Inquirer.js](https://github.com/SBoudrias/Inquirer.js))，该包提供用于提示用户的特性。
- en: '**Tip**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all other chapters
    in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)下载本章的示例项目——以及本书所有其他章节的示例项目。查看*第1章*了解如果在运行示例时遇到问题如何获取帮助。
- en: 'Listing 14.1: Installing a package'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.1：安装包
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create the `src/cmdline` folder and add to it a file named `main.mjs`, with
    the contents shown in *Listing 14.2*. The .`mjs` file extension tells Node.js
    to treat this file as a JavaScript module and allow the use of the `import` statement.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/cmdline`文件夹中创建一个名为`main.mjs`的文件，并添加*列表14.2*中显示的内容。`.mjs`文件扩展名告诉Node.js将此文件视为JavaScript模块，并允许使用`import`语句。
- en: 'Listing 14.2: The contents of the main.mjs file in the src/cmdline folder'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.2：src/cmdline文件夹中的main.mjs文件的内容
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code uses the `Inquirer` package to prompt the user to choose an operation
    to perform. The choices presented to the user are obtained from the properties
    of an object, and making a choice executes the function assigned to that property.
    Add a file named `operations.mjs` to the `src/cmdline` folder with the contents
    shown in *Listing 14.3*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`Inquirer`包提示用户选择要执行的操作。用户面前呈现的选项是从一个对象属性中获得的，并做出选择将执行分配给该属性的函数。在`src/cmdline`文件夹中添加一个名为`operations.mjs`的文件，并添加*列表14.3*中显示的内容。
- en: 'Listing 14.3: The contents of the operations.mjs file in the src/cmdline folder'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.3：src/cmdline文件夹中的operations.mjs文件的内容
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file provides the operations that the user can select, with a `Test` operation
    to get started and make sure everything works as it should, and an `Exit` option
    that uses the Node.js `process.exit` method to terminate the process. *Listing
    14.4* adds an entry to the scripts section of the `package.json` file to run the
    command-line client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件提供了用户可以选择的操作，包括一个`Test`操作以开始并确保一切按预期工作，以及一个使用Node.js `process.exit`方法终止进程的`Exit`选项。*列表14.4*将条目添加到`package.json`文件的脚本部分以运行命令行客户端。
- en: 'Listing 14.4: Adding a script in the package.json file in the part2app folder'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.4：在part2app文件夹中的package.json文件中添加脚本
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new entry will execute the `main.mjs` file using Node.js. The `--watch`
    argument puts Node.js into watch mode, where it will restart if changes are detected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 新的条目将使用Node.js执行`main.mjs`文件。`--watch`参数将Node.js置于监视模式，如果检测到更改，它将重新启动。
- en: Preparing for a web service
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备网络服务
- en: To prepare for the introduction of a web service, create the `src/server/api`
    folder and add to it a file named `index.ts` with the content shown in *Listing
    14.5*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍网络服务做准备，创建`src/server/api`文件夹，并向其中添加一个名为`index.ts`的文件，其内容如*列表14.5*所示。
- en: 'Listing 14.5: The contents of the index.ts file in the src/server/api folder'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.5：src/server/api文件夹中的index.ts文件的内容
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This file is just a placeholder for now but will be used to configure Express
    to handle HTTP API requests. The final change is to call the function defined
    in *Listing 14.5* to set up the web service, as shown in *Listing 14.6*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件目前只是一个占位符，但将被用于配置Express以处理HTTP API请求。最后的更改是调用*列表14.5*中定义的函数来设置网络服务，如*列表14.6*所示。
- en: 'Listing 14.6: Configuring Express in the server.ts file in the src/server folder'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.6：在src/server文件夹中的server.ts文件中配置Express
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the command shown in *Listing 14.7* in the `part2app` folder to start the
    development tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`part2app`文件夹中运行*列表14.7*中显示的命令以启动开发工具。
- en: 'Listing 14.7: Starting the development tools'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.7：启动开发工具
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open a second command prompt, navigate to the `part2app` folder, and run the
    command shown in *Listing 14.8* to start the command-line client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开第二个命令提示符，导航到`part2app`文件夹，并运行*列表14.8*中显示的命令以启动命令行客户端。
- en: 'Listing 14.8: Starting the command-line client'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.8：启动命令行客户端
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The features provided by the `Inquirer` package present a single choice, like
    this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inquirer`包提供的功能呈现单选选项，如下所示：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use the arrow keys to move up and down the list of choices. Selecting the `Test`
    operation displays a test message, and selecting `Exit` terminates the process.
    Node.js is running in watch mode, which means that it will start the command-line
    client again if a change is detected. Press *Ctrl + C* if you want to stop the
    client entirely.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头键可以上下移动选择列表。选择`Test`操作将显示测试消息，选择`Exit`将终止进程。Node.js正在运行监视模式，这意味着如果检测到更改，它将再次启动命令行客户端。如果您想完全停止客户端，请按*Ctrl
    + C*。
- en: Understanding web services
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络服务
- en: 'There is no definitive agreement about what a web service is, no single standard
    to follow, and no set of widely adopted patterns. The opposite is true: there
    is an endless multitude of opinions, countless patterns, and an endless internet
    shouting match over the “correct” way to deliver data to clients.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于什么是网络服务，没有明确的共识，没有单一的标准可以遵循，也没有一套广泛采用的模式。相反，情况正好相反：有无数的意见，无数的模式，以及关于向客户端“正确”提供数据的“正确”方式的无限争论。
- en: The chaos and noise surrounding web services can be overwhelming, and it can
    be difficult to know where to start. However, the lack of standardization can
    be liberating because it means that a project can focus on delivering just the
    functionality that clients require, without any of the boilerplate or overheads
    that standardization can sometimes bring.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕网络服务的混乱和噪音可能令人难以承受，难以知道从哪里开始。然而，缺乏标准化可能是一种解放，因为它意味着项目可以专注于仅提供客户端需要的功能，而不需要标准化有时会带来的任何样板或开销。
- en: Web services are just data access APIs that are accessed over HTTP. A RESTful
    web service is just a web service that uses aspects of the HTTP requests to determine
    which parts of the API a client wants to use. The term *RESTful* comes from the
    **representational state transfer** (**REST**) pattern, but there has been so
    much variation and adaptation in web services that only the core premise of REST
    is widely used, which is that an API is defined using a combination of HTTP methods
    and URLs. The HTTP method, such as GET or POST, defines the type of operation
    that will be performed, while the URL specifies the data object or objects to
    which the operation will be applied.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务只是通过HTTP访问的数据访问API。RESTful网络服务只是使用HTTP请求的一些方面来确定客户端想要使用API的哪些部分的网络服务。术语*RESTful*来自**表征状态转移**（**REST**）模式，但由于网络服务中的变化和适应如此之多，只有REST的核心前提被广泛使用，即API是通过HTTP方法和URL的组合来定义的。HTTP方法，如GET或POST，定义了将要执行的操作类型，而URL指定了操作将应用到的数据对象或对象。
- en: 'Projects are free to create web service APIs in any way, but the best web services
    are the ones that are simple and easy to use. As an example, here is a URL that
    might identify data managed by the application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以自由地以任何方式创建网络服务API，但最好的网络服务是那些简单易用的服务。以下是一个可能标识应用程序管理的数据的URL示例：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are no restrictions on how the URL is used to identify data, as long as
    the client and the server both understand the URL format so that data can be unambiguously
    identified. If an application stores data in a database, then a URL typically
    identifies a specific value using a primary key, but that is just a common convention
    and not a requirement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用URL来标识数据时没有限制，只要客户端和服务器都理解URL格式，以便可以明确地标识数据。如果一个应用程序在数据库中存储数据，那么URL通常使用主键来标识特定的值，但这只是一个常见的约定，并不是必需的。
- en: The URL identifies the data, but it is the HTTP request method that specifies
    what should be done with that data. *Table 14.3* describes the HTTP methods that
    are commonly used in web services and the operations they conventionally represent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: URL标识数据，但指定对数据进行什么操作的是HTTP请求方法。*表14.3*描述了在Web服务中常用且传统上表示的操作的HTTP方法。
- en: 'Table 14.3: Commonly used HTTP methods'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.3：常用HTTP方法
- en: '| Method | Description |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `GET` | This method is used to retrieve one or more data values |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 此方法用于检索一个或多个数据值 |'
- en: '| `POST` | This method is used to store a new data value |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 此方法用于存储新的数据值 |'
- en: '| `PUT` | This method is used to replace an existing data value |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 此方法用于替换现有的数据值 |'
- en: '| `PATCH` | This method is used to update part of an existing data value |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 此方法用于更新现有数据值的一部分 |'
- en: '| `DELETE` | This method is used to delete a data value |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 此方法用于删除数据值 |'
- en: A web service presents an API by combining URLs and methods and will typically
    return JSON data. For operations that don’t query for data, an indication of the
    outcome is returned and that can also be JSON data. A basic web service might
    provide the combinations described in *Table 14.4*, which also describes the results
    the web service will produce.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Early web services used XML rather than JSON. JSON became the de facto standard
    because it is simple and easily parsed by JavaScript clients, but you will still
    see the occasional reference to XML, such as the `XMLHttpRequest` objects, that
    browsers provide for sending HTTP requests (although these have been superseded
    by the more modern Fetch API).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.4: A typical web service'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | URL | Description |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| This combination gets the single value with ID `1`, expressed as a JSON representation
    of a `Result` object. If there is no such ID, a 404 response will be returned.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| This combination gets all available data values, expressed as a JSON representation
    of an array of `Result` objects. If there is no data, an empty array will be returned.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| This combination finds all values with a `name` value of `Alice` and returns
    a JSON representation of an array of `Result` objects. An empty array will be
    returned if there is no matching data. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This combination stores a value and returns a JSON representation of the
    stored data. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This combination deletes the single value with ID `1` and returns a JSON
    object with a `success` property with a `boolean` value that indicates the outcome.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '**Understanding microservice**s'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Any research on web services will quickly take you into the world of microservices,
    which is why I suggested it as a search term in the previous section. Microservices
    are a way to design applications around business capabilities and that often involves
    web services. A good overview of microservices can be found at [https://microservices.io](https://microservices.io),
    along with details design patterns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: My view of microservices is that they are interesting but should be avoided
    for most projects. The core problem that microservices address is a dysfunctional
    development organization that cannot be managed to provide coordinated software
    releases. This is a problem that many projects face, given that any group of three
    or more developers immediately splits into factions that compete for resources,
    argue over design issues, and blame each other for delays.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Microservices attempt to resolve these problems by having development teams
    work largely in isolation and agreeing only on how different parts of the project
    will be integrated. There are some excellent tools designed to support microservices,
    the most well-known one being Kubernetes, but the tools are incredibly complex,
    and adopting microservices feels like giving up on the complexities of staff management
    to focus on the complexities of software management. In my experience, few HR
    issues have been resolved by increasing the complexity of development tools, so
    I am skeptical that microservices are a practical way to solve complex organizational
    problems. You should form your own view, but my advice is to think carefully before
    adopting microservices and ask yourself whether your colleagues will behave any
    better in a federated development model than they do today.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过让开发团队在大部分情况下独立工作，并仅就项目不同部分如何集成达成一致来尝试解决这些问题。有一些优秀的工具旨在支持微服务，其中最著名的是Kubernetes，但这些工具极其复杂，采用微服务感觉像是放弃人力资源管理复杂性，专注于软件管理复杂性。根据我的经验，很少有HR问题是通过增加开发工具的复杂性来解决的，因此我对微服务是否是解决复杂组织问题的实际方法持怀疑态度。你应该形成自己的观点，但我的建议是在采用微服务之前仔细思考，并问问自己，在联邦开发模型中，你的同事是否会表现得比现在更好。
- en: Creating a basic RESTful web service
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的RESTful Web服务
- en: As a first step, *Listing 14.9* creates a web service that implements some of
    the combinations of URL and HTTP methods described in *Table 14.4*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，*列表14.9* 创建了一个实现*表14.4* 中描述的URL和HTTP方法组合的一些组合的Web服务。
- en: 'Listing 14.9: Creating a basic web service in the index.ts file in the src/server/api
    folder'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.9：在src/server/api文件夹中的index.ts文件中创建基本Web服务
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The listing shows how easy it is to create an API for clients by repurposing
    the parts of the application created for round-trip requests. This is how most
    web services start, but there are some problems and improvements that can be made,
    as later sections explain. But, to complete the initial process, *Listing 14.10*
    adds operations to the client to consume the API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表展示了通过重新利用为往返请求创建的应用程序部分来创建客户端API的简便性。大多数网络服务都是这样开始的，但正如后续章节所解释的，存在一些问题和改进之处。
- en: 'Listing 14.10: Adding operations in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.10：在src/cmdline文件夹中的operations.mjs文件中添加操作
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Node.js supports the Fetch API, which is commonly used by browser-based JavaScript
    code to make HTTP requests. The changes in *Listing 14.10* add a `sendRequest`
    function that sends HTTP requests and displays their results and adds `Get All`
    and `Get Name` operations. The `Get Name` operation uses `Inquirer` to prompt
    for a name, which is then added to the HTTP request query string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js支持Fetch API，这是基于浏览器的JavaScript代码通常用于发起HTTP请求的API。*列表14.10* 中的更改添加了一个`sendRequest`函数，用于发送HTTP请求并显示其结果，并添加了“获取所有”和“获取名称”操作。其中，“获取名称”操作使用`Inquirer`来提示输入名称，然后将其添加到HTTP请求的查询字符串中。
- en: 'The command-line client will restart when the changes in *Listing 14.10* are
    detected. Selecting the **Get All** option and pressing *Return* will display
    all of the available data, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到*列表14.10* 中的更改时，命令行客户端将重新启动。选择“获取所有”选项并按*回车*将显示所有可用数据，如下所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Select the `Get Name` operation and press the *Return* key, and you will be
    prompted for a name. Enter `Alice` and press *Return*, and you will see the matching
    results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“获取名称”操作并按*回车*键，系统将提示输入一个名称。输入“Alice”并按*回车*，你将看到匹配的结果：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you enter a name that doesn’t exist, the web service will respond with a
    404 Not Found response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个不存在的名称，网络服务将响应一个404未找到的错误。
- en: Getting data for the web service
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Web服务的数据
- en: The reason that the web service only supports two of the combinations from *Table
    14.4* is that those are the only operations that can be performed using the repository,
    which was created for the needs of the round-trip application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务只支持*表14.4* 中两种组合的原因是，这些是唯一可以使用为往返应用程序需求创建的存储库执行的操作。
- en: There is no single best way to address this issue, and compromises are required.
    Some projects have web service and round-trip requirements that are similar enough
    to share a repository, but these are rare, and trying to force consistency between
    the two can end up compromising one or both parts of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种单一的最好方法来解决这个问题，需要做出妥协。一些项目有网络服务和往返需求足够相似，可以共享一个仓库，但这些情况很少见，试图在这两者之间强制一致性可能会导致应用程序的一个或两个部分做出妥协。
- en: '**Understanding GraphQL**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 GraphQL**'
- en: GraphQL ([https://graphql.org](https://graphql.org)) is a different approach
    to providing clients with data. A regular RESTful web service provides a specific
    set of operations that produce the same results for all clients. If a client needs
    additional data in responses, for example, then a developer must modify the web
    service, and then all clients will receive that new data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL ([https://graphql.org](https://graphql.org)) 是一种向客户端提供数据的不同方法。常规的 RESTful
    网络服务提供一组特定的操作，这些操作对所有客户端产生相同的结果。如果客户端需要在响应中获取额外的数据，例如，那么开发者必须修改网络服务，然后所有客户端都将接收到这些新数据。
- en: GraphQL still uses HTTP requests, and the data is still expressed as JSON, but
    clients can execute custom queries, which include selecting the data values that
    will be included and filtering data in different ways. This means that clients
    can receive just the data they require, and different clients can receive different
    data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 仍然使用 HTTP 请求，数据仍然以 JSON 格式表达，但客户端可以执行自定义查询，包括选择要包含的数据值以及以不同的方式过滤数据。这意味着客户端可以只接收他们需要的数据，并且不同的客户端可以接收不同的数据。
- en: GraphQL is great, but it is more complex than a regular RESTful web service,
    both in terms of the server-side development and performing client queries, and
    most projects are better suited to conventional RESTful web services, which present
    a fixed set of operations and results to all clients. GraphQL shines in projects
    that have large amounts of data and clients that are going to use that data in
    widely different ways, which the server-side developers cannot anticipate. But,
    for most other projects, GraphQL is too complex, and a conventional web service
    is simpler to create and consume.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 很好，但它比常规的 RESTful 网络服务更复杂，无论是在服务器端开发还是在执行客户端查询方面，而且大多数项目更适合传统的 RESTful
    网络服务，这些服务向所有客户端提供固定的一组操作和结果。GraphQL 在那些拥有大量数据且客户端将以不同方式使用这些数据的项目中表现出色，而这些数据服务器端开发者无法预知。但是，对于大多数其他项目来说，GraphQL
    过于复杂，而传统的网络服务更容易创建和消费。
- en: One alternative is to create separate repositories for each part of the application,
    which allows each to evolve independently, but inevitably leads to some degree
    of code duplication since some operations are likely to be needed by both round-trip
    and web service clients.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是为应用程序的每个部分创建单独的仓库，这允许每个部分独立发展，但不可避免地会导致一定程度上的代码重复，因为某些操作可能同时被往返和 Web 服务客户端需要。
- en: Another alternative – and the one used in this chapter – is to create a subclass
    of the original repository and add the missing features. This works when the features
    required by one part of the application are a subset of those required elsewhere,
    which is the case with the example application. *Listing 14.11* defines a new
    interface that describes additional features required for the web service. Further
    methods will be required later, but this is enough for the moment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择——也是本章使用的方法——是创建原始仓库的子类并添加缺失的功能。当应用程序的一部分所需的功能是其他地方所需功能的一个子集时，这种方法是可行的，例如在示例应用程序中就是这样。*列表
    14.11* 定义了一个新的接口，该接口描述了为网络服务所需的其他功能。稍后还需要更多方法，但现阶段这已经足够了。
- en: '**Tip**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you are unsure where to start, then start by creating a subclass. If you
    find that you need to replace most of the features inherited from the base class,
    then you should split the code into two separate repositories.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定从哪里开始，那么先从创建一个子类开始。如果你发现你需要替换从基类继承的大多数功能，那么你应该将代码分成两个独立的仓库。
- en: 'Listing 14.11: Defining a new interface in the repository.ts file in the src/server/data
    folder'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.11：在 src/server/data 文件夹中的 repository.ts 文件中定义一个新的接口
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The new methods allow an individual `Result` object to be requested by its ID,
    and for data to be deleted by specifying an ID. *Listing 14.12* updates the `OrmRepository`
    class to implement the new interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法允许通过其 ID 请求单个 `Result` 对象，并且可以通过指定 ID 来删除数据。*列表 14.12* 更新了 `OrmRepository`
    类以实现新的接口。
- en: 'Listing 14.12: Implementing the interface in the orm_repository.ts file in
    the src/server/data folder'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.12：在src/server/data文件夹中的orm_repository.ts文件中实现接口
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 14.13* updates the exports from the `data` module to add the API-specific
    repository.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14.13*更新`data`模块的导出，以添加API特定的仓库。'
- en: 'Listing 14.13: Updating exports in the index.ts file in the src/server/data
    folder'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.13：在src/server/data文件夹中的index.ts文件中更新导出
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 14.14* uses the new repository interface to add features to the web
    service. This code is difficult to read, but this will be addressed in the next
    section.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14.14*使用新的仓库接口向网络服务添加功能。这段代码难以阅读，但将在下一节中解决。'
- en: 'Listing 14.14: Adding features in the index.ts file in the src/server/api folder'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.14：在src/server/api文件夹中的index.ts文件中添加功能
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new routes add support for querying by ID, storing new results, and deleting
    existing results. The ability to store new results depends on the ability to query
    by ID because there is a mismatch between the result returned by the `Repository.saveResult`
    method, and the result required by the web service for POST requests. The `saveResult`
    method returns the `Id` of the newly stored object, and so an additional query
    is required to get the `Result` object that has been stored so that it can be
    sent back to the client. *Listing 14.15* adds new operations to the command-line
    client that rely on the new web service features.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 新的路由增加了按ID查询、存储新结果和删除现有结果的支持。存储新结果的能力取决于按ID查询的能力，因为`Repository.saveResult`方法返回的结果与网络服务POST请求所需的结果不匹配。`saveResult`方法返回新存储对象的`Id`，因此需要额外的查询来获取已存储的`Result`对象，以便将其发送回客户端。*列表14.15*向命令行客户端添加了依赖于新网络服务功能的新操作。
- en: 'Listing 14.15: Adding features in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.15：在src/cmdline文件夹中的operations.mjs文件中添加功能
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the command-line client, select the `Get Id` option and enter `3` when
    prompted, which will produce the following result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行客户端，选择`获取ID`选项，并在提示时输入`3`，将产生以下结果：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The web service will return a 404 Not Found response for `ID`s that don’t exist
    in the database. Select the `Store` option and enter `Drew, 50, and 5`, when prompted
    for the name, age, and years values, and the response will show the new record
    that is stored:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库中不存在的`ID`，网络服务将返回404未找到响应。当提示输入名称、年龄和年数值时，选择`存储`选项并输入`Drew, 50, and 5`，响应将显示存储的新记录：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Selecting the `Get All` option will show the new record along with the existing
    data in the database (but bear in mind that the database is reset and reseeded
    every time the server-side application restarts, so don’t make any code changes):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`获取全部`选项将显示数据库中的新记录以及现有数据（但请注意，每次服务器端应用程序重启时，数据库都会重置并重新播种，因此不要进行任何代码更改）：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Select the **Delete** option and enter the `ID` of the newly stored item when
    prompted. The result is a JSON object with a deleted property that indicates the
    outcome:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**删除**选项，并在提示时输入新存储项的`ID`。结果是包含已删除属性以指示结果的JSON对象：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Selecting the **Get All** option will confirm that the data has been deleted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**获取全部**选项将确认数据已被删除。
- en: '**Understanding OpenAPI**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解OpenAPI**'
- en: The OpenAPI specification ([https://www.openapis.org](https://www.openapis.org))
    is a standard for describing web services, which can help client-side developers
    understand how a web service is intended to be used and provides a description
    of the data to which it provides access. There are tools and packages available
    that generate client-side code automatically from an OpenAPI description, and
    some JavaScript packages used to define web services will automatically generate
    OpenAPI documents.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范([https://www.openapis.org](https://www.openapis.org))是描述网络服务的标准，可以帮助客户端开发者了解网络服务应该如何使用，并提供对它提供访问的数据的描述。有工具和包可以从OpenAPI描述自动生成客户端代码，并且一些用于定义网络服务的JavaScript包将自动生成OpenAPI文档。
- en: OpenAPI is a good idea, but it is often used as a substitute for descriptive
    documentation, which tends to leave a gap between the features a web service provides
    and how the developer intended them to be used. If you adopt OpenAPI in your project,
    you must ensure that you supplement the description it produces with notes that
    explain how your web service should be consumed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 是一个好主意，但它通常被用作描述性文档的替代品，这往往会在 Web 服务提供的功能与开发者意图使用它们之间留下差距。如果你在项目中采用
    OpenAPI，你必须确保补充描述它产生的说明，以说明你的 Web 服务应该如何被消费。
- en: Separating the HTTP code
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离 HTTP 状态码
- en: 'The web service in *Listing 14.15* supports all the combinations of HTTP method
    and URL described in *Table 14.4*, but the code is difficult to understand. The
    web service has three tasks to perform: parsing the HTTP request, performing an
    operation, and preparing the HTTP response. When the same code is responsible
    for all of these tasks, it can be hard to identify the statements that perform
    the operations because they get lost in all the HTTP handling.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14.15* 中的 Web 服务支持 *表 14.4* 中描述的所有 HTTP 方法与 URL 的组合，但代码难以理解。Web 服务有三个任务要执行：解析
    HTTP 请求、执行操作和准备 HTTP 响应。当相同的代码负责所有这些任务时，很难识别执行操作的语句，因为它们在所有 HTTP 处理中都被淹没。'
- en: 'The result also tends to be HTTP centric, by which I mean that most developers
    end up writing code with as few routes as possible, and that further complicates
    the results. You can see this in *Listing 14.14*, where the Express `all` method
    is used to match all requests for a URL path, with the HTTP method being identified
    in the request handler, like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果往往也以 HTTP 为中心，我的意思是大多数开发者最终会编写尽可能少的路由的代码，这进一步复杂了结果。你可以在 *列表 14.14* 中看到这一点，其中使用了
    Express 的 `all` 方法来匹配对 URL 路径的所有请求，HTTP 方法在请求处理器中被识别，如下所示：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I end up writing this kind of code all the time. The code compiles, and the
    web service works, but it is difficult to maintain because different aspects of
    the web service are intertwined.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是编写这类代码。代码可以编译，Web 服务也能工作，但维护起来很困难，因为 Web 服务的不同方面交织在一起。
- en: Web services are more easily written and maintained if the code that handles
    the HTTP requests is extracted into an adapter, with the added benefit that web
    services that require the same set of HTTP methods and URL formats can use the
    same adapter code. To describe the functionality of a web service, add a file
    named `http_adapter.ts` to the `src/server/api` folder with the code in *Listing
    14.16*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将处理 HTTP 请求的代码提取到适配器中，Web 服务将更容易编写和维护，而且还有一个额外的好处，即需要相同一组 HTTP 方法和 URL 格式的
    Web 服务可以使用相同的适配器代码。为了描述 Web 服务的功能，将名为 `http_adapter.ts` 的文件添加到 `src/server/api`
    文件夹中，其中包含 *列表 14.16* 中的代码。
- en: 'Listing 14.16: The contents of the http_adapter.ts file in the src/server/api
    folder'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14.16*：src/server/api 文件夹中 http_adapter.ts 文件的内容'
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `WebService<T>` interface describes a web service that operates on type
    `T`, with methods that describe the operations required to support the basic web
    service features. The `createAdapter<T>` function creates Express routes that
    rely on the `WebService<T>` methods to produce results. To create an implementation
    of the `WebService<T>` interface for `Result` data, add a file named `results_api.ts`
    to the `src/server/api` folder with the content shown in *Listing 14.17*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebService<T>` 接口描述了一个在类型 `T` 上操作的 Web 服务，其中包含描述支持基本 Web 服务功能的操作的方法。`createAdapter<T>`
    函数创建依赖于 `WebService<T>` 方法的 Express 路由。为了为 `Result` 数据创建 `WebService<T>` 接口的实现，将名为
    `results_api.ts` 的文件添加到 `src/server/api` 文件夹中，其中包含 *列表 14.17* 中显示的内容。'
- en: '**Note**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'I generally define JavaScript functions using the fat arrow syntax because
    it feels more natural to me. However, I used the `function` keyword in *Listing
    14.16* to define the `createAdapter<T>` function, because the way that TypeScript
    type parameters are expressed on fat arrow functions seems awkward to me. The
    equivalent function signature in fat arrow form is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用箭头函数语法来定义 JavaScript 函数，因为这对我来说感觉更自然。然而，我在 *列表 14.16* 中使用了 `function` 关键字来定义
    `createAdapter<T>` 函数，因为我觉得在箭头函数上表达 TypeScript 类型参数的方式有些笨拙。等效的函数签名在箭头函数形式中是：
- en: '`export const createAdapter = <T>(app: Express, ws: WebService<T>, baseUrl:
    string) => {`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`export const createAdapter = <T>(app: Express, ws: WebService<T>, baseUrl:
    string) => {`'
- en: Putting the type parameter after the equals sign seems jarring to me, although
    you are free to follow either syntax as your preferences dictate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型参数放在等号之后对我来说感觉有些刺耳，尽管你可以根据你的偏好选择任何一种语法。
- en: 'Listing 14.17: The contents of the results_api.ts file in the src/server/api
    folder'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.17：src/server/api文件夹中的results_api.ts文件的内容
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ResultWebService` class implements the `WebService<Result>` interface and
    implements the methods by using the repository features. *Listing 14.18* uses
    the new adapter to register the web service, replacing the mixed code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultWebService`类实现了`WebService<Result>`接口，并通过使用仓库功能来实现方法。*列表14.18*使用新的适配器注册网络服务，替换了混合代码。'
- en: 'Listing 14.18: Using the adapter in the index.ts file in the src/server/api
    folder'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.18：在src/server/api文件夹中的index.ts文件中使用适配器
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is no change in the behavior of the web service, but removing the code
    that deals with HTTP requests and responses makes the web service easier to understand
    and maintain.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务的行为没有改变，但移除处理HTTP请求和响应的代码使得网络服务更容易理解和维护。
- en: Updating data
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'There are two ways to support updates in web services: replacing data and patching
    data. An HTTP PUT request is sent when the client wants to completely replace
    data, and the request body contains all of the data the web service will need
    for the replacement. An HTTP `PATCH` method is used when the client wants to modify
    data, and the request body contains a description of how that data should be modified.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务中支持更新的有两种方式：替换数据和修补数据。当客户端想要完全替换数据时，发送HTTP PUT请求，请求体包含网络服务将用于替换的所有数据。当客户端想要修改数据时，使用HTTP
    `PATCH`方法，请求体包含描述如何修改该数据的内容。
- en: Supporting updates with PUT requests is simpler to implement but requires the
    client to provide a complete replacement for the stored data. PATCH requests are
    more complex but offer more flexibility and can be more efficient because only
    the changes are sent to the web service.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PUT请求支持更新更容易实现，但需要客户端提供存储数据的完整替换。PATCH请求更复杂，但提供了更多灵活性，并且可能更高效，因为只有更改被发送到网络服务。
- en: '**Tip**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It can be hard to know which approach to adopt at the start of a new project
    when the types of updates clients will send are unknown. My advice is to start
    by supporting complete updates because they are simpler to implement and move
    to partial updates only if you find that the unchanged data values start to outnumber
    the changed values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当不知道客户端将发送的更新类型时，在新的项目开始时可能很难知道采用哪种方法。我的建议是首先支持完整更新，因为它们更容易实现，只有在你发现未更改的数据值开始超过更改的值时，才转向部分更新。
- en: This chapter demonstrates both PUT and PATCH requests. To prepare, *Listing
    14.19* adds a new method to the `ApiRepository` interface that will allow data
    to be updated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了PUT和PATCH请求。为了准备，*列表14.19*向`ApiRepository`接口添加了一个新方法，这将允许更新数据。
- en: 'Listing 14.19: Adding a method in the repository.ts file in the src/server/data
    folder'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.19：在src/server/data文件夹中的repository.ts文件中添加方法
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 14.20* implements this method using the Sequelize ORM package.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14.20*使用Sequelize ORM包实现了此方法。'
- en: 'Listing 14.20: Updating data in the orm_repository.ts file in the src/server/data
    folder'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.20：在src/server/data文件夹中的orm_repository.ts文件中更新数据
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Updating the data in the example means changing either the name or calculation
    associated with a result. The implementation of the `update` method performs an
    update in four steps, all of which are performed as a transaction. The first step
    is to read the data that is to be updated from the database using the `id` property
    of the `Result` parameter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中更新数据意味着更改与结果关联的名称或计算。`update`方法的实现通过四个步骤进行更新，所有这些步骤都作为事务执行。第一步是从数据库中读取要更新的数据，使用`Result`参数的`id`属性：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If there is a matching entry in the database, the `findOrCreate` method is
    used to locate the `Person` and `Calculation` data that matches the `Result` parameter
    or create new data if there are no matches. The next step is to update the `ID`s
    so the stored data refers to the new `Person` and `Calculation` records and write
    the changes to the database, which is done using the `save` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中有一个匹配的条目，使用`findOrCreate`方法来定位与`Result`参数匹配的`Person`和`Calculation`数据，或者在没有匹配的情况下创建新数据。下一步是更新`ID`s，以便存储的数据引用新的`Person`和`Calculation`记录，并将更改写入数据库，这是使用`save`方法完成的：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `save` method is smart enough to detect changes and will only update the
    database for properties whose values have changed. The final step is performed
    after the transaction has been committed and returns the modified data using the
    `getResultById` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 方法足够智能，可以检测更改，并且仅对值已更改的属性更新数据库。最后一步是在事务提交后执行，并使用 `getResultById` 方法返回修改后的数据。'
- en: Replacing data with PUT requests
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PUT 请求替换数据
- en: PUT requests are the simplest to implement because the web service simply uses
    the data sent by the client to replace the stored data. *Listing 14.21* extends
    the interface that describes web services to add a new method and extends the
    HTTP wrapper to use the interface method to handle PUT requests.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 请求是最容易实现的，因为 Web 服务只需使用客户端发送的数据来替换存储的数据。*列表 14.21* 扩展了描述 Web 服务的接口以添加新方法，并扩展了
    HTTP 包装器以使用接口方法处理 PUT 请求。
- en: '**Note**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Not every web service uses PUT requests for updates. POST requests are often
    used both to store new data and update data, using the URL to differentiate between
    operations, so that the URL used for an update will include a unique `ID` (`/api/results/1`)
    and the URL used to store data will not (`/api/results`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个 Web 服务都使用 PUT 请求进行更新。POST 请求通常用于存储新数据和更新数据，使用 URL 来区分操作，因此用于更新的 URL 将包含一个唯一的
    `ID` (`/api/results/1`)，而用于存储数据的 URL 则不会 (`/api/results`)。
- en: 'Listing 14.21: Adding methods in the http_adapter.ts file in the src/server/api
    folder'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.21：在 src/server/api 文件夹中的 http_adapter.ts 文件中添加方法
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `replace` method added to the `WebService<T>` interface accepts an `id`
    and a `data` object. The new route matches requests with the PUT method, extracts
    the `ID` from the URL, and uses the request body for the data. Implementing the
    method in the web service is a matter of receiving the data from the HTTP wrapper
    and passing it on to the repository, as shown in *Listing 14.22*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `WebService<T>` 接口的 `replace` 方法接受一个 `id` 和一个 `data` 对象。新的路由匹配使用 PUT 方法的请求，从
    URL 中提取 `ID`，并使用请求体作为数据。在 Web 服务中实现此方法的问题在于从 HTTP 包装器接收数据并将其传递给存储库，如 *列表 14.22*
    所示。
- en: 'Listing 14.22: Replacing data in the results_api.ts file in the src/server/api
    folder'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.22：在 src/server/api 文件夹中的 results_api.ts 文件中替换数据
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The data received from the HTTP wrapper is deconstructed into constant values
    that are combined with the `id` parameter and passed to the repository’s `update`
    method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从 HTTP 包装器接收的数据被解构为与 `id` 参数组合的常量值，并传递给存储库的 `update` 方法。
- en: The last step is to add an operation to the command-line client that will send
    the PUT request, as shown in *Listing 14.23*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是向命令行客户端添加一个操作，该操作将发送 PUT 请求，如 *列表 14.23* 所示。
- en: 'Listing 14.23: Supporting updates in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.23：在 src/cmdline 文件夹中的 operations.mjs 文件中支持更新
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The operation is called `Replace` and it prompts for all the values required
    to store data and sends them to the web service using an HTTP `PUT` request. Select
    the new **Replace** option from the command line and enter `1`, `Joe`, `35`, `10`,
    and `45` when prompted. This operation will update the result whose `ID` is `1`
    with a new name, like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 操作称为 `Replace`，它会提示存储数据所需的所有值，并使用 HTTP `PUT` 请求将它们发送到 Web 服务。从命令行选择新的 **Replace**
    选项，并在提示时输入 `1`、`Joe`、`35`、`10` 和 `45`。此操作将更新 `ID` 为 `1` 的结果，并赋予新的名称，如下所示：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The name is changed but the other values are the same, so the relationship between
    the result and the calculation in the database remains unchanged.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 名称已更改，但其他值保持不变，因此结果与数据库中的计算之间的关系保持不变。
- en: Modifying data with PATCH requests
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PATCH 请求修改数据
- en: PATCH requests allow a client to ask a web server to apply partial updates,
    without having to send a complete data record. There is no standard way to describe
    partial changes in a PATCH request and any data format can be used, just as long
    as the client and the web service both understand how data is identified and how
    changes are described. To support PATCH requests, *Listing 14.24* adds a new method
    to the web service interface and defines a route that matches PATCH requests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: PATCH 请求允许客户端请求 Web 服务器应用部分更新，而无需发送完整的数据记录。没有标准方式来描述 PATCH 请求中的部分更改，可以使用任何数据格式，只要客户端和
    Web 服务都理解如何标识数据以及如何描述更改。为了支持 PATCH 请求，*列表 14.24* 向 Web 服务接口添加了一个新方法，并定义了一个匹配 PATCH
    请求的路由。
- en: 'Listing 14.24: Supporting PATCH requests in the http_adapter.ts file in the
    src/server/api folder'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.24：在 src/server/api 文件夹中的 http_adapter.ts 文件中支持 PATCH 请求
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The simplest way to support partial updates is to allow the client to provide
    a JSON object that contains only replacement values and omits any property that
    should be left unchanged, as shown in *Listing 14.25*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 支持部分更新的最简单方法是允许客户端提供一个仅包含替换值的JSON对象，并省略任何应保持不变的属性，如*列表14.25*所示。
- en: 'Listing 14.25: Modifying data in the results_api.ts file in the src/server/api
    folder'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.25：在src/server/api文件夹中的results_api.ts文件中修改数据
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The implementation method enumerates the properties defined by the `Result`
    interface and checks to see whether the data received from the request contains
    a replacement value. New values are applied to update the existing data, which
    is then passed to the repository’s `replace` method to be stored. Notice that
    the repository is used in the same way for replacements and updates and that it
    is the job of the web service to prepare the data for storage. *Listing 14.26*
    adds an operation to the command-line client that sends PATCH requests.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法枚举由`Result`接口定义的属性，并检查从请求接收到的数据是否包含替换值。新值被应用于更新现有数据，然后传递给存储库的`replace`方法进行存储。请注意，存储库在替换和更新时使用的方式相同，并且准备数据以供存储是网络服务的职责。*列表14.26*向命令行客户端添加了一个操作，用于发送PATCH请求。
- en: 'Listing 14.26: Sending PATCH requests in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.26：在src/cmdline文件夹中的operations.mjs文件中发送PATCH请求
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This operation prompts for values in the same way as for PUT requests, but the
    JavaScript `Object.fromEntries`, `Object.entries`, and `filter` functions are
    used to exclude any property for which no value is provided so that a partial
    update is sent to the web service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作以与PUT请求相同的方式提示值，但使用JavaScript的`Object.fromEntries`、`Object.entries`和`filter`函数来排除任何未提供值的属性，以便向网络服务发送部分更新。
- en: 'Select the new **Modify** option from the command line and enter `2` for the
    `ID` and `Clara` for the name, and then press *Return* for the other prompts.
    This operation will update the result whose `ID` is `2` with a new name, like
    this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行选择新的**修改**选项，输入`2`作为`ID`，输入`Clara`作为名称，然后按*回车*键以响应其他提示。此操作将更新`ID`为`2`的结果，并赋予新的名称，如下所示：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The client sent only a new name value to the web service and didn’t need to
    send values for the properties whose values were not changed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只向网络服务发送了新的名称值，并且不需要发送未更改值的属性值。
- en: Using JSON Patch
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON Patch
- en: The approach used in the previous section is useful when the only updates sent
    by the client are changes to existing data values. Many projects fall into this
    category, and it is a useful technique when the data becomes too complex for replacement
    requests and the only changes are providing updated values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中使用的方法在客户端仅发送现有数据值更改时很有用。许多项目属于这一类别，当数据变得过于复杂，无法使用替换请求，并且只有提供更新值的变化时，这是一种有用的技术。
- en: 'The JSON Patch format ([https://jsonpatch.com](https://jsonpatch.com)) can
    be used for more complex updates. A JSON Patch document contains a series of operations
    that are applied to a JSON document. A JSON Patch document to update the value
    of the `name` property, for example, would look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Patch格式([https://jsonpatch.com](https://jsonpatch.com))可用于更复杂的更新。一个JSON
    Patch文档包含一系列应用于JSON文档的操作。例如，用于更新`name`属性值的JSON Patch文档将看起来像这样：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: JSON Patch documents contain an array of JSON objects, with `op` and `path`
    properties that describe the operation to be performed and the target for that
    operation. Additional properties are required for some operations, such as the
    `value` property used to specify the new value for the replace operation. *Table
    14.5* describes the JSON Patch operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Patch文档包含一个包含JSON对象的数组，其中`op`和`path`属性描述了要执行的操作及其目标。某些操作需要额外的属性，例如用于指定替换操作的新值的`value`属性。*表14.5*描述了JSON
    Patch操作。
- en: 'Table 14.5: The JSON Patch operations'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.5：JSON Patch操作
- en: '| Operation | Description |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| This operation adds a property to the JSON document, with the name and value
    specified by the `path` and `value` properties. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 此操作向JSON文档添加一个属性，该属性由`path`和`value`属性指定的名称和值。 |'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| This operation removes a property from the JSON document, specified by the
    `path` property. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 此操作从JSON文档中删除一个属性，该属性由`path`属性指定。 |'
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| This operation changes the property specified by the `path` property using
    the value assigned to the `value` property. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 此操作使用`value`属性分配的值更改由`path`属性指定的属性。 |'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| This operation duplicates a property specified by the `from` property to
    the location specified by the `path` property. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 此操作将 `from` 属性指定的属性复制到 `path` 属性指定的位置。|'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| This operation moves a property specified by the `from` property to the location
    specified by the `path` property. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 此操作将 `from` 属性指定的属性移动到 `path` 属性指定的位置。|'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| This property checks to see that the JSON document contains a property and
    value specified by the `path` and `value` properties. No other operations will
    be performed if this operation fails. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 此属性检查 JSON 文档是否包含由 `path` 和 `value` 属性指定的属性和值。如果此操作失败，则不会执行其他操作。|'
- en: The `path` property is used to identify values in the JSON document using the
    JSON Pointer syntax, which is described at [https://datatracker.ietf.org/doc/html/rfc6901](https://datatracker.ietf.org/doc/html/rfc6901),
    and which can be used to select properties and array elements. The location `/name`,
    for example, denotes a `name` property at the top level of the JSON document.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 属性用于使用 JSON Pointer 语法在 JSON 文档中标识值，该语法在 [https://datatracker.ietf.org/doc/html/rfc6901](https://datatracker.ietf.org/doc/html/rfc6901)
    中描述，并且可以用于选择属性和数组元素。例如，位置 `/name` 表示 JSON 文档顶层的一个 `name` 属性。'
- en: JSON Patch documents can be parsed and applied using custom code, but it is
    easier to use one of the available open-source JavaScript packages. Run the command
    shown in *Listing 14.27* in the `part2app` folder to install the `fast-json-patch`
    package ([https://github.com/Starcounter-Jack/JSON-Patch](https://github.com/Starcounter-Jack/JSON-Patch)),
    which is a popular JSON Patch package.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用自定义代码解析和应用 JSON Patch 文档，但使用可用的开源 JavaScript 包更容易。在 `part2app` 文件夹中运行 *列表
    14.27* 中显示的命令来安装 `fast-json-patch` 包 ([https://github.com/Starcounter-Jack/JSON-Patch](https://github.com/Starcounter-Jack/JSON-Patch))，这是一个流行的
    JSON Patch 包。
- en: 'Listing 14.27: Installing the JSON Patch package'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.27：安装 JSON Patch 包
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 14.28* updates the web service so that the `modify` method will treat
    the data it receives as a JSON Patch document and apply it using the `fast-json-patch`
    package.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14.28* 更新了 Web 服务，使得 `modify` 方法将接收到的数据视为 JSON Patch 文档，并使用 `fast-json-patch`
    包应用它。'
- en: 'Listing 14.28: Using JSON Patch in the result_api.ts file in the src/server/api
    folder'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.28：在 src/server/api 文件夹中的 result_api.ts 文件中使用 JSON Patch
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `applyPatch` method is used to process the JSON Patch document to an object.
    The `result` object defines a `newDocument` property that returns the modified
    object, which can be stored in the database.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `applyPatch` 方法将 JSON Patch 文档处理为一个对象。`result` 对象定义了一个 `newDocument` 属性，它返回修改后的对象，该对象可以存储在数据库中。
- en: The HTTP `Content-Type` header is set to `application/json-patch+json` when
    sending a JSON Patch document and this type is not decoded automatically by the
    Express JSON middleware component. *Listing 14.29* configures the JSON middleware
    so that normal JSON payloads and JSON Patch payloads will be decoded.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送 JSON Patch 文档时，HTTP `Content-Type` 标头设置为 `application/json-patch+json`，并且此类型不是由
    Express JSON 中间件组件自动解码。*列表 14.29* 配置了 JSON 中间件，以便正常 JSON 负载和 JSON Patch 负载将被解码。
- en: 'Listing 14.29: Enabling JSON Patch decoding in the server.ts file in the src/server
    folder'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.29：在 src/server 文件夹中的 server.ts 文件中启用 JSON Patch 解码
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The JSON middleware accepts a configuration object whose `type` property can
    be configured with an array of content types to decode. The final step is to create
    a JSON Patch document in the command-line client, as shown in *Listing 14.30*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 中间件接受一个配置对象，其 `type` 属性可以配置为要解码的内容类型数组。最后一步是在命令行客户端中创建 JSON Patch 文档，如
    *列表 14.30* 所示。
- en: 'Listing 14.30: Using JSON Patch in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.30：在 src/cmdline 文件夹中的 operations.mjs 文件中使用 JSON Patch
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `fast-json-patch` package is capable of generating a JSON Patch document,
    but it is easier to create patches with custom code than it is to apply them,
    and the modified statement in *Listing 14.30* creates `replace` operations for
    each of the values entered by the user.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`fast-json-patch` 包能够生成 JSON Patch 文档，但与应用它们相比，使用自定义代码创建补丁更容易，*列表 14.30* 中修改的语句为用户输入的每个值创建
    `replace` 操作。'
- en: 'There is no change in the way the client and web service behave, which you
    can confirm by selecting the `Modify` option from the command line and entering
    `2` for the `ID` and `Clara` for the name, and then pressing return for the other
    prompts. This is the same change performed earlier in the chapter and it should
    produce the same results, like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和网络服务的行为方式没有变化，你可以通过从命令行选择`修改`选项，输入`2`作为`ID`，`Clara`作为名称，然后按回车键确认其他提示来验证这一点。这是本章前面执行过的相同更改，应该会产生相同的结果，如下所示：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Validating client data
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证客户端数据
- en: Web services cannot trust the data that is received from clients and are subject
    to the same kinds of issues that affect HTML forms. Malicious users can craft
    HTTP requests or alter the client-side JavaScript code to send data values that
    will cause errors or create unexpected results, similar to the problems with form
    data described in *Chapter 11*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务无法信任从客户端接收到的数据，并且会面临与影响HTML表单相同类型的问题。恶意用户可以构造HTTP请求或修改客户端JavaScript代码，发送会导致错误或产生意外结果的数据值，类似于*第11章*中描述的表单数据问题。
- en: The difficulty with web services is validating data in a way that doesn’t undermine
    the code clarity that came from isolating the statements that handle HTTP requests.
    If every web service method validates its data directly, the result is a mess
    of duplicated code statements that bury the web service functionality and are
    difficult to read and entertain. The best approach to validation is to describe
    validation requirements and apply them outside of the web service.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务的困难在于以不损害通过隔离处理HTTP请求的语句所获得的代码清晰性的方式验证数据。如果每个网络服务方法都直接验证其数据，结果将是一堆重复的代码语句，这些语句掩盖了网络服务功能，难以阅读和理解。最佳的验证方法是描述验证要求并在网络服务外部应用它们。
- en: Creating the validation infrastructure
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建验证基础设施
- en: Allowing the validation requirements of a web service to be expressed clearly
    and concisely requires infrastructure that hides away the messy implementation
    details.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 允许清晰地简洁地表达网络服务的验证要求需要一种基础设施，它可以隐藏那些杂乱的实现细节。
- en: The starting point is to define the types that describe validation for an entire
    web service, a web service method, and a single validation rule. Add a file named
    `validation_types.ts` to the `src/server/api` folder with the content shown in
    *Listing 14.31*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点是定义描述整个网络服务、网络服务方法和单个验证规则的类型。将名为`validation_types.ts`的文件添加到`src/server/api`文件夹中，内容如*列表14.31*所示。
- en: 'Listing 14.31: The contents of the validation_types.ts file in the src/server/api
    folder'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.31：src/server/api文件夹中validation_types.ts文件的内容
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `WebServiceValidation` type describes the validation requirements for a
    web service. The `keyValidator` property specifies the validation requirements
    for the `ID` values that identify data records, using the `ValidationRule` type.
    A `ValidationRule` can either be an array of test functions that will be applied
    to a value, or an object that additionally specifies whether a value is required
    and a converter that will transform the value into the type expected by the web
    service method.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebServiceValidation`类型描述了网络服务的验证要求。`keyValidator`属性指定了用于标识数据记录的`ID`值的验证要求，使用`ValidationRule`类型。`ValidationRule`可以是应用于值的测试函数数组，或者是一个对象，它还指定了值是否必需以及一个将值转换为网络服务方法期望的类型转换器。'
- en: The other properties defined by the `WebServiceValidation` type correspond to
    the web service methods that consume data. These properties can be assigned a
    `ValidationRequirements` object, which can specify the shape of the object expected
    by the web service, and a `ValidationRule` for each of them. The `ValidationError`
    class represents a problem validating the data sent by the client in a request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由`WebServiceValidation`类型定义的其他属性对应于消耗数据的网络服务方法。这些属性可以分配一个`ValidationRequirements`对象，它可以指定网络服务期望的对象形状，并为每个对象指定一个`ValidationRule`。`ValidationError`类表示在请求中验证客户端发送的数据时出现的问题。
- en: The next step is to define functions that will apply the requirements described
    using the types in *Listing 14.31* to validate data. Add a file named `validation_functions.ts`
    to the `src/server/api` folder with the code shown in *Listing 14.32*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义将应用*列表14.31*中使用的类型描述的要求的函数以验证数据。将名为`validation_functions.ts`的文件添加到`src/server/api`文件夹中，内容如*列表14.32*所示。
- en: 'Listing 14.32: The contents of the validation_functions.ts file in the src/server/api
    folder'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.32：src/server/api文件夹中validation_functions.ts文件的内容
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `validate` function accepts a `data` object and a `ValidationRequirements`
    object. Each property specified by the `ValidationRequirements` object is read
    from the `data` object and validated. The result is an object that contains validated
    `data` that can be trusted by the web service. `ValidationError` is thrown if
    a data property doesn’t meet its validation requirements.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: To integrate the validation process as smoothly as possible, I am going to insert
    a validation layer between the HTTP adapter and the web service. The validation
    layer will receive the request and response from the adapter, validate the data,
    and pass it on to the web service. Add a file named `validation_adapter.ts` to
    the `src/server/api` folder with the contents shown in *Listing 14.33*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.33: The validation_adapter.ts file in the src/server/api folder'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `ID` values included in URLs are validated using the `validateIdProperty`
    function, and any additional data is validated using the `validate` function.
    If validation fails, `ValidationError` will be thrown. *Listing 14.34* updates
    the HTTP adapter to catch exceptions thrown when a request is handled and generates
    a `400 Bad Request` response for validation errors and a `500 Internal Server
    Error` response for any other issue.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.34: Handling validation errors in the http_adapter.ts file in the
    src/server/api folder'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that no details of the validation problem are included in the result
    sent to the client. It would be possible to send the client a JSON object that
    describes the validation issues, but in practical terms, clients are rarely able
    to make sensible use of such information. Validation requirements are encountered
    during the development process and are best included in the developer documentation
    so that the client can validate the data received from the user before sending
    it to the web service.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Relying on the web service to provide validation errors that can be presented
    to the user is a problematic process and one that should be avoided, even when
    the client and web service are written by the same team. When you publish a web
    service, you should expect to provide support to the client-side developers as
    they consume the functionality you provide.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Defining validation for the Result API
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complexity of validation is in the infrastructure, which allows the validation
    requirements for a web service to be defined concisely. Add a file named `results_api_validation.ts`
    in the `src/server/api` folder with the contents shown in *Listing 14.35*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.35: The contents of the results_api_validation.ts file in the src/server/api
    folder'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `ResultWebServiceValidation` object defines the `keyValidator`, `store`,
    and `replace` properties, which indicates that the web service requires its `ID`
    values to be validated, as well as the data used by the `store` and `replace`
    methods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidationRule` named `intValidator` describes validation for integer values,
    with a `validation` property that uses the `validator` package to ensure a value
    is an integer and a `converter` function that parses the value to a `number`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`intValidator`的`ValidationRule`描述了整数值的验证，它使用`validation`属性和`validator`包来确保值是整数，以及一个将值解析为`number`的`converter`函数。
- en: The `intValidator` is used on its own as the key validator and in the `ValidationRequirements`
    object named `partialResultValidator`, which validates the `name`, `age`, and
    `years` properties that are required by the `store` method. The validation requirements
    for the `replace` method extend those used by the `store` method by adding a `nextage`
    property.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`intValidator`作为主验证器单独使用，并在名为`partialResultValidator`的`ValidationRequirements`对象中使用，该对象验证`store`方法所需的`name`、`age`和`years`属性。`replace`方法的验证要求通过添加`nextage`属性扩展了`store`方法使用的验证要求。'
- en: This approach to validation allows a web service’s data requirements to be expressed
    separately from the application of those requirements. *Listing 14.36* wraps the
    web service in its validator.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证方法允许将网络服务的数据要求与这些要求的实施分开表达。*列表14.36*将验证器包裹在服务周围。
- en: 'Listing 14.36: Applying validation in the index.ts file in the src/server/api
    folder'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.36：在src/server/api文件夹中的index.ts文件中应用验证
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The final change is a small one, which takes advantage of the type conversion
    performed by the validation system, as shown in *Listing 14.37*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改很小，它利用了验证系统执行的类型转换，如*列表14.37*所示。
- en: 'Listing 14.37: Relying on type conversion in the results_api.ts file in the
    src/server/api folder'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.37：在src/server/api文件夹中的results_api.ts文件中依赖类型转换
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `store` method won’t be called unless the `age` and `years` buttons have
    been converted to `number` values, which means that the `store` method doesn’t
    need to perform its own conversions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`age`和`years`按钮已转换为`number`值时，才会调用`store`方法，这意味着`store`方法不需要执行自己的转换。
- en: 'To test validation, select the command-line client’s Get `ID` option and enter
    `ABC` when prompted. The validation check will reject this value, and produce
    a `400 Bad Request` response, like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试验证，选择命令行客户端的获取`ID`选项，并在提示时输入`ABC`。验证检查将拒绝此值，并产生一个`400 Bad Request`响应，如下所示：
- en: '[PRE68]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Select the **Store** option and enter `Joe`, `30`, and `Ten` when prompted.
    The last value fails validation and causes another `400` response.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**存储**选项，并在提示时输入`Joe`、`30`和`Ten`。最后一个值验证失败，导致另一个`400`响应。
- en: Performing model validation
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行模型验证
- en: Not all validation can be done before the request is passed to the web service
    method that will generate a response. One example is PATCH requests, where the
    client can send partial updates that may lead to inconsistent data in the database,
    such as providing a new `years` value without a corresponding `nextage` value,
    so that the calculation result doesn’t make sense.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有验证都可以在将请求传递给将生成响应的网络服务方法之前完成。一个例子是PATCH请求，客户端可以发送可能导致数据库中不一致数据的部分更新，例如提供新的`years`值而没有相应的`nextage`值，这样计算结果就没有意义了。
- en: Validating this kind of update cannot be done until the update has been applied
    to the existing stored data, which means that it must be done by the web service
    method, which is the earliest point in the update process where the changes and
    the stored data are both available. This is often known as *model validation*,
    although there is no consistent terminology.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 验证此类更新必须在更新应用于现有存储数据之后才能进行，这意味着它必须通过网络服务方法来完成，这是更新过程中最早可以同时获得更改和存储数据的位置。这通常被称为*模型验证*，尽管没有一致的术语。
- en: '*Listing 14.38* defines a new data type that combines the existing validation
    with a new rule that applies to the entire data model object.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14.38*定义了一个新的数据类型，它将现有的验证与适用于整个数据模型对象的新规则相结合。'
- en: 'Listing 14.38: Adding a type in the validation_types.ts file in the src/server/api
    folder'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.38：在src/server/api文件夹中的validation_types.ts文件中添加一个类型
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*Listing 14.39* uses the `ModelValidation` type in a new function that can
    be used to validate an object before it is stored.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14.39*在一个新函数中使用`ModelValidation`类型，该函数可以在对象存储之前对其进行验证。'
- en: 'Listing 14.39: Adding a function in the validation_functions.ts file in the
    src/server/api folder'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.39：在src/server/api文件夹中的validation_functions.ts文件中添加一个函数
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `validateModel` function applies the rules for each property and then applies
    the model-wide rule. The property rules may perform type conversions and so the
    result from the property checks is used as the input for the model-wide validation.
    *Listing 14.40* defines the validation required for a `Result` object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateModel` 函数应用每个属性的规则，然后应用模型级别的规则。属性规则可能执行类型转换，因此属性检查的结果用作模型级验证的输入。*列表
    14.40* 定义了 `Result` 对象所需的验证。'
- en: 'Listing 14.40: Defining a model validator in the result_api_validation.ts file
    in the src/server/api folder'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.40：在 src/server/api 文件夹中的 result_api_validation.ts 文件中定义模型验证器
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `propertyRules` property uses the validation rules created for earlier examples.
    The `modelRule` property checks to see that the `nextage` value is the sum of
    the `age` and `years` properties.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyRules` 属性使用为早期示例创建的验证规则。`modelRule` 属性检查 `nextage` 值是否是 `age` 和 `years`
    属性的总和。'
- en: A small change is required to the rule used to validate integers. The `isInt`
    method provided by the `validator` package only operates on string values, but
    a partial update may combine the `string` values received from the HTTP request
    with `number` values read from the database. To avoid exceptions, the value being
    checked is always converted to a string.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改用于验证整数的规则。由 `validator` 包提供的 `isInt` 方法仅对字符串值操作，但部分更新可能将来自 HTTP 请求的 `string`
    值与从数据库中读取的 `number` 值组合。为了避免异常，被检查的值始终转换为字符串。
- en: '*Listing 14.41* updates the web service to use the model validation feature
    for the `replace` and `modify` methods, ensuring that inconsistent data isn’t
    written to the database.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14.41* 更新了网络服务，使其在 `replace` 和 `modify` 方法中使用模型验证功能，确保不一致的数据不会被写入数据库。'
- en: 'Listing 14.41: Validating data in the results_api.ts file in the src/server/api
    folder'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.41：在 src/server/api 文件夹中的 results_api.ts 文件中验证数据
- en: '[PRE72]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The validation can be performed in the `replace` method, which allows replacements
    and updates to be validated consistently.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 验证可以在 `replace` 方法中执行，这允许进行替换和更新的一致性验证。
- en: 'Select the command-line client’s `Replace` option and enter `1`, `Joe`, `20`,
    `10`, and `25` when prompted. This is invalid data because the `nextage` value
    should be `30`, so the validation process fails and a `400 Bad Request` response
    is produced, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 选择命令行客户端的 `Replace` 选项，并在提示时输入 `1`、`Joe`、`20`、`10` 和 `25`。这是无效数据，因为 `nextage`
    的值应该是 `30`，所以验证过程失败，并产生一个 `400 Bad Request` 响应，如下所示：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The combination of request and model validation ensures that the web service
    only receives and stores valid data, while the abstracted HTTP and validation
    features help simplify the web service implementation so that it is easier to
    understand and maintain.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和模型验证的结合确保了网络服务只接收和存储有效数据，而抽象的 HTTP 和验证功能有助于简化网络服务的实现，使其更容易理解和维护。
- en: Using a package for web services
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包进行网络服务
- en: There are excellent packages available for creating web services, although the
    lack of standardization means that you have to find one that suits your preferences
    about how web services should function, which may be different from the approach
    I have taken in this chapter. I like the Feathers package ([https://feathersjs.com](https://feathersjs.com)),
    which works similarly to the custom code in this chapter and has good integrations
    with popular databases and other packages, including Express.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有优秀的包可用于创建网络服务，但由于缺乏标准化，您必须找到一个适合您对网络服务如何运行的偏好的包，这可能与本章中采取的方法不同。我喜欢 Feathers
    包 ([https://feathersjs.com](https://feathersjs.com))，它的工作方式与本章中的自定义代码类似，并且与流行的数据库和其他包（包括
    Express）有良好的集成。
- en: But there are plenty of good packages available, and a good tip is to search
    for microservices, which has become such a hot term that some packages position
    themselves as being part of the microservices ecosystem.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 但有许多优秀的包可用，一个好的建议是搜索微服务，这已经成为一个热门术语，一些包将自己定位为微服务生态系统的组成部分。
- en: Run the commands shown in *Listing 14.42* in the `part2app` folder to install
    the Feathers package and the integrations with Express.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `part2app` 文件夹中运行 *列表 14.42* 中显示的命令以安装 Feathers 包及其与 Express 的集成。
- en: 'Listing 14.42: Installing packages'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.42：安装包
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The Feathers packages contain TypeScript type declarations, but they override
    the declarations for the Express package. A change to the compiler configuration
    is required to work around this issue, as shown in *Listing 14.43*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers包包含TypeScript类型声明，但它们会覆盖Express包的声明。需要更改编译器配置以解决这个问题，如*列表14.43*所示。
- en: 'Listing 14.43: Changing the compiler configuration in the tsconfig.json file
    in the part2app folder'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.43：在`part2app`文件夹中的`tsconfig.json`文件中更改编译器配置
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The Feathers integration with Express works by extending the existing API, and
    the type declarations that the package provides are different from those provided
    by the `@types/express` package.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers与Express的集成通过扩展现有API来实现，该包提供的类型声明与`@types/express`包提供的不同。
- en: Creating an adaptor for web services
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于Web服务的适配器
- en: The Feathers package describes web services using a series of methods, similar
    to the interface used by the custom code earlier in the chapter. There are some
    small differences, but the two approaches are similar enough that a simple adapter
    will allow the custom HTTP-handling code to be replaced with the Feathers package,
    without needing to make changes to the web service. Add a file named `feathers_adapter.ts`
    to the `src/server/api` folder with the contents shown in *Listing 14.44*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers包使用一系列方法描述Web服务，类似于本章前面自定义代码使用的接口。有一些小的差异，但两种方法足够相似，以至于一个简单的适配器可以将自定义HTTP处理代码替换为Feathers包，而无需对Web服务进行更改。在`src/server/api`文件夹中添加一个名为`feathers_adapter.ts`的文件，其内容如*列表14.44*所示。
- en: 'Listing 14.44: The contents of the feathers_adapter.ts file in the src/server/api
    folder'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.44：`src/server/api`文件夹中`feathers_adapter.ts`文件的内容
- en: '[PRE76]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The Feathers API provides types that represent `ID` values, request bodies,
    and query parameters, but there are only so many ways an HTTP request can be represented,
    so it is a simple process to bridge between the Feathers package and the custom
    code. Later examples will use the Feathers API directly, but this approach demonstrates
    how easy it is to adapt existing code to work with third-party packages.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers API提供表示`ID`值、请求体和查询参数的类型，但由于HTTP请求可以表示的方式有限，因此将Feathers包和自定义代码之间的桥梁建立起来是一个简单的过程。后续示例将直接使用Feathers
    API，但这种方法展示了将现有代码适配到第三方包是多么容易。
- en: The Feathers integration with Express assumes that Feathers will extend the
    Express API to add features. *Listing 14.45* uses the Feathers functionality to
    create a web service without changing the rest of the application.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers与Express的集成假设Feathers将扩展Express API以添加功能。*列表14.45*使用Feathers功能创建一个Web服务，而无需更改应用程序的其他部分。
- en: 'Listing 14.45: Using Feathers in the index.ts file in the src/server/api folder'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.45：在`src/server/api`文件夹中的`index.ts`文件中使用Feathers
- en: '[PRE77]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The enhanced version of Express is created by this statement:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Express的增强版本是通过以下声明创建的：
- en: '[PRE78]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This incantation enables Feathers and configures it to support RESTful queries.
    Feathers can be used in different ways, and RESTful requests are only one of the
    ways that clients can communicate with Feathers’ server-side components.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个咒语使Feathers生效，并配置它以支持RESTful查询。Feathers可以用不同的方式使用，而RESTful请求只是客户端与Feathers服务器端组件通信的方式之一。
- en: 'Feathers supports *hooks*, which allow functions to be executed at key moments
    in the request life cycle. Hooks are a useful feature and can be used for tasks
    including validation and error handling. Validation is handled by the custom code
    in this example, but this statement defines a hook that will be invoked when an
    exception is thrown while handling a request:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers支持*钩子*，允许在请求生命周期的关键时刻执行函数。钩子是一个有用的功能，可以用于包括验证和错误处理在内的任务。在这个例子中，验证由自定义代码处理，但这个声明定义了一个在处理请求时抛出异常时将被调用的钩子：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The custom code throws `ValidationError` when validation fails, which Feathers
    handles by sending a 500 response. Hooks receives a context object that provides
    details of the request and its outcome, and this statement changes the response
    status code if `ValidationError` has occurred. There is no change in the way the
    web service works because it uses the same custom code-handling requests. But,
    having seen how RESTful web services operate and how they can be created, moving
    to a package such as Feathers allows the same features to be utilized without
    the need for custom code.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证失败时，自定义代码会抛出`ValidationError`，Feathers通过发送500响应来处理这种情况。钩子接收一个上下文对象，该对象提供了请求及其结果的详细信息，并且如果发生`ValidationError`，此语句会更改响应状态码。由于它使用相同的自定义代码来处理请求，因此网络服务的工作方式没有变化。但是，通过了解RESTful网络服务的工作方式和创建方式，转向如Feathers这样的包允许利用相同的功能，而无需编写自定义代码。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I demonstrated how the HTTP features provided by Node.js and
    enhanced by the Express package, can be used to create a RESTful web service.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了如何使用Node.js提供的HTTP功能，并通过Express包增强，来创建一个RESTful网络服务。
- en: The HTTP request URL identifies the data and the HTTP method denotes the operation
    that will be performed.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求URL标识数据，HTTP方法表示将要执行的操作。
- en: The JSON format is used by most web services, which has replaced XML as the
    default data format.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数网络服务使用JSON格式，这已经取代了XML成为默认的数据格式。
- en: There is little standardization in the way that web services are implemented,
    although there are some common conventions that are widely used, particularly
    relating to the operations that HTTP methods represent.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现网络服务的方式上，标准化程度较低，尽管有一些广泛使用的通用约定，尤其是与HTTP方法所表示的操作相关。
- en: The data received by web services must be validated before it can be safely
    used.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全使用之前，网络服务接收到的数据必须经过验证。
- en: Web services are most easily written by separating the implementation from the
    code that handles HTTP requests and performs validation.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将实现与处理HTTP请求和执行验证的代码分离，可以最轻松地编写网络服务。
- en: In the next chapter, I will demonstrate how HTTP requests can be authenticated
    and how the user’s identity can be used for authorization.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将展示如何对HTTP请求进行身份验证以及如何使用用户的身份进行授权。
