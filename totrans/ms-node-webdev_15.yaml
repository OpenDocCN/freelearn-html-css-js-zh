- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how Node.js can be used to create web services that provide
    access to data over HTTP requests, which is a key enabler for **single-page applications**
    (**SPAs**). The chapter begins with a basic web service and then incorporates
    more complex features, such as partial updates and data validation. *Table 14.1*
    puts this chapter in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.1: Putting RESTful web services in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | RESTful web services provide access to data over HTTP requests.
    Instead of sending data embedded in HTML content, the server responds with “raw”
    data, usually in JSON format. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Web services allow clients to perform data operations,
    such as querying or updating data, using HTTP requests. This is most often used
    by JavaScript code executing in the browser, although any type of client can consume
    a web service. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | The HTTP request method/verb is used to denote an operation
    and the request URL identifies the data on which the operations should be performed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | There is no standard way to create
    a web service, which leads to significant variations in how they are designed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Most modern web applications require some form
    of web service to deliver data to client-side JavaScript applications. That said,
    web services are not required for applications that are purely round-trip and
    that do not need to support clients. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 14.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Define a web service | Use the standard request handlers and return JSON
    data instead of HTML. | *9-15* |'
  prefs: []
  type: TYPE_TB
- en: '| Consolidate the code required to create a web service | Separate the code
    that handles HTTP requests so that the data-handling code can be isolated. | *16-18,
    43-45* |'
  prefs: []
  type: TYPE_TB
- en: '| Update data with a web service | Handle `PUT` and `PATCH` requests. | *19-26*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Describe complex data changes | Use the JSON Patch specification. | *27-30*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Validate the data values received by the web service | Perform validation
    before passing the data to the code that processes data. | *31-37* |'
  prefs: []
  type: TYPE_TB
- en: '| Validate the combinations of data received by the web service | Perform model
    validation. | *38-41* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `part2app` project from *Chapter 13*. The examples in
    this chapter are easier to understand with a simple command-line client application
    that sends HTTP requests and displays the responses that are received. To prepare,
    run the commands shown in *Listing 14.1* in the `part2app` folder to install the
    `Inquirer` package ([https://github.com/SBoudrias/Inquirer.js](https://github.com/SBoudrias/Inquirer.js)),
    which provides features for prompting the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all other chapters
    in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.1: Installing a package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create the `src/cmdline` folder and add to it a file named `main.mjs`, with
    the contents shown in *Listing 14.2*. The .`mjs` file extension tells Node.js
    to treat this file as a JavaScript module and allow the use of the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.2: The contents of the main.mjs file in the src/cmdline folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `Inquirer` package to prompt the user to choose an operation
    to perform. The choices presented to the user are obtained from the properties
    of an object, and making a choice executes the function assigned to that property.
    Add a file named `operations.mjs` to the `src/cmdline` folder with the contents
    shown in *Listing 14.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.3: The contents of the operations.mjs file in the src/cmdline folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This file provides the operations that the user can select, with a `Test` operation
    to get started and make sure everything works as it should, and an `Exit` option
    that uses the Node.js `process.exit` method to terminate the process. *Listing
    14.4* adds an entry to the scripts section of the `package.json` file to run the
    command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.4: Adding a script in the package.json file in the part2app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The new entry will execute the `main.mjs` file using Node.js. The `--watch`
    argument puts Node.js into watch mode, where it will restart if changes are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for a web service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for the introduction of a web service, create the `src/server/api`
    folder and add to it a file named `index.ts` with the content shown in *Listing
    14.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.5: The contents of the index.ts file in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This file is just a placeholder for now but will be used to configure Express
    to handle HTTP API requests. The final change is to call the function defined
    in *Listing 14.5* to set up the web service, as shown in *Listing 14.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.6: Configuring Express in the server.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 14.7* in the `part2app` folder to start the
    development tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.7: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Open a second command prompt, navigate to the `part2app` folder, and run the
    command shown in *Listing 14.8* to start the command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.8: Starting the command-line client'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The features provided by the `Inquirer` package present a single choice, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Use the arrow keys to move up and down the list of choices. Selecting the `Test`
    operation displays a test message, and selecting `Exit` terminates the process.
    Node.js is running in watch mode, which means that it will start the command-line
    client again if a change is detected. Press *Ctrl + C* if you want to stop the
    client entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no definitive agreement about what a web service is, no single standard
    to follow, and no set of widely adopted patterns. The opposite is true: there
    is an endless multitude of opinions, countless patterns, and an endless internet
    shouting match over the “correct” way to deliver data to clients.'
  prefs: []
  type: TYPE_NORMAL
- en: The chaos and noise surrounding web services can be overwhelming, and it can
    be difficult to know where to start. However, the lack of standardization can
    be liberating because it means that a project can focus on delivering just the
    functionality that clients require, without any of the boilerplate or overheads
    that standardization can sometimes bring.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are just data access APIs that are accessed over HTTP. A RESTful
    web service is just a web service that uses aspects of the HTTP requests to determine
    which parts of the API a client wants to use. The term *RESTful* comes from the
    **representational state transfer** (**REST**) pattern, but there has been so
    much variation and adaptation in web services that only the core premise of REST
    is widely used, which is that an API is defined using a combination of HTTP methods
    and URLs. The HTTP method, such as GET or POST, defines the type of operation
    that will be performed, while the URL specifies the data object or objects to
    which the operation will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Projects are free to create web service APIs in any way, but the best web services
    are the ones that are simple and easy to use. As an example, here is a URL that
    might identify data managed by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are no restrictions on how the URL is used to identify data, as long as
    the client and the server both understand the URL format so that data can be unambiguously
    identified. If an application stores data in a database, then a URL typically
    identifies a specific value using a primary key, but that is just a common convention
    and not a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The URL identifies the data, but it is the HTTP request method that specifies
    what should be done with that data. *Table 14.3* describes the HTTP methods that
    are commonly used in web services and the operations they conventionally represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.3: Commonly used HTTP methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | This method is used to retrieve one or more data values |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | This method is used to store a new data value |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | This method is used to replace an existing data value |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | This method is used to update part of an existing data value |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | This method is used to delete a data value |'
  prefs: []
  type: TYPE_TB
- en: A web service presents an API by combining URLs and methods and will typically
    return JSON data. For operations that don’t query for data, an indication of the
    outcome is returned and that can also be JSON data. A basic web service might
    provide the combinations described in *Table 14.4*, which also describes the results
    the web service will produce.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Early web services used XML rather than JSON. JSON became the de facto standard
    because it is simple and easily parsed by JavaScript clients, but you will still
    see the occasional reference to XML, such as the `XMLHttpRequest` objects, that
    browsers provide for sending HTTP requests (although these have been superseded
    by the more modern Fetch API).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.4: A typical web service'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | URL | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| This combination gets the single value with ID `1`, expressed as a JSON representation
    of a `Result` object. If there is no such ID, a 404 response will be returned.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| This combination gets all available data values, expressed as a JSON representation
    of an array of `Result` objects. If there is no data, an empty array will be returned.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| This combination finds all values with a `name` value of `Alice` and returns
    a JSON representation of an array of `Result` objects. An empty array will be
    returned if there is no matching data. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| This combination stores a value and returns a JSON representation of the
    stored data. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This combination deletes the single value with ID `1` and returns a JSON
    object with a `success` property with a `boolean` value that indicates the outcome.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Understanding microservice**s'
  prefs: []
  type: TYPE_NORMAL
- en: Any research on web services will quickly take you into the world of microservices,
    which is why I suggested it as a search term in the previous section. Microservices
    are a way to design applications around business capabilities and that often involves
    web services. A good overview of microservices can be found at [https://microservices.io](https://microservices.io),
    along with details design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: My view of microservices is that they are interesting but should be avoided
    for most projects. The core problem that microservices address is a dysfunctional
    development organization that cannot be managed to provide coordinated software
    releases. This is a problem that many projects face, given that any group of three
    or more developers immediately splits into factions that compete for resources,
    argue over design issues, and blame each other for delays.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices attempt to resolve these problems by having development teams
    work largely in isolation and agreeing only on how different parts of the project
    will be integrated. There are some excellent tools designed to support microservices,
    the most well-known one being Kubernetes, but the tools are incredibly complex,
    and adopting microservices feels like giving up on the complexities of staff management
    to focus on the complexities of software management. In my experience, few HR
    issues have been resolved by increasing the complexity of development tools, so
    I am skeptical that microservices are a practical way to solve complex organizational
    problems. You should form your own view, but my advice is to think carefully before
    adopting microservices and ask yourself whether your colleagues will behave any
    better in a federated development model than they do today.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a first step, *Listing 14.9* creates a web service that implements some of
    the combinations of URL and HTTP methods described in *Table 14.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.9: Creating a basic web service in the index.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The listing shows how easy it is to create an API for clients by repurposing
    the parts of the application created for round-trip requests. This is how most
    web services start, but there are some problems and improvements that can be made,
    as later sections explain. But, to complete the initial process, *Listing 14.10*
    adds operations to the client to consume the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.10: Adding operations in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Node.js supports the Fetch API, which is commonly used by browser-based JavaScript
    code to make HTTP requests. The changes in *Listing 14.10* add a `sendRequest`
    function that sends HTTP requests and displays their results and adds `Get All`
    and `Get Name` operations. The `Get Name` operation uses `Inquirer` to prompt
    for a name, which is then added to the HTTP request query string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command-line client will restart when the changes in *Listing 14.10* are
    detected. Selecting the **Get All** option and pressing *Return* will display
    all of the available data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the `Get Name` operation and press the *Return* key, and you will be
    prompted for a name. Enter `Alice` and press *Return*, and you will see the matching
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you enter a name that doesn’t exist, the web service will respond with a
    404 Not Found response.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data for the web service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason that the web service only supports two of the combinations from *Table
    14.4* is that those are the only operations that can be performed using the repository,
    which was created for the needs of the round-trip application.
  prefs: []
  type: TYPE_NORMAL
- en: There is no single best way to address this issue, and compromises are required.
    Some projects have web service and round-trip requirements that are similar enough
    to share a repository, but these are rare, and trying to force consistency between
    the two can end up compromising one or both parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding GraphQL**'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL ([https://graphql.org](https://graphql.org)) is a different approach
    to providing clients with data. A regular RESTful web service provides a specific
    set of operations that produce the same results for all clients. If a client needs
    additional data in responses, for example, then a developer must modify the web
    service, and then all clients will receive that new data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL still uses HTTP requests, and the data is still expressed as JSON, but
    clients can execute custom queries, which include selecting the data values that
    will be included and filtering data in different ways. This means that clients
    can receive just the data they require, and different clients can receive different
    data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is great, but it is more complex than a regular RESTful web service,
    both in terms of the server-side development and performing client queries, and
    most projects are better suited to conventional RESTful web services, which present
    a fixed set of operations and results to all clients. GraphQL shines in projects
    that have large amounts of data and clients that are going to use that data in
    widely different ways, which the server-side developers cannot anticipate. But,
    for most other projects, GraphQL is too complex, and a conventional web service
    is simpler to create and consume.
  prefs: []
  type: TYPE_NORMAL
- en: One alternative is to create separate repositories for each part of the application,
    which allows each to evolve independently, but inevitably leads to some degree
    of code duplication since some operations are likely to be needed by both round-trip
    and web service clients.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative – and the one used in this chapter – is to create a subclass
    of the original repository and add the missing features. This works when the features
    required by one part of the application are a subset of those required elsewhere,
    which is the case with the example application. *Listing 14.11* defines a new
    interface that describes additional features required for the web service. Further
    methods will be required later, but this is enough for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure where to start, then start by creating a subclass. If you
    find that you need to replace most of the features inherited from the base class,
    then you should split the code into two separate repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.11: Defining a new interface in the repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The new methods allow an individual `Result` object to be requested by its ID,
    and for data to be deleted by specifying an ID. *Listing 14.12* updates the `OrmRepository`
    class to implement the new interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.12: Implementing the interface in the orm_repository.ts file in
    the src/server/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14.13* updates the exports from the `data` module to add the API-specific
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.13: Updating exports in the index.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14.14* uses the new repository interface to add features to the web
    service. This code is difficult to read, but this will be addressed in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.14: Adding features in the index.ts file in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new routes add support for querying by ID, storing new results, and deleting
    existing results. The ability to store new results depends on the ability to query
    by ID because there is a mismatch between the result returned by the `Repository.saveResult`
    method, and the result required by the web service for POST requests. The `saveResult`
    method returns the `Id` of the newly stored object, and so an additional query
    is required to get the `Result` object that has been stored so that it can be
    sent back to the client. *Listing 14.15* adds new operations to the command-line
    client that rely on the new web service features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.15: Adding features in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the command-line client, select the `Get Id` option and enter `3` when
    prompted, which will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The web service will return a 404 Not Found response for `ID`s that don’t exist
    in the database. Select the `Store` option and enter `Drew, 50, and 5`, when prompted
    for the name, age, and years values, and the response will show the new record
    that is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting the `Get All` option will show the new record along with the existing
    data in the database (but bear in mind that the database is reset and reseeded
    every time the server-side application restarts, so don’t make any code changes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the **Delete** option and enter the `ID` of the newly stored item when
    prompted. The result is a JSON object with a deleted property that indicates the
    outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Selecting the **Get All** option will confirm that the data has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding OpenAPI**'
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI specification ([https://www.openapis.org](https://www.openapis.org))
    is a standard for describing web services, which can help client-side developers
    understand how a web service is intended to be used and provides a description
    of the data to which it provides access. There are tools and packages available
    that generate client-side code automatically from an OpenAPI description, and
    some JavaScript packages used to define web services will automatically generate
    OpenAPI documents.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI is a good idea, but it is often used as a substitute for descriptive
    documentation, which tends to leave a gap between the features a web service provides
    and how the developer intended them to be used. If you adopt OpenAPI in your project,
    you must ensure that you supplement the description it produces with notes that
    explain how your web service should be consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the HTTP code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The web service in *Listing 14.15* supports all the combinations of HTTP method
    and URL described in *Table 14.4*, but the code is difficult to understand. The
    web service has three tasks to perform: parsing the HTTP request, performing an
    operation, and preparing the HTTP response. When the same code is responsible
    for all of these tasks, it can be hard to identify the statements that perform
    the operations because they get lost in all the HTTP handling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result also tends to be HTTP centric, by which I mean that most developers
    end up writing code with as few routes as possible, and that further complicates
    the results. You can see this in *Listing 14.14*, where the Express `all` method
    is used to match all requests for a URL path, with the HTTP method being identified
    in the request handler, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I end up writing this kind of code all the time. The code compiles, and the
    web service works, but it is difficult to maintain because different aspects of
    the web service are intertwined.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are more easily written and maintained if the code that handles
    the HTTP requests is extracted into an adapter, with the added benefit that web
    services that require the same set of HTTP methods and URL formats can use the
    same adapter code. To describe the functionality of a web service, add a file
    named `http_adapter.ts` to the `src/server/api` folder with the code in *Listing
    14.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.16: The contents of the http_adapter.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `WebService<T>` interface describes a web service that operates on type
    `T`, with methods that describe the operations required to support the basic web
    service features. The `createAdapter<T>` function creates Express routes that
    rely on the `WebService<T>` methods to produce results. To create an implementation
    of the `WebService<T>` interface for `Result` data, add a file named `results_api.ts`
    to the `src/server/api` folder with the content shown in *Listing 14.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'I generally define JavaScript functions using the fat arrow syntax because
    it feels more natural to me. However, I used the `function` keyword in *Listing
    14.16* to define the `createAdapter<T>` function, because the way that TypeScript
    type parameters are expressed on fat arrow functions seems awkward to me. The
    equivalent function signature in fat arrow form is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export const createAdapter = <T>(app: Express, ws: WebService<T>, baseUrl:
    string) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: Putting the type parameter after the equals sign seems jarring to me, although
    you are free to follow either syntax as your preferences dictate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.17: The contents of the results_api.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `ResultWebService` class implements the `WebService<Result>` interface and
    implements the methods by using the repository features. *Listing 14.18* uses
    the new adapter to register the web service, replacing the mixed code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.18: Using the adapter in the index.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There is no change in the behavior of the web service, but removing the code
    that deals with HTTP requests and responses makes the web service easier to understand
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to support updates in web services: replacing data and patching
    data. An HTTP PUT request is sent when the client wants to completely replace
    data, and the request body contains all of the data the web service will need
    for the replacement. An HTTP `PATCH` method is used when the client wants to modify
    data, and the request body contains a description of how that data should be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting updates with PUT requests is simpler to implement but requires the
    client to provide a complete replacement for the stored data. PATCH requests are
    more complex but offer more flexibility and can be more efficient because only
    the changes are sent to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: It can be hard to know which approach to adopt at the start of a new project
    when the types of updates clients will send are unknown. My advice is to start
    by supporting complete updates because they are simpler to implement and move
    to partial updates only if you find that the unchanged data values start to outnumber
    the changed values.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrates both PUT and PATCH requests. To prepare, *Listing
    14.19* adds a new method to the `ApiRepository` interface that will allow data
    to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.19: Adding a method in the repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14.20* implements this method using the Sequelize ORM package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.20: Updating data in the orm_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating the data in the example means changing either the name or calculation
    associated with a result. The implementation of the `update` method performs an
    update in four steps, all of which are performed as a transaction. The first step
    is to read the data that is to be updated from the database using the `id` property
    of the `Result` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a matching entry in the database, the `findOrCreate` method is
    used to locate the `Person` and `Calculation` data that matches the `Result` parameter
    or create new data if there are no matches. The next step is to update the `ID`s
    so the stored data refers to the new `Person` and `Calculation` records and write
    the changes to the database, which is done using the `save` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `save` method is smart enough to detect changes and will only update the
    database for properties whose values have changed. The final step is performed
    after the transaction has been committed and returns the modified data using the
    `getResultById` method.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing data with PUT requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PUT requests are the simplest to implement because the web service simply uses
    the data sent by the client to replace the stored data. *Listing 14.21* extends
    the interface that describes web services to add a new method and extends the
    HTTP wrapper to use the interface method to handle PUT requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Not every web service uses PUT requests for updates. POST requests are often
    used both to store new data and update data, using the URL to differentiate between
    operations, so that the URL used for an update will include a unique `ID` (`/api/results/1`)
    and the URL used to store data will not (`/api/results`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.21: Adding methods in the http_adapter.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `replace` method added to the `WebService<T>` interface accepts an `id`
    and a `data` object. The new route matches requests with the PUT method, extracts
    the `ID` from the URL, and uses the request body for the data. Implementing the
    method in the web service is a matter of receiving the data from the HTTP wrapper
    and passing it on to the repository, as shown in *Listing 14.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.22: Replacing data in the results_api.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The data received from the HTTP wrapper is deconstructed into constant values
    that are combined with the `id` parameter and passed to the repository’s `update`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to add an operation to the command-line client that will send
    the PUT request, as shown in *Listing 14.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.23: Supporting updates in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation is called `Replace` and it prompts for all the values required
    to store data and sends them to the web service using an HTTP `PUT` request. Select
    the new **Replace** option from the command line and enter `1`, `Joe`, `35`, `10`,
    and `45` when prompted. This operation will update the result whose `ID` is `1`
    with a new name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The name is changed but the other values are the same, so the relationship between
    the result and the calculation in the database remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying data with PATCH requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PATCH requests allow a client to ask a web server to apply partial updates,
    without having to send a complete data record. There is no standard way to describe
    partial changes in a PATCH request and any data format can be used, just as long
    as the client and the web service both understand how data is identified and how
    changes are described. To support PATCH requests, *Listing 14.24* adds a new method
    to the web service interface and defines a route that matches PATCH requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.24: Supporting PATCH requests in the http_adapter.ts file in the
    src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The simplest way to support partial updates is to allow the client to provide
    a JSON object that contains only replacement values and omits any property that
    should be left unchanged, as shown in *Listing 14.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.25: Modifying data in the results_api.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The implementation method enumerates the properties defined by the `Result`
    interface and checks to see whether the data received from the request contains
    a replacement value. New values are applied to update the existing data, which
    is then passed to the repository’s `replace` method to be stored. Notice that
    the repository is used in the same way for replacements and updates and that it
    is the job of the web service to prepare the data for storage. *Listing 14.26*
    adds an operation to the command-line client that sends PATCH requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.26: Sending PATCH requests in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This operation prompts for values in the same way as for PUT requests, but the
    JavaScript `Object.fromEntries`, `Object.entries`, and `filter` functions are
    used to exclude any property for which no value is provided so that a partial
    update is sent to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the new **Modify** option from the command line and enter `2` for the
    `ID` and `Clara` for the name, and then press *Return* for the other prompts.
    This operation will update the result whose `ID` is `2` with a new name, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The client sent only a new name value to the web service and didn’t need to
    send values for the properties whose values were not changed.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON Patch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The approach used in the previous section is useful when the only updates sent
    by the client are changes to existing data values. Many projects fall into this
    category, and it is a useful technique when the data becomes too complex for replacement
    requests and the only changes are providing updated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON Patch format ([https://jsonpatch.com](https://jsonpatch.com)) can
    be used for more complex updates. A JSON Patch document contains a series of operations
    that are applied to a JSON document. A JSON Patch document to update the value
    of the `name` property, for example, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: JSON Patch documents contain an array of JSON objects, with `op` and `path`
    properties that describe the operation to be performed and the target for that
    operation. Additional properties are required for some operations, such as the
    `value` property used to specify the new value for the replace operation. *Table
    14.5* describes the JSON Patch operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.5: The JSON Patch operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| This operation adds a property to the JSON document, with the name and value
    specified by the `path` and `value` properties. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '| This operation removes a property from the JSON document, specified by the
    `path` property. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| This operation changes the property specified by the `path` property using
    the value assigned to the `value` property. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| This operation duplicates a property specified by the `from` property to
    the location specified by the `path` property. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| This operation moves a property specified by the `from` property to the location
    specified by the `path` property. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '| This property checks to see that the JSON document contains a property and
    value specified by the `path` and `value` properties. No other operations will
    be performed if this operation fails. |'
  prefs: []
  type: TYPE_TB
- en: The `path` property is used to identify values in the JSON document using the
    JSON Pointer syntax, which is described at [https://datatracker.ietf.org/doc/html/rfc6901](https://datatracker.ietf.org/doc/html/rfc6901),
    and which can be used to select properties and array elements. The location `/name`,
    for example, denotes a `name` property at the top level of the JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Patch documents can be parsed and applied using custom code, but it is
    easier to use one of the available open-source JavaScript packages. Run the command
    shown in *Listing 14.27* in the `part2app` folder to install the `fast-json-patch`
    package ([https://github.com/Starcounter-Jack/JSON-Patch](https://github.com/Starcounter-Jack/JSON-Patch)),
    which is a popular JSON Patch package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.27: Installing the JSON Patch package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14.28* updates the web service so that the `modify` method will treat
    the data it receives as a JSON Patch document and apply it using the `fast-json-patch`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.28: Using JSON Patch in the result_api.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `applyPatch` method is used to process the JSON Patch document to an object.
    The `result` object defines a `newDocument` property that returns the modified
    object, which can be stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP `Content-Type` header is set to `application/json-patch+json` when
    sending a JSON Patch document and this type is not decoded automatically by the
    Express JSON middleware component. *Listing 14.29* configures the JSON middleware
    so that normal JSON payloads and JSON Patch payloads will be decoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.29: Enabling JSON Patch decoding in the server.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The JSON middleware accepts a configuration object whose `type` property can
    be configured with an array of content types to decode. The final step is to create
    a JSON Patch document in the command-line client, as shown in *Listing 14.30*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.30: Using JSON Patch in the operations.mjs file in the src/cmdline
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `fast-json-patch` package is capable of generating a JSON Patch document,
    but it is easier to create patches with custom code than it is to apply them,
    and the modified statement in *Listing 14.30* creates `replace` operations for
    each of the values entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no change in the way the client and web service behave, which you
    can confirm by selecting the `Modify` option from the command line and entering
    `2` for the `ID` and `Clara` for the name, and then pressing return for the other
    prompts. This is the same change performed earlier in the chapter and it should
    produce the same results, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Validating client data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services cannot trust the data that is received from clients and are subject
    to the same kinds of issues that affect HTML forms. Malicious users can craft
    HTTP requests or alter the client-side JavaScript code to send data values that
    will cause errors or create unexpected results, similar to the problems with form
    data described in *Chapter 11*.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty with web services is validating data in a way that doesn’t undermine
    the code clarity that came from isolating the statements that handle HTTP requests.
    If every web service method validates its data directly, the result is a mess
    of duplicated code statements that bury the web service functionality and are
    difficult to read and entertain. The best approach to validation is to describe
    validation requirements and apply them outside of the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the validation infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allowing the validation requirements of a web service to be expressed clearly
    and concisely requires infrastructure that hides away the messy implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point is to define the types that describe validation for an entire
    web service, a web service method, and a single validation rule. Add a file named
    `validation_types.ts` to the `src/server/api` folder with the content shown in
    *Listing 14.31*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.31: The contents of the validation_types.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `WebServiceValidation` type describes the validation requirements for a
    web service. The `keyValidator` property specifies the validation requirements
    for the `ID` values that identify data records, using the `ValidationRule` type.
    A `ValidationRule` can either be an array of test functions that will be applied
    to a value, or an object that additionally specifies whether a value is required
    and a converter that will transform the value into the type expected by the web
    service method.
  prefs: []
  type: TYPE_NORMAL
- en: The other properties defined by the `WebServiceValidation` type correspond to
    the web service methods that consume data. These properties can be assigned a
    `ValidationRequirements` object, which can specify the shape of the object expected
    by the web service, and a `ValidationRule` for each of them. The `ValidationError`
    class represents a problem validating the data sent by the client in a request.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to define functions that will apply the requirements described
    using the types in *Listing 14.31* to validate data. Add a file named `validation_functions.ts`
    to the `src/server/api` folder with the code shown in *Listing 14.32*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.32: The contents of the validation_functions.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `validate` function accepts a `data` object and a `ValidationRequirements`
    object. Each property specified by the `ValidationRequirements` object is read
    from the `data` object and validated. The result is an object that contains validated
    `data` that can be trusted by the web service. `ValidationError` is thrown if
    a data property doesn’t meet its validation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate the validation process as smoothly as possible, I am going to insert
    a validation layer between the HTTP adapter and the web service. The validation
    layer will receive the request and response from the adapter, validate the data,
    and pass it on to the web service. Add a file named `validation_adapter.ts` to
    the `src/server/api` folder with the contents shown in *Listing 14.33*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.33: The validation_adapter.ts file in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `ID` values included in URLs are validated using the `validateIdProperty`
    function, and any additional data is validated using the `validate` function.
    If validation fails, `ValidationError` will be thrown. *Listing 14.34* updates
    the HTTP adapter to catch exceptions thrown when a request is handled and generates
    a `400 Bad Request` response for validation errors and a `500 Internal Server
    Error` response for any other issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.34: Handling validation errors in the http_adapter.ts file in the
    src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that no details of the validation problem are included in the result
    sent to the client. It would be possible to send the client a JSON object that
    describes the validation issues, but in practical terms, clients are rarely able
    to make sensible use of such information. Validation requirements are encountered
    during the development process and are best included in the developer documentation
    so that the client can validate the data received from the user before sending
    it to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on the web service to provide validation errors that can be presented
    to the user is a problematic process and one that should be avoided, even when
    the client and web service are written by the same team. When you publish a web
    service, you should expect to provide support to the client-side developers as
    they consume the functionality you provide.
  prefs: []
  type: TYPE_NORMAL
- en: Defining validation for the Result API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complexity of validation is in the infrastructure, which allows the validation
    requirements for a web service to be defined concisely. Add a file named `results_api_validation.ts`
    in the `src/server/api` folder with the contents shown in *Listing 14.35*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.35: The contents of the results_api_validation.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `ResultWebServiceValidation` object defines the `keyValidator`, `store`,
    and `replace` properties, which indicates that the web service requires its `ID`
    values to be validated, as well as the data used by the `store` and `replace`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidationRule` named `intValidator` describes validation for integer values,
    with a `validation` property that uses the `validator` package to ensure a value
    is an integer and a `converter` function that parses the value to a `number`.
  prefs: []
  type: TYPE_NORMAL
- en: The `intValidator` is used on its own as the key validator and in the `ValidationRequirements`
    object named `partialResultValidator`, which validates the `name`, `age`, and
    `years` properties that are required by the `store` method. The validation requirements
    for the `replace` method extend those used by the `store` method by adding a `nextage`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to validation allows a web service’s data requirements to be expressed
    separately from the application of those requirements. *Listing 14.36* wraps the
    web service in its validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.36: Applying validation in the index.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The final change is a small one, which takes advantage of the type conversion
    performed by the validation system, as shown in *Listing 14.37*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.37: Relying on type conversion in the results_api.ts file in the
    src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `store` method won’t be called unless the `age` and `years` buttons have
    been converted to `number` values, which means that the `store` method doesn’t
    need to perform its own conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test validation, select the command-line client’s Get `ID` option and enter
    `ABC` when prompted. The validation check will reject this value, and produce
    a `400 Bad Request` response, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Select the **Store** option and enter `Joe`, `30`, and `Ten` when prompted.
    The last value fails validation and causes another `400` response.
  prefs: []
  type: TYPE_NORMAL
- en: Performing model validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all validation can be done before the request is passed to the web service
    method that will generate a response. One example is PATCH requests, where the
    client can send partial updates that may lead to inconsistent data in the database,
    such as providing a new `years` value without a corresponding `nextage` value,
    so that the calculation result doesn’t make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Validating this kind of update cannot be done until the update has been applied
    to the existing stored data, which means that it must be done by the web service
    method, which is the earliest point in the update process where the changes and
    the stored data are both available. This is often known as *model validation*,
    although there is no consistent terminology.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14.38* defines a new data type that combines the existing validation
    with a new rule that applies to the entire data model object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.38: Adding a type in the validation_types.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14.39* uses the `ModelValidation` type in a new function that can
    be used to validate an object before it is stored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.39: Adding a function in the validation_functions.ts file in the
    src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `validateModel` function applies the rules for each property and then applies
    the model-wide rule. The property rules may perform type conversions and so the
    result from the property checks is used as the input for the model-wide validation.
    *Listing 14.40* defines the validation required for a `Result` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.40: Defining a model validator in the result_api_validation.ts file
    in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `propertyRules` property uses the validation rules created for earlier examples.
    The `modelRule` property checks to see that the `nextage` value is the sum of
    the `age` and `years` properties.
  prefs: []
  type: TYPE_NORMAL
- en: A small change is required to the rule used to validate integers. The `isInt`
    method provided by the `validator` package only operates on string values, but
    a partial update may combine the `string` values received from the HTTP request
    with `number` values read from the database. To avoid exceptions, the value being
    checked is always converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14.41* updates the web service to use the model validation feature
    for the `replace` and `modify` methods, ensuring that inconsistent data isn’t
    written to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.41: Validating data in the results_api.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The validation can be performed in the `replace` method, which allows replacements
    and updates to be validated consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the command-line client’s `Replace` option and enter `1`, `Joe`, `20`,
    `10`, and `25` when prompted. This is invalid data because the `nextage` value
    should be `30`, so the validation process fails and a `400 Bad Request` response
    is produced, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The combination of request and model validation ensures that the web service
    only receives and stores valid data, while the abstracted HTTP and validation
    features help simplify the web service implementation so that it is easier to
    understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package for web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are excellent packages available for creating web services, although the
    lack of standardization means that you have to find one that suits your preferences
    about how web services should function, which may be different from the approach
    I have taken in this chapter. I like the Feathers package ([https://feathersjs.com](https://feathersjs.com)),
    which works similarly to the custom code in this chapter and has good integrations
    with popular databases and other packages, including Express.
  prefs: []
  type: TYPE_NORMAL
- en: But there are plenty of good packages available, and a good tip is to search
    for microservices, which has become such a hot term that some packages position
    themselves as being part of the microservices ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Run the commands shown in *Listing 14.42* in the `part2app` folder to install
    the Feathers package and the integrations with Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.42: Installing packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The Feathers packages contain TypeScript type declarations, but they override
    the declarations for the Express package. A change to the compiler configuration
    is required to work around this issue, as shown in *Listing 14.43*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.43: Changing the compiler configuration in the tsconfig.json file
    in the part2app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The Feathers integration with Express works by extending the existing API, and
    the type declarations that the package provides are different from those provided
    by the `@types/express` package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adaptor for web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Feathers package describes web services using a series of methods, similar
    to the interface used by the custom code earlier in the chapter. There are some
    small differences, but the two approaches are similar enough that a simple adapter
    will allow the custom HTTP-handling code to be replaced with the Feathers package,
    without needing to make changes to the web service. Add a file named `feathers_adapter.ts`
    to the `src/server/api` folder with the contents shown in *Listing 14.44*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.44: The contents of the feathers_adapter.ts file in the src/server/api
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The Feathers API provides types that represent `ID` values, request bodies,
    and query parameters, but there are only so many ways an HTTP request can be represented,
    so it is a simple process to bridge between the Feathers package and the custom
    code. Later examples will use the Feathers API directly, but this approach demonstrates
    how easy it is to adapt existing code to work with third-party packages.
  prefs: []
  type: TYPE_NORMAL
- en: The Feathers integration with Express assumes that Feathers will extend the
    Express API to add features. *Listing 14.45* uses the Feathers functionality to
    create a web service without changing the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 14.45: Using Feathers in the index.ts file in the src/server/api folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The enhanced version of Express is created by this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This incantation enables Feathers and configures it to support RESTful queries.
    Feathers can be used in different ways, and RESTful requests are only one of the
    ways that clients can communicate with Feathers’ server-side components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feathers supports *hooks*, which allow functions to be executed at key moments
    in the request life cycle. Hooks are a useful feature and can be used for tasks
    including validation and error handling. Validation is handled by the custom code
    in this example, but this statement defines a hook that will be invoked when an
    exception is thrown while handling a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The custom code throws `ValidationError` when validation fails, which Feathers
    handles by sending a 500 response. Hooks receives a context object that provides
    details of the request and its outcome, and this statement changes the response
    status code if `ValidationError` has occurred. There is no change in the way the
    web service works because it uses the same custom code-handling requests. But,
    having seen how RESTful web services operate and how they can be created, moving
    to a package such as Feathers allows the same features to be utilized without
    the need for custom code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I demonstrated how the HTTP features provided by Node.js and
    enhanced by the Express package, can be used to create a RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request URL identifies the data and the HTTP method denotes the operation
    that will be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON format is used by most web services, which has replaced XML as the
    default data format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is little standardization in the way that web services are implemented,
    although there are some common conventions that are widely used, particularly
    relating to the operations that HTTP methods represent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data received by web services must be validated before it can be safely
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services are most easily written by separating the implementation from the
    code that handles HTTP requests and performs validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will demonstrate how HTTP requests can be authenticated
    and how the user’s identity can be used for authorization.
  prefs: []
  type: TYPE_NORMAL
