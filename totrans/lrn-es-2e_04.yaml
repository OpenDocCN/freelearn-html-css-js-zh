- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of all chapters in this book, this is my favorite, because I've faced the
    consequences of bad asynchronous programming in the past, with callbacks on event
    listeners, HTTP requests, and basically everything that requires latency.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has evolved from all these cluttered, unreadable, unmaintainable
    programming practices and that's what we're going to learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, let's learn what an asynchronous program is. You can think of an asynchronous
    program as a program consisting of two lines of code, say L1 and L2\. Now, we
    all know that in a given file, the code always executes from top to bottom. Also,
    it is intuitive such that the code will wait for each line to complete before
    executing the next line.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of asynchronous programming, the code will execute L1, but it will
    not block L2 till L1 is completed. You can think of it as a kind of *non-blocking*
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript execution model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difficulties faced while writing asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are promises?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and working with promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How async/await differs from promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced asynchronous programming with async/await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript execution model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript code is executed in a single thread, that is, two pieces of a script
    cannot run at the same time. Each website opened in the browser gets a single
    thread for downloading, parsing, and executing the website, called the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The main thread also maintains a queue, which has asynchronous tasks queued
    to be executed one by one. These queued tasks can be event handlers, callbacks,
    or any other kind of task. New tasks are added to the queue as AJAX requests/responses
    happen, events occur, timers are registered, and more. One long-running queue
    task can stop the execution of all other queue tasks and the main script. The
    main thread executes the tasks in this queue whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 introduced web workers, which are actual threads running parallel to the
    main thread. When a web worker finishes executing or needs to notify the main
    thread, it simply adds a new event item to the queue. We'll discuss web workers
    separately in Chapter 9, *JavaScript on the Web*.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript follows an *event loop-based* model in how it works. This is very
    different from languages such as Java. Although modern JavaScript compilers implement
    a very complex and heavily optimized version of the event loop model, we can still
    basically understand how the event loop works.
  prefs: []
  type: TYPE_NORMAL
- en: The call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a single-threaded language. That means it can have one call stack
    at a given time (take one thread = one call stack). Furthermore, it implies that
    JavaScript cannot do more than two things at a time. Or can it?
  prefs: []
  type: TYPE_NORMAL
- en: When you call a function, you step inside that function. This function is added
    to the call stack. When the function returns a value, the function is popped from
    the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, consider `$.syncHTTP` as a predefined method that
    performs **synchronous** HTTP requests, that is, it'll block the code until completed.
    Let's assume every request takes ~500 ms to complete. Thus, if all these requests
    fire on clicking, say, a button, JavaScript immediately blocks the browser from
    doing anything for two seconds! That kills the user experience by a factor of
    100!
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the call stack will consist of the first request, then after 500ms
    it'll remove that from the call stack, go to the second request, add that to the
    call stack, wait for 500ms for the response to receive, remove that from the call
    stack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, something strange happens when we make use of an asynchronous function
    such as `setTimeout()`.Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, as you expect, we'll first get `Start` printed because the call stack
    adds `console.log` to the stack, executes it, and removes it from the stack. Then
    the JavaScript comes to `setTimeout()`, adds it to the call stack, magically removes
    it without doing anything (more on this later), comes to the final `console.log`,
    adds it to the call stack, executes it to show `End`, and removes it from the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, magically, after 1 second, another `console.log` appears on the call
    stack, gets executed to print `Middle`, and then gets removed from the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this magic.
  prefs: []
  type: TYPE_NORMAL
- en: Stack, queue, and Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what happened when we called `setTimeout()` in the previous code? Where did
    it magically disappear from the call stack, making room for the next function
    execution?
  prefs: []
  type: TYPE_NORMAL
- en: Well, `setTimeout()` is a web API provided by each browser individually. When
    you call setTimeout, the call stack sends the `setTimeout()` function call to
    the Web API, which then keeps track of the timer (in our case) till it's complete.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Web API realizes the timer is complete, it does not immediately push
    the contents back to the stack. It pushes a callback of the  `setTimeout()` function
    to something known as a queue**.** A Queue, as the name implies, could be a queue
    of functions to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: This is when the event loop comes into play. The event loop is a simple little
    tool that looks at the stack and queue all the time and sees if the stack is empty;
    if the queue has something it takes it from the queue and pushes it to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: So essentially, once you're out of the call stack (async function), your function
    has to wait for the call stack to get emptied before it gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based upon the previous line, guess the output of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to think about this. When you''re ready, see the answer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now the reason for this is, when you call `setTimeout()`, it is cleared off
    from the call stack and the next function is called. The Web API finds that the
    timer for `setTimeout()` is over and pushes it to a queue. The event loop waits
    for the final `console.log` statement to finish before pushing the callback function
    of `setTimeout()` to the stack. And thus we get the output shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35452ed8-c8c9-4066-b0c9-026711589635.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although modern JavaScript brings promises and ES8 brings in async/await (which
    we'll see soon), still, there will be times when you'll encounter old APIs using
    callback mechanism/event-based mechanisms for their asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the working of older asynchronous coding practices.
    This is because you cannot convert a callback-based asynchronous code piece to
    shining promises/async-await-based code without actually understanding how it
    works!
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, earlier, natively supported two patterns for writing asynchronous
    code, that is, the event pattern and the callback pattern. While writing asynchronous
    code, we usually start an asynchronous operation and register the event handlers
    or pass the callbacks, which will be executed once the operation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers or callbacks are used, depending on how the specific asynchronous
    API is designed. An API that is designed for an event pattern can be wrapped with
    some custom code to create the callback pattern for the API, and vice-versa. For
    example, AJAX is designed for the event pattern, but jQuery AJAX exposes it as
    a callback pattern. Let's consider some examples of writing asynchronous code
    involving events and callbacks and their difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code involving events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For asynchronous JavaScript APIs involving events, you need to register the
    success and error event handlers that will be executed depending on whether the
    operation was a success or failure respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while making an AJAX request, we register the event handlers that
    will be executed depending on whether the AJAX request was made successfully or
    not. Consider this code snippet, which makes an AJAX request and logs the retrieved
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assume the `data.json` file to have this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` method of the `XMLHttpRequest()` object is executed asynchronously,
    and retrieves the `data.json` file and calls the load or error event handler depending
    on whether the request was made successfully or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is absolutely no issue with how this AJAX works, but the issue is how
    we write the code involving events. Here are the issues that we faced while writing
    the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We had to add an exception handler for every block of code that will be executed
    asynchronously. We can't just wrap the whole code using a single `try` and `catch`
    statement. This makes it difficult to catch the exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If another part of the program wants to know if the asynchronous operation
    is finished, pending, or being executed then we have to maintain custom variables
    for that purpose. So we can say it is difficult to find the state of an asynchronous
    operation. This code can get even more complicated and harder to read if you are
    nesting multiple AJAX or any other asynchronous operations. For example, after
    displaying the data, you may want to ask the user to verify if the data is correct
    or not, and then send the Boolean value back to the server. Here is the code example
    to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous code involving callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For asynchronous JavaScript APIs involving callbacks, you need to pass success
    and error callbacks, which will be called depending on whether the operation was
    a success or failure respectively. For example, while making an AJAX request using
    jQuery, we need to pass the callbacks, which will be executed depending on whether
    the AJAX request was made successfully or not. Consider this code snippet that
    makes an AJAX request using jQuery and logs the retrieved information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Even here, there is absolutely no issue with how this jQuery AJAX works, but
    the issue is how we write the code involving callbacks. Here are the issues that
    we faced while writing the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to catch the exceptions, as we have to use multiple `try` and
    `catch` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to maintain the state of the asynchronous operation. This code
    will get even more complicated if we nest multiple jQuery AJAX or any other asynchronous
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises and async programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript now has a new native pattern for writing asynchronous code called
    the **Promise** pattern. This new pattern removes the common code issues that
    the event and callback pattern had. It also makes the code look more like synchronous
    code. A promise (or a `Promise` object) represents an asynchronous operation.
    Existing asynchronous JavaScript APIs are usually wrapped with promises, and the
    new JavaScript APIs are purely implemented using promises. Promises are new in
    JavaScript but are already present in many other programming languages. Programming
    languages, such as C# 5, C++ 11, Swift, Scala, and more are some examples that
    support promises.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to use promises.
  prefs: []
  type: TYPE_NORMAL
- en: Promise states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A promise is always in one of these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fulfilled:** If the resolve callback is invoked with a non-promise object
    as the argument or no argument, then we say that the promise is fulfilled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected:** If the rejecting callback is invoked or an exception occurs in
    the executor scope, then we say that the promise is rejected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pending:** If the resolve or reject callback is yet to be invoked, then we
    say that the promise is pending'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settled:** A promise is said to be settled if it''s either fulfilled or rejected,
    but not pending'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a promise is fulfilled or rejected, it cannot be transitioned back. An
    attempt to transition it will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Promises versus callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you wanted to perform three AJAX requests one after another. Here''s
    a dummy implementation of that in callback-style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see how quickly you can enter into something known as **callback-hell**.
    Multiple nesting makes code not only unreadable but also difficult to maintain.
    Furthermore, if you start processing data after every call, and the next call
    is based on a previous call's response data, the complexity of the code will be
    unmatchable.
  prefs: []
  type: TYPE_NORMAL
- en: Callback-hell refers to multiple asynchronous functions nested inside each other's
    callback functions. This makes code harder to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Promises can be used to flatten this code. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see the code complexity is suddenly reduced and the code looks much
    cleaner and readable. Let's first see how `ajaxCallPromise` would've been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Please read the following explanation for more clarity of preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Promise constructor and (resolve, reject) methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert an existing *callback type* function to `Promise`, we have to use
    the `Promise` constructor. In the preceding example, `ajaxCallPromise` returns
    a `Promise`, which can be either **resolved** or **rejected** by the developer.
    Let''s see how to implement `ajaxCallPromise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Hang on! What just happened there?
  prefs: []
  type: TYPE_NORMAL
- en: First, we returned `Promise` from the `ajaxCallPromise` function. That means
    whatever we do now will be a `Promise`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Promise` accepts a function argument, with the function itself accepting
    two very special arguments, that is, resolve and reject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`resolve` and `reject` are themselves functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When, inside a `Promise` constructor function body, you call `resolve` or `reject`,
    the promise acquires a *resolved* or *rejected* value that is unchangeable later
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then make use of the native callback-based API and check if everything is
    OK. If everything is indeed OK, we resolve the `Promise` with the value being
    the message sent by the server (assuming a JSON response).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there was an error in the response, we reject the promise instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can return a promise in a then call. When you do that, you can flatten the
    code instead of chaining promises again.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if `foo()` and `bar()` both return `Promise`, `then`, instead
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This flattens the code.
  prefs: []
  type: TYPE_NORMAL
- en: The then(onFulfilled, onRejected) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `then()` method of a `Promise` object lets us do a task after a `Promise`
    has been fulfilled or rejected. The task can also be another event-driven or callback-based
    asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `then()` method of a `Promise` object takes two arguments, that is, the
    `onFulfilled` and `onRejected` callbacks. The `onFulfilled` callback is executed
    if the `Promise` object was fulfilled, and the `onRejected` callback is executed
    if the `Promise` was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The `onRejected` callback is also executed if an exception is thrown in the
    scope of the executor. Therefore, it behaves like an exception handler, that is,
    it catches the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onFulfilled` callback takes a parameter, that is, the fulfilment value
    of the promise. Similarly, the `onRejected` callback takes a parameter, that is,
    the reason for rejection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we reject the promise inside the `ajaxCallPromise` definition, the second
    function will execute (`failData` one) instead of the first function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one more example by converting `setTimeout()` from a callback to
    a promise. This is how `setTimeout()` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A promised version will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we resolved the promise without a value. If you do that, it gets resolved
    with a value equal to undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The catch(onRejected) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `catch()` method of a `Promise` object is used instead of the `then()` method
    when we use the `then()` method only to handle errors and exceptions. There is
    nothing special about how the `catch()` method works. It's just that it makes
    the code much easier to read, as the word *catch* makes it more meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The `catch()` method just takes one argument, that is, the `onRejected` callback.
    The `onRejected` callback of the `catch()` method is invoked in the same way as
    the `onRejected` callback of the `then()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `catch()` method always returns a promise. Here is how a new `Promise`
    object is returned by the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no return statement in the `onRejected` callback, then a new fulfilled
    `Promise` is created internally and returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we return a custom `Promise`, then it internally creates and returns a new
    `Promise` object. The new promise object resolves the custom promise object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we return something else other than a custom `Promise` in the `onRejected`
    callback, then a new `Promise` object is created internally and returned. The
    new `Promise` object resolves the returned value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we pass null instead of the `onRejected` callback or omit it, then a callback
    is created internally and used instead. The internally created `onRejected` callback
    returns a rejected `Promise` object. The reason for the rejection of the new `Promise`
    object is the same as the reason for the rejection of a parent `Promise` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Promise` object to which `catch()` is called gets fulfilled, then the
    `catch()` method simply returns a new fulfilled promise object and ignores the
    `onRejected` callback. The fulfillment value of the new `Promise` object is the
    same as the fulfillment value of the parent `Promise`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the `catch()` method, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be rewritten in this way using the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These two code snippets work more or less in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise.resolve(value) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `resolve()` method of the `Promise` object takes a value and returns a `Promise`
    object that resolves the passed value. The `resolve()` method is basically used
    to convert a value to a `Promise` object. It is useful when you find yourself
    with a value that may or may not be a `Promise`, but you want to use it as a `Promise`.
    For example, jQuery promises have different interfaces from ES6 promises. Therefore,
    you can use the `resolve()` method to convert jQuery promises into ES6 promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how to use the `resolve()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.reject(value) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `reject()` method of the `Promise` object takes a value and returns a rejected
    `Promise` object with the passed value as the reason. Unlike the `Promise.resolve()`
    method, the `reject()` method is used for debugging purposes and not for converting
    values into promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how to use the `reject()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.all(iterable) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `all()` method of the `Promise` object takes an iterable object as an argument
    and returns a `Promise` that fulfills when all of the promises in the iterable
    object have been fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful when we want to execute a task after some asynchronous operations
    have finished. Here is a code example that demonstrates how to use the `Promise.all()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the iterable object contains a value that is not a `Promise` object, then
    it's converted to the `Promise` object using the `Promise.resolve()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the passed promises get rejected, then the `Promise.all()` method
    immediately returns a new rejected `Promise` for the same reason as the rejected
    passed `Promise`. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.race(iterable) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `race()` method of the `Promise` object takes an iterable object as the
    argument and returns a `Promise` that fulfills or rejects as soon as one of the
    promises in the iterable object is fulfilled or rejected, with the fulfillment
    value or reason from that `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, the `race()` method is used to race between promises
    and see which one finishes first. Here is a code example that shows how to use
    the `race()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now at this point, I assume you have a basic understanding of how promises work,
    what they are, and how to convert a callback-like API into a promised API. Let's
    take a look at **async/await**, the future of asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: async/await – the future of asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be honest, async/await blows away whatever you read previously about promises.
    But hey! You obviously need to know how promises work in order to know how to
    work with async/await. async/await are built on top of promises; however, once
    you get used to them, there is no going back to promises (unless, again, you need
    to convert a callback type API to async/await (you need to use promises for that).)
  prefs: []
  type: TYPE_NORMAL
- en: 'About async/await:'
  prefs: []
  type: TYPE_NORMAL
- en: It's for asynchronous coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes code look extremely similar to synchronous coding and thus makes it
    extremely powerful and easy on the eyes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is built on top of promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes error handling a cake walk. You can finally use `try` and `catch` with
    asynchronous coding!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES8 introduced async/await and, by the time you're reading this, it will have
    been implemented in all browsers natively (at the time of writing, only IE and
    Opera don't support async/await)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: async/await versus promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although async/await are actually promises under the hood, they help a lot
    by adding a ton of readability to code. On the surface level, I believe a developer
    should be aware of minute differences in the usage of async/await versus promises.
    Here''s a glimpse of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **async/await** | **promises** |'
  prefs: []
  type: TYPE_TB
- en: '| Extremely clean code base | Uglier codebase with nested promises |'
  prefs: []
  type: TYPE_TB
- en: '| Error handling with native `try`-`catch` blocks | Separate `catch()` method
    for error handling |'
  prefs: []
  type: TYPE_TB
- en: '| Syntactic sugar for promises (built on promises) | Native implementation
    in standard |'
  prefs: []
  type: TYPE_TB
- en: '| Introduced in ES8 | Introduced in ES6 |'
  prefs: []
  type: TYPE_TB
- en: The async function and await keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the `await` keyword, we need to have an `async` function. The
    difference between a function and an `async` function is that the `async` function
    is followed by an *async* keyword. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the crux of the thing. You can only use `await` inside an `async` function.
    This is because, when you call an `async` function, it returns a `Promise`. However,
    instead of using then with it, which eventually makes it a promise chain, we use
    the `await` keyword in front of it to kind of pause the execution *(not really)*
    inside the `async` function context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a real example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: OK! First things first. Remember that an async function returns a `Promise`?
    Why didn't we use the `async` keyword with `sendAsyncHTTP`? Why did we return
    a `Promise` from `sendAsyncHTTP`? Why won't the code below work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Carefully take a look at the hint comment line. Since we're using a function
    in `onreadystatechange`, returning inside that function does not return the parent
    function. So essentially, you return `undefined` from the `sendAsyncHTTP` function
    instead of a valid response. Had there been other async functions used with the `await`
    keyword, we could've returned a value without making use of the `new Promise()`
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? Stay with me. If you didn''t really get what happened previously,
    continue reading. You will. Take a look at the next function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Look carefully! We didn't return a `Promise` here by using `return new Promise`.
    Why does this work then? This is because this function actually waits for an `async`
    function using the `await` keyword. See, when the code comes to `Line 1`, it halts
    before executing the next line `(console.log('Got first document'))`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever JavaScript finds await followed by a function that returns a `Promise`,
    it will wait for that promise to either resolve or reject. In our case, `sendAsyncHTTP`
    resolves with the source code of the website, so we get that back in the `documentFile2`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We do a similar thing again but with a slightly different URL this time. And
    once we're done with both, we return  `documentFile2`. Hang on here. Remember
    again, the `async function` returns a `Promise`. That means, whatever value you return
    from an `async` function, it is actually the resolved value of that returned `Promise`.And
    whatever value you `throw` inside the `async` function, it goes as the rejected
    value of that returned `Promise`. This is important!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we called `doSomeTasks()`, and as mentioned it returned a `Promise`.
    Therefore, you can use a then chain with it to just log to the console that everything
    was done. The `res` variable consists of whatever value you returned. The `catch()`
    method will catch any error you throw inside the `async` function.
  prefs: []
  type: TYPE_NORMAL
- en: Making asynchronous code look synchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to convert the following `Promise` code to async/await:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You see? Even with promises, you cannot avoid nesting if you need to make use
    of the first promise's value somewhere down the chain. This is because, if you
    flatten out the promise chain, you eventually lose the previous promise's returned
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready for the answer? Here you go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the code clarity in the latter code? It is remarkable! Try to use
    async/await wherever you can, instead of callbacks or promises.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how JavaScript executes asynchronous code. We learned
    about event loops, and basically how JavaScript manages all asynchronous and multiple
    tasks without using any additional threads. We learned about different patterns
    for writing asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how promises make it easier to read and write asynchronous code, and
    how async/await blows away promises in practice. In the next chapter, we'll take
    a look at how to organize your JavaScript code with a modular programming approach.
  prefs: []
  type: TYPE_NORMAL
