<html><head></head><body>
<div id="_idContainer088">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.2.1">Framework Maintenance</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In our framework development journey, we have reached the point where we can discuss framework maintenance in detail. </span><span class="koboSpan" id="kobo.3.2">So far, we have completed an initial version of the full stack framework in the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">previous chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, the framework maintenance topics will guide you toward future frameworks to develop. </span><span class="koboSpan" id="kobo.5.2">These are the topics related to the framework release process, the continuous development cycles, and, finally, the long-term maintenance of large framework projects. </span><span class="koboSpan" id="kobo.5.3">In more detail about framework maintenance, we shall learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.7.1">Development cycle</span></strong><span class="koboSpan" id="kobo.8.1">: We’ll learn about the concepts and paradigms that help develop formal </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.9.1">feature definitions and figure out how to seek framework user feedback. </span><span class="koboSpan" id="kobo.9.2">First, we shall recap the analysis and design steps of the framework development process. </span><span class="koboSpan" id="kobo.9.3">Then, we’ll move on to formal feature definitions, as well as ways to seek user feedback and keep these users informed about changes in the framework. </span><span class="koboSpan" id="kobo.9.4">Being adept at these concepts will help you keep your framework relevant, user-friendly, </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and competitive.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.11.1">Release process</span></strong><span class="koboSpan" id="kobo.12.1">: Getting accustomed to the release process involves several logistical tasks, such as </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.13.1">defining the versioning and licensing terms, combined with a pipeline that can release and deliver your project to the public. </span><span class="koboSpan" id="kobo.13.2">This entails creating automated pipelines to build, test, and deploy your framework. </span><span class="koboSpan" id="kobo.13.3">This process also teaches you how to smoothly transition from code completion to a published product that users can easily adopt and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">benefit from.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.15.1">Long-term maintenance</span></strong><span class="koboSpan" id="kobo.16.1">: This part revolves around broader aspects that extend beyond </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.17.1">typical coding tasks. </span><span class="koboSpan" id="kobo.17.2">The long-term framework management tasks include monitoring a project’s health, keeping it secure, managing dependencies, and making </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">necessary improvements.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">Understanding these three aspects – the development cycle, the release process, and long-term maintenance – will significantly enhance the success of the frameworks you build and maintain. </span><span class="koboSpan" id="kobo.19.2">It will ensure that your project stays relevant, secure, and robust and is of the highest quality, ultimately leading to a better response from </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">its stakeholders.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">Just like in the other chapters, we will continue to use the repository at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">chapter9</span></strong><span class="koboSpan" id="kobo.26.1"> directory for this chapter consists of several sample projects that showcase tools related to framework maintenance. </span><span class="koboSpan" id="kobo.26.2">Most of these have a similar structure to a common Node.js project. </span><span class="koboSpan" id="kobo.26.3">For each child directory in </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">chapter9</span></strong><span class="koboSpan" id="kobo.28.1">, you can explore the maintenance tool examples. </span><span class="koboSpan" id="kobo.28.2">Refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">chapter9/README.md</span></strong><span class="koboSpan" id="kobo.30.1"> files for extra information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">included projects.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.32.1">The development cycle</span></h1>
<p><span class="koboSpan" id="kobo.33.1">To better </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.34.1">understand the framework maintenance tasks, we will rely on the </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Software Development Life Cycle</span></strong><span class="koboSpan" id="kobo.36.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.37.1">SDLC</span></strong><span class="koboSpan" id="kobo.38.1">) to partition some of the important </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.39.1">milestones of our framework development, such as building features and releasing them for your stakeholders. </span><span class="koboSpan" id="kobo.39.2">Our goal is to take the broad themes of SDLC and apply them to our framework projects, focusing on specific examples that will help you build </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">better projects.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.41.1"><img alt="Figure 9.1: The software development life cycle" src="image/Figure_9.1_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.42.1">Figure 9.1: The software development life cycle</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.44.1">.1</span></em><span class="koboSpan" id="kobo.45.1"> shows a simplified diagram of the SDLC, which we can apply to our framework projects. </span><span class="koboSpan" id="kobo.45.2">In this book, we have performed these steps in detail, except we need to focus further on the </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Deployment</span></strong><span class="koboSpan" id="kobo.47.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Maintenance</span></strong><span class="koboSpan" id="kobo.49.1"> steps to complete the cycle. </span><span class="koboSpan" id="kobo.49.2">We have taken care of the first </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Analysis</span></strong><span class="koboSpan" id="kobo.51.1"> step by learning about the organization of other frameworks and planning out each large portion of the </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Componium</span></em><span class="koboSpan" id="kobo.53.1"> full stack framework. </span><span class="koboSpan" id="kobo.53.2">We have </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.54.1">performed useful examinations of the existing abstractions, popular patterns, and types of frameworks in </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Chapters 2 and 3</span></em><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">To further reinforce this </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Analysis</span></strong><span class="koboSpan" id="kobo.58.1"> step, we brainstormed with potential stakeholders and the feature set of the testing, backend, and frontend parts of </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Componium</span></em><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">In this chapter, we will look at other strategies that help framework developers make framework projects </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">more successful.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.62.1">About SDLC</span></p>
<p class="callout"><span class="koboSpan" id="kobo.63.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Software Development Life Cycle</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">SDLC</span></strong><span class="koboSpan" id="kobo.67.1">), in some cases also called the </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">Systems Development Life cycle</span></strong><span class="koboSpan" id="kobo.69.1">, is a term that originated in the 1960s. </span><span class="koboSpan" id="kobo.69.2">At the time, it was </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.70.1">used to help develop complex business systems. </span><span class="koboSpan" id="kobo.70.2">Later, it was used further in software projects, combined with different development models such as waterfall. </span><span class="koboSpan" id="kobo.70.3">This term defines the systematic process of building large systems and software, providing the methodology for a development process, and focusing on quality and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">programming efficiency.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.72.1">Software developers usually use this model as a foundation and evolve their approach to building software, based on what works works better in their organization. </span><span class="koboSpan" id="kobo.72.2">The introduction of agile software development methods is an extension of an approach to SDLC. </span><span class="koboSpan" id="kobo.72.3">In the instance of JavaScript application development, development teams can use these life cycle concepts to build new projects, with the use of framework tooling and libraries. </span><span class="koboSpan" id="kobo.72.4">Simultaneously, framework developers can also rely on the SDLC methodology to craft a high-quality, performant </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">framework experience.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Design</span></strong><span class="koboSpan" id="kobo.76.1"> stage, following the </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Analysis</span></strong><span class="koboSpan" id="kobo.78.1"> step, is what we discussed in when building a framework in </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Chapters 6</span></em><span class="koboSpan" id="kobo.80.1">,</span><em class="italic"><span class="koboSpan" id="kobo.81.1"> 7</span></em><span class="koboSpan" id="kobo.82.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.83.1">8</span></em><span class="koboSpan" id="kobo.84.1">, and it outlines the architecture parts of a framework. </span><span class="koboSpan" id="kobo.84.2">This is where framework authors focus on bridging the gap between requirements and the start of writing code. </span><span class="koboSpan" id="kobo.84.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Design</span></strong><span class="koboSpan" id="kobo.86.1"> step is particularly interesting when working with the JavaScript ecosystem. </span><span class="koboSpan" id="kobo.86.2">Due to the multifaceted nature of web development, including different aspects of JavaScript, runtimes, and web APIs, there is an opportunity to create innovative design approaches, combining the existing and newly built components. </span><span class="koboSpan" id="kobo.86.3">For example, in </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Chapters 6</span></em><span class="koboSpan" id="kobo.88.1">, </span><em class="italic"><span class="koboSpan" id="kobo.89.1">7</span></em><span class="koboSpan" id="kobo.90.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.91.1">8</span></em><span class="koboSpan" id="kobo.92.1">, we had to make careful decisions about the combination of abstractions and the choice of libraries that we intended to use within the full stack framework. </span><span class="koboSpan" id="kobo.92.2">Going beyond the choice of libraries, the elements of the </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Design</span></strong><span class="koboSpan" id="kobo.94.1"> stage require making concrete decisions about the combination of technologies that will be used in the framework projects and how these technologies communicate together. </span><span class="koboSpan" id="kobo.94.2">This is where we strike a balance of strong opinions versus a </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">flexible framework.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">However, the whole concept of the SDLC process is a </span><em class="italic"><span class="koboSpan" id="kobo.97.1">cycle</span></em><span class="koboSpan" id="kobo.98.1">, which means the design decisions will return </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.99.1">to a developer in a cyclical manner. </span><span class="koboSpan" id="kobo.99.2">This conveys that not all decisions are set in stone and can be changed over time as a project progresses. </span><span class="koboSpan" id="kobo.99.3">However, some decisions are harder to change than others. </span><span class="koboSpan" id="kobo.99.4">For example, changing the API structure in the </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Componium</span></em><span class="koboSpan" id="kobo.101.1"> testing framework will require all the consumers of the framework to rewrite or migrate their tests to a newer API. </span><span class="koboSpan" id="kobo.101.2">Most likely, the API change is for the benefit of the framework and its users, but it still creates friction for the projects utilizing the framework. </span><span class="koboSpan" id="kobo.101.3">This can result in framework users being stuck on certain versions of the project or moving off to use something </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">else entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">As a framework developer, you will reach the </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">Design</span></strong><span class="koboSpan" id="kobo.105.1"> stage again after a project’s initial release. </span><span class="koboSpan" id="kobo.105.2">When that happens, the framework SDLC will be more narrowly focused on feature development and larger refactoring of code. </span><span class="koboSpan" id="kobo.105.3">In the real world, an example of this stage would be in the Vue.js project. </span><span class="koboSpan" id="kobo.105.4">The major versions of Vue.js introduced changes to the renderer, made it easier to work with template directives, and changed the API of components. </span><span class="koboSpan" id="kobo.105.5">More details on that migration can be found at </span><a href="https://v3-migration.vuejs.org/breaking-changes"><span class="koboSpan" id="kobo.106.1">v3-migration.vuejs.org/breaking-changes</span></a><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">With cases like these, the framework authors go back to the drawing board or find ways to drastically redesign certain public-facing and underlying structures of </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">a framework.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">This cycle of coming back to the </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Design</span></strong><span class="koboSpan" id="kobo.111.1"> stage is common in the evolution of a framework, particularly when it’s in active development or has a thriving user base. </span><span class="koboSpan" id="kobo.111.2">While potentially disruptive to the existing users, this iterative process is key to the framework’s long-term success and sustainability. </span><span class="koboSpan" id="kobo.111.3">Frameworks that fail to adapt or evolve can quickly become outdated and lose relevance. </span><span class="koboSpan" id="kobo.111.4">Consider the evolution of the Angular framework project. </span><span class="koboSpan" id="kobo.111.5">A complete rewrite was undertaken in its evolution from AngularJS to modern versions of Angular. </span><span class="koboSpan" id="kobo.111.6">While initially disruptive to the developers, this transition allowed the framework to modernize its architecture and take advantage of the latest JavaScript features. </span><span class="koboSpan" id="kobo.111.7">It also set the foundation for a more future-proof growth path, ensuring Angular’s position as one of the top frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">JavaScript frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Another area where the </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">Design</span></strong><span class="koboSpan" id="kobo.115.1"> stage reoccurs is the introduction of performance improvements, specifically those affecting JavaScript projects. </span><span class="koboSpan" id="kobo.115.2">Given the nature of the JavaScript language and ever-evolving web technologies, performance optimization is often an ongoing endeavor. </span><span class="koboSpan" id="kobo.115.3">The team behind the React library has consistently revisited its design phase to </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.116.1">make performance improvements, leading to significant enhancements such as the introduction of Hooks, concurrent mode, and the new JSX transform. </span><span class="koboSpan" id="kobo.116.2">The SDLC </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Design</span></strong><span class="koboSpan" id="kobo.118.1"> stage keeps you busy, as it is a continuous activity that enables a framework to stay relevant, performant, and useful to its users. </span><span class="koboSpan" id="kobo.118.2">The key is handling these design changes in such a way that it minimizes disruptions and provides clear paths for users to adapt to the changes. </span><span class="koboSpan" id="kobo.118.3">Continuing on a similar theme, in the following sections, we will learn more about what framework authors can do to safely implement and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">new features.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.120.1">Seeking user feedback</span></h2>
<p><span class="koboSpan" id="kobo.121.1">One of the most exciting parts of framework development is getting some stakeholders to use what you have developed. </span><span class="koboSpan" id="kobo.121.2">These stakeholders could be teams within your company, external </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.122.1">open source users, or even your own team. </span><span class="koboSpan" id="kobo.122.2">The framework product that you produce needs an efficient feedback loop. </span><span class="koboSpan" id="kobo.122.3">This loop will consist of finding ways to get the best feedback you can from as many stakeholders as possible. </span><span class="koboSpan" id="kobo.122.4">After successfully acquiring the required input, a framework developer can outline the required changes to adapt to that feedback. </span><span class="koboSpan" id="kobo.122.5">These changes can include fixes to issues, the addition of new features, improvement of the developer experience, or overall organizational tweaks. </span><span class="koboSpan" id="kobo.122.6">Once these changes are in place, we reach another exciting part of the framework development process – delivering the newly updated version of the framework to </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the users.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">In this part of the chapter, let's focus on the first part of seeking user feedback, which is properly gathering feedback. </span><span class="koboSpan" id="kobo.124.2">Depending on the scale of your project and organization, you may end up interacting with large groups of stakeholders or having a one-on-one interaction with just a few users. </span><span class="koboSpan" id="kobo.124.3">For larger groups, it is beneficial to utilize a system that can facilitate discussion and the ability to have different discussions related to various aspects of a framework. </span><span class="koboSpan" id="kobo.124.4">The most simplistic approach is to maintain an issue or feature request tracking system. </span><span class="koboSpan" id="kobo.124.5">This is very similar to other software projects, but with a framework, investing more time in managing the aspects of this system is more important. </span><span class="koboSpan" id="kobo.124.6">With a framework, you want to be able to clearly separate the issue and feature discussions, slating the feedback for different releases of </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">The framework can also provide opportunities to direct feedback to the right place. </span><span class="koboSpan" id="kobo.126.2">For instance, gathering developer feedback can be embedded within the developer experience of a project. </span><span class="koboSpan" id="kobo.126.3">This is where the executable that developers use daily can provide links to the feature request tracker. </span><span class="koboSpan" id="kobo.126.4">In </span><a href="B19014_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.128.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">componium</span></strong><span class="koboSpan" id="kobo.130.1"> executable had mechanisms to generate scaffolding of certain common components, and the feedback direction could be built right into that executable. </span><span class="koboSpan" id="kobo.130.2">Overall, you must rely on tools and systems </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.131.1">to gather feedback and avoid spending too much time manually managing all of it. </span><span class="koboSpan" id="kobo.131.2">Most importantly, it is important to be respectful of all types of feedback. </span><span class="koboSpan" id="kobo.131.3">In some cases, the features built and described within a framework may not work well for some stakeholders. </span><span class="koboSpan" id="kobo.131.4">Therefore, it is essential to appreciate each piece of feedback as a unique perspective that brings with it the prospect of innovation and expansion of your project. </span><span class="koboSpan" id="kobo.131.5">In the next part, we will discuss a formal feature definition process that worked well across open source and private </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">framework projects.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.133.1">Formal feature definition</span></h2>
<p><span class="koboSpan" id="kobo.134.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Request for Comments</span></strong><span class="koboSpan" id="kobo.136.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">RFC</span></strong><span class="koboSpan" id="kobo.138.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">Request for Proposals</span></strong><span class="koboSpan" id="kobo.140.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">RFP</span></strong><span class="koboSpan" id="kobo.142.1">) processes are commonly used across many industries to define new features or get feedback. </span><span class="koboSpan" id="kobo.142.2">These same </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.143.1">processes work really well in software framework development as well. </span><span class="koboSpan" id="kobo.143.2">Many frameworks have implemented their own approach </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.144.1">to this process of formal feature definition, with stakeholder feedback built in. </span><span class="koboSpan" id="kobo.144.2">For example, Ember.js hosts its RFCs at </span><a href="https://github.com/emberjs/rfcs"><span class="koboSpan" id="kobo.145.1">github.com/emberjs/rfcs</span></a><span class="koboSpan" id="kobo.146.1">, and Vue.js hosts RFCs at </span><a href="https://github.com/vuejs/rfcs"><span class="koboSpan" id="kobo.147.1">github.com/vuejs/rfcs</span></a><span class="koboSpan" id="kobo.148.1">, keeping track of all new, pending, and archived proposals for feature additions and drastic changes to </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.149.1">the project. </span><span class="koboSpan" id="kobo.149.2">With the open source </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.150.1">nature of those frameworks, anyone can chime in as new feature proposals arrive in those repositories. </span><span class="koboSpan" id="kobo.150.2">The proposals get reviewed in a similar manner to code contributions. </span><span class="koboSpan" id="kobo.150.3">Conveniently, these feature definitions are stored in a code repository so that they can be logged and referenced in </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Including a process for formal feature definition helps organize both framework developers and </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.153.1">users to participate in the </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">Design</span></strong><span class="koboSpan" id="kobo.155.1"> stage of the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Framework Development Lifecycle</span></strong><span class="koboSpan" id="kobo.157.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">FDLC</span></strong><span class="koboSpan" id="kobo.159.1">). </span><span class="koboSpan" id="kobo.159.2">As a framework developer, you are free to choose how involved this process can be. </span><span class="koboSpan" id="kobo.159.3">For example, if we added a new feature to Componium to get native WebSocket support, we could create an RFC explaining the gist of the feature, propose an API for it, and state why it would be beneficial to the full stack framework overall. </span><span class="koboSpan" id="kobo.159.4">Depending on the complexity of </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.160.1">our organization, the proposal to add this particular feature can transition through the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">following stages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">Proposed</span></strong><span class="koboSpan" id="kobo.163.1">: When the new WebSocket feature is described in full detail. </span><span class="koboSpan" id="kobo.163.2">At this stage, other framework developers and potential stakeholders get the opportunity to provide initial feedback. </span><span class="koboSpan" id="kobo.163.3">In our example, this is where the public API, frontend and backend integration, and the coverage of the WebSocket feature </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">are proposed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Exploring</span></strong><span class="koboSpan" id="kobo.166.1">: The stage where framework developers get to explore technical prototypes and explore the potential architecture of the feature. </span><span class="koboSpan" id="kobo.166.2">During this stage, implementation details can be refined. </span><span class="koboSpan" id="kobo.166.3">For a framework project, it is also a good idea to share the feature with the teams that have a stake in the framework to seek </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">further feedback.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.168.1">Accepted</span></strong><span class="koboSpan" id="kobo.169.1">: If the feature is deemed sufficient, then the framework can proceed with the implementation and merge the code into the main code base at </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">this stage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Ready for release</span></strong><span class="koboSpan" id="kobo.172.1">: The pre-release </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.173.1">stage is a good opportunity to create a new </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">release candidate</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.176.1">RC</span></strong><span class="koboSpan" id="kobo.177.1">) for the latest improvements to the framework. </span><span class="koboSpan" id="kobo.177.2">There is another opportunity to get useful feedback on how the feature works with the existing projects and integrations. </span><span class="koboSpan" id="kobo.177.3">In terms of maintenance, user documentation can </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">be introduced.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.179.1">Released</span></strong><span class="koboSpan" id="kobo.180.1">: The final stage is where the feature is launched and made available. </span><span class="koboSpan" id="kobo.180.2">This is the point at which the RFC can finally be tagged as complete and released. </span><span class="koboSpan" id="kobo.180.3">Future proposals can also reference this feature to help with feedback and the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">technical architecture.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.182.1">Having a formal process like this helps structure a well-organized approach to feature development and user feedback. </span><span class="koboSpan" id="kobo.182.2">However, it is worth noting that many features can get stuck at the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Proposal</span></strong><span class="koboSpan" id="kobo.184.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">Exploration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> stages.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">A real-world example of a simple RFC that was accepted and merged is the removal of Internet Explorer 11 support in Vue.js: </span><a href="https://github.com/vuejs/rfcs/pull/294/files"><span class="koboSpan" id="kobo.188.1">github.com/vuejs/rfcs/pull/294/files</span></a><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">The documentation mentions the motivation behind the change, including the concerns about the maintenance burden and how the change affected the consumers of the framework. </span><span class="koboSpan" id="kobo.189.3">Over 50 replies were contributed to the discussion thread of that proposal, including members of the framework’s core team and other developers passionate about </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the change.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The RFP process can work in a similar way to trigger interest or a bid from another entity to help contribute to the framework. </span><span class="koboSpan" id="kobo.191.2">If there is some feature that you would like to add to your framework but are not able to, then through this process, you can find a vendor that will do it for you. </span><span class="koboSpan" id="kobo.191.3">This process is more common in corporate </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">proprietary environments.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Both of these </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.194.1">approaches create a structure around feature development and help us follow the SDLC in our own way that fits well with the project. </span><span class="koboSpan" id="kobo.194.2">As your </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.195.1">framework evolves and develops, you might choose to tweak how these formal feature definition processes perform best for </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">With the feature development cycle in place, in the next section, we can now highlight the ways a JavaScript framework approaches the release process, including providing the ability to report to its stakeholders about all the new improvements and features shipping in the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">new versions.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.199.1">Release process</span></h1>
<p><span class="koboSpan" id="kobo.200.1">In the SDLC diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.202.1">.1</span></em><span class="koboSpan" id="kobo.203.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Deployment</span></strong><span class="koboSpan" id="kobo.205.1"> step signifies when software can be utilized by consumers. </span><span class="koboSpan" id="kobo.205.2">In the context of framework development, this means a new release that </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.206.1">is made available. </span><span class="koboSpan" id="kobo.206.2">This is where newly crafted features become available, and to make them available, developers need to go through the </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">release process</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">In this part of the chapter, we shall explore the topics related to the initial and subsequent release of JavaScript framework projects. </span><span class="koboSpan" id="kobo.208.3">This will include showcasing some of the existing tools, licensing options, versioning, and continuous delivery. </span><span class="koboSpan" id="kobo.208.4">To follow the </span><em class="italic"><span class="koboSpan" id="kobo.209.1">The development cycle</span></em><span class="koboSpan" id="kobo.210.1"> section, where we discussed the introduction of new features, we will begin by learning how to keep everyone informed of the changes to a framework. </span><span class="koboSpan" id="kobo.210.2">Later, the </span><em class="italic"><span class="koboSpan" id="kobo.211.1">Simplifying releases</span></em><span class="koboSpan" id="kobo.212.1"> section will discuss the opportunities to make the release chores </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">more approachable.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.214.1">Change logs</span></h2>
<p><span class="koboSpan" id="kobo.215.1">Framework developers already have to spend a lot of time planning, architecting, and developing features. </span><span class="koboSpan" id="kobo.215.2">Luckily, for the final step of releasing those features, the process of collecting the </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.216.1">details of all the newly built framework components can be standardized and automated. </span><span class="koboSpan" id="kobo.216.2">To make this happen, projects rely on existing tooling, such as release utilities and change log generation tools, to support publishing new </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.217.1">releases of a framework. </span><span class="koboSpan" id="kobo.217.2">The first thing that is useful to maintain and generate is a log of changes in every release. </span><span class="koboSpan" id="kobo.217.3">The change log is useful in any framework setting and should be the way you communicate with stakeholders about the impact of every </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">new release.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Here are some good examples of change log structures from other </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">popular projects:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Electron</span></strong><span class="koboSpan" id="kobo.222.1">: The application framework project hosts its change log at </span><a href="https://releases.electronjs.org/releases/stable"><span class="koboSpan" id="kobo.223.1">releases.electronjs.org/releases/stable</span></a><span class="koboSpan" id="kobo.224.1">, with very detailed information on changes in </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.225.1">stable releases and upcoming pre-releases. </span><span class="koboSpan" id="kobo.225.2">It gives you the ability to filter by major framework versions and integrates with landed code by linking directly to the source at GitHub. </span><span class="koboSpan" id="kobo.225.3">The calendar </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.226.1">of releases at </span><a href="https://releases.electronjs.org/history"><span class="koboSpan" id="kobo.227.1">releases.electronjs.org/history</span></a><span class="koboSpan" id="kobo.228.1"> also provides a great visual of all the newly tagged versions. </span><span class="koboSpan" id="kobo.228.2">This example could be overkill for a newly created framework but works well for an established project with a large </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">user base.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">SvelteKit</span></strong><span class="koboSpan" id="kobo.231.1">: The framework takes a simpler approach to managing the change log. </span><span class="koboSpan" id="kobo.231.2">It hosts </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.232.1">this log of changes at </span><a href="https://github.com/sveltejs/kit/blob/master/packages/kit/CHANGELOG.md"><span class="koboSpan" id="kobo.233.1">github.com/sveltejs/kit/blob/master/packages/kit/CHANGELOG.md</span></a><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">The log keeps </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.235.1">track of the releases and the changes within those releases by category. </span><span class="koboSpan" id="kobo.235.2">For instance, types of changes can include </span><em class="italic"><span class="koboSpan" id="kobo.236.1">feat</span></em><span class="koboSpan" id="kobo.237.1"> (feature development), </span><em class="italic"><span class="koboSpan" id="kobo.238.1">docs</span></em><span class="koboSpan" id="kobo.239.1"> (documentation changes), and </span><em class="italic"><span class="koboSpan" id="kobo.240.1">perf</span></em><span class="koboSpan" id="kobo.241.1"> (performance improvements). </span><span class="koboSpan" id="kobo.241.2">The log update process is automated using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">changesets</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.243.1">automation tool.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Next.js</span></strong><span class="koboSpan" id="kobo.245.1">: The framework </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.246.1">uses the </span><em class="italic"><span class="koboSpan" id="kobo.247.1">GitHub Releases</span></em><span class="koboSpan" id="kobo.248.1"> feature to </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.249.1">outline the changes in </span><a href="https://github.com/vercel/next.js/"><span class="koboSpan" id="kobo.250.1">github.com/vercel/next.js/</span></a><span class="koboSpan" id="kobo.251.1"> releases. </span><span class="koboSpan" id="kobo.251.2">Using GitHub’s interface allows the project to document the changes, including the contributors, assets, and source code on the same page. </span><span class="koboSpan" id="kobo.251.3">GitHub’s tooling allows you to run comparisons across releases to get a series of commits that have changed from a previous release. </span><span class="koboSpan" id="kobo.251.4">The creation of the change log itself is done with manual scripts within the framework at </span><a href="https://github.com/vercel/next.js/blob/canary/release.js"><span class="koboSpan" id="kobo.252.1">github.com/vercel/next.js/blob/canary/release.js</span></a><span class="koboSpan" id="kobo.253.1">. </span><span class="koboSpan" id="kobo.253.2">These scripts are automated using </span><em class="italic"><span class="koboSpan" id="kobo.254.1">GitHub Actions</span></em><span class="koboSpan" id="kobo.255.1"> when triggered by </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">framework maintainers.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.257.1">The common </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.258.1">theme around these change logs is that, often, the change logs are automatically generated, based on certain code commit message structures </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.259.1">and with the use of different automated tools, which are published for users to browse through. </span><span class="koboSpan" id="kobo.259.2">Depending on your requirements, you can benefit from the following tools or similar in your JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">framework projects:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.261.1">commitizen</span></strong><span class="koboSpan" id="kobo.262.1"> (</span><a href="https://commitizen.github.io/cz-cli"><span class="koboSpan" id="kobo.263.1">commitizen.github.io/cz-cli</span></a><span class="koboSpan" id="kobo.264.1">): A command-line tool specifically to make the </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.265.1">process of writing and logging commit messages organized. </span><span class="koboSpan" id="kobo.265.2">If you integrate this or a similar tool into your code workflow, the whole team contributing code to the framework will produce consistent and quality commit messages. </span><span class="koboSpan" id="kobo.265.3">It supports different change log conventions and formats, depending on how detailed the message should be. </span><span class="koboSpan" id="kobo.265.4">For instance, the logs may contain a convention to be in the following format – </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">&lt;type&gt;(&lt;scope&gt;): &lt;summary&gt;</span></strong><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">These conventions either become more complex or simpler, depending on the choice of the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">framework developer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.269.1">commitlint</span></strong><span class="koboSpan" id="kobo.270.1"> (</span><a href="https://github.com/conventional-changelog/commitlint"><span class="koboSpan" id="kobo.271.1">github.com/conventional-changelog/commitlint</span></a><span class="koboSpan" id="kobo.272.1">): Another tool that helps </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.273.1">validate the commit message structure and adheres to a certain commit convention. </span><span class="koboSpan" id="kobo.273.2">It is capable of validating the messages as strings through an interactive CLI or </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">programmatic usage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.275.1">Changesets</span></strong><span class="koboSpan" id="kobo.276.1"> (</span><a href="https://github.com/changesets/changesets"><span class="koboSpan" id="kobo.277.1">github.com/changesets/changesets</span></a><span class="koboSpan" id="kobo.278.1">): A more involved solution to </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.279.1">generate change sets for simple and multi-package code bases. </span><span class="koboSpan" id="kobo.279.2">This helps when a framework is spread across </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">many sources.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.281.1">After you look into using these tools for your framework projects, you will find that there are common themes to all of them. </span><span class="koboSpan" id="kobo.281.2">Most of the time, these tools have different approaches to configuration and structures. </span><span class="koboSpan" id="kobo.281.3">However, with so many options to choose from, using any of </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.282.1">these can help you save time by providing important </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.283.1">information about the progress of your framework to your users. </span><span class="koboSpan" id="kobo.283.2">For instance, the Ember.js project has an easy-to-follow change log (</span><a href="https://github.com/emberjs/ember.js/blob/main/CHANGELOG.md"><span class="koboSpan" id="kobo.284.1">github.com/emberjs/ember.js/blob/main/CHANGELOG.md</span></a><span class="koboSpan" id="kobo.285.1">) that helps developers keep up with updates. </span><span class="koboSpan" id="kobo.285.2">If you explore some of the change logs, including the Ember.js one, you will see different types of versioning that are maintained throughout the development cycle, which is what we will cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">following section.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.287.1">Versioning</span></h2>
<p><span class="koboSpan" id="kobo.288.1">Maintaining proper versioning for your framework can be a challenge. </span><span class="koboSpan" id="kobo.288.2">Keeping proper versioning schemes </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.289.1">helps stakeholders understand the compatibility of their code with new iterations of the framework. </span><span class="koboSpan" id="kobo.289.2">If a project is properly versioned and is </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.290.1">strict in defining its versions, then downstream consumers can be confident when they update the framework dependency. </span><span class="koboSpan" id="kobo.290.2">Any changes in the upstream framework versions can cause breakages in the existing components and cause havoc in the already-built applications. </span><span class="koboSpan" id="kobo.290.3">There are many cases, especially in older software, where framework users are asked to be cautious updating to the latest versions of a framework, even if projects are known to have security vulnerabilities. </span><span class="koboSpan" id="kobo.290.4">Some examples include drastic changes from AngularJS to modern versions of Angular or major version changes </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.291.1">of JavaScript tooling, such as </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">webpack</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">In addition, if a project frequently breaks a versioning contract, then the users of the framework will slow down their upgrade cycles and potentially avoid using particular projects in </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Luckily, the software </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.296.1">community has created standards around </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.297.1">versioning, such as </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">SemVer</span></strong><span class="koboSpan" id="kobo.299.1"> (</span><a href="https://semver.org"><span class="koboSpan" id="kobo.300.1">semver.org</span></a><span class="koboSpan" id="kobo.301.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Calendar Versioning</span></strong><span class="koboSpan" id="kobo.303.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">CalVer</span></strong><span class="koboSpan" id="kobo.305.1">) (</span><a href="https://calver.org"><span class="koboSpan" id="kobo.306.1">calver.org</span></a><span class="koboSpan" id="kobo.307.1">), which can help define proper versioning contracts. </span><span class="koboSpan" id="kobo.307.2">These standards can help define the framework release process and should be documented somewhere in the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">framework documentation.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 9.2: Semantic versioning" src="image/Figure_9.2_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 9.2: Semantic versioning</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.311.1">Semantic versioning</span></strong><span class="koboSpan" id="kobo.312.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.313.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.314.1">.2</span></em><span class="koboSpan" id="kobo.315.1">, is the most common system adopted across many </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.316.1">projects nowadays. </span><span class="koboSpan" id="kobo.316.2">It consists of three required and one </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">optional components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.318.1">First, we have the </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">Major</span></strong><span class="koboSpan" id="kobo.320.1"> version, which signifies changes that are incompatible if a user </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.321.1">updates from an earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">major version</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Minor</span></strong><span class="koboSpan" id="kobo.325.1"> version means new features are available, and the release is still backward-compatible with </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">earlier versions</span></span></li>
<li><span class="koboSpan" id="kobo.327.1">The last required component is the </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Patch</span></strong><span class="koboSpan" id="kobo.329.1"> version, which means that there a bug fixes that are also backward-compatible with </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">earlier versions</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">Optional</span></strong><span class="koboSpan" id="kobo.333.1"> component toward the end of the version can consist of pre-release names, with the addition of metadata or </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">build numbers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.335.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">semantic-release</span></strong><span class="koboSpan" id="kobo.337.1"> (</span><a href="https://npmjs.com/package/semantic-release"><span class="koboSpan" id="kobo.338.1">npmjs.com/package/semantic-release</span></a><span class="koboSpan" id="kobo.339.1">) package uses SemVer and attempts </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.340.1">to simplify versioning for JavaScript projects by utilizing the code base commit history, determining whether a version of the project should be a </span><em class="italic"><span class="koboSpan" id="kobo.341.1">major</span></em><span class="koboSpan" id="kobo.342.1">, </span><em class="italic"><span class="koboSpan" id="kobo.343.1">minor</span></em><span class="koboSpan" id="kobo.344.1">, or a </span><em class="italic"><span class="koboSpan" id="kobo.345.1">patch</span></em><span class="koboSpan" id="kobo.346.1"> release. </span><span class="koboSpan" id="kobo.346.2">It works as a utility during an automated </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">release step.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">The alternative CalVer format defines its structure using dates in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">YYYY.MM.DD</span></strong><span class="koboSpan" id="kobo.350.1"> format. </span><span class="koboSpan" id="kobo.350.2">It can be useful if project releases are based on the calendar year. </span><span class="koboSpan" id="kobo.350.3">Ultimately, the framework </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.351.1">maintainer decides the set version, and it is a big responsibility to correctly set these versions and ensure that downstream users do not have their application </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">builds broken.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.353.1">Simplifying releases</span></h2>
<p><span class="koboSpan" id="kobo.354.1">So far, we have seen many tools that automate different parts of the release process. </span><span class="koboSpan" id="kobo.354.2">We focused on </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.355.1">versioning, feature feedback, and change logs. </span><span class="koboSpan" id="kobo.355.2">We can introduce tools to simplify our framework’s new release workflow further. </span><span class="koboSpan" id="kobo.355.3">This type of tooling aims to ensure that all the release process tasks are successfully executed and requires releases to be consistent across </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the board.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 9.3: Publishing a new release" src="image/Figure_9.3_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 9.3: Publishing a new release</span></p>
<p><span class="koboSpan" id="kobo.359.1">Tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">release-it</span></strong><span class="koboSpan" id="kobo.361.1"> (</span><a href="https://github.com/release-it/release-it"><span class="koboSpan" id="kobo.362.1">github.com/release-it/release-it</span></a><span class="koboSpan" id="kobo.363.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">np</span></strong><span class="koboSpan" id="kobo.365.1"> (</span><a href="https://github.com/sindresorhus/np"><span class="koboSpan" id="kobo.366.1">github.com/sindresorhus/np</span></a><span class="koboSpan" id="kobo.367.1">) make it possible to ensure that the release process goes smoothly. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.369.1">.3</span></em><span class="koboSpan" id="kobo.370.1"> shows the np tool in action when publishing a new version of the Componium test. </span><span class="koboSpan" id="kobo.370.2">These tools ensure that the following tasks are completed for </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">your project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.372.1">Any prerequisite scripts are executed, which could include formatting and </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">linting files.</span></span></li>
<li><span class="koboSpan" id="kobo.374.1">The required release tests run and pass. </span><span class="koboSpan" id="kobo.374.2">If the tests fail, then the release process </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">is aborted.</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">Bumping the version number using the maintainer choice or based on some other criteria, such as using the </span><em class="italic"><span class="koboSpan" id="kobo.377.1">semantic-release</span></em><span class="koboSpan" id="kobo.378.1"> package that we </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">saw earlier.</span></span></li>
<li><span class="koboSpan" id="kobo.380.1">Publishing code to a specific registry. </span><span class="koboSpan" id="kobo.380.2">For internal projects, this could be an internal source; for public projects, this means uploading the source code to a public registry. </span><span class="koboSpan" id="kobo.380.3">This will probably be the source from which the framework users get the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">latest code.</span></span></li>
<li><span class="koboSpan" id="kobo.382.1">Pushing the necessary tags to the code repository with the same version number as the one published to </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the registry.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.384.1">These are just </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.385.1">some of the steps that are generally run, but for more complex projects, many of the steps can be tweaked to accommodate the needs of the code base. </span><span class="koboSpan" id="kobo.385.2">Usage of these tools depends on how well they fit into your workflows. </span><span class="koboSpan" id="kobo.385.3">It’s a good idea to start simple and find tools that work right outside of the box. </span><span class="koboSpan" id="kobo.385.4">As the framework project grows, you will find yourself mixing and matching different tools to craft your own approach to the release process. </span><span class="koboSpan" id="kobo.385.5">For example, </span><a href="B19014_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.387.1"> mentioned the </span><em class="italic"><span class="koboSpan" id="kobo.388.1">ng-dev</span></em><span class="koboSpan" id="kobo.389.1"> tool used for internal Angular development. </span><span class="koboSpan" id="kobo.389.2">In the internals of that tool, the team utilizes the </span><em class="italic"><span class="koboSpan" id="kobo.390.1">np</span></em><span class="koboSpan" id="kobo.391.1"> command-line tool for the release process. </span><span class="koboSpan" id="kobo.391.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">release-it</span></strong><span class="koboSpan" id="kobo.393.1"> package offers some extra features, suitable for projects that live inside a mono-repo code base or require </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">further configuration.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.395.1">Maintenance tool showcase</span></p>
<p class="callout"><span class="koboSpan" id="kobo.396.1">The book code repository in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">chapter9</span></strong><span class="koboSpan" id="kobo.398.1"> includes a collection of tools that you can quickly try out and see how effective they are. </span><span class="koboSpan" id="kobo.398.2">Your framework projects can integrate the included or similar tools, thus improving the framework development workflow. </span><span class="koboSpan" id="kobo.398.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">chapter9/commitizen</span></strong><span class="koboSpan" id="kobo.400.1"> directory consists of a project that uses the Commitizen package to enforce Git commit guidelines for </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">your projects.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.402.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">maintenance-tools</span></strong><span class="koboSpan" id="kobo.404.1"> directory showcases several Node.js utilities used for framework maintenance. </span><span class="koboSpan" id="kobo.404.2">To see the available scripts, make sure to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">npm install</span></strong><span class="koboSpan" id="kobo.406.1"> and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">run dev</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">In the next section, we will reach the final milestone of the release process, which is combining the </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.411.1">tools we have seen so far and the continuous integration environment, making it possible to publish a new release of a framework with a single click of </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">a button.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.413.1">Continuous delivery</span></h2>
<p><span class="koboSpan" id="kobo.414.1">Configuring and maintaining the infrastructure for framework release and other tasks involves following </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.415.1">best practices and adapting tools from the DevOps methodology space. </span><span class="koboSpan" id="kobo.415.2">This involves mixing software development tasks and IT operations to improve software releases, making them much more easily manageable. </span><span class="koboSpan" id="kobo.415.3">Often, integrating with DevOps systems will require learning new technical skills outside of the core technologies used in the framework that you are working on. </span><span class="koboSpan" id="kobo.415.4">This includes learning about the latest approaches to automation, secure release processes, and application deployment in </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">DevOps environments.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">These days, it is </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.418.1">ubiquitous and effortless to set up the </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.420.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.421.1">CI</span></strong><span class="koboSpan" id="kobo.422.1">) step for software projects, and it is important to do so for framework projects. </span><span class="koboSpan" id="kobo.422.2">It is important to use the CI environment to make sure that the required framework tests run in an isolated environment. </span><span class="koboSpan" id="kobo.422.3">The CI steps also ensure code quality </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.423.1">and help create a good framework development workflow. </span><span class="koboSpan" id="kobo.423.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Continuous Delivery</span></strong><span class="koboSpan" id="kobo.425.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.426.1">CD</span></strong><span class="koboSpan" id="kobo.427.1">) pipeline is designed to deliver the framework product. </span><span class="koboSpan" id="kobo.427.2">It is configured alongside the CI steps to prepare the code changes to be inspected, built, and tested. </span><span class="koboSpan" id="kobo.427.3">These pipelines are also configured in both open source and </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">internal environments.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Delivery</span></strong><span class="koboSpan" id="kobo.431.1"> part ensures that maintainers can prepare new releases of a project, which includes executing the set of tools that were part of the simplified release routines. </span><span class="koboSpan" id="kobo.431.2">In the delivery phases, the internal development scripts can run all the relevant tasks to the release, which could include generating project documentation and publishing other artifacts. </span><span class="koboSpan" id="kobo.431.3">This release environment also has access to the required credentials to publish code to the relevant registries. </span><span class="koboSpan" id="kobo.431.4">During the delivery stages, maintainers can configure all the different types of tools that we have seen in this chapter to automate the process of publishing a new version of the framework software that </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">is produced.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">An example of this would be a workflow set up with </span><em class="italic"><span class="koboSpan" id="kobo.434.1">GitHub Actions</span></em><span class="koboSpan" id="kobo.435.1"> to release new versions of Next.js. </span><span class="koboSpan" id="kobo.435.2">These workflows can be seen executing at </span><a href="https://github.com/vercel/next.js/actions/workflows/trigger_release.yml"><span class="koboSpan" id="kobo.436.1">github.com/vercel/next.js/actions/workflows/trigger_release.yml</span></a><span class="koboSpan" id="kobo.437.1">, triggered by the maintainers of the framework. </span><span class="koboSpan" id="kobo.437.2">Configuring these automated workflows will give you a massive boost </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.438.1">in productivity, as it will avoid a lot </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.439.1">of manual tasks. </span><span class="koboSpan" id="kobo.439.2">This will also give you more confidence in your product because these workflows enforce the high-quality bar for all </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">framework maintainers.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.441.1">Continuous integration sample</span></p>
<p class="callout"><span class="koboSpan" id="kobo.442.1">Similar to the information shared about the maintenance tool in the </span><em class="italic"><span class="koboSpan" id="kobo.443.1">Simplifying releases</span></em><span class="koboSpan" id="kobo.444.1"> section, you can find a sample of CI configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">chapter9/ci</span></strong><span class="koboSpan" id="kobo.446.1"> directory. </span><span class="koboSpan" id="kobo.446.2">This configuration can be used for your own projects with the GitHub Actions (</span><a href="https://github.com/features/actions"><span class="koboSpan" id="kobo.447.1">github.com/features/actions</span></a><span class="koboSpan" id="kobo.448.1">) and Circle CI (</span><a href="https://circleci.com"><span class="No-Break"><span class="koboSpan" id="kobo.449.1">circleci.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.450.1">) infrastructure.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.451.1">To test out these configurations, you can copy the files from the chapter into your own repository, where you have full access to edit the source of </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Another relevant aspect of releasing is licensing, wherein framework authors need to explain the terms of use and distribution for their creations. </span><span class="koboSpan" id="kobo.453.2">This is what we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">next section.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.455.1">Licensing</span></h2>
<p><span class="koboSpan" id="kobo.456.1">As your framework develops, you will find you need to set an appropriate license for the code base. </span><span class="koboSpan" id="kobo.456.2">This release </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.457.1">procedure can apply to both internally </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.458.1">developed projects and open source initiatives. </span><span class="koboSpan" id="kobo.458.2">In both cases, you can choose from many different types of license types. </span><span class="koboSpan" id="kobo.458.3">For private business-related projects, you can </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.459.1">choose a </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">proprietary license</span></strong><span class="koboSpan" id="kobo.461.1">, restricting the use of the framework outside of the control of the company. </span><span class="koboSpan" id="kobo.461.2">This type grants exclusive ownership </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.462.1">of the code base and internal projects. </span><span class="koboSpan" id="kobo.462.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">commercial license</span></strong><span class="koboSpan" id="kobo.464.1"> can be useful if you want to sell or restrict the redistribution to only the users who paid for the use of your code. </span><span class="koboSpan" id="kobo.464.2">For example, you can find some JavaScript frameworks distributing different editions of their frameworks, such as </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Sencha Ext JS</span></strong><span class="koboSpan" id="kobo.466.1"> (</span><a href="https://store.sencha.com"><span class="koboSpan" id="kobo.467.1">store.sencha.com</span></a><span class="koboSpan" id="kobo.468.1">), which </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.469.1">includes community and enterprise versions. </span><span class="koboSpan" id="kobo.469.2">The extended enterprise versions can include more support, custom features, and dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">developer attention.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">For open source use cases, there are licensing options as well. </span><span class="koboSpan" id="kobo.471.2">The website at </span><a href="https://choosealicense.com"><span class="koboSpan" id="kobo.472.1">choosealicense.com</span></a><span class="koboSpan" id="kobo.473.1"> supports software developers and helps them figure out the needs behind open sourcing their work. </span><span class="koboSpan" id="kobo.473.2">You will find many popular open source projects using the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">following licenses:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.475.1">MIT</span></strong><span class="koboSpan" id="kobo.476.1">: This is a very </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.477.1">permissive license that allows commercial use, distribution, modification, and private use. </span><span class="koboSpan" id="kobo.477.2">It’s based on the conditions that you retain copyright notices and avoid any liability or warranty from </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">your code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.479.1">The GNU General Public License (GPL)</span></strong><span class="koboSpan" id="kobo.480.1">: This is a copyleft license that offers </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.481.1">similar commercial permissions to the MIT license but is more detailed around patent and distribution rules. </span><span class="koboSpan" id="kobo.481.2">However, with this license, there are conditions for disclosing the </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">source code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Apache License 2.0</span></strong><span class="koboSpan" id="kobo.484.1">: This is a permissive license similar to MIT but with additional </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.485.1">limitations on trademarks and providing patent use cases. </span><span class="koboSpan" id="kobo.485.2">If anyone changes the code of your framework under the Apache license, then they need to declare </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.487.1">As a framework author, it is important to decide on the license that all contributors will adhere to while </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.488.1">contributing to a project. </span><span class="koboSpan" id="kobo.488.2">The process of changing </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.489.1">the licenses down the road takes quite a bit of effort because all the contributors have to re-license their code under the new license. </span><span class="koboSpan" id="kobo.489.2">It is also important to remember the license types of libraries you use within </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">your framework.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">This concludes the section on release process items, which included gathering feedback, notifying users of new releases, and helping optimize those releases. </span><span class="koboSpan" id="kobo.491.2">Now, we are ready to move on to additional topics of maintenance that focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">long term.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.493.1">Long-term maintenance</span></h1>
<p><span class="koboSpan" id="kobo.494.1">So far in this chapter, we have looked at maintenance tasks that occur as a framework progresses </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.495.1">through the development life cycle, covering topics around the initial or following feature updates. </span><span class="koboSpan" id="kobo.495.2">However, there are additional unique aspects of framework development that are part of the longer-term upkeep. </span><span class="koboSpan" id="kobo.495.3">To focus on a few, we will explore the topics of security, dependency management, evolving feature compatibility, </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">and more.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.497.1">Security</span></h2>
<p><span class="koboSpan" id="kobo.498.1">The approach to web application security has changed in recent years. </span><span class="koboSpan" id="kobo.498.2">More tools and solutions are now </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.499.1">available in the security space that try to protect the whole development workflow. </span><span class="koboSpan" id="kobo.499.2">When users choose a framework to suit their needs, they also have certain security expectations from it, especially if the framework is built for purposes that handle critical data and user input. </span><span class="koboSpan" id="kobo.499.3">As you maintain your framework, you can expect to receive security bugs and patches that address security vulnerabilities. </span><span class="koboSpan" id="kobo.499.4">The bug </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.500.1">bounty programs websites, such as </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">HackerOne</span></strong><span class="koboSpan" id="kobo.502.1"> (</span><a href="https://hackerone.com"><span class="koboSpan" id="kobo.503.1">hackerone.com</span></a><span class="koboSpan" id="kobo.504.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">Huntr</span></strong><span class="koboSpan" id="kobo.506.1"> (</span><a href="https://huntr.dev"><span class="koboSpan" id="kobo.507.1">huntr.dev</span></a><span class="koboSpan" id="kobo.508.1">), focus on protecting </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.509.1">software and can reach out with vulnerability reports filed against your framework. </span><span class="koboSpan" id="kobo.509.2">Both internal and open source frameworks can receive reports, and as a maintainer, the expectation is to fix the known vulnerabilities to maintain a strong </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">security posture.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">The vulnerabilities </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.512.1">that are created could be assigned a </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Common Vulnerabilities and Exposures</span></strong><span class="koboSpan" id="kobo.514.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.515.1">CVE</span></strong><span class="koboSpan" id="kobo.516.1">) identifier. </span><span class="koboSpan" id="kobo.516.2">For example, look at Electron’s </span><em class="italic"><span class="koboSpan" id="kobo.517.1">CVE-2022-29247</span></em><span class="koboSpan" id="kobo.518.1"> (</span><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-29247"><span class="koboSpan" id="kobo.519.1">nvd.nist.gov/vuln/detail/CVE-2022-29247</span></a><span class="koboSpan" id="kobo.520.1">), which reports a vulnerability in the framework’s process communication. </span><span class="koboSpan" id="kobo.520.2">It outlines the fixed versions of the framework and the </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">risk score.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">To stay on the offensive and reduce the risk of vulnerability, you can follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">following strategies:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.524.1">Document dangerous APIs</span></strong><span class="koboSpan" id="kobo.525.1">: Invest time in writing up documentation to highlight potential APIs that can present danger when misused. </span><span class="koboSpan" id="kobo.525.2">In a server framework, this can involve explaining how to protect against dangerous request payloads. </span><span class="koboSpan" id="kobo.525.3">In the frontend, issues can result from unsafely rendering HTML or failure to sanitize URLs or other types of input. </span><span class="koboSpan" id="kobo.525.4">For instance, the Vue.js project has a best practices guide that includes information on this topic: </span><a href="https://vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you"><span class="koboSpan" id="kobo.526.1">vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you</span></a><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">This strategy also applies to non-application frameworks </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">as well.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.529.1">Security audits</span></strong><span class="koboSpan" id="kobo.530.1">: These types of audits can help run a framework against common attack vectors or specific vulnerabilities that can affect the framework feature set. </span><span class="koboSpan" id="kobo.530.2">During this process, your code can be audited by an internal security team or a third party to find potential issues. </span><span class="koboSpan" id="kobo.530.3">The goal is to find attack vectors that could make your framework cause harm even when used properly. </span><span class="koboSpan" id="kobo.530.4">For application-level </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.531.1">frameworks, there exists the </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">OWASP Application Security Verification Standard</span></strong><span class="koboSpan" id="kobo.533.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.534.1">ASVS</span></strong><span class="koboSpan" id="kobo.535.1">), which outlines 70+ pages of technical security controls to ensure secure development. </span><span class="koboSpan" id="kobo.535.2">These controls can be found in several languages </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">at </span></span><a href="https://owasp.org/www-project-application-security-verification-standard"><span class="No-Break"><span class="koboSpan" id="kobo.537.1">owasp.org/www-project-application-security-verification-standard</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.538.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.539.1">Update dependencies</span></strong><span class="koboSpan" id="kobo.540.1">: Relying on external modules and libraries introduces security risks </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.541.1">when vulnerabilities get discovered in the underlying code. </span><span class="koboSpan" id="kobo.541.2">From what we have seen in Componium and other JavaScript frameworks, there are a lot of external dependencies that projects count on. </span><span class="koboSpan" id="kobo.541.3">Recently, more and more security scanners, such as Socket (</span><a href="https://socket.dev"><span class="koboSpan" id="kobo.542.1">socket.dev</span></a><span class="koboSpan" id="kobo.543.1">) and Dependabot (</span><a href="https://github.com/features/security"><span class="koboSpan" id="kobo.544.1">github.com/features/security</span></a><span class="koboSpan" id="kobo.545.1">), have become available to track down JavaScript vulnerabilities in particular and inform the maintainers to fix them. </span><span class="koboSpan" id="kobo.545.2">However, these scanners cannot fix the issues and create releases, so it is still up to framework developers to keep up with all the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">dependency updates.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.547.1">Define a security policy</span></strong><span class="koboSpan" id="kobo.548.1">: Creating a security policy can outline how security issues are reported against your project and provide guidelines to contact maintainers to fix particular issues. </span><span class="koboSpan" id="kobo.548.2">Many frameworks from </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.550.1"> define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">SECURITY.md</span></strong><span class="koboSpan" id="kobo.552.1"> file, where the security policy is documented. </span><span class="koboSpan" id="kobo.552.2">It can usually be found in the root directory of the project; the one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">express.js</span></strong><span class="koboSpan" id="kobo.554.1"> project is </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">at </span></span><a href="https://github.com/expressjs/express/blob/master/Security.md"><span class="No-Break"><span class="koboSpan" id="kobo.556.1">github.com/expressjs/express/blob/master/Security.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.558.1">There is always a lot to keep track of in terms of framework security maintenance, but even investing a bit of time into the security posture can help reduce your burden and improve sufficiently benefit your project. </span><span class="koboSpan" id="kobo.558.2">Keeping up with security tasks is also relevant for the dependencies </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.559.1">of your project. </span><span class="koboSpan" id="kobo.559.2">The next section focuses on managing the dependencies that can affect your project in different ways, including the security aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">the project.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.561.1">Dependencies</span></h2>
<p><span class="koboSpan" id="kobo.562.1">In the long term, managing the dependencies of a JavaScript framework can be a very involved task. </span><span class="koboSpan" id="kobo.562.2">The libraries and modules that are relied upon can become outdated or unmaintained, and this </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.563.1">goes beyond being affected by security issues. </span><span class="koboSpan" id="kobo.563.2">As an ecosystem moves forward, framework developers need to keep an eye on some of the stale modules that are used internally. </span><span class="koboSpan" id="kobo.563.3">The lack of updates to dependencies can be limiting when a lingering bug fix depends on a component outside of the framework code base. </span><span class="koboSpan" id="kobo.563.4">If the dependent package is fully abandoned, creating your own copy and attempting to fix the issue is a good idea. </span><span class="koboSpan" id="kobo.563.5">The other option is to migrate to a similar package or rewrite it independently. </span><span class="koboSpan" id="kobo.563.6">Dependencies can also break compatibility in some way, and it will be a maintenance task for the framework author to refactor the usage of that module to </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">restore compatibility.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">A more positive turn of events can be additional features being added to the libraries that are used within a framework project. </span><span class="koboSpan" id="kobo.565.2">In such cases, the project and its users can benefit from the improvements. </span><span class="koboSpan" id="kobo.565.3">These enhancements can come with the addition of new, exciting features or potential </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">performance optimizations.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.567.1"><img alt="Figure 9.4: Running npm-check-updates" src="image/Figure_9.4_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.568.1">Figure 9.4: Running npm-check-updates</span></p>
<p><span class="koboSpan" id="kobo.569.1">We can count on some dependency management tooling to keep track of dependencies for us. </span><span class="koboSpan" id="kobo.569.2">For </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.570.1">example, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.571.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.572.1">.4</span></em><span class="koboSpan" id="kobo.573.1"> shows the </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">npm-check-updates</span></strong><span class="koboSpan" id="kobo.575.1"> (</span><a href="https://npmjs.com/package/npm-check-updates"><span class="koboSpan" id="kobo.576.1">npmjs.com/package/npm-check-updates</span></a><span class="koboSpan" id="kobo.577.1">) tool running via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">ncu</span></strong><span class="koboSpan" id="kobo.579.1"> command line, which tracks down some of the dependencies that have newer versions. </span><span class="koboSpan" id="kobo.579.2">Alternatively, automated CI tools can also produce a </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">similar report.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Due to the </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.582.1">nature of the ecosystem, keeping track of dependencies in JavaScript projects is especially hard, so having a certain strategy, either through using tools or minimizing the number of dependencies, can be quite useful for a framework project of </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">any size.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Dependency management fits into the larger theme of feature coverage. </span><span class="koboSpan" id="kobo.584.2">As a project progresses, framework designers alter how features are structured and remove the unused ones. </span><span class="koboSpan" id="kobo.584.3">This is something every maintainer needs to consider for the long-term strategy of their </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">framework project.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.586.1">Feature coverage and deprecation</span></h2>
<p><span class="koboSpan" id="kobo.587.1">Earlier, in the </span><em class="italic"><span class="koboSpan" id="kobo.588.1">Development cycle</span></em><span class="koboSpan" id="kobo.589.1"> part of the chapter, we used the SDLC and defined processes to drive feature development. </span><span class="koboSpan" id="kobo.589.2">With the long-term outlook of a framework project, it is useful to keep a good coverage of features that are practical and features that are not </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.590.1">used by any stakeholders. </span><span class="koboSpan" id="kobo.590.2">When we consider user feedback, we also need to make sure that a feature is worth adding from a long-term maintenance point of view. </span><span class="koboSpan" id="kobo.590.3">This is where it is worth considering the quick wins of adding more features versus the project’s long-term vision. </span><span class="koboSpan" id="kobo.590.4">In a similar fashion, deprecating features of a framework might mean cleaning up the less relevant components. </span><span class="koboSpan" id="kobo.590.5">Usually, this would involve a lengthy process of creating a migration path for existing users and providing an alternative solution. </span><span class="koboSpan" id="kobo.590.6">Otherwise, the project would lose some of its credibility over time. </span><span class="koboSpan" id="kobo.590.7">To avoid expanding the hurdles of complex feature management, frameworks create extension interfaces that allow for feature expansion without bloating up the core functionality. </span><span class="koboSpan" id="kobo.590.8">We have seen examples of this in several projects. </span><span class="koboSpan" id="kobo.590.9">For instance, the Componium server allows custom middleware functions to intercept the requests based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">express.js</span></strong><span class="koboSpan" id="kobo.592.1"> behavior. </span><span class="koboSpan" id="kobo.592.2">Vue.js is a frontend framework example that offers a plugin interface for functionality, which cannot be bundled in the core </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">framework: </span></span><a href="https://vuejs.org/guide/reusability/plugins.html"><span class="No-Break"><span class="koboSpan" id="kobo.594.1">vuejs.org/guide/reusability/plugins.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.595.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Performance optimizations are a type of feature optimization that often end up spanning over a long term. </span><span class="koboSpan" id="kobo.596.2">Frameworks may find bottlenecks or slowdowns through user feedback or particular use cases. </span><span class="koboSpan" id="kobo.596.3">This is where performance initiatives, which span many releases and large refactorings, can be useful to develop a more </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">optimized product.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">In this section, we covered some of the long-term issues and tasks that may come up during the </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.599.1">lifespan of frameworks. </span><span class="koboSpan" id="kobo.599.2">Other maintenance undertakings that we did not cover could be solved by familiar patterns, including introducing particular tooling, utilizing an external service, or relying on existing software methodologies to reduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">maintenance burden.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.601.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.602.1">In this chapter on framework maintenance, we learned and reviewed some new and familiar topics – the development cycle, the release process, and maintenance tasks. </span><span class="koboSpan" id="kobo.602.2">These three topics enable us to successfully maintain a JavaScript software project over long periods of time. </span><span class="koboSpan" id="kobo.602.3">Part of the reason we dived into the details of these subjects is to enable you to create your own maintenance workflow, with your choice of tools </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">and techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">When we looked at the steps of the development cycle, we scoped it down to the specificities of JavaScript framework development. </span><span class="koboSpan" id="kobo.604.2">Alongside that topic, we learned about the RFC process and found ways to get valuable feedback from the users of our frameworks. </span><span class="koboSpan" id="kobo.604.3">Furthermore, we focused on the release process, which included learning about structuring our approach to versioning, licensing, documentation, and so on. </span><span class="koboSpan" id="kobo.604.4">Finally, the long-term maintenance tasks included preparing for events that occurred previously in other JavaScript projects. </span><span class="koboSpan" id="kobo.604.5">These included topics such as dependency management, dealing with security incidents, and handling </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">out-of-date features.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">Overall, we have captured the essence of framework maintenance, and this should give you a good foundation to explore the other aspects of maintenance that are present in other projects. </span><span class="koboSpan" id="kobo.606.2">I encourage you to examine other frameworks. </span><span class="koboSpan" id="kobo.606.3">For instance, by looking at the open source frameworks from </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.607.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.608.1">, you can find other examples of tools and techniques used in the maintenance of </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">those projects.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">In the next and final chapter, we shall circle back to all the key fundamentals from this book and conclude our JavaScript development adventure by discussing the best practices of </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">this topic.</span></span></p>
</div>
</body></html>