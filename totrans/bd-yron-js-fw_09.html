<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor156"/>9</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Framework Maintenance</h1>
<p>In our framework development journey, we have reached the point where we can discuss framework maintenance in detail. So far, we have completed an initial version of the full stack framework in the previous chapters.</p>
<p>In this chapter, the framework maintenance topics will guide you toward future frameworks to develop. These are the topics related to the framework release process, the continuous development cycles, and, finally, the long-term maintenance of large framework projects. In more detail about framework maintenance, we shall learn about the following:</p>
<ul>
<li><strong class="bold">Development cycle</strong>: We’ll learn about the concepts and paradigms that help develop formal <a id="_idIndexMarker601"/>feature definitions and figure out how to seek framework user feedback. First, we shall recap the analysis and design steps of the framework development process. Then, we’ll move on to formal feature definitions, as well as ways to seek user feedback and keep these users informed about changes in the framework. Being adept at these concepts will help you keep your framework relevant, user-friendly, and competitive.</li>
<li><strong class="bold">Release process</strong>: Getting accustomed to the release process involves several logistical tasks, such as <a id="_idIndexMarker602"/>defining the versioning and licensing terms, combined with a pipeline that can release and deliver your project to the public. This entails creating automated pipelines to build, test, and deploy your framework. This process also teaches you how to smoothly transition from code completion to a published product that users can easily adopt and benefit from.</li>
<li><strong class="bold">Long-term maintenance</strong>: This part revolves around broader aspects that extend beyond <a id="_idIndexMarker603"/>typical coding tasks. The long-term framework management tasks include monitoring a project’s health, keeping it secure, managing dependencies, and making necessary improvements.</li>
</ul>
<p>Understanding these three aspects – the development cycle, the release process, and long-term maintenance – will significantly enhance the success of the frameworks you build and maintain. It will ensure that your project stays relevant, secure, and robust and is of the highest quality, ultimately leading to a better response from its stakeholders.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Technical requirements</h1>
<p>Just like in the other chapters, we will continue to use the repository at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. The <code>chapter9</code> directory for this chapter consists of several sample projects that showcase tools related to framework maintenance. Most of these have a similar structure to a common Node.js project. For each child directory in <code>chapter9</code>, you can explore the maintenance tool examples. Refer to the <code>chapter9/README.md</code> files for extra information about the included projects.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>The development cycle</h1>
<p>To better <a id="_idIndexMarker604"/>understand the framework maintenance tasks, we will rely on the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>) to partition some of the important <a id="_idIndexMarker605"/>milestones of our framework development, such as building features and releasing them for your stakeholders. Our goal is to take the broad themes of SDLC and apply them to our framework projects, focusing on specific examples that will help you build better projects.</p>
<div><div><img alt="Figure 9.1: The software development life cycle" src="img/Figure_9.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The software development life cycle</p>
<p><em class="italic">Figure 9</em><em class="italic">.1</em> shows a simplified diagram of the SDLC, which we can apply to our framework projects. In this book, we have performed these steps in detail, except we need to focus further on the <strong class="bold">Deployment</strong> and <strong class="bold">Maintenance</strong> steps to complete the cycle. We have taken care of the first <strong class="bold">Analysis</strong> step by learning about the organization of other frameworks and planning out each large portion of the <em class="italic">Componium</em> full stack framework. We have <a id="_idIndexMarker606"/>performed useful examinations of the existing abstractions, popular patterns, and types of frameworks in <em class="italic">Chapters 2 and 3</em>. To further reinforce this <strong class="bold">Analysis</strong> step, we brainstormed with potential stakeholders and the feature set of the testing, backend, and frontend parts of <em class="italic">Componium</em>. In this chapter, we will look at other strategies that help framework developers make framework projects more successful.</p>
<p class="callout-heading">About SDLC</p>
<p class="callout">The <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>), in some cases also called the <strong class="bold">Systems Development Life cycle</strong>, is a term that originated in the 1960s. At the time, it was <a id="_idIndexMarker607"/>used to help develop complex business systems. Later, it was used further in software projects, combined with different development models such as waterfall. This term defines the systematic process of building large systems and software, providing the methodology for a development process, and focusing on quality and programming efficiency.</p>
<p class="callout">Software developers usually use this model as a foundation and evolve their approach to building software, based on what works works better in their organization. The introduction of agile software development methods is an extension of an approach to SDLC. In the instance of JavaScript application development, development teams can use these life cycle concepts to build new projects, with the use of framework tooling and libraries. Simultaneously, framework developers can also rely on the SDLC methodology to craft a high-quality, performant framework experience.</p>
<p>The <strong class="bold">Design</strong> stage, following the <strong class="bold">Analysis</strong> step, is what we discussed in when building a framework in <em class="italic">Chapters 6</em>,<em class="italic"> 7</em>, and <em class="italic">8</em>, and it outlines the architecture parts of a framework. This is where framework authors focus on bridging the gap between requirements and the start of writing code. The <strong class="bold">Design</strong> step is particularly interesting when working with the JavaScript ecosystem. Due to the multifaceted nature of web development, including different aspects of JavaScript, runtimes, and web APIs, there is an opportunity to create innovative design approaches, combining the existing and newly built components. For example, in <em class="italic">Chapters 6</em>, <em class="italic">7</em>, and <em class="italic">8</em>, we had to make careful decisions about the combination of abstractions and the choice of libraries that we intended to use within the full stack framework. Going beyond the choice of libraries, the elements of the <strong class="bold">Design</strong> stage require making concrete decisions about the combination of technologies that will be used in the framework projects and how these technologies communicate together. This is where we strike a balance of strong opinions versus a flexible framework.</p>
<p>However, the whole concept of the SDLC process is a <em class="italic">cycle</em>, which means the design decisions will return <a id="_idIndexMarker608"/>to a developer in a cyclical manner. This conveys that not all decisions are set in stone and can be changed over time as a project progresses. However, some decisions are harder to change than others. For example, changing the API structure in the <em class="italic">Componium</em> testing framework will require all the consumers of the framework to rewrite or migrate their tests to a newer API. Most likely, the API change is for the benefit of the framework and its users, but it still creates friction for the projects utilizing the framework. This can result in framework users being stuck on certain versions of the project or moving off to use something else entirely.</p>
<p>As a framework developer, you will reach the <strong class="bold">Design</strong> stage again after a project’s initial release. When that happens, the framework SDLC will be more narrowly focused on feature development and larger refactoring of code. In the real world, an example of this stage would be in the Vue.js project. The major versions of Vue.js introduced changes to the renderer, made it easier to work with template directives, and changed the API of components. More details on that migration can be found at <a href="https://v3-migration.vuejs.org/breaking-changes">v3-migration.vuejs.org/breaking-changes</a>. With cases like these, the framework authors go back to the drawing board or find ways to drastically redesign certain public-facing and underlying structures of a framework.</p>
<p>This cycle of coming back to the <strong class="bold">Design</strong> stage is common in the evolution of a framework, particularly when it’s in active development or has a thriving user base. While potentially disruptive to the existing users, this iterative process is key to the framework’s long-term success and sustainability. Frameworks that fail to adapt or evolve can quickly become outdated and lose relevance. Consider the evolution of the Angular framework project. A complete rewrite was undertaken in its evolution from AngularJS to modern versions of Angular. While initially disruptive to the developers, this transition allowed the framework to modernize its architecture and take advantage of the latest JavaScript features. It also set the foundation for a more future-proof growth path, ensuring Angular’s position as one of the top frontend JavaScript frameworks.</p>
<p>Another area where the <strong class="bold">Design</strong> stage reoccurs is the introduction of performance improvements, specifically those affecting JavaScript projects. Given the nature of the JavaScript language and ever-evolving web technologies, performance optimization is often an ongoing endeavor. The team behind the React library has consistently revisited its design phase to <a id="_idIndexMarker609"/>make performance improvements, leading to significant enhancements such as the introduction of Hooks, concurrent mode, and the new JSX transform. The SDLC <strong class="bold">Design</strong> stage keeps you busy, as it is a continuous activity that enables a framework to stay relevant, performant, and useful to its users. The key is handling these design changes in such a way that it minimizes disruptions and provides clear paths for users to adapt to the changes. Continuing on a similar theme, in the following sections, we will learn more about what framework authors can do to safely implement and maintain new features.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Seeking user feedback</h2>
<p>One of the most exciting parts of framework development is getting some stakeholders to use what you have developed. These stakeholders could be teams within your company, external <a id="_idIndexMarker610"/>open source users, or even your own team. The framework product that you produce needs an efficient feedback loop. This loop will consist of finding ways to get the best feedback you can from as many stakeholders as possible. After successfully acquiring the required input, a framework developer can outline the required changes to adapt to that feedback. These changes can include fixes to issues, the addition of new features, improvement of the developer experience, or overall organizational tweaks. Once these changes are in place, we reach another exciting part of the framework development process – delivering the newly updated version of the framework to the users.</p>
<p>In this part of the chapter, let's focus on the first part of seeking user feedback, which is properly gathering feedback. Depending on the scale of your project and organization, you may end up interacting with large groups of stakeholders or having a one-on-one interaction with just a few users. For larger groups, it is beneficial to utilize a system that can facilitate discussion and the ability to have different discussions related to various aspects of a framework. The most simplistic approach is to maintain an issue or feature request tracking system. This is very similar to other software projects, but with a framework, investing more time in managing the aspects of this system is more important. With a framework, you want to be able to clearly separate the issue and feature discussions, slating the feedback for different releases of the project.</p>
<p>The framework can also provide opportunities to direct feedback to the right place. For instance, gathering developer feedback can be embedded within the developer experience of a project. This is where the executable that developers use daily can provide links to the feature request tracker. In <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, the <code>componium</code> executable had mechanisms to generate scaffolding of certain common components, and the feedback direction could be built right into that executable. Overall, you must rely on tools and systems <a id="_idIndexMarker611"/>to gather feedback and avoid spending too much time manually managing all of it. Most importantly, it is important to be respectful of all types of feedback. In some cases, the features built and described within a framework may not work well for some stakeholders. Therefore, it is essential to appreciate each piece of feedback as a unique perspective that brings with it the prospect of innovation and expansion of your project. In the next part, we will discuss a formal feature definition process that worked well across open source and private framework projects.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Formal feature definition</h2>
<p>The <strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) and <strong class="bold">Request for Proposals</strong> (<strong class="bold">RFP</strong>) processes are commonly used across many industries to define new features or get feedback. These same <a id="_idIndexMarker612"/>processes work really well in software framework development as well. Many frameworks have implemented their own approach <a id="_idIndexMarker613"/>to this process of formal feature definition, with stakeholder feedback built in. For example, Ember.js hosts its RFCs at <a href="https://github.com/emberjs/rfcs">github.com/emberjs/rfcs</a>, and Vue.js hosts RFCs at <a href="https://github.com/vuejs/rfcs">github.com/vuejs/rfcs</a>, keeping track of all new, pending, and archived proposals for feature additions and drastic changes to <a id="_idIndexMarker614"/>the project. With the open source <a id="_idIndexMarker615"/>nature of those frameworks, anyone can chime in as new feature proposals arrive in those repositories. The proposals get reviewed in a similar manner to code contributions. Conveniently, these feature definitions are stored in a code repository so that they can be logged and referenced in the future.</p>
<p>Including a process for formal feature definition helps organize both framework developers and <a id="_idIndexMarker616"/>users to participate in the <strong class="bold">Design</strong> stage of the <strong class="bold">Framework Development Lifecycle</strong> (<strong class="bold">FDLC</strong>). As a framework developer, you are free to choose how involved this process can be. For example, if we added a new feature to Componium to get native WebSocket support, we could create an RFC explaining the gist of the feature, propose an API for it, and state why it would be beneficial to the full stack framework overall. Depending on the complexity of <a id="_idIndexMarker617"/>our organization, the proposal to add this particular feature can transition through the following stages:</p>
<ul>
<li><strong class="bold">Proposed</strong>: When the new WebSocket feature is described in full detail. At this stage, other framework developers and potential stakeholders get the opportunity to provide initial feedback. In our example, this is where the public API, frontend and backend integration, and the coverage of the WebSocket feature are proposed.</li>
<li><strong class="bold">Exploring</strong>: The stage where framework developers get to explore technical prototypes and explore the potential architecture of the feature. During this stage, implementation details can be refined. For a framework project, it is also a good idea to share the feature with the teams that have a stake in the framework to seek further feedback.</li>
<li><strong class="bold">Accepted</strong>: If the feature is deemed sufficient, then the framework can proceed with the implementation and merge the code into the main code base at this stage.</li>
<li><strong class="bold">Ready for release</strong>: The pre-release <a id="_idIndexMarker618"/>stage is a good opportunity to create a new <strong class="bold">release candidate</strong> (<strong class="bold">RC</strong>) for the latest improvements to the framework. There is another opportunity to get useful feedback on how the feature works with the existing projects and integrations. In terms of maintenance, user documentation can be introduced.</li>
<li><strong class="bold">Released</strong>: The final stage is where the feature is launched and made available. This is the point at which the RFC can finally be tagged as complete and released. Future proposals can also reference this feature to help with feedback and the technical architecture.</li>
</ul>
<p>Having a formal process like this helps structure a well-organized approach to feature development and user feedback. However, it is worth noting that many features can get stuck at the <strong class="bold">Proposal</strong> and <strong class="bold">Exploration</strong> stages.</p>
<p>A real-world example of a simple RFC that was accepted and merged is the removal of Internet Explorer 11 support in Vue.js: <a href="https://github.com/vuejs/rfcs/pull/294/files">github.com/vuejs/rfcs/pull/294/files</a>. The documentation mentions the motivation behind the change, including the concerns about the maintenance burden and how the change affected the consumers of the framework. Over 50 replies were contributed to the discussion thread of that proposal, including members of the framework’s core team and other developers passionate about the change.</p>
<p>The RFP process can work in a similar way to trigger interest or a bid from another entity to help contribute to the framework. If there is some feature that you would like to add to your framework but are not able to, then through this process, you can find a vendor that will do it for you. This process is more common in corporate proprietary environments.</p>
<p>Both of these <a id="_idIndexMarker619"/>approaches create a structure around feature development and help us follow the SDLC in our own way that fits well with the project. As your <a id="_idIndexMarker620"/>framework evolves and develops, you might choose to tweak how these formal feature definition processes perform best for your needs.</p>
<p>With the feature development cycle in place, in the next section, we can now highlight the ways a JavaScript framework approaches the release process, including providing the ability to report to its stakeholders about all the new improvements and features shipping in the new versions.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Release process</h1>
<p>In the SDLC diagram in <em class="italic">Figure 9</em><em class="italic">.1</em>, the <strong class="bold">Deployment</strong> step signifies when software can be utilized by consumers. In the context of framework development, this means a new release that <a id="_idIndexMarker621"/>is made available. This is where newly crafted features become available, and to make them available, developers need to go through the <strong class="bold">release process</strong>. In this part of the chapter, we shall explore the topics related to the initial and subsequent release of JavaScript framework projects. This will include showcasing some of the existing tools, licensing options, versioning, and continuous delivery. To follow the <em class="italic">The development cycle</em> section, where we discussed the introduction of new features, we will begin by learning how to keep everyone informed of the changes to a framework. Later, the <em class="italic">Simplifying releases</em> section will discuss the opportunities to make the release chores more approachable.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Change logs</h2>
<p>Framework developers already have to spend a lot of time planning, architecting, and developing features. Luckily, for the final step of releasing those features, the process of collecting the <a id="_idIndexMarker622"/>details of all the newly built framework components can be standardized and automated. To make this happen, projects rely on existing tooling, such as release utilities and change log generation tools, to support publishing new <a id="_idIndexMarker623"/>releases of a framework. The first thing that is useful to maintain and generate is a log of changes in every release. The change log is useful in any framework setting and should be the way you communicate with stakeholders about the impact of every new release.</p>
<p>Here are some good examples of change log structures from other popular projects:</p>
<ul>
<li><strong class="bold">Electron</strong>: The application framework project hosts its change log at <a href="https://releases.electronjs.org/releases/stable">releases.electronjs.org/releases/stable</a>, with very detailed information on changes in <a id="_idIndexMarker624"/>stable releases and upcoming pre-releases. It gives you the ability to filter by major framework versions and integrates with landed code by linking directly to the source at GitHub. The calendar <a id="_idIndexMarker625"/>of releases at <a href="https://releases.electronjs.org/history">releases.electronjs.org/history</a> also provides a great visual of all the newly tagged versions. This example could be overkill for a newly created framework but works well for an established project with a large user base.</li>
<li><code>changesets</code> automation tool.</li>
<li><strong class="bold">Next.js</strong>: The framework <a id="_idIndexMarker628"/>uses the <em class="italic">GitHub Releases</em> feature to <a id="_idIndexMarker629"/>outline the changes in <a href="https://github.com/vercel/next.js/">github.com/vercel/next.js/</a> releases. Using GitHub’s interface allows the project to document the changes, including the contributors, assets, and source code on the same page. GitHub’s tooling allows you to run comparisons across releases to get a series of commits that have changed from a previous release. The creation of the change log itself is done with manual scripts within the framework at <a href="https://github.com/vercel/next.js/blob/canary/release.js">github.com/vercel/next.js/blob/canary/release.js</a>. These scripts are automated using <em class="italic">GitHub Actions</em> when triggered by framework maintainers.</li>
</ul>
<p>The common <a id="_idIndexMarker630"/>theme around these change logs is that, often, the change logs are automatically generated, based on certain code commit message structures <a id="_idIndexMarker631"/>and with the use of different automated tools, which are published for users to browse through. Depending on your requirements, you can benefit from the following tools or similar in your JavaScript framework projects:</p>
<ul>
<li><code>&lt;type&gt;(&lt;scope&gt;): &lt;summary&gt;</code>. These conventions either become more complex or simpler, depending on the choice of the framework developer.</li>
<li><strong class="bold">commitlint</strong> (<a href="https://github.com/conventional-changelog/commitlint">github.com/conventional-changelog/commitlint</a>): Another tool that helps <a id="_idIndexMarker633"/>validate the commit message structure and adheres to a certain commit convention. It is capable of validating the messages as strings through an interactive CLI or programmatic usage.</li>
<li><strong class="bold">Changesets</strong> (<a href="https://github.com/changesets/changesets">github.com/changesets/changesets</a>): A more involved solution to <a id="_idIndexMarker634"/>generate change sets for simple and multi-package code bases. This helps when a framework is spread across many sources.</li>
</ul>
<p>After you look into using these tools for your framework projects, you will find that there are common themes to all of them. Most of the time, these tools have different approaches to configuration and structures. However, with so many options to choose from, using any of <a id="_idIndexMarker635"/>these can help you save time by providing important <a id="_idIndexMarker636"/>information about the progress of your framework to your users. For instance, the Ember.js project has an easy-to-follow change log (<a href="https://github.com/emberjs/ember.js/blob/main/CHANGELOG.md">github.com/emberjs/ember.js/blob/main/CHANGELOG.md</a>) that helps developers keep up with updates. If you explore some of the change logs, including the Ember.js one, you will see different types of versioning that are maintained throughout the development cycle, which is what we will cover in the following section.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>Versioning</h2>
<p>Maintaining proper versioning for your framework can be a challenge. Keeping proper versioning schemes <a id="_idIndexMarker637"/>helps stakeholders understand the compatibility of their code with new iterations of the framework. If a project is properly versioned and is <a id="_idIndexMarker638"/>strict in defining its versions, then downstream consumers can be confident when they update the framework dependency. Any changes in the upstream framework versions can cause breakages in the existing components and cause havoc in the already-built applications. There are many cases, especially in older software, where framework users are asked to be cautious updating to the latest versions of a framework, even if projects are known to have security vulnerabilities. Some examples include drastic changes from AngularJS to modern versions of Angular or major version changes <a id="_idIndexMarker639"/>of JavaScript tooling, such as <strong class="bold">webpack</strong>. In addition, if a project frequently breaks a versioning contract, then the users of the framework will slow down their upgrade cycles and potentially avoid using particular projects in the future.</p>
<p>Luckily, the software <a id="_idIndexMarker640"/>community has created standards around <a id="_idIndexMarker641"/>versioning, such as <strong class="bold">SemVer</strong> (<a href="https://semver.org">semver.org</a>) and <strong class="bold">Calendar Versioning</strong> (<strong class="bold">CalVer</strong>) (<a href="https://calver.org">calver.org</a>), which can help define proper versioning contracts. These standards can help define the framework release process and should be documented somewhere in the framework documentation.</p>
<div><div><img alt="Figure 9.2: Semantic versioning" src="img/Figure_9.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Semantic versioning</p>
<p><strong class="bold">Semantic versioning</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.2</em>, is the most common system adopted across many <a id="_idIndexMarker642"/>projects nowadays. It consists of three required and one optional components:</p>
<ul>
<li>First, we have the <strong class="bold">Major</strong> version, which signifies changes that are incompatible if a user <a id="_idIndexMarker643"/>updates from an earlier major version</li>
<li>The <strong class="bold">Minor</strong> version means new features are available, and the release is still backward-compatible with earlier versions</li>
<li>The last required component is the <strong class="bold">Patch</strong> version, which means that there a bug fixes that are also backward-compatible with earlier versions</li>
<li>The <strong class="bold">Optional</strong> component toward the end of the version can consist of pre-release names, with the addition of metadata or build numbers</li>
</ul>
<p>The <code>semantic-release</code> (<a href="https://npmjs.com/package/semantic-release">npmjs.com/package/semantic-release</a>) package uses SemVer and attempts <a id="_idIndexMarker644"/>to simplify versioning for JavaScript projects by utilizing the code base commit history, determining whether a version of the project should be a <em class="italic">major</em>, <em class="italic">minor</em>, or a <em class="italic">patch</em> release. It works as a utility during an automated release step.</p>
<p>The alternative CalVer format defines its structure using dates in the <code>YYYY.MM.DD</code> format. It can be useful if project releases are based on the calendar year. Ultimately, the framework <a id="_idIndexMarker645"/>maintainer decides the set version, and it is a big responsibility to correctly set these versions and ensure that downstream users do not have their application builds broken.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Simplifying releases</h2>
<p>So far, we have seen many tools that automate different parts of the release process. We focused on <a id="_idIndexMarker646"/>versioning, feature feedback, and change logs. We can introduce tools to simplify our framework’s new release workflow further. This type of tooling aims to ensure that all the release process tasks are successfully executed and requires releases to be consistent across the board.</p>
<div><div><img alt="Figure 9.3: Publishing a new release" src="img/Figure_9.3_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Publishing a new release</p>
<p>Tools such as <strong class="bold">release-it</strong> (<a href="https://github.com/release-it/release-it">github.com/release-it/release-it</a>) and <strong class="bold">np</strong> (<a href="https://github.com/sindresorhus/np">github.com/sindresorhus/np</a>) make it possible to ensure that the release process goes smoothly. <em class="italic">Figure 9</em><em class="italic">.3</em> shows the np tool in action when publishing a new version of the Componium test. These tools ensure that the following tasks are completed for your project:</p>
<ul>
<li>Any prerequisite scripts are executed, which could include formatting and linting files.</li>
<li>The required release tests run and pass. If the tests fail, then the release process is aborted.</li>
<li>Bumping the version number using the maintainer choice or based on some other criteria, such as using the <em class="italic">semantic-release</em> package that we saw earlier.</li>
<li>Publishing code to a specific registry. For internal projects, this could be an internal source; for public projects, this means uploading the source code to a public registry. This will probably be the source from which the framework users get the latest code.</li>
<li>Pushing the necessary tags to the code repository with the same version number as the one published to the registry.</li>
</ul>
<p>These are just <a id="_idIndexMarker647"/>some of the steps that are generally run, but for more complex projects, many of the steps can be tweaked to accommodate the needs of the code base. Usage of these tools depends on how well they fit into your workflows. It’s a good idea to start simple and find tools that work right outside of the box. As the framework project grows, you will find yourself mixing and matching different tools to craft your own approach to the release process. For example, <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a> mentioned the <em class="italic">ng-dev</em> tool used for internal Angular development. In the internals of that tool, the team utilizes the <em class="italic">np</em> command-line tool for the release process. The <code>release-it</code> package offers some extra features, suitable for projects that live inside a mono-repo code base or require further configuration.</p>
<p class="callout-heading">Maintenance tool showcase</p>
<p class="callout">The book code repository in the <code>chapter9</code> includes a collection of tools that you can quickly try out and see how effective they are. Your framework projects can integrate the included or similar tools, thus improving the framework development workflow. The <code>chapter9/commitizen</code> directory consists of a project that uses the Commitizen package to enforce Git commit guidelines for your projects.</p>
<p class="callout">The <code>maintenance-tools</code> directory showcases several Node.js utilities used for framework maintenance. To see the available scripts, make sure to run <code>npm install</code> and then <code>npm </code><code>run dev</code>.</p>
<p>In the next section, we will reach the final milestone of the release process, which is combining the <a id="_idIndexMarker648"/>tools we have seen so far and the continuous integration environment, making it possible to publish a new release of a framework with a single click of a button.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Continuous delivery</h2>
<p>Configuring and maintaining the infrastructure for framework release and other tasks involves following <a id="_idIndexMarker649"/>best practices and adapting tools from the DevOps methodology space. This involves mixing software development tasks and IT operations to improve software releases, making them much more easily manageable. Often, integrating with DevOps systems will require learning new technical skills outside of the core technologies used in the framework that you are working on. This includes learning about the latest approaches to automation, secure release processes, and application deployment in DevOps environments.</p>
<p>These days, it is <a id="_idIndexMarker650"/>ubiquitous and effortless to set up the <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) step for software projects, and it is important to do so for framework projects. It is important to use the CI environment to make sure that the required framework tests run in an isolated environment. The CI steps also ensure code quality <a id="_idIndexMarker651"/>and help create a good framework development workflow. The <strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) pipeline is designed to deliver the framework product. It is configured alongside the CI steps to prepare the code changes to be inspected, built, and tested. These pipelines are also configured in both open source and internal environments.</p>
<p>The <strong class="bold">Delivery</strong> part ensures that maintainers can prepare new releases of a project, which includes executing the set of tools that were part of the simplified release routines. In the delivery phases, the internal development scripts can run all the relevant tasks to the release, which could include generating project documentation and publishing other artifacts. This release environment also has access to the required credentials to publish code to the relevant registries. During the delivery stages, maintainers can configure all the different types of tools that we have seen in this chapter to automate the process of publishing a new version of the framework software that is produced.</p>
<p>An example of this would be a workflow set up with <em class="italic">GitHub Actions</em> to release new versions of Next.js. These workflows can be seen executing at <a href="https://github.com/vercel/next.js/actions/workflows/trigger_release.yml">github.com/vercel/next.js/actions/workflows/trigger_release.yml</a>, triggered by the maintainers of the framework. Configuring these automated workflows will give you a massive boost <a id="_idIndexMarker652"/>in productivity, as it will avoid a lot <a id="_idIndexMarker653"/>of manual tasks. This will also give you more confidence in your product because these workflows enforce the high-quality bar for all framework maintainers.</p>
<p class="callout-heading">Continuous integration sample</p>
<p class="callout">Similar to the information shared about the maintenance tool in the <em class="italic">Simplifying releases</em> section, you can find a sample of CI configuration in the <code>chapter9/ci</code> directory. This configuration can be used for your own projects with the GitHub Actions (<a href="https://github.com/features/actions">github.com/features/actions</a>) and Circle CI (<a href="https://circleci.com">circleci.com</a>) infrastructure.</p>
<p class="callout">To test out these configurations, you can copy the files from the chapter into your own repository, where you have full access to edit the source of the project.</p>
<p>Another relevant aspect of releasing is licensing, wherein framework authors need to explain the terms of use and distribution for their creations. This is what we will discuss in the next section.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Licensing</h2>
<p>As your framework develops, you will find you need to set an appropriate license for the code base. This release <a id="_idIndexMarker654"/>procedure can apply to both internally <a id="_idIndexMarker655"/>developed projects and open source initiatives. In both cases, you can choose from many different types of license types. For private business-related projects, you can <a id="_idIndexMarker656"/>choose a <strong class="bold">proprietary license</strong>, restricting the use of the framework outside of the control of the company. This type grants exclusive ownership <a id="_idIndexMarker657"/>of the code base and internal projects. A <strong class="bold">commercial license</strong> can be useful if you want to sell or restrict the redistribution to only the users who paid for the use of your code. For example, you can find some JavaScript frameworks distributing different editions of their frameworks, such as <strong class="bold">Sencha Ext JS</strong> (<a href="https://store.sencha.com">store.sencha.com</a>), which <a id="_idIndexMarker658"/>includes community and enterprise versions. The extended enterprise versions can include more support, custom features, and dedicated developer attention.</p>
<p>For open source use cases, there are licensing options as well. The website at <a href="https://choosealicense.com">choosealicense.com</a> supports software developers and helps them figure out the needs behind open sourcing their work. You will find many popular open source projects using the following licenses:</p>
<ul>
<li><strong class="bold">MIT</strong>: This is a very <a id="_idIndexMarker659"/>permissive license that allows commercial use, distribution, modification, and private use. It’s based on the conditions that you retain copyright notices and avoid any liability or warranty from your code.</li>
<li><strong class="bold">The GNU General Public License (GPL)</strong>: This is a copyleft license that offers <a id="_idIndexMarker660"/>similar commercial permissions to the MIT license but is more detailed around patent and distribution rules. However, with this license, there are conditions for disclosing the source code.</li>
<li><strong class="bold">Apache License 2.0</strong>: This is a permissive license similar to MIT but with additional <a id="_idIndexMarker661"/>limitations on trademarks and providing patent use cases. If anyone changes the code of your framework under the Apache license, then they need to declare the changes.</li>
</ul>
<p>As a framework author, it is important to decide on the license that all contributors will adhere to while <a id="_idIndexMarker662"/>contributing to a project. The process of changing <a id="_idIndexMarker663"/>the licenses down the road takes quite a bit of effort because all the contributors have to re-license their code under the new license. It is also important to remember the license types of libraries you use within your framework.</p>
<p>This concludes the section on release process items, which included gathering feedback, notifying users of new releases, and helping optimize those releases. Now, we are ready to move on to additional topics of maintenance that focus on the long term.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/>Long-term maintenance</h1>
<p>So far in this chapter, we have looked at maintenance tasks that occur as a framework progresses <a id="_idIndexMarker664"/>through the development life cycle, covering topics around the initial or following feature updates. However, there are additional unique aspects of framework development that are part of the longer-term upkeep. To focus on a few, we will explore the topics of security, dependency management, evolving feature compatibility, and more.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Security</h2>
<p>The approach to web application security has changed in recent years. More tools and solutions are now <a id="_idIndexMarker665"/>available in the security space that try to protect the whole development workflow. When users choose a framework to suit their needs, they also have certain security expectations from it, especially if the framework is built for purposes that handle critical data and user input. As you maintain your framework, you can expect to receive security bugs and patches that address security vulnerabilities. The bug <a id="_idIndexMarker666"/>bounty programs websites, such as <strong class="bold">HackerOne</strong> (<a href="https://hackerone.com">hackerone.com</a>) and <strong class="bold">Huntr</strong> (<a href="https://huntr.dev">huntr.dev</a>), focus on protecting <a id="_idIndexMarker667"/>software and can reach out with vulnerability reports filed against your framework. Both internal and open source frameworks can receive reports, and as a maintainer, the expectation is to fix the known vulnerabilities to maintain a strong security posture.</p>
<p>The vulnerabilities <a id="_idIndexMarker668"/>that are created could be assigned a <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) identifier. For example, look at Electron’s <em class="italic">CVE-2022-29247</em> (<a href="https://nvd.nist.gov/vuln/detail/CVE-2022-29247">nvd.nist.gov/vuln/detail/CVE-2022-29247</a>), which reports a vulnerability in the framework’s process communication. It outlines the fixed versions of the framework and the risk score.</p>
<p>To stay on the offensive and reduce the risk of vulnerability, you can follow the following strategies:</p>
<ul>
<li><strong class="bold">Document dangerous APIs</strong>: Invest time in writing up documentation to highlight potential APIs that can present danger when misused. In a server framework, this can involve explaining how to protect against dangerous request payloads. In the frontend, issues can result from unsafely rendering HTML or failure to sanitize URLs or other types of input. For instance, the Vue.js project has a best practices guide that includes information on this topic: <a href="https://vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you">vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you</a>. This strategy also applies to non-application frameworks as well.</li>
<li><strong class="bold">Security audits</strong>: These types of audits can help run a framework against common attack vectors or specific vulnerabilities that can affect the framework feature set. During this process, your code can be audited by an internal security team or a third party to find potential issues. The goal is to find attack vectors that could make your framework cause harm even when used properly. For application-level <a id="_idIndexMarker669"/>frameworks, there exists the <strong class="bold">OWASP Application Security Verification Standard</strong> (<strong class="bold">ASVS</strong>), which outlines 70+ pages of technical security controls to ensure secure development. These controls can be found in several languages at <a href="https://owasp.org/www-project-application-security-verification-standard">owasp.org/www-project-application-security-verification-standard</a>.</li>
<li><strong class="bold">Update dependencies</strong>: Relying on external modules and libraries introduces security risks <a id="_idIndexMarker670"/>when vulnerabilities get discovered in the underlying code. From what we have seen in Componium and other JavaScript frameworks, there are a lot of external dependencies that projects count on. Recently, more and more security scanners, such as Socket (<a href="https://socket.dev">socket.dev</a>) and Dependabot (<a href="https://github.com/features/security">github.com/features/security</a>), have become available to track down JavaScript vulnerabilities in particular and inform the maintainers to fix them. However, these scanners cannot fix the issues and create releases, so it is still up to framework developers to keep up with all the dependency updates.</li>
<li><code>SECURITY.md</code> file, where the security policy is documented. It can usually be found in the root directory of the project; the one for the <code>express.js</code> project is at <a href="https://github.com/expressjs/express/blob/master/Security.md">github.com/expressjs/express/blob/master/Security.md</a>.</li>
</ul>
<p>There is always a lot to keep track of in terms of framework security maintenance, but even investing a bit of time into the security posture can help reduce your burden and improve sufficiently benefit your project. Keeping up with security tasks is also relevant for the dependencies <a id="_idIndexMarker671"/>of your project. The next section focuses on managing the dependencies that can affect your project in different ways, including the security aspects of the project.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Dependencies</h2>
<p>In the long term, managing the dependencies of a JavaScript framework can be a very involved task. The libraries and modules that are relied upon can become outdated or unmaintained, and this <a id="_idIndexMarker672"/>goes beyond being affected by security issues. As an ecosystem moves forward, framework developers need to keep an eye on some of the stale modules that are used internally. The lack of updates to dependencies can be limiting when a lingering bug fix depends on a component outside of the framework code base. If the dependent package is fully abandoned, creating your own copy and attempting to fix the issue is a good idea. The other option is to migrate to a similar package or rewrite it independently. Dependencies can also break compatibility in some way, and it will be a maintenance task for the framework author to refactor the usage of that module to restore compatibility.</p>
<p>A more positive turn of events can be additional features being added to the libraries that are used within a framework project. In such cases, the project and its users can benefit from the improvements. These enhancements can come with the addition of new, exciting features or potential performance optimizations.</p>
<div><div><img alt="Figure 9.4: Running npm-check-updates" src="img/Figure_9.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: Running npm-check-updates</p>
<p>We can count on some dependency management tooling to keep track of dependencies for us. For <a id="_idIndexMarker673"/>example, <em class="italic">Figure 9</em><em class="italic">.4</em> shows the <code>ncu</code> command line, which tracks down some of the dependencies that have newer versions. Alternatively, automated CI tools can also produce a similar report.</p>
<p>Due to the <a id="_idIndexMarker674"/>nature of the ecosystem, keeping track of dependencies in JavaScript projects is especially hard, so having a certain strategy, either through using tools or minimizing the number of dependencies, can be quite useful for a framework project of any size.</p>
<p>Dependency management fits into the larger theme of feature coverage. As a project progresses, framework designers alter how features are structured and remove the unused ones. This is something every maintainer needs to consider for the long-term strategy of their framework project.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Feature coverage and deprecation</h2>
<p>Earlier, in the <em class="italic">Development cycle</em> part of the chapter, we used the SDLC and defined processes to drive feature development. With the long-term outlook of a framework project, it is useful to keep a good coverage of features that are practical and features that are not <a id="_idIndexMarker675"/>used by any stakeholders. When we consider user feedback, we also need to make sure that a feature is worth adding from a long-term maintenance point of view. This is where it is worth considering the quick wins of adding more features versus the project’s long-term vision. In a similar fashion, deprecating features of a framework might mean cleaning up the less relevant components. Usually, this would involve a lengthy process of creating a migration path for existing users and providing an alternative solution. Otherwise, the project would lose some of its credibility over time. To avoid expanding the hurdles of complex feature management, frameworks create extension interfaces that allow for feature expansion without bloating up the core functionality. We have seen examples of this in several projects. For instance, the Componium server allows custom middleware functions to intercept the requests based on the <code>express.js</code> behavior. Vue.js is a frontend framework example that offers a plugin interface for functionality, which cannot be bundled in the core framework: <a href="https://vuejs.org/guide/reusability/plugins.html">vuejs.org/guide/reusability/plugins.html</a>.</p>
<p>Performance optimizations are a type of feature optimization that often end up spanning over a long term. Frameworks may find bottlenecks or slowdowns through user feedback or particular use cases. This is where performance initiatives, which span many releases and large refactorings, can be useful to develop a more optimized product.</p>
<p>In this section, we covered some of the long-term issues and tasks that may come up during the <a id="_idIndexMarker676"/>lifespan of frameworks. Other maintenance undertakings that we did not cover could be solved by familiar patterns, including introducing particular tooling, utilizing an external service, or relying on existing software methodologies to reduce the maintenance burden.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Summary</h1>
<p>In this chapter on framework maintenance, we learned and reviewed some new and familiar topics – the development cycle, the release process, and maintenance tasks. These three topics enable us to successfully maintain a JavaScript software project over long periods of time. Part of the reason we dived into the details of these subjects is to enable you to create your own maintenance workflow, with your choice of tools and techniques.</p>
<p>When we looked at the steps of the development cycle, we scoped it down to the specificities of JavaScript framework development. Alongside that topic, we learned about the RFC process and found ways to get valuable feedback from the users of our frameworks. Furthermore, we focused on the release process, which included learning about structuring our approach to versioning, licensing, documentation, and so on. Finally, the long-term maintenance tasks included preparing for events that occurred previously in other JavaScript projects. These included topics such as dependency management, dealing with security incidents, and handling out-of-date features.</p>
<p>Overall, we have captured the essence of framework maintenance, and this should give you a good foundation to explore the other aspects of maintenance that are present in other projects. I encourage you to examine other frameworks. For instance, by looking at the open source frameworks from <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, you can find other examples of tools and techniques used in the maintenance of those projects.</p>
<p>In the next and final chapter, we shall circle back to all the key fundamentals from this book and conclude our JavaScript development adventure by discussing the best practices of this topic.</p>
</div>
</body></html>