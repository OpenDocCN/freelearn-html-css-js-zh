- en: Chapter 6. Webhooks and Slash Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every bot we''ve created so far shares the same two traits: they rely on commands
    issued by users and require a Slack API token. This has been very useful in our
    bots so far, but what if we want a bot to post messages to a Slack channel without
    needing an API token? Plus what if we want a bot that does not require an API
    token to interact with users? An example of this is the GitHub Slack integration,
    a service that posts GitHub activity on specific repositories to a Slack channel
    of your choice.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to use webhooks to get data in and out
    of Slack and how to create slash commands that users can interact with throughout
    Slack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incoming webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outgoing webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slash commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-channel and ephemeral responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A webhook is a way of altering or augmenting a web application through HTTP
    methods. Previously, we used third-party APIs in our bots to get data into and
    out of Slack. However, this isn't the only way. Webhooks allow us to post message
    to and from Slack using regular HTTP requests with a JSON payload. What makes
    a webhook a bot is its ability to post messages to Slack as if they are a bot
    user.
  prefs: []
  type: TYPE_NORMAL
- en: These webhooks can be divided into incoming and outgoing webhooks, each with
    their own purposes and uses.
  prefs: []
  type: TYPE_NORMAL
- en: Incoming webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example of an incoming webhook would be a service that relays information
    from an external source to a Slack channel without being explicitly requested.
    An example of this is the aforementioned GitHub Slack integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Incoming webhooks](img/B05384_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The GitHub integration posts messages about repositories we are interested in
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see how a message was sent to Slack after
    a new branch was made on a repository this team is watching. This data wasn't
    explicitly requested by a team member, but it was automatically sent to the channel
    as a result of the incoming webhook.
  prefs: []
  type: TYPE_NORMAL
- en: Other popular examples include a Jenkins integration, where infrastructure changes
    can be monitored in Slack (for example, if a server watched by Jenkins goes down,
    a warning message can be posted immediately to a relevant Slack channel).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up an incoming webhook that sends a simple *Hello world*
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to the Custom Integration Slack team page ([https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)).![Incoming
    webhooks](img/B05384_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The various flavors of custom integration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Incoming WebHooks** from the list, and then select the channel you'd
    like your webhook app to post messages to:![Incoming webhooks](img/B05384_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Webhook apps will post to a channel of your choosing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Custom webhooks (that is, webhooks created for your team only) use the selected
    channel as a default channel to send message to. It is possible to use the same
    webhook to post to different channels, as we'll see in a moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you've clicked on the **Add Incoming WebHooks integration** button, you
    will be presented with an options page that allows you to customize your integration
    a little further.![Incoming webhooks](img/B05384_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Names, descriptions, and icons can be set from this menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set a customized icon for your integration (for this example, the `wave` emoji
    was used) and copy down the webhook URL, which has the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This generated URL is unique to your team, meaning that any JSON payloads sent
    via this URL will only appear in your team's Slack channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s throw together a quick test of our incoming webhook in Node. Start
    a new Node project (remember you can use `npm init` to create your `package.json`)
    and install the familiar `superagent` AJAX library by running the following in
    your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `index.js` and paste the following JavaScript code within
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to replace `[YOUR_WEBHOOK_URL]` with your newly generated URL, and
    then run the program by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things should happen now: firstly a long response should be logged in your
    terminal and secondly you should see a message like the following in the Slack
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Incoming webhooks](img/B05384_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The incoming webhook equivalent of "hello world"
  prefs: []
  type: TYPE_NORMAL
- en: The `res` object that we logged in our terminal is the response from the AJAX
    request. Taking the form of a large JavaScript object, it displays information
    about the HTTP POST request we made to our webhook URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the message received in the Slack client, notice how the name and
    icon are the same as what we set in our integration setup in the team admin site.
    Remember that the default icon, name, and channel are used if none are provided,
    so let''s see what happens when we change that around. Replace your `request`
    AJAX call in `index.js` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and `nodemon` will automatically restart the program. Switch
    over to the Slack client and you should see a message like the following pop up
    in your `#general` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Incoming webhooks](img/B05384_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New name, icon, and message
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In place of `icon_emoji`, you could also use `icon_url` to link to a specific
    image of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish your message to only be sent to one user, you can supply a username
    as the value for the `channel` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the message to be sent from within the Slackbot direct message.
    The message's icon and username will match what you either configured in the setup
    or set in the body of the POST request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at sending links in our integration; replace the `text`
    property with the following and save `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Slack will automatically parse any links it finds, whether it''s in the format
    `http://www.example.com` or `www.example.com`. By enclosing the URL in angled
    brackets and using the `|` character, we can specify what we would like the URL
    to be shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Incoming webhooks](img/B05384_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Formatted links are easier to read than long URLs
  prefs: []
  type: TYPE_NORMAL
- en: For more information on message formatting, visit [https://api.slack.com/docs/formatting](https://api.slack.com/docs/formatting).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that as this is a custom webhook integration, we can change the name, icon,
    and channel of the integration. If we were to package the integration as a Slack
    app (an app which is installable by other teams), then it is not possible to override
    the default channel, username, and icon set.
  prefs: []
  type: TYPE_NORMAL
- en: Incoming webhooks are triggered by external sources—an example would be if a
    new user signs up to your service or if a product is sold. The goal of the incoming
    webhook is to provide easy-to-reach and comprehensible information for your team.
    The opposite would be if you want users to get data out of Slack, which can be
    done via the medium of outgoing webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: Outgoing webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outgoing webhooks differ from the incoming variety in that they send data out
    of Slack and to a service of your choosing, which in turn can respond with a message
    to the Slack channel.
  prefs: []
  type: TYPE_NORMAL
- en: To set up an outgoing webhook, visit the custom integration page of your Slack
    team's admin page again ([https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)).
    This time, select the **Outgoing WebHooks** option.
  prefs: []
  type: TYPE_NORMAL
- en: In the next screen, be sure to select a channel, a name, and an icon. Notice
    how there is a `target` URL field to be filled in; we will fill this out shortly.
  prefs: []
  type: TYPE_NORMAL
- en: When an outgoing webhook is triggered in Slack, an HTTP POST request is made
    to the URL (or URLs, as you can specify multiples) you provide. So first we need
    to build a server that can accept our webhook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.js`, paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how we require the `http` module, despite not installing it with NPM.
    That is because the `http` module is a core Node dependency and is automatically
    included with your installation of Node.
  prefs: []
  type: TYPE_NORMAL
- en: In this block of code, we start a simple server on port 8080 and listen for
    incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we set our server to run at 0.0.0.0 rather than `localhost`.
    This is important as Slack is sending a request to our server, so it needs to
    be accessible from the Internet. Setting the **Internet Protocol** (**IP**) of
    our server to 0.0.0.0 tells Node to use your computer's network-assigned IP address.
    Therefore, by setting the IP of our server to 0.0.0.0, Slack can reach your server
    by hitting your IP on port 8080 (for example, `http://123.456.78.90:8080`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having trouble with Slack reaching your server, it is most likely
    because you are behind a router or firewall. To circumvent this issue, you can
    use a service such as `ngrok` ([https://ngrok.com/](https://ngrok.com/)). Alternatively,
    look into the **Port Forwarding** settings for your router or firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our outgoing webhook settings accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Outgoing webhooks](img/B05384_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The outgoing webhook settings, with destination URL
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your settings and run your Node app; test that the outgoing webhook works
    by typing a message into the channel you specified in the webhook''s settings.
    You should then see something like this in Slack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Outgoing webhooks](img/B05384_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We built a spam bot
  prefs: []
  type: TYPE_NORMAL
- en: Well the good news is that our server is receiving requests and returning a
    message to send to Slack. The issue here is that we skipped over the **Trigger
    Word(s)** field in the webhook settings page. Without a trigger word, any message
    sent to the specified channel will trigger the outgoing webhook. This causes our
    webhook to trigger on a message sent by the outgoing webhook in the first place,
    creating an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this we could do one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Refrain from returning a message to the channel when listening to all the channel's
    messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a trigger word or trigger words to ensure we don't spam the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a message is optional, yet it is encouraged to ensure a better user
    experience. Even a confirmation message such as **Message received!** is better
    than no message, as it confirms to the user that their message was received and
    is being processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s presume we prefer the second option and add a trigger word:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Outgoing webhooks](img/B05384_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trigger words keep our webhooks organized
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try that again, this time sending a message with the trigger word
    at the beginning of the message. Restart your Node app and send a new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Outgoing webhooks](img/B05384_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our outgoing webhook app now functions a lot like our bots from earlier
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, now switch over to your terminal and see what that message logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This array contains the body of the HTTP POST request sent by Slack. In it,
    we have some useful data such as the user's name, the message sent, and the team
    ID. We can use this data to customize the response or to perform some validation
    to make sure the user is authorized to use this webhook.
  prefs: []
  type: TYPE_NORMAL
- en: In our response, we simply sent back a **Message received** string. However,
    like with incoming webhooks, we can set our own username and icon. The channel
    cannot be different from the channel specified in the webhook's settings. The
    same restrictions apply when the webhook is not a custom integration. This means
    that if the webhook was installed as a Slack app for another team, the webhook
    can only post messages as the username and icon specified in the setup screen.
    We will cover Slack apps in detail in [Chapter 7](ch07.html "Chapter 7. Publishing
    Your App"), *Publishing Your App*.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note is that webhooks, either incoming or outgoing, can
    only be set up in public channels. This is predominantly to discourage abuse and
    uphold privacy, as we've seen that it's trivial to set up a webhook that can record
    all the activity in a channel.
  prefs: []
  type: TYPE_NORMAL
- en: If you want similar functionality in private groups or DMs, we can use a slash
    command instead.
  prefs: []
  type: TYPE_NORMAL
- en: Slash commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commands that begin with a slash (`/`) are commands that can be used from anywhere
    within the Slack client. You are probably already familiar with the more common
    ones implemented by Slack themselves. For instance, use the `topic` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will set the channel's topic to "Sloths are great." Like with incoming
    and outgoing webhooks, Slack allows teams to configure their own custom slash
    commands. To demonstrate their use, we'll build a bot that uses the popular computational
    knowledge engine Wolfram Alpha ([http://www.wolframalpha.com/](http://www.wolframalpha.com/)).
    The end goal is a bot that returns the results from the query submitted via the
    slash command.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike webhooks, slash commands can only send data included with the command,
    so you are guaranteed to only receive data that was intentionally sent. Because
    of this nuance, we get an additional benefit to using slash commands. They are
    available to be used from any channel, DM, or private group.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's set up the slash command integration and get a Wolfram Alpha API
    key. Although we don't specifically need a Slack token, we do require one to access
    Wolfram Alpha's services. Navigate to your team's integration settings ([https://buildingbots.slack.com/apps/manage/custom-integrations](https://buildingbots.slack.com/apps/manage/custom-integrations)),
    select **Slash Commands**, and then select **Add Configuration**. We're going
    to use the `wolfram` string as our slash command, so let's fill that in and continue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The slash command must be unique to your team
  prefs: []
  type: TYPE_NORMAL
- en: Now, specify a URL that the slash command will send a request to, similar to
    what we did earlier with webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The slash command can be customized in a different way to webhooks
  prefs: []
  type: TYPE_NORMAL
- en: We have the choice of which HTTP method to use when requesting the provided
    URL. If you wish to send data to a server, use the **POST** method. If you wish
    to retrieve data without sending anything, use the **GET** method. For our Wolfram
    Alpha bot, we will be using **POST**, as we're sending a query to the server we
    created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Take special note of the generated token. This is a unique identifier that you
    can use to ensure that all requests coming to your server are from this particular
    Slack slash command, allowing you to reject any unwanted requests. We'll get back
    to the token later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will fill out the autocomplete details. Although optional, it is strongly
    recommended that you fill them out anyway, as they give clear instructions for
    your users on how to use your slash command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Help text is incredibly helpful to users who have never used your command before
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other third-party APIs we''ve used in this book, the Wolfram Alpha
    API requires an API token to access their computational services. To get one,
    navigate to the following URL and follow the on-screen sign up instructions: [https://developer.wolframalpha.com/portal/apisignup.html](https://developer.wolframalpha.com/portal/apisignup.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the Wolfram Alpha API is only free up to 2000 requests per month.
    If your slash command exceeds that amount, your requests will be denied unless
    you pay for a higher-tier service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Wolfram Alpha API sends responses in XML, which we''ll need to convert
    to JSON for easier use. Luckily, there is an NPM package that can abstract this
    problem away for us: `node-wolfram` ([https://www.npmjs.com/package/node-wolfram](https://www.npmjs.com/package/node-wolfram)).
    Install the `node-wolfram` package by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your key and you''ve installed `node-wolfram`, paste the following
    code in `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply put, this block of code listens for incoming requests at port 8080\.
    Once data is received (via a POST request), we convert the data to a JavaScript
    object for easy use. If the token sent in the request matches the one hardcoded
    in our program, we send a request to Wolfram Alpha that includes the slash command''s
    content. Luckily, Wolfram Alpha run their own **natural language processing**
    (**NLP**), so we can just send the user''s input and let Wolfram Alpha do the
    heavy lifting. Once we receive a callback from the Wolfram Alpha API, we return
    the results to Slack, which posts it in the Slack channel. Run your server and
    type the following command into Slack to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few moments, you should see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wolfram Alpha calculates a simple math problem
  prefs: []
  type: TYPE_NORMAL
- en: 'Success! Now let''s try a more challenging query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That request should result in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The query took too long
  prefs: []
  type: TYPE_NORMAL
- en: Oh dear, it looks like our query timed out. Were we to add some logging to our
    app, we'd see that although the Wolfram Alpha API does eventually return a result,
    it takes more than the maximum timeout period of Slack webhook integrations (3,000
    milliseconds). This causes the slash command to fail and displays the preceding
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, let''s look at the data received from Slack initially; the body
    from the previous slash command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last index of the `Body` array is what interests us—a response URL. Should
    your calculations take longer than the maximum timeout of 3000 milliseconds, Slack
    provides us with a URL which we can make a POST HTTP request to, much like how
    we sent webhook messages.
  prefs: []
  type: TYPE_NORMAL
- en: If your slash command does take longer than the maximum timeout and you're using
    the request URL, it is highly recommended that you return a message to Slack,
    letting the user know that their request is processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `http.createServer` block in your code with the following, noting
    the highlighted areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After confirming that the slash command request came from our team, but before
    we even start the Wolfram Alpha API request, we return a confirmation message
    to the Slack channel letting the user know that their request is in the works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Wolfram Alpha has returned our data, we send an HTTP POST request to the
    response URL provided to us in the slash command''s initial request body. Let''s
    try that last command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a confirmation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A confirmation message lets the user know things are happening
  prefs: []
  type: TYPE_NORMAL
- en: 'A few seconds later, we should see the full result of the slash command query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slash commands](img/B05384_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our slash command returns an abundance of data
  prefs: []
  type: TYPE_NORMAL
- en: With our slash command working as expected, let's look at a quirk of the returned
    output.
  prefs: []
  type: TYPE_NORMAL
- en: In-channel and ephemeral responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that when the Wolfram Alpha bot responds, it has the
    text **Only you can see this message** next to its name. As the text implies,
    the result of our bot is only visible to the user who initiated the slash command.
    This is an example of an ephemeral response. Note that the original slash command's
    text is also only viewable to the user that executed it. The opposite of ephemeral
    is an in-channel response, which can show both the slash command and result in
    the channel, for all to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all slash command responses are set to ephemeral mode by the Slack
    API. Let''s look at changing that and send in-channel messages instead. Once again,
    let''s replace the contents of `http.createServer`. Go over the changes step by
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The main difference here is that we've changed the response's header content
    type to be `application/json`. This notifies Slack to expect a JSON package in
    string form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our error response now requires that it be in stringified JSON format. Also,
    we add the response type `ephemeral`, which means that the error message will
    only be visible to the user who initiated the slash command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we specifically want an `in-channel` response. In this context, it means
    that both the slash command and the processing response will be visible to all
    in the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In-channel and ephemeral responses](img/B05384_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both the original slash command and the interim response are visible
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally we query **Wolfram|Alpha**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we again ensure that the Wolfram Alpha result is visible to the entire
    channel. Finally, let''s make some improvements to the display of the data in
    our `queryWolfram` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Improvements here include bolding the title of a section and removing sections
    that have no text associated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve put it all together, let''s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In-channel and ephemeral responses](img/B05384_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wolfram Alpha can also be used to get definitions of popular algorithms
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that slash commands are available universally in your Slack team.
    In our case, it means that the **Wolfram|Alpha** bot can be triggered from any
    channel, DM, or private group.
  prefs: []
  type: TYPE_NORMAL
- en: Using webhooks and slash commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a firm grasp on what webhooks and slash commands are, we should
    establish when to use them. First, we should consider when we'd use a webhook
    or slash command over a bot user, which we've learnt to build in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: A bot user generally operates on a one-to-one basis; every bot requires a Slack
    token unique to that bot, meaning that the bot can only interact with the team
    associated with that token. This also allows the bot to maintain a real-time messaging
    connection with Slack and to reconnect in case of connection failure. Webhooks
    and slash commands, on the other hand, exist as external services and can be reused
    by many teams. By removing the need for a Slack token, you open up your app to
    be used by many other teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this flowchart to decide whether a webhook or a slash command is best for
    your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using webhooks and slash commands](img/B05384_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When to use webhooks or slash commands
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we mention the concepts of **active** and **reactive**.
    We covered these concepts back in [Chapter 3](ch03.html "Chapter 3. Adding Complexity"),
    *Adding Complexity*, but the basic gist is that active apps and bots post messages
    without requiring input, whereas reactive bots respond to stimuli in the form
    of user input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what webhooks are and how to set them up to send data
    out of Slack and get data into Slack through a third-party server. We also discussed
    slash commands and how to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to publish your app so that other teams
    can make use of your bots, webhooks, and slash commands.
  prefs: []
  type: TYPE_NORMAL
