- en: Chapter 6. Webhooks and Slash Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. Webhooks和Slash Commands
- en: 'Every bot we''ve created so far shares the same two traits: they rely on commands
    issued by users and require a Slack API token. This has been very useful in our
    bots so far, but what if we want a bot to post messages to a Slack channel without
    needing an API token? Plus what if we want a bot that does not require an API
    token to interact with users? An example of this is the GitHub Slack integration,
    a service that posts GitHub activity on specific repositories to a Slack channel
    of your choice.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的每个机器人都有两个共同特点：它们依赖于用户发出的命令，并且需要Slack API令牌。这在我们的机器人中非常有用，但如果我们想让一个机器人向Slack频道发送消息而不需要API令牌呢？再或者，如果我们想创建一个不需要API令牌与用户交互的机器人呢？GitHub
    Slack集成就是一个例子，这是一个将特定仓库的GitHub活动发布到您选择的Slack频道的服务。
- en: In this chapter, we will discuss how to use webhooks to get data in and out
    of Slack and how to create slash commands that users can interact with throughout
    Slack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用Webhooks将数据传入和传出Slack，以及如何创建用户可以在Slack中与之交互的slash命令。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Webhooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhooks
- en: Incoming webhooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Incoming webhooks
- en: Outgoing webhooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Outgoing webhooks
- en: Slash commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slash commands
- en: In-channel and ephemeral responses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频道内和临时响应
- en: Webhooks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhooks
- en: A webhook is a way of altering or augmenting a web application through HTTP
    methods. Previously, we used third-party APIs in our bots to get data into and
    out of Slack. However, this isn't the only way. Webhooks allow us to post message
    to and from Slack using regular HTTP requests with a JSON payload. What makes
    a webhook a bot is its ability to post messages to Slack as if they are a bot
    user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook是一种通过HTTP方法修改或增强Web应用程序的方式。以前，我们在机器人中使用第三方API将数据传入和传出Slack。然而，这并非唯一的方法。Webhooks允许我们使用带有JSON有效负载的常规HTTP请求将消息从Slack发送到其他地方。使Webhook成为机器人的特性是它能够将消息发布到Slack，就像它们是机器人用户一样。
- en: These webhooks can be divided into incoming and outgoing webhooks, each with
    their own purposes and uses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Webhook可以分为传入Webhook和传出Webhook，每种都有自己的目的和用途。
- en: Incoming webhooks
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Incoming webhooks
- en: 'An example of an incoming webhook would be a service that relays information
    from an external source to a Slack channel without being explicitly requested.
    An example of this is the aforementioned GitHub Slack integration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传入Webhook的例子是一个将信息从外部源转发到Slack频道的服务，而不需要明确请求。上述GitHub Slack集成就是一个例子：
- en: '![Incoming webhooks](img/B05384_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Incoming webhooks](img/B05384_06_01.jpg)'
- en: The GitHub integration posts messages about repositories we are interested in
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub集成发布关于我们感兴趣的仓库的消息
- en: In the preceding screenshot, we can see how a message was sent to Slack after
    a new branch was made on a repository this team is watching. This data wasn't
    explicitly requested by a team member, but it was automatically sent to the channel
    as a result of the incoming webhook.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到在团队监视的仓库上创建新分支后，消息是如何发送到Slack的。这些数据并非团队成员明确请求的，但它们是作为传入Webhook的结果自动发送到频道的。
- en: Other popular examples include a Jenkins integration, where infrastructure changes
    can be monitored in Slack (for example, if a server watched by Jenkins goes down,
    a warning message can be posted immediately to a relevant Slack channel).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的例子包括Jenkins集成，其中可以在Slack中监控基础设施更改（例如，如果Jenkins监视的服务器宕机，可以立即在相关的Slack频道发布警告消息）。
- en: 'Let''s start by setting up an incoming webhook that sends a simple *Hello world*
    message:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置一个发送简单*Hello world*消息的传入Webhook开始：
- en: First, navigate to the Custom Integration Slack team page ([https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)).![Incoming
    webhooks](img/B05384_06_02.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到自定义集成Slack团队页面([https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration))。![Incoming
    webhooks](img/B05384_06_02.jpg)
- en: The various flavors of custom integration
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的自定义集成版本
- en: Select **Incoming WebHooks** from the list, and then select the channel you'd
    like your webhook app to post messages to:![Incoming webhooks](img/B05384_06_03.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择**Incoming WebHooks**，然后选择您希望Webhook应用发布消息到的频道：![Incoming webhooks](img/B05384_06_03.jpg)
- en: Webhook apps will post to a channel of your choosing
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Webhook应用将发布到您选择的频道
- en: Custom webhooks (that is, webhooks created for your team only) use the selected
    channel as a default channel to send message to. It is possible to use the same
    webhook to post to different channels, as we'll see in a moment.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义webhook（即只为您的团队创建的webhook）使用所选频道作为默认频道来发送消息。我们可以看到，可以使用相同的webhook向不同的频道发送消息。
- en: Once you've clicked on the **Add Incoming WebHooks integration** button, you
    will be presented with an options page that allows you to customize your integration
    a little further.![Incoming webhooks](img/B05384_06_04.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您点击了**添加入站WebHooks集成**按钮，您将看到一个选项页面，允许您进一步自定义您的集成。![入站webhook](img/B05384_06_04.jpg)
- en: Names, descriptions, and icons can be set from this menu
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称、描述和图标都可以从这个菜单中设置
- en: 'Set a customized icon for your integration (for this example, the `wave` emoji
    was used) and copy down the webhook URL, which has the following format:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的集成设置一个自定义图标（例如，本例中使用了`wave`表情符号）并记下webhook URL，其格式如下：
- en: '`https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`'
- en: This generated URL is unique to your team, meaning that any JSON payloads sent
    via this URL will only appear in your team's Slack channels.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的URL对您的团队是唯一的，这意味着通过此URL发送的任何JSON有效负载都只会出现在您的团队Slack频道中。
- en: 'Now, let''s throw together a quick test of our incoming webhook in Node. Start
    a new Node project (remember you can use `npm init` to create your `package.json`)
    and install the familiar `superagent` AJAX library by running the following in
    your terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Node中快速测试我们的入站webhook。启动一个新的Node项目（记住您可以使用`npm init`来创建`package.json`），然后在您的终端中运行以下命令来安装熟悉的`superagent`
    AJAX库：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file named `index.js` and paste the following JavaScript code within
    it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`index.js`的文件，并将以下JavaScript代码粘贴到其中：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember to replace `[YOUR_WEBHOOK_URL]` with your newly generated URL, and
    then run the program by executing the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住用您新生成的URL替换`[YOUR_WEBHOOK_URL]`，然后通过执行以下命令来运行程序：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Two things should happen now: firstly a long response should be logged in your
    terminal and secondly you should see a message like the following in the Slack
    client:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该发生两件事：首先，在您的终端中记录一个长响应，其次，您应该在Slack客户端看到如下消息：
- en: '![Incoming webhooks](img/B05384_06_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![入站webhook](img/B05384_06_05.jpg)'
- en: The incoming webhook equivalent of "hello world"
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 入站webhook的“hello world”等效
- en: The `res` object that we logged in our terminal is the response from the AJAX
    request. Taking the form of a large JavaScript object, it displays information
    about the HTTP POST request we made to our webhook URL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在终端中记录的`res`对象是我们对webhook URL发出的HTTP POST请求的响应。它以大型JavaScript对象的形式出现，显示了我们对webhook
    URL发出的HTTP POST请求的信息。
- en: 'Looking at the message received in the Slack client, notice how the name and
    icon are the same as what we set in our integration setup in the team admin site.
    Remember that the default icon, name, and channel are used if none are provided,
    so let''s see what happens when we change that around. Replace your `request`
    AJAX call in `index.js` with the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 观察在Slack客户端收到的消息，注意名称和图标是否与我们在团队管理员网站上设置的集成设置中的内容相同。请记住，如果没有提供，将使用默认图标、名称和频道，所以让我们看看当我们更改这些设置时会发生什么。将`index.js`中的`request`
    AJAX调用替换为以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save the file and `nodemon` will automatically restart the program. Switch
    over to the Slack client and you should see a message like the following pop up
    in your `#general` channel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，`nodemon`将自动重启程序。切换到Slack客户端，您应该在`#general`频道中看到如下消息：
- en: '![Incoming webhooks](img/B05384_06_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![入站webhook](img/B05384_06_06.jpg)'
- en: New name, icon, and message
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新名称、图标和消息
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In place of `icon_emoji`, you could also use `icon_url` to link to a specific
    image of your choosing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`icon_emoji`的位置，您也可以使用`icon_url`链接到您选择的特定图像。
- en: 'If you wish your message to only be sent to one user, you can supply a username
    as the value for the `channel` property:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望消息只发送给一个用户，可以将用户名作为`channel`属性的值：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will cause the message to be sent from within the Slackbot direct message.
    The message's icon and username will match what you either configured in the setup
    or set in the body of the POST request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致消息从Slackbot直接消息中发送。消息的图标和用户名将与您在设置中配置的或设置在POST请求正文中的内容相匹配。
- en: 'Finally, let''s look at sending links in our integration; replace the `text`
    property with the following and save `index.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看在我们的集成中发送链接；将`text`属性替换为以下内容，并保存`index.js`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Slack will automatically parse any links it finds, whether it''s in the format
    `http://www.example.com` or `www.example.com`. By enclosing the URL in angled
    brackets and using the `|` character, we can specify what we would like the URL
    to be shown as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Slack会自动解析它找到的任何链接，无论是`http://www.example.com`还是`www.example.com`的格式。通过将URL放在尖括号中并使用`|`字符，我们可以指定我们希望URL显示的内容：
- en: '![Incoming webhooks](img/B05384_06_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![入站webhooks](img/B05384_06_07.jpg)'
- en: Formatted links are easier to read than long URLs
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化的链接比长URL更容易阅读
- en: For more information on message formatting, visit [https://api.slack.com/docs/formatting](https://api.slack.com/docs/formatting).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有关消息格式的更多信息，请访问[https://api.slack.com/docs/formatting](https://api.slack.com/docs/formatting)。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that as this is a custom webhook integration, we can change the name, icon,
    and channel of the integration. If we were to package the integration as a Slack
    app (an app which is installable by other teams), then it is not possible to override
    the default channel, username, and icon set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这是一个自定义webhook集成，我们可以更改集成的名称、图标和频道。如果我们将集成打包成Slack应用（其他团队可以安装的应用），则无法覆盖默认的频道、用户名和图标设置。
- en: Incoming webhooks are triggered by external sources—an example would be if a
    new user signs up to your service or if a product is sold. The goal of the incoming
    webhook is to provide easy-to-reach and comprehensible information for your team.
    The opposite would be if you want users to get data out of Slack, which can be
    done via the medium of outgoing webhooks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 入站webhook由外部源触发——一个例子是当新用户注册到您的服务或产品被卖出时。入站webhook的目的是为您的团队提供易于访问和易于理解的信息。相反，如果您想从Slack中获取数据，这可以通过出站webhook的方式完成。
- en: Outgoing webhooks
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出站webhooks
- en: Outgoing webhooks differ from the incoming variety in that they send data out
    of Slack and to a service of your choosing, which in turn can respond with a message
    to the Slack channel.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 出站webhook与入站webhook不同，因为它们将数据从Slack发送到您选择的服务，然后该服务可以回复消息到Slack频道。
- en: To set up an outgoing webhook, visit the custom integration page of your Slack
    team's admin page again ([https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)).
    This time, select the **Outgoing WebHooks** option.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置出站webhook，请再次访问您的Slack团队管理页面的自定义集成页面（[https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)）。这次，请确保选择**Outgoing
    WebHooks**选项。
- en: In the next screen, be sure to select a channel, a name, and an icon. Notice
    how there is a `target` URL field to be filled in; we will fill this out shortly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，请确保选择一个频道、一个名称和一个图标。注意有一个`target` URL字段需要填写；我们很快就会填写它。
- en: When an outgoing webhook is triggered in Slack, an HTTP POST request is made
    to the URL (or URLs, as you can specify multiples) you provide. So first we need
    to build a server that can accept our webhook.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当Slack中的出站webhook被触发时，会向您提供的URL（或URLs，因为您可以指定多个）发送HTTP POST请求。因此，我们首先需要构建一个可以接受我们的webhook的服务器。
- en: 'In `index.js`, paste the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`中，粘贴以下代码：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we require the `http` module, despite not installing it with NPM.
    That is because the `http` module is a core Node dependency and is automatically
    included with your installation of Node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们要求使用`http`模块，尽管我们没有使用NPM安装它。这是因为`http`模块是Node的核心依赖项，并且会自动包含在您的Node安装中。
- en: In this block of code, we start a simple server on port 8080 and listen for
    incoming requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码块中，我们在端口8080上启动一个简单的服务器，并监听传入的请求。
- en: In this example, we set our server to run at 0.0.0.0 rather than `localhost`.
    This is important as Slack is sending a request to our server, so it needs to
    be accessible from the Internet. Setting the **Internet Protocol** (**IP**) of
    our server to 0.0.0.0 tells Node to use your computer's network-assigned IP address.
    Therefore, by setting the IP of our server to 0.0.0.0, Slack can reach your server
    by hitting your IP on port 8080 (for example, `http://123.456.78.90:8080`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将服务器设置为在`0.0.0.0`上运行，而不是`localhost`。这很重要，因为Slack正在向我们的服务器发送请求，因此它需要从互联网上可访问。将我们服务器的**互联网协议**（**IP**）设置为`0.0.0.0`告诉Node使用您的计算机的网络分配的IP地址。因此，通过将我们服务器的IP设置为`0.0.0.0`，Slack可以通过在端口8080上击中您的IP地址（例如，`http://123.456.78.90:8080`）来访问您的服务器。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are having trouble with Slack reaching your server, it is most likely
    because you are behind a router or firewall. To circumvent this issue, you can
    use a service such as `ngrok` ([https://ngrok.com/](https://ngrok.com/)). Alternatively,
    look into the **Port Forwarding** settings for your router or firewall.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到Slack无法连接到你的服务器的问题，这很可能是由于你位于路由器或防火墙后面。为了解决这个问题，你可以使用像`ngrok`([https://ngrok.com/](https://ngrok.com/))这样的服务。或者，检查你的路由器或防火墙的**端口转发**设置。
- en: 'Let''s update our outgoing webhook settings accordingly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们相应地更新我们的外部钩子设置：
- en: '![Outgoing webhooks](img/B05384_06_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![外部钩子](img/B05384_06_08.jpg)'
- en: The outgoing webhook settings, with destination URL
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 带有目标URL的外部钩子设置
- en: 'Save your settings and run your Node app; test that the outgoing webhook works
    by typing a message into the channel you specified in the webhook''s settings.
    You should then see something like this in Slack:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的设置并运行你的Node应用；通过在钩子设置中指定的频道中输入消息来测试外部钩子是否工作。你应该在Slack中看到类似以下内容：
- en: '![Outgoing webhooks](img/B05384_06_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![外部钩子](img/B05384_06_09.jpg)'
- en: We built a spam bot
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个垃圾邮件机器人
- en: Well the good news is that our server is receiving requests and returning a
    message to send to Slack. The issue here is that we skipped over the **Trigger
    Word(s)** field in the webhook settings page. Without a trigger word, any message
    sent to the specified channel will trigger the outgoing webhook. This causes our
    webhook to trigger on a message sent by the outgoing webhook in the first place,
    creating an infinite loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们的服务器正在接收请求并向Slack发送消息。这里的问题是我们在外部钩子设置页面中跳过了**触发词**字段。没有触发词，发送到指定频道的任何消息都会触发外部钩子。这导致我们的钩子最初由发送外部钩子的消息触发，从而形成一个无限循环。
- en: 'To fix this we could do one of two things:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以做两件事之一：
- en: Refrain from returning a message to the channel when listening to all the channel's
    messages
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在监听所有频道消息时，请勿向频道返回消息
- en: Specify a trigger word or trigger words to ensure we don't spam the channel
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定一个或多个触发词，以确保我们不会向频道发送垃圾邮件
- en: Returning a message is optional, yet it is encouraged to ensure a better user
    experience. Even a confirmation message such as **Message received!** is better
    than no message, as it confirms to the user that their message was received and
    is being processed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 返回消息是可选的，但为了确保更好的用户体验，鼓励这样做。即使是一条确认消息，例如**消息已接收**，也比没有消息要好，因为它向用户确认他们的消息已被接收并正在处理。
- en: 'Let''s presume we prefer the second option and add a trigger word:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们更喜欢第二个选项并添加一个触发词：
- en: '![Outgoing webhooks](img/B05384_06_10.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![外部钩子](img/B05384_06_10.jpg)'
- en: Trigger words keep our webhooks organized
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 触发词帮助我们组织外部钩子
- en: 'Now, let''s try that again, this time sending a message with the trigger word
    at the beginning of the message. Restart your Node app and send a new message:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试，这次在消息开头发送带有触发词的消息。重新启动你的Node应用并发送一条新消息：
- en: '![Outgoing webhooks](img/B05384_06_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![外部钩子](img/B05384_06_11.jpg)'
- en: Our outgoing webhook app now functions a lot like our bots from earlier
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部钩子应用现在功能上与之前我们的机器人非常相似
- en: 'Great, now switch over to your terminal and see what that message logged:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在切换到你的终端，看看那条消息记录了什么：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This array contains the body of the HTTP POST request sent by Slack. In it,
    we have some useful data such as the user's name, the message sent, and the team
    ID. We can use this data to customize the response or to perform some validation
    to make sure the user is authorized to use this webhook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含由Slack发送的HTTP POST请求的主体。其中包含一些有用的数据，例如用户的姓名、发送的消息和团队ID。我们可以使用这些数据来自定义响应或执行一些验证，以确保用户有权使用此钩子。
- en: In our response, we simply sent back a **Message received** string. However,
    like with incoming webhooks, we can set our own username and icon. The channel
    cannot be different from the channel specified in the webhook's settings. The
    same restrictions apply when the webhook is not a custom integration. This means
    that if the webhook was installed as a Slack app for another team, the webhook
    can only post messages as the username and icon specified in the setup screen.
    We will cover Slack apps in detail in [Chapter 7](ch07.html "Chapter 7. Publishing
    Your App"), *Publishing Your App*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的响应中，我们只是发送了一个“**消息已接收**”字符串。然而，就像入站webhooks一样，我们可以设置自己的用户名和图标。频道不能与webhook设置中指定的频道不同。当webhook不是自定义集成时，同样适用这些限制。这意味着如果webhook作为另一个团队的Slack应用安装，则webhook只能以设置屏幕中指定的用户名和图标发布消息。我们将在[第7章](ch07.html
    "第7章。发布您的应用")*发布您的应用*中详细讨论Slack应用。
- en: An important thing to note is that webhooks, either incoming or outgoing, can
    only be set up in public channels. This is predominantly to discourage abuse and
    uphold privacy, as we've seen that it's trivial to set up a webhook that can record
    all the activity in a channel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，无论是入站还是出站的webhooks，都只能在公共频道中设置。这主要是为了防止滥用并维护隐私，因为我们已经看到设置一个可以记录频道所有活动的webhook是极其简单的。
- en: If you want similar functionality in private groups or DMs, we can use a slash
    command instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在私人组或DM中使用类似的功能，我们可以使用斜杠命令。
- en: Slash commands
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斜杠命令
- en: 'Commands that begin with a slash (`/`) are commands that can be used from anywhere
    within the Slack client. You are probably already familiar with the more common
    ones implemented by Slack themselves. For instance, use the `topic` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以斜杠（`/`）开头的命令是可以在Slack客户端的任何地方使用的命令。你可能已经熟悉了Slack自己实现的更常见的那些命令。例如，使用`topic`命令：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will set the channel's topic to "Sloths are great." Like with incoming
    and outgoing webhooks, Slack allows teams to configure their own custom slash
    commands. To demonstrate their use, we'll build a bot that uses the popular computational
    knowledge engine Wolfram Alpha ([http://www.wolframalpha.com/](http://www.wolframalpha.com/)).
    The end goal is a bot that returns the results from the query submitted via the
    slash command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置频道的主题为“树懒很棒。”就像处理入站和出站webhooks一样，Slack允许团队配置他们自己的自定义斜杠命令。为了演示其用法，我们将构建一个使用流行的计算知识引擎Wolfram
    Alpha ([http://www.wolframalpha.com/](http://www.wolframalpha.com/))的机器人。最终目标是创建一个机器人，它可以通过斜杠命令返回查询结果。
- en: Unlike webhooks, slash commands can only send data included with the command,
    so you are guaranteed to only receive data that was intentionally sent. Because
    of this nuance, we get an additional benefit to using slash commands. They are
    available to be used from any channel, DM, or private group.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与webhooks不同，斜杠命令只能发送命令中包含的数据，因此你只能保证接收到的数据是故意发送的。正因为这个细微差别，我们使用斜杠命令还能获得额外的好处。它们可以在任何频道、DM或私人组中使用。
- en: First, let's set up the slash command integration and get a Wolfram Alpha API
    key. Although we don't specifically need a Slack token, we do require one to access
    Wolfram Alpha's services. Navigate to your team's integration settings ([https://buildingbots.slack.com/apps/manage/custom-integrations](https://buildingbots.slack.com/apps/manage/custom-integrations)),
    select **Slash Commands**, and then select **Add Configuration**. We're going
    to use the `wolfram` string as our slash command, so let's fill that in and continue.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置斜杠命令集成并获取Wolfram Alpha API密钥。虽然我们不需要特定的Slack令牌，但我们确实需要它来访问Wolfram Alpha的服务。导航到您团队的集成设置([https://buildingbots.slack.com/apps/manage/custom-integrations](https://buildingbots.slack.com/apps/manage/custom-integrations))，选择**斜杠命令**，然后选择**添加配置**。我们将使用`wolfram`字符串作为我们的斜杠命令，所以让我们填写它并继续。
- en: '![Slash commands](img/B05384_06_12.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_12.jpg)'
- en: The slash command must be unique to your team
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠命令必须对您的团队是唯一的
- en: Now, specify a URL that the slash command will send a request to, similar to
    what we did earlier with webhooks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，指定斜杠命令将要发送请求的URL，这与我们之前处理webhooks时所做的类似。
- en: '![Slash commands](img/B05384_06_13.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_13.jpg)'
- en: The slash command can be customized in a different way to webhooks
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠命令可以以不同于webhooks的方式定制
- en: We have the choice of which HTTP method to use when requesting the provided
    URL. If you wish to send data to a server, use the **POST** method. If you wish
    to retrieve data without sending anything, use the **GET** method. For our Wolfram
    Alpha bot, we will be using **POST**, as we're sending a query to the server we
    created earlier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择在请求提供的URL时使用哪种HTTP方法。如果您希望向服务器发送数据，请使用**POST**方法。如果您希望检索数据而不发送任何内容，请使用**GET**方法。对于我们的Wolfram
    Alpha机器人，我们将使用**POST**，因为我们正在向之前创建的服务器发送查询。
- en: Take special note of the generated token. This is a unique identifier that you
    can use to ensure that all requests coming to your server are from this particular
    Slack slash command, allowing you to reject any unwanted requests. We'll get back
    to the token later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意生成的令牌。这是一个唯一的标识符，您可以使用它来确保所有发送到您服务器的请求都来自这个特定的Slack斜杠命令，从而允许您拒绝任何不想要的请求。我们稍后会回到令牌。
- en: Next, we will fill out the autocomplete details. Although optional, it is strongly
    recommended that you fill them out anyway, as they give clear instructions for
    your users on how to use your slash command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将填写自动完成详情。尽管这是可选的，但强烈建议您无论如何都填写它们，因为它们为用户提供清晰的说明，告诉他们如何使用您的斜杠命令。
- en: '![Slash commands](img/B05384_06_14.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_14.jpg)'
- en: Help text is incredibly helpful to users who have never used your command before
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从未使用过您的命令的用户来说，帮助文本非常有帮助
- en: 'Similar to other third-party APIs we''ve used in this book, the Wolfram Alpha
    API requires an API token to access their computational services. To get one,
    navigate to the following URL and follow the on-screen sign up instructions: [https://developer.wolframalpha.com/portal/apisignup.html](https://developer.wolframalpha.com/portal/apisignup.html).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在本书中使用的其他第三方API类似，Wolfram Alpha API需要API令牌才能访问他们的计算服务。要获取一个，请导航到以下URL并遵循屏幕上的注册说明：[https://developer.wolframalpha.com/portal/apisignup.html](https://developer.wolframalpha.com/portal/apisignup.html)。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the Wolfram Alpha API is only free up to 2000 requests per month.
    If your slash command exceeds that amount, your requests will be denied unless
    you pay for a higher-tier service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Wolfram Alpha API每月免费请求量只有2000次。如果您的斜杠命令超过这个数量，除非您支付更高级别的服务费用，否则您的请求将被拒绝。
- en: 'The Wolfram Alpha API sends responses in XML, which we''ll need to convert
    to JSON for easier use. Luckily, there is an NPM package that can abstract this
    problem away for us: `node-wolfram` ([https://www.npmjs.com/package/node-wolfram](https://www.npmjs.com/package/node-wolfram)).
    Install the `node-wolfram` package by running the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Wolfram Alpha API以XML格式发送响应，我们需要将其转换为JSON以便于使用。幸运的是，有一个NPM包可以为我们抽象这个问题：`node-wolfram`
    ([https://www.npmjs.com/package/node-wolfram](https://www.npmjs.com/package/node-wolfram))。通过运行以下命令安装`node-wolfram`包：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once you have your key and you''ve installed `node-wolfram`, paste the following
    code in `index.js`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了密钥并且已经安装了`node-wolfram`，请将以下代码粘贴到`index.js`中：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Simply put, this block of code listens for incoming requests at port 8080\.
    Once data is received (via a POST request), we convert the data to a JavaScript
    object for easy use. If the token sent in the request matches the one hardcoded
    in our program, we send a request to Wolfram Alpha that includes the slash command''s
    content. Luckily, Wolfram Alpha run their own **natural language processing**
    (**NLP**), so we can just send the user''s input and let Wolfram Alpha do the
    heavy lifting. Once we receive a callback from the Wolfram Alpha API, we return
    the results to Slack, which posts it in the Slack channel. Run your server and
    type the following command into Slack to see it in action:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这段代码监听8080端口的传入请求。一旦接收到数据（通过POST请求），我们将数据转换为JavaScript对象以便于使用。如果请求中发送的令牌与程序中硬编码的令牌匹配，我们将发送一个包含斜杠命令内容的请求到Wolfram
    Alpha。幸运的是，Wolfram Alpha运行自己的**自然语言处理**（**NLP**），因此我们可以直接发送用户的输入，让Wolfram Alpha完成繁重的工作。一旦我们从Wolfram
    Alpha API收到回调，我们将结果返回给Slack，它会在Slack频道中发布。运行你的服务器，并在Slack中输入以下命令以查看其效果：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a few moments, you should see the result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您应该会看到结果：
- en: '![Slash commands](img/B05384_06_15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_15.jpg)'
- en: Wolfram Alpha calculates a simple math problem
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Wolfram Alpha计算一个简单的数学问题
- en: 'Success! Now let''s try a more challenging query:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！现在让我们尝试一个更具挑战性的查询：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That request should result in something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那个请求应该会产生类似以下的结果：
- en: '![Slash commands](img/B05384_06_16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_16.jpg)'
- en: The query took too long
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查询耗时过长
- en: Oh dear, it looks like our query timed out. Were we to add some logging to our
    app, we'd see that although the Wolfram Alpha API does eventually return a result,
    it takes more than the maximum timeout period of Slack webhook integrations (3,000
    milliseconds). This causes the slash command to fail and displays the preceding
    error message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，看起来我们的查询超时了。如果我们给我们的应用程序添加一些日志记录，我们会看到虽然 Wolfram Alpha API 最终会返回结果，但它需要超过
    Slack webhook 集成（3000 毫秒）的最大超时时间。这导致斜杠命令失败并显示前面的错误消息。
- en: 'To solve this, let''s look at the data received from Slack initially; the body
    from the previous slash command looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们看看 Slack 初始接收到的数据；上一个斜杠命令的正文看起来像这样：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last index of the `Body` array is what interests us—a response URL. Should
    your calculations take longer than the maximum timeout of 3000 milliseconds, Slack
    provides us with a URL which we can make a POST HTTP request to, much like how
    we sent webhook messages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是 `Body` 数组的最后一个索引——一个响应 URL。如果你的计算时间超过最大超时时间 3000 毫秒，Slack 会提供一个 URL，我们可以向其发送
    POST HTTP 请求，就像我们发送 webhook 消息一样。
- en: If your slash command does take longer than the maximum timeout and you're using
    the request URL, it is highly recommended that you return a message to Slack,
    letting the user know that their request is processing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的斜杠命令处理时间超过最大超时时间，并且你正在使用请求 URL，强烈建议你向 Slack 返回一条消息，告知用户他们的请求正在处理中。
- en: 'Replace the `http.createServer` block in your code with the following, noting
    the highlighted areas:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的代码中的 `http.createServer` 块替换为以下内容，注意高亮区域：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After confirming that the slash command request came from our team, but before
    we even start the Wolfram Alpha API request, we return a confirmation message
    to the Slack channel letting the user know that their request is in the works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认斜杠命令请求来自我们的团队之后，但在我们开始 Wolfram Alpha API 请求之前，我们向 Slack 频道返回一个确认消息，告知用户他们的请求正在进行中。
- en: 'Once Wolfram Alpha has returned our data, we send an HTTP POST request to the
    response URL provided to us in the slash command''s initial request body. Let''s
    try that last command again:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Wolfram Alpha 返回我们的数据，我们就向斜杠命令初始请求体中提供的响应 URL 发送 HTTP POST 请求。让我们再次尝试那个最后的命令：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should return a confirmation message:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个确认消息：
- en: '![Slash commands](img/B05384_06_17.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_17.jpg)'
- en: A confirmation message lets the user know things are happening
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确认消息让用户知道事情正在进行
- en: 'A few seconds later, we should see the full result of the slash command query:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们应该看到斜杠命令查询的完整结果：
- en: '![Slash commands](img/B05384_06_18.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![斜杠命令](img/B05384_06_18.jpg)'
- en: Our slash command returns an abundance of data
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的斜杠命令返回大量数据
- en: With our slash command working as expected, let's look at a quirk of the returned
    output.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的斜杠命令按预期工作后，让我们看看返回输出的一个特性。
- en: In-channel and ephemeral responses
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频道内和短暂响应
- en: You might have noticed that when the Wolfram Alpha bot responds, it has the
    text **Only you can see this message** next to its name. As the text implies,
    the result of our bot is only visible to the user who initiated the slash command.
    This is an example of an ephemeral response. Note that the original slash command's
    text is also only viewable to the user that executed it. The opposite of ephemeral
    is an in-channel response, which can show both the slash command and result in
    the channel, for all to see.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当 Wolfram Alpha 机器人响应时，它的名字旁边有文本 **只有你能看到这条消息**。正如文本所暗示的，我们机器人的结果只对发起斜杠命令的用户可见。这是一个短暂响应的例子。请注意，原始斜杠命令的文本也只对执行它的用户可见。短暂响应的反面是频道内响应，它可以在频道中显示斜杠命令和结果，供所有人查看。
- en: 'By default, all slash command responses are set to ephemeral mode by the Slack
    API. Let''s look at changing that and send in-channel messages instead. Once again,
    let''s replace the contents of `http.createServer`. Go over the changes step by
    step:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有斜杠命令响应都由 Slack API 设置为短暂模式。让我们看看如何更改它，并发送频道内消息。再次，让我们替换 `http.createServer`
    的内容。一步一步地查看更改：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main difference here is that we've changed the response's header content
    type to be `application/json`. This notifies Slack to expect a JSON package in
    string form.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于，我们将响应的头部内容类型更改为 `application/json`。这通知 Slack 预期一个字符串形式的 JSON 包。
- en: 'The code is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our error response now requires that it be in stringified JSON format. Also,
    we add the response type `ephemeral`, which means that the error message will
    only be visible to the user who initiated the slash command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误响应现在需要以字符串化的 JSON 格式呈现。此外，我们添加了响应类型 `ephemeral`，这意味着错误消息只会对发起 slash 命令的用户可见：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we specifically want an `in-channel` response. In this context, it means
    that both the slash command and the processing response will be visible to all
    in the channel:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们特别想要一个 `in-channel` 响应。在这个上下文中，这意味着 slash 命令和处理的响应将对频道中的所有人可见：
- en: '![In-channel and ephemeral responses](img/B05384_06_19.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![频道内和短暂响应](img/B05384_06_19.jpg)'
- en: Both the original slash command and the interim response are visible
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 slash 命令和中间响应都是可见的
- en: 'And finally we query **Wolfram|Alpha**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们查询 **Wolfram|Alpha**：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we again ensure that the Wolfram Alpha result is visible to the entire
    channel. Finally, let''s make some improvements to the display of the data in
    our `queryWolfram` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次确保 Wolfram Alpha 的结果对整个频道可见。最后，让我们对我们的 `queryWolfram` 函数中数据的显示做一些改进：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Improvements here include bolding the title of a section and removing sections
    that have no text associated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的改进包括加粗章节标题和删除没有文本关联的章节。
- en: 'Now that we''ve put it all together, let''s test it out:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有这些都整合在一起了，让我们来测试一下：
- en: '![In-channel and ephemeral responses](img/B05384_06_20.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![频道内和短暂响应](img/B05384_06_20.jpg)'
- en: Wolfram Alpha can also be used to get definitions of popular algorithms
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Wolfram Alpha 还可以用来获取流行算法的定义
- en: Bear in mind that slash commands are available universally in your Slack team.
    In our case, it means that the **Wolfram|Alpha** bot can be triggered from any
    channel, DM, or private group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，slash 命令在您的 Slack 团队中是通用的。在我们的例子中，这意味着 **Wolfram|Alpha** 机器人可以从任何频道、DM 或私人组中触发。
- en: Using webhooks and slash commands
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Webhooks 和 slash 命令
- en: Now that we have a firm grasp on what webhooks and slash commands are, we should
    establish when to use them. First, we should consider when we'd use a webhook
    or slash command over a bot user, which we've learnt to build in previous chapters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Webhooks 和 slash 命令有了明确的了解，我们应该确定何时使用它们。首先，我们应该考虑在什么情况下我们会使用 webhook
    或 slash 命令而不是机器人用户，这是我们之前章节中学到的如何构建机器人用户。
- en: A bot user generally operates on a one-to-one basis; every bot requires a Slack
    token unique to that bot, meaning that the bot can only interact with the team
    associated with that token. This also allows the bot to maintain a real-time messaging
    connection with Slack and to reconnect in case of connection failure. Webhooks
    and slash commands, on the other hand, exist as external services and can be reused
    by many teams. By removing the need for a Slack token, you open up your app to
    be used by many other teams.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人用户通常以一对一的方式进行操作；每个机器人都需要一个唯一的 Slack 令牌，这意味着机器人只能与该令牌关联的团队进行交互。这也允许机器人与 Slack
    保持实时消息连接，并在连接失败的情况下重新连接。另一方面，Webhooks 和 slash 命令作为外部服务存在，可以被许多团队重复使用。通过消除对 Slack
    令牌的需求，您可以让您的应用被许多其他团队使用。
- en: 'Use this flowchart to decide whether a webhook or a slash command is best for
    your needs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此流程图来决定 webhook 或 slash 命令是否最适合您的需求：
- en: '![Using webhooks and slash commands](img/B05384_06_21.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Webhooks 和 slash 命令](img/B05384_06_21.jpg)'
- en: When to use webhooks or slash commands
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用 Webhooks 或 slash 命令
- en: In the preceding diagram, we mention the concepts of **active** and **reactive**.
    We covered these concepts back in [Chapter 3](ch03.html "Chapter 3. Adding Complexity"),
    *Adding Complexity*, but the basic gist is that active apps and bots post messages
    without requiring input, whereas reactive bots respond to stimuli in the form
    of user input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们提到了 **主动** 和 **响应** 的概念。我们在 [第 3 章](ch03.html "第 3 章。增加复杂性") 中讨论了这些概念，*增加复杂性*，但基本要点是，主动应用和机器人无需输入即可发布消息，而响应式机器人会以用户输入的形式对刺激做出反应。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what webhooks are and how to set them up to send data
    out of Slack and get data into Slack through a third-party server. We also discussed
    slash commands and how to implement them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Webhooks 是什么以及如何设置它们以将数据从 Slack 发送到第三方服务器，并通过第三方服务器将数据传入 Slack。我们还讨论了
    slash 命令以及如何实现它们。
- en: In the next chapter, we will cover how to publish your app so that other teams
    can make use of your bots, webhooks, and slash commands.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何发布您的应用，以便其他团队可以使用您的机器人、Webhooks 和 slash 命令。
