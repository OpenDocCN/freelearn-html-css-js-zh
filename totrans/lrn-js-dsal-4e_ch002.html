<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>
<link rel="stylesheet" type="text/css" href="../override_v1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/><link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section id="introducing-data-structures-and-algorithms-in-javascript" class="level1 pkt" data-number="2">
<h1 data-number="2">1 Introducing Data Structures and Algorithms in JavaScript</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="../media/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p><strong>JavaScript</strong> is an immensely powerful language. It is one of the most popular languages in the world and is one of the most prominent languages on the internet. For example, GitHub (the world's largest code host, available at <a href="https://github.com">https://github.com</a>) hosts over 300,000 JavaScript repositories at the time of writing (the largest number of active repositories available on GitHub are in JavaScript; refer to <a href="http://githut.info">http://githut.info</a>). The number of projects in JavaScript on GitHub grows every year.</p>
<p>JavaScript is an essential skill for any web developer. It offers a convenient environment for learning data structures and algorithms, requiring only a text editor or browser to get started. More importantly, JavaScript's widespread use in web development allows you to directly apply this knowledge to build efficient, scalable web applications, optimizing performance and handling complex tasks.</p>
<p>Data structures and algorithms are fundamental building blocks of software development. Data structures provide ways to organize and store data, while algorithms define the operations performed on that data. Mastering these concepts is crucial for creating well-structured, maintainable, and high-performing JavaScript code.</p>
<p>In this chapter, we'll cover the essential JavaScript syntax and functionalities needed to start building our own data structures and algorithms. Additionally, we'll introduce TypeScript, a language that builds upon JavaScript and offers enhanced code safety, structure, and tooling. This will enable us to create data structures and algorithms using both JavaScript and TypeScript, showcasing their respective strengths. We will cover:</p>
<ul>
<li>The importance of data structures</li>
<li>Why algorithms matter</li>
<li>Why companies ask for these concepts during interviews</li>
<li>Why choose JavaScript to learn data structures and algorithms</li>
<li>Setting up the environment</li>
<li>JavaScript fundamentals</li>
<li><strong>TypeScript</strong> fundamentals</li>
</ul>
<section id="the-importance-of-data-structures" class="level2" data-number="2.1">
<h2 data-number="2.1">The importance of data structures</h2>
<p>A data structure is a way to organize and store data in a computer's memory, enabling the data to be efficiently accessed and modified.</p>
<p>Think about data structures as containers designed to hold specific types of information, that have their own way of arranging and managing the information. For example, in your home, you cook food in the kitchen, sleep in the bedroom, and take a shower in the bathroom. Each place in a house or apartment is designed with a specific goal for certain tasks so we can keep our home organized.</p>
<p>In the real world, data can often be overly complex, due to factors such as volume, various forms (numbers, dates, text, images, emails), and the speed that data is generated, among other factors. Data structures bring order to this chaos, allowing computers to handle vast amounts of information systematically and efficiently. Think of it like a well-organized library compared to a very large pile of books. Finding a specific book is easier in the library as the books are organized by genre and by author (alphabetically).</p>
<p>Good data structure choices help programs perform consistently regardless of the amount of data being processed. Imagine needing to store data for the weather forecast for 10 days versus 10 years. The use of the correct data structure can make a difference between an algorithm crashing or being able to scale.</p>
<p>And finally, a data structure can drastically impact how easy it is to write algorithms that work with that data. For example, finding the shortest route on a map can be efficiently solved using a graph data structure that shows which cities are connected by what distances, rather than an unordered array of city names.</p>
</section>
<section id="why-algorithms-matter" class="level2" data-number="2.2">
<h2 data-number="2.2">Why algorithms matter</h2>
<p>Computers are powerful tools, but their intelligence is derived from the instructions we provide. Algorithms are the sets of rules and procedures that guide a computer's actions, enabling it to solve problems, make decisions, and perform complex tasks. In essence, algorithms are the language through which we communicate with computers, transforming them from mere machines into intelligent problem-solvers.</p>
<p>Algorithms can turn tasks into repeatable and automated processes. If you need to generate a report every day at work, this is a task that can be automated using an algorithm.</p>
<p>Algorithms are around us every day, from search engines to social networks, to self-driving cars. Algorithms and data structures are what make them function. Understanding data structures and algorithms unlocks the ability to create and innovate in the technology world.</p>
<p>As software developers, writing algorithms and manipulating data are core aspects of our work. This is precisely why companies emphasize these concepts in job interviews – they are essential skills for assessing a candidate's problem-solving abilities and their potential to contribute effectively to software development projects.</p>
</section>
<section id="why-companies-ask-for-these-concepts-during-interviews" class="level2" data-number="2.3">
<h2 data-number="2.3">Why companies ask for these concepts during interviews</h2>
<p>There are many reasons why companies focus on data structures and algorithms concepts during job interviews, even if you are not going to use some of these concepts during daily tasks, including:</p>
<ul>
<li>Problem-solving skills: data structures and algorithms are a great tool to evaluate the candidate's problem-solving abilities. They can be used to evaluate how a person approaches unfamiliar problems, breaks them down into smaller tasks and designs a solution.</li>
<li>Coding proficiency: companies can evaluate how candidates translate their solution into clean and efficient code, how candidates choose the appropriate data structure for the problem, design an algorithm with the correct logic, consider edge cases and optimize their code.</li>
<li>Software performance: a strong understanding of data structures and algorithms translates directly to successful delivery of every development task, such as designing scalable solutions by choosing the right data structure and algorithms, especially when dealing with large datasets. In the realm of Big Data, where you're likely dealing with massive datasets, it is crucial that your solution not only functions correctly but also operates efficiently at scale. Performance optimization often relies on selecting the optimal data structure or tweaking existing algorithms.</li>
<li>Debugging and troubleshooting: A solid grasp of data structures and algorithms can help engineers pinpoint where issues might occur within their code.</li>
<li>Ability to learn and adapt: technology is always evolving, as well as programming languages and frameworks, however, data structures and algorithms concepts remain fundamental throughout the years. That is one of the reasons we often say these concepts are part of the basic knowledge about computer science. And once you learn the concepts in one language, you can easily adapt to a different programming language. This helps companies test if a person can adapt to changing requirements, which is essential in this industry.</li>
<li>Communication: usually, when companies present a problem to be solved using data structures and algorithms, they are not looking for the eventual answer, but the process that the candidate follows to get to the definitive answer. Companies can evaluate how candidates are able to explain their thought process and reason behind their decision-making approach; and the candidate's ability to discuss different trade-offs involved in choosing different data structures and algorithms to resolve the program. This can be used to evaluate if a person can collaborate within a team setting and if the candidate can clearly communicate a message.</li>
</ul>
<p>Of course, these are only some of the factors that companies will evaluate, and domain-specific knowledge, experience and cultural fit are also crucial factors when choosing the right candidate for a job position.</p>
</section>
<section id="why-choose-javascript-to-learn-data-structures-and-algorithms" class="level2" data-number="2.4">
<h2 data-number="2.4">Why choose JavaScript to learn data structures and algorithms?</h2>
<p>JavaScript is one of the most popular programming languages in the world, according to various industry surveys, making it an excellent choice if you are already familiar with the basics of programming. The thriving JavaScript community and the abundance of online resources create a supportive and dynamic environment for learning, collaborating, and advancing your career as a JavaScript developer.</p>
<p>JavaScript is also a beginner friendly language and you do not need to worry about complex memory management concepts that exist in other languages such as C++. This is extremely helpful especially when learning data structures like linked lists, trees, and graphs, which are dynamic data structures due to their ability to grow or shrink in size during program execution (runtime), and when using JavaScript, you can focus on the data structure concepts, without mixing with memory management controls.</p>
<p>As JavaScript is used for web development, learning data structures and algorithms with JavaScript allows you to directly apply your skills to building interactive web applications.</p>
<p>However, there is one big disadvantage of using JavaScript: the lack of strict typing that exists in other languages such as C++ and Java. JavaScript is a dynamically typed language, meaning you do not need to explicitly declare the data type of variables. When working with data structures, we need to pay attention to not mix data types within the same data structure as it can lead to subtle errors. Typically, when working with data structures, it is considered best practice to ensure all data within the same structure is of the same type. We will take care of this gap by always using the same data type for the same data structure instance throughout this book and we will also resolve the lack of strict typing by providing the source code in <strong>TypeScript</strong>, which extends JavaScript by adding types to the language.</p>
<p>And it is important to remember: the best language is the one you are most comfortable using and that motivates you to learn. This book will present different data structures and algorithms using JavaScript and TypeScript, and you can always adapt the concepts to another programming language as well.</p>
</section>
<section id="setting-up-the-environment" class="level2" data-number="2.5">
<h2 data-number="2.5">Setting up the environment</h2>
<p>One of the pros of the JavaScript language compared to other languages is that you do not need to install or configure a complicated environment to get started with it. To follow the examples in this book, you will need to download Node.js from <a href="https://nodejs.org">https://nodejs.org</a> so we can execute the source code. On the download page, you will find detailed steps to download and install Node.js in your operating system.</p>
<p>As a rule of thumb, always download the <em>LTS</em> (<em>Long Term Support</em>) version, which is often used by enterprise companies.</p>
<p>While JavaScript can run in both browsers and Node.js, the latter provides a more streamlined and focused environment for studying data structures and algorithms. Node.js eliminates browser-specific complexities, offers powerful debugging tools, and facilitates a more direct approach to learning these core concepts.</p>
<p>The source code for this book is also available in TypeScript, which offers enhanced type safety and structure. To run TypeScript code, including the examples in this book, we'll need to transpile it into JavaScript, a process we will cover in detail.</p>
<section id="installing-a-code-editor-or-ide" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1">Installing a code editor or IDE</h3>
<p>We also need an editor or <strong>IDE</strong> (<em>Integrated Development Environment</em>) to be able to develop an application in a comfortable environment. For the examples in this book, the author used <strong>Visual Studio Code</strong> (<strong>VSCode</strong>), a free and open-source editor. However, you can use any editor of your choice (Notepad++, WebStorm, and other editors or IDEs available on the market).</p>
<blockquote>
<p>You can download the <strong>VSCode</strong> installer for your operating system at <a href="https://code.visualstudio.com">https://code.visualstudio.com</a>.</p>
</blockquote>
<p>Now that we have everything we need, we can start coding our examples!</p>
</section>
</section>
<section id="javascript-fundamentals" class="level2" data-number="2.6">
<h2 data-number="2.6">JavaScript Fundamentals</h2>
<p>Before we start diving into the various data structures and algorithms, let's have a quick overview of the JavaScript language. This section will present the JavaScript fundamental concepts required to implement the algorithms we will create in the subsequent chapters.</p>
<section id="hello-world" class="level3" data-number="2.6.1">
<h3 data-number="2.6.1">Hello World</h3>
<p>We will begin with the classic "Hello, World!" example, a simple program that displays the message "Hello, World!".</p>
<p>Let's create our first example together. Follow these steps:</p>
<ol>
<li>Create a folder named <code>javascript-datastructures-algorithms</code>.</li>
<li>Inside it, create a folder named <code>src</code> (source, where we will create our files for this book).</li>
<li>Inside the <code>src</code> folder, create a folder named <code>01-intro</code></li>
</ol>
<p>We can place all the examples for this chapter inside this directory. Now let's create a <code>Hello, World</code> example. To do so, create a file named <code>01-hello-variables.js</code>. Inside the file, add the code below:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('Hello, World!');</code></pre>
</div>
<p>To run this example, you can use the default operating system terminal or command prompt (or in case you are using Visual Studio Code, open the built-in terminal) and execute the following command:</p>
<div class="C0-SHConPACKT">
<pre><code>node src/01-intro/01-hello-variables.js</code></pre>
</div>
<p>You will see the "<code>Hello, World!</code>" output, as shown in the image below:</p>
<figure>
<img src="../media/file1.png" alt="Figure 1.1 – Visual Studio Code with JavaScript Hello, World! example" width="1210" height="754"/><figcaption aria-hidden="true">Figure 1.1 – Visual Studio Code with JavaScript Hello, World! example</figcaption>
</figure>
<blockquote>
<p>For every source file for this book, you will see in the first line the path of the file, followed by the source code we will create together, and the file will end with the command we can use to see the output in the terminal.</p>
</blockquote>
</section>
<section id="variables-and-data-types" class="level3" data-number="2.6.2">
<h3 data-number="2.6.2">Variables and data types</h3>
<p>There are three ways of declaring a variable in JavaScript:</p>
<ol>
<li><code>var</code>: declares a variable, and it is optional to initialize it with a value. This is the oldest way to declare variables in JavaScript.</li>
<li><code>let</code>: declares a local variable, block-scoped (this means the variable is only accessible within the specific block of code such as inside a loop or conditional statement), and it is also optional to initialize it with a value. For our algorithms, this will be our preferred way due to its more predictable behavior.</li>
<li><code>const</code>: declares a read-only constant. It is mandatory to initialize it, and we will not be able to re-assign it.</li>
</ol>
<p>Let's see a few examples:</p>
<div class="C0-SHCodePACKT">
<pre><code>var num = 1;
num = 'one' ;
let myVar = 2;
myVar = 4;
const price = 1.5;</code></pre>
</div>
<p>Where:</p>
<ol>
<li>In the first line, we have an example of how to declare a variable in JavaScript (the legacy way, before modern JavaScript). Although it is not necessary to use the <code>var</code> keyword declaration, it is a good practice to always specify when we declare a new variable.</li>
<li>In the second line, we updated an existing variable. JavaScript is not a strongly typed language. This means you can declare a variable, initialize it with a number, and then update it with a text or any other datatype. Assigning a value to a variable that is different from its original type is often not considered a good practice, although it is possible.</li>
<li>In the third line, we also declared a number, but this time we are using the <code>let</code> keyword to specify this is a local variable.</li>
<li>In the fourth line, we can change the value of <code>myVar</code> to a different number;</li>
<li>In the fifth line, we declared another variable, but this time using the <code>const</code> keyword. This means the value of this variable is final and if we try to assign another value, we will get an error (<em>assignment to constant variable</em>).</li>
</ol>
<p>Let's see next what datatypes are supported by JavaScript.</p>
<section id="data-types" class="level4" data-number="2.6.2.1">
<h4 data-number="2.6.2.1">Data types</h4>
<ul>
<li>The latest <strong>ECMAScript</strong> standard (the JavaScript specification) defines a few primitive data types at the time of writing:
<ul>
<li><strong>Number</strong>: an integer or floating number;</li>
<li><strong>String</strong>: a text value;</li>
<li><strong>Boolean</strong>: true or false values;</li>
<li><strong>null</strong>: a special keyword denoting a null value;</li>
<li><strong>undefined</strong>: a variable with no value or that has not been initialized;</li>
<li><strong>Symbol</strong>, which are unique and immutable;</li>
<li><strong>BigInt</strong>: an integer with arbitrary precision: <code>1234567890n</code>;</li>
<li>and <strong>Object</strong>.</li>
</ul></li>
</ul>
<p>Let's see an example of how to declare variables that hold different data types:</p>
<div class="C0-SHCodePACKT">
<pre><code>const price = 1.5; // number
const publisher = 'Packt'; // string
const javaScriptBook = true; // boolean
const nullVar = null; // null
let und; // undefined</code></pre>
</div>
<p>If we want to see the value of each variable we declared, we can use <code>console.log</code> to do so, as listed in the following code snippet:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('price: ' + price);
console.log('publisher: ' + publisher);
console.log('javaScriptBook: ' + javaScriptBook);
console.log('nullVar: ' + nullVar);
console.log('und: ' + und);</code></pre>
</div>
<blockquote>
<p>The console.log method also accepts more than one argument. Instead of <code>console.log('num: ' + num)</code>, we can also use <code>console.log('num: ', num)</code>. While the first option will concatenate the result into a single string, the second allows us to add a description and visualize the variable content in case it is an object.</p>
</blockquote>
<p>In JavaScript, the <code>typeof</code> operator is an operator that helps to determine the data type of a variable or expression. It returns a string that represents the type of the operand. In case we would like to check the type of the declared variables, we can use the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('typeof price: ', typeof price); // number
console.log('typeof publisher: ', typeof publisher); // string
console.log('typeof javaScriptBook: ', typeof javaScriptBook); // boolean
console.log('typeof nullVar: ', typeof nullVar); // object
console.log('typeof und: ', typeof und); // undefined</code></pre>
</div>
<blockquote>
<p>In JavaScript, <code>typeof null</code> returns "object", which can be confusing since <code>null</code> is not actually an object. This is considered a historical quirk or bug in the language.</p>
</blockquote>
<section id="the-object-and-symbol-data-types" class="level5" data-number="2.6.2.1.1">
<h5 data-number="2.6.2.1.1">The object and symbol data types</h5>
<p>In JavaScript, an object is a fundamental data structure that serves as a collection of <em>key-value</em> pairs. These key-value pairs are often referred to as properties or methods of the object. Think of it as a container that can store various types of data and functionality.</p>
<p>If we want to represent a book in JavaScript with attributes like its title, we can effectively do so using an object:</p>
<div class="C0-SHCodePACKT">
<pre><code>const book = {
  title: 'Data Structures and Algorithms',
}</code></pre>
</div>
<p>Objects are a cornerstone of JavaScript programming, providing a powerful way to structure data, encapsulate logic, and model real-world entities.</p>
<p>If we would like to output the title of the book, we can do so using the dot notation as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log('book title: ', book.title);</code></pre>
</div>
<p>Although we are not able to reassign values to a constant, we can <em>mutate</em> it if its data type is an object. Let's see an example:</p>
<div class="C0-SHCodePACKT">
<pre><code>book.title = 'Data Structures and Algorithms in JavaScript';
// book = {anotherTitle:'Data Structures'} this will not work</code></pre>
</div>
<p>Mutaing an object means changing the properties within the existing object as we just did. Reassigning an object means changing the entire object that a variable refers to as showed in the following example:</p>
<div class="C0-SHCodePACKT">
<pre><code>let book2 = {
  title: 'Data Structures and Algorithms',
}
book2 = { title: 'Data Structures' };</code></pre>
</div>
<p>This concept is important, as we will use it in a lot of examples.</p>
<p>JavaScript also supports a special and unique data type called <strong>symbol</strong>. Symbols serve as unique identifiers and are primarily used for the following purposes:</p>
<ul>
<li>Unique property keys: symbols can be used as keys for object properties, ensuring that these properties are distinct and will not clash with any other keys (even strings with the same name). This is particularly useful when working with libraries or modules where naming conflicts might arise.</li>
<li>Hidden properties: symbols are not enumerable by default, meaning they will not show up in <code>for...in</code> loops or <code>Object.keys()</code>. This makes them ideal for creating <em>private</em> properties within objects.</li>
</ul>
<p>Let's see an example for better understanding:</p>
<div class="C0-SHCodePACKT">
<pre><code>const title = Symbol('title');
const book3 = {
  [title]: 'Data Structures and Algorithms'
};
console.log(book3[title]); // Data Structures and Algorithms</code></pre>
</div>
<p>In this example, we are creating a symbol <code>title</code> and using it as a key for the <code>book3</code> object. When we need to access this property, we cannot simply use <code>book3.title</code> using the dot notation, but <code>book3.[title]</code>, using the brackets notation.</p>
<p>We will not use symbols in the examples of this book, but it is an interesting concept to know.</p>
</section>
</section>
</section>
<section id="control-structures" class="level3" data-number="2.6.3">
<h3 data-number="2.6.3">Control structures</h3>
<p>JavaScript has a similar set of control structures as the C and Java languages. Conditional statements are supported by <code>if...else</code> and <code>switch</code>. JavaScript also supports different loop statements such as <code>for</code>, <code>while</code>, <code>do…while</code>, <code>for…in</code> and <code>for…of</code>.</p>
<p>In this section, we explore both conditional statements and loop statements, starting with conditional statements.</p>
<section id="conditionals" class="level4" data-number="2.6.3.1">
<h4 data-number="2.6.3.1">Conditionals</h4>
<p>Conditional statements in JavaScript are essential building blocks for controlling the flow of your code. They allow you to make decisions based on certain conditions and execute different code blocks accordingly.</p>
<p>We can use the <code>if</code> statement if we want to execute a block of code only if the condition is true. And we can use the optional <code>else</code> statement if the condition is false:</p>
<div class="C0-SHCodePACKT">
<pre><code>let number = 0;
if (number === 1) {
  console.log('number is equal to 1');
} else {
  console.log('number is not equal to 1, the value of number is ' + number);
}</code></pre>
</div>
<p>The <code>if...else</code> statement can also be represented by a ternary operator. For example, take a look at the following if...else statement:</p>
<div class="C0-SHCodePACKT">
<pre><code>if (number === 1) {
  number--;
} else {
  number++;
}</code></pre>
</div>
<p>It can also be represented as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>number === 1 ? number-- : number++;</code></pre>
</div>
<p>Ternary operators are expressions that evaluate to a value, whereas the if-statement is just an imperative statement. This means we can use it directly within another expression, assign its result to a variable, or use it as an argument in a function call. For example, we can rewrite the previous example as following, without changing its output:</p>
<div class="C0-SHCodePACKT">
<pre><code>number = number === 1 ? number - 1 : number + 1;</code></pre>
</div>
<p>Also, if we have several scripts, we can use <code>if...else</code> several times to execute different scripts based on different conditions, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>let month = 5;
if (month === 1) {
  console.log('January');
} else if (month === 2) {
  console.log('February');
} else if (month === 3) {
  console.log('March');
} else {
  console.log('Month is not January, February or March');
}</code></pre>
</div>
<p>Finally, we have the <code>switch</code> statement. The <code>switch</code> statement provides an alternative way to write multiple <code>if...else</code> if chains. It evaluates an expression and then matches its value against a series of cases. When a match is found, the code associated with that case is executed:</p>
<div class="C0-SHCodePACKT">
<pre><code>switch (month) {
  case 1:
    console.log('January');
    break;
  case 2:
    console.log('February');
    break;
  case 3:
    console.log('March');
    break;
  default:
    console.log('Month is not January, February or March');
}</code></pre>
</div>
<p>JavaScript will look for a match of the value (in this example, the variable <code>month</code>) in one of the <code>case</code> statements. If no match is found, then the <code>default</code> statement is executed. The <code>break</code> clause inside each <code>case</code> statement will halt the execution and break out of the <code>switch</code> statement. If we do not add the <code>break</code> statement, the code inside each subsequent <code>case</code> statement is also executed, including the <code>default</code> statement.</p>
</section>
<section id="loops" class="level4" data-number="2.6.3.2">
<h4 data-number="2.6.3.2">Loops</h4>
<p>In JavaScript, loops are fundamental structures that allow you to repeatedly execute a block of code as long as a specified condition is <code>true</code>. They are essential for automating repetitive tasks and iterating over collections of data like arrays or objects.</p>
<p>The <code>for</code> loop is the same as in C and Java. It consists of a loop counter that is usually assigned a numeric value, then the variable is compared against the condition to break the loop, and finally the numeric value is increased or decreased.</p>
<p>In the following example, we have a <code>for</code> loop. It outputs the value of <code>i</code> in the console, while <code>i </code>is less than <code>10</code>. <code>i</code> is initiated with 0, so the following code will output the values 0 to 9:</p>
<div class="C0-SHCodePACKT">
<pre><code>for (let i = 0; i &lt; 10; i++) {
  console.log(i);
}</code></pre>
</div>
<p>In the <code>for</code> loop, first we have the initialization (<code>let i = 0</code>), which happens only once, before the loop starts. Next, we have the condition that is evaluated before each iteration (<code>i &lt; 10</code>). If it evaluates to <code>true</code>, the loop's body is executed. If it is <code>false</code>, the loop ends. We then have the final expression, (<code>i++</code>), which is often used to update the counter variable. The final expression is executed after the body of the loop is executed.</p>
<p>The next loop construct we will look at is the <code>while</code> loop. The script inside the while loop is executed while the condition is true.</p>
<p>In the following code, we have a variable <code>i</code>, initiated with the value 0, and we want the value of <code>i</code> to be logged while <code>i</code> is less than 10 (or less than or equal to 9). The output will be the values from 0 to 9:</p>
<div class="C0-SHCodePACKT">
<pre><code>let i = 0;
while (i &lt; 10) {
  console.log(i);
  i++;
}</code></pre>
</div>
<p>The <code>do...while</code> loop is similar. The only difference is that in the <code>while</code> loop, the condition is evaluated before executing the script, and in the <code>do...while</code> loop, the condition is evaluated after the script is executed. The <code>do...while</code> loop ensures that the script is executed at least once. The following code also outputs the values from 0 to 9:</p>
<div class="C0-SHCodePACKT">
<pre><code>i = 0;
do {
  console.log(i);
  i++;
} while (i &lt; 10);</code></pre>
</div>
<p>The <code>for…in</code> loop iterates a variable over the properties of an object. This loop is especially useful when working with dictionaries and sets.</p>
<p>In the following code, we will declare an object, and output the name of each property, along with its value:</p>
<div class="C0-SHCodePACKT">
<pre><code>const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key, obj[key]);
}
// output: a 1 b 2 c 3</code></pre>
</div>
<p>The <code>for…of</code> loop iterates a variable over the values of an Array, Map or Set as shown by the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>const arr = [1, 2, 3];
for (const value of arr) {
  console.log(value);
}
// output: 1 2 3</code></pre>
</div>
</section>
</section>
<section id="functions" class="level3" data-number="2.6.4">
<h3 data-number="2.6.4">Functions</h3>
<p>Functions are important when working with JavaScript. Functions are blocks of code designed to perform specific tasks. They are one of the fundamental building blocks in JavaScript and offer a way to organize code, promote reusability, and improve maintainability. We will also use functions in our examples.</p>
<p>The following code demonstrates the basic syntax of a function:</p>
<div class="C0-SHCodePACKT">
<pre><code>function sayHello(name) {
  console.log('Hello! ', name);
}</code></pre>
</div>
<p>The purpose of this function is to create a reusable piece of code that greets a person by their name. We have one parameter named <code>name</code>. A parameter acts as a placeholder for a value that will be provided when the function is called.</p>
<p>To execute this code, we simply use the following statement:</p>
<div class="C0-SHCodePACKT">
<pre><code>sayHello('Packt');</code></pre>
</div>
<p>The string "Packt" is passed as an argument. This value is assigned to the <code>name</code> parameter inside the function.</p>
<p>A function can also return a value, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>function sum(num1, num2) {
  return num1 + num2;
}</code></pre>
</div>
<blockquote>
<p>Note that in JavaScript, a function will always return a value. A function can explicitly return a value using the <code>return</code> keyword followed by an expression.</p>
<blockquote>
<p>If a function doesn't have a <code>return</code> statement (as in the <code>sayHello</code> example above) or reaches the end of its code block without encountering a <code>return</code>, it implicitly returns <code>undefined</code>.</p>
</blockquote>
</blockquote>
<p>This function calculates the sum of two given numbers and returns its result. We can use it as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>const result = sum(1, 2);
console.log(result); // outputs 3</code></pre>
</div>
<p>We can also assign default values to the parameters. In case we do not pass the value, the function will use the default value:</p>
<div class="C0-SHCodePACKT">
<pre><code>function sumDefault(num1, num2 = 2) { // num2 has a default value
    return num1 + num2;
}
console.log(sumDefault(1)); // outputs 3
console.log(sumDefault(1, 3)); // outputs 4</code></pre>
</div>
<p>We will explore more about functions throughout this book, as well as other advanced features related to functions, especially when covering the algorithms section.</p>
<section id="variable-scope" class="level4" data-number="2.6.4.1">
<h4 data-number="2.6.4.1">Variable scope</h4>
<p>The scope refers to where in the algorithm we can access the variable. To understand how variables scope work, let's use the following example:</p>
<div class="C0-SHCodePACKT">
<pre><code>let movie = 'Lord of the Rings';
function starWarsFan() {
  const movie = 'Star Wars';
  return movie;
}
function marvelFan() {
  movie = 'The Avengers';
  return movie;
}</code></pre>
</div>
<p>Now let's log some output so we can see the results:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(movie); // Lord of the Rings
console.log(starWarsFan()); // Star Wars
console.log(marvelFan()); // The Avengers
console.log(movie); // The Avengers</code></pre>
</div>
<p>Following is the explanation of why we got this output:</p>
<ul>
<li>We start by declaring a variable named <code>movie</code> in the global scope and assigning it the value "Lord of the Rings". This variable can be accessed from anywhere in the code. The first <code>console.log</code> statement is printing the initial value of this variable.</li>
<li>For the <code>starWarsFan</code> function, we declared a new variable named <code>movie</code> using <code>const</code>. This variable has the same name as the global variable <code>movie</code>, but it exists only within the function's scope. This is called "<strong>shadowing</strong>", where the local variable hides the global one within the function's context. The second <code>console.log</code> is calling the <code>starWarsFan</code> function. It prints "Star Wars" because inside the function we are working with the local variable <code>movie</code>, leaving the global <code>movie</code> variable unchanged.</li>
<li>Next, we have the marvelFan function, which does not declare a new <code>movie</code> variable using <code>let</code> or <code>const</code>. Instead, it directly modifies the global <code>movie</code> variable by assigning it the value "The Avengers". This is possible because there is no local variable to shadow the global one. So, we print the third console.log calling this function, the output is "The Avengers".</li>
<li>Finally, we have the last <code>console.log(movie)</code>. This again prints the global <code>movie</code> variable, which now holds the value "The Avengers" due to the previous <code>marvenFan</code> function call.</li>
</ul>
<p>Let's review a second example, this time using only a function, to showcase how variable scope affects the visibility and value of variables within different parts of the code:</p>
<div class="C0-SHCodePACKT">
<pre><code>function blizzardFan() {
  const isFan = true;
  let phrase = 'Warcraft';
  console.log('Before if: ' + phrase);
  if (isFan) {
    let phrase = 'initial text';
    phrase = 'For the Horde!';
    console.log('Inside if: ' + phrase);
  }
  phrase = 'For the Alliance!';
  console.log('After if: ' + phrase);
}</code></pre>
</div>
<p>When we call the blizzardFan() function, the output will be:</p>
<div class="C0-SHCodePACKT">
<pre><code>Before if: Warcraft
Inside if: For the Horde!
After if: For the Alliance!</code></pre>
</div>
<p>Let's understand why:</p>
<ol>
<li>We start by declaring a constant variable <code>isFan</code> and initializing it with the value <code>true</code>. Since it is declared with <code>const</code>, its value cannot be changed.</li>
<li>A variable <code>phrase</code> is declared using <code>let</code> and assigned the value 'Warcraft'.</li>
<li>Next, we have the first console.log that outputs the current value of the phrase variable which is Warcraft.</li>
<li>Then we have the <code>if (isFan)</code> block. Since <code>isFan</code> is <code>true</code>, the code inside the if block is executed.</li>
<li>Inside the if block, we declare a new variable, also named <code>phrase</code>, within the if block's scope. This creates a separate, block-scoped variable that shadows the outer <code>phrase</code> variable.</li>
<li>The value of the inner <code>phrase</code> variable (the one declared within the if block) is changed to "For the Horde!".</li>
<li><code>console.log('Inside if: ' + phrase)</code> prints "Inside if: For the Horde!" because this is the inner <code>phrase</code> variable.</li>
<li>After the if block, the outer <code>phrase</code> variable (the one declared at the beginning of the function) is still accessible. Its value is changed to "For the Alliance!".</li>
<li>Finally, <code>console.log('After if: ' + phrase)</code> prints "After if: For the Alliance!" because we are printing the variable we declared in the first line of the function.</li>
</ol>
<p>Now that we know the basics of the JavaScript language, let's see how we can use it in an Object-oriented programming approach.</p>
</section>
</section>
<section id="object-oriented-programming-in-javascript" class="level3" data-number="2.6.5">
<h3 data-number="2.6.5">Object-oriented programming in JavaScript</h3>
<p><strong>Object-Oriented Programming (OOP)</strong> in JavaScript consist of five concepts:</p>
<ol>
<li>Objects: these are the fundamental building blocks of OOP. They represent real-world entities or abstract concepts, encapsulating both data (properties) and behavior (methods).</li>
<li>Classes: these are a more structured way to create objects. A class serves as a blueprint for creating multiple objects (instances) of a similar type.</li>
<li>Encapsulation: this involves bundling data and the functions that operate on that data into a single unit (the object). It protects the object's internal state and allows you to control access to its properties and methods.</li>
<li>Inheritance: this allows us to create new classes (child classes) that inherit properties and methods from existing classes (parent classes). This promotes code reusability and establishes relationships between classes.</li>
<li>Polymorphism: this means <em>many forms</em>. In OOP, it refers to the ability of objects of different classes to respond to the same method call in their own unique way.</li>
</ol>
<p>OOP helps organize code, promotes reusability, makes code more maintainable, and allows for better modeling of real-world relationships. Let's review each concept to understand how they work in JavaScript.</p>
<section id="objects-classes-and-encapsulation" class="level4" data-number="2.6.5.1">
<h4 data-number="2.6.5.1">Objects, classes and encapsulation</h4>
<p>JavaScript objects are simple collections of name-value pairs.</p>
<p>There are two ways of creating a simple object in JavaScript. An example of the first way is as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>let obj = new Object();</code></pre>
</div>
<p>And an example of the second way is as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>obj = {};</code></pre>
</div>
<p>The example of the second way is called an object literal, which is a means to create and define objects directly in the code using a convenient notation. It is one of the most common ways to work with objects in JavaScript and also the preferred way over the <code>new Object</code> constructor in the first example, due to convenience (compact syntax), and overall performance when creating objects.</p>
<p>We can also create an object entirely, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>obj = {
  name: {
    first: 'Gandalf',
    last: 'the Grey'
  },
  address: 'Middle Earth'
};</code></pre>
</div>
<p>To declare a JavaScript object, <em>[key, value]</em> pairs are used, where the key can be considered a property of the object and the value is the property value. In the previous example, <code>address</code> is the key, and its value is "Middle Earth". We will use this concept when creating some data structures, such as Sets or Dictionaries.</p>
<p>Objects can contain other objects as their properties. We call them nested objects. This creates a hierarchical structure where objects can be nested within each other at multiple levels, as we can see in the previous example, where <code>name</code> is a nested object within <code>obj</code>.</p>
<p>In Object-Oriented Programming (OOP), an object is an instance of a class. A class defines the characteristics of the object and helps us with encapsulation, bundling the properties and methods so they can work as one unit (an object). For our algorithms and data structures, we will create some classes that will represent them. This is how we can define a class that represents a book:</p>
<div class="C0-SHCodePACKT">
<pre><code>class Book {
  #percentagePerSale = 0.12;
  constructor(title, pages, isbn) {
    this.title = title;
    this.pages = pages;
    this.isbn = isbn;
  }
  get price() {
    return this.pages * this.#percentagePerSale;
  }
  static copiesSold = 0;
  static sellCopy() {
    this.copiesSold++;
  }
  printIsbn() {
    console.log(this.isbn);
  }
}</code></pre>
</div>
<p>We can declare properties in a JavaScript class through the constructor. JavaScript will automatically declare a property that is public, meaning it can be accessed and modified directly.</p>
<p>Inside the constructor, <code>this</code> refers to the object instance being created. In the case of our example, this is referencing itself. We could interpret the code as this book's title is being assigned the title value passed to the constructor.</p>
<p>Modern JavaScript also allows us to declare private properties by adding the prefix <code>#</code> as in <code>#percentagePerSale</code>. This property is only visible inside the class and cannot be accessed directly.</p>
<blockquote>
<p>Public members (properties and methods) are accessible from anywhere, both inside and outside the class. By default, all members in a JavaScript class are public.</p>
<blockquote>
<p>Private members are accessible only from within the class itself. They cannot be accessed or modified directly from outside the class, providing better encapsulation and data protection.</p>
</blockquote>
</blockquote>
<p>We can also create getters using the <code>get</code> keyword (<code>get price()</code>). These can be used to declare a property that returns a calculated value based on the object's other properties. In this case, the price of the book depends on the number of <code>pages</code> (which is a public property) and the percentage of profit per sale, which is private. We access a property locally inside the class by referencing the keyword <code>this</code>.</p>
<p>We can also declare methods in a class (<code>printIsbn</code>). Methods are simply functions that are associated with the class. They define the actions or behaviors that objects created from the class (instances) can perform.</p>
<p>Modern JavaScript also allows us to declare static properties using the <code>static</code> keyword and static methods. Static properties are shared between all instances of the class, which is a fantastic way to keep track of properties that are shared between every object in the class (such as a count of how many books have been sold in total, for example). In other languages such as Ruby, they are classes class variables.</p>
<p>Static methods do not require an instance of the class and can be accessed directly, such as <code>Book.sellCopy()</code>.</p>
<p>To instantiate this class, we can use the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>let myBook = new Book('title', 400, 'isbn');</code></pre>
</div>
<p>Then, we can access its public properties and update them as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(myBook.title); // outputs the book title
myBook.title = 'new title'; // update the value of the book title
console.log(myBook.title); // outputs the updated value: new title</code></pre>
</div>
<p>We can use the getter method to find out the price of the book as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(myBook.price); // 48</code></pre>
</div>
<p>And access the static property and method as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(Book.copiesSold); // 0
Book.sellCopy();
console.log(Book.copiesSold); // 1
Book.sellCopy();
console.log(Book.copiesSold); // 2</code></pre>
</div>
<p>What if we would like to represent another type of book, such as an e-book? Can we reuse some of the definitions we have declared in the <code>Book</code> class? Let's find out in the next section.</p>
</section>
<section id="inheritance-and-polymorphism" class="level4" data-number="2.6.5.2">
<h4 data-number="2.6.5.2">Inheritance and polymorphism</h4>
<p>JavaScript also allows the use of inheritance, which is a powerful mechanism in OOP that allows us to create new classes (child class) that derive properties and methods from existing classes (parent class or superclass). Let's look at an example:</p>
<div class="C0-SHCodePACKT">
<pre><code>class Ebook extends Book {
  constructor(title, pages, isbn, format) {
    super(title, pages, isbn);
    this.format = format;
  }
  printIsbn() {
    console.log('Ebook ISBN:',this.isbn);
  }
}
Ebook.sellCopy();
console.log(Ebook.copiesSold); // 3</code></pre>
</div>
<p>We can extend another class and inherit its behavior using the keyword <code>extends</code>. In our example, the Ebook is the child class, and the Book is the superclass.</p>
<p>Inside the <code>constructor</code>, we can refer to the constructor <code>superclass</code> using the keyword <code>super</code>. We can add more properties to the child class (<code>format</code>). The child class can still access static methods (<code>sellCopy</code>) and properties (<code>copiesSold</code>) from the superclass.</p>
<p>A child class can also provide its own implementation of a method initially declared in the superclass. This is called <em>method overriding</em> and allows objects of the child class to exhibit different behavior for the same method call.</p>
<p>By overriding methods from the superclass, we can achieve a concept called polymorphism, which literally means many forms. In OOP, polymorphism is the ability of objects of different classes to respond to the same method call in their own unique way. For example:</p>
<div class="C0-SHCodePACKT">
<pre><code>const myBook = new Book('title', 400, 'isbn');
myBook.printIsbn(); // isbn
const myEbook = new Ebook('DS Ebook', 401, 'isbn 123', 'pdf');
myEbook.printIsbn(); // Ebook ISBN: isbn 123</code></pre>
</div>
<p>We have two book instances here, and one of them is an e-book. We can call the method <code>printIsbn</code> from both instances, and we will get different outputs due to the different behavior in each instance.</p>
<p>Most of the data structures we will cover throughout this book will follow the JavaScript class approach.</p>
<blockquote>
<p>Although the class syntax in JavaScript is remarkably similar to other programming languages such as Java and C/C++, it is good to remember that JavaScript object-oriented programming is done through a prototype.</p>
</blockquote>
</section>
</section>
<section id="modern-techniques" class="level3" data-number="2.6.6">
<h3 data-number="2.6.6">Modern Techniques</h3>
<p>JavaScript is a language that continues to evolve and get new features each year. There are some features that make some concepts easier when working with data structures and algorithms. Let's check them out.</p>
<section id="arrow-functions" class="level4" data-number="2.6.6.1">
<h4 data-number="2.6.6.1">Arrow functions</h4>
<p>Arrow functions are a concise and expressive way to write functions in JavaScript. They offer a shorter syntax and some key differences in behavior compared to traditional function expressions. Consider the following example:</p>
<div class="C0-SHCodePACKT">
<pre><code>const circleAreaFn = function(radius) { 
  const PI = 3.14; 
  const area = PI * radius * radius; 
  return area; 
};
console.log(circleAreaFn(2)); // 12.56</code></pre>
</div>
<p>With arrow functions, we can simplify the syntax of the preceding code to the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>const circleArea = (radius) =&gt; {
  const PI = 3.14; 
  return PI * radius * radius; 
};</code></pre>
</div>
<p>The main difference is in the first line of the example, on which we can omit the keyword <code>function</code> using <code>=&gt;</code>, hence the name arrow function.</p>
<p>If the function has a single statement, we can use a simpler version, by omitting the keyword <code>return</code> and the curly brackets as demonstrated in the following code snippet:</p>
<div class="C0-SHCodePACKT">
<pre><code>const circleAreaSimp = radius =&gt; 3.14 * radius * radius;
console.log(circleAreaSimp(2)); // 12.56</code></pre>
</div>
<p>If the function does not receive any argument, we can use empty parenthesis as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>const hello = () =&gt; console.log('hello!');
hello(); // hello!</code></pre>
</div>
<p>We will be using arrow functions to code some algorithms later in this book for a simpler syntax.</p>
</section>
<section id="spread-and-rest-operators" class="level4" data-number="2.6.6.2">
<h4 data-number="2.6.6.2">Spread and rest operators</h4>
<p>In JavaScript, we can turn arrays into parameters using the <code>apply()</code> function. Modern JavaScript has the spread operator (<code>...</code>) for this purpose. For example, consider the function <code>sum</code> as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>const sum = (x, y, z) =&gt; x + y + z;</code></pre>
</div>
<p>We can execute the following code to pass the <code>x</code>, <code>y</code>, and <code>z</code> parameters:</p>
<div class="C0-SHCodePACKT">
<pre><code>const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6</code></pre>
</div>
<p>The preceding code is the same as the code written in classic JavaScript, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(sum.apply(null, numbers));</code></pre>
</div>
<p>The spread operator (<code>...</code>) can also be used as a rest parameter in functions to replace <code>arguments</code>. Consider the following example:</p>
<div class="C0-SHCodePACKT">
<pre><code>const restParamaterFunction = (x, y, ...a) =&gt; (x + y) * a.length;
console.log(restParamaterFunction(1, 2, 'hello', true, 7)); // 9</code></pre>
</div>
<p>The preceding code is the same as the following (also outputs 9 in the console):</p>
<div class="C0-SHCodePACKT">
<pre><code>function restParamaterFunction(x, y) {
  const a = Array.prototype.slice.call(arguments, 2);
  return (x + y) * a.length;
}
console.log(restParamaterFunction(1, 2, 'hello', true, 7));</code></pre>
</div>
<p>The rest and spread operators are going to be useful in some data structures and algorithms throughout this book.</p>
</section>
<section id="exponentiation-operator" class="level4" data-number="2.6.6.3">
<h4 data-number="2.6.6.3">Exponentiation operator</h4>
<p>The exponentiation operator may come in handy when working with math algorithms. Let's use the formula to calculate the area of a circle as an example that can be improved/simplified with the exponentiation operator:</p>
<div class="C0-SHCodePACKT">
<pre><code>let area = 3.14 * radius * radius; </code></pre>
</div>
<p>The expression <code>radius * radius</code> is the same as radius squared. We could also use the <code>Math.pow</code> function available in JavaScript to write the same code:</p>
<div class="C0-SHCodePACKT">
<pre><code>area = 3.14 * Math.pow(radius, 2); </code></pre>
</div>
<p>In JavaScript, the exponentiation operator is denoted by two asterisks (**). It is used to raise a number (the base) to the power of another number (the exponent). We can calculate the area of a circle using the exponentiation operator as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>area = 3.14 * (radius ** 2);  </code></pre>
</div>
</section>
</section>
</section>
<section id="typescript-fundamentals" class="level2" data-number="2.7">
<h2 data-number="2.7">TypeScript fundamentals</h2>
<p>TypeScript is an open source <strong>gradually typed</strong> superset of JavaScript created and maintained by Microsoft. Gradual typing is a type system that combines elements of both static typing and dynamic typing within the same programming language.</p>
<p>TypeScript allows us to add types to our JavaScript code, improving code readability, improving early error detection as we can catch type-related errors during development and enhanced tooling as code editors and IDEs offer better code autocompletion and navigation.</p>
<p>Regarding the scope of this book, with TypeScript we can use some Object-Oriented concepts that are not available in JavaScript such as interfaces - this can be useful when working with data structures and sorting algorithms. And of course, we can also leverage the typing functionality, which is especially important for some data structures. In algorithms that modify data structures, like searching or sorting, ensuring consistent data types within the collection is crucial for smooth operation and predictable outcomes. TypeScript excels at automatically enforcing this type consistency, while JavaScript requires additional measures to achieve the same level of assurance.</p>
<p>All these functionalities are available at <strong>compilation time</strong>. Before TypeScript code can run in a browser or Node.js environment, it needs to be compiled into JavaScript. The TypeScript compiler (<strong>tsc</strong>) takes your TypeScript files (<em>.ts</em> extension) and generates corresponding JavaScript files. During compilation, TypeScript checks the code for type-related errors and provides feedback. This helps catch potential issues early in development, leading to more reliable and easier-to-maintain code.</p>
<p>To work with TypeScript in our data structures and algorithms source code, we will leverage <strong>npm</strong> (<em>Node Package Manager</em>). Let's set up TypeScript as a development dependency within our "<code>javascript-datastructures-algorithms</code>" folder. This involves creating a <code>package.json</code> file, which will manage project dependencies. To initiate this process, execute the following command in the project directory using the terminal:</p>
<div class="C0-SHConPACKT">
<pre><code>npm init</code></pre>
</div>
<p>You will be prompted some questions, simply press <span class="KeystrokePACKT">Enter</span> to proceed. And at the end, we will have a <code>package.json</code> file with the following content:</p>
<div class="C0-SHCodePACKT">
<pre><code>{
  "name": "javascript-datastructures-algorithms",
  "version": "4.0.0",
  "description": "Learning JavaScript Data Structures and Algorithms",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Loiane Groner"
}</code></pre>
</div>
<p>Next, we will install TypeScript:</p>
<div class="C0-SHConPACKT">
<pre><code>npm install --save-dev typescript</code></pre>
</div>
<p>By running this command, we will save the TypeScript as a development dependency, meaning this will only be used locally during development time. This command will also create a <code>package-lock.json</code> file, that can help to ensure that anyone installing the dependencies for the source code from this book will use the exact same packages used for the examples.</p>
<blockquote>
<p>In case you prefer to download the source code, to install the dependencies locally run:</p>
</blockquote>
<pre><code>npm install</code></pre>
<p>Next, we need to create a file with <code>ts</code> extension, which is the extension used for TypeScript files, such as <code>src/01-intro/08-typescript.ts</code> with the following content:</p>
<div class="C0-SHCodePACKT">
<pre><code>let myName = 'Packt';
myName = 10;</code></pre>
</div>
<p>The code above is a simple JavaScript code. Now let's compile it using the <code>tsc</code> command:</p>
<div class="C0-SHConPACKT">
<pre><code>npx tsc src/01-intro/08-typescript.ts</code></pre>
</div>
<p>Where:</p>
<ul>
<li><code>npx</code> is the Node Package eXecute, meaning it is a package runner that we will use to execute the TypeScript compiler command.</li>
<li><code>tsc </code>is the TypeScript compiler command and will compile and transform the source code from src/01-intro/08-typescript.ts into JavaScript.</li>
</ul>
<p>On the terminal, we will get the following warning:</p>
<div class="C0-SHConPACKT">
<pre><code>src/01-intro/08-typescript.ts:4:1 - error TS2322: Type 'number' is not assignable to type 'string'.
4 myName = 10;
  ~~~~~~
Found 1 error in src/01-intro/08-typescript.ts:4</code></pre>
</div>
<p>The warning is due to assigning the numeric value 10 to the variable <code>myName</code> we initialized as string.</p>
<p>But if we verify inside the folder <code>src/01-intro</code> where we created the file, we will see it created a <code>08-typescript.js</code> file with the following content:</p>
<div class="C0-SHCodePACKT">
<pre><code>var myName = 'Packt';
myName = 10;</code></pre>
</div>
<p>The generated code above is JavaScript code. Even with the error in the terminal (which in fact is a warning, not an error), the TypeScript compiler generated the JavaScript code as it should. This reinforces the fact that TypeScript does all the type and error checking during compile-time, it does not prevent the compiler from generating JavaScript code. This allows developers to leverage all these validations while we are writing the code and get a JavaScript code with less chance of errors or bugs.</p>
<section id="type-inference" class="level3" data-number="2.7.1">
<h3 data-number="2.7.1">Type inference</h3>
<p>While working with TypeScript, you can find code as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>let age: number = 20;
let existsFlag: boolean = true;
let language: string = 'JavaScript';</code></pre>
</div>
<p>TypeScript allows us to assign a type to variable. But the code above is verbose. TypeScript has type inference, meaning TypeScript will verify and apply a type to the variable automatically based on the value that was assigned to it. Let's rewrite the preceding code with a cleaner syntax:</p>
<div class="C0-SHCodePACKT">
<pre><code>let age = 20; // number
let existsFlag = true; // boolean
let language = 'JavaScript'; // string</code></pre>
</div>
<p>With the code above, TypeScript still knows that <code>age</code> is a number, <code>existsFlag</code> is a boolean and <code>language</code> is a string, based on the values that they have been assigned to, so no need to explicitly assign a type to these variables.</p>
<p>So, when do we type a variable? If we declare the variable and do not initialize it with a value, then it recommended to assign a type as demonstrated by the code below:</p>
<div class="C0-SHCodePACKT">
<pre><code>let favoriteLanguage: string;
let langs = ['JavaScript', 'Ruby', 'Python'];
favoriteLanguage = langs[0];</code></pre>
</div>
<p>If we do not type a variable, then it is automatically typed as <code>any</code>, meaning it can receive any value, as it is in JavaScript.</p>
<blockquote>
<p>Although we have object types such as <code>String</code>, <code>Number</code>, <code>Boolean</code>, and so on in JavaScript, when typing a variable in TypeScript, it is not a good practice to use the object types with the first letter capital case. When typing a variable in TypeScript, always prefer <code>string</code>, <code>number</code>, <code>boolean</code> (with the lowercase).</p>
<blockquote>
<p><code>String</code>, <code>Number</code>, and <code>Boolean</code> are wrapper objects for the respective primitive types. They provide additional methods and properties, but are generally less efficient and not typically used for basic variable typing. The primitive types (lowercase types) ensure better compatibility with existing JavaScript code and libraries.</p>
</blockquote>
</blockquote>
</section>
<section id="interfaces" class="level3" data-number="2.7.2">
<h3 data-number="2.7.2">Interfaces</h3>
<p>In TypeScript, there are two concepts for interfaces: types and OOP interfaces. Let's review each one.</p>
<section id="interface-as-a-type" class="level4" data-number="2.7.2.1">
<h4 data-number="2.7.2.1">Interface as a type</h4>
<p>In TypeScript, interfaces are a powerful way to define the structure or shape of objects. Consider the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>interface Person {
  name: string;
  age: number;
}
function printName(person: Person) {
  console.log(person.name);
}</code></pre>
</div>
<p>By declaring a <code>Person</code> interface, we are specifying the properties and methods an object might have to adhere to the description of what a <code>Person</code> is, meaning we can use the interface <code>Person</code> as a type, as we have declared as parameters in the <code>printName</code> function.</p>
<p>This allows editors such as VSCode to have autocomplete with intellisense as shown below:</p>
<figure>
<img src="../media/file2.png" alt="Figure 1.2 – Visual Studio Code with intellisense for a type interface" width="1212" height="714"/><figcaption aria-hidden="true">Figure 1.2 – Visual Studio Code with intellisense for a type interface</figcaption>
</figure>
<p>Now let's try using the <code>printName</code> function:</p>
<div class="C0-SHCodePACKT">
<pre><code>const john = { name: 'John', age: 21 };
const mary = { name: 'Mary', age: 21, phone: '123-45678' };
printName(john);
printName(mary);</code></pre>
</div>
<p>The code above does not have any compilation errors. The variable <code>john</code> has a <code>name</code> and <code>age</code> as expected by the <code>printName</code> function. The variable <code>mary</code> has <code>name</code> and <code>age</code>, but also has <code>phone</code> information.</p>
<p>So why does this code work? TypeScript has a concept called <strong>Duck Typing</strong>. If it looks like a duck, emits sounds like a duck and behaves like a duck, then it must be a duck! In the example, the variable <code>mary</code> behaves like the <code>Person</code> interface because it has <code>name</code> and <code>age</code> properties, so it must be a <code>Person</code>. This is a powerful feature of TypeScript.</p>
<p>And after running the <code>npx tsc src/01-intro/08-typescript.ts</code> command again, we will get the following output in the <code>08-typescript.js</code> file:</p>
<div class="C0-SHCodePACKT">
<pre><code>function printName(person) {
    console.log(person.name);
}
var john = { name: 'John', age: 21 };
var mary = { name: 'Mary', age: 21, phone: '123-45678' };</code></pre>
</div>
<p>The code above is plain JavaScript. The code completion and type and error checking are available in compile-time only.</p>
<blockquote>
<p>By default, TypeScript compiles to ECMAScript 3. The variable declaration as let and const was only introduced in ECMAScript 6. You can specify the target version by creating a <code>tsconfig.json</code> file. Please check the documentation for the steps in case you would like to change this behavior.</p>
</blockquote>
</section>
<section id="oop-interface" class="level4" data-number="2.7.2.2">
<h4 data-number="2.7.2.2">OOP Interface</h4>
<p>The second concept for the TypeScript interface is related to object-oriented programming, this is the same concept as in other OO languages such as Java, C#, Ruby, and so on. An interface is a contract. In this contract, we can define what behavior the classes or interfaces that will implement this contract should have. Consider the ECMAScript standard. ECMAScript is an interface for the JavaScript language. It tells the JavaScript language what functionalities it should have, but each browser might have a different implementation of it.</p>
<p>Let's see an example that will be useful for the data structures and algorithms we will implement throughout this book. Consider the code below:</p>
<div class="C0-SHCodePACKT">
<pre><code>interface Comparable {
  compareTo(b): number;
}
class MyObject implements Comparable {
  age: number;
 
  constructor(age: number) {
    this.age = age;
  }
  compareTo(b): number {
    if (this.age === b.age) {
      return 0;
    }
    return this.age &gt; b.age ? 1 : -1;
  }
}</code></pre>
</div>
<p>The interface <code>Comparable</code> tells the class <code>MyObject</code> that it should implement a method called <code>compareTo</code> that receives an argument. Inside this method, we can code the required logic. In this case, we are comparing two numbers, but we could use a different logic for comparing two strings or even a more complex object with different attributes. The <code>compareTo</code> method returns 0 in case the object is the same, 1, if the current object is bigger than, and -1 in case the current object is smaller than the other object. This interface behavior does not exist in JavaScript, but it is immensely helpful when working with sorting algorithms as an example.</p>
<p>To demonstrate the concept of polymorphism, we can use the code below:</p>
<div class="C0-SHCodePACKT">
<pre><code>function compareTwoObjects(a: Comparable, b: Comparable) {
  console.log(a.compareTo(b));
  console.log(b.compareTo(a));
}</code></pre>
</div>
<p>In this case, the function <code>compareTwoObjects</code> receives two objects that implement the Comparable interface. It can be instances of <code>MyObject</code> or any other class that implements this interface.</p>
</section>
</section>
<section id="generics" class="level3" data-number="2.7.3">
<h3 data-number="2.7.3">Generics</h3>
<p><em>Generics</em> are a powerful feature in TypeScript (and many other strongly typed programming languages) that allow you to write reusable code that can work with various types while maintaining type safety. Think of them as templates or blueprints for functions, classes, or interfaces that can be parameterized with different types.</p>
<p>Let's modify the <code>Comparable</code> interface so we can define the type of the object the method <code>compareTo</code> should receive as an argument:</p>
<div class="C0-SHCodePACKT">
<pre><code>interface Comparable&lt;T&gt; {
  compareTo(b: T): number;
}</code></pre>
</div>
<p>By passing the type <code>T</code> dynamically to the <code>Comparable </code>interface – between the diamond operator <code>&lt;&gt;</code>, we can specify the argument type of the <code>compareTo </code>function:</p>
<div class="C0-SHCodePACKT">
<pre><code>class MyObject implements Comparable&lt;MyObject&gt; {
  age: number;
 
  constructor(age: number) {
    this.age = age;
  }
  compareTo(b: MyObject): number {
    if (this.age === b.age) {
      return 0;
    }
    return this.age &gt; b.age ? 1 : -1;
  }
}</code></pre>
</div>
<p>This is useful so we can make sure we are comparing objects of the same type. This is done by ensuring the parameter <code>b</code> has a type of T that matches the T inside the diamond operator. By using this functionality, we also get code completion from the editor.</p>
</section>
<section id="enums" class="level3" data-number="2.7.4">
<h3 data-number="2.7.4">Enums</h3>
<p><strong>Enums</strong> (short for <em>Enumerations</em>) are a way to define a set of named constants. They help organize your code and make it more readable by giving meaningful names to values.</p>
<p>We can use TypeScript <code>enums</code> to avoid code smells such as <em>magic numbers</em>. A magic number refers to a numerical constant with no explicit explanation of its meaning.</p>
<p>When working with comparing values or objects, which is quite common in sorting algorithms, we often see values such as -1, 1 and 0. But what do these numbers mean?</p>
<p>That is when <code>enums</code> come to the rescue to improve code readability. Let's refactor the <code>compareTo</code> function from the previous example using an <code>enum</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>enum Compare {
  LESS_THAN = -1,
  BIGGER_THAN = 1,
  EQUALS = 0
}
function compareTo(a: MyObject, b: MyObject): number {
  if (a.age === b.age) {
    return Compare.EQUALS;
  }
  return a.age &gt; b.age ? Compare.BIGGER_THAN : Compare.LESS_THAN;
}</code></pre>
</div>
<p>By assigning values to each <code>enum</code> constant, we can replace the values -1, 1 and 0 with a brief explanation without changing the output of the code.</p>
</section>
<section id="type-aliases" class="level3" data-number="2.7.5">
<h3 data-number="2.7.5">Type aliases</h3>
<p>TypeScript also has a cool feature called <strong>type aliases</strong>. It allows you to create new names for existing types. It also makes code easier to understand, especially when you are dealing with complex types.</p>
<p>Let's check an example:</p>
<div class="C0-SHCodePACKT">
<pre><code>type UserID = string;
type User = {
  id: UserID;
  name: string;
}</code></pre>
</div>
<p>In the preceding example, we are creating a type named <code>UserID</code> that is an alias for a <code>string</code>. And when declaring the second type <code>User</code>, we are saying that the <code>id</code> is of type <code>UserID</code>, making it easier to read the code and understand what the <code>id</code> means.</p>
<p>This feature is going to be useful when working with sorting algorithms, as we will be able to create aliases to compare functions so we can write the algorithms in the most generic viable way to work with any data type.</p>
</section>
<section id="typescript-compile-time-checking-in-javascript-files" class="level3" data-number="2.7.6">
<h3 data-number="2.7.6">TypeScript compile-time checking in JavaScript files</h3>
<p>Some developers still prefer using plain JavaScript to develop their code instead of TypeScript. But it would be nice if we could use some of the type and error checking features from TypeScript in JavaScript as well, since JavaScript does not provide these features.</p>
<p>The good news is that TypeScript has a special functionality that allows us to have this compile-time error and type checking! To use it, we need to have TypeScript installed globally in our computer using the <code>npm install -g TypeScript command</code>.</p>
<p>Let's see how JavaScript is handling the types of a code we used previously in this chapter:</p>
<figure>
<img src="../media/file3.png" alt="Figure 1.3 – JavaScript code in VSCode without TypeScript compile-time checking" width="1211" height="407"/><figcaption aria-hidden="true">Figure 1.3 – JavaScript code in VSCode without TypeScript compile-time checking</figcaption>
</figure>
<p>In the first line of the JavaScript files, if we want to use the type and error checking, we need to add <code>// @ts-check</code> as demonstrated below:</p>
<figure>
<img src="../media/file4.png" alt="Figure 1.4 – JavaScript code in VSCode with TypeScript compile-time checking" width="1210" height="604"/><figcaption aria-hidden="true">Figure 1.4 – JavaScript code in VSCode with TypeScript compile-time checking</figcaption>
</figure>
<p>The type checking is enabled when we add JSDoc (JavaScript documentation) to our code. To do this, add the following code right before the function declaration:</p>
<div class="C0-SHCodePACKT">
<pre><code>/**
 * Arrow function example, calculates the area of a circle
 * @param {number} radius
 * @returns
 */</code></pre>
</div>
<p>Then, if we try to pass a string to our circle (or <code>circleAreaFn</code>) function, we will get a compilation error:</p>
<figure>
<img src="../media/file5.png" alt="Figure 1.5 – Type checking in action for JavaScript" width="1211" height="454"/><figcaption aria-hidden="true">Figure 1.5 – Type checking in action for JavaScript</figcaption>
</figure>
<blockquote>
<p>To enable the inferred variable names and types in VSCode, open your settings, and search by <em>inlay hint</em>, and enable this feature. It can make a difference (for the better) when coding.</p>
</blockquote>
</section>
<section id="other-typescript-functionalities" class="level3" data-number="2.7.7">
<h3 data-number="2.7.7">Other TypeScript functionalities</h3>
<p>This was a very quick introduction to TypeScript. The TypeScript documentation is a wonderful place for learning all the other functionalities and diving into the details of the topics we quickly covered in this chapter: <a href="https://www.typescriptlang.org">https://www.typescriptlang.org</a>.</p>
<blockquote>
<p>The source code bundle of this book also contains a TypeScript version of the JavaScript data structures and algorithms we will develop throughout this book as an extra resource. And whenever TypeScript makes concepts related to data structures and algorithms easier to understand, we will also use it throughout this book.</p>
</blockquote>
</section>
</section>
<section id="summary" class="level2" data-number="2.8">
<h2 data-number="2.8">Summary</h2>
<p>In this chapter, we learned the importance of learning data structures and algorithms, and how it can make us better developers and help us pass technical job interviews in technology. We also reviewed reasons why we chose JavaScript to learn and apply these concepts.</p>
<p>You learned how to set up the development environment to be able to create or execute the examples in this book. We also covered the basics of the JavaScript language that are needed prior to getting started with developing the algorithms and data structures we will cover throughout the book.</p>
<p>We also covered a comprehensive introduction to TypeScript, showcasing its ability to enhance JavaScript with static typing and error checking for more reliable code. We explored essential concepts like interfaces, type inference, and generics, empowering us to write more robust and maintainable data structures and algorithms.</p>
<p>In the next chapter, we'll shift our focus to the critical topic of Big O notation, a fundamental tool for evaluating and understanding the efficiency and performance of our code implementations.</p>
</section>
</section>
</div>
</div>
</body>
</html>