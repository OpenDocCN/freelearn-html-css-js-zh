- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered matrices, transformations, and cameras.
    So far, we have only discussed static scenes, where all interactions are done
    by moving the camera. With these interactions, a camera transformation is applied
    to all objects in the 3D scene; we therefore call it a *global* transform. However,
    objects in 3D scenes can have actions of their own. For instance, in a car-racing
    game, each car has its own speed and trajectory. In a first-person shooter game,
    enemies can hide behind barricades, come to fight, or simply run away. In general,
    each one of these actions is modeled as a matrix transformation that is attached
    to the corresponding actor in the scene. These are called *local* transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the difference between global and local transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about matrix stacks and how to use them to perform animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JavaScript timers to do time-based animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about parametric curves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about interpolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore various interpolation techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL Matrix Naming Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go any further, let''s take a moment to quickly summarize some of
    the conventions around matrix-naming. As we''ve seen, WebGL is a simple API with
    nearly everything – except for a few predefined names, such as `gl_Position` –
    defined by you, the programmer. That being said, common and semi-common naming
    conventions do exist. This is especially true for matrices. Here are a few important
    ones we’ve already covered, along with a few new ones that we’ll cover shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**World Matrix:** Sometimes referred to as the **Model matrix**, this is a
    matrix that takes the vertices of a model and moves them to world space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera Matrix:** This matrix positions the camera in the world. You can also
    think of it as the World matrix for the camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Matrix:** This matrix moves everything else in the world in front of
    the camera. As we''ve seen, this is the inverse of the Camera matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection Matrix:** This is the matrix that converts a frustum of space
    into clip space. You can also think of it as the matrix returned by your matrix
    math library''s perspective or orthographic function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local Matrix**: The matrix is used in scene graphs, where the matrix, at
    any particular node on the graph, is used before multiplying with any other nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene Graph** This is a data structure, commonly used by vector-based graphics-editing
    applications and modern computer games, that arranges the logical and often spatial
    representation of a graphical scene. A scene graph is a collection of nodes in
    a graph or tree structure. For more information, please visit [https://en.wikipedia.org/wiki/Scene_graph](https://en.wikipedia.org/wiki/Scene_graph)[.](https://en.wikipedia.org/wiki/Scene_graph)'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **matrix stack** provides a way to apply local transforms to individual objects
    in our scene while preserving global transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrix stack works as each rendering cycle (each call to our `render` function)
    requires calculating the scene matrices to react to camera movements. We first
    update the Model-View matrix for each object in our scene before passing the matrices
    to the shading program (as `attributes`). We do this in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the global Model-View matrix (such as camera transform) has been calculated,
    we save (push) it onto a stack. This allows us to recover the original matrix
    once we’ve applied local transforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate an updated Model-View matrix for each object in the scene. This update
    consists of multiplying the original Model-View matrix by a matrix that represents
    the rotation, translation, and/or scaling of each object in the scene. The updated
    Model-View matrix is passed to the program and the respective object then appears
    in the location indicated by its local transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recover the original matrix from the stack, and then repeat steps one to three
    for the next object that needs to be rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows this three-step procedure for one object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/642dbed2-267e-4027-babe-57452aa9d79a.png)'
  prefs: []
  type: TYPE_IMG
- en: Animating a 3D scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating a scene is nothing more than applying the appropriate local transformations
    to the objects in the scene. For instance, if we want to move a cone and a sphere,
    each one of them will have a corresponding local transformation that will describe
    its location, orientation, and scale. In the previous section, we learned that
    matrix stacks allow us to preserve the original Model-View transform so that we
    can apply the correct local transforms to each object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to move objects with local transforms and matrix stacks,
    we should address w*hen* to apply these transforms.
  prefs: []
  type: TYPE_NORMAL
- en: If we calculate the position to apply to the cone and sphere in our example
    every time we call the `render` function, this would imply that the animation
    rate would depend on the speed of our rendering cycle. A slow rendering cycle
    would produce choppy animations and too fast a rendering cycle would create the
    illusion of objects jumping from one side to the other without smooth transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, it is important to make the animation independent of the rendering
    cycle. There are a couple of solutions that we can use to achieve this goal: the
    `requestAnimationFrame` function and JavaScript timers.'
  prefs: []
  type: TYPE_NORMAL
- en: The requestAnimationFrame Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `requestAnimationFrame` function is available in all WebGL-enabled browsers.
    One of the advantages of leveraging this function is that it is designed to call
    the rendering function (whatever function we indicate) only when the browser/tab
    window is in focus. Otherwise, there is no call. This saves precious CPU, GPU,
    and memory resources. By using the `requestAnimationFrame` function, we can obtain
    a rendering cycle that is in sync with hardware capabilities and one that will
    automatically suspend itself when the window is out of focus.
  prefs: []
  type: TYPE_NORMAL
- en: requestAnimationFrame
  prefs: []
  type: TYPE_NORMAL
- en: To check out the status of `requestAnimationFrame` in your browser, visit [https://caniuse.com/#search=requestanimationframe](https://caniuse.com/#search=requestanimationframe).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That said, `requestAnimationFrame` is not a magical function that is a complete
    black box. It’s important to remember that we can implement our own in situations
    where it's not available or if we want a tailored animation experience. To do
    so, we will use two JavaScript timers to isolate the rendering rate from the animation
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `requestAnimationFrame` function, JavaScript timers continue running
    in the background, even when the page is not in focus. This is not optimal performance
    since computer resources are allocated toward a scene that is not in view. To
    mimic some of the intelligent behavior of `requestAnimationFrame`, we can use
    the `onblur` and `onfocus` events of the JavaScript window object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action (What)** | **Goal (Why)** | **Method (How)** |'
  prefs: []
  type: TYPE_TB
- en: '| Pause the rendering | To stop the rendering until the window is in focus.
    | Clear the timer calling `clearInterval` in the `window.onblur` function. |'
  prefs: []
  type: TYPE_TB
- en: '| Slow the rendering | To reduce resource consumption but make sure that the
    3D scene keeps evolving, even if we’re not looking at it. | We can clear current
    timer calling `clearInterval` in the `window.onblur` function and create a new
    timer with a more relaxed interval (higher value). |'
  prefs: []
  type: TYPE_TB
- en: '| Resume the rendering | To activate the 3D scene at full speed when the browser
    window recovers its focus. | We start a new timer with the original render rate
    in the `window.onfocus` function. |'
  prefs: []
  type: TYPE_TB
- en: By reducing the JavaScript timer rate or clearing the timer, we can handle hardware
    resources more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Render Cycle
  prefs: []
  type: TYPE_NORMAL
- en: An example of this sort of low-level functionality can be seen in the `common/js/Clock.js`
    file. With this universal clock, you can see how the `onblur` and `onfocus` events
    have been used to control the clock ticking (the rendering cycle), as we described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Timing Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've programmed animations in JavaScript before, you may have used either
    `setInterval` or `setTimeout` to get your drawing function to be called.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using these two approaches for drawing is that they have no
    relation to the browser's render cycle. That is, they aren't synced to when the
    browser is going to draw a new frame, which can leave the animation out of sync
    with the user's machine. For example, if you use `setInterval` or `setTimeout`
    and assume `60` frames a second, and the user's machine is actually running a
    different frame rate, you'll be out of sync with their machine.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `requestAnimationFrame` is available on all WebGL-enabled browsers,
    we'll leverage our own animation JavaScript timers for educational purposes. In
    production, it is recommended that you leverage the browser's optimized version.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a JavaScript timer that will allow us to control
    the animation. As we mentioned previously, we will implement a JavaScript timing
    strategy that provides independence between how fast your computer can render
    frames and how fast you want the animation to go. We will refer to this property
    as the **animation rate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving forward, we must address a caveat about working with timers:
    *JavaScript is not a multithreaded language*. This means that if there are several
    asynchronous events occurring at the same time (blocking events), the browser
    will queue them for posterior execution. Each browser has a different mechanism
    to deal with blocking event queues.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two blocking event-handling alternatives for the purpose of developing
    an animation timer.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first alternative is to calculate the elapsed time inside the timer callback.
    The pseudocode looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In doing so, we guarantee that the animation time is independent of how often
    the timer callback is actually executed. If there are big delays (due to other
    blocking events), this method may result in **dropped frames**. This means that
    the object's positions in our scene will immediately be moved to the current position
    that they should be in according to the elapsed time (between consecutive animation
    timer callbacks), and then the intermediate positions will be ignored. The motion
    on screen may jump, but often, a dropped animation frame is an acceptable loss
    in a real-time application. One example is the movement of one object from point
    `A` to point `B` over a given period of time. However, if we used this strategy
    when shooting a target in a 3D shooting game, we could quickly run into problems.
    Imagine that you are trying to shoot a target where there is a delay. The next
    thing you know, the target is no longer there! Since we need to calculate a collision
    in this case, we cannot afford to miss frames. This is because the collision could
    occur in any of the frames that we would drop without analyzing. The following
    strategy solves this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Simulation Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several applications, such as the shooting game example, that require
    all intermediate frames to ensure the integrity of the outcome. These applications
    include working with collision detection, physics simulations, or artificial intelligence
    for games. For games, we need to update the object''s positions at a constant
    rate. We do so by directly calculating the next position for the objects inside
    the timer callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This may lead to **frozen frames** that occur when there is a long list of blocking
    events because the object's positions would not be updated in a timely manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combined Approach: Animation and Simulation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, browsers can efficiently handle blocking events, and in
    most cases, performance would be similar regardless of the chosen strategy. Deciding
    to calculate the elapsed time or the next position in timer callbacks will then
    depend on your particular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, there are cases where it is desirable to combine both animation
    and simulation strategies. We can create a timer callback that calculates the
    elapsed time and updates the animation as many times as required per frame. The
    pseudocode looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates that the animation will always update
    at a fixed rate, regardless of how much time elapses between frames. If the app
    is running at `60` Hz, the animation will update once every other frame; if the
    app runs at `30` Hz, the animation will update once per frame; if the app runs
    at `15` Hz, the animation will update twice per frame. The animation remains far
    more stable and deterministic if it is always moved forward by a fixed amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence shows the responsibilities of each function in the call
    stack for the combined approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '`render`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the timer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the animation rate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer callback is the `onFrame` function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onFrame`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculates the elapsed time since the last call.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the elapsed time is less than the animation rate, then it returns without
    further processing. Otherwise, it calculates the number of frames that the animation
    needs to be updated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the animation by calling the `animate` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`animate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the object positions by a fixed increment. In this example, the sphere
    is updated by `0.1` units every time `animate` is called.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `draw` to update the object on screen. This is *optional*, since the
    rendering loop calls `draw` periodically anyway.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a local transformation using the new position calculated in `animate`,
    and it applies it to the corresponding object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This approach may cause issues if an animation step actually takes longer to
    compute than the fixed step. If this occurs, you should simplify your animation
    code or release a recommended minimum system spec for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web Workers: Multithreading in JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though outside the scope of this book, you should consider using **Web Workers**
    if performance is critical to you. Doing so will ensure that a particular update
    loop always fires at a consistent rate.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers is an API that allows web applications to spawn background processes
    that run scripts in parallel to their main page. This allows for thread-like operation
    with message-passing as the coordination mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Web Workers specification at [http://dev.w3.org/html5/workers/](http://dev.w3.org/html5/workers/).
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review the structure of the examples developed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: App Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `init` function defines three function hooks that control the life cycle
    of the application. As we've covered in previous chapters, we create our application
    by invoking the `init` function. Then, we call the hooks to the `configure`, `load`,
    and `render` functions. Also, please note that the `init` function is the entry
    point for the application and it is automatically invoked using the `onload` event
    of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Support for Matrix Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve also added a new script: `Transforms.js`. This file contains the `Transforms`
    class that encapsulate the matrix-handling operations, including the `push` and
    `pop` matrix stack operations. The `Transforms` class replaces the functionality
    behind the `initTransforms`, `updateTransforms`, and `setMatrixUniforms` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for SceneTransforms in `common/js/Transforms.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Matrix Stacks and JavaScript Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will investigate a simple scene where we’ve animated
    a cone and a sphere. We will use matrix stacks to implement local transformations
    and JavaScript timers to implement the animation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Simple Animation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example covering a simple animation technique:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch05_01_simple-animation.html` in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d37c4b9e-baa4-4ed9-aa77-47337b58ccb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Move the camera around (left mouse-click + drag) and see how the objects (sphere
    and cone) move independently of one another (local transformations) and the camera
    (global transformation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also dolly the camera (left mouse-click + *Alt* + drag).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the camera type to Tracking. If for any reason you lose your bearings,
    click on Go Home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's examine the source code to see how we’ve implemented this example. Open
    `ch05_01_simple-animation.html` in a code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the `render`, `onFrame`, and `animate` functions. Which timing
    strategy are we using here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `spherePosition` and `conePosition` global variables contain the position
    of the sphere and the cone, respectively. Scroll up to the `draw` function. Inside
    the main loop where each object scene is rendered, a different local transformation
    is calculated depending on the current object being rendered. The code looks like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the transforms object (which is an instance of `Transforms`), we obtain
    the global Model-View matrix by calling `transforms.calculateModelView()`. Push
    it into a matrix stack by calling the `push` method. We can now apply any transform
    that we want, knowing that we can retrieve the global transform since it is available
    for the next object on the list. We do so at the end of the code snippet by calling
    the `pop` method. Between the `push` and `pop` calls, we determine which object
    is currently being rendered and use the `spherePosition` or `conePosition` global
    variable to apply a translation to the current Model-View matrix. By doing so,
    we create a local transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a second look at the preceding code. As you saw at the beginning of this
    exercise, the cone is moving in the x-axis while the sphere is moving in the z-axis.
    What do you need to change to animate the cone in the y-axis? Test your hypothesis
    by modifying this code, saving the web page, and opening it again in your web
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's return to the `animate` function. What should we modify here to make the
    objects move faster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HintTake a look at the global variables this function uses.
  prefs: []
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw a simple animation of two objects. We examined the
    source code to understand the call stack of functions that makes the animation
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Simulating Dropped and Frozen Frames'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can control the render rate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch05_02_dropping-frames.html` file using your browser. Here, you
    will see the same scene we analyzed in the previous section. You’ll notice that
    the animation is not smooth because we are simulating dropping frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ed16d5f-554b-4a79-a902-90640efc94f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the source code in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the `onFrame` function. You can see that we’ve included a new variable:
    `simulationRate`. In the `onFrame` function, this variable calculates how many
    simulation steps need to be performed when the time elapsed is around `300 ms`
    (`animationRate`). Given that `simulationRate` is `30 ms`, this will produce a
    total of `10` simulation steps. These steps can increase if there are unexpected
    delays and the elapsed time is considerably higher. This is the behavior that
    we expect.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Experiment with different values for the `animationRate` and `simulationRate`
    variables to answer the following questions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we get rid of the dropping frames issue?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we simulate frozen frames?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the relationship between the `animationRate` and `simulationRate` variables
    when simulating frozen frames?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametric Curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many situations where we don't know the exact position of an object
    at a given time, but we do know an equation that describes its movement. These
    equations are known as **parametric curves**; they are parametric because the
    position depends on one parameter—for example, the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many examples of parametric curves. For example, a projectile shot
    in a game, a car going downhill, or a bouncing ball. In each case, there are equations
    that describe the motion of these objects under ideal conditions. The following
    diagram shows the parametric equation that describes the free-fall motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa1aee03-0e31-469f-a5f5-8c68f39fb723.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`![](img/f9b25215-a7b1-4e98-9f13-401c373d2969.png)`: Gravity at `![](img/1a9485fd-ce69-4ce7-9a9c-231b2e71a06f.png)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`![](img/8bb375bf-01ed-4cde-9cda-2c7ac33d0807.png)`: Initial velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`![](img/3176d700-ce2d-48ee-912f-243c75e96a4a.png)`: Initial Position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`![](img/bb542fe3-b290-46fe-a77f-13ba6d11434d.png)`: Time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`![](img/525e9640-f7e2-4759-999c-ab45bbf9fb68.png)`: Position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use parametric curves to animate objects in a WebGL scene. In
    this example, we will model a set of bouncing balls. The complete source code
    for this exercise can be found in `ch05_03_bouncing-balls.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a global variable that will store the (simulation) time. We
    will also create the global variables that regulate the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `load` function is updated to load a bunch of balls using the same geometry
    (same JSON file), but we are adding it several times to the `scene` object. The
    code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ES6 Template LiteralsIf you're not familiar with the `` `ball${i}` `` syntax,
    it's equivalent to `'ball' + i`. Instead of concatenating strings, we can leverage
    template literals in ES6 for dynamic string values. For more information, check
    out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve also populated an array named `balls[]`. We do this so that
    we can store the ball positions every time the global time changes. We will talk
    in depth about the bouncing ball simulation in the next *Time for action* section.
    For the moment, it’s worth mentioning that it is on the `load` function that we
    load the geometry and initialize the ball array with the initial ball positions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Animation Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `render` and `onFrame` functions look exactly the same as in the previous
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `animate` function passes the `sceneTime` variable to the `update` method
    of every ball in the ball array. Then, `sceneTime` updates by a fixed amount.
    The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, parametric curves are very helpful because they don’t require us to know
    the location of every object that we want to move beforehand. We just apply a
    parametric equation that gives us the location based on the current time. This
    occurs for every ball inside its update method.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Each Ball in Its Current Position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `draw` function, we use a matrix stack to save the state of the Model-View
    matrix before applying a local transformation for each one of the balls. The code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The trick here is to use the number that makes up part of the ball alias to
    look up the respective ball position in the `balls` array. For example, if the
    ball being rendered has the `ball32` alias, then this code will look for the current
    position of the ball whose index is `32` in the `balls` array. This one-to-one
    correspondence between the `ball` alias and its location in the ball array was
    established in the `load` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following *Time for Action* section, we will see the bouncing balls animation
    in action. We will also discuss some of the code detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Bouncing Ball'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example covering how we''d animate many objects in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch05_03_bouncing-balls.html` in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/093df5f6-3ddc-40bd-8125-5fe9ba38125c.png)'
  prefs: []
  type: TYPE_IMG
- en: The orbiting camera is activated by default. Move the camera and you will see
    how all the objects adjust to the global transform (camera) and continue bouncing
    according to their local transforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's explain how we keep track of each ball in more detail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the appropriate global variables and constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `balls` array. We use a `for` loop in the `load` function to
    achieve this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BouncingBall` class initializes the simulation variables for each ball
    in the `balls` array. One of these attributes is the position, which we select
    randomly. You can see how we do this by using the `generatePosition` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After adding a new ball to the `balls` array, we add a new ball object (geometry)
    to the `scene` instance. Please note that the alias we create includes the current
    index of the ball object in the `balls` array. For example, if we add the 32nd
    ball to the array, the alias that the corresponding geometry will have in `scene`
    will be `ball32`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only other object that we add to the scene here is `Floor`. We have used
    this object in previous exercises. You can find the code for the `Floor` class
    in `common/js/Floor.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's talk about the `draw` function. Here, we go through the elements of `scene`
    and retrieve each object's alias. If the alias contains the word `ball`, we know
    that the alias corresponds to its `index` in the ball array. We could have probably
    used an associative array here to make it look nicer, but doing so does not really
    change our goal. The main point here is to make sure that we can associate the
    simulation variables for each ball with the corresponding object (geometry) in
    `scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that for each object (ball geometry) in `scene`, we extract the current
    position and the color from the respective `BouncingBall` instance in the `balls`
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter the current Model-View matrix for each ball by using a matrix stack to
    handle local transformations, as described previously. In our case, we want the
    animation for each ball to be independent from the transformations of the camera
    and one another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we’ve described how the bouncing balls are created (`load`) and how
    they are rendered (`draw`). None of these functions modifies the current position
    of the balls. We do that by using `BouncingBall.update`. This code uses the animation
    time (the `sceneTime` global variable) to calculate the position for the bouncing
    ball. Since each `BouncingBall` has its own simulation parameters, we can calculate
    the position for each given position when `sceneTime` is provided . In short,
    the ball position is a function of time and, as such, it falls into the category
    of motion described by parametric curves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `BouncingBall.update` method is called inside the `animate` function. As
    we saw previously, this function is invoked by the animation timer each time the
    timer is up. Inside this function, you can see how the simulation variables are
    updated to reflect the current state of that ball in the simulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to handle several object-local transformations while preserving
    global transformations by using a matrix stack strategy. In the bouncing ball
    example, we used an animation timer for the animation that is independent from
    the rendering timer. Finally, we saw how the bouncing ball `update` method shows
    how parametric curves work.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you play around a little bit and increase the value of the `ballsCount`
    global constant from `50` to `500`, you will start to notice that the frame rate
    degrades:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cafae70-a0f1-4436-bcb8-5c180c2e0354.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the rendering hovered roughly around `30` frames
    per second. Depending on your computer, the average time for the `draw` function
    can be higher than the frequency at which the animation timer callback is invoked.
    This will result in dropped frames. To correct this, we need to make the `draw`
    function faster. Let's see a couple of strategies to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Batch Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL 2 adds some interesting features, such as **geometry-instancing.** This
    feature allows us to render the same instance of a single mesh with differing
    shader attributes using **instancing** and only one `render` call. Though instancing
    is limited, as it’s based on the same mesh only, it’s still a great way to improve
    performance if you have to draw the same meshes multiple times, especially if
    combined with shaders. While this functionality is provided in WebGL 2, we'll
    build our own geometry-optimization techniques for educational purposes. We will
    cover WebGL 2's geometry instancing feature in [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml),
    *WebGL 2 Highlights*.
  prefs: []
  type: TYPE_NORMAL
- en: How do we optimize our scene without using the WebGL 2 geometry-instancing API?
    We can use geometry-caching as a way to optimize the animation of a scene full
    of similar objects. This is the case in the bouncing balls example. Each bouncing
    ball has a different position and color. These features are unique and independent
    for each ball. However, all of the balls share the same geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In the `load` function, for `ch05_03_bouncing-balls.html`, we created `50` vertex
    buffer objects (VBOs) for each ball. Additionally, the same geometry is loaded
    `50` times, and on every rendering loop (`draw` function), a different VBO is
    bound, despite the geometry being the same for all the balls!
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ch05_04_bouncing-balls-optimized.html`, we modified the `load` and `draw`
    functions to handle geometry-caching. In the first place, the geometry is loaded
    just once (`load` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, when the object with the `''ball''` alias is the current object in
    the rendering loop (the `draw` function), the `drawBalls` delegate function is
    invoked. This function sets some of the uniforms that are common to all bouncing
    balls (so that we do not waste time passing them every time to `program` for every
    ball). After that, the `drawBall` function is invoked. This function will set
    up those elements that are unique for each ball. In our case, we set up the `program`
    uniform that corresponds to the ball color and the Model-View matrix, which is
    unique for each ball because of the local transformation (ball position):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24f0cb7b-5c28-42c5-83d0-328ff3f9391e.png)'
  prefs: []
  type: TYPE_IMG
- en: Performing Translations in the Vertex Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a look at the code in `ch05_04_bouncing-balls-optimized.html`, you
    will see that we have taken an extra step to cache the Model-View matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind this is to transfer the original matrix to the GPU (global)
    once and then perform the translation for each ball (local) inside the vertex
    shader. This change significantly improves the performance because of the parallel
    nature of the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we do, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new uniform that tells the vertex shader whether it should perform
    a translation (`uTranslate`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new uniform that contains the ball position for each ball (`uTranslation`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Map these two new uniforms to JavaScript variables (we do this in the `configure`
    function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the translation inside the vertex shader. This part is probably the
    trickiest part since it requires a little bit of ESSL programming:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, we are defining `vecPosition`, a variable of the `vec3`
    type. If the `uTranslate` uniform is `true` (meaning we are trying to render a
    bouncing ball), then we update `vecPosition` with the translation. This is implemented
    using vector-addition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the transformed vertex carries the translation in case of having
    one, so the following line looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In `drawBall`, pass the current ball position as the content for the `uTranslation`
    uniform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In `drawBalls`, set the `uTranslate` uniform to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In `draw`, pass the Model-View matrix once for all balls by using the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Increase the `ballsCount` global variable from `50` to `500` and watch how
    the application continues to perform reasonably well, regardless of the increased
    scene complexity. The improvement in execution times is shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c835db02-7b8a-4f89-ad15-4d7d7320ed9e.png)'
  prefs: []
  type: TYPE_IMG
- en: After these optimizations, the example runs at a smooth `60` frames per second.
    The optimized source code is available at `ch05_bouncing-balls-optimized.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpolation greatly simplifies a 3D objects’ animation. Unlike parametric
    curves, it is not necessary to define the position of the object as a function
    of time. When interpolation is used, we only need to define control points or
    knots. The set of control points describes the path that a particular animate
    object will follow. There are many interpolation methods; however, it’s always
    a good idea to start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method requires that we define the starting and ending points of the location
    of our object, along with the number of interpolating steps. The object will move
    on the line determined by the starting and ending points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d131837a-66c0-4948-927f-a51d3512721b.png)'
  prefs: []
  type: TYPE_IMG
- en: Polynomial Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method allows us to determine as many control points as we want. The object
    will move from the starting point to the ending point and will pass through each
    one of the control points in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0828ec46-3b85-4064-863a-6816dfd6213d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While using polynomials, an increasing number of control points can produce
    undesired oscillations on the object''s path described by this technique. This
    is known as **Runge''s phenomenon**. The following diagram illustrates the result
    of moving one of the control points of a polynomial described with `11` control
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d62c7061-455c-4f57-9bbf-e7177702ea53.png)'
  prefs: []
  type: TYPE_IMG
- en: B-Splines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is similar to polynomial interpolation with the difference that
    the control points are outside of the object''s path. In other words, the object
    does not pass through the control points as it moves. In general, this method
    is common in computer graphics because the knots allow for much smoother path-generation
    than the polynomial equivalent at the same time that fewer knots are required.
    B-splines also respond better to Runge''s phenomenon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1725689b-aa39-4bd5-84f2-4a559af72f9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following *Time for action* section, we will see in the three different
    interpolation techniques that have been introduced in practice: **linear**, **polynomial**,
    and **b-spline**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Interpolation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example showcasing various interpolation techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch05_05_interpolation.html` using your browser. You should see something
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8043fa8a-ae62-4586-ba80-64153008709a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inspect the code in an editor. Nearly all of the functions are the same as
    before, except for the new function called `interpolate`. This function interpolates
    the position in a linear fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up `ch05_06_interpolation-final.html` in your browser. You should see
    something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65e81e88-8c6b-499f-9bcd-84cfcaffa39b.png)'
  prefs: []
  type: TYPE_IMG
- en: Select **Linear** interpolation if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the start and end points using the slider provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the number of interpolation steps. What happens to the animation when
    you decrease the number of steps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code for the linear interpolation has been implemented in the `doLinearInterpolation`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Polynomial** interpolation. In this example, we have implemented Lagrange's
    interpolation method. You can see the source code in the `doLagrangeInterpolation`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Three new control points (flags) appear on screen. Using the sliders provided
    on the web page, you can change the location of these control points. You can
    also change the number of interpolation steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29507453-9d0a-45d5-831b-a5d0183ea39d.png)'
  prefs: []
  type: TYPE_IMG
- en: You may have also noticed that whenever the ball approaches one of the flags
    (with the exception of the start and end points), the flag changes color. To do
    that, we have written the ancillary `close` function. We use this function inside
    the `draw` routine to determine the color of the flags. If the current position
    of the ball, determined by `position[sceneTime]`, is close to one of the flag
    positions, the respective flag changes color. When the ball is far from the flag,
    the flag changes back to its original color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the source code so that each flag remains *activated*; that is, activated
    with the new color after the ball passes by until the animation loops back to
    the beginning. This happens when `sceneTime` is equal to `incrementSteps` (see
    the `animate` function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **B-Spline** interpolation. Notice how the ball does not reach any
    of the intermediate flags in the initial configuration. Is there any configuration
    you can test so that the ball passes through at least two of the flags?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to use interpolation to describe the movement of an object
    in our 3D world. We've also created very simple scripts to detect object proximity
    and alter our scene accordingly (changing flag colors, in this example). Reaction
    to proximity is a key element in game design!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can leverage matrix stacks to preserve global transformations
    while applying local transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the basic concepts behind object animations in WebGL. More specifically,
    we learned about the differences between local and global transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about the `requestAnimationFrame` browser and built our own version
    with JavaScript timers for animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An animation timer that is not tied up to the rendering cycle provides a lot
    of flexibility by ensuring that the time in the scene is independent of how fast
    it can be rendered on screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We distinguished between animation and simulation strategies for various problem-solving
    approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at interpolation methods and their various approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will play with colors and blending in a WebGL scene.
    We will study the interaction between objects and light colors, and learn how
    to create translucent objects.
  prefs: []
  type: TYPE_NORMAL
