- en: Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: In the previous chapter, we covered matrices, transformations, and cameras.
    So far, we have only discussed static scenes, where all interactions are done
    by moving the camera. With these interactions, a camera transformation is applied
    to all objects in the 3D scene; we therefore call it a *global* transform. However,
    objects in 3D scenes can have actions of their own. For instance, in a car-racing
    game, each car has its own speed and trajectory. In a first-person shooter game,
    enemies can hide behind barricades, come to fight, or simply run away. In general,
    each one of these actions is modeled as a matrix transformation that is attached
    to the corresponding actor in the scene. These are called *local* transforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了矩阵、变换和相机。到目前为止，我们只讨论了静态场景，其中所有交互都是由移动相机完成的。在这些交互中，对3D场景中的所有对象应用了相机变换；因此，我们称之为**全局**变换。然而，3D场景中的对象可以有自己的动作。例如，在赛车游戏中，每辆车都有自己的速度和轨迹。在第一人称射击游戏中，敌人可以躲在障碍物后面，前来战斗，或者简单地逃跑。一般来说，这些动作中的每一个都被建模为一个附加到场景中相应演员的矩阵变换。这些被称为**局部**变换。
- en: 'In this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn the difference between global and local transformations.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解全局变换和局部变换之间的区别。
- en: Learn about matrix stacks and how to use them to perform animations.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解矩阵栈以及如何使用它们进行动画。
- en: Use JavaScript timers to do time-based animations.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript计时器进行基于时间的动画。
- en: Learn about parametric curves.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解参数曲线。
- en: Learn about interpolation.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解插值。
- en: Explore various interpolation techniques.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索各种插值技术。
- en: WebGL Matrix Naming Conventions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL矩阵命名约定
- en: 'Before we go any further, let''s take a moment to quickly summarize some of
    the conventions around matrix-naming. As we''ve seen, WebGL is a simple API with
    nearly everything – except for a few predefined names, such as `gl_Position` –
    defined by you, the programmer. That being said, common and semi-common naming
    conventions do exist. This is especially true for matrices. Here are a few important
    ones we’ve already covered, along with a few new ones that we’ll cover shortly:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们花一点时间快速总结一下关于矩阵命名的约定。正如我们所见，WebGL是一个简单的API，几乎所有内容（除了少数预定义的名称，如`gl_Position`）都是由程序员你定义的。话虽如此，确实存在一些常见的和半常见的命名约定。这在矩阵方面尤其如此。以下是我们已经覆盖的一些重要约定，以及我们将很快介绍的一些新约定：
- en: '**World Matrix:** Sometimes referred to as the **Model matrix**, this is a
    matrix that takes the vertices of a model and moves them to world space.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界矩阵:** 有时被称为**模型矩阵**，这是一个矩阵，它将模型的顶点移动到世界空间。'
- en: '**Camera Matrix:** This matrix positions the camera in the world. You can also
    think of it as the World matrix for the camera.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机矩阵:** 这个矩阵将相机定位在世界中。你也可以将其视为相机的世界矩阵。'
- en: '**View Matrix:** This matrix moves everything else in the world in front of
    the camera. As we''ve seen, this is the inverse of the Camera matrix.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图矩阵:** 这个矩阵将世界中的其他所有内容移动到相机前面。正如我们所见，这是相机矩阵的逆矩阵。'
- en: '**Projection Matrix:** This is the matrix that converts a frustum of space
    into clip space. You can also think of it as the matrix returned by your matrix
    math library''s perspective or orthographic function.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影矩阵:** 这是将空间的一个截锥体转换为裁剪空间的矩阵。你也可以将其视为你的矩阵数学库的透视或正交函数返回的矩阵。'
- en: '**Local Matrix**: The matrix is used in scene graphs, where the matrix, at
    any particular node on the graph, is used before multiplying with any other nodes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部矩阵:** 这个矩阵用于场景图中，在图上的任何特定节点上使用的矩阵在与其他任何节点相乘之前使用。'
- en: '**Scene Graph** This is a data structure, commonly used by vector-based graphics-editing
    applications and modern computer games, that arranges the logical and often spatial
    representation of a graphical scene. A scene graph is a collection of nodes in
    a graph or tree structure. For more information, please visit [https://en.wikipedia.org/wiki/Scene_graph](https://en.wikipedia.org/wiki/Scene_graph)[.](https://en.wikipedia.org/wiki/Scene_graph)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景图:** 这是一个数据结构，通常由基于向量的图形编辑应用程序和现代计算机游戏使用，它安排了图形场景的逻辑和通常空间表示。场景图是一个图或树结构中的节点集合。有关更多信息，请访问[https://en.wikipedia.org/wiki/Scene_graph](https://en.wikipedia.org/wiki/Scene_graph)。'
- en: Matrix Stacks
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵栈
- en: A **matrix stack** provides a way to apply local transforms to individual objects
    in our scene while preserving global transforms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵栈**提供了一种方法，可以在我们的场景中对单个对象应用局部变换，同时保留全局变换。'
- en: 'The matrix stack works as each rendering cycle (each call to our `render` function)
    requires calculating the scene matrices to react to camera movements. We first
    update the Model-View matrix for each object in our scene before passing the matrices
    to the shading program (as `attributes`). We do this in three steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵栈在每个渲染周期（每次调用我们的`render`函数）中工作，因为每个渲染周期都需要计算场景矩阵以响应相机移动。我们在将矩阵传递给着色程序（作为`attributes`）之前，首先更新场景中每个对象的模型视图矩阵。我们分三步进行这一操作：
- en: Once the global Model-View matrix (such as camera transform) has been calculated,
    we save (push) it onto a stack. This allows us to recover the original matrix
    once we’ve applied local transforms.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦计算出了全局模型视图矩阵（如相机变换），我们就将其保存（推入）栈中。这允许我们在应用局部变换后恢复原始矩阵。
- en: Calculate an updated Model-View matrix for each object in the scene. This update
    consists of multiplying the original Model-View matrix by a matrix that represents
    the rotation, translation, and/or scaling of each object in the scene. The updated
    Model-View matrix is passed to the program and the respective object then appears
    in the location indicated by its local transform.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算场景中每个对象更新的模型视图矩阵。这个更新包括将原始模型视图矩阵乘以一个表示场景中每个对象旋转、平移和/或缩放的矩阵。更新的模型视图矩阵传递给程序，相应的对象随后出现在其局部变换指示的位置。
- en: Recover the original matrix from the stack, and then repeat steps one to three
    for the next object that needs to be rendered.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从栈中恢复原始矩阵，然后对下一个需要渲染的对象重复步骤一至三。
- en: 'The following diagram shows this three-step procedure for one object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了单个对象的三步过程：
- en: '![](img/642dbed2-267e-4027-babe-57452aa9d79a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/642dbed2-267e-4027-babe-57452aa9d79a.png)'
- en: Animating a 3D scene
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画3D场景
- en: Animating a scene is nothing more than applying the appropriate local transformations
    to the objects in the scene. For instance, if we want to move a cone and a sphere,
    each one of them will have a corresponding local transformation that will describe
    its location, orientation, and scale. In the previous section, we learned that
    matrix stacks allow us to preserve the original Model-View transform so that we
    can apply the correct local transforms to each object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 动画场景不过是将适当的局部变换应用到场景中的对象上。例如，如果我们想移动一个圆锥和一个球，每个对象都将有一个相应的局部变换来描述其位置、方向和比例。在上一节中，我们了解到矩阵栈允许我们保留原始模型视图变换，这样我们就可以为每个对象应用正确的局部变换。
- en: Now that we know how to move objects with local transforms and matrix stacks,
    we should address w*hen* to apply these transforms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用局部变换和矩阵栈来移动对象，我们应该考虑何时应用这些变换。
- en: If we calculate the position to apply to the cone and sphere in our example
    every time we call the `render` function, this would imply that the animation
    rate would depend on the speed of our rendering cycle. A slow rendering cycle
    would produce choppy animations and too fast a rendering cycle would create the
    illusion of objects jumping from one side to the other without smooth transitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们每次调用`render`函数时都计算应用于示例中的圆锥和球的位置，这将意味着动画速率将取决于我们的渲染周期速度。缓慢的渲染周期会产生不流畅的动画，而过快的渲染周期则会在物体之间跳跃时产生不自然的过渡效果。
- en: 'Therefore, it is important to make the animation independent of the rendering
    cycle. There are a couple of solutions that we can use to achieve this goal: the
    `requestAnimationFrame` function and JavaScript timers.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使动画独立于渲染周期是很重要的。我们可以使用以下几种解决方案来实现这一目标：`requestAnimationFrame`函数和JavaScript计时器。
- en: The requestAnimationFrame Function
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`函数'
- en: The `requestAnimationFrame` function is available in all WebGL-enabled browsers.
    One of the advantages of leveraging this function is that it is designed to call
    the rendering function (whatever function we indicate) only when the browser/tab
    window is in focus. Otherwise, there is no call. This saves precious CPU, GPU,
    and memory resources. By using the `requestAnimationFrame` function, we can obtain
    a rendering cycle that is in sync with hardware capabilities and one that will
    automatically suspend itself when the window is out of focus.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`函数在所有支持WebGL的浏览器中都是可用的。利用这个函数的一个优点是，它被设计成仅在浏览器/标签窗口处于焦点时调用渲染函数（无论我们指定的是哪个函数）。否则，不会进行调用。这可以节省宝贵的CPU、GPU和内存资源。通过使用`requestAnimationFrame`函数，我们可以获得一个与硬件能力同步的渲染周期，并且当窗口失去焦点时，它会自动暂停。'
- en: requestAnimationFrame
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`'
- en: To check out the status of `requestAnimationFrame` in your browser, visit [https://caniuse.com/#search=requestanimationframe](https://caniuse.com/#search=requestanimationframe).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查浏览器中`requestAnimationFrame`的状态，请访问[https://caniuse.com/#search=requestanimationframe](https://caniuse.com/#search=requestanimationframe)。
- en: JavaScript Timers
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript计时器
- en: That said, `requestAnimationFrame` is not a magical function that is a complete
    black box. It’s important to remember that we can implement our own in situations
    where it's not available or if we want a tailored animation experience. To do
    so, we will use two JavaScript timers to isolate the rendering rate from the animation
    rate.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`requestAnimationFrame`不是一个魔法函数，它是一个完整的黑盒。重要的是要记住，在它不可用或我们想要定制动画体验的情况下，我们可以实现自己的。为此，我们将使用两个JavaScript计时器来隔离渲染速率和动画速率。
- en: Unlike the `requestAnimationFrame` function, JavaScript timers continue running
    in the background, even when the page is not in focus. This is not optimal performance
    since computer resources are allocated toward a scene that is not in view. To
    mimic some of the intelligent behavior of `requestAnimationFrame`, we can use
    the `onblur` and `onfocus` events of the JavaScript window object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与`requestAnimationFrame`函数不同，JavaScript计时器即使在页面未获得焦点时也会在后台继续运行。这不是最佳性能，因为计算机资源被分配到了一个不可见的场景。为了模仿`requestAnimationFrame`的一些智能行为，我们可以使用JavaScript窗口对象的`onblur`和`onfocus`事件。
- en: 'Let''s see what we can do:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能做什么：
- en: '| **Action (What)** | **Goal (Why)** | **Method (How)** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **动作（做什么）** | **目标（为什么）** | **方法（如何）** |'
- en: '| Pause the rendering | To stop the rendering until the window is in focus.
    | Clear the timer calling `clearInterval` in the `window.onblur` function. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 暂停渲染 | 在窗口获得焦点之前停止渲染。 | 在`window.onblur`函数中调用`clearInterval`清除计时器。 |'
- en: '| Slow the rendering | To reduce resource consumption but make sure that the
    3D scene keeps evolving, even if we’re not looking at it. | We can clear current
    timer calling `clearInterval` in the `window.onblur` function and create a new
    timer with a more relaxed interval (higher value). |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 减慢渲染 | 减少资源消耗，但确保3D场景即使在未查看时也能继续演变。 | 我们可以在`window.onblur`函数中清除当前计时器调用`clearInterval`，并创建一个新的计时器，具有更宽松的间隔（更高的值）。
    |'
- en: '| Resume the rendering | To activate the 3D scene at full speed when the browser
    window recovers its focus. | We start a new timer with the original render rate
    in the `window.onfocus` function. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 恢复渲染 | 当浏览器窗口恢复焦点时，以全速激活3D场景。 | 在`window.onfocus`函数中启动一个新的计时器，以原始渲染速率。 |'
- en: By reducing the JavaScript timer rate or clearing the timer, we can handle hardware
    resources more efficiently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少JavaScript计时器速率或清除计时器，我们可以更有效地处理硬件资源。
- en: Controlling the Render Cycle
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 控制渲染周期
- en: An example of this sort of low-level functionality can be seen in the `common/js/Clock.js`
    file. With this universal clock, you can see how the `onblur` and `onfocus` events
    have been used to control the clock ticking (the rendering cycle), as we described
    previously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级功能的一个例子可以在`common/js/Clock.js`文件中看到。使用这个通用时钟，你可以看到`onblur`和`onfocus`事件是如何被用来控制时钟滴答（渲染周期）的，正如我们之前所描述的。
- en: Timing Strategies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间策略
- en: If you've programmed animations in JavaScript before, you may have used either
    `setInterval` or `setTimeout` to get your drawing function to be called.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在JavaScript中编写过动画，你可能已经使用了`setInterval`或`setTimeout`来调用你的绘图函数。
- en: The problem with using these two approaches for drawing is that they have no
    relation to the browser's render cycle. That is, they aren't synced to when the
    browser is going to draw a new frame, which can leave the animation out of sync
    with the user's machine. For example, if you use `setInterval` or `setTimeout`
    and assume `60` frames a second, and the user's machine is actually running a
    different frame rate, you'll be out of sync with their machine.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法绘制的问题在于它们与浏览器的渲染周期没有关系。也就是说，它们没有同步到浏览器将要绘制新帧的时间，这可能导致动画与用户的机器不同步。例如，如果你使用`setInterval`或`setTimeout`并假设每秒`60`帧，而用户的机器实际上运行的是不同的帧率，你将与他们的机器不同步。
- en: Even though `requestAnimationFrame` is available on all WebGL-enabled browsers,
    we'll leverage our own animation JavaScript timers for educational purposes. In
    production, it is recommended that you leverage the browser's optimized version.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`requestAnimationFrame`在所有启用WebGL的浏览器上都是可用的，但出于教育目的，我们将利用我们自己的动画JavaScript计时器。在生产环境中，建议您利用浏览器的优化版本。
- en: In this section, we will create a JavaScript timer that will allow us to control
    the animation. As we mentioned previously, we will implement a JavaScript timing
    strategy that provides independence between how fast your computer can render
    frames and how fast you want the animation to go. We will refer to this property
    as the **animation rate**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个JavaScript计时器，允许我们控制动画。正如我们之前提到的，我们将实现一个JavaScript计时策略，它提供计算机渲染帧的速度和动画速度之间的独立性。我们将把这个属性称为**动画速率**。
- en: 'Before moving forward, we must address a caveat about working with timers:
    *JavaScript is not a multithreaded language*. This means that if there are several
    asynchronous events occurring at the same time (blocking events), the browser
    will queue them for posterior execution. Each browser has a different mechanism
    to deal with blocking event queues.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们必须解决与计时器一起工作的一个注意事项：*JavaScript不是多线程语言*。这意味着如果有几个异步事件同时发生（阻塞事件），浏览器将排队等待后续执行。每个浏览器都有不同的机制来处理阻塞事件队列。
- en: There are two blocking event-handling alternatives for the purpose of developing
    an animation timer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发动画计时器时，有两种阻塞事件处理的替代方案。
- en: Animation Strategy
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画策略
- en: 'The first alternative is to calculate the elapsed time inside the timer callback.
    The pseudocode looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个替代方案是在计时器回调内部计算经过的时间。伪代码如下：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In doing so, we guarantee that the animation time is independent of how often
    the timer callback is actually executed. If there are big delays (due to other
    blocking events), this method may result in **dropped frames**. This means that
    the object's positions in our scene will immediately be moved to the current position
    that they should be in according to the elapsed time (between consecutive animation
    timer callbacks), and then the intermediate positions will be ignored. The motion
    on screen may jump, but often, a dropped animation frame is an acceptable loss
    in a real-time application. One example is the movement of one object from point
    `A` to point `B` over a given period of time. However, if we used this strategy
    when shooting a target in a 3D shooting game, we could quickly run into problems.
    Imagine that you are trying to shoot a target where there is a delay. The next
    thing you know, the target is no longer there! Since we need to calculate a collision
    in this case, we cannot afford to miss frames. This is because the collision could
    occur in any of the frames that we would drop without analyzing. The following
    strategy solves this problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们保证动画时间与计时器回调实际执行频率无关。如果有大的延迟（由于其他阻塞事件），这种方法可能会导致**丢帧**。这意味着在我们的场景中，对象的位姿将立即移动到根据经过的时间（连续动画计时器回调之间）它们应该所处的当前位置，然后忽略中间位置。屏幕上的运动可能会跳跃，但在实时应用中，丢失的动画帧通常是可以接受的损失。一个例子是物体在给定时间段内从点`A`移动到点`B`。然而，如果我们使用这种策略在3D射击游戏中射击目标，我们可能会迅速遇到问题。想象一下，你正在尝试射击一个有延迟的目标。接下来你知道的，目标已经不在那里了！由于在这种情况下我们需要计算碰撞，我们无法承受丢失帧。这是因为碰撞可能发生在我们丢弃的任何帧中，而没有进行分析。以下策略解决了这个问题。
- en: Simulation Strategy
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟策略
- en: 'There are several applications, such as the shooting game example, that require
    all intermediate frames to ensure the integrity of the outcome. These applications
    include working with collision detection, physics simulations, or artificial intelligence
    for games. For games, we need to update the object''s positions at a constant
    rate. We do so by directly calculating the next position for the objects inside
    the timer callback:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '有一些应用程序，如射击游戏示例，需要所有中间帧以确保结果的完整性。这些应用程序包括与碰撞检测、物理模拟或游戏人工智能一起工作。对于游戏，我们需要以恒定的速率更新对象的位姿。我们通过在计时器回调内部直接计算对象的下一个位置来实现这一点：  '
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This may lead to **frozen frames** that occur when there is a long list of blocking
    events because the object's positions would not be updated in a timely manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致**冻结帧**，当存在大量阻塞事件时会发生，因为对象的位姿不会及时更新。
- en: 'Combined Approach: Animation and Simulation'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合方法：动画和模拟
- en: Generally speaking, browsers can efficiently handle blocking events, and in
    most cases, performance would be similar regardless of the chosen strategy. Deciding
    to calculate the elapsed time or the next position in timer callbacks will then
    depend on your particular application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，浏览器可以有效地处理阻塞事件，并且在大多数情况下，无论选择哪种策略，性能都会相似。因此，决定在计时器回调中计算经过的时间或下一个位置将取决于你的特定应用。
- en: 'Nonetheless, there are cases where it is desirable to combine both animation
    and simulation strategies. We can create a timer callback that calculates the
    elapsed time and updates the animation as many times as required per frame. The
    pseudocode looks like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有些情况下，结合动画和模拟策略是有益的。我们可以创建一个计时器回调，该回调计算经过的时间，并根据每帧所需的次数更新动画。伪代码如下：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet demonstrates that the animation will always update
    at a fixed rate, regardless of how much time elapses between frames. If the app
    is running at `60` Hz, the animation will update once every other frame; if the
    app runs at `30` Hz, the animation will update once per frame; if the app runs
    at `15` Hz, the animation will update twice per frame. The animation remains far
    more stable and deterministic if it is always moved forward by a fixed amount.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段表明，动画将以固定的速率更新，无论帧之间经过多少时间。如果应用以`60` Hz运行，动画将每帧更新一次；如果应用以`30` Hz运行，动画将每帧更新一次；如果应用以`15`
    Hz运行，动画将每帧更新两次。如果动画始终通过固定量向前移动，它将保持更加稳定和确定。
- en: 'The following sequence shows the responsibilities of each function in the call
    stack for the combined approach:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的序列显示了在组合方法中每个函数在调用堆栈中的职责：
- en: '`render`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`:'
- en: Starts the timer
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动计时器
- en: Sets the animation rate
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置动画速率
- en: The timer callback is the `onFrame` function
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器回调是`onFrame`函数
- en: '`onFrame`:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onFrame`:'
- en: Calculates the elapsed time since the last call.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算自上次调用以来的经过时间。
- en: If the elapsed time is less than the animation rate, then it returns without
    further processing. Otherwise, it calculates the number of frames that the animation
    needs to be updated.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果经过的时间小于动画速率，则它将不进行进一步处理而返回。否则，它计算动画需要更新的帧数。
- en: Updates the animation by calling the `animate` function.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`animate`函数更新动画。
- en: '`animate`:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animate`:'
- en: Updates the object positions by a fixed increment. In this example, the sphere
    is updated by `0.1` units every time `animate` is called.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过固定增量更新对象位置。在这个例子中，每次调用`animate`时，球体都会更新`0.1`单位。
- en: It calls `draw` to update the object on screen. This is *optional*, since the
    rendering loop calls `draw` periodically anyway.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用`draw`来更新屏幕上的对象。这是可选的，因为渲染循环会定期调用`draw`。
- en: '`draw`:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`:'
- en: Creates a local transformation using the new position calculated in `animate`,
    and it applies it to the corresponding object.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在`animate`中计算的新位置创建局部变换，并将其应用于相应的对象。
- en: 'The code looks something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像这样：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This approach may cause issues if an animation step actually takes longer to
    compute than the fixed step. If this occurs, you should simplify your animation
    code or release a recommended minimum system spec for your application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画步骤实际上计算的时间比固定步骤长，这种方法可能会引起问题。如果发生这种情况，你应该简化你的动画代码或为你的应用程序发布推荐的最低系统规格。
- en: 'Web Workers: Multithreading in JavaScript'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers：JavaScript中的多线程
- en: Though outside the scope of this book, you should consider using **Web Workers**
    if performance is critical to you. Doing so will ensure that a particular update
    loop always fires at a consistent rate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这超出了本书的范围，但如果你对性能有严格要求，应该考虑使用**Web Workers**。这样做将确保特定的更新循环始终以一致的速率触发。
- en: Web Workers is an API that allows web applications to spawn background processes
    that run scripts in parallel to their main page. This allows for thread-like operation
    with message-passing as the coordination mechanism.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers是一个允许Web应用程序在主页面并行运行脚本的背景进程API。这允许以消息传递作为协调机制进行类似线程的操作。
- en: Web Workers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers
- en: You can find the Web Workers specification at [http://dev.w3.org/html5/workers/](http://dev.w3.org/html5/workers/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://dev.w3.org/html5/workers/](http://dev.w3.org/html5/workers/)找到Web
    Workers规范。
- en: Architectural Updates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑更新
- en: Let's review the structure of the examples developed in this book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本书中开发的示例结构。
- en: App Review
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序审查
- en: The `init` function defines three function hooks that control the life cycle
    of the application. As we've covered in previous chapters, we create our application
    by invoking the `init` function. Then, we call the hooks to the `configure`, `load`,
    and `render` functions. Also, please note that the `init` function is the entry
    point for the application and it is automatically invoked using the `onload` event
    of the web page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数定义了三个函数钩子，用于控制应用程序的生命周期。正如我们在前面的章节中提到的，我们通过调用 `init` 函数来创建我们的应用程序。然后，我们调用
    `configure`、`load` 和 `render` 函数的钩子。请注意，`init` 函数是应用程序的入口点，并且它将自动使用网页的 `onload`
    事件调用。'
- en: Adding Support for Matrix Stacks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对矩阵栈的支持
- en: 'We''ve also added a new script: `Transforms.js`. This file contains the `Transforms`
    class that encapsulate the matrix-handling operations, including the `push` and
    `pop` matrix stack operations. The `Transforms` class replaces the functionality
    behind the `initTransforms`, `updateTransforms`, and `setMatrixUniforms` functions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新的脚本：`Transforms.js`。此文件包含 `Transforms` 类，它封装了矩阵处理操作，包括 `push` 和 `pop`
    矩阵栈操作。`Transforms` 类取代了 `initTransforms`、`updateTransforms` 和 `setMatrixUniforms`
    函数背后的功能。
- en: You can find the source code for SceneTransforms in `common/js/Transforms.js`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `common/js/Transforms.js` 中找到 SceneTransforms 的源代码。
- en: Connecting Matrix Stacks and JavaScript Timers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接矩阵栈和 JavaScript 定时器
- en: In the following section, we will investigate a simple scene where we’ve animated
    a cone and a sphere. We will use matrix stacks to implement local transformations
    and JavaScript timers to implement the animation sequence.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将研究一个简单的场景，其中我们动画化了圆锥和球体。我们将使用矩阵栈来实现局部变换，并使用 JavaScript 定时器来实现动画序列。
- en: 'Time for Action: Simple Animation'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：简单动画
- en: 'Let''s look at an example covering a simple animation technique:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个涵盖简单动画技术的例子：
- en: 'Open `ch05_01_simple-animation.html` in your browser:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `ch05_01_simple-animation.html`：
- en: '![](img/d37c4b9e-baa4-4ed9-aa77-47337b58ccb2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d37c4b9e-baa4-4ed9-aa77-47337b58ccb2.png)'
- en: Move the camera around (left mouse-click + drag) and see how the objects (sphere
    and cone) move independently of one another (local transformations) and the camera
    (global transformation).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动相机（左键单击 + 拖动）并观察对象（球体和圆锥）如何独立移动（局部变换）以及相机（全局变换）。
- en: You can also dolly the camera (left mouse-click + *Alt* + drag).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以推拉相机（左键单击 + *Alt* + 拖动）。
- en: Change the camera type to Tracking. If for any reason you lose your bearings,
    click on Go Home.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机类型更改为跟踪。如果你因为任何原因失去了方向，请点击“返回主页”。
- en: Let's examine the source code to see how we’ve implemented this example. Open
    `ch05_01_simple-animation.html` in a code editor.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查源代码，看看我们是如何实现这个例子的。在代码编辑器中打开 `ch05_01_simple-animation.html`。
- en: Take a look at the `render`, `onFrame`, and `animate` functions. Which timing
    strategy are we using here?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看 `render`、`onFrame` 和 `animate` 函数。我们在这里使用哪种计时策略？
- en: 'The `spherePosition` and `conePosition` global variables contain the position
    of the sphere and the cone, respectively. Scroll up to the `draw` function. Inside
    the main loop where each object scene is rendered, a different local transformation
    is calculated depending on the current object being rendered. The code looks like
    the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spherePosition` 和 `conePosition` 全局变量分别包含球体和圆锥的位置。向上滚动到 `draw` 函数。在主循环中，每个对象场景渲染时，根据当前渲染的对象计算不同的局部变换。代码如下：'
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the transforms object (which is an instance of `Transforms`), we obtain
    the global Model-View matrix by calling `transforms.calculateModelView()`. Push
    it into a matrix stack by calling the `push` method. We can now apply any transform
    that we want, knowing that we can retrieve the global transform since it is available
    for the next object on the list. We do so at the end of the code snippet by calling
    the `pop` method. Between the `push` and `pop` calls, we determine which object
    is currently being rendered and use the `spherePosition` or `conePosition` global
    variable to apply a translation to the current Model-View matrix. By doing so,
    we create a local transform.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变换对象（它是 `Transforms` 的一个实例），我们通过调用 `transforms.calculateModelView()` 获取全局模型视图矩阵。通过调用
    `push` 方法将其推入矩阵栈。现在我们可以应用我们想要的任何变换，因为我们知道我们可以检索全局变换，因为它对于列表中的下一个对象是可用的。我们在代码片段的末尾通过调用
    `pop` 方法这样做。在 `push` 和 `pop` 调用之间，我们确定当前正在渲染的对象，并使用 `spherePosition` 或 `conePosition`
    全局变量将平移应用于当前的模型视图矩阵。通过这样做，我们创建了一个局部变换。
- en: Take a second look at the preceding code. As you saw at the beginning of this
    exercise, the cone is moving in the x-axis while the sphere is moving in the z-axis.
    What do you need to change to animate the cone in the y-axis? Test your hypothesis
    by modifying this code, saving the web page, and opening it again in your web
    browser.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次查看前面的代码。正如你在本练习开始时看到的，圆锥在x轴上移动，而球体在z轴上移动。你需要改变什么来使圆锥在y轴上动画化？通过修改此代码、保存网页并在你的网络浏览器中再次打开它来测试你的假设。
- en: Let's return to the `animate` function. What should we modify here to make the
    objects move faster?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`animate`函数。我们应该在这里修改什么来使物体移动得更快？
- en: HintTake a look at the global variables this function uses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：查看这个函数使用的全局变量。
- en: '***What just happened?***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: In this exercise, we saw a simple animation of two objects. We examined the
    source code to understand the call stack of functions that makes the animation
    possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了两个物体的简单动画。我们检查了源代码，以了解使动画成为可能的函数调用栈。
- en: 'Have a Go: Simulating Dropped and Frozen Frames'
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试模拟掉帧和冻结帧
- en: 'Let''s see how we can control the render rate:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何控制渲染速率：
- en: 'Open the `ch05_02_dropping-frames.html` file using your browser. Here, you
    will see the same scene we analyzed in the previous section. You’ll notice that
    the animation is not smooth because we are simulating dropping frames:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的浏览器打开`ch05_02_dropping-frames.html`文件。在这里，你会看到我们在上一节中分析的相同场景。你会注意到动画不流畅，因为我们正在模拟掉帧：
- en: '![](img/2ed16d5f-554b-4a79-a902-90640efc94f6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ed16d5f-554b-4a79-a902-90640efc94f6.png)'
- en: Take a look at the source code in your editor.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你编辑器中的源代码。
- en: 'Scroll to the `onFrame` function. You can see that we’ve included a new variable:
    `simulationRate`. In the `onFrame` function, this variable calculates how many
    simulation steps need to be performed when the time elapsed is around `300 ms`
    (`animationRate`). Given that `simulationRate` is `30 ms`, this will produce a
    total of `10` simulation steps. These steps can increase if there are unexpected
    delays and the elapsed time is considerably higher. This is the behavior that
    we expect.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`onFrame`函数。你可以看到我们增加了一个新的变量：`simulationRate`。在`onFrame`函数中，这个变量计算当时间流逝约为`300
    ms`（`animationRate`）时需要执行多少个模拟步骤。鉴于`simulationRate`是`30 ms`，这将产生总共`10`个模拟步骤。如果出现意外延迟且流逝的时间显著更高，这些步骤可能会增加。这是我们期望的行为。
- en: 'Experiment with different values for the `animationRate` and `simulationRate`
    variables to answer the following questions:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的`animationRate`和`simulationRate`变量的值来回答以下问题：
- en: How do we get rid of the dropping frames issue?
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何解决掉帧问题？
- en: How can we simulate frozen frames?
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何模拟冻结帧？
- en: What is the relationship between the `animationRate` and `simulationRate` variables
    when simulating frozen frames?
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟冻结帧时，`animationRate`和`simulationRate`变量之间的关系是什么？
- en: Parametric Curves
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数曲线
- en: There are many situations where we don't know the exact position of an object
    at a given time, but we do know an equation that describes its movement. These
    equations are known as **parametric curves**; they are parametric because the
    position depends on one parameter—for example, the time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们不知道物体在特定时间点的确切位置，但我们知道描述其运动的方程。这些方程被称为**参数曲线**；它们是参数化的，因为位置取决于一个参数——例如，时间。
- en: 'There are many examples of parametric curves. For example, a projectile shot
    in a game, a car going downhill, or a bouncing ball. In each case, there are equations
    that describe the motion of these objects under ideal conditions. The following
    diagram shows the parametric equation that describes the free-fall motion:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 参数曲线有很多例子。例如，游戏中射出的弹丸、下山的车或弹跳的球。在每种情况下，都有描述这些物体在理想条件下运动的方程。以下图显示了描述自由落体运动的参数方程：
- en: '![](img/fa1aee03-0e31-469f-a5f5-8c68f39fb723.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa1aee03-0e31-469f-a5f5-8c68f39fb723.png)'
- en: 'Where:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里：
- en: '`![](img/f9b25215-a7b1-4e98-9f13-401c373d2969.png)`: Gravity at `![](img/1a9485fd-ce69-4ce7-9a9c-231b2e71a06f.png)`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`![](img/f9b25215-a7b1-4e98-9f13-401c373d2969.png)`: 在`![](img/1a9485fd-ce69-4ce7-9a9c-231b2e71a06f.png)`处的重力'
- en: '`![](img/8bb375bf-01ed-4cde-9cda-2c7ac33d0807.png)`: Initial velocity'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`![](img/8bb375bf-01ed-4cde-9cda-2c7ac33d0807.png)`: 初始速度'
- en: '`![](img/3176d700-ce2d-48ee-912f-243c75e96a4a.png)`: Initial Position'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`![](img/3176d700-ce2d-48ee-912f-243c75e96a4a.png)`: 初始位置'
- en: '`![](img/bb542fe3-b290-46fe-a77f-13ba6d11434d.png)`: Time'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`![](img/bb542fe3-b290-46fe-a77f-13ba6d11434d.png)`: 时间'
- en: '`![](img/525e9640-f7e2-4759-999c-ab45bbf9fb68.png)`: Position'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`![](img/525e9640-f7e2-4759-999c-ab45bbf9fb68.png)`: 位置'
- en: We are going to use parametric curves to animate objects in a WebGL scene. In
    this example, we will model a set of bouncing balls. The complete source code
    for this exercise can be found in `ch05_03_bouncing-balls.html`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用参数曲线来动画化 WebGL 场景中的对象。在这个例子中，我们将模拟一组弹跳球。这个练习的完整源代码可以在 `ch05_03_bouncing-balls.html`
    中找到。
- en: Initialization Steps
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化步骤
- en: 'We will create a global variable that will store the (simulation) time. We
    will also create the global variables that regulate the animation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个全局变量来存储（模拟）时间。我们还将创建全局变量来调节动画：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `load` function is updated to load a bunch of balls using the same geometry
    (same JSON file), but we are adding it several times to the `scene` object. The
    code looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 函数更新为使用相同的几何形状（相同的 JSON 文件）加载一堆球，但我们将其多次添加到 `scene` 对象中。代码如下：'
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ES6 Template LiteralsIf you're not familiar with the `` `ball${i}` `` syntax,
    it's equivalent to `'ball' + i`. Instead of concatenating strings, we can leverage
    template literals in ES6 for dynamic string values. For more information, check
    out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模板字符串
- en: Notice that we’ve also populated an array named `balls[]`. We do this so that
    we can store the ball positions every time the global time changes. We will talk
    in depth about the bouncing ball simulation in the next *Time for action* section.
    For the moment, it’s worth mentioning that it is on the `load` function that we
    load the geometry and initialize the ball array with the initial ball positions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还填充了一个名为 `balls[]` 的数组。我们这样做是为了在全局时间每次变化时存储球的位置。我们将在下一个 *行动时间* 部分深入讨论弹跳球模拟。目前，值得一提的是，我们是在
    `load` 函数中加载几何形状并使用初始球位置初始化球数组的。
- en: Setting up the Animation Timer
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置动画计时器
- en: 'The `render` and `onFrame` functions look exactly the same as in the previous
    examples:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 和 `onFrame` 函数与之前的示例完全相同：'
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the Animation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行动画
- en: 'The `animate` function passes the `sceneTime` variable to the `update` method
    of every ball in the ball array. Then, `sceneTime` updates by a fixed amount.
    The code looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate` 函数将 `sceneTime` 变量传递给球数组中每个球的 `update` 方法。然后，`sceneTime` 通过一个固定量更新。代码如下：'
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, parametric curves are very helpful because they don’t require us to know
    the location of every object that we want to move beforehand. We just apply a
    parametric equation that gives us the location based on the current time. This
    occurs for every ball inside its update method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，参数曲线非常有帮助，因为它们不需要我们事先知道我们想要移动的每个对象的位置。我们只需应用一个参数方程，它根据当前时间给出位置。这发生在每个球在其更新方法内部。
- en: Drawing Each Ball in Its Current Position
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置绘制每个球
- en: 'In the `draw` function, we use a matrix stack to save the state of the Model-View
    matrix before applying a local transformation for each one of the balls. The code
    looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw` 函数中，我们使用矩阵栈在为每个球应用局部变换之前保存 Model-View 矩阵的状态。代码如下：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trick here is to use the number that makes up part of the ball alias to
    look up the respective ball position in the `balls` array. For example, if the
    ball being rendered has the `ball32` alias, then this code will look for the current
    position of the ball whose index is `32` in the `balls` array. This one-to-one
    correspondence between the `ball` alias and its location in the ball array was
    established in the `load` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是使用组成球别名的数字来查找 `balls` 数组中相应的球位置。例如，如果正在渲染的球具有 `ball32` 别名，那么此代码将查找 `balls`
    数组中索引为 `32` 的球当前位置。这种 `ball` 别名与其在球数组中的位置之间的一对一对应关系是在 `load` 函数中建立的。
- en: In the following *Time for Action* section, we will see the bouncing balls animation
    in action. We will also discuss some of the code detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 *行动时间* 部分，我们将看到弹跳球动画的实际效果。我们还将讨论一些代码细节。
- en: 'Time for Action: Bouncing Ball'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：弹跳球
- en: 'Let''s look at an example covering how we''d animate many objects in our scene:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，了解我们如何在我们的场景中动画化多个对象：
- en: 'Open `ch05_03_bouncing-balls.html` in your browser:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `ch05_03_bouncing-balls.html`：
- en: '![](img/093df5f6-3ddc-40bd-8125-5fe9ba38125c.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/093df5f6-3ddc-40bd-8125-5fe9ba38125c.png)'
- en: The orbiting camera is activated by default. Move the camera and you will see
    how all the objects adjust to the global transform (camera) and continue bouncing
    according to their local transforms.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下激活了环绕相机。移动相机，你会看到所有对象如何调整到全局变换（相机）并继续根据它们的局部变换弹跳。
- en: Let's explain how we keep track of each ball in more detail.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更详细地解释我们是如何跟踪每个球的。
- en: 'Define the appropriate global variables and constants:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义适当的全局变量和常量：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Initialize the `balls` array. We use a `for` loop in the `load` function to
    achieve this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`balls`数组。我们在`load`函数中使用`for`循环来实现这一点：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `BouncingBall` class initializes the simulation variables for each ball
    in the `balls` array. One of these attributes is the position, which we select
    randomly. You can see how we do this by using the `generatePosition` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BouncingBall`类为`balls`数组中的每个球初始化模拟变量。其中一个属性是位置，我们随机选择。你可以通过使用`generatePosition`函数看到我们是如何做到这一点的：'
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After adding a new ball to the `balls` array, we add a new ball object (geometry)
    to the `scene` instance. Please note that the alias we create includes the current
    index of the ball object in the `balls` array. For example, if we add the 32nd
    ball to the array, the alias that the corresponding geometry will have in `scene`
    will be `ball32`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将新球添加到`balls`数组后，我们在`scene`实例中添加一个新的球对象（几何形状）。请注意，我们创建的别名包括球对象在`balls`数组中的当前索引。例如，如果我们向数组中添加第32个球，相应的几何形状在`scene`中将具有`ball32`的别名。
- en: The only other object that we add to the scene here is `Floor`. We have used
    this object in previous exercises. You can find the code for the `Floor` class
    in `common/js/Floor.js`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里添加到场景中的唯一其他对象是`Floor`。我们在之前的练习中使用了这个对象。你可以在`common/js/Floor.js`中找到`Floor`类的代码。
- en: Let's talk about the `draw` function. Here, we go through the elements of `scene`
    and retrieve each object's alias. If the alias contains the word `ball`, we know
    that the alias corresponds to its `index` in the ball array. We could have probably
    used an associative array here to make it look nicer, but doing so does not really
    change our goal. The main point here is to make sure that we can associate the
    simulation variables for each ball with the corresponding object (geometry) in
    `scene`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们谈谈`draw`函数。在这里，我们遍历`scene`的元素并检索每个对象的别名。如果别名包含单词`ball`，我们知道这个别名对应于球数组中的`index`。我们可能在这里使用关联数组来使其看起来更美观，但这样做实际上并没有改变我们的目标。这里的主要目的是确保我们可以将每个球的模拟变量与`scene`中相应的对象（几何形状）关联起来。
- en: Notice that for each object (ball geometry) in `scene`, we extract the current
    position and the color from the respective `BouncingBall` instance in the `balls`
    array.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，对于`scene`中的每个对象（球几何形状），我们从`balls`数组中的相应`BouncingBall`实例中提取当前位置和颜色。
- en: Alter the current Model-View matrix for each ball by using a matrix stack to
    handle local transformations, as described previously. In our case, we want the
    animation for each ball to be independent from the transformations of the camera
    and one another.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用矩阵堆栈来处理局部变换，如前所述，修改每个球当前的模型-视图矩阵。在我们的例子中，我们希望每个球的动画独立于相机变换和彼此之间的变换。
- en: So far, we’ve described how the bouncing balls are created (`load`) and how
    they are rendered (`draw`). None of these functions modifies the current position
    of the balls. We do that by using `BouncingBall.update`. This code uses the animation
    time (the `sceneTime` global variable) to calculate the position for the bouncing
    ball. Since each `BouncingBall` has its own simulation parameters, we can calculate
    the position for each given position when `sceneTime` is provided . In short,
    the ball position is a function of time and, as such, it falls into the category
    of motion described by parametric curves.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了如何创建弹跳球（`load`）以及它们是如何渲染的（`draw`）。这些函数中的任何一个都没有修改球当前的当前位置。我们通过使用`BouncingBall.update`来实现这一点。此代码使用动画时间（全局变量`sceneTime`）来计算弹跳球的位置。由于每个`BouncingBall`都有自己的模拟参数，因此当提供`sceneTime`时，我们可以为每个给定位置计算位置。简而言之，球的位置是时间的函数，因此它属于由参数曲线描述的运动类别。
- en: The `BouncingBall.update` method is called inside the `animate` function. As
    we saw previously, this function is invoked by the animation timer each time the
    timer is up. Inside this function, you can see how the simulation variables are
    updated to reflect the current state of that ball in the simulation.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BouncingBall.update`方法在`animate`函数内部被调用。正如我们之前看到的，这个函数由动画计时器在计时器到达时调用。在这个函数内部，你可以看到模拟变量是如何更新以反映该球在模拟中的当前状态的。'
- en: '***What just happened?***'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We’ve learned how to handle several object-local transformations while preserving
    global transformations by using a matrix stack strategy. In the bouncing ball
    example, we used an animation timer for the animation that is independent from
    the rendering timer. Finally, we saw how the bouncing ball `update` method shows
    how parametric curves work.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用矩阵栈策略处理多个对象局部变换，同时保持全局变换。在弹跳球示例中，我们使用了一个独立于渲染计时器的动画计时器进行动画。最后，我们看到了弹跳球`update`方法如何展示参数曲线的工作原理。
- en: Optimization Strategies
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化策略
- en: 'If you play around a little bit and increase the value of the `ballsCount`
    global constant from `50` to `500`, you will start to notice that the frame rate
    degrades:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微调整一下，将全局常量`ballsCount`的值从`50`增加到`500`，你将开始注意到帧率下降：
- en: '![](img/7cafae70-a0f1-4436-bcb8-5c180c2e0354.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cafae70-a0f1-4436-bcb8-5c180c2e0354.png)'
- en: In the preceding screenshot, the rendering hovered roughly around `30` frames
    per second. Depending on your computer, the average time for the `draw` function
    can be higher than the frequency at which the animation timer callback is invoked.
    This will result in dropped frames. To correct this, we need to make the `draw`
    function faster. Let's see a couple of strategies to do this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，渲染速度大约在每秒`30`帧左右。根据你的电脑配置，`draw`函数的平均执行时间可能会高于动画计时器回调的调用频率。这会导致帧丢失。为了纠正这个问题，我们需要使`draw`函数运行得更快。让我们看看一些实现这一目标的策略。
- en: Optimizing Batch Performance
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理性能优化
- en: WebGL 2 adds some interesting features, such as **geometry-instancing.** This
    feature allows us to render the same instance of a single mesh with differing
    shader attributes using **instancing** and only one `render` call. Though instancing
    is limited, as it’s based on the same mesh only, it’s still a great way to improve
    performance if you have to draw the same meshes multiple times, especially if
    combined with shaders. While this functionality is provided in WebGL 2, we'll
    build our own geometry-optimization techniques for educational purposes. We will
    cover WebGL 2's geometry instancing feature in [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml),
    *WebGL 2 Highlights*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2增加了一些有趣的功能，例如**几何实例化**。这个功能允许我们使用**实例化**和单个`render`调用渲染具有不同着色器属性的相同网格实例。尽管实例化有限制，因为它基于相同的网格，但它仍然是在必须多次绘制相同网格时提高性能的绝佳方法，特别是如果与着色器结合使用。虽然这个功能在WebGL
    2中提供，但我们将为了教育目的构建自己的几何优化技术。我们将在第11章[WebGL 2 Highlights](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml)中介绍WebGL
    2的几何实例化功能。
- en: How do we optimize our scene without using the WebGL 2 geometry-instancing API?
    We can use geometry-caching as a way to optimize the animation of a scene full
    of similar objects. This is the case in the bouncing balls example. Each bouncing
    ball has a different position and color. These features are unique and independent
    for each ball. However, all of the balls share the same geometry.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在不用WebGL 2几何实例化API的情况下优化场景？我们可以使用几何缓存作为优化场景中大量相似对象动画的一种方式。这在弹跳球示例中就是这种情况。每个弹跳球都有不同的位置和颜色。这些特征对于每个球来说都是独特且独立的。然而，所有的球都共享相同的几何形状。
- en: In the `load` function, for `ch05_03_bouncing-balls.html`, we created `50` vertex
    buffer objects (VBOs) for each ball. Additionally, the same geometry is loaded
    `50` times, and on every rendering loop (`draw` function), a different VBO is
    bound, despite the geometry being the same for all the balls!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`load`函数中，对于`ch05_03_bouncing-balls.html`，我们为每个球创建了`50`个顶点缓冲对象（VBO）。此外，相同的几何形状被加载了`50`次，并且在每次渲染循环（`draw`函数）中，都会绑定一个不同的VBO，尽管所有球的几何形状都是相同的！
- en: 'In `ch05_04_bouncing-balls-optimized.html`, we modified the `load` and `draw`
    functions to handle geometry-caching. In the first place, the geometry is loaded
    just once (`load` function):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch05_04_bouncing-balls-optimized.html`中，我们修改了`load`和`draw`函数以处理几何缓存。首先，几何形状只加载一次（`load`函数）：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Second, when the object with the `''ball''` alias is the current object in
    the rendering loop (the `draw` function), the `drawBalls` delegate function is
    invoked. This function sets some of the uniforms that are common to all bouncing
    balls (so that we do not waste time passing them every time to `program` for every
    ball). After that, the `drawBall` function is invoked. This function will set
    up those elements that are unique for each ball. In our case, we set up the `program`
    uniform that corresponds to the ball color and the Model-View matrix, which is
    unique for each ball because of the local transformation (ball position):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，当具有 `'ball'` 别名的对象是渲染循环中的当前对象（`draw` 函数）时，会调用 `drawBalls` 代理函数。这个函数设置了一些对所有弹跳球都通用的统一变量（这样我们就不必每次都为每个球传递它们到
    `program`）。之后，调用 `drawBall` 函数。这个函数将设置每个球独特的元素。在我们的例子中，我们设置了与球颜色和模型视图矩阵相对应的 `program`
    统一变量，由于局部变换（球的位置），这个矩阵对每个球来说是唯一的：
- en: '![](img/24f0cb7b-5c28-42c5-83d0-328ff3f9391e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24f0cb7b-5c28-42c5-83d0-328ff3f9391e.png)'
- en: Performing Translations in the Vertex Shader
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在顶点着色器中执行平移
- en: If you take a look at the code in `ch05_04_bouncing-balls-optimized.html`, you
    will see that we have taken an extra step to cache the Model-View matrix.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `ch05_04_bouncing-balls-optimized.html` 中的代码，你会看到我们额外采取了一步来缓存模型视图矩阵。
- en: The basic idea behind this is to transfer the original matrix to the GPU (global)
    once and then perform the translation for each ball (local) inside the vertex
    shader. This change significantly improves the performance because of the parallel
    nature of the vertex shader.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的基本思想是将原始矩阵一次性传输到 GPU（全局），然后在顶点着色器内部为每个球（局部）执行平移。这种改变由于顶点着色器的并行性质，显著提高了性能。
- en: 'This is what we do, step by step:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的操作步骤，一步一步来：
- en: Create a new uniform that tells the vertex shader whether it should perform
    a translation (`uTranslate`).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的统一变量，告诉顶点着色器是否应该执行平移（`uTranslate`）。
- en: Create a new uniform that contains the ball position for each ball (`uTranslation`).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的统一变量，包含每个球的位置（`uTranslation`）。
- en: 'Map these two new uniforms to JavaScript variables (we do this in the `configure`
    function):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个新统一变量映射到 JavaScript 变量（我们在 `configure` 函数中这样做）：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Perform the translation inside the vertex shader. This part is probably the
    trickiest part since it requires a little bit of ESSL programming:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器内部执行平移。这部分可能是最棘手的部分，因为它需要一点 ESSL 编程：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code fragment, we are defining `vecPosition`, a variable of the `vec3`
    type. If the `uTranslate` uniform is `true` (meaning we are trying to render a
    bouncing ball), then we update `vecPosition` with the translation. This is implemented
    using vector-addition.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了 `vecPosition`，一个 `vec3` 类型的变量。如果 `uTranslate` 统一变量为 `true`（意味着我们正在尝试渲染一个弹跳球），则使用向量加法更新
    `vecPosition`。这是通过以下方式实现的：
- en: 'Make sure that the transformed vertex carries the translation in case of having
    one, so the following line looks like this:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在存在平移的情况下，变换后的顶点携带平移，所以以下行看起来像这样：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `drawBall`, pass the current ball position as the content for the `uTranslation`
    uniform:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `drawBall` 中，将当前球的位置作为 `uTranslation` 统一变量的内容传递：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `drawBalls`, set the `uTranslate` uniform to `true`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `drawBalls` 中，将 `uTranslate` 统一变量设置为 `true`：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In `draw`, pass the Model-View matrix once for all balls by using the following
    line of code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 中，使用以下代码行一次性为所有球传递模型视图矩阵：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Increase the `ballsCount` global variable from `50` to `500` and watch how
    the application continues to perform reasonably well, regardless of the increased
    scene complexity. The improvement in execution times is shown in the following
    screenshot:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全局变量 `ballsCount` 从 `50` 增加到 `500`，并观察应用程序如何继续以合理的性能运行，无论场景复杂度如何增加。执行时间的改进在下面的屏幕截图中显示：
- en: '![](img/c835db02-7b8a-4f89-ad15-4d7d7320ed9e.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c835db02-7b8a-4f89-ad15-4d7d7320ed9e.png)'
- en: After these optimizations, the example runs at a smooth `60` frames per second.
    The optimized source code is available at `ch05_bouncing-balls-optimized.html`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过这些优化后，示例以流畅的 `60` 帧每秒运行。优化的源代码可在 `ch05_bouncing-balls-optimized.html` 中找到。
- en: Interpolation
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: Interpolation greatly simplifies a 3D objects’ animation. Unlike parametric
    curves, it is not necessary to define the position of the object as a function
    of time. When interpolation is used, we only need to define control points or
    knots. The set of control points describes the path that a particular animate
    object will follow. There are many interpolation methods; however, it’s always
    a good idea to start with the basics.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 插值大大简化了3D对象的动画。与参数曲线不同，不需要将对象的位置定义为时间的函数。当使用插值时，我们只需要定义控制点或节点。控制点集描述了特定动画对象将遵循的路径。有众多插值方法；然而，始终从基础开始是一个好主意。
- en: Linear Interpolation
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性插值
- en: 'This method requires that we define the starting and ending points of the location
    of our object, along with the number of interpolating steps. The object will move
    on the line determined by the starting and ending points:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法要求我们定义对象位置的开始点和结束点，以及插值步数的数量。对象将在由起点和终点确定的直线上移动：
- en: '![](img/d131837a-66c0-4948-927f-a51d3512721b.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d131837a-66c0-4948-927f-a51d3512721b.png)'
- en: Polynomial Interpolation
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式插值
- en: 'This method allows us to determine as many control points as we want. The object
    will move from the starting point to the ending point and will pass through each
    one of the control points in between:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们确定我们想要的任意数量的控制点。对象将从起点移动到终点，并穿过中间的每一个控制点：
- en: '![](img/0828ec46-3b85-4064-863a-6816dfd6213d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0828ec46-3b85-4064-863a-6816dfd6213d.png)'
- en: 'While using polynomials, an increasing number of control points can produce
    undesired oscillations on the object''s path described by this technique. This
    is known as **Runge''s phenomenon**. The following diagram illustrates the result
    of moving one of the control points of a polynomial described with `11` control
    points:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多项式时，越来越多的控制点可能会在由该技术描述的对象路径上产生不希望的振荡。这被称为**Runge现象**。以下图表展示了使用`11`个控制点描述的多项式的一个控制点的移动结果：
- en: '![](img/d62c7061-455c-4f57-9bbf-e7177702ea53.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d62c7061-455c-4f57-9bbf-e7177702ea53.png)'
- en: B-Splines
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B-Splines
- en: 'This method is similar to polynomial interpolation with the difference that
    the control points are outside of the object''s path. In other words, the object
    does not pass through the control points as it moves. In general, this method
    is common in computer graphics because the knots allow for much smoother path-generation
    than the polynomial equivalent at the same time that fewer knots are required.
    B-splines also respond better to Runge''s phenomenon:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于多项式插值，不同之处在于控制点位于对象路径之外。换句话说，当对象移动时，它不会穿过控制点。一般来说，这种方法在计算机图形学中很常见，因为节点允许生成比多项式等价物更平滑的路径，同时所需的节点更少。B样条对Runge现象也有更好的响应：
- en: '![](img/1725689b-aa39-4bd5-84f2-4a559af72f9d.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1725689b-aa39-4bd5-84f2-4a559af72f9d.png)'
- en: 'In the following *Time for action* section, we will see in the three different
    interpolation techniques that have been introduced in practice: **linear**, **polynomial**,
    and **b-spline**.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下*行动时间*部分，我们将看到在实践中引入的三种不同的插值技术：**线性**、**多项式**和**B样条**。
- en: 'Time for Action: Interpolation'
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：插值
- en: 'Let''s cover an example showcasing various interpolation techniques:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示各种插值技术：
- en: 'Open `ch05_05_interpolation.html` using your browser. You should see something
    similar to the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器打开`ch05_05_interpolation.html`。你应该看到以下类似的内容：
- en: '![](img/8043fa8a-ae62-4586-ba80-64153008709a.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8043fa8a-ae62-4586-ba80-64153008709a.png)'
- en: 'Inspect the code in an editor. Nearly all of the functions are the same as
    before, except for the new function called `interpolate`. This function interpolates
    the position in a linear fashion:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中检查代码。几乎所有函数都与之前相同，只是新增了一个名为`interpolate`的函数。此函数以线性方式插值位置：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open up `ch05_06_interpolation-final.html` in your browser. You should see
    something similar to the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch05_06_interpolation-final.html`。你应该看到以下类似的内容：
- en: '![](img/65e81e88-8c6b-499f-9bcd-84cfcaffa39b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65e81e88-8c6b-499f-9bcd-84cfcaffa39b.png)'
- en: Select **Linear** interpolation if it is not already selected.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，请选择**线性**插值。
- en: Move the start and end points using the slider provided.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的滑块移动起点和终点。
- en: Change the number of interpolation steps. What happens to the animation when
    you decrease the number of steps?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变插值步数的数量。当你减少步数时，动画会发生什么变化？
- en: The code for the linear interpolation has been implemented in the `doLinearInterpolation`
    function.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性插值的代码已经在`doLinearInterpolation`函数中实现。
- en: Select **Polynomial** interpolation. In this example, we have implemented Lagrange's
    interpolation method. You can see the source code in the `doLagrangeInterpolation`
    function.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**多项式**插值。在这个例子中，我们实现了拉格朗日插值法。你可以在`doLagrangeInterpolation`函数中看到源代码。
- en: 'Three new control points (flags) appear on screen. Using the sliders provided
    on the web page, you can change the location of these control points. You can
    also change the number of interpolation steps:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕上出现了三个新的控制点（旗帜）。使用网页上提供的滑块，你可以改变这些控制点的位置。你还可以更改插值步数的数量：
- en: '![](img/29507453-9d0a-45d5-831b-a5d0183ea39d.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29507453-9d0a-45d5-831b-a5d0183ea39d.png)'
- en: You may have also noticed that whenever the ball approaches one of the flags
    (with the exception of the start and end points), the flag changes color. To do
    that, we have written the ancillary `close` function. We use this function inside
    the `draw` routine to determine the color of the flags. If the current position
    of the ball, determined by `position[sceneTime]`, is close to one of the flag
    positions, the respective flag changes color. When the ball is far from the flag,
    the flag changes back to its original color.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能也注意到，每当球体接近一个旗帜（除起点和终点外），旗帜会改变颜色。为了做到这一点，我们编写了辅助的`close`函数。我们在`draw`例程中使用此函数来确定旗帜的颜色。如果球体的当前位置（由`position[sceneTime]`确定）接近旗帜位置之一，相应的旗帜会改变颜色。当球体远离旗帜时，旗帜会变回原来的颜色。
- en: Modify the source code so that each flag remains *activated*; that is, activated
    with the new color after the ball passes by until the animation loops back to
    the beginning. This happens when `sceneTime` is equal to `incrementSteps` (see
    the `animate` function).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改源代码，使得每个旗帜都保持**激活**状态；也就是说，在球体经过后，使用新的颜色激活，直到动画循环回到开始。这发生在`sceneTime`等于`incrementSteps`时（参见`animate`函数）。
- en: Select the **B-Spline** interpolation. Notice how the ball does not reach any
    of the intermediate flags in the initial configuration. Is there any configuration
    you can test so that the ball passes through at least two of the flags?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**B-Spline**插值。注意球体在初始配置中并没有触及任何中间旗帜。你能测试出任何配置，使得球体至少穿过两个旗帜吗？
- en: '***What just happened?***'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We’ve learned how to use interpolation to describe the movement of an object
    in our 3D world. We've also created very simple scripts to detect object proximity
    and alter our scene accordingly (changing flag colors, in this example). Reaction
    to proximity is a key element in game design!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用插值来描述我们3D世界中物体的运动。我们还创建了非常简单的脚本，用于检测物体接近并相应地改变场景（在这个例子中改变旗帜颜色）。对接近的反应是游戏设计中的关键元素！
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let’s summarize what we learned in this chapter:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章学到的内容：
- en: We saw how we can leverage matrix stacks to preserve global transformations
    while applying local transformations.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何利用矩阵栈来在应用局部变换的同时保留全局变换。
- en: We covered the basic concepts behind object animations in WebGL. More specifically,
    we learned about the differences between local and global transformations.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了WebGL中对象动画背后的基本概念。更具体地说，我们学习了局部和全局变换之间的区别。
- en: We learned about the `requestAnimationFrame` browser and built our own version
    with JavaScript timers for animation.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了`requestAnimationFrame`浏览器和用JavaScript计时器构建的动画版本。
- en: An animation timer that is not tied up to the rendering cycle provides a lot
    of flexibility by ensuring that the time in the scene is independent of how fast
    it can be rendered on screen.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与渲染周期无关的动画计时器通过确保场景中的时间独立于屏幕上渲染速度的快慢，提供了很大的灵活性。
- en: We distinguished between animation and simulation strategies for various problem-solving
    approaches.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们区分了针对各种问题解决方法的动画和模拟策略。
- en: We looked at interpolation methods and their various approaches.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了插值方法和它们的各种方法。
- en: In the next chapter, we will play with colors and blending in a WebGL scene.
    We will study the interaction between objects and light colors, and learn how
    to create translucent objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在一个WebGL场景中玩转颜色和混合。我们将研究物体和光颜色之间的相互作用，并学习如何创建半透明物体。
