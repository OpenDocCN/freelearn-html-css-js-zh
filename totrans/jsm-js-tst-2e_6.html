<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Light Speed Unit Testing</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Asynchronous Testing – AJAX">Chapter 4</a>, <em>Asynchronous Testing – AJAX</em>, we saw how including AJAX testing in the application can increase the complexity of the tests. In the example in that chapter, we created a server where the results were predictable. It was basically a complex test fixture. Even though we could have used a real server implementation, it would increase the complexity of the test even more; try changing the state of a server with a database or third-party services from the browser—it is not an easy or scalable solution.</p><p>There is also the impact on productivity; these requests take time to process and transmit, which hurts the quick feedback loop that unit testing usually provides.</p><p>You can also say that these specs test both the client and the server code and, therefore, could not be considered unit tests; rather, they could be considered integration tests.</p><p>A solution to all these problems is to use either <strong>stubs</strong><a id="id184" class="indexterm"/> or <strong>fakes</strong><a id="id185" class="indexterm"/> in place of the real dependencies of the code. So, instead of making a request to the server, we use a test double of the server inside the browser.</p><p>We are going to use the same example from <a class="link" href="ch04.html" title="Chapter 4. Asynchronous Testing – AJAX">Chapter 4</a>, <em>Asynchronous Testing – AJAX</em>, and rewrite it using different techniques.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Jasmine stubs</h1></div></div></div><p>We have already seen some use cases for <a id="id186" class="indexterm"/>Jasmine spies. Remember that a spy is a special function that<a id="id187" class="indexterm"/> records how it was called. You can think of a stub as a spy with behavior.</p><p>We use stubs whenever we want to force a specific path in our specs or replace a real implementation for a simpler one.</p><p>Let's revisit the example of the acceptance criteria, "Stock when fetched, should update its share price", by rewriting it using Jasmine stubs.</p><p>We know that the stock's <code class="literal">fetch</code> function is implemented using the <code class="literal">$.getJSON</code> function, as follows:</p><div><pre class="programlisting">Stock.prototype.fetch = function(parameters) {
 <strong> $.getJSON</strong>(url, function (data) {
    that.sharePrice = data.sharePrice;
    success(that);
  });
};</pre></div><p>We could use the <code class="literal">spyOn</code> function to set up a spy on the <code class="literal">getJSON</code> function with the following code:</p><div><pre class="programlisting">describe("when fetched", function() {
  beforeEach(function() {
    <strong>spyOn($, 'getJSON').and.callFake(function(url, callback) {</strong>
      <strong>callback({ sharePrice: 20.18 });</strong>
    <strong>});</strong>
    stock.fetch();
  });

  it("should update its share price", function() {
    expect(stock.sharePrice).toEqual(20.18);
  });
});</pre></div><p>But this time, we will use <a id="id188" class="indexterm"/>the <code class="literal">and.callFake</code> function to set a behavior to our spy (by default, a spy does nothing and returns undefined). We make the spy invoke its <code class="literal">callback</code> parameter<a id="id189" class="indexterm"/> with an object response (<code class="literal">{ sharePrice: 20.18 }</code>).</p><p>Later, at the expectation, we use the <code class="literal">toEqual</code> assertion to verify that the stock's <code class="literal">sharePrice</code> has changed.</p><p>To run this spec, you no longer need a server to make the requests to, which is a good thing, but there is one issue with this approach. If the fetch function gets refactored to use <code class="literal">$.ajax</code> instead of <code class="literal">$.getJSON</code>, then the test will fail. A better solution, provided by a Jasmine plugin called<a id="id190" class="indexterm"/> <strong>jasmine-ajax</strong>, is to stub the browser's AJAX infrastructure instead, so the implementation of the AJAX request is free to be done in different manners.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Jasmine Ajax</h1></div></div></div><p>Jasmine Ajax is<a id="id191" class="indexterm"/> an official plugin developed to help out the testing of AJAX requests. It changes the browser's AJAX request infrastructure to a fake implementation.</p><p>This fake (or mocked) implementation, although simpler, still behaves like the real implementation to any code using its API.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Installing the plugin</h2></div></div></div><p>Before we dig into the spec <a id="id192" class="indexterm"/>implementation, first we need to add the plugin to the project. Go<a id="id193" class="indexterm"/> to <a class="ulink" href="https://github.com/jasmine/jasmine-ajax/">https://github.com/jasmine/jasmine-ajax/</a> and download the current release (which should be compatible with the Jasmine 2.x release). Place it inside the <code class="literal">lib</code> folder.</p><p>It is also needed to be added to the <code class="literal">SpecRunner.html</code> file, so go ahead and add another script:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/mock-ajax.js"&gt;&lt;/script&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec27"/>A fake XMLHttpRequest</h2></div></div></div><p>Whenever you are using jQuery to<a id="id194" class="indexterm"/> make AJAX requests, under the hood it is<a id="id195" class="indexterm"/> actually using the <code class="literal">XMLHttpRequest</code> object to perform the request.</p><p><code class="literal">XMLHttpRequest</code> is the standard JavaScript HTTP API. Even though its name suggests that it uses XML, it supports other types of content such as JSON; the name has remained the same for compatibility reasons.</p><p>So, instead of stubbing jQuery, we could change the <code class="literal">XMLHttpRequest</code> object with a fake implementation. That is exactly what this plugin does.</p><p>Let's rewrite the previous spec to use this fake implementation:</p><div><pre class="programlisting">describe("when fetched", function() {
  <strong>beforeEach(function() {</strong>
<strong>    jasmine.Ajax.install();</strong>
<strong>  });</strong>

  beforeEach(function() {
    stock.fetch();

    <strong>jasmine.Ajax.requests.mostRecent().respondWith({</strong>
<strong>      'status': 200,</strong>
<strong>      'contentType': 'application/json',</strong>
<strong>      'responseText': '{ "sharePrice": 20.18 }'</strong>
<strong>    });</strong>
  });

  <strong>afterEach(function() {</strong>
<strong>    jasmine.Ajax.uninstall();</strong>
<strong>  });</strong>

  it("should update its share price", function() {
    expect(stock.sharePrice).toEqual(20.18);
  });
});</pre></div><p>Drilling the <a id="id196" class="indexterm"/>implementation down:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we tell the<a id="id197" class="indexterm"/> plugin to replace the original implementation of the <code class="literal">XMLHttpRequest</code> object by a fake implementation using the <code class="literal">jasmine.Ajax.install</code> function.</li><li class="listitem">We then invoke the <code class="literal">stock.fetch</code> function, which will invoke <code class="literal">$.getJSON</code>, creating <code class="literal">XMLHttpRequest</code> anew under the hood.</li><li class="listitem">And finally, we use the <code class="literal">jasmine.Ajax.requests.mostRecent().respondWith</code> function to get the most recently made request and respond to it with a fake response.</li></ol></div><p>We use the <code class="literal">respondWith</code> function, which accepts an object with three properties:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">status</code> property to define the HTTP status code.</li><li class="listitem">The <code class="literal">contentType</code> (JSON in the example) property.</li><li class="listitem">The <code class="literal">responseText</code> property, which is a text string containing the response body for the request.</li></ol></div><p>Then, it's all a matter of running the expectations:</p><div><pre class="programlisting">it("should update its share price", function() {
  expect(stock.sharePrice).toEqual(20.18);
});</pre></div><p>Since the plugin changes the global <code class="literal">XMLHttpRequest</code> object, you must remember to tell Jasmine to restore it to its original implementation after the test runs; otherwise, you could interfere with the code from other specs (such as the Jasmine jQuery fixtures module). Here's how you can accomplish this:</p><div><pre class="programlisting">afterEach(function() {
  jasmine.Ajax.uninstall();
});</pre></div><p>There is also a slightly different approach to write this spec; here, the request is first stubbed (with the response details) and the code to be exercised is executed later.</p><p>The previous example is changed to the following:</p><div><pre class="programlisting">beforeEach(function() {
  <strong>jasmine.Ajax.stubRequest('http://localhost:8000/stocks/AOUE').andReturn({</strong>
<strong>    'status': 200,</strong>
<strong>    'contentType': 'application/json',</strong>
<strong>    'responseText': '{ "sharePrice": 20.18 }'</strong>
<strong>  });</strong>

  stock.fetch();
});</pre></div><p>It is possible to use the <code class="literal">jasmine.Ajax.stubRequest</code> function to stub any request to a specific request. In the example, it is defined by the URL <code class="literal">http://localhost:8000/stocks/AOUE</code>, and the response definition is as follows:</p><div><pre class="programlisting">{
  'status': 200,
  'contentType': 'application/json',
  'responseText': '{ "sharePrice": 20.18 }'
}</pre></div><p>The response definition<a id="id198" class="indexterm"/> follows the same properties as the previously <a id="id199" class="indexterm"/>used <code class="literal">respondWith</code> function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, you learned how asynchronous tests can hurt the quick feedback loop you can get with unit testing. I showed how you can use either stubs or fakes to make your specs run quicker and with fewer dependencies.</p><p>We have seen two different ways in which you could test AJAX requests with a simple Jasmine stub and with the more advanced, fake implementation of the <code class="literal">XMLHttpRequest</code>.</p><p>You also got more familiar with spies and stubs and should be more comfortable using them in different scenarios.</p><p>In the next chapter, we are going to go further into the complexity of our application, and we will do an overall refactoring to transform it into a fully featured single-page application using the <code class="literal">React.js</code> library.</p></div></body></html>