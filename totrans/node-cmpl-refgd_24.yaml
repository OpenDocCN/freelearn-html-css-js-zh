- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we successfully deployed our service to a cloud provider
    without having to fundamentally change our code. We used a database to store our
    data, and the only thing we needed to do was to point to the new location.
  prefs: []
  type: TYPE_NORMAL
- en: It's common, during the specification and development process, to have challenging
    problems with one or more ways of solving them. The ways, or paths, you choose
    throughout the development are called design patterns, as they're part of your
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Some design patterns are more common than others. Some are well-known, others,
    not so much. Some are good design patterns and you should follow them. Others
    are bad because of the disadvantages they bring in the short or long term.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a look at the importance of choosing good
    patterns; we will look at some common architectural patterns and review the continuous
    integration we followed through the entire book until we successfully deployed
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns are not libraries or classes, they're concepts, reusable solutions
    to common programming problems, tested and optimized for specific use cases. As
    they're just concepts to solve specific problems, they have to be implemented
    in every language.
  prefs: []
  type: TYPE_NORMAL
- en: Every pattern has its advantages and disadvantages, and choosing a wrong pattern
    for a problem can cause you a big headache.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns can speed up the development process because they provide well-tested
    and well-proven development paradigms. Reusing patterns helps prevent issues and
    improves code readability between developers that are familiar with the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns have major importance in high-performance applications. Sometimes,
    in order to achieve some flexibility, patterns introduce a new level of indirection
    in the code, which may reduce performance. You should choose when to introduce
    a pattern or when that introduction will hurt the performance metric you're targeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing good patterns is essential for avoiding the opposite: anti-patterns.
    An anti-pattern is something that looks good in the beginning but later on turns
    out to look like the worst decision you ever made. Anti-patterns are not specific
    patterns but are more like common errors, seen by the majority as strategies you
    shouldn''t use. Some of the most common and frequent anti-patterns seen out there
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeating yourself**: Don''t repeat excessive parts of the code. Lean back,
    look at the big picture and refactor it. Some developers tend to look at this
    refactoring as a complexity of the application, but it can actually turn your
    application simpler. If you think you won''t be able to understand the simplicity
    of your refactoring, don''t forget to add a couple of introductory comments to
    the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golden hammer or silver bullet**: Don''t think your favorite language or
    framework is universally applicable. Most of the languages can actually do practically
    anything, at least the mature ones, and with a huge community. That doesn''t mean
    a language performs some tasks well. If your goal is performance, try to have
    a couple of hammers in your belt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coding by exception**: Don''t add new code to handle new cases as they appear.
    By new cases, I don''t mean new features; I mean behavior your code was not expecting.
    For example, when you''re making a file upload feature of some kind, remember
    an error might happen during transfer, the file can be empty, have weird content,
    be huge, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming by accident**: Don''t program by trial and error until you succeed.
    This is something you should really avoid. Programming by accident can sometimes
    make your code work in some cases (by accident) and produce erroneous behaviors
    in others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing microservices and, more specifically, an ecosystem of microservices,
    some patterns become very obvious, and you'll use them without knowing. Just looking
    at the architectural patterns, here are some that you might find interesting.
    Perhaps you have already used them before.
  prefs: []
  type: TYPE_NORMAL
- en: Front Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Front Controller** pattern is when all requests go for a single point
    in your architecture, called the handler, which then processes and dispatches
    the requests to other handlers. This is the pattern used by, for example, load
    balancers and reverses proxies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d6b169f-e015-4e4b-a9fb-6f19784bcdb9.png)'
  prefs: []
  type: TYPE_IMG
- en: It's useful to scale horizontally, especially when the **Front Controller**
    is just routing requests, so it can handle a lot more requests than each separate
    controller, which need, some time to actually process each request.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is also very useful in helping other services not having to know
    where the controllers are and choosing the one with the lowest load that should
    handle the request faster.
  prefs: []
  type: TYPE_NORMAL
- en: Layered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The layered pattern is common in filesystems and operative systems (and virtual
    machines for that matter). This pattern consists of creating different layers
    that go from the raw data through to the data seen by a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9108de4-0f45-4c97-b35e-1a5fae26a05f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The idea is to separate the complexity of the different layers, each one not
    having to know how the others do their tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the data structures and storing them in a fast and secure way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating the data structures and adding business logic to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user requests and showing the data in a localised format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Service Locator** pattern is actually an anti-pattern. It''s not considered
    a good practice because it adds much more complexity to an ecosystem. The pattern
    consists of a central registry, called a **Service Locator**, where services register
    their abilities, and other services can consult the registry and know where the
    services they need are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8726196c-a92f-4b0c-a0f2-aed006649424.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Service Locator** is similar to the Front Controller, but with added complexity,
    as you need to contact the Service Locator and the service you need, instead of
    just making a simple request to a Front Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Observer pattern is used every day in Node.js. It consists of a **Subject**,
    which maintains a list of dependents, called Observers, which get notified of
    any state change happening on the **Subject**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0035ea4e-a748-478e-81cc-246dfedcf072.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see this happening every time in your web browser when some code (**Observer**)
    attaches an event listener to an object or interface element (**Subject**).
  prefs: []
  type: TYPE_NORMAL
- en: Publish-Subscribe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very similar pattern is the Publish-Subscribe pattern, usually abbreviated
    as **Pub-Sub**. This pattern is almost exactly the same as the previous one. You
    have Subscribers that, as the name implies, subscribe to a specific event, or
    topic, or whatever you want to call it, and then you have Publishers that emit
    those events or send information to those topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76f8596-5cfc-4d66-97ae-7bf57f0051ae.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference to the previous pattern may look very thin but is actually very
    important. The **Pub-Sub** pattern involves a third-party service and, unlike
    the Observer pattern, the Publishers have no knowledge of the Subscribers. This
    removes the need to handle and directly notify the Subscribers, thereby simplifying
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is quite useful for microservice communication. It involves a third
    party that abstracts the state change notification. Also, Publishers and Subscribers
    have no knowledge of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Using patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing good design patterns is essentially choosing best practices. Not all
    design patterns fit every purpose, but for many scenarios, they'll make your life
    easier. Perhaps you may not notice any difference in the beginning, but you should
    in the long-term.
  prefs: []
  type: TYPE_NORMAL
- en: Good design patterns also have indirect advantages. You'll find more documentation
    and examples online, as well as a broader set of options to choose from, for example,
    when using the Publish-Subscribe pattern, where you'll find many types of implementations
    to integrate with your services.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the pattern that fits your needs also involves planning and knowing
    what you need and what you'll need in the future. Think of the edge cases and
    see if the pattern is capable of handling them.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a microservice may look like a simple task. As the name implies,
    it is a micro service. But that is not necessarily true, as sometimes we tend
    to complexify something that should be simple.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean a service should be simple, it can be quite complex. What
    should be simple is the goal and the properties of the service. There shouldn't
    be any doubt regarding what it does and what it shouldn't do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing any line of code, you should start by knowing a couple of what
    I call characteristics of the service, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: What is it for? What tasks will it do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other services will use it? What protocol will it speak?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will it replace another service? Will it cover the same tasks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be summed in one word—purpose. If you don't clearly define its purpose
    and just start developing tasks it can handle, you'll end up having a mixed service
    that deviates from the main goal of a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: After having a proper purpose, you can then choose the best pattern and plan
    the individual tasks. The first task will probably take longer to develop, as
    you're creating the base layout for the service.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to add tests, coverage, and documentation as soon as possible.
    I know this is something most developers tend to ignore, but it will bite you
    later. It's easier to add a simple test for a first simple task. Code coverage
    is easier at this point. Adding documentation should also be easier if you're
    planning the individual tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having your first task, with a proper test, you should set your first
    deploy. This will end your first development cycle and bring you back to planning.
    If you keep this loop going, with small tasks, you''ll develop faster, and deploy
    faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8b06c25-bf65-4bf1-be50-7ba83cd2977f.png)'
  prefs: []
  type: TYPE_IMG
- en: This type of simple loop with small tasks will allow you to do what is called
    **continuous integration** and **continuous deployment**, where you're able to
    develop and deploy to a testing cluster. The change can be automatically tested
    and deployed if everything passes the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Obstacles when developing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw previously, a microservice architecture has many advantages, such
    as splitting code into smaller isolated projects, where it becomes easier to develop
    or even delegate responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: These advantages come at a cost, which is the build of a more complex system
    or application. Because of how microservices are supposed to work, an information
    barrier is intrinsic. A microservice responsible for a type of information should
    be the only one manipulating it, forcing any other service to communicate with
    it to have access to information.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a finer control over the information because you know the service
    responsible for it, and you can force service or user authentication, with authorization
    or even rate-access limits. But, this means that a complex application will tend
    to penalize the network as there will be significant inter-service messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-service messaging means network traffic and latency. If the services are
    not on the same local network, this will eventually create noticeable latency.
    Adding some kind of cache service to accelerate access will also add more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Although testing and development for each microservice should be easier than
    a monolith application, looking at the microservice test frameworks all together,
    and having two or more services test together, is more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, avoid something called a nanoservice. This is considered an anti-pattern,
    and it's when you exaggerate on fine-graining your architecture and create overly 
    small services, complexifying your development to the extreme.
  prefs: []
  type: TYPE_NORMAL
- en: Find a good balance between the number of microservices and what each will do.
    Think of them as a person that will handle a specific task. Is the task too simple
    to have one person allocated to do just that? Shouldn't the person have a broader
    set of tasks from the same context?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's applications have space for microservices. Applications are no longer
    monolith and left the traditional computer architecture long ago. Users constantly
    demand integrations and interoperability between applications.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices help developers to reduce the complexity of applications by separating
    different contexts, such as frontend, backend, mobile, or a simple API. They're
    a concept, or a pattern, that, when used well, can give you great power, and split
    complexity and responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: But, microservices are more than that. Microservices help you scale horizontally
    by just replicating the services you need and not a complete monolith application,
    saving resources and, ultimately, money.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot to explore out there; we have just scratched the surface. There
    are plenty of cloud providers and tools for you to experiment with and choose
    what fits you best. Remember, practice makes perfect, so head to your work desk,
    and good luck!
  prefs: []
  type: TYPE_NORMAL
