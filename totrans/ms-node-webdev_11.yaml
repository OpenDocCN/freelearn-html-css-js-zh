- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using HTML Templates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML模板
- en: In this chapter, I describe how templates are used to generate HTML content,
    allowing an application to adapt the content display to the user to reflect the
    request that is being processed or the application’s state data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我将描述模板如何用于生成HTML内容，使应用程序能够根据用户的需求或应用程序的状态数据来调整内容显示。
- en: Like many of the topics described in this book, templates are much easier to
    understand once you see how they work. Therefore, I will start by creating a simple
    custom template system using just the features provided by the JavaScript and
    Node.js APIs, just to explain how the pieces fit together. I will demonstrate
    *server-side templates*, where the backend server generates the HTML content,
    and *client-side templates*, where the browser generates the content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中描述的许多主题一样，一旦您了解了它们的工作原理，模板就更容易理解。因此，我将首先创建一个简单的自定义模板系统，仅使用JavaScript和Node.js
    API提供的功能，以解释各个部分是如何组合在一起的。我将演示*服务器端模板*，其中后端服务器生成HTML内容，以及*客户端模板*，其中浏览器生成内容。
- en: The custom templates in this chapter are educational but too limited for use
    in a real project, so I also introduce a popular template package that has many
    more features and much better performance, and which is suitable for use in a
    real project. *Table 10.1* puts HTML templates in context.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的自定义模板具有教育意义，但用于实际项目过于有限，因此我还介绍了一个具有更多功能和更好性能的流行模板包，它适合用于实际项目。*表10.1*将HTML模板置于上下文中。
- en: 'Table 10.1: Putting HTML templates in context'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1：将HTML模板置于上下文中
- en: '| Question | Answer |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | HTML templates are HTML documents that contain placeholders
    that are replaced with dynamic content to reflect the state of the application.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | HTML模板是包含占位符的HTML文档，这些占位符会被动态内容替换，以反映应用程序的状态。 |'
- en: '| Why are they useful? | Templates allow the content presented to the user
    to reflect changes in the application state and are a key building block in most
    web applications. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 它们为什么有用？ | 模板允许用户展示的内容反映应用程序状态的变化，并且是大多数网络应用程序的关键构建块。 |'
- en: '| How are they used? | There are many good template packages available and
    popular frameworks generally include a template system. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 它们是如何使用的？ | 有许多优秀的模板包可用，并且流行的框架通常包括模板系统。 |'
- en: '| Are there any pitfalls or limitations? | It is important to find a package
    with a format that you find easy to read, but otherwise, template engines are
    a positive addition to a web application project. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 存在哪些陷阱或限制？ | 重要的是找到一个您觉得易于阅读的格式，但除此之外，模板引擎是网络应用程序项目的积极补充。 |'
- en: '| Are there any alternatives? | You could generate content entirely using JavaScript
    code, but this tends to be difficult to maintain. You may not be able to avoid
    using templates if you are using a framework, such as React or Angular. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 您可以使用JavaScript代码完全生成内容，但这通常难以维护。如果您使用的是React或Angular等框架，可能无法避免使用模板。
    |'
- en: '*Table 10.2* summarizes the chapter.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*表10.2*总结了本章内容。'
- en: 'Table 10.2: Chapter summary'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2：章节总结
- en: '| Problem | Solution | Listing |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Dynamically render HTML elements | Use a template engine that mixes HTML
    elements and expressions that are evaluated to produce data values. | *1-4, 11-15,
    21-27* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 动态渲染HTML元素 | 使用混合HTML元素和表达式的模板引擎，这些表达式被评估以产生数据值。 | *1-4, 11-15, 21-27* |'
- en: '| Evaluate template expressions | Use the `eval` keyword to evaluate string
    expressions as JavaScript statements. | *5, 6* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 评估模板表达式 | 使用`eval`关键字将字符串表达式评估为JavaScript语句。 | *5, 6* |'
- en: '| Break up templates into more manageable content | Use partial templates/views.
    | *7-10* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 将模板拆分为更易于管理的部分 | 使用部分模板/视图。 | *7-10* |'
- en: '| Dynamically render HTML elements at the browser | Compile templates into
    JavaScript code that is included in the bundle loaded by the browser. | *16-20,
    28-31* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 在浏览器中动态渲染HTML元素 | 将模板编译成浏览器加载的包中包含的JavaScript代码。 | *16-20, 28-31* |'
- en: Preparing for this chapter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本章做准备
- en: This chapter uses the `part2app` project created in *Chapter 9*. No changes
    are required to prepare for this chapter. Open a command prompt and run the command
    shown in *Listing 10.1* in the `part2app` folder to start the development tools.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的是在第9章中创建的`part2app`项目。为此章节做准备不需要任何更改。打开命令提示符，在`part2app`文件夹中运行*列表10.1*中显示的命令以启动开发工具。
- en: '**Tip**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)下载本章的示例项目——以及本书中所有其他章节的示例项目。有关运行示例时遇到问题的帮助，请参阅*第1章*。
- en: 'Listing 10.1: Starting the development tools'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1：启动开发工具
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open a web browser, request `http://localhost:5000`, and click the **Send Request**
    button. The browser will send a request to the backend server and display details
    of the results, as shown in *Figure 10.1*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器，请求`http://localhost:5000`，然后点击**发送请求**按钮。浏览器将向后端服务器发送请求，并显示结果详情，如图*10.1*所示。
- en: '![](img/B21959_10_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_10_01.png)'
- en: 'Figure 10.1: Running the example application'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：运行示例应用程序
- en: Using server-side HTML templates
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端HTML模板
- en: Server-side HTML templates allow the backend server to dynamically generate
    content to send the browser content that is tailored to an individual request.
    Tailoring can take any form, but a typical example is to include content that
    is specific to the user, such as including the user’s name.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端HTML模板允许后端服务器动态生成内容，发送给浏览器的内容是根据单个请求定制的。定制可以采取任何形式，但一个典型的例子是包括特定于用户的内容，例如包括用户的姓名。
- en: 'Three things are required for an HTML template: a *template* file that has
    placeholder sections into which dynamic content will be inserted, a *data dictionary*
    or *context* that provides the values that will determine the specific dynamic
    content that will be generated, and a *template engine* that processes the view
    and the dictionary to produce an HTML document into which dynamic content has
    been inserted, and which can be used as a response to an HTTP request, as shown
    in *Figure 10.2*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板需要三个要素：一个包含占位符部分的*模板*文件，动态内容将被插入其中；一个*数据字典*或*上下文*，它提供了将决定特定动态内容生成的值；以及一个*模板引擎*，它处理视图和字典，生成一个包含已插入动态内容的HTML文档，该文档可以用作对HTTP请求的响应，如图*10.2*所示。
- en: '![](img/B21959_10_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_10_02.png)'
- en: 'Figure 10.2: The components of an HTML template'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：HTML模板的组成部分
- en: The task of processing a template is known as *rendering* and it occurs entirely
    in the backend server. Rendering produces a regular HTML document that, from the
    perspective of the browser, appears no different from regular static content.
    (There is a different kind of template that is sent to the browser as JavaScript,
    where it is rendered to create HTML content by the client, as described in the
    *Using client-side HTML templates* section).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理模板的任务被称为*渲染*，它完全发生在后端服务器上。渲染生成一个普通的HTML文档，从浏览器的角度来看，它与常规静态内容没有区别。（还有另一种类型的模板，它作为JavaScript发送到浏览器，由客户端渲染以创建HTML内容，如*使用客户端HTML模板*部分所述）。
- en: Creating a simple template engine
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的模板引擎
- en: It is easy to create a simple template engine to help understand how they work,
    although it is much harder to create one that is production ready. In this section,
    I’ll create something simple and then introduce an open-source template engine
    package that is better, faster, and has many more features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的模板引擎来帮助理解它们的工作原理很容易，但要创建一个可用于生产的模板引擎则要困难得多。在本节中，我将创建一个简单的模板，然后介绍一个更优秀、更快、功能更丰富的开源模板引擎包。
- en: I am going to start by creating the template, which will help put everything
    in context. Create the `part2app/templates/server` folder and add to it a file
    named `basic.custom` with the content shown in *Listing 10.2*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建模板，这将有助于将所有内容置于上下文中。创建`part2app/templates/server`文件夹，并向其中添加一个名为`basic.custom`的文件，其内容如图*列表10.2*所示。
- en: '**Tip**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Most code editors can be configured to understand that files with a non-standard
    extension, such as `.custom`, contain a well-known format, such as HTML. If you
    are using Visual Studio Code, for example, click on **Plain Text** in the bottom-right
    corner of the window and either choose the format for a single file or set up
    an association so that all `.custom` files are treated like HTML, which will make
    it easier to spot mistakes when following the examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码编辑器都可以配置为理解具有非标准扩展名（如 `.custom`）的文件包含一个已知的格式，例如 HTML。例如，如果你使用 Visual Studio
    Code，请在窗口的右下角点击 **纯文本**，然后选择单个文件的格式或设置关联，以便所有 `.custom` 文件都像 HTML 一样处理，这将使在遵循示例时更容易发现错误。
- en: 'Listing 10.2: The contents of the basic.custom file in the templates/server
    folder'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.2：templates/server 文件夹中 basic.custom 文件的内容
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This template is a complete HTML document with one placeholder, which is denoted
    by the double curly braces (the `{{` and `}}` characters). The content inside
    of the braces is a *template expression* that will be evaluated when the template
    is rendered and used to replace the placeholder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板是一个完整的 HTML 文档，包含一个占位符，该占位符由双大括号（`{{` 和 `}}` 字符）表示。大括号内的内容是一个 *模板表达式*，当模板渲染时将被评估，并用于替换占位符。
- en: Not all template engines use the `{{` and `}}` characters, although that is
    a popular choice, and what is important is that the character sequence that denotes
    a placeholder is unlikely to occur in the static parts of the template, which
    is why you will usually see sequences of repeating characters, or unusual characters,
    used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然双大括号 `{{` 和 `}}` 字符是一个流行的选择，但并非所有模板引擎都使用这些字符，重要的是表示占位符的字符序列不太可能出现在模板的静态部分中，这就是为什么你通常会看到重复字符序列或特殊字符的使用。
- en: Creating the custom template engine
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义模板引擎
- en: The Express package has integrated support for template engines, which makes
    it easy to experiment and learn how they work. Add a file named `custom_engine.ts`
    to the `src/server` folder with the content shown in *Listing 10.3*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Express 包集成了对模板引擎的支持，这使得实验和学习它们的工作方式变得容易。将一个名为 `custom_engine.ts` 的文件添加到 `src/server`
    文件夹中，其内容如图 *清单 10.3* 所示。
- en: 'Listing 10.3: The contents of the custom_engine.ts file in the src/server folder'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.3：src/server 文件夹中 custom_engine.ts 文件的内容
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `renderTemplate` function will be called by Express to render a template.
    The parameters are a `string` that contains the template file path, an `object`
    that provides context data for rendering the template, and a callback function
    used to provide Express with the rendered content or an error if something goes
    wrong.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderTemplate` 函数将由 Express 调用来渲染模板。参数是一个包含模板文件路径的 `string`，一个提供模板渲染上下文数据的
    `object`，以及一个回调函数，用于向 Express 提供渲染内容或错误（如果发生错误）。'
- en: 'The `renderTemplate` function uses the `readFile` function to read the contents
    of the template file and then invokes the `parseTemplate` function, which uses
    a regular expression to search for the `{{` and `}}` characters. For each match,
    a callback function inserts a data value from the context object in the result,
    like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderTemplate` 函数使用 `readFile` 函数读取模板文件的内容，然后调用 `parseTemplate` 函数，该函数使用正则表达式搜索
    `{{` 和 `}}` 字符。对于每个匹配项，回调函数将上下文对象中的数据值插入到结果中，如下所示：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a rudimentary approach, and real engines are more complex and take
    greater care to find template expressions, but this is enough to demonstrate the
    idea. The `registerCustomTemplateEngine` function registers the template engine
    with Express, which is done by calling the `Express.engine` method, specifying
    the file extension and the `renderTemplate` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的方法，而真正的引擎更复杂，并且更仔细地寻找模板表达式，但这足以演示这个想法。`registerCustomTemplateEngine`
    函数通过调用 `Express.engine` 方法将模板引擎注册到 Express 中，指定文件扩展名和 `renderTemplate` 函数：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This statement tells Express to use the `renderTemplate` function to render
    template files that have a `.custom` file extension.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句告诉 Express 使用 `renderTemplate` 函数来渲染具有 `.custom` 文件扩展名的模板文件。
- en: Setting up the custom template engine
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置自定义模板引擎
- en: The final part of the process is to configure Express and create a route that
    matches requests that will be handled with a template, as shown in *Listing 10.4*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 流程的最后部分是配置 Express 并创建一个与模板匹配的路线，如图 *清单 10.4* 所示。
- en: 'Listing 10.4: Setting up the template engine in the server.ts file in the src/server
    folder'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.4：在 src/server 文件夹中的 server.ts 文件中设置模板引擎
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Calling the `registerCustomTemplateEngine` defined in *Listing 10.4* sets up
    the custom template engine. By default, Express looks for template files in the
    `views` folder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*列表10.4*中定义的`registerCustomTemplateEngine`设置自定义模板引擎。默认情况下，Express在`views`文件夹中查找模板文件。
- en: '*Views* and *view engines* are alternate names for templates and template engines,
    but to keep the terminology consistent, I used the `ExpressApp.set` method to
    change the template file location:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图*和*视图引擎*是模板和模板引擎的别名，但为了保持术语的一致性，我使用了`ExpressApp.set`方法来更改模板文件的位置：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete set of Express configuration properties can be found at [https://expressjs.com/en/4x/api.html#app.set](https://expressjs.com/en/4x/api.html#app.set)
    and the `views` property is used to specify the directory that contains template
    files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Express配置属性的完整集合可以在[https://expressjs.com/en/4x/api.html#app.set](https://expressjs.com/en/4x/api.html#app.set)找到，而`views`属性用于指定包含模板文件的目录。
- en: 'The Express router is used to match requests that will be handled by templates,
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Express路由器用于匹配将由模板处理的请求，如下所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `get` method creates a route that matches paths that start with `/dynamic`
    and captures the next path segment to a route parameter named `file`. The request
    handler invokes the `Response.render` method, which is responsible for rendering
    a template. The `file` route parameter is used to create the first argument to
    the render method, which is the name of the template file. The second argument
    is an object that provides the template engine with context data to help it generate
    content. In this example, the context object defines a `message` property, whose
    value will be included in the rendered output.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法创建一个匹配以`/dynamic`开头的路径的路由，并将下一个路径段捕获到名为`file`的路由参数中。请求处理器调用`Response.render`方法，该方法负责渲染模板。`file`路由参数用于创建渲染方法的第一个参数，即模板文件的名称。第二个参数是一个对象，为模板引擎提供上下文数据，以帮助它生成内容。在这个例子中，上下文对象定义了一个`message`属性，其值将包含在渲染输出中。'
- en: To test the custom template engine, use a browser to request `http://localhost:5000/dynamic/basic`.
    The `dynamic` part of the URL will be matched by the new Express route, and the
    `basic` part corresponds to the `basic.custom` file in the templates folder. The
    custom view engine will process the template file and the results will be written
    to the response, as shown in *Figure 10.3*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试自定义模板引擎，请使用浏览器请求`http://localhost:5000/dynamic/basic`。URL中的`dynamic`部分将与新的Express路由匹配，而`basic`部分对应于模板文件夹中的`basic.custom`文件。自定义视图引擎将处理模板文件，并将结果写入响应，如图*10.3*所示。
- en: '![](img/B21959_10_03.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_10_03.png)'
- en: 'Figure 10.3: Using a custom template engine'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：使用自定义模板引擎
- en: Evaluating expressions in templates
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中评估表达式
- en: Inserting data values into templates is a good start, but most template engines
    have support for evaluating fragments of JavaScript code and inserting the results
    into the output. *Listing 10.5* adds some template expressions to the template.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据值插入模板是一个好的开始，但大多数模板引擎都支持评估JavaScript代码片段并将结果插入输出中。*列表10.5*向模板添加了一些模板表达式。
- en: 'Listing 10.5: Adding expressions to the basic.custom file in the templates/server
    folder'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5：在templates/server文件夹中的basic.custom文件中添加表达式
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10.6* adds support for evaluating expressions to the template engine,
    using the JavaScript `eval` function.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10.6*通过使用JavaScript的`eval`函数为模板引擎添加了对评估表达式的支持。'
- en: '**Caution**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The JavaScript `eval` function is dangerous, especially if there is the possibility
    that it might be used with content or data provided by users because it can be
    used to execute any JavaScript code. This alone is enough reason to use a well-tested
    template engine package, such as the one introduced in the Using a template package
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`eval`函数很危险，尤其是如果有可能与用户提供的内容或数据一起使用，因为它可以用来执行任何JavaScript代码。这本身就是一个使用经过良好测试的模板引擎包（如在使用模板包部分介绍的那个）的充分理由。
- en: 'Listing 10.6: Evaluating expressions in the custom_engine.ts file in the src/server
    folder'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6：在src/server文件夹中的custom_engine.ts文件中评估表达式
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The difficulty of using `eval` is making sure that context data is available
    as local variables when evaluating an expression. To make sure that the context
    data is in scope, I create a string for each property of the context object and
    combine those strings with the expression to be evaluated, like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`eval`的困难之处在于确保在评估表达式时上下文数据作为局部变量可用。为了确保上下文数据在作用域内，我为上下文对象的每个属性创建一个字符串，并将这些字符串与要评估的表达式组合起来，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach ensures that there is a `message` value for the expression to
    use, for example. There are some serious dangers in using `eval` but it is fine
    for the example application, although it bears repeating to say a real template
    package should be used in real projects, especially when dealing with user-supplied
    data. Use a browser window to request `http://localhost:5000/dynamic/basic` and
    you will see the results shown in *Figure 10.4*. (The browser won’t reload automatically,
    so you will either have to make a new request or reload the browser).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保表达式有一个`message`值可以使用，例如。使用`eval`有一些严重的风险，但对于示例应用程序来说是可以的，尽管需要重复的是，在实际项目中，尤其是在处理用户提供的资料时，应该使用真正的模板包。使用浏览器窗口请求`http://localhost:5000/dynamic/basic`，你将看到*图10.4*中显示的结果。（浏览器不会自动重新加载，所以你可能需要发出新的请求或重新加载浏览器）。
- en: '![](img/B21959_10_04.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_10_04.png)'
- en: 'Figure 10.4: Evaluating JavaScript expressions in a template'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：在模板中评估JavaScript表达式
- en: Adding template features
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加模板功能
- en: The ability to evaluate expressions provides a foundation for creating additional
    features, which can be easily written as JavaScript functions and added to the
    context used to parse the template. Add a file named `custom_features.ts` to the
    `src/server` folder with the content shown in *Listing 10.7*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式的功能为创建附加功能提供了一个基础，这些功能可以轻松地编写为JavaScript函数并添加到解析模板时使用的上下文中。将名为`custom_features.ts`的文件添加到`src/server`文件夹中，其内容如*列表10.7*所示。
- en: '**Compiling templates**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译模板**'
- en: Most real template engines compile their templates, which means that templates
    are converted into a series of JavaScript functions that can be invoked to generate
    content. This doesn’t change the content that is generated but it can improve
    performance because output can be created without needing to read and search the
    template file. Client-side templates are also compiled so that the JavaScript
    functions can be presented to the browser. You can see an example of this process
    in the *Using a template package* section, later in the chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数真实的模板引擎都会编译它们的模板，这意味着模板会被转换成一系列可以调用来生成内容的JavaScript函数。这不会改变生成的内容，但它可以提高性能，因为输出可以在不需要读取和搜索模板文件的情况下创建。客户端模板也会被编译，以便JavaScript函数可以呈现给浏览器。你可以在本章后面的*使用模板包*部分看到一个此过程的示例。
- en: 'Listing 10.7: The contents of the custom_features.ts file in the src/server
    folder'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7：src/server文件夹中custom_features.ts文件的内容
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This file defines a `style` function that accepts a stylesheet name and returns
    a `link` element. The `partial` function reads another template file and returns
    its content for inclusion in the overall content. The `partial` function receives
    a context object, which it uses to locate the requested file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了一个接受样式表名称并返回一个`link`元素的`style`函数。`partial`函数读取另一个模板文件，并返回其内容以包含在整体内容中。`partial`函数接收一个上下文对象，它使用该对象来定位请求的文件：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The context object that Express provides to the template engine has a `settings`
    property, which returns an object that contains the application’s configuration.
    One of the settings properties is `views`, which returns the location of the template
    files (the `templates/server` folder). *Listing 10.8* revises the template to
    use these new features.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供的上下文对象传递给模板引擎，它有一个`settings`属性，该属性返回一个包含应用程序配置的对象。其中设置属性之一是`views`，它返回模板文件的位置（`templates/server`文件夹）。*列表10.8*修改了模板以使用这些新功能。
- en: '**Note**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `partial` function in *Listing 10.7* performs a blocking operation to read
    the contents of the file. As explained in *Chapter 4*, this is something that
    should be avoided as much as possible, and I have used the `readFileSync` function
    only for the sake of simplicity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10.7*中的`partial`函数执行一个阻塞操作来读取文件内容。正如*第4章*中解释的，这是应该尽可能避免的事情，我仅为了简单起见使用了`readFileSync`函数。'
- en: 'Listing 10.8: Using template features in the basic.custom file in the templates/server
    folder'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8：在templates/server文件夹中的basic.custom文件中使用模板功能
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new features are accessed with a `@` prefix, which makes them easy to find
    when parsing templates. In *Listing 10.8*, the `@style` expression will invoke
    the `style` function to create a `link` element for the Bootstrap CSS file, and
    the `@partial` expression will invoke the `partial` function to load a template
    named `message`. To create the template – known as a *partial template* – that
    will be loaded by the `@partial` expression, create a file named `message.custom`
    in the `templates/server` folder with the content shown in *Listing 10.9*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能使用`@`前缀访问，这使得在解析模板时很容易找到它们。在*列表 10.8*中，`@style`表达式将调用`style`函数来创建 Bootstrap
    CSS 文件的`link`元素，而`@partial`表达式将调用`partial`函数来加载名为`message`的模板。为了创建将由`@partial`表达式加载的模板——称为*部分模板*——在`templates/server`文件夹中创建一个名为`message.custom`的文件，其内容如*列表
    10.9*所示。
- en: 'Listing 10.9: The contents of the message.custom in the templates/server folder'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9：在 templates/server 文件夹中的 message.custom 的内容
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mapping expressions to features
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将表达式映射到功能
- en: 'All that remains is translating the `@` expressions in the template to JavaScript
    statements that invoke the functions from *Listing 10.7*. Take the following expression:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是将模板中的`@`表达式转换为调用*列表 10.7*中函数的 JavaScript 语句。以下是一个表达式示例：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding expression will be translated into the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将被翻译成以下内容：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the translation is complete, the result can be evaluated just like any
    other expression. *Listing 10.10* changes the template engine to support the new
    features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦翻译完成，结果可以像任何其他表达式一样进行评估。*列表 10.10*将模板引擎更改为支持新功能。
- en: 'Listing 10.10: Supporting template features in the custom_engine.ts file in
    the src/server folder'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10：在 src/server 文件夹中的 custom_engine.ts 文件中支持模板功能
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The functions defined in *Listing 10.7* are imported and assigned the `features`
    prefix. String manipulation performs the translation from the `@` expression to
    the function name, with the addition of the `context` property and an `eval` function.
    This allows expressions to access the context object, the settings it includes,
    and the ability to evaluate expressions with the context. The result from a `@`
    feature may contain other template expressions; therefore, the regular expression
    is used to recursively parse the result.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*列表 10.7*中定义的函数被导入并赋予`features`前缀。字符串操作将`@`表达式转换为函数名，并添加`context`属性和`eval`函数。这允许表达式访问上下文对象、它包含的设置以及使用上下文评估表达式的功能。`@`特征的结果可能包含其他模板表达式；因此，使用正则表达式递归解析结果。
- en: Use a browser to request `http://localhost:5000/dynamic/basic` and you will
    see the output produced by the new features, as shown in *Figure 10.5*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000/dynamic/basic`，你将看到新功能产生的输出，如*图 10.5*所示。
- en: '![](img/B21959_10_05.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_10_05.png)'
- en: 'Figure 10.5: Adding template features'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：添加模板功能
- en: Using templates to create a simple round-trip application
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板创建简单的往返应用
- en: The template engine is simple, but it has just enough functionality to create
    a basic application that alters the HTML it displays based on user interaction,
    which is the key function of any web application. To demonstrate, I am going to
    present the user with a button that increments a counter, where the value of the
    counter will result in different content being presented to the user. This is
    an example of a *round-trip application*, where each interaction requires an HTTP
    request to the server to get a new HTML document to display to the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎很简单，但它恰好有足够的功能来创建一个基本的应用程序，根据用户交互改变显示的 HTML，这是任何网络应用的关键功能。为了演示，我将向用户展示一个按钮，该按钮增加计数器的值，计数器的值将导致向用户展示不同的内容。这是一个*往返应用*的例子，其中每次交互都需要向服务器发送
    HTTP 请求以获取新的 HTML 文档来显示给用户。
- en: The first step is to add the object that represents the HTTP request to the
    context data given to the custom template engine, as shown in *Listing 10.11*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将表示 HTTP 请求的对象添加到自定义模板引擎提供的上下文数据中，如*列表 10.11*所示。
- en: 'Listing 10.11: Adding to the context data in the server.ts file in the src/server
    folder'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11：在 src/server 文件夹中的 server.ts 文件中添加上下文数据
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, add a file named `counter.custom` to the `templates/server` folder with
    the content shown in *Listing 10.12*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个名为`counter.custom`的文件添加到`templates/server`文件夹中，其内容如*列表 10.12*所示。
- en: 'Listing 10.12: The contents of the counter.custom file in the templates/server
    folder'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12：在 templates/server 文件夹中的 counter.custom 文件的内容
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This template contains an anchor element (the `a` tag) that, when clicked, requests
    a new HTML document from the backend server using a URL that contains a query
    string parameter named `c`. The value of `c` included in the request URL is always
    one more than the value displayed to the user, such that clicking the button has
    the effect of incrementing the counter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含一个锚点元素（`a`标签），当点击时，会使用包含名为`c`的查询字符串参数的URL从后端服务器请求新的HTML文档。请求URL中包含的`c`的值总是比显示给用户的值多1，因此点击按钮的效果是增加计数器。
- en: The template contains a `@conditional` expression, which will be used to render
    different partial templates for odd and even values of `c`. The arguments to `@conditional`
    are an expression to be evaluated and two partial template names that will be
    used for `true` and `false` results when the expression is evaluated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包含一个`@conditional`表达式，该表达式将被用来渲染`c`的奇偶值对应的不同的部分模板。`@conditional`的参数是一个要评估的表达式和两个部分模板名称，当表达式评估时，将用于`true`和`false`结果。
- en: To create the partial template that will be used for odd values, add a file
    named `odd.custom` to the `templates/server` folder with the content shown in
    *Listing 10.13*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用于奇数值的部分模板，请将名为`odd.custom`的文件添加到`templates/server`文件夹中，其内容如*列表10.13*所示。
- en: 'Listing 10.13: The content of the odd.custom file in the templates/server folder'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13：templates/server文件夹中odd.custom文件的内容
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To create the partial template that will be used for even values, add a file
    named `even.custom` to the `templates/server` folder with the content shown in
    *Listing 10.14*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用于偶数值的部分模板，请将名为`even.custom`的文件添加到`templates/server`文件夹中，其内容如*列表10.14*所示。
- en: 'Listing 10.14: The contents of the even.custom file in the templates/server
    folder'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.14：templates/server文件夹中even.custom文件的内容
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The remaining step is to implement the `@conditional` expression as a template
    feature, as shown in *Listing 10.15*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的步骤是实现`@conditional`表达式作为模板功能，如*列表10.15*所示。
- en: 'Listing 10.15: Adding a conditional feature in the custom_features.ts file
    in the src/server folder'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.15：在src/server文件夹中的custom_features.ts文件中添加条件功能
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `conditional` function accepts an expression, two file paths, a context
    object, and a function used to evaluate expressions. The expression is evaluated,
    and the result is passed to the `partial` function, effectively selecting a partial
    view based on whether the expression has evaluated to `true` or `false`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditional`函数接受一个表达式、两个文件路径、一个上下文对象和一个用于评估表达式的函数。表达式被评估，结果传递给`partial`函数，有效地根据表达式是否评估为`true`或`false`选择部分视图。'
- en: Use a browser to request `http://localhost:5000/dynamic/counter` and click the
    **Increment** button. Each click causes the browser to request a URL like `http://localhost:5000/dynamic/counter?c=1`
    and the value of `c` is used to select the HTML content in the response, as shown
    in *Figure 10.6*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000/dynamic/counter`并点击**增加**按钮。每次点击都会导致浏览器请求一个类似`http://localhost:5000/dynamic/counter?c=1`的URL，`c`的值用于选择响应中的HTML内容，如图*图10.6*所示。
- en: '![](img/Image10809.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image10809.png)'
- en: 'Figure 10.6: Using templates to create a simple round-trip application'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：使用模板创建简单的往返应用
- en: Using client-side HTML templates
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端HTML模板
- en: One drawback of the previous example is that a completely new HTML document
    is generated and sent to the browser every time `Increment` is clicked, even though
    only one section of the HTML changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的一个缺点是，每次点击“增加”时，都会生成并发送一个新的HTML文档到浏览器，即使只有HTML的一个部分发生了变化。
- en: '*Client-side HTML templates* perform the same task as their server-side counterparts,
    but the template is parsed by JavaScript code running in the browser. This allows
    a targeted approach, where selected elements are modified, which can be more responsive
    than waiting for a new HTML document. This is the basis for **single-page applications**
    (**SPAs**), where a single HTML document is delivered to the client and then modified
    by JavaScript code.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端HTML模板*执行与它们的服务器端对应模板相同的任务，但模板由在浏览器中运行的JavaScript代码解析。这允许一种有针对性的方法，即修改选定的元素，这比等待新的HTML文档更具有响应性。这是**单页应用**（**SPAs**）的基础，其中向客户端发送单个HTML文档，然后由JavaScript代码进行修改。'
- en: The main difficulty with client-side templates is that they have to be written
    entirely in JavaScript, which can make it awkward to express HTML content in a
    way that is easy to read and maintain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端模板的主要困难在于它们必须完全用JavaScript编写，这可能会使以易于阅读和维护的方式表达HTML内容变得尴尬。
- en: The most popular client-side frameworks, such as React and Angular, use client-side
    template formats that are easier to read than pure JavaScript, but they use a
    compiler to transform the template into a JavaScript function so that it can be
    added to the JavaScript bundle given to the browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的客户端框架，如React和Angular，使用比纯JavaScript更容易阅读的客户端模板格式，但它们使用编译器将模板转换为JavaScript函数，以便将其添加到浏览器接收的JavaScript包中。
- en: The templates used by the big frameworks have other benefits, such as making
    it easy to combine templates to create complex content and ensuring that updates
    to HTML elements are performed as efficiently as possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大型框架使用的模板具有其他好处，例如，使组合模板以创建复杂内容变得容易，并确保HTML元素的更新尽可能高效。
- en: But, leaving aside these features, the process of generating content at the
    client is similar to doing so at the server. A good way to understand the issues
    involved in client-side templating is to recreate the counter example from the
    previous section using client-side JavaScript. To start, add a file named `counter_custom.js`
    to the `src/client` folder with the content shown in *Listing 10.16*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，抛开这些特性不谈，客户端生成内容的过程与服务器端生成内容的过程相似。了解客户端模板涉及的问题的一个好方法是使用客户端JavaScript重新创建上一节中的反例。首先，将一个名为`counter_custom.js`的文件添加到`src/client`文件夹中，其内容如*清单10.16*所示。
- en: '**Client-side versus server-side templates**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端与服务器端模板**'
- en: Most web application projects tend to mix both server-side and client-side templates
    because each type of template solves a different problem.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序项目倾向于混合使用服务器端和客户端模板，因为每种类型的模板都解决不同的问题。
- en: Server-side templates require an HTTP connection for every HTML document, which
    can impact performance. However, the performance deficit can be offset by how
    fast the browser can display the contents of the HTML document once it has been
    received.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端模板需要为每个HTML文档建立HTTP连接，这可能会影响性能。然而，这种性能损失可以通过浏览器接收HTML文档内容后显示速度的快慢来抵消。
- en: Client-side templates respond to changes more efficiently and without the need
    to make additional HTTP requests, but this advantage can be undermined by the
    need to transfer the JavaScript code and the state data in the first place. When
    a framework like React or Angular is used, the JavaScript for the framework must
    also be transferred, and this can be a barrier in regions where less capable devices
    and unreliable networks are common.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端模板对变化的响应更高效，且无需进行额外的HTTP请求，但这种优势可能会因为最初需要传输JavaScript代码和状态数据而被削弱。当使用React或Angular等框架时，框架的JavaScript也必须传输，这可能在设备能力较弱和网络不可靠的地区成为障碍。
- en: To bridge the gap and give the best of both worlds, some frameworks offer **server-side
    rendering** (**SSR**), where templates are rendered at the server to create a
    round-trip version of the application, which can be displayed quickly by the browser.
    Once the server-rendered content is displayed, the browser requests JavaScript
    code and transitions to a single-page application. SSR has improved in recent
    years, but it is still clunky and doesn’t suit all projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥合差距，提供两者的最佳特性，一些框架提供了**服务器端渲染**（**SSR**）功能，其中模板在服务器上渲染以创建一个往返版本的应用程序，该版本可以由浏览器快速显示。一旦服务器渲染的内容显示出来，浏览器请求JavaScript代码，并过渡到单页应用程序。SSR在近年来有所改进，但仍然笨拙，并不适合所有项目。
- en: 'Listing 10.16: The contents of the counter_custom.js file in the src/client
    folder'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10.16：`src/client`文件夹中`counter_custom.js`文件的内容
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The templates in this example are JavaScript functions that return HTML strings,
    which is the simplest way to create a client-side template and it doesn’t require
    a compiler. The JavaScript template functions will receive a `context` parameter
    that contains the current application state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的模板是返回HTML字符串的JavaScript函数，这是创建客户端模板的最简单方式，并且不需要编译器。JavaScript模板函数将接收一个`context`参数，该参数包含当前应用程序状态。
- en: The JavaScript string features make it easy to insert data values into HTML
    strings. In this case, the value of the `counter` property on the `context` object
    received by the function is used to choose between the `Odd` and `Even` functions,
    which is a simpler approach than the equivalent functionality in the server-side
    template example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript字符串功能使得将数据值插入HTML字符串变得容易。在这种情况下，函数接收到的`context`对象上`counter`属性的值用于在`Odd`和`Even`函数之间进行选择，这比服务器端模板示例中的等效功能更简单。
- en: One problem with this approach is that handling events from elements can be
    difficult. Not only does the example application’s content security policy prevent
    inline event handlers, but it can be difficult to define handler functions that
    use context data in HTML strings.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是处理元素事件可能很困难。不仅示例应用程序的内容安全策略阻止了内联事件处理器，而且定义使用HTML字符串中的上下文数据的处理函数可能也很困难。
- en: To work around this limitation, I have added an `action` attribute to the `button`
    element in *Listing 10.16*, which is assigned the value `incrementCounter`. Events
    from the button will be allowed to propagate up the HTML document and I’ll use
    the value of the `action` attribute to decide how to respond.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我在*10.16*列表中的`button`元素上添加了一个`action`属性，其值为`incrementCounter`。按钮的事件将被允许在HTML文档中向上传播，我将使用`action`属性的值来决定如何响应。
- en: To create the partial view that will display even values, add a file named `even_custom.js`
    to the `src/client` folder with the content shown in *Listing 10.17*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建显示偶数值的局部视图，将名为`even_custom.js`的文件添加到`src/client`文件夹中，其内容如*10.17*列表所示。
- en: 'Listing 10.17: The contents of the even_custom.js file in the src/client folder'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.17：src/client文件夹中even_custom.js文件的内容
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The HTML string returned by this function includes the value of the `counter.couter`
    property. To create the template for odd values, create a file named `odd_custom.js`
    in the `src/client` folder with the content shown in *Listing 10.18*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回的HTML字符串包括`counter.couter`属性的值。要创建奇数值的模板，在`src/client`文件夹中创建一个名为`odd_custom.js`的文件，其内容如*列表10.18*所示。
- en: 'Listing 10.18: The contents of the odd_custom.js file in the src/client folder'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.18：src/client文件夹中odd_custom.js文件的内容
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10.19* replaces the code in the `client.js` file to use the new template
    functions and define the features they require.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10.19*替换了`client.js`文件中的代码，以使用新的模板函数并定义它们所需的功能。'
- en: 'Listing 10.19: Replacing the contents of the client.js file in the src/client
    folder'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.19：src/client文件夹中client.js文件的内容替换
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the `DOMContentLoaded` event is emitted, which indicates the browser has
    finished parsing the HTML document, an event listener is created for `click` events,
    and the `render` function is invoked.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当`DOMContentLoaded`事件被触发，这表示浏览器已经完成了解析HTML文档时，会创建一个用于`click`事件的监听器，并调用`render`函数。
- en: The `render` function invokes the `Counter` template function and uses the HTML
    string it receives to set the content of an HTML element whose `id` is `target`.
    When a `click` event is received, the target for the event is checked for an `action`
    attribute, and its value is used to select a function to execute from the `actions`
    object. There is one action in the example, which increments the `counter` property
    of the `context` object and calls the `render` function to update the content
    presented to the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数调用`Counter`模板函数，并使用它接收到的HTML字符串来设置一个`id`为`target`的HTML元素的内容。当接收到`click`事件时，会检查事件的目标是否有`action`属性，并使用其值从`actions`对象中选择一个要执行的功能。示例中有一个动作，它增加`context`对象的`counter`属性，并调用`render`函数来更新向用户展示的内容。'
- en: The final step is to remove the existing content from the static HTML document
    and create the element that will be populated with the client-side template content,
    as shown in *Listing 10.20*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一步是从静态HTML文档中移除现有内容，并创建一个将用客户端模板内容填充的元素，如图*10.20*所示。
- en: 'Listing 10.20: Preparing the HTML document in the index.html file in the static
    folder'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.20：static文件夹中index.html文件中的HTML文档准备
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use a browser to request `http://localhost:5000` and you will be presented with
    the same content produced by the server-side templates. The difference is that
    when the **Increment** button is clicked, the state change is handled by rendering
    the client-side templates, as shown in *Figure 10.7*, without the need to request
    a new HTML document from the backend server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000`，你将看到由服务器端模板生成的相同内容。不同之处在于，当点击**增量**按钮时，状态变化由渲染客户端模板处理，如图*10.7*所示，无需从后端服务器请求新的HTML文档。
- en: '![](img/Image10818.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image10818.png)'
- en: 'Figure 10.7: Using simple client-side templates'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：使用简单的客户端模板
- en: Using a template package
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板包
- en: The examples so far in this chapter have demonstrated how templates can be used
    to render content and show how some basic features can be easily created. For
    real projects, it makes more sense to adopt one of the excellent template packages
    available for JavaScript. Run the commands shown in *Listing 10.21* in the `part2app`
    folder to install one of the most widely used template packages, which is named
    Handlebars, and a package that integrates it into Express.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止的示例已经展示了如何使用模板来渲染内容，并展示了如何轻松创建一些基本功能。对于实际项目，采用 JavaScript 可用的优秀模板包中的一种更为合理。在
    `part2app` 文件夹中运行 *清单 10.21* 中显示的命令，以安装最广泛使用的模板包之一，名为 Handlebars，以及一个将其集成到 Express
    中的包。
- en: 'Listing 10.21: Installing a template package'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.21：安装模板包
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are many template packages available, and they all offer similar features.
    The main difference between packages is the way that templates are written and
    how expressions are denoted. The `{{` and `}}` characters are a common way to
    denote expressions, and they are known as mustache templates because the curly
    braces are reminiscent of a mustache. The `Handlebars` package ([https://handlebarsjs.com](https://handlebarsjs.com))
    uses this style of expression, as its name suggests. This is the style of JavaScript
    template I am used to, and familiarity goes a long way when picking a template
    package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多模板包可供选择，它们都提供了类似的功能。包之间主要的不同在于模板的编写方式和表达式的表示方式。`{{` 和 `}}` 字符是一个表示表达式的常见方式，并且因为它们的括号形状像胡子，所以被称为
    mustache 模板。`Handlebars` 包 ([https://handlebarsjs.com](https://handlebarsjs.com))
    使用这种表达方式，正如其名称所暗示的那样。这是我习惯的 JavaScript 模板风格，当选择模板包时，熟悉度有很大的帮助。
- en: '**Note**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: There are other options if you don’t like the mustache-style templates. The
    Pug package ([https://pugjs.org](https://pugjs.org)) relies on indentation to
    structure templates, which is a popular choice, and the **Embedded JavaScript**
    (**EJS**) ([https://ejs.co](https://ejs.co)) package uses `<%` and `%>` sequences.
    Stylistic preferences aside, all of these packages are well-written and have good
    levels of support.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢 mustache 风格的模板，还有其他选择。Pug 包 ([https://pugjs.org](https://pugjs.org))
    依赖于缩进来结构化模板，这是一个流行的选择，而 **嵌入式 JavaScript** (**EJS**) ([https://ejs.co](https://ejs.co))
    包使用 `<%` 和 `%>` 序列。不考虑风格偏好，所有这些包都编写得很好，并且有良好的支持水平。
- en: Using a package for server-side templates
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务器端模板包
- en: Handlebars templates are *logic free*, which means they cannot contain fragments
    of JavaScript that are evaluated to produce content. Instead, helper functions
    are defined to implement the logic required to generate content. Add a file named
    `template_helpers.ts` to the `src/server` folder with the content shown in *Listing
    10.22*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板是*无逻辑的*，这意味着它们不能包含用于生成内容的 JavaScript 片段。相反，定义辅助函数来实现生成内容所需的逻辑。将一个名为
    `template_helpers.ts` 的文件添加到 `src/server` 文件夹中，其内容如 *清单 10.22* 所示。
- en: 'Listing 10.22: The contents of the template_helpers.ts file in the src/server
    folder'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.22：`src/server` 文件夹中 template_helpers.ts 文件的内容
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `style` function accepts the name of a stylesheet and generates a link element
    for it. The `valueOrZero` function checks to see whether a value is defined and,
    if it is not, returns zero. The `increment` function increments a value. The `isOdd`
    function returns `true` if a value is odd.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 函数接受样式表的名称并为其生成一个链接元素。`valueOrZero` 函数检查一个值是否已定义，如果没有，则返回零。`increment`
    函数增加一个值。`isOdd` 函数如果值是奇数则返回 `true`。'
- en: Defining the templates
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义模板
- en: The package that integrates Handlebars into Express supports *layouts*, which
    are templates that contain the common elements that would otherwise be repeated
    in every template. Create the `templates/server/layouts` folder and add to it
    a file named `main.handlebars` with the content shown in *Listing 10.23*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 集成 Handlebars 到 Express 的包支持 *布局*，这些布局包含在模板中通常会被重复的公共元素。创建 `templates/server/layouts`
    文件夹，并向其中添加一个名为 `main.handlebars` 的文件，其内容如 *清单 10.23* 所示。
- en: 'Listing 10.23: The contents of the main.handlebars file in the templates/server/layouts
    folder'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.23：`templates/server/layouts` 文件夹中 main.handlebars 文件的内容
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are two expressions in this layout. The first invokes the `style` helper
    function defined in *Listing 10.22*, using the `bootstrap.min.css` string as an
    argument (arguments for helpers are separated by spaces and not parentheses).
    The other expression is `body`, into which the contents template that has been
    requested is inserted.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此布局中有两个表达式。第一个调用在 *清单 10.22* 中定义的 `style` 辅助函数，使用 `bootstrap.min.css` 字符串作为参数（辅助函数的参数由空格分隔，而不是括号）。另一个表达式是
    `body`，其中插入已请求的内容模板。
- en: The expressions in the layout are denoted with triple curly braces (`{{{` and
    `}}}`), which tells Handlebars that the results should be inserted into the template
    without being escaped for HTML safety. Care must be taken when dealing with data
    that has been received from users, and most template engines automatically format
    content so that it won’t be interpreted as HTML by the browser. A sequence of
    three curly braces tells Handlebars that the result should be passed on without
    formatting, which is required when an expression is producing HTML.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 布局中的表达式用三个大括号（`{{{` 和 `}}}`）表示，这告诉 Handlebars 将结果插入模板而不进行 HTML 安全转义。在处理从用户接收的数据时必须小心，大多数模板引擎会自动格式化内容，以便浏览器不会将其解释为
    HTML。三个大括号的序列告诉 Handlebars 将结果传递而不进行格式化，这是当表达式生成 HTML 时所需的。
- en: To create the main server-side template for the example project, add a file
    named `counter.handlebars` to the `templates/server` folder with the content shown
    in *Listing 10.24*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建示例项目的主体服务器端模板，请将名为 `counter.handlebars` 的文件添加到 `templates/server` 文件夹中，其内容如
    *清单 10.24* 所示。
- en: 'Listing 10.24: The contents of the counter.handlebars in the templates/server
    folder'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.24：`templates/server` 文件夹中 counter.handlebars 的内容
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the most complex template required by the example. The `increment`
    helper is used to create the URL that the browser will request when the anchor
    element is clicked:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例中需要的最复杂的模板。使用 `increment` 辅助函数创建浏览器在点击锚元素时请求的 URL：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The double curly braces denote a template expression that can be formatted for
    HTML safety. This expression invokes the `increment` helper and uses the value
    of the query parameter as the argument. The helper will increment the value it
    receives, and the result will be included in the value for the anchor element’s
    `href` attribute.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号表示一个模板表达式，可以格式化为 HTML 安全。此表达式调用 `increment` 辅助函数，并使用查询参数的值作为参数。辅助函数将增加它接收的值，并将结果包含在锚元素的
    `href` 属性的值中。
- en: 'The other expressions are more complex. First, there is an `if`/`else` expression,
    like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他表达式更复杂。首先，有一个 `if`/`else` 表达式，如下所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `#if` expression is evaluated, and the result is used to determine whether
    the content in the first or second block is included in the result. In this example,
    the outcomes apply further template expressions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`#if` 表达式将被评估，其结果用于确定是否将第一个或第二个块中的内容包含在结果中。在这个例子中，结果将应用进一步的模板表达式：'
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `>` character tells the template engine to load a partial template. If the
    `#if` expression is `true`, then the `odd` partial will be used, otherwise it
    will be the `even` partial. *Table 10.3* describes the most useful template features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 字符告诉模板引擎加载一个部分模板。如果 `#if` 表达式为 `true`，则使用 `odd` 部分模板，否则使用 `even` 部分模板。*表
    10.3* 描述了最有用的模板功能。'
- en: '**Note**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You must not insert a space (or any other character) between the `{{` sequence
    and the rest of the expression, otherwise the template engine will report an error.
    So, `{{/if }}` is OK but `{{ /if }}` won’t work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在 `{{` 序列和其余表达式之间插入一个空格（或任何其他字符），否则模板引擎将报告错误。因此，`{{/if}}` 是可以的，但 `{{ /if
    }}` 将不会工作。
- en: 'Table 10.3: Useful template features'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3：有用的模板功能
- en: '| Name | Description |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| Content will be included in the output if the value in the expression is
    `true`. There is also an `{{else }}` clause that can be used to create an `if/then/else`
    effect. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 如果表达式的值为 `true`，则内容将被包含在输出中。还有一个 `{{else}}` 子句，可以用来创建 `if/then/else` 效果。|'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| Content will be included in the output if the value in the expression is
    `false`. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 如果表达式的值为 `false`，则内容将被包含在输出中。|'
- en: '|'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| This expression inserts the specified partial template into the result. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式将指定的部分模板插入到结果中。|'
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| This expression repeats a set of elements for each item in an array, as demonstrated
    in *Chapter 12*. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 此表达式重复数组中的每个元素的一组元素，如 *第 12 章* 中所示。|'
- en: To create the partial template for even values, create the `templates/server/partials`
    folder and add to it a file named `even.handlebars` with the content shown in
    *Listing 10.25*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建偶数值的局部模板，请创建 `templates/server/partials` 文件夹，并向其中添加一个名为 `even.handlebars`
    的文件，其内容如 *列表 10.25* 所示。
- en: 'Listing 10.25: The contents of the even.handlebars file in the templates/server/partials
    folder'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.25：templates/server/partials 文件夹中 even.handlebars 文件的内容
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The partial template contains an expression that uses the `valueOrZero` helper
    to display the `c` value from the query string or zero if there is no value. Add
    a file named `odd.handlebars` to the `templates/server/partials` folder with the
    content shown in *Listing 10.26*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 局部模板包含一个使用 `valueOrZero` 辅助函数的表达式，用于显示查询字符串中的 `c` 值或如果没有值则显示零。向 `templates/server/partials`
    文件夹添加一个名为 `odd.handlebars` 的文件，其内容如 *列表 10.26* 所示。
- en: 'Listing 10.26: The contents of the odd.handlebars file in the templates/server/partial
    folder'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.26：templates/server/partial 文件夹中 odd.handlebars 文件的内容
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are other ways to recreate the example using Handlebars, which has some
    excellent features, but this approach most closely matches the custom engine that
    was created earlier. The final step is to configure the application to use Handlebars,
    as shown in *Listing 10.27*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Handlebars 重新创建示例还有其他方法，它具有一些优秀的功能，但这种方法最接近之前创建的自定义引擎。最后一步是配置应用程序以使用 Handlebars，如
    *列表 10.27* 所示。
- en: 'Listing 10.27: Setting up the template engine in the server.ts file in the
    src/server folder'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.27：在 src/server 文件夹中的 server.ts 文件中设置模板引擎
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `express-handlebars` package is used to integrate the Handlebars template
    engine into Express. One difference is that the help functions are added to the
    context object that is used to render the template, but otherwise, the configuration
    is similar to the custom engine.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-handlebars` 包用于将 Handlebars 模板引擎集成到 Express 中。一个不同之处在于帮助函数被添加到用于渲染模板的上下文对象中，但除此之外，配置与自定义引擎相似。'
- en: '**Note**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The integration of Handlebars with Express provides support for providing extra
    data values, known as locals, outside of the call to the `render` method. *Chapter
    15* demonstrates the use of this feature to include authentication details in
    the template.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 与 Express 的集成提供了在 `render` 方法调用之外提供额外数据值（称为局部变量）的支持。*第 15 章* 展示了如何使用此功能在模板中包含身份验证详细信息。
- en: Use a browser to request `http://localhost:5000/dynamic/counter` and you will
    see the round-trip application but rendered by a real template package, with the
    addition of the word “Handlebars” in the partial templates to emphasize the change,
    as shown in *Figure 10.8*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000/dynamic/counter`，你将看到往返应用程序，但由真实的模板包渲染，局部模板中添加了“Handlebars”一词以强调更改，如
    *图 10.8* 所示。
- en: '![](img/Image11047.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image11047.png)'
- en: 'Figure 10.8: Using a package for server-side templates'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：使用包进行服务器端模板
- en: Using a package for client-side templates
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端模板的包
- en: Many template packages can also be used in the browser to create client-side
    templating, but this requires wrapping templates in `script` elements in the HTML
    documents sent to the browser, which is awkward to do. For this reason, most template
    packages offer integrations with popular build tools and bundlers, such as webpack,
    that compile templates into JavaScript code. Run the command shown in *Listing
    10.28* in the `part2app` folder to add a package that integrates Handlebars into
    webpack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模板包也可以在浏览器中使用来创建客户端模板，但这需要在发送到浏览器的 HTML 文档中的 `script` 元素中包装模板，这样做很麻烦。因此，大多数模板包都提供了与流行的构建工具和打包器（如
    webpack）的集成，这些工具将模板编译成 JavaScript 代码。在 `part2app` 文件夹中运行 *列表 10.28* 中显示的命令以添加一个集成
    Handlebars 到 webpack 的包。
- en: 'Listing 10.28: Installing an integration package'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.28：安装集成包
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A change is required to the webpack configuration file to add support for compiling
    Handlebars templates, as shown in *Listing 10.29*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改 webpack 配置文件以添加对编译 Handlebars 模板的支持，如 *列表 10.29* 所示。
- en: 'Listing 10.29: Changing the configuration in the webpack.config.mjs file in
    the part2app folder'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.29：在 part2app 文件夹中的 webpack.config.mjs 文件中更改配置
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `module` configuration section adds support for processing Handlebars templates.
    The `resolve` section creates an alias so that JavaScript files created from templates
    can be imported with `@templates`, rather than using a relative path in an `import`
    statement.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`module` 配置部分添加了对处理 Handlebars 模板的支持。`resolve` 部分创建了一个别名，以便可以从模板创建的 JavaScript
    文件使用 `@templates` 导入，而不是在 `import` 语句中使用相对路径。'
- en: Webpack doesn’t detect changes to its configuration file, so stop the build
    tools and run the `npm start` command again so the new configuration takes effect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack无法检测其配置文件的变化，因此停止构建工具并再次运行`npm start`命令，以便新的配置生效。
- en: To define the client-side template, add a file named `counter_client.handlebars`
    in the `templates/client` folder with the content shown in *Listing 10.30*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义客户端模板，请在`templates/client`文件夹中添加一个名为`counter_client.handlebars`的文件，其内容如*列表10.30*所示。
- en: 'Listing 10.30: The contents of the counter_client.handlebars file in the templates/client
    folder'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.30：`templates/client`文件夹中`counter_client.handlebars`文件的内容
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All the Handlebars features are available in client-side templates, including
    partial templates, but I have combined everything for simplicity. The content
    security policy restrictions on inline event handlers still apply and so I have
    used the `action` attribute on the `button` element to identify what action should
    be performed when the button is clicked.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Handlebars功能在客户端模板中都是可用的，包括部分模板，但我为了简单起见将它们全部组合在一起。内联事件处理器的安全内容策略限制仍然适用，因此我使用了`button`元素的`action`属性来标识当按钮被点击时应执行的操作。
- en: Only one helper is required on the client side. Add a file named `isOdd.js`
    to the `templates/client` folder with the contents shown in *Listing 10.31*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只需要一个助手。将一个名为`isOdd.js`的文件添加到`templates/client`文件夹中，其内容如*列表10.31*所示。
- en: 'Listing 10.31: The contents of the isOdd.js file in the templates/client folder'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.31：`templates/client`文件夹中`isOdd.js`文件的内容
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The location of files is specified by the `handlebars-loader` package and the
    default configuration has template helper functions defined in individual files
    with the helper name used as the filename, alongside the templates that use them.
    *Listing 10.32* updates the `client.js` file to use the Handlebars template.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的位置由`handlebars-loader`包指定，默认配置中模板助手函数定义在单独的文件中，助手名称用作文件名，与使用它们的模板并列。*列表10.32*更新了`client.js`文件以使用Handlebars模板。
- en: 'Listing 10.32: Using a template in the client.js file in the src/client folder'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.32：在`src/client`文件夹中的`client.js`文件中使用模板
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The compiled template is a drop-in replacement for the custom function I defined
    earlier in the chapter. When webpack builds the client-side bundle, the Handlebars
    template files are compiled into JavaScript. (You may receive a build error when
    you save the changes in *Listing 10.32*. If that happens, stop the development
    tools, and start them again using the `npm start` command).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的模板是替换我在本章早期定义的定制函数的即插即用替代品。当webpack构建客户端包时，Handlebars模板文件被编译成JavaScript。（如果您在*列表10.32*中保存更改时收到构建错误，请停止开发工具，并使用`npm
    start`命令重新启动它们）。
- en: Use a browser to request `http://localhost:5000` and you will see the client-side
    application, as shown in *Figure 10.9*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000`，您将看到如图*图10.9*所示的客户端应用程序。
- en: '![](img/Image11054.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image11054.png)'
- en: 'Figure 10.9: Using a package for client-side templates'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：使用客户端模板的包
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I demonstrated how server-side and client-side templates work,
    and how they can be used to generate HTML content. The following information was
    also covered:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我演示了服务器端和客户端模板的工作原理，以及如何使用它们生成HTML内容。以下信息也得到了涵盖：
- en: Templates are a mix of static content with placeholders for data values.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板是静态内容和数据值占位符的混合体。
- en: When a template is rendered, the result is an HTML document or fragment that
    reflects the current state of the application.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模板被渲染时，结果是反映应用程序当前状态的HTML文档或片段。
- en: Templates can be rendered by Node.js, as server-side templates, or by JavaScript
    running in the browser, as client-side templates.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板可以由Node.js作为服务器端模板渲染，或者由在浏览器中运行的JavaScript作为客户端模板渲染。
- en: Client-side templates are usually compiled into JavaScript functions so they
    can be easily rendered by the browser.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端模板通常被编译成JavaScript函数，以便浏览器可以轻松渲染。
- en: There are many good open-source template packages available, all of which offer
    similar features, but use different template file formats.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多优秀的开源模板包可用，它们都提供类似的功能，但使用不同的模板文件格式。
- en: In the next chapter, I will explain how you can use HTML forms to receive data
    from the user, and how to validate the data when it is received.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将解释如何使用HTML表单从用户那里接收数据，以及如何在接收到数据时验证数据。
