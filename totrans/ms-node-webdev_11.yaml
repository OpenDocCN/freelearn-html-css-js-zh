- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using HTML Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I describe how templates are used to generate HTML content,
    allowing an application to adapt the content display to the user to reflect the
    request that is being processed or the application’s state data.
  prefs: []
  type: TYPE_NORMAL
- en: Like many of the topics described in this book, templates are much easier to
    understand once you see how they work. Therefore, I will start by creating a simple
    custom template system using just the features provided by the JavaScript and
    Node.js APIs, just to explain how the pieces fit together. I will demonstrate
    *server-side templates*, where the backend server generates the HTML content,
    and *client-side templates*, where the browser generates the content.
  prefs: []
  type: TYPE_NORMAL
- en: The custom templates in this chapter are educational but too limited for use
    in a real project, so I also introduce a popular template package that has many
    more features and much better performance, and which is suitable for use in a
    real project. *Table 10.1* puts HTML templates in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10.1: Putting HTML templates in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | HTML templates are HTML documents that contain placeholders
    that are replaced with dynamic content to reflect the state of the application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Templates allow the content presented to the user
    to reflect changes in the application state and are a key building block in most
    web applications. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | There are many good template packages available and
    popular frameworks generally include a template system. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | It is important to find a package
    with a format that you find easy to read, but otherwise, template engines are
    a positive addition to a web application project. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | You could generate content entirely using JavaScript
    code, but this tends to be difficult to maintain. You may not be able to avoid
    using templates if you are using a framework, such as React or Angular. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 10.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamically render HTML elements | Use a template engine that mixes HTML
    elements and expressions that are evaluated to produce data values. | *1-4, 11-15,
    21-27* |'
  prefs: []
  type: TYPE_TB
- en: '| Evaluate template expressions | Use the `eval` keyword to evaluate string
    expressions as JavaScript statements. | *5, 6* |'
  prefs: []
  type: TYPE_TB
- en: '| Break up templates into more manageable content | Use partial templates/views.
    | *7-10* |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamically render HTML elements at the browser | Compile templates into
    JavaScript code that is included in the bundle loaded by the browser. | *16-20,
    28-31* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `part2app` project created in *Chapter 9*. No changes
    are required to prepare for this chapter. Open a command prompt and run the command
    shown in *Listing 10.1* in the `part2app` folder to start the development tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.1: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser, request `http://localhost:5000`, and click the **Send Request**
    button. The browser will send a request to the backend server and display details
    of the results, as shown in *Figure 10.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Running the example application'
  prefs: []
  type: TYPE_NORMAL
- en: Using server-side HTML templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-side HTML templates allow the backend server to dynamically generate
    content to send the browser content that is tailored to an individual request.
    Tailoring can take any form, but a typical example is to include content that
    is specific to the user, such as including the user’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three things are required for an HTML template: a *template* file that has
    placeholder sections into which dynamic content will be inserted, a *data dictionary*
    or *context* that provides the values that will determine the specific dynamic
    content that will be generated, and a *template engine* that processes the view
    and the dictionary to produce an HTML document into which dynamic content has
    been inserted, and which can be used as a response to an HTTP request, as shown
    in *Figure 10.2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The components of an HTML template'
  prefs: []
  type: TYPE_NORMAL
- en: The task of processing a template is known as *rendering* and it occurs entirely
    in the backend server. Rendering produces a regular HTML document that, from the
    perspective of the browser, appears no different from regular static content.
    (There is a different kind of template that is sent to the browser as JavaScript,
    where it is rendered to create HTML content by the client, as described in the
    *Using client-side HTML templates* section).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easy to create a simple template engine to help understand how they work,
    although it is much harder to create one that is production ready. In this section,
    I’ll create something simple and then introduce an open-source template engine
    package that is better, faster, and has many more features.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to start by creating the template, which will help put everything
    in context. Create the `part2app/templates/server` folder and add to it a file
    named `basic.custom` with the content shown in *Listing 10.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Most code editors can be configured to understand that files with a non-standard
    extension, such as `.custom`, contain a well-known format, such as HTML. If you
    are using Visual Studio Code, for example, click on **Plain Text** in the bottom-right
    corner of the window and either choose the format for a single file or set up
    an association so that all `.custom` files are treated like HTML, which will make
    it easier to spot mistakes when following the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.2: The contents of the basic.custom file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This template is a complete HTML document with one placeholder, which is denoted
    by the double curly braces (the `{{` and `}}` characters). The content inside
    of the braces is a *template expression* that will be evaluated when the template
    is rendered and used to replace the placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Not all template engines use the `{{` and `}}` characters, although that is
    a popular choice, and what is important is that the character sequence that denotes
    a placeholder is unlikely to occur in the static parts of the template, which
    is why you will usually see sequences of repeating characters, or unusual characters,
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the custom template engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Express package has integrated support for template engines, which makes
    it easy to experiment and learn how they work. Add a file named `custom_engine.ts`
    to the `src/server` folder with the content shown in *Listing 10.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.3: The contents of the custom_engine.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `renderTemplate` function will be called by Express to render a template.
    The parameters are a `string` that contains the template file path, an `object`
    that provides context data for rendering the template, and a callback function
    used to provide Express with the rendered content or an error if something goes
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `renderTemplate` function uses the `readFile` function to read the contents
    of the template file and then invokes the `parseTemplate` function, which uses
    a regular expression to search for the `{{` and `}}` characters. For each match,
    a callback function inserts a data value from the context object in the result,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a rudimentary approach, and real engines are more complex and take
    greater care to find template expressions, but this is enough to demonstrate the
    idea. The `registerCustomTemplateEngine` function registers the template engine
    with Express, which is done by calling the `Express.engine` method, specifying
    the file extension and the `renderTemplate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This statement tells Express to use the `renderTemplate` function to render
    template files that have a `.custom` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the custom template engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final part of the process is to configure Express and create a route that
    matches requests that will be handled with a template, as shown in *Listing 10.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.4: Setting up the template engine in the server.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `registerCustomTemplateEngine` defined in *Listing 10.4* sets up
    the custom template engine. By default, Express looks for template files in the
    `views` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Views* and *view engines* are alternate names for templates and template engines,
    but to keep the terminology consistent, I used the `ExpressApp.set` method to
    change the template file location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The complete set of Express configuration properties can be found at [https://expressjs.com/en/4x/api.html#app.set](https://expressjs.com/en/4x/api.html#app.set)
    and the `views` property is used to specify the directory that contains template
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Express router is used to match requests that will be handled by templates,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `get` method creates a route that matches paths that start with `/dynamic`
    and captures the next path segment to a route parameter named `file`. The request
    handler invokes the `Response.render` method, which is responsible for rendering
    a template. The `file` route parameter is used to create the first argument to
    the render method, which is the name of the template file. The second argument
    is an object that provides the template engine with context data to help it generate
    content. In this example, the context object defines a `message` property, whose
    value will be included in the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: To test the custom template engine, use a browser to request `http://localhost:5000/dynamic/basic`.
    The `dynamic` part of the URL will be matched by the new Express route, and the
    `basic` part corresponds to the `basic.custom` file in the templates folder. The
    custom view engine will process the template file and the results will be written
    to the response, as shown in *Figure 10.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Using a custom template engine'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating expressions in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inserting data values into templates is a good start, but most template engines
    have support for evaluating fragments of JavaScript code and inserting the results
    into the output. *Listing 10.5* adds some template expressions to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.5: Adding expressions to the basic.custom file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10.6* adds support for evaluating expressions to the template engine,
    using the JavaScript `eval` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caution**'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript `eval` function is dangerous, especially if there is the possibility
    that it might be used with content or data provided by users because it can be
    used to execute any JavaScript code. This alone is enough reason to use a well-tested
    template engine package, such as the one introduced in the Using a template package
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.6: Evaluating expressions in the custom_engine.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The difficulty of using `eval` is making sure that context data is available
    as local variables when evaluating an expression. To make sure that the context
    data is in scope, I create a string for each property of the context object and
    combine those strings with the expression to be evaluated, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach ensures that there is a `message` value for the expression to
    use, for example. There are some serious dangers in using `eval` but it is fine
    for the example application, although it bears repeating to say a real template
    package should be used in real projects, especially when dealing with user-supplied
    data. Use a browser window to request `http://localhost:5000/dynamic/basic` and
    you will see the results shown in *Figure 10.4*. (The browser won’t reload automatically,
    so you will either have to make a new request or reload the browser).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Evaluating JavaScript expressions in a template'
  prefs: []
  type: TYPE_NORMAL
- en: Adding template features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to evaluate expressions provides a foundation for creating additional
    features, which can be easily written as JavaScript functions and added to the
    context used to parse the template. Add a file named `custom_features.ts` to the
    `src/server` folder with the content shown in *Listing 10.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiling templates**'
  prefs: []
  type: TYPE_NORMAL
- en: Most real template engines compile their templates, which means that templates
    are converted into a series of JavaScript functions that can be invoked to generate
    content. This doesn’t change the content that is generated but it can improve
    performance because output can be created without needing to read and search the
    template file. Client-side templates are also compiled so that the JavaScript
    functions can be presented to the browser. You can see an example of this process
    in the *Using a template package* section, later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.7: The contents of the custom_features.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This file defines a `style` function that accepts a stylesheet name and returns
    a `link` element. The `partial` function reads another template file and returns
    its content for inclusion in the overall content. The `partial` function receives
    a context object, which it uses to locate the requested file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The context object that Express provides to the template engine has a `settings`
    property, which returns an object that contains the application’s configuration.
    One of the settings properties is `views`, which returns the location of the template
    files (the `templates/server` folder). *Listing 10.8* revises the template to
    use these new features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `partial` function in *Listing 10.7* performs a blocking operation to read
    the contents of the file. As explained in *Chapter 4*, this is something that
    should be avoided as much as possible, and I have used the `readFileSync` function
    only for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.8: Using template features in the basic.custom file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The new features are accessed with a `@` prefix, which makes them easy to find
    when parsing templates. In *Listing 10.8*, the `@style` expression will invoke
    the `style` function to create a `link` element for the Bootstrap CSS file, and
    the `@partial` expression will invoke the `partial` function to load a template
    named `message`. To create the template – known as a *partial template* – that
    will be loaded by the `@partial` expression, create a file named `message.custom`
    in the `templates/server` folder with the content shown in *Listing 10.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.9: The contents of the message.custom in the templates/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Mapping expressions to features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All that remains is translating the `@` expressions in the template to JavaScript
    statements that invoke the functions from *Listing 10.7*. Take the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression will be translated into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once the translation is complete, the result can be evaluated just like any
    other expression. *Listing 10.10* changes the template engine to support the new
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.10: Supporting template features in the custom_engine.ts file in
    the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The functions defined in *Listing 10.7* are imported and assigned the `features`
    prefix. String manipulation performs the translation from the `@` expression to
    the function name, with the addition of the `context` property and an `eval` function.
    This allows expressions to access the context object, the settings it includes,
    and the ability to evaluate expressions with the context. The result from a `@`
    feature may contain other template expressions; therefore, the regular expression
    is used to recursively parse the result.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/dynamic/basic` and you will
    see the output produced by the new features, as shown in *Figure 10.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Adding template features'
  prefs: []
  type: TYPE_NORMAL
- en: Using templates to create a simple round-trip application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template engine is simple, but it has just enough functionality to create
    a basic application that alters the HTML it displays based on user interaction,
    which is the key function of any web application. To demonstrate, I am going to
    present the user with a button that increments a counter, where the value of the
    counter will result in different content being presented to the user. This is
    an example of a *round-trip application*, where each interaction requires an HTTP
    request to the server to get a new HTML document to display to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to add the object that represents the HTTP request to the
    context data given to the custom template engine, as shown in *Listing 10.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.11: Adding to the context data in the server.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a file named `counter.custom` to the `templates/server` folder with
    the content shown in *Listing 10.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.12: The contents of the counter.custom file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This template contains an anchor element (the `a` tag) that, when clicked, requests
    a new HTML document from the backend server using a URL that contains a query
    string parameter named `c`. The value of `c` included in the request URL is always
    one more than the value displayed to the user, such that clicking the button has
    the effect of incrementing the counter.
  prefs: []
  type: TYPE_NORMAL
- en: The template contains a `@conditional` expression, which will be used to render
    different partial templates for odd and even values of `c`. The arguments to `@conditional`
    are an expression to be evaluated and two partial template names that will be
    used for `true` and `false` results when the expression is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: To create the partial template that will be used for odd values, add a file
    named `odd.custom` to the `templates/server` folder with the content shown in
    *Listing 10.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.13: The content of the odd.custom file in the templates/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To create the partial template that will be used for even values, add a file
    named `even.custom` to the `templates/server` folder with the content shown in
    *Listing 10.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.14: The contents of the even.custom file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The remaining step is to implement the `@conditional` expression as a template
    feature, as shown in *Listing 10.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.15: Adding a conditional feature in the custom_features.ts file
    in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `conditional` function accepts an expression, two file paths, a context
    object, and a function used to evaluate expressions. The expression is evaluated,
    and the result is passed to the `partial` function, effectively selecting a partial
    view based on whether the expression has evaluated to `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/dynamic/counter` and click the
    **Increment** button. Each click causes the browser to request a URL like `http://localhost:5000/dynamic/counter?c=1`
    and the value of `c` is used to select the HTML content in the response, as shown
    in *Figure 10.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image10809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Using templates to create a simple round-trip application'
  prefs: []
  type: TYPE_NORMAL
- en: Using client-side HTML templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One drawback of the previous example is that a completely new HTML document
    is generated and sent to the browser every time `Increment` is clicked, even though
    only one section of the HTML changes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Client-side HTML templates* perform the same task as their server-side counterparts,
    but the template is parsed by JavaScript code running in the browser. This allows
    a targeted approach, where selected elements are modified, which can be more responsive
    than waiting for a new HTML document. This is the basis for **single-page applications**
    (**SPAs**), where a single HTML document is delivered to the client and then modified
    by JavaScript code.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difficulty with client-side templates is that they have to be written
    entirely in JavaScript, which can make it awkward to express HTML content in a
    way that is easy to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular client-side frameworks, such as React and Angular, use client-side
    template formats that are easier to read than pure JavaScript, but they use a
    compiler to transform the template into a JavaScript function so that it can be
    added to the JavaScript bundle given to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The templates used by the big frameworks have other benefits, such as making
    it easy to combine templates to create complex content and ensuring that updates
    to HTML elements are performed as efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: But, leaving aside these features, the process of generating content at the
    client is similar to doing so at the server. A good way to understand the issues
    involved in client-side templating is to recreate the counter example from the
    previous section using client-side JavaScript. To start, add a file named `counter_custom.js`
    to the `src/client` folder with the content shown in *Listing 10.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side versus server-side templates**'
  prefs: []
  type: TYPE_NORMAL
- en: Most web application projects tend to mix both server-side and client-side templates
    because each type of template solves a different problem.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side templates require an HTTP connection for every HTML document, which
    can impact performance. However, the performance deficit can be offset by how
    fast the browser can display the contents of the HTML document once it has been
    received.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side templates respond to changes more efficiently and without the need
    to make additional HTTP requests, but this advantage can be undermined by the
    need to transfer the JavaScript code and the state data in the first place. When
    a framework like React or Angular is used, the JavaScript for the framework must
    also be transferred, and this can be a barrier in regions where less capable devices
    and unreliable networks are common.
  prefs: []
  type: TYPE_NORMAL
- en: To bridge the gap and give the best of both worlds, some frameworks offer **server-side
    rendering** (**SSR**), where templates are rendered at the server to create a
    round-trip version of the application, which can be displayed quickly by the browser.
    Once the server-rendered content is displayed, the browser requests JavaScript
    code and transitions to a single-page application. SSR has improved in recent
    years, but it is still clunky and doesn’t suit all projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.16: The contents of the counter_custom.js file in the src/client
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The templates in this example are JavaScript functions that return HTML strings,
    which is the simplest way to create a client-side template and it doesn’t require
    a compiler. The JavaScript template functions will receive a `context` parameter
    that contains the current application state.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript string features make it easy to insert data values into HTML
    strings. In this case, the value of the `counter` property on the `context` object
    received by the function is used to choose between the `Odd` and `Even` functions,
    which is a simpler approach than the equivalent functionality in the server-side
    template example.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this approach is that handling events from elements can be
    difficult. Not only does the example application’s content security policy prevent
    inline event handlers, but it can be difficult to define handler functions that
    use context data in HTML strings.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this limitation, I have added an `action` attribute to the `button`
    element in *Listing 10.16*, which is assigned the value `incrementCounter`. Events
    from the button will be allowed to propagate up the HTML document and I’ll use
    the value of the `action` attribute to decide how to respond.
  prefs: []
  type: TYPE_NORMAL
- en: To create the partial view that will display even values, add a file named `even_custom.js`
    to the `src/client` folder with the content shown in *Listing 10.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.17: The contents of the even_custom.js file in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The HTML string returned by this function includes the value of the `counter.couter`
    property. To create the template for odd values, create a file named `odd_custom.js`
    in the `src/client` folder with the content shown in *Listing 10.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.18: The contents of the odd_custom.js file in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10.19* replaces the code in the `client.js` file to use the new template
    functions and define the features they require.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.19: Replacing the contents of the client.js file in the src/client
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the `DOMContentLoaded` event is emitted, which indicates the browser has
    finished parsing the HTML document, an event listener is created for `click` events,
    and the `render` function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` function invokes the `Counter` template function and uses the HTML
    string it receives to set the content of an HTML element whose `id` is `target`.
    When a `click` event is received, the target for the event is checked for an `action`
    attribute, and its value is used to select a function to execute from the `actions`
    object. There is one action in the example, which increments the `counter` property
    of the `context` object and calls the `render` function to update the content
    presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to remove the existing content from the static HTML document
    and create the element that will be populated with the client-side template content,
    as shown in *Listing 10.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.20: Preparing the HTML document in the index.html file in the static
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000` and you will be presented with
    the same content produced by the server-side templates. The difference is that
    when the **Increment** button is clicked, the state change is handled by rendering
    the client-side templates, as shown in *Figure 10.7*, without the need to request
    a new HTML document from the backend server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image10818.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Using simple client-side templates'
  prefs: []
  type: TYPE_NORMAL
- en: Using a template package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples so far in this chapter have demonstrated how templates can be used
    to render content and show how some basic features can be easily created. For
    real projects, it makes more sense to adopt one of the excellent template packages
    available for JavaScript. Run the commands shown in *Listing 10.21* in the `part2app`
    folder to install one of the most widely used template packages, which is named
    Handlebars, and a package that integrates it into Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.21: Installing a template package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are many template packages available, and they all offer similar features.
    The main difference between packages is the way that templates are written and
    how expressions are denoted. The `{{` and `}}` characters are a common way to
    denote expressions, and they are known as mustache templates because the curly
    braces are reminiscent of a mustache. The `Handlebars` package ([https://handlebarsjs.com](https://handlebarsjs.com))
    uses this style of expression, as its name suggests. This is the style of JavaScript
    template I am used to, and familiarity goes a long way when picking a template
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: There are other options if you don’t like the mustache-style templates. The
    Pug package ([https://pugjs.org](https://pugjs.org)) relies on indentation to
    structure templates, which is a popular choice, and the **Embedded JavaScript**
    (**EJS**) ([https://ejs.co](https://ejs.co)) package uses `<%` and `%>` sequences.
    Stylistic preferences aside, all of these packages are well-written and have good
    levels of support.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package for server-side templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handlebars templates are *logic free*, which means they cannot contain fragments
    of JavaScript that are evaluated to produce content. Instead, helper functions
    are defined to implement the logic required to generate content. Add a file named
    `template_helpers.ts` to the `src/server` folder with the content shown in *Listing
    10.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.22: The contents of the template_helpers.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `style` function accepts the name of a stylesheet and generates a link element
    for it. The `valueOrZero` function checks to see whether a value is defined and,
    if it is not, returns zero. The `increment` function increments a value. The `isOdd`
    function returns `true` if a value is odd.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package that integrates Handlebars into Express supports *layouts*, which
    are templates that contain the common elements that would otherwise be repeated
    in every template. Create the `templates/server/layouts` folder and add to it
    a file named `main.handlebars` with the content shown in *Listing 10.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.23: The contents of the main.handlebars file in the templates/server/layouts
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There are two expressions in this layout. The first invokes the `style` helper
    function defined in *Listing 10.22*, using the `bootstrap.min.css` string as an
    argument (arguments for helpers are separated by spaces and not parentheses).
    The other expression is `body`, into which the contents template that has been
    requested is inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The expressions in the layout are denoted with triple curly braces (`{{{` and
    `}}}`), which tells Handlebars that the results should be inserted into the template
    without being escaped for HTML safety. Care must be taken when dealing with data
    that has been received from users, and most template engines automatically format
    content so that it won’t be interpreted as HTML by the browser. A sequence of
    three curly braces tells Handlebars that the result should be passed on without
    formatting, which is required when an expression is producing HTML.
  prefs: []
  type: TYPE_NORMAL
- en: To create the main server-side template for the example project, add a file
    named `counter.handlebars` to the `templates/server` folder with the content shown
    in *Listing 10.24*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.24: The contents of the counter.handlebars in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most complex template required by the example. The `increment`
    helper is used to create the URL that the browser will request when the anchor
    element is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The double curly braces denote a template expression that can be formatted for
    HTML safety. This expression invokes the `increment` helper and uses the value
    of the query parameter as the argument. The helper will increment the value it
    receives, and the result will be included in the value for the anchor element’s
    `href` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other expressions are more complex. First, there is an `if`/`else` expression,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#if` expression is evaluated, and the result is used to determine whether
    the content in the first or second block is included in the result. In this example,
    the outcomes apply further template expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `>` character tells the template engine to load a partial template. If the
    `#if` expression is `true`, then the `odd` partial will be used, otherwise it
    will be the `even` partial. *Table 10.3* describes the most useful template features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You must not insert a space (or any other character) between the `{{` sequence
    and the rest of the expression, otherwise the template engine will report an error.
    So, `{{/if }}` is OK but `{{ /if }}` won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10.3: Useful template features'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| Content will be included in the output if the value in the expression is
    `true`. There is also an `{{else }}` clause that can be used to create an `if/then/else`
    effect. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| Content will be included in the output if the value in the expression is
    `false`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| This expression inserts the specified partial template into the result. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| This expression repeats a set of elements for each item in an array, as demonstrated
    in *Chapter 12*. |'
  prefs: []
  type: TYPE_TB
- en: To create the partial template for even values, create the `templates/server/partials`
    folder and add to it a file named `even.handlebars` with the content shown in
    *Listing 10.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.25: The contents of the even.handlebars file in the templates/server/partials
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The partial template contains an expression that uses the `valueOrZero` helper
    to display the `c` value from the query string or zero if there is no value. Add
    a file named `odd.handlebars` to the `templates/server/partials` folder with the
    content shown in *Listing 10.26*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.26: The contents of the odd.handlebars file in the templates/server/partial
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to recreate the example using Handlebars, which has some
    excellent features, but this approach most closely matches the custom engine that
    was created earlier. The final step is to configure the application to use Handlebars,
    as shown in *Listing 10.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.27: Setting up the template engine in the server.ts file in the
    src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `express-handlebars` package is used to integrate the Handlebars template
    engine into Express. One difference is that the help functions are added to the
    context object that is used to render the template, but otherwise, the configuration
    is similar to the custom engine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The integration of Handlebars with Express provides support for providing extra
    data values, known as locals, outside of the call to the `render` method. *Chapter
    15* demonstrates the use of this feature to include authentication details in
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/dynamic/counter` and you will
    see the round-trip application but rendered by a real template package, with the
    addition of the word “Handlebars” in the partial templates to emphasize the change,
    as shown in *Figure 10.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image11047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Using a package for server-side templates'
  prefs: []
  type: TYPE_NORMAL
- en: Using a package for client-side templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many template packages can also be used in the browser to create client-side
    templating, but this requires wrapping templates in `script` elements in the HTML
    documents sent to the browser, which is awkward to do. For this reason, most template
    packages offer integrations with popular build tools and bundlers, such as webpack,
    that compile templates into JavaScript code. Run the command shown in *Listing
    10.28* in the `part2app` folder to add a package that integrates Handlebars into
    webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.28: Installing an integration package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A change is required to the webpack configuration file to add support for compiling
    Handlebars templates, as shown in *Listing 10.29*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.29: Changing the configuration in the webpack.config.mjs file in
    the part2app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `module` configuration section adds support for processing Handlebars templates.
    The `resolve` section creates an alias so that JavaScript files created from templates
    can be imported with `@templates`, rather than using a relative path in an `import`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack doesn’t detect changes to its configuration file, so stop the build
    tools and run the `npm start` command again so the new configuration takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: To define the client-side template, add a file named `counter_client.handlebars`
    in the `templates/client` folder with the content shown in *Listing 10.30*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.30: The contents of the counter_client.handlebars file in the templates/client
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All the Handlebars features are available in client-side templates, including
    partial templates, but I have combined everything for simplicity. The content
    security policy restrictions on inline event handlers still apply and so I have
    used the `action` attribute on the `button` element to identify what action should
    be performed when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Only one helper is required on the client side. Add a file named `isOdd.js`
    to the `templates/client` folder with the contents shown in *Listing 10.31*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.31: The contents of the isOdd.js file in the templates/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The location of files is specified by the `handlebars-loader` package and the
    default configuration has template helper functions defined in individual files
    with the helper name used as the filename, alongside the templates that use them.
    *Listing 10.32* updates the `client.js` file to use the Handlebars template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10.32: Using a template in the client.js file in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The compiled template is a drop-in replacement for the custom function I defined
    earlier in the chapter. When webpack builds the client-side bundle, the Handlebars
    template files are compiled into JavaScript. (You may receive a build error when
    you save the changes in *Listing 10.32*. If that happens, stop the development
    tools, and start them again using the `npm start` command).
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000` and you will see the client-side
    application, as shown in *Figure 10.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image11054.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Using a package for client-side templates'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I demonstrated how server-side and client-side templates work,
    and how they can be used to generate HTML content. The following information was
    also covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates are a mix of static content with placeholders for data values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a template is rendered, the result is an HTML document or fragment that
    reflects the current state of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates can be rendered by Node.js, as server-side templates, or by JavaScript
    running in the browser, as client-side templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side templates are usually compiled into JavaScript functions so they
    can be easily rendered by the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many good open-source template packages available, all of which offer
    similar features, but use different template file formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will explain how you can use HTML forms to receive data
    from the user, and how to validate the data when it is received.
  prefs: []
  type: TYPE_NORMAL
