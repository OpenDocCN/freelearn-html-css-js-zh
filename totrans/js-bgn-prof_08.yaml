- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Built-In JavaScript Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置JavaScript方法
- en: We have just covered most of the basic building blocks in JavaScript. Now it's
    time to look at some powerful built-in methods that will make your life easier
    that we haven't seen yet. Built-in methods are functionality that we get out of
    the box with JavaScript. We can use these methods without having to code them
    first. This is something we have done a lot already, for example, `console.log()`
    and `prompt()`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚覆盖了JavaScript中的大多数基本构建块。现在，是时候看看一些将使您的生活更轻松的强大内置方法了，这些方法我们还没有看到。内置方法是我们在使用JavaScript时直接获得的功能。我们可以使用这些方法而无需先编写代码。这是我们已经做了很多的事情，例如`console.log()`和`prompt()`。
- en: Many built-in methods belong to built-in classes as well. These classes and
    their methods can be used at any time because JavaScript has already defined them.
    These classes exist for our convenience, since they are very common things to
    need, such as the `Date`, `Array`, and `Object` classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内置方法也属于内置类。这些类及其方法可以随时使用，因为JavaScript已经定义了它们。这些类是为了我们的方便而存在的，因为它们是非常常见的需求，例如`Date`、`Array`和`Object`类。
- en: 'The ability to harness the capabilities that are already built into JavaScript
    can improve the effectiveness of the code, save time, and comply with various
    best practices for developing solutions. We are going to address some of the common
    uses for such functions, such as manipulating text, mathematical computations,
    dealing with date and time values, interactions, and supporting robust code. Here
    are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 利用已经内置到JavaScript中的功能可以提高代码的有效性，节省时间，并符合开发解决方案的各种最佳实践。我们将讨论一些此类函数的常见用途，例如操作文本、数学计算、处理日期和时间值、交互以及支持健壮的代码。以下是本章涵盖的主题：
- en: Global JavaScript methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局JavaScript方法
- en: String methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串方法
- en: Math methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学方法
- en: Date methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期方法
- en: Array methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组方法
- en: Number methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字方法
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Introduction to built-in JavaScript methods
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置JavaScript方法简介
- en: We have seen many built-in JavaScript methods already. Any method that we didn't
    define ourselves is a built-in method. Some examples include `console.log()`,
    `Math.random()`, `prompt()`, and many more—think about methods on arrays for example.
    The difference between a method and a function is that a function is defined anywhere
    in the script, and a method is defined inside a class. So methods are pretty much
    functions on classes and instances.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多内置的JavaScript方法。任何我们没有自己定义的方法都是内置方法。一些例子包括`console.log()`、`Math.random()`、`prompt()`等等——例如，考虑数组上的方法。方法和函数之间的区别在于，函数可以在脚本中的任何地方定义，而方法是在类内部定义的。因此，方法基本上是类和实例上的函数。
- en: 'Methods can often be chained as well; this is only true for methods returning
    a result. The next method will then be performed on the result. So for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常也可以链式调用；这仅适用于返回结果的方法。下一个方法将在结果上执行。例如：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We create a variable, `s`, and we store `Hello` in there on the first line.
    Then we want to be logging something. This code has been divided over different
    lines for readability, but it''s actually one statement. We first perform a `concat()`
    method on our `s` variable, which appends a string to our string. So after that
    first operation the value is `Hello there!`. Then we transform this to uppercase
    with the next method. At that point the value is `HELLO THERE!`. Then we proceed
    to replace `THERE` with `you`. After that, the value becomes `HELLO you!`. We
    then append a string to it again and finally the value will be logged:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个变量`s`，并在第一行将其中的`Hello`存储进去。然后我们想要记录一些内容。这段代码被分成不同的行以提高可读性，但实际上它是一个语句。我们首先在我们的`s`变量上执行一个`concat()`方法，该方法将字符串附加到我们的字符串上。因此，在第一次操作之后，值变为`Hello
    there!`。然后我们使用下一个方法将其转换为大写。此时，值变为`HELLO THERE!`。然后我们继续将`THERE`替换为`you`。之后，值变为`HELLO
    you!`。然后我们再次向其附加一个字符串，最终将值记录下来：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to log or store the output in this example, because the original string
    value will not be updated by just calling methods on a string.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要记录或存储输出，因为仅调用字符串上的方法并不会更新原始字符串值。
- en: Global methods
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局方法
- en: 'The global JavaScript methods can be used without referring to the built-in
    object they are part of. This means that we can just use the method name as if
    it is a function that has been defined inside the scope we are in, without the
    "object" in front of it. For example, instead of writing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 全局JavaScript方法可以在不引用它们所属的内置对象的情况下使用。这意味着我们可以直接使用方法名，就像它是一个在我们当前作用域内定义的函数一样，前面不需要“对象”。例如，而不是写：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also write:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样写：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the `Number` can be left out, because `isNaN` is made globally available
    without referring to the class it belongs to (in this instance, the `Number` class).
    In this case, both of these `console.log` statements will log `false` (they are
    doing the exact same thing), because `isNaN` returns `true` when it isn't a number.
    And `7` is a number, so it will log `false`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Number`可以省略，因为`isNaN`在不需要引用它所属的类（在这种情况下是`Number`类）的情况下被全局提供。在这种情况下，这两个`console.log`语句都将记录`false`（它们正在做完全相同的事情），因为当它不是数字时，`isNaN`返回`true`。而`7`是一个数字，所以它将记录`false`。
- en: JavaScript has been built to have these available directly, so to achieve this,
    some magic is going on beneath the surface. The JavaScript creators chose the
    methods that they thought were most common. So the reasons why some of them are
    available as global methods and others are not might seem a bit arbitrary. It's
    just the choice of some very bright developers at a certain point in time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript被构建为可以直接使用这些方法，因此为了实现这一点，在表面之下进行了一些魔法操作。JavaScript的创造者选择了他们认为最常用的方法。因此，为什么一些方法是作为全局方法提供的，而其他方法则不是，可能看起来有些随意。这只是某些非常聪明的开发者在一个特定时间点的选择。
- en: We'll address the most common global methods below. We start with decoding and
    encoding URIs, escaped and unescaped, followed by parsing numbers, and finally
    evaluate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面讨论最常见的全局方法。我们首先从解码和编码URI（包括转义和未转义的）开始，然后解析数字，最后进行评估。
- en: Decoding and encoding URIs
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI的解码和编码
- en: Sometimes you will need to encode or decode a string. Encoding is simply converting
    from one shape to another. In this case we will be dealing with percent encoding,
    also called URL encoding. Before we start, there might be some confusion on the
    URI and URL meaning. A **URI** (**uniform resource identifier**) is an identifier
    of a certain resource. **URL** (**uniform resource locator**) is a subcategory
    of URI that is not only an identifier, but also holds the information on how to
    access it (location).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要对字符串进行编码或解码。编码简单地说就是将一种形状转换为另一种形状。在这种情况下，我们将处理百分编码，也称为URL编码。在我们开始之前，可能会有一些关于URI和URL含义的混淆。**URI**（**统一资源标识符**）是某种资源的标识符。**URL**（**统一资源定位符**）是URI的一个子类别，它不仅是一个标识符，而且还包含有关如何访问它的信息（位置）。
- en: Let's talk about encoding and decoding these URIs (and also URLs, since they
    are a subset). An example of when you'd need this is when you are sending variables
    over the URL using the `get` method in a form. These variables that you are sending
    via the URL are called query parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何对这些URI（以及URL，因为它们是子集）进行编码和解码。你需要这样做的一个例子是在表单中使用`get`方法通过URL发送变量。你通过URL发送的这些变量被称为查询参数。
- en: 'If something contains a space, this will be decoded, because you cannot use
    spaces in your URL. They will be converted to `%20`. The URL might look something
    like:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个内容包含空格，这将进行解码，因为你的URL中不能使用空格。它们将被转换为`%20`。URL可能看起来像这样：
- en: '`www.example.com/submit?name=maaike%20van%20putten&love=coding`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`www.example.com/submit?name=maaike%20van%20putten&love=coding`'
- en: 'All characters can be converted to some `%`-starting format. However, this
    is not necessary in most cases. URIs can contain a certain number of alphanumeric
    characters. The special characters need to be encoded. An example, before encoding,
    is:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符都可以转换为以`%`开头的格式。然而，在大多数情况下，这并不是必要的。URI可以包含一定数量的字母数字字符。特殊字符需要编码。一个例子，在编码之前是：
- en: '`https://www.example.com/submit?name=maaike van putten`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.example.com/submit?name=maaike van putten`'
- en: 'The same URL after encoding is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编码后的相同URL是：
- en: '`https://www.example.com/submit?name=maaike%20van%20putten`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.example.com/submit?name=maaike%20van%20putten`'
- en: There are two pairs of encode and decode methods. We will discuss them and their
    use cases here. You cannot have a URI with spaces, so working with these methods
    is crucial in order to work with variables containing spaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种编码和解码方法。我们将在下面讨论它们及其用例。由于URI不能包含空格，因此使用包含空格的变量时，使用这些方法是至关重要的。
- en: decodeUri() and encodeUri()
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: decodeUri() 和 encodeUri()
- en: 'The `decodeUri()` and `encodeUri()` are actually not really encoding and decoding,
    they are more so fixing broken URIs. It is like the previous example with the
    spaces. This method pair is really good at fixing broken URIs and decoding them
    back into a string. Here you can see them in action:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeUri()` 和 `encodeUri()` 实际上并不是真正的编码和解码，它们更多的是修复损坏的URI。就像之前的例子中的空格一样。这对方法非常擅长修复损坏的URI并将它们解码回字符串。这里你可以看到它们的作用：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is the output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, it has replaced the spaces in the encoded version and removed
    them again in the decoded version. All the other characters get to stay the same—this
    encode and decode do not take special characters into account, and therefore leave
    them in the URI. Colons, question marks, equal signs, slashes, and ampersands
    can be expected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它已经替换了编码版本中的空格，并在解码版本中再次删除它们。所有其他字符都保持不变——这个编码和解码不关注特殊字符，因此将它们留在URI中。冒号、问号、等号、斜杠和和号是可以预期的。
- en: 'This is great for fixing broken URIs, but it''s actually a bit useless whenever
    you need to encode strings that contain any of these characters: `/` `,` `?` `:`
    `@` `&` `=` `+` `$` `#`. These can be used in URIs as part of the URI and are
    therefore skipped. This is where the next two built-in methods come in handy.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于修复损坏的URI非常棒，但实际上，当你需要编码包含这些字符的字符串时（`/` `,` `?` `:` `@` `&` `=` `+` `$` `#`），实际上是无用的。这些可以用作URI的一部分，因此被跳过。这就是下一个两个内置方法派上用场的地方。
- en: decodeUriComponent() and encodeUriComponent()
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: decodeUriComponent() 和 encodeUriComponent()
- en: 'So, the methods `decodeURI()` and `encodeURI()` can be very useful to fix a
    broken URI, but they are useless when you only want to encode or decode a string
    that contains a character with a special meaning, such as `=` or `&`. Take the
    following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`decodeURI()` 和 `encodeURI()` 方法可以非常有助于修复损坏的URI，但当你只想编码或解码包含特殊字符（如 `=` 或
    `&`）的字符串时，它们就毫无用处。以下是一个例子：
- en: '`https://www.example.com/submit?name=this&that=some thing&code=love`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.example.com/submit?name=this&that=some thing&code=love`'
- en: 'Weird value, we can agree on that, but it will demonstrate our problem. Using
    encodeURI on this will leave us with:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的价值，我们可以同意这一点，但它将展示我们的问题。使用 encodeURI 对此进行编码后，我们将得到：
- en: '`https://www.example.com/submit?name=this&that=some%20thing&code=love`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.example.com/submit?name=this&that=some%20thing&code=love`'
- en: 'There are actually 3 variables in here according to URI standards:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据URI标准，这里实际上有3个变量：
- en: '`name` (value is `this`)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（值是 `this`）'
- en: '`that` (value is `some` `thing`)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`that`（值是 `some` `thing`）'
- en: '`code` (value is `love`)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`（值是 `love`）'
- en: While we intended to send in one variable, `name`, with the value `this&that=some
    thing&code=love`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们打算发送一个变量，`name`，其值为 `this&that=some thing&code=love`。
- en: 'In this case, you will need `decodeUriComponent()` and `encodeUriComponent()`,
    because you would need the `=` and `&` in the variable part encoded as well. Right
    now, this is not the case and it will actually cause problems in interpreting
    the query parameters (the variables after the `?`). We only wanted to send in
    one parameter: `name`. But instead we sent in three.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要 `decodeUriComponent()` 和 `encodeUriComponent()`，因为变量部分中的 `=` 和 `&`
    也需要编码。目前，这种情况并不存在，它实际上会在解释查询参数（`?` 后的变量）时引起问题。我们只想发送一个参数：`name`。但结果我们发送了三个。
- en: 'Let''s have a look at another example. Here is what the example of the previous
    section would have done with this component encoding:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。这是前一个章节中示例使用组件编码的结果：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The resulting output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的输出如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clearly, you don't want this as your URI, but the component methods are useful
    to encode, for example, a URL variable. If the URL variable were to contain a
    special character, like `=` and `&,` this would change the meaning and break the
    URI if these characters don't get encoded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不想你的URI是这样的，但组件方法对于编码，例如URL变量很有用。如果URL变量包含特殊字符，如 `=` 和 `&`，这些字符如果没有被编码，就会改变意义并破坏URI。
- en: Encoding with escape() and unescape()
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 escape() 和 unescape() 进行编码
- en: These are still global methods available to do something similar to encode (escape)
    and decode (unescape). Both methods are strongly discouraged to use and they might
    actually disappear from future JavaScript versions or may not be supported by
    browsers for good reasons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仍然是全局方法，可用于执行类似于编码（escape）和解码（unescape）的操作。这两种方法强烈建议不要使用，并且它们实际上可能从未来的JavaScript版本中消失，或者浏览器可能出于良好原因不支持它们。
- en: Practice exercise 8.1
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8.1
- en: 'Output the `decodeURIComponent()` for the string `How''s%20it%20going%3F` to
    the console. Also, encode the string `How''s it going?` to be output into the
    console. Create a web URL and encode the URI:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串`How's%20it%20going%3F`的`decodeURIComponent()`输出到控制台。也将字符串`How's it going?`编码并输出到控制台。创建一个网络URL并编码URI：
- en: Add the strings as variables in the JavaScript code
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串作为变量添加到JavaScript代码中
- en: Using `encodeURIComponent()` and `decodeURIComponent()` output the results into
    the console
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`encodeURIComponent()`和`decodeURIComponent()`将结果输出到控制台
- en: Create a web URI with request parameters `http://www.basescripts.com?=Hello
    World";`
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有请求参数`http://www.basescripts.com?=Hello World";`的网络URI
- en: Encode and output the web URI into the console
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网络URI编码并输出到控制台
- en: Parsing numbers
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析数字
- en: There are different ways to parse strings to numbers. In many situations you
    will have to translate a string to a number, for example reading input boxes from
    an HTML web page. You cannot calculate with strings, but you can with numbers.
    Depending on what exactly you need to do, you will need either one of these methods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解析字符串到数字有不同的方法。在许多情况下，你将不得不将字符串转换为数字，例如从HTML网页中读取输入框。你不能用字符串进行计算，但可以用数字。根据你确切需要做什么，你可能需要这些方法中的任何一个。
- en: Making integers with parseInt()
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`parseInt()`创建整数
- en: 'With the method `parseInt()` a string will be changed to an integer. This method
    is part of the `Number` class, but it is global and you can use it without the
    `Number` in front of it. Here you can see it in action:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parseInt()`方法将字符串转换为整数。这个方法是`Number`类的一部分，但它全局可用，你可以不用在前面加上`Number`来使用它。这里你可以看到它是如何工作的：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start off with a string containing a `6`. Then we convert this string to
    an integer using the `parseInt` method, and when we log the result, we will get
    in the console:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含`6`的字符串开始。然后我们使用`parseInt`方法将这个字符串转换为整数，当我们记录结果时，我们将在控制台得到：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that the type has changed from `string` to `number`. At this point,
    you may wonder what will happen if `parseInt()` tries to parse other types of
    numbers, like string versions of floats or binary numbers. What do you think will
    happen when we do this?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到类型已经从`string`变成了`number`。在这个时候，你可能想知道如果`parseInt()`尝试解析其他类型的数字，比如浮点数的字符串版本或二进制数字，会发生什么。你认为当我们这样做时会发生什么？
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will log:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Can you figure out the logic here? First of all, JavaScript doesn''t like crashing
    or using errors as a way out, so it is trying to make it work to the best of its
    abilities. The `parseInt()` method simply stops parsing when it runs into a non-numeric
    character. This is the specified behavior, and you need to keep that in mind while
    working with `parseInt()`. In the first case, it stops parsing as soon as it finds
    the dot, so the result is `7`. And in the binary number case, it stops parsing
    as soon as it hits the `b`, and the result is `0`. By now you can probably figure
    out what this does:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你能理解这里的逻辑吗？首先，JavaScript不喜欢通过崩溃或使用错误作为退出方式，所以它正在尽力让它尽可能正常工作。`parseInt()`方法在遇到非数字字符时会停止解析。这是指定的行为，你在使用`parseInt()`时需要记住这一点。在第一种情况下，它一遇到点就停止解析，所以结果是`7`。在二进制数字的情况下，它一遇到`b`就停止解析，结果是`0`。到现在你可能已经能猜出这是做什么的：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the first character is non-numeric, JavaScript will convert this string
    to `NaN`. Here is the result that you will get in the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个字符是非数字的，JavaScript将这个字符串转换为`NaN`。这是你将在控制台得到的结果：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So `parseInt()` can be a bit quirky, but it's very valuable. In the real world,
    it is used a lot to combine the input of users via web pages and calculations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`parseInt()`可能有点古怪，但它非常有价值。在现实世界中，它被大量用于通过网页结合用户输入和计算。
- en: Making floats with parseFloat()
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`parseFloat()`创建浮点数
- en: 'Similarly, we can use `parseFloat()` to parse a string to a float. It works
    exactly the same, except it can also understand decimal numbers and it doesn''t
    quit parsing as soon as it runs into the first dot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`parseFloat()`将字符串解析为浮点数。它的工作方式完全相同，但它也可以理解小数，并且它不会一遇到第一个点就停止解析：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will log:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the `parseInt()`, this value became `7`, because it would stop parsing
    as soon as it finds a non-numeric character. However, `parseFloat()` can deal
    with one dot in the number, and the numbers after that are interpreted as decimals.
    Can you guess what happens when it runs into a second dot?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parseInt()`，这个值变成了`7`，因为它一遇到非数字字符就会停止解析。然而，`parseFloat()`可以处理数字中的一个点，并且将之后的数字解释为小数。你能猜出当它遇到第二个点时会发生什么吗？
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will log:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The strategy is similar to the `parseInt()` function. As soon as it finds a
    character it cannot interpret, a second dot in this case, it will stop parsing
    and just return the result so far. Then one more thing to note. It is not going
    to append a `.0` to integers, so `6` is not going to become `6.0`. This example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 策略与 `parseInt()` 函数类似。一旦它找到一个无法解释的字符，在这个例子中是第二个点，它将停止解析并只返回到目前为止的结果。然后要注意的另一件事是，它不会在整数后面添加
    `.0`，所以 `6` 不会变成 `6.0`。这个例子：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Will log:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, the behavior for binary numbers and strings is the same. It is going
    to stop parsing as soon as it runs into a character it cannot interpret:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，二进制数和字符串的行为是相同的。它会在遇到无法解释的字符时停止解析：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will log:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will use the `parseFloat()` whenever you need a decimal number. However,
    it will not work with binary, hexadecimal, and octal values, so whenever you really
    need to work with these values or integers you'll have to use `parseInt()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在需要十进制数时使用 `parseFloat()`。然而，它不能与二进制、十六进制和八进制值一起工作，所以当你真正需要处理这些值或整数时，你必须使用
    `parseInt()`。
- en: Executing JavaScript with eval()
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 eval() 执行 JavaScript
- en: 'This global method executes the argument as a JavaScript statement. This means
    that it will just do whatever JavaScript is inserted in there, as if that JavaScript
    were written directly on the spot instead of `eval()`. This can be convenient
    for working with injected JavaScript, but injected code comes with great risks.
    We''ll deal with these risks later; let''s first explore an example. Here is a
    fabulous website:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局方法将参数作为 JavaScript 语句执行。这意味着它将执行插入其中的任何 JavaScript，就像那个 JavaScript 是直接在那个地方写的一样，而不是
    `eval()`。这对于处理注入的 JavaScript 可能很方便，但注入的代码伴随着巨大的风险。我们稍后会处理这些风险；让我们首先探索一个例子。这是一个非常棒的网站：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a basic HTML web page with an input box on it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有输入框的基本 HTML 网页。
- en: You'll learn more about HTML in *Chapter 9*, *The Document Object Model*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *第 9 章*，*文档对象模型* 中了解更多关于 HTML 的内容。
- en: 'Whatever you insert in the input box will get executed. If we were to write
    this in the input box:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入框中插入的内容将被执行。如果我们把这个写在输入框里：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The website background would change to pink. That looks like fun, right? However,
    we cannot stress enough how careful you should be using `eval()`. They might as
    well have called it *evil* according to many developers. Can you reason why this
    might be?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的背景会变成粉色。这看起来很有趣，对吧？然而，我们无法强调使用 `eval()` 时应该多么小心。根据许多开发者的说法，他们甚至可能把它称为 *邪恶的*。你能解释为什么这可能是吗？
- en: The answer is security! Yes, this is probably the worst thing security-wise
    you can do in most situations. You are going to execute external code. This code
    could be malicious. It is a method for supporting code injection. The well-respected
    **OWASP** (**Open Web Application Security Project**) Foundation creates top 10s
    for security threats every 3 years. Code injection has been on it since their
    first top 10 and it is still in the OWASP top 10 security threats now. Running
    it server side can cause your server to crash and your website to go down, or
    worse. There are almost always better solutions to what you want to do than using
    `eval()`. Next to the security risks, it is terrible performance-wise. So just
    for this reason already you might want to avoid using it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是安全性！是的，这可能是大多数情况下在安全性方面最糟糕的事情。你将执行外部代码。这段代码可能是恶意的。这是一种支持代码注入的方法。备受尊敬的 **OWASP**
    （**开放网络应用安全项目**） 基金会每三年发布一次安全威胁的前 10 名。代码注入自他们第一次发布的前 10 名以来一直存在，并且现在它仍然是 OWASP
    前 10 名安全威胁之一。在服务器端运行它可能导致你的服务器崩溃，你的网站关闭，或者更糟。几乎总是有比使用 `eval()` 更好的解决方案。除了安全风险之外，它在性能方面也很糟糕。所以仅仅因为这个原因，你可能想要避免使用它。
- en: Alright, so one last note on this. If you know what you are doing you might
    want to use it in very specific cases. Even though it is "evil", it has a lot
    of power. It can be okay to use in certain cases, for example when you are creating
    template engines, your own interpreter, and all other JavaScript core tools. Just
    beware of the danger and control access to this method carefully. And one last
    bonus tip, when you feel like you really have to use eval, do a quick search on
    the web. Chances are that you will find a better approach.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于这个的最后一点。如果你知道你在做什么，你可能想在非常具体的情况下使用它。尽管它被认为是“邪恶的”，但它拥有很大的力量。在某些情况下使用它是可以接受的，例如当你创建模板引擎、你自己的解释器和所有其他
    JavaScript 核心工具时。只是要小心危险，并仔细控制对这个方法的访问。还有一个最后的技巧，当你觉得你真的必须使用 eval 时，在网上快速搜索一下。很可能你会找到一个更好的方法。
- en: Array methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组方法
- en: We have seen arrays already—they can contain multiple items. We have also seen
    quite a few built-in methods on arrays, like `shift()` and `push()`. Let's look
    at a few more in the following sections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了数组——它们可以包含多个项目。我们也看到了数组上的一些内置方法，如 `shift()` 和 `push()`。让我们在接下来的几节中看看更多。
- en: Performing a certain action for every item
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对每个项目执行特定操作
- en: 'There is a reason we are starting with this method. You might be thinking of
    loops at this point, but there is a built-in method that you can use to execute
    a function for every element in the array. This is the `forEach()` method. We
    mentioned this briefly in *Chapter 6*, *Functions*, but let''s consider it in
    some more detail. It takes the function that needs to be executed for every element
    as input. Here you can see an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以从这种方法开始，是有原因的。您可能此时正在考虑循环，但有一个内置的方法可以用来为数组中的每个元素执行一个函数。这就是 `forEach()`
    方法。我们在 *第 6 章*，*函数* 中简要提到了它，但让我们更详细地考虑它。它接受需要为每个元素执行的函数作为输入。这里您可以看到一个示例：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code snippet will write to the console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将写入控制台：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, it called the `printStuff()` function for every element in the
    array. And we can also use the index, it is the second parameter. We don't need
    to control the flow of the loop here and we cannot get stuck at a certain point.
    We just need to specify what function needs to be executed for every element.
    And the element will be input for this function. This is used a lot, especially
    for a more functional programming style in which many methods get chained, for
    example, to process data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它为数组中的每个元素调用了 `printStuff()` 函数。我们还可以使用索引，它是第二个参数。我们不需要控制循环的流程，我们也不能在某个点上卡住。我们只需要指定需要为每个元素执行哪个函数。这个元素将被输入到这个函数中。这被广泛使用，尤其是在更函数式编程风格的场景中，其中许多方法被链式使用，例如，处理数据。
- en: Filtering an array
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤数组
- en: 'We can use the built-in `filter()` method on an array to alter which values
    are in the array. The filter method takes a function as an argument, and this
    function should return a Boolean. If the Boolean has the value `true`, the element
    will end up in the filtered array. If the Boolean has the value `false`, the element
    will be left out. You can see how it works here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组上的内置 `filter()` 方法来改变数组中的值。`filter()` 方法接受一个函数作为参数，这个函数应该返回一个布尔值。如果布尔值为
    `true`，则元素将最终出现在过滤后的数组中。如果布尔值为 `false`，则元素将被排除在外。您可以看到它是如何工作的：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will log to the console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is important to realize that the original array has not changed, the `filter()`
    method returns a new array with the elements that made it through the filter.
    We capture it here in the variable `filterArr`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到原始数组没有改变，`filter()` 方法返回一个包含通过过滤器的元素的新数组。我们在这里将这个新数组捕获到变量 `filterArr`
    中。
- en: Checking a condition for all elements
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查所有元素的条件
- en: 'You can use the `every()` method to see whether something is true for all elements
    in the array. If that is the case, the `every()` method will return `true`, else
    it will return `false`. We are using the `checkString()` function and array from
    the previous example here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `every()` 方法来检查数组中所有元素是否都满足某个条件。如果是这样，`every()` 方法将返回 `true`，否则将返回 `false`。我们在这里使用前一个例子中的
    `checkString()` 函数和数组：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will log `false`, since not all elements are of type `string` in the array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `false`，因为数组中并非所有元素都是 `string` 类型。
- en: Replacing part of an array with another part of the array
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用数组的另一部分替换数组的一部分
- en: 'The `copyWithin()` method can be used to replace a part of the array with another
    part of the array. In the first example we specify 3 arguments. The first one
    is the target position, to which the values get copied. The second one is the
    start of what to copy to the target position and the last one is the end of the
    sequence that will be copied to the target position; this last index is not included.
    Here we are only going to override position 0 with whatever is in position 3:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithin()` 方法可以用来用数组的另一部分替换数组的一部分。在第一个例子中，我们指定了 3 个参数。第一个参数是目标位置，值将被复制到该位置。第二个参数是要复制到目标位置的起始位置，最后一个参数是要复制到目标位置的序列的结束位置；这个最后一个索引不包括在内。这里我们只是用位置
    3 的值覆盖位置 0：'
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`arr` becomes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr` 变成了：'
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we specify a range with length `2`, the first two elements after the starting
    position get overridden:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定长度为 `2` 的范围，则从起始位置开始的前两个元素将被覆盖：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And now `arr` becomes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `arr` 变成了：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also not specify an end at all; it will take the range to the end of
    the string:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以完全不指定结束；它将取到字符串的末尾：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will log:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is important to keep in mind that this function changes the *content* of
    the original array, but will never change the *length* of the original array.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这个函数会改变原始数组的*内容*，但永远不会改变原始数组的*长度*。
- en: Mapping the values of an array
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射数组的值
- en: 'Sometimes you''ll need to change all the values in an array. With the array
    `map()` method you can do just that. This method will return a new array with
    all the new values. You''ll have to say how to create these new values. This can
    be done with the arrow function. It is going to execute the arrow function for
    every element in the array, so for example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要改变数组中的所有值。使用数组的`map()`方法，你可以做到这一点。这个方法将返回一个包含所有新值的新数组。你将必须说明如何创建这些新值。这可以通过箭头函数来完成。它将为数组中的每个元素执行箭头函数，例如：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is what the console output with the new mapped array looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新映射数组在控制台输出的样子：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the arrow function, the `map()` method has created a new array, in which
    each of the original array values has been increased by 1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，`map()`方法创建了一个新数组，其中每个原始数组值都增加了1。
- en: Finding the last occurrence in an array
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中查找最后一个出现的位置
- en: We can find occurrences with `indexOf()` as we have seen already. To find the
    last occurrence, we can use the `lastIndexOf()` method on an array, just as we
    did for `string`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`indexOf()`找到出现，就像我们已经看到的那样。要找到最后一个出现，我们可以使用数组上的`lastIndexOf()`方法，就像我们对`string`做的那样。
- en: 'It will return the index of the last element with that value, if it can find
    it at all:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它能找到具有该值的最后一个元素，它将返回该元素的索引：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will log `2`, because the index 2 holds the last `bye` variable. What do
    you think you'll get when you ask for the last index of something that's not there?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录`2`，因为索引2持有最后一个`bye`变量。当你请求一个不存在的东西的最后一个索引时，你认为你会得到什么？
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's right (hopefully)! It's `-1`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对的（希望如此）！它是`-1`。
- en: Practice exercise 8.2
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.2
- en: 'Remove duplicates from the array using `filter()` and `indexOf()`. The starting
    array is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter()`和`indexOf()`从数组中删除重复项。起始数组是：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using the array `filter()` method, this will create a new array using the elements
    that pass the test condition implemented by the function. The final result will
    be:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组`filter()`方法，这将创建一个新数组，使用通过函数实现的测试条件通过的元素。最终结果将是：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Take the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤：
- en: Create an array of names of people. Make sure you include duplicates. The exercise
    will remove the duplicate names.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含人名的数组。确保你包含重复的名字。这个练习将删除重复的名字。
- en: Using the `filter()` method, assign the results of each item from the array
    as arguments within an anonymous function. Using the value, index, and array arguments,
    return the filtered result. You can set the return value to `true` temporarily
    as this will build the new array with all the results in the original array.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`方法，将数组中每个项目的结果作为匿名函数内的参数。使用值、索引和数组参数，返回过滤后的结果。你可以暂时将返回值设置为`true`，因为这将使用原始数组中的所有结果构建新数组。
- en: Add a `console.log` call within the function that will output the index value
    of the current item in the array. Also add the value so you can see the results
    of the item value that has the current index number and the first matching result
    from the array's index value.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内添加一个`console.log`调用，该调用将输出数组中当前项目的索引值。同时添加值，以便你可以看到具有当前索引号的项值以及数组索引值的第一匹配结果。
- en: Using `indexOf()` the current value returns the index value of the item and
    applies the condition to check to see if it matches the original index value.
    This condition will only be true on the first result so all subsequent duplicates
    will be false and not get added to the new array. `false` will not return the
    value into the new array. The duplicates will all be false since the `indexof()`
    only gets the first match in the array.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`indexOf()`当前值返回项目索引值，并应用条件检查是否与原始索引值匹配。这个条件只会在第一个结果上为真，所以所有后续的重复项都将为假，并且不会添加到新数组中。`false`不会将值返回到新数组中。由于`indexOf()`只获取数组中的第一个匹配项，所以重复项都将为假。
- en: Output the new, unique value array onto the console.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的唯一值数组输出到控制台。
- en: Practice exercise 8.3
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.3
- en: 'Using the array `map()` method, update an array''s contents. Take the following
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组`map()`方法更新数组的内 容。采取以下步骤：
- en: Create an array of numbers.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数字数组。
- en: Using the array `map` method and an anonymous function, return an updated array,
    multiplying all the numbers in the array by 2\. Output the result into the console.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组 `map` 方法和一个匿名函数，返回一个更新后的数组，将数组中的所有数字乘以 2。将结果输出到控制台。
- en: As an alternative method, use the arrow function format to multiply each element
    of the array by 2 with the array `map()` method in one line of code.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为另一种方法，使用箭头函数格式，通过一行代码使用数组的 `map()` 方法将数组的每个元素乘以 2。
- en: Log the result onto the console.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果记录到控制台。
- en: String methods
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串方法
- en: We have worked with strings already and chances are that you have run into some
    of the methods on strings by now. There are a few we didn't address specifically
    just yet and we are going to discuss them in this section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理过字符串了，你很可能已经遇到了一些字符串方法。有一些我们没有特别说明，我们将在本节中讨论它们。
- en: Combining strings
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的合并
- en: 'When you want to concatenate strings, you can use the `concat()` method. This
    does not change the original string(s); it returns the combined result as a string.
    You will have to capture the result in a new variable, else it will get lost:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想连接字符串时，可以使用 `concat()` 方法。这不会改变原始字符串（们）；它返回作为字符串的合并结果。你必须将结果捕获到新变量中，否则它将丢失：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will log:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Converting a string to an array
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串转换为数组
- en: 'With the `split()` method we can convert a string to an array. Again, we will
    have to capture the result; it is not changing the original string. Let''s use
    the previous result containing `Hello JavaScript`. We will have to tell the `split`
    method on what string it should split. Every time it encounters that string, it
    will create a new array item:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `split()` 方法我们可以将字符串转换为数组。同样，我们还需要捕获结果；它不会改变原始字符串。让我们使用包含 `Hello JavaScript`
    的上一个结果。我们必须告诉 `split` 方法它应该在哪个字符串上分割。每次它遇到该字符串时，它都会创建一个新的数组项：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will log:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, it creates an array of all the elements separated by a space.
    We can split by any character, for example a comma:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它创建了一个由空格分隔的所有元素的数组。我们可以按任何字符分割，例如逗号：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will log:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It has now created an array with 3 items. You can split on anything, and the
    string you are splitting on is left out of the result.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已创建一个包含 3 个元素的数组。你可以根据任何内容进行分割，而你正在分割的字符串将不包括在结果中。
- en: Converting an array to a string
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数组转换为字符串
- en: 'With the `join()` method you can convert an array to a string. Here is a basic
    example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法可以将数组转换为字符串。以下是一个基本示例：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will log:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The type of `x` is `string`. If you want something else other than a comma,
    you can specify that, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 的类型是 `string`。如果你想用其他东西而不是逗号，你可以指定它，就像这样：'
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will use the `–` instead of the comma. This is the result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `–` 而不是逗号。这是结果：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This can be nicely combined with the `split()` method that we covered in the
    previous section, which does the reverse and converts a string into an array.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很好地与我们在上一节中介绍的 `split()` 方法结合使用，它执行相反的操作，将字符串转换为数组。
- en: Working with index and positions
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理索引和位置
- en: 'Being able to find out what index a certain substring is at within your string
    is very useful. For example, when you need to search for a certain word through
    the user input of a log file and create a substring starting at that index. Here
    is an example of how to find the index of a string. The `indexOf()` method returns
    the index, a single number, of the first character of the substring:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 能够找出字符串中某个子字符串的索引非常有用。例如，当你需要通过日志文件的用户输入搜索某个特定单词并从该索引开始创建子字符串时。以下是如何找到字符串索引的示例。`indexOf()`
    方法返回子字符串的第一个字符的索引，一个单一的数字：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is logging `7` to the console, because the first occurrence of `re` is
    in `are`, and the `re` begins at index `7`. When it can''t find an index, it will
    return `-1`, like this example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台记录 `7`，因为 `re` 在 `are` 中的第一次出现是在索引 `7`。当它找不到索引时，它将返回 `-1`，就像这个例子一样：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It is logging `-1` to indicate that the string we are searching for doesn''t
    occur in the target string. Often you will write an `if` check to see whether
    it''s `-1` before dealing with the result. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它记录 `-1` 来指示我们正在搜索的字符串在目标字符串中不存在。通常你会在处理结果之前编写一个 `if` 检查来查看它是否为 `-1`。例如：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An alternative way of searching for a particular substring within a string
    is to use the `search()` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中搜索特定子字符串的另一种方法是使用 `search()` 方法：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will log `17`, because that is the index of `lo` in `fellow`. Much like
    `indexOf()`, if it cannot find it, it will return `-1`. This is the case for this
    example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `17`，因为这是 `lo` 在 `fellow` 中的索引。与 `indexOf()` 类似，如果找不到，它将返回 `-1`。这个例子就是这样：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`search()` will accept a regex format as input, whereas `indexOf()` just takes
    a string. `indexOf()` is faster than the `search()` method, so if you just need
    to look for a string, use `indexOf()`. If you need to look for a string pattern,
    you''ll have to use the `search()` method.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()` 方法可以接受正则表达式格式作为输入，而 `indexOf()` 只接受一个字符串。`indexOf()` 比搜索方法更快，所以如果你只需要查找一个字符串，请使用
    `indexOf()`。如果你需要查找字符串模式，你必须使用 `search()` 方法。'
- en: Regex is a special syntax for defining string patterns, with which you can replace
    all occurrences, but we'll deal with that in *Chapter 12*, *Intermediate JavaScript*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是定义字符串模式的特殊语法，你可以用它来替换所有出现，但我们将在 *第 12 章*，*中级 JavaScript* 中处理它。
- en: 'Moving on, the `indexOf()` method is returning the index of the first occurrence,
    but similarly, we also have a `lastIndexOf()` method. It returns the index where
    the argument string occurs last. If it cannot find it, it returns `-1`. Here is
    an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`indexOf()` 方法返回第一次出现的索引，但同样，我们还有一个 `lastIndexOf()` 方法。它返回参数字符串最后一次出现的位置。如果找不到，它返回
    `-1`。以下是一个示例：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This returns `24`; this is the last time `re` appears in our poem. It is the
    second `are`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回 `24`；这是 `re` 在我们的诗中最后一次出现。它是第二个 `are`。
- en: 'Sometimes you will have to do the reverse; instead of looking for what index
    a string occurs at, you will want to know what character is at a certain index
    position. This is where the `charAt(index)` method comes in handy, where the specified
    index position is taken as an argument:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要做相反的操作；不是寻找字符串出现的索引，而是想知道某个索引位置上的字符是什么。这就是 `charAt(index)` 方法派上用场的地方，其中指定的索引位置作为参数：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is logging `r`, because the character at index 10 is the `r` of `red`.
    If you are asking for the position of an index that is out of the range of the
    string, it will return an empty string, as is happening in this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在记录 `r`，因为索引 10 的字符是 `red` 中的 `r`。如果你询问的索引位置超出了字符串的范围，它将返回一个空字符串，就像在这个例子中发生的那样：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will log an empty line to the screen, and if you ask for the type of `pos2`,
    it will return `string`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上输出一个空行，如果你询问 `pos2` 的类型，它将返回 `string`。
- en: Creating substrings
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子字符串
- en: 'With the `slice(start, end)` method we can create substrings. This does not
    alter the original string, but returns a new string with the substring. It takes
    two parameters, the first is the index at which it starts and the second is the
    end index. If you leave out the second index it will just continue until the end
    of the string from the start. The end index is not included in the substring.
    Here is an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `slice(start, end)` 方法我们可以创建子字符串。这不会改变原始字符串，而是返回一个新的包含子字符串的字符串。它接受两个参数，第一个是开始索引的位置，第二个是结束索引。如果你省略第二个索引，它将从开始位置继续到字符串的末尾。结束索引不包括在子字符串中。以下是一个示例：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will log:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first one only has one argument, so it starts at index 5 (which holds an
    `e`) and grabs the rest of the string from there. The second one has two arguments,
    `0` and `3`. `C` is at index 0 and `a` is at index 3\. Since the last index is
    not included in the substring, it will only return `Cre`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个只有一个参数，所以它从索引 5（包含一个 `e`）开始，并从那里获取字符串的其余部分。第二个有两个参数，`0` 和 `3`。`C` 在索引 0，`a`
    在索引 3。由于最后一个索引不包括在子字符串中，它只会返回 `Cre`。
- en: Replacing parts of the string
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换字符串的一部分
- en: 'If you need to replace a part of the string, you can use the `replace(old,
    new)` method. It takes two arguments, one string to look for in the string and
    one new value to replace the old value with. Here is an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要替换字符串的一部分，你可以使用 `replace(old, new)` 方法。它接受两个参数，一个是要在字符串中查找的字符串，一个是要替换旧值的新的值。以下是一个示例：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will log to the console `Hi Pascal`. If you don''t capture the result,
    it is gone, because the original string will not get changed. If the string you
    are targeting doesn''t appear in the original string, the replacement doesn''t
    take place and the original string will be returned:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出 `Hi Pascal`。如果你没有捕获结果，它就会消失，因为原始字符串不会改变。如果你要替换的字符串在原始字符串中不存在，替换不会发生，原始字符串将被返回：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This logs `Hi buddy`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这记录了 `Hi buddy`。
- en: 'One last note here, it is only changing the first occurrence by default. So
    this example will only replace the first `hello` in the new string:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是，默认情况下它只会改变第一次出现的位置。所以这个例子只会替换新字符串中的第一个 `hello`：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This logs `oh hello`. If we wanted to replace all the occurences, we could
    use the `replaceAll()` method. This will replace all occurrences with the specified
    new string, like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这会记录 `oh hello`。如果我们想替换所有出现的位置，我们可以使用 `replaceAll()` 方法。这将用指定的新字符串替换所有出现的位置，如下所示：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This logs `oh oh`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这会记录 `oh oh`。
- en: Uppercase and lowercase
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写和小写
- en: 'We can change the letters of a string with the `toUpperCase()` and `toLowerCase()`
    built-in methods on `string`. Again, this is not changing the original string,
    so we''ll have to capture the result:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `string` 上的内置方法 `toUpperCase()` 和 `toLowerCase()` 来改变字符串的字母。再次强调，这并不会改变原始字符串，所以我们需要捕获结果：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This logs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这会记录：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It converts all the letters to uppercase. We can do the opposite with `toLowerCase()`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它将所有字母转换为大写。我们可以使用 `toLowerCase()` 来做相反的操作：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This will log:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这会记录：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s make it a bit more complicated and say that we''d like the first letter
    of the sentence to be capitalized. We can do this by combining some of the methods
    we have seen already right now:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让它更复杂一些，比如说我们想要句子的第一个字母大写。我们可以通过结合我们现在已经看到的一些方法来实现这一点：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are chaining the methods here; we first grab the first character of `fixed_caps`
    with `charAt(0)` and then make it uppercase by calling `toUpperCase()` on it.
    We then need the rest of the string and we get it by concatenating `slice(1)`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里正在链式调用方法；我们首先使用 `charAt(0)` 获取 `fixed_caps` 的第一个字符，然后通过调用 `toUpperCase()`
    来将其转换为大写。然后我们需要字符串的其余部分，我们可以通过连接 `slice(1)` 来获取它。
- en: The start and end of a string
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的开始和结束
- en: 'Sometimes you would want to check what a string starts or ends with. You''ve
    guessed it, there are built-in methods for this on `string`. We can imagine this
    chapter is tough to work through, so here is a little encouragement and an example
    at the same time:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能会想检查一个字符串的开始或结束部分。你已经猜到了，`string` 上有内置方法可以做到这一点。我们可以想象这一章很难理解，所以这里有一点点鼓励，同时也是一个例子：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will log `true` to the console, because the sentence starts with `You`.
    Careful here, because it is case sensitive. So the following example will log
    `false`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出 `true`，因为句子以 `You` 开头。请注意，这是大小写敏感的。所以下面的例子将输出 `false`：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you don''t care about uppercase or lowercase, you can use the previously
    discussed `toLowerCase()` method here, so that it will not take uppercase or lowercase into
    account:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎大小写，你可以在之前讨论的 `toLowerCase()` 方法中使用它，这样它就不会考虑大小写。
- en: '[PRE72]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We are now converting the string to lowercase first, so we know we are only
    working with lowercase characters here. However, an important side note here is
    that this will affect performance for huge strings.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将字符串转换为小写，这样我们就知道我们在这里只处理小写字母。然而，这里的一个重要注意事项是，这将对大字符串的性能产生影响。
- en: Again, a more performance-friendly alternative is to use regex. Getting excited
    for *Chapter 12*, *Intermediate JavaScript*, yet?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一个更高效的替代方案是使用正则表达式。对 *第 12 章*，*中级 JavaScript* 感到兴奋了吗？
- en: 'To end this section, we can do the same thing for checking whether a string
    ends with a certain string. You can see it in action here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一节，我们可以对检查字符串是否以特定字符串结束做同样的事情。你可以在这里看到它的实际应用：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Since it doesn't end with `Something else`, it will return `false`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它不以 `Something else` 结尾，所以它将返回 `false`。
- en: Practice exercise 8.4
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.4
- en: 'Using string manipulation, create a function that will return a string with
    the first letter of all the words capitalized and the rest of the letters in lowercase.
    You should transform the sentence `thIs will be capiTalized for each word` into
    `This Will Be Capitalized For Each Word`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串操作，创建一个函数，该函数将返回一个字符串，其中所有单词的首字母大写，其余字母小写。你应该将句子 `thIs will be capiTalized
    for each word` 转换为 `This Will Be Capitalized For Each Word`：
- en: Create a string with several words that have letters with different cases, a
    mix of upper and lowercase words.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含不同大小写字母的单词的字符串，包括大写和小写的单词混合。
- en: Create a function that gets a string as an argument, which will be the value
    that we will manipulate.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数接受一个字符串作为参数，这是我们将会操作的值。
- en: In the function first transform everything to lowercase letters.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中首先将所有内容转换为小写字母。
- en: Create an empty array that can hold the values of the words when we capitalize
    them.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空数组，用于存储当我们将单词大写时它们的值。
- en: Convert the phrase into words in an array using the `split()` method.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `split()` 方法将短语转换为单词数组。
- en: Loop through each one of the words that are now in the new array, so you can
    select each one independently. You can use `forEach()` for this.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历新数组中的每个单词，以便你可以独立选择每个单词。你可以使用 `forEach()` 来做这个。
- en: Using `slice()` isolate the first letter in each word, then transform it to
    uppercase. Again using `slice()`, get the remaining value of the word without
    including the first letter. Then concatenate the two together to form the word
    that is now capitalized.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `slice()` 从每个单词中隔离第一个字母，然后将其转换为大写。再次使用 `slice()`，获取不包括第一个字母的单词剩余部分。然后将这两个部分连接起来，形成现在已大写的单词。
- en: Add the new capitalized word into the blank array that you created. By the end
    of the loop you should have an array with all the words as separate items in the
    new array.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的大写单词添加到您创建的空白数组中。循环结束时，你应该有一个包含所有单词作为新数组中单独项目的数组。
- en: Take the array of updated words and using the `join()` method, transform them
    back into a string with spaces between each word.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法将更新后的单词数组转换回一个字符串，单词之间用空格分隔。
- en: Return the value of the newly updated string with capitalized words that can
    then be output into the console.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回更新后带有大写单词的新字符串的值，然后可以将其输出到控制台。
- en: Practice exercise 8.5
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.5
- en: 'Using the `replace()` string method, complete this vowel replacer exercise
    by replacing the vowels in a string with numbers. You can start with this string:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `replace()` 字符串方法，通过将字符串中的元音字母替换为数字来完成这个元音替换练习。你可以从以下字符串开始：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And turn it into something like the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其转换为以下类似的内容：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Take the following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤操作：
- en: Create the previously specified string, and convert it to lowercase.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建之前指定的字符串，并将其转换为小写。
- en: 'Create an array containing the vowels: a, e, i, o, u.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含元音字母的数组：a, e, i, o, u。
- en: Loop through each letter you have in the array, and output the current letter
    into the console so that you can see which letter will be converted.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历数组中的每个字母，并将当前字母输出到控制台，以便你可以看到哪个字母将被转换。
- en: Within the loop, using `replaceAll()` update each vowel substring with the index
    value of the letter from the vowel array.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，使用 `replaceAll()` 更新每个元音子字符串，使用元音数组中字母的索引值。
- en: Using `replace()` will only replace the first occurrence; if you use `replaceAll()`
    this will update all matching results.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `replace()` 只会替换第一次出现的内容；如果你使用 `replaceAll()`，这将更新所有匹配的结果。
- en: Once the loop completes output the result of the new string into the console.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成后，将新字符串的结果输出到控制台。
- en: Number methods
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字方法
- en: Let's move on to some built-in methods on the `Number` object. We have seen
    a few already, these are so popular that some of them have been made into global
    methods.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习 `Number` 对象的一些内置方法。我们已经见过一些了，它们非常受欢迎，以至于其中一些已经被做成全局方法。
- en: Checking if something is (not) a number
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查某个值是否（不是）一个数字
- en: 'This can be done with `isNaN()`. We have seen this already when we talked about
    global methods, we can use this method without `Number` in front of it. Often
    you will want to do the opposite, you can negate the function with an `!` in front
    of it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用 `isNaN()` 来做。我们已经在讨论全局方法时见过这个方法，我们可以在它前面不加 `Number` 使用这个方法。通常你想要做的是相反的操作，你可以在函数前面加一个
    `!` 来取反：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will log to the console:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Since `x` is a number, `isNaN` will be `false`. But this result negated becomes
    `true`, since `x` is a number. The string `hi` is not a number, so it will become
    `false`. And this one?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x` 是一个数字，`isNaN` 将为 `false`。但这个结果取反后变为 `true`，因为 `x` 是一个数字。字符串 `hi` 不是一个数字，所以它将变为
    `false`。那么这个呢？
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Some funky stuff is going on here, even though `5` is between quotation marks,
    JavaScript still sees that it's a 5 and it will log `false`. At this point, I'm
    sure you'd wish your partner, family, and coworkers are as understanding and forgiving
    as JavaScript.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在进行一些有趣的操作，即使 `5` 在引号之间，JavaScript 仍然将其视为数字 5，并将输出 `false`。在这个时候，我相信你希望你的伴侣、家人和同事像
    JavaScript 一样理解和宽容。
- en: Checking if something is finite
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查某个值是否是有限的
- en: 'By now you might be able to guess the name of the method on `Number` that checks
    whether something is finite. It is a very popular one and has been made into a
    global method as well, and its name is `isFinite()`. It returns `false` for `NaN`,
    `Infinity`, and `undefined`, and `true` for all other values:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经能够猜出在 `Number` 上检查某个数是否有限的那个方法的名字。它是一个非常流行的方法，并且已经被做成全局方法，它的名字是 `isFinite()`。对于
    `NaN`、`Infinity` 和 `undefined`，它返回 `false`，对于所有其他值返回 `true`：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This will log:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The only finite number in this list is `x`. The others are not finite. A string
    is a not a number and is therefore not finite. `Infinity` is not finite and `10`
    divided by `0` returns `Infinity` (not an error).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，唯一的有限数是 `x`。其他的都不是有限的。字符串不是一个数字，因此不是有限的。`Infinity` 也不是有限的，`10` 除以 `0`
    返回 `Infinity`（这不是一个错误）。
- en: Checking if something is an integer
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查是否为整数
- en: 'Yes, this is done with `isInteger()`. Unlike `isNaN()` and `isFinite()`, `isInteger()`
    has not been made global and we will have to refer to the `Number` object to use
    it. It really does what you think it would: it returns `true` if the value is
    an integer and `false` when it''s not:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是用 `isInteger()` 做的。与 `isNaN()` 和 `isFinite()` 不同，`isInteger()` 没有被做成全局方法，我们必须引用
    `Number` 对象来使用它。它确实做了你想象中的事情：如果值是整数，它返回 `true`；如果不是，返回 `false`：
- en: '[PRE81]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will log:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE82]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Since the only integer in the list is `x`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表中唯一的整数是 `x`。
- en: Specifying a number of decimals
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定小数位数
- en: 'We can tell JavaScript how many decimals to use with the `toFixed()` method.
    This is different from the rounding methods in `Math`, since we can specify the
    number of decimals here. It doesn''t change the original value, so we''ll have
    to store the result:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `toFixed()` 方法告诉 JavaScript 使用多少位小数。这与 `Math` 中的四舍五入方法不同，因为我们可以在这里指定小数位数。它不会改变原始值，所以我们必须存储结果：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This will only leave two decimals, so the value of `newX` will be `1.23`. It
    rounds the number normally; you can see this when we ask for one more decimal:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只保留两位小数，所以 `newX` 的值将是 `1.23`。它按正常方式四舍五入；当你要求更多一位小数时，你可以看到这一点：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This logs `1.23456 1.235` as output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这记录了 `1.23456 1.235` 作为输出。
- en: Specifying precision
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定精度
- en: 'There is also a method to specify precision. Again this is different from the
    rounding methods in the `Math` class, since we can specify the total number of
    numbers to look at. This comes down to JavaScript looking at the total number
    of numbers. It is also counting the ones before the dot:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有一个方法可以指定精度。这又不同于 `Math` 类中的四舍五入方法，因为我们可以指定要查看的总数。这归结为 JavaScript 查看总数。它也在计算小数点前的数字：
- en: '[PRE85]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So the value of newX will be `1.2` here. And also here, it is rounding the
    numbers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里 `newX` 的值将是 `1.2`。同样，这里它也在进行四舍五入：
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This will log `1.235`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `1.235`。
- en: Now, let's move on and talk about some related mathematical methods!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论一些相关的数学方法！
- en: Math methods
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学方法
- en: The `Math` object has many methods that we can use to do calculations and operations
    on numbers. We will go over the most important ones here. You can see all the
    available ones when you use an editor that shows suggestions and options during typing.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 对象有许多方法，我们可以使用它们在数字上进行计算和操作。我们将在下面介绍最重要的几个。当你使用一个在输入时显示建议和选项的编辑器时，你可以看到所有可用的方法。'
- en: Finding the highest and lowest number
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找最大和最小数
- en: 'There is a built-in method `max()` to find the highest number among the arguments.
    You can see it here:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个内置的 `max()` 方法可以找到参数中的最大数。你可以在这里看到它：
- en: '[PRE87]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'It logs `233`, because that''s the highest number. In a similar way, we can
    find the lowest number:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它记录了 `233`，因为这是最大的数。以类似的方式，我们可以找到最小的数：
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This will log `1`, because that is the lowest number. If you try to do this
    with non-numeric arguments, you will get `NaN` as a result:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `1`，因为这是最小的数。如果你尝试用非数字参数做这个操作，你将得到 `NaN` 作为结果：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: It is not giving `3` as output, because it is not ignoring the text but concluding
    that it cannot determine whether `hi` should be higher or lower than `3`. So it
    returns `NaN` instead.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有输出 `3`，因为它不是忽略文本，而是得出结论，它无法确定 `hi` 应该是高于还是低于 `3`。因此，它返回 `NaN`。
- en: Square root and raising to the power of
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平方根和幂运算
- en: 'The method `sqrt()` is used to calculate the square root of a certain number.
    Here you can see it in action:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt()` 方法用于计算某个数的平方根。这里你可以看到它的实际应用：'
- en: '[PRE90]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This will log `8`, because the square root of `64` is `8`. This method works
    just like the mathematics you learned in school. In order to raise a number to
    a certain power (base^(exponent), for example 2³), we can use the `pow(base, exponent)`
    function. Like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录`8`，因为`64`的平方根是`8`。这种方法与你在学校学到的数学一样。为了将一个数提升到某个幂（例如2³），我们可以使用`pow(base,
    exponent)`函数。就像这样：
- en: '[PRE91]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We are raising `5` to the power of `3` here (5³), so the result will be `125`,
    which is the result of 5*5*5.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将`5`提升到`3`的幂（5³），所以结果是`125`，这是5*5*5的结果。
- en: Turning decimals into integers
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将小数转换为整数
- en: 'There are different ways to turn decimals into integers. Sometimes you will
    want to round a number. This you can do with the `round()` method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将小数转换为整数的方法有很多。有时你可能需要四舍五入一个数字。你可以使用`round()`方法来做这件事：
- en: '[PRE92]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This will log:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE93]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'As you can see it is using normal rounding here. It is also possible that you
    don''t want to round down, but up. For example, if you need to calculate how many
    wood boards you need and you conclude that you need `1.1`, `1` is not going to
    be enough to do the job. You''ll need `2`. In this case, you can use the `ceil()`
    method (referring to ceiling):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里使用的是正常的四舍五入。也可能你不想向下取整，而是向上取整。例如，如果你需要计算你需要多少块木板，你得出结论你需要`1.1`，`1`将不足以完成工作。你需要`2`。在这种情况下，你可以使用`ceil()`方法（即天花板）：
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This will log:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE95]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `ceil()` method is always rounding up to the first integer it encounters.
    We have used this before when we were generating random numbers! Careful with
    negative numbers here, because `-5` is higher than `-6`. This is how it works,
    as you can see in this example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ceil()`方法总是向上取整到遇到的第一个整数。我们之前在生成随机数时已经使用过这个方法了！注意这里的负数，因为`-5`比`-6`要大。这是它的工作方式，就像你在下面的例子中看到的那样：'
- en: '[PRE96]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This will log:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE97]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `floor()` method is doing the exact opposite of the `ceil()` method. It
    rounds down to the nearest integer number, as you can see here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`floor()`方法与`ceil()`方法正好相反。它向下取整到最接近的整数，就像你在这里看到的那样：'
- en: '[PRE98]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This will log:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE99]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Again, careful with negative numbers here, because it can feel counterintuitive:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，注意这里的负数，因为它可能感觉不太直观：
- en: '[PRE100]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This logs:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE101]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'And then one last method, `trunc()`. This gives the exact same result as `floor()`
    for positive numbers, but it gets to these results differently. It is not rounding
    down, it is simply only returning the integer part:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一个最后的方法，`trunc()`。对于正数，它给出的结果与`floor()`相同，但它得到这些结果的方式不同。它不是向下取整，它只是简单地返回整数部分：
- en: '[PRE102]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This will log:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE103]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'When we use negative numbers for `trunc()` we can see the difference:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用负数进行`trunc()`时，我们可以看到差异：
- en: '[PRE104]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: So whenever you need to round down, you'll have to use `floor()`, if you need
    the integer part of the number, you'll need `trunc()`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，每当你需要向下取整时，你将不得不使用`floor()`，如果你需要数字的整数部分，你需要`trunc()`。
- en: Exponent and logarithm
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数和对数
- en: 'The exponent is the number to which a base is being raised. We use `e` (Euler''s
    number) a lot in mathematics, this is what the `exp()` method in JavaScript does.
    It returns the number to which `e` must be raised to get the input. We can use
    the `exp()` built-in method of `Math` to calculate the exponent, and the `log()`
    method to calculate the natural logarithm. You can see an example here:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 指数是基数被提升到的数。在数学中，我们经常使用`e`（欧拉数），这就是JavaScript中的`exp()`方法所做的工作。它返回`e`必须提升到的数以得到输入。我们可以使用`Math`的内置`exp()`方法来计算指数，以及`log()`方法来计算自然对数。你可以在这里看到一个例子：
- en: '[PRE105]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This will log:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE106]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Don't worry if you can't follow along mathematically at this point. You'll figure
    this out whenever you'll need it for your programming.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在数学上跟不上了，不要担心。当你需要编程时，你会弄明白的。
- en: Practice exercise 8.6
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题8.6
- en: 'Experiment with the `Math` object with these steps:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤实验`Math`对象：
- en: Output the value of `PI` into the console using `Math`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math`将`PI`的值输出到控制台。
- en: Using `Math` get the `ceil()` value of `5.7`, get the `floor()` value of `5.7`,
    get the round value of `5.7`, and output it into the console.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math`获取`5.7`的`ceil()`值，获取`5.7`的`floor()`值，获取`5.7`的舍入值，并将其输出到控制台。
- en: Output a random value into the console.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将随机值输出到控制台。
- en: Use `Math.floor()` and `Math.random()` to get a number from 0 to 10.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math.floor()`和`Math.random()`从0到10获取一个数字。
- en: Use `Math.floor()` and `Math.random()` to get a number from 1 to 10.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math.floor()`和`Math.random()`从1到10获取一个数字。
- en: Use `Math.floor()` and `Math.random()` to get a number from 1 to 100.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math.floor()`和`Math.random()`从1到100获取一个数字。
- en: Create a function to generate a random number using the parameters of `min`
    and `max`. Run that function 100 times, returning into the console a random number
    from 1 to 100 each time.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用 `min` 和 `max` 参数生成随机数。运行该函数 100 次，每次在控制台返回一个 1 到 100 的随机数。
- en: Date methods
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期方法
- en: In order to work with dates in JavaScript we use the built-in `Date` object.
    This object contains a lot of built-in functions to work with dates.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 JavaScript 中处理日期，我们使用内置的 `Date` 对象。此对象包含许多内置函数，用于处理日期。
- en: Creating dates
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建日期
- en: 'There are different ways to create a date. One way to create dates is by using
    the different constructors. You can see some examples here:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 创建日期有不同的方法。创建日期的一种方法是通过使用不同的构造函数。您在这里可以看到一些示例：
- en: '[PRE107]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This will log the current date and time, in this case:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录当前日期和时间，在这种情况下：
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'But, this way we are not using the built-in method, but the constructor. There
    is a built-in method, `now()`, that returns the current date and time, similar
    to what the no argument constructor does:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们这里不是使用内置方法，而是使用构造函数。有一个内置方法，`now()`，它返回当前日期和时间，类似于无参数构造函数所做的那样：
- en: '[PRE109]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This will log the current time, represented in seconds since January 1^(st)
    1970\. This is an arbitrary date representing the Unix epoch. In this case:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录当前时间，以自 1970 年 1 月 1 日以来的秒数表示。这是一个表示 Unix 纪元的任意日期。在这种情况下：
- en: '[PRE110]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can add 1,000 milliseconds to the Unix epoch time:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 Unix 纪元时间添加 1,000 毫秒：
- en: '[PRE111]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'It will log:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 它将记录：
- en: '[PRE112]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'JavaScript can also convert many string formats to a date. Always mind the
    order in which days and months of dates are presented in the date format and the
    interpreter of JavaScript. This can vary depending on the region:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也可以将许多字符串格式转换为日期。始终注意日期格式中日期和月份的顺序以及 JavaScript 的解释器。这可能会根据地区而变化：
- en: '[PRE113]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This will log:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE114]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And lastly, you can also specify a certain date using the constructor:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以使用构造函数指定一个特定日期：
- en: '[PRE115]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This will log:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE116]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Please mind this very important detail here, the second parameter is the month.
    `0` is for January and `11` is for December.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的一个非常重要的细节，第二个参数是月份。`0` 代表一月，`11` 代表十二月。
- en: Methods to get and set the elements of a date
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置日期元素的函数
- en: 'Now we have seen how to create dates, we''ll learn how to get certain parts
    of dates. This can be done with one of the many `get` methods. Which you will
    use depends on the part you need:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建日期，我们将学习如何获取日期的某些部分。这可以通过许多 `get` 方法之一来完成。您将使用哪个取决于您需要哪个部分：
- en: '[PRE117]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This will log right now:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即记录：
- en: '[PRE118]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The time is so high because it''s the number of milliseconds since January
    1^(st) 1970\. You can change the date in a similar way with a `set` method. Important
    to note here is that the original date object gets changed with these set methods:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 时间如此之高，因为它是从 1970 年 1 月 1 日以来的毫秒数。您可以使用类似的 `set` 方法更改日期。这里需要注意的是，原始日期对象会通过这些设置方法被更改：
- en: '[PRE119]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We have changed the year of our date object to 2010\. This will output:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的日期对象的年份更改为 2010 年。这将输出：
- en: '[PRE120]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We can also change the month. Let''s add the below snippet to our change of
    the year code. This will change it to October. Please mind that while I''m doing
    this, I run the code again and again, so the minutes and smaller units of time
    will vary in the examples when I haven''t set these yet:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改月份。让我们将以下代码片段添加到我们的年份更改代码中。这将将其更改为十月。请注意，当我这样做的时候，我会反复运行代码，所以当我没有设置这些时，示例中的分钟和更小的时间单位将会变化：
- en: '[PRE121]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'It will log:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 它将记录：
- en: '[PRE122]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This is a weird one, in order to change the day, we have to call the `setDate()`
    method and not the `setDay()` method. There is no `setDay()` method, since the
    day of the week is deducted from the specific date. We cannot change that September
    5^(th) 2021 is a Sunday. We can change the number of days of the month though:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个奇怪的情况，为了更改日期，我们必须调用 `setDate()` 方法，而不是 `setDay()` 方法。没有 `setDay()` 方法，因为星期几是从特定日期中扣除的。我们不能改变
    2021 年 9 月 5 日是星期日的事实。不过，我们可以更改月份中的天数：
- en: '[PRE123]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This will log:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE124]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can also change the hours:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改小时：
- en: '[PRE125]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now it will log:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将记录：
- en: '[PRE126]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Remember how JavaScript doesn't like to crash? If you call `setHours()` with
    a number higher than 24, it will roll over to the next date (1 per 24 hours) and
    after using the modulo operator, whatever is left over from `hours % 24` will
    be the hours. The same process applies for minutes, seconds, and milliseconds.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 JavaScript 不喜欢崩溃吗？如果您使用大于 24 的数字调用 `setHours()`，它将滚动到下一个日期（每 24 小时一个），并且在使用模运算符后，`hours
    % 24` 剩余的部分将是小时。同样的过程适用于分钟、秒和毫秒。
- en: 'The `setTime()` actually overrides the complete date with the inserted epoch
    time:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTime()`实际上用插入的纪元时间覆盖了完整的日期：'
- en: '[PRE127]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This will log:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE128]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Parsing dates
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析日期
- en: 'With the built-in `parse()` method we can parse epoch dates from strings. It
    accepts many formats, but again you will have to be careful with the order of
    days and months:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`parse()`方法，我们可以从字符串中解析纪元日期。它接受许多格式，但同样，你需要注意日期和月份的顺序：
- en: '[PRE129]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This will log:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE130]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'As you can see it ends with many zeros, because no time or seconds are specified
    in our string. And here is another example of a completely different format:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它以许多零结尾，因为我们没有在字符串中指定时间或秒。这里还有一个完全不同格式的例子：
- en: '[PRE131]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This will also log:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将记录：
- en: '[PRE132]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The input for the parse is ISO formats of dates. Quite a few formats can be
    parsed to string, but you'll have to be careful. The result might depend on the
    exact implementation. Make sure that you know what the format of the incoming
    string is, so that you don't confuse months and days, and make sure that you know
    the behavior of the implementations. This can only be done reliably if you know
    what the string format is. So for example when you need to convert data coming
    from your own database or website's date picker.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的输入是日期的ISO格式。许多格式可以解析为字符串，但你需要小心。结果可能取决于确切的实现。确保你知道传入字符串的格式，以免混淆月份和日期，并确保你知道实现的行为了。只有当你知道字符串格式时，才能可靠地完成这项工作。例如，当你需要将来自你自己的数据库或网站日期选择器的数据转换为日期时。
- en: Converting a date to a string
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日期转换为字符串
- en: 'We can also convert dates back to strings. For example with these methods:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将日期转换回字符串。例如，使用这些方法：
- en: '[PRE133]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This will log the day in written format:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录以文字格式表示的日期：
- en: '[PRE134]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This is another method that converts it differently:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种不同的转换方法：
- en: '[PRE135]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'It will log:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 它将记录：
- en: '[PRE136]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Practice exercise 8.7
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题8.7
- en: 'Output the date with the full month name into the console. When converting
    to or from arrays, remember that they are zero-based:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将完整的月份名称输出到控制台中的日期。在转换到或从数组时，请记住它们是零基的：
- en: Set up a date object, which can be any date in the future or past. Log the date
    out into the console to see how it is typically output as a date object.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个日期对象，可以是未来的任何日期或过去的日期。将日期输出到控制台以查看它通常如何作为日期对象输出。
- en: Set up an array with all the named months of the year. Keep them in sequential
    order so that they will match the date month output.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个包含一年中所有月份名称的数组。保持它们的顺序，以便它们与日期月份输出相匹配。
- en: Get the day from the date object value, using `getDate()`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getDate()`从日期对象值中获取日期。
- en: Get the year from the date object value, using `getFullYear()`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从日期对象值中获取年份，使用`getFullYear()`。
- en: Get the month of the date object value, using `getMonth()`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getMonth()`从日期对象值中获取月份。
- en: Set up a variable to hold the date of the date object and output the month using
    the numeric value as the index for the array month name. Due to arrays being zero-based
    and the month returning a value of 1-12, the result needs to be subtracted by
    one.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个变量来存储日期对象中的日期，并使用数组月份名称的数值作为索引输出月份。由于数组是零基的，月份返回的值为1-12，因此结果需要减去1。
- en: Output the result into the console.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果输出到控制台。
- en: Chapter projects
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Word scrambler
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词打乱器
- en: 'Create a function that returns a value of a word and scrambles the letter order
    with `Math.random()`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数返回单词的值，并使用`Math.random()`打乱字母顺序：
- en: Create a string that will hold a word value of your choice.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串，用于存储你选择的单词值。
- en: Create a function that can intake a parameter of the string word value.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以接受字符串单词值的参数的函数。
- en: Just like an array, strings also have a length by default. You can use this
    length to set the loop maximum value. You will need to create a separate variable
    to hold this value as the length of the string will be decreasing as the loop
    continues.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像数组一样，字符串也有默认的长度。你可以使用这个长度来设置循环的最大值。你需要创建一个单独的变量来存储这个值，因为随着循环的进行，字符串的长度会减小。
- en: Create an empty temporary string variable that you can use to hold the new scrambled
    word value.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空临时的字符串变量，你可以用它来存储新的打乱后的单词值。
- en: Create a `for` loop that will iterate the number of letters within the string
    parameter starting at 0 and iterating until the original length value of the string
    is reached.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环，该循环将从字符串参数中的0开始迭代，直到达到字符串的原始长度值。
- en: Create a variable that will randomly select one letter using its index value,
    with `Math.floor()` and `Math.random()` multiplied by the current length of the
    string.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，使用`Math.floor()`和`Math.random()`乘以当前字符串的长度，通过其索引值随机选择一个字母。
- en: Add the new letter to the new string and remove it from the original string.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新字母添加到新字符串中，并从原始字符串中移除它。
- en: Using `console.log()` output the newly constructed string from the random letters
    and output to the console both the original string and the new one as the loop
    continues.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`console.log()`输出由随机字母组成的新构造字符串，并在循环继续时同时输出原始字符串和新字符串。
- en: Update the original string by selecting the substring from the index value and
    adding it to the remaining string value from the index plus one onward. Output
    the new original string value with the removed characters.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择从索引值开始的子字符串并将其添加到索引加一之后的剩余字符串值来更新原始字符串。输出新的原始字符串值，其中已移除字符。
- en: As you loop through the content you will see a countdown of the remaining letters,
    the new scrambled version of the word as it is built, and the decreasing letters
    in the original word.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你遍历内容时，你会看到剩余字母的倒计时、构建中的单词的新打乱版本，以及原始单词中减少的字母。
- en: Return the final result and invoke the function with the original string word
    as an argument. Output this to the console.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回最终结果，并使用原始字符串单词作为参数调用该函数。将此输出到控制台。
- en: Countdown timer
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒计时计时器
- en: 'Create code for a countdown timer that can be executed in the console window,
    and will show the total milliseconds, days, hours, minutes, and seconds remaining
    until a target date is reached:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以在控制台窗口中执行的倒计时计时器代码，并显示到达目标日期之前剩余的总毫秒数、天数、小时数、分钟数和秒数：
- en: Create an end date that you want to count down to. Format it in a date type
    format within a string.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个你想要倒计时的结束日期。在字符串中将其格式化为日期类型格式。
- en: Create a countdown function that will parse the `endDate()` and subtract the
    current date from that end date. This will show the total in milliseconds. Using
    `Date.parse()` you can convert a string representation of a date to a numeric
    value as a number of milliseconds since January 1, 1970, 00:00:00 UTC.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个倒计时函数，该函数将解析`endDate()`并从当前日期减去该结束日期。这将显示以毫秒为单位的总数。使用`Date.parse()`，你可以将日期的字符串表示形式转换为自1970年1月1日00:00:00
    UTC以来的数值。
- en: 'Once you have the total milliseconds, to get the days, hours, minutes, and
    seconds you can take the following steps:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了总毫秒数，要获取天数、小时数、分钟数和秒数，你可以采取以下步骤：
- en: To get days you can divide the number of milliseconds in a date, removing the
    remainder with `Math.floor()`.
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取天数，你可以将日期中的毫秒数除以，并使用`Math.floor()`移除余数。
- en: To get hours you can use modulus to capture just the remainder once the total
    days are removed.
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取小时数，可以使用模运算来捕获在总天数被移除后的余数。
- en: To get minutes you can use the value of milliseconds in a minute and using the
    modulus capture the remainder.
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取分钟数，你可以使用分钟中的毫秒值，并使用模运算捕获余数。
- en: Do the same for seconds by dividing the number by seconds in milliseconds and
    getting the remainder. If you use `Math.floor()` you can round down removing any
    remaining decimal places that will be shown in the lower values.
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将数字除以毫秒中的秒数并获取余数，以同样的方式获取秒数。如果你使用`Math.floor()`，你可以向下取整，移除任何将在较低值中显示的剩余小数位。
- en: Return all the values within an object with property names indicating what the
    unit of time the values refer to.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个对象中的所有值，其属性名表示值所引用的时间单位。
- en: Create a function to use a `setTimeout()` to run the `update()` function every
    second (1,000 milliseconds). The `update()` function will create a variable that
    can temporarily hold the object return values of `countdown()`, and create an
    empty variable that will be used to create the output values.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用`setTimeout()`每秒（1,000毫秒）运行`update()`函数。`update()`函数将创建一个变量，可以暂时保存`countdown()`的对象返回值，并创建一个空变量，将用于创建输出值。
- en: Within the same function, using the `for` loop get all the properties and values
    of the `temp` object variable. As you iterate through the object update the output
    string to contain the property name and property value.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一函数中，使用`for`循环获取`temp`对象变量的所有属性和值。当你遍历对象时，更新输出字符串以包含属性名和属性值。
- en: Using `console.log()`, print the output result string into the console.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`console.log()`将输出结果字符串打印到控制台。
- en: Self-check quiz
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: Which method will decode the following?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法可以解码以下内容？
- en: '[PRE137]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`decodeURIComponent(e)`'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decodeURIComponent(e)`'
- en: '`e.decodeUriComponent()`'
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`e.decodeUriComponent()`'
- en: '`decoderURIComponent(c)`'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decoderURIComponent(c)`'
- en: '`decoderURIComponent(e)`'
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decoderURIComponent(e)`'
- en: What will be output into the console from the following syntax?
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语法将在控制台输出什么？
- en: '[PRE138]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: What is the result of the below code in the console?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码在控制台的结果是什么？
- en: '[PRE139]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: What is the result of the below code in the console?
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码在控制台的结果是什么？
- en: '[PRE140]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have dealt with many built-in methods. These are methods
    that are handed to us by JavaScript and that we can use for things that we'll
    often need. We went over the most used global built-in methods, which are so common
    they can be used without being prepended by the object they belong to.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了许多内置方法。这些是JavaScript提供给我们的方法，我们可以使用它们来完成我们经常需要做的事情。我们回顾了最常用的全局内置方法，这些方法如此常见，以至于无需使用它们所属的对象作为前缀即可使用。
- en: We also discussed array methods, string methods, number methods, math methods,
    and date methods. You'll find yourself using these methods a lot and chaining
    them (whenever they return a result) when you get more comfortable with JavaScript.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了数组方法、字符串方法、数字方法、数学方法和日期方法。当你对JavaScript更加熟悉时，你会发现自己会大量使用这些方法，并在适当的时候将它们链接起来（只要它们返回结果）。
- en: Now we've become familiar with many of JavaScript's core features, we'll spend
    the next couple of chapters diving into how it works alongside HTML and the browser
    to bring web pages to life!
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了JavaScript的许多核心特性，接下来几章我们将深入探讨它是如何与HTML和浏览器协同工作，使网页生动起来的！
