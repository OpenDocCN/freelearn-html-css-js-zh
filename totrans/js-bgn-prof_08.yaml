- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-In JavaScript Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just covered most of the basic building blocks in JavaScript. Now it's
    time to look at some powerful built-in methods that will make your life easier
    that we haven't seen yet. Built-in methods are functionality that we get out of
    the box with JavaScript. We can use these methods without having to code them
    first. This is something we have done a lot already, for example, `console.log()`
    and `prompt()`.
  prefs: []
  type: TYPE_NORMAL
- en: Many built-in methods belong to built-in classes as well. These classes and
    their methods can be used at any time because JavaScript has already defined them.
    These classes exist for our convenience, since they are very common things to
    need, such as the `Date`, `Array`, and `Object` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to harness the capabilities that are already built into JavaScript
    can improve the effectiveness of the code, save time, and comply with various
    best practices for developing solutions. We are going to address some of the common
    uses for such functions, such as manipulating text, mathematical computations,
    dealing with date and time values, interactions, and supporting robust code. Here
    are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Global JavaScript methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to built-in JavaScript methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many built-in JavaScript methods already. Any method that we didn't
    define ourselves is a built-in method. Some examples include `console.log()`,
    `Math.random()`, `prompt()`, and many more—think about methods on arrays for example.
    The difference between a method and a function is that a function is defined anywhere
    in the script, and a method is defined inside a class. So methods are pretty much
    functions on classes and instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can often be chained as well; this is only true for methods returning
    a result. The next method will then be performed on the result. So for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a variable, `s`, and we store `Hello` in there on the first line.
    Then we want to be logging something. This code has been divided over different
    lines for readability, but it''s actually one statement. We first perform a `concat()`
    method on our `s` variable, which appends a string to our string. So after that
    first operation the value is `Hello there!`. Then we transform this to uppercase
    with the next method. At that point the value is `HELLO THERE!`. Then we proceed
    to replace `THERE` with `you`. After that, the value becomes `HELLO you!`. We
    then append a string to it again and finally the value will be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to log or store the output in this example, because the original string
    value will not be updated by just calling methods on a string.
  prefs: []
  type: TYPE_NORMAL
- en: Global methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The global JavaScript methods can be used without referring to the built-in
    object they are part of. This means that we can just use the method name as if
    it is a function that has been defined inside the scope we are in, without the
    "object" in front of it. For example, instead of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, the `Number` can be left out, because `isNaN` is made globally available
    without referring to the class it belongs to (in this instance, the `Number` class).
    In this case, both of these `console.log` statements will log `false` (they are
    doing the exact same thing), because `isNaN` returns `true` when it isn't a number.
    And `7` is a number, so it will log `false`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has been built to have these available directly, so to achieve this,
    some magic is going on beneath the surface. The JavaScript creators chose the
    methods that they thought were most common. So the reasons why some of them are
    available as global methods and others are not might seem a bit arbitrary. It's
    just the choice of some very bright developers at a certain point in time.
  prefs: []
  type: TYPE_NORMAL
- en: We'll address the most common global methods below. We start with decoding and
    encoding URIs, escaped and unescaped, followed by parsing numbers, and finally
    evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and encoding URIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you will need to encode or decode a string. Encoding is simply converting
    from one shape to another. In this case we will be dealing with percent encoding,
    also called URL encoding. Before we start, there might be some confusion on the
    URI and URL meaning. A **URI** (**uniform resource identifier**) is an identifier
    of a certain resource. **URL** (**uniform resource locator**) is a subcategory
    of URI that is not only an identifier, but also holds the information on how to
    access it (location).
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about encoding and decoding these URIs (and also URLs, since they
    are a subset). An example of when you'd need this is when you are sending variables
    over the URL using the `get` method in a form. These variables that you are sending
    via the URL are called query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If something contains a space, this will be decoded, because you cannot use
    spaces in your URL. They will be converted to `%20`. The URL might look something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`www.example.com/submit?name=maaike%20van%20putten&love=coding`'
  prefs: []
  type: TYPE_NORMAL
- en: 'All characters can be converted to some `%`-starting format. However, this
    is not necessary in most cases. URIs can contain a certain number of alphanumeric
    characters. The special characters need to be encoded. An example, before encoding,
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.example.com/submit?name=maaike van putten`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same URL after encoding is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.example.com/submit?name=maaike%20van%20putten`'
  prefs: []
  type: TYPE_NORMAL
- en: There are two pairs of encode and decode methods. We will discuss them and their
    use cases here. You cannot have a URI with spaces, so working with these methods
    is crucial in order to work with variables containing spaces.
  prefs: []
  type: TYPE_NORMAL
- en: decodeUri() and encodeUri()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `decodeUri()` and `encodeUri()` are actually not really encoding and decoding,
    they are more so fixing broken URIs. It is like the previous example with the
    spaces. This method pair is really good at fixing broken URIs and decoding them
    back into a string. Here you can see them in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it has replaced the spaces in the encoded version and removed
    them again in the decoded version. All the other characters get to stay the same—this
    encode and decode do not take special characters into account, and therefore leave
    them in the URI. Colons, question marks, equal signs, slashes, and ampersands
    can be expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great for fixing broken URIs, but it''s actually a bit useless whenever
    you need to encode strings that contain any of these characters: `/` `,` `?` `:`
    `@` `&` `=` `+` `$` `#`. These can be used in URIs as part of the URI and are
    therefore skipped. This is where the next two built-in methods come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: decodeUriComponent() and encodeUriComponent()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, the methods `decodeURI()` and `encodeURI()` can be very useful to fix a
    broken URI, but they are useless when you only want to encode or decode a string
    that contains a character with a special meaning, such as `=` or `&`. Take the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.example.com/submit?name=this&that=some thing&code=love`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Weird value, we can agree on that, but it will demonstrate our problem. Using
    encodeURI on this will leave us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.example.com/submit?name=this&that=some%20thing&code=love`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually 3 variables in here according to URI standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value is `this`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`that` (value is `some` `thing`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code` (value is `love`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we intended to send in one variable, `name`, with the value `this&that=some
    thing&code=love`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you will need `decodeUriComponent()` and `encodeUriComponent()`,
    because you would need the `=` and `&` in the variable part encoded as well. Right
    now, this is not the case and it will actually cause problems in interpreting
    the query parameters (the variables after the `?`). We only wanted to send in
    one parameter: `name`. But instead we sent in three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at another example. Here is what the example of the previous
    section would have done with this component encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, you don't want this as your URI, but the component methods are useful
    to encode, for example, a URL variable. If the URL variable were to contain a
    special character, like `=` and `&,` this would change the meaning and break the
    URI if these characters don't get encoded.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding with escape() and unescape()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are still global methods available to do something similar to encode (escape)
    and decode (unescape). Both methods are strongly discouraged to use and they might
    actually disappear from future JavaScript versions or may not be supported by
    browsers for good reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 8.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Output the `decodeURIComponent()` for the string `How''s%20it%20going%3F` to
    the console. Also, encode the string `How''s it going?` to be output into the
    console. Create a web URL and encode the URI:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the strings as variables in the JavaScript code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `encodeURIComponent()` and `decodeURIComponent()` output the results into
    the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a web URI with request parameters `http://www.basescripts.com?=Hello
    World";`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode and output the web URI into the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different ways to parse strings to numbers. In many situations you
    will have to translate a string to a number, for example reading input boxes from
    an HTML web page. You cannot calculate with strings, but you can with numbers.
    Depending on what exactly you need to do, you will need either one of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Making integers with parseInt()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the method `parseInt()` a string will be changed to an integer. This method
    is part of the `Number` class, but it is global and you can use it without the
    `Number` in front of it. Here you can see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off with a string containing a `6`. Then we convert this string to
    an integer using the `parseInt` method, and when we log the result, we will get
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the type has changed from `string` to `number`. At this point,
    you may wonder what will happen if `parseInt()` tries to parse other types of
    numbers, like string versions of floats or binary numbers. What do you think will
    happen when we do this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you figure out the logic here? First of all, JavaScript doesn''t like crashing
    or using errors as a way out, so it is trying to make it work to the best of its
    abilities. The `parseInt()` method simply stops parsing when it runs into a non-numeric
    character. This is the specified behavior, and you need to keep that in mind while
    working with `parseInt()`. In the first case, it stops parsing as soon as it finds
    the dot, so the result is `7`. And in the binary number case, it stops parsing
    as soon as it hits the `b`, and the result is `0`. By now you can probably figure
    out what this does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the first character is non-numeric, JavaScript will convert this string
    to `NaN`. Here is the result that you will get in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So `parseInt()` can be a bit quirky, but it's very valuable. In the real world,
    it is used a lot to combine the input of users via web pages and calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Making floats with parseFloat()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, we can use `parseFloat()` to parse a string to a float. It works
    exactly the same, except it can also understand decimal numbers and it doesn''t
    quit parsing as soon as it runs into the first dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With the `parseInt()`, this value became `7`, because it would stop parsing
    as soon as it finds a non-numeric character. However, `parseFloat()` can deal
    with one dot in the number, and the numbers after that are interpreted as decimals.
    Can you guess what happens when it runs into a second dot?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The strategy is similar to the `parseInt()` function. As soon as it finds a
    character it cannot interpret, a second dot in this case, it will stop parsing
    and just return the result so far. Then one more thing to note. It is not going
    to append a `.0` to integers, so `6` is not going to become `6.0`. This example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the behavior for binary numbers and strings is the same. It is going
    to stop parsing as soon as it runs into a character it cannot interpret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will use the `parseFloat()` whenever you need a decimal number. However,
    it will not work with binary, hexadecimal, and octal values, so whenever you really
    need to work with these values or integers you'll have to use `parseInt()`.
  prefs: []
  type: TYPE_NORMAL
- en: Executing JavaScript with eval()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This global method executes the argument as a JavaScript statement. This means
    that it will just do whatever JavaScript is inserted in there, as if that JavaScript
    were written directly on the spot instead of `eval()`. This can be convenient
    for working with injected JavaScript, but injected code comes with great risks.
    We''ll deal with these risks later; let''s first explore an example. Here is a
    fabulous website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic HTML web page with an input box on it.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn more about HTML in *Chapter 9*, *The Document Object Model*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever you insert in the input box will get executed. If we were to write
    this in the input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The website background would change to pink. That looks like fun, right? However,
    we cannot stress enough how careful you should be using `eval()`. They might as
    well have called it *evil* according to many developers. Can you reason why this
    might be?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is security! Yes, this is probably the worst thing security-wise
    you can do in most situations. You are going to execute external code. This code
    could be malicious. It is a method for supporting code injection. The well-respected
    **OWASP** (**Open Web Application Security Project**) Foundation creates top 10s
    for security threats every 3 years. Code injection has been on it since their
    first top 10 and it is still in the OWASP top 10 security threats now. Running
    it server side can cause your server to crash and your website to go down, or
    worse. There are almost always better solutions to what you want to do than using
    `eval()`. Next to the security risks, it is terrible performance-wise. So just
    for this reason already you might want to avoid using it.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, so one last note on this. If you know what you are doing you might
    want to use it in very specific cases. Even though it is "evil", it has a lot
    of power. It can be okay to use in certain cases, for example when you are creating
    template engines, your own interpreter, and all other JavaScript core tools. Just
    beware of the danger and control access to this method carefully. And one last
    bonus tip, when you feel like you really have to use eval, do a quick search on
    the web. Chances are that you will find a better approach.
  prefs: []
  type: TYPE_NORMAL
- en: Array methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen arrays already—they can contain multiple items. We have also seen
    quite a few built-in methods on arrays, like `shift()` and `push()`. Let's look
    at a few more in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a certain action for every item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a reason we are starting with this method. You might be thinking of
    loops at this point, but there is a built-in method that you can use to execute
    a function for every element in the array. This is the `forEach()` method. We
    mentioned this briefly in *Chapter 6*, *Functions*, but let''s consider it in
    some more detail. It takes the function that needs to be executed for every element
    as input. Here you can see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet will write to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it called the `printStuff()` function for every element in the
    array. And we can also use the index, it is the second parameter. We don't need
    to control the flow of the loop here and we cannot get stuck at a certain point.
    We just need to specify what function needs to be executed for every element.
    And the element will be input for this function. This is used a lot, especially
    for a more functional programming style in which many methods get chained, for
    example, to process data.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the built-in `filter()` method on an array to alter which values
    are in the array. The filter method takes a function as an argument, and this
    function should return a Boolean. If the Boolean has the value `true`, the element
    will end up in the filtered array. If the Boolean has the value `false`, the element
    will be left out. You can see how it works here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is important to realize that the original array has not changed, the `filter()`
    method returns a new array with the elements that made it through the filter.
    We capture it here in the variable `filterArr`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking a condition for all elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `every()` method to see whether something is true for all elements
    in the array. If that is the case, the `every()` method will return `true`, else
    it will return `false`. We are using the `checkString()` function and array from
    the previous example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will log `false`, since not all elements are of type `string` in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing part of an array with another part of the array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `copyWithin()` method can be used to replace a part of the array with another
    part of the array. In the first example we specify 3 arguments. The first one
    is the target position, to which the values get copied. The second one is the
    start of what to copy to the target position and the last one is the end of the
    sequence that will be copied to the target position; this last index is not included.
    Here we are only going to override position 0 with whatever is in position 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`arr` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we specify a range with length `2`, the first two elements after the starting
    position get overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And now `arr` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also not specify an end at all; it will take the range to the end of
    the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is important to keep in mind that this function changes the *content* of
    the original array, but will never change the *length* of the original array.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the values of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you''ll need to change all the values in an array. With the array
    `map()` method you can do just that. This method will return a new array with
    all the new values. You''ll have to say how to create these new values. This can
    be done with the arrow function. It is going to execute the arrow function for
    every element in the array, so for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the console output with the new mapped array looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the arrow function, the `map()` method has created a new array, in which
    each of the original array values has been increased by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the last occurrence in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can find occurrences with `indexOf()` as we have seen already. To find the
    last occurrence, we can use the `lastIndexOf()` method on an array, just as we
    did for `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will return the index of the last element with that value, if it can find
    it at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will log `2`, because the index 2 holds the last `bye` variable. What do
    you think you'll get when you ask for the last index of something that's not there?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That's right (hopefully)! It's `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 8.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remove duplicates from the array using `filter()` and `indexOf()`. The starting
    array is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the array `filter()` method, this will create a new array using the elements
    that pass the test condition implemented by the function. The final result will
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of names of people. Make sure you include duplicates. The exercise
    will remove the duplicate names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `filter()` method, assign the results of each item from the array
    as arguments within an anonymous function. Using the value, index, and array arguments,
    return the filtered result. You can set the return value to `true` temporarily
    as this will build the new array with all the results in the original array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `console.log` call within the function that will output the index value
    of the current item in the array. Also add the value so you can see the results
    of the item value that has the current index number and the first matching result
    from the array's index value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `indexOf()` the current value returns the index value of the item and
    applies the condition to check to see if it matches the original index value.
    This condition will only be true on the first result so all subsequent duplicates
    will be false and not get added to the new array. `false` will not return the
    value into the new array. The duplicates will all be false since the `indexof()`
    only gets the first match in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the new, unique value array onto the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice exercise 8.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the array `map()` method, update an array''s contents. Take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the array `map` method and an anonymous function, return an updated array,
    multiplying all the numbers in the array by 2\. Output the result into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an alternative method, use the arrow function format to multiply each element
    of the array by 2 with the array `map()` method in one line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log the result onto the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: String methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have worked with strings already and chances are that you have run into some
    of the methods on strings by now. There are a few we didn't address specifically
    just yet and we are going to discuss them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Combining strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to concatenate strings, you can use the `concat()` method. This
    does not change the original string(s); it returns the combined result as a string.
    You will have to capture the result in a new variable, else it will get lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Converting a string to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `split()` method we can convert a string to an array. Again, we will
    have to capture the result; it is not changing the original string. Let''s use
    the previous result containing `Hello JavaScript`. We will have to tell the `split`
    method on what string it should split. Every time it encounters that string, it
    will create a new array item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it creates an array of all the elements separated by a space.
    We can split by any character, for example a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It has now created an array with 3 items. You can split on anything, and the
    string you are splitting on is left out of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an array to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `join()` method you can convert an array to a string. Here is a basic
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `x` is `string`. If you want something else other than a comma,
    you can specify that, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will use the `–` instead of the comma. This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This can be nicely combined with the `split()` method that we covered in the
    previous section, which does the reverse and converts a string into an array.
  prefs: []
  type: TYPE_NORMAL
- en: Working with index and positions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Being able to find out what index a certain substring is at within your string
    is very useful. For example, when you need to search for a certain word through
    the user input of a log file and create a substring starting at that index. Here
    is an example of how to find the index of a string. The `indexOf()` method returns
    the index, a single number, of the first character of the substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is logging `7` to the console, because the first occurrence of `re` is
    in `are`, and the `re` begins at index `7`. When it can''t find an index, it will
    return `-1`, like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It is logging `-1` to indicate that the string we are searching for doesn''t
    occur in the target string. Often you will write an `if` check to see whether
    it''s `-1` before dealing with the result. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way of searching for a particular substring within a string
    is to use the `search()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log `17`, because that is the index of `lo` in `fellow`. Much like
    `indexOf()`, if it cannot find it, it will return `-1`. This is the case for this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`search()` will accept a regex format as input, whereas `indexOf()` just takes
    a string. `indexOf()` is faster than the `search()` method, so if you just need
    to look for a string, use `indexOf()`. If you need to look for a string pattern,
    you''ll have to use the `search()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Regex is a special syntax for defining string patterns, with which you can replace
    all occurrences, but we'll deal with that in *Chapter 12*, *Intermediate JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the `indexOf()` method is returning the index of the first occurrence,
    but similarly, we also have a `lastIndexOf()` method. It returns the index where
    the argument string occurs last. If it cannot find it, it returns `-1`. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This returns `24`; this is the last time `re` appears in our poem. It is the
    second `are`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you will have to do the reverse; instead of looking for what index
    a string occurs at, you will want to know what character is at a certain index
    position. This is where the `charAt(index)` method comes in handy, where the specified
    index position is taken as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is logging `r`, because the character at index 10 is the `r` of `red`.
    If you are asking for the position of an index that is out of the range of the
    string, it will return an empty string, as is happening in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will log an empty line to the screen, and if you ask for the type of `pos2`,
    it will return `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating substrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `slice(start, end)` method we can create substrings. This does not
    alter the original string, but returns a new string with the substring. It takes
    two parameters, the first is the index at which it starts and the second is the
    end index. If you leave out the second index it will just continue until the end
    of the string from the start. The end index is not included in the substring.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The first one only has one argument, so it starts at index 5 (which holds an
    `e`) and grabs the rest of the string from there. The second one has two arguments,
    `0` and `3`. `C` is at index 0 and `a` is at index 3\. Since the last index is
    not included in the substring, it will only return `Cre`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing parts of the string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to replace a part of the string, you can use the `replace(old,
    new)` method. It takes two arguments, one string to look for in the string and
    one new value to replace the old value with. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log to the console `Hi Pascal`. If you don''t capture the result,
    it is gone, because the original string will not get changed. If the string you
    are targeting doesn''t appear in the original string, the replacement doesn''t
    take place and the original string will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This logs `Hi buddy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last note here, it is only changing the first occurrence by default. So
    this example will only replace the first `hello` in the new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs `oh hello`. If we wanted to replace all the occurences, we could
    use the `replaceAll()` method. This will replace all occurrences with the specified
    new string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This logs `oh oh`.
  prefs: []
  type: TYPE_NORMAL
- en: Uppercase and lowercase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can change the letters of a string with the `toUpperCase()` and `toLowerCase()`
    built-in methods on `string`. Again, this is not changing the original string,
    so we''ll have to capture the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It converts all the letters to uppercase. We can do the opposite with `toLowerCase()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make it a bit more complicated and say that we''d like the first letter
    of the sentence to be capitalized. We can do this by combining some of the methods
    we have seen already right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We are chaining the methods here; we first grab the first character of `fixed_caps`
    with `charAt(0)` and then make it uppercase by calling `toUpperCase()` on it.
    We then need the rest of the string and we get it by concatenating `slice(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: The start and end of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you would want to check what a string starts or ends with. You''ve
    guessed it, there are built-in methods for this on `string`. We can imagine this
    chapter is tough to work through, so here is a little encouragement and an example
    at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log `true` to the console, because the sentence starts with `You`.
    Careful here, because it is case sensitive. So the following example will log
    `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t care about uppercase or lowercase, you can use the previously
    discussed `toLowerCase()` method here, so that it will not take uppercase or lowercase into
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We are now converting the string to lowercase first, so we know we are only
    working with lowercase characters here. However, an important side note here is
    that this will affect performance for huge strings.
  prefs: []
  type: TYPE_NORMAL
- en: Again, a more performance-friendly alternative is to use regex. Getting excited
    for *Chapter 12*, *Intermediate JavaScript*, yet?
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this section, we can do the same thing for checking whether a string
    ends with a certain string. You can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Since it doesn't end with `Something else`, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 8.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using string manipulation, create a function that will return a string with
    the first letter of all the words capitalized and the rest of the letters in lowercase.
    You should transform the sentence `thIs will be capiTalized for each word` into
    `This Will Be Capitalized For Each Word`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string with several words that have letters with different cases, a
    mix of upper and lowercase words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that gets a string as an argument, which will be the value
    that we will manipulate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function first transform everything to lowercase letters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty array that can hold the values of the words when we capitalize
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the phrase into words in an array using the `split()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through each one of the words that are now in the new array, so you can
    select each one independently. You can use `forEach()` for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `slice()` isolate the first letter in each word, then transform it to
    uppercase. Again using `slice()`, get the remaining value of the word without
    including the first letter. Then concatenate the two together to form the word
    that is now capitalized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new capitalized word into the blank array that you created. By the end
    of the loop you should have an array with all the words as separate items in the
    new array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the array of updated words and using the `join()` method, transform them
    back into a string with spaces between each word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the value of the newly updated string with capitalized words that can
    then be output into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice exercise 8.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `replace()` string method, complete this vowel replacer exercise
    by replacing the vowels in a string with numbers. You can start with this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And turn it into something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the previously specified string, and convert it to lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an array containing the vowels: a, e, i, o, u.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through each letter you have in the array, and output the current letter
    into the console so that you can see which letter will be converted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the loop, using `replaceAll()` update each vowel substring with the index
    value of the letter from the vowel array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `replace()` will only replace the first occurrence; if you use `replaceAll()`
    this will update all matching results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the loop completes output the result of the new string into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to some built-in methods on the `Number` object. We have seen
    a few already, these are so popular that some of them have been made into global
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if something is (not) a number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This can be done with `isNaN()`. We have seen this already when we talked about
    global methods, we can use this method without `Number` in front of it. Often
    you will want to do the opposite, you can negate the function with an `!` in front
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Since `x` is a number, `isNaN` will be `false`. But this result negated becomes
    `true`, since `x` is a number. The string `hi` is not a number, so it will become
    `false`. And this one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Some funky stuff is going on here, even though `5` is between quotation marks,
    JavaScript still sees that it's a 5 and it will log `false`. At this point, I'm
    sure you'd wish your partner, family, and coworkers are as understanding and forgiving
    as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if something is finite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now you might be able to guess the name of the method on `Number` that checks
    whether something is finite. It is a very popular one and has been made into a
    global method as well, and its name is `isFinite()`. It returns `false` for `NaN`,
    `Infinity`, and `undefined`, and `true` for all other values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The only finite number in this list is `x`. The others are not finite. A string
    is a not a number and is therefore not finite. `Infinity` is not finite and `10`
    divided by `0` returns `Infinity` (not an error).
  prefs: []
  type: TYPE_NORMAL
- en: Checking if something is an integer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yes, this is done with `isInteger()`. Unlike `isNaN()` and `isFinite()`, `isInteger()`
    has not been made global and we will have to refer to the `Number` object to use
    it. It really does what you think it would: it returns `true` if the value is
    an integer and `false` when it''s not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Since the only integer in the list is `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a number of decimals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can tell JavaScript how many decimals to use with the `toFixed()` method.
    This is different from the rounding methods in `Math`, since we can specify the
    number of decimals here. It doesn''t change the original value, so we''ll have
    to store the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This will only leave two decimals, so the value of `newX` will be `1.23`. It
    rounds the number normally; you can see this when we ask for one more decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This logs `1.23456 1.235` as output.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying precision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also a method to specify precision. Again this is different from the
    rounding methods in the `Math` class, since we can specify the total number of
    numbers to look at. This comes down to JavaScript looking at the total number
    of numbers. It is also counting the ones before the dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'So the value of newX will be `1.2` here. And also here, it is rounding the
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This will log `1.235`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and talk about some related mathematical methods!
  prefs: []
  type: TYPE_NORMAL
- en: Math methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Math` object has many methods that we can use to do calculations and operations
    on numbers. We will go over the most important ones here. You can see all the
    available ones when you use an editor that shows suggestions and options during typing.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the highest and lowest number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a built-in method `max()` to find the highest number among the arguments.
    You can see it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'It logs `233`, because that''s the highest number. In a similar way, we can
    find the lowest number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log `1`, because that is the lowest number. If you try to do this
    with non-numeric arguments, you will get `NaN` as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: It is not giving `3` as output, because it is not ignoring the text but concluding
    that it cannot determine whether `hi` should be higher or lower than `3`. So it
    returns `NaN` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Square root and raising to the power of
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method `sqrt()` is used to calculate the square root of a certain number.
    Here you can see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log `8`, because the square root of `64` is `8`. This method works
    just like the mathematics you learned in school. In order to raise a number to
    a certain power (base^(exponent), for example 2³), we can use the `pow(base, exponent)`
    function. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We are raising `5` to the power of `3` here (5³), so the result will be `125`,
    which is the result of 5*5*5.
  prefs: []
  type: TYPE_NORMAL
- en: Turning decimals into integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different ways to turn decimals into integers. Sometimes you will
    want to round a number. This you can do with the `round()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it is using normal rounding here. It is also possible that you
    don''t want to round down, but up. For example, if you need to calculate how many
    wood boards you need and you conclude that you need `1.1`, `1` is not going to
    be enough to do the job. You''ll need `2`. In this case, you can use the `ceil()`
    method (referring to ceiling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ceil()` method is always rounding up to the first integer it encounters.
    We have used this before when we were generating random numbers! Careful with
    negative numbers here, because `-5` is higher than `-6`. This is how it works,
    as you can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `floor()` method is doing the exact opposite of the `ceil()` method. It
    rounds down to the nearest integer number, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, careful with negative numbers here, because it can feel counterintuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'And then one last method, `trunc()`. This gives the exact same result as `floor()`
    for positive numbers, but it gets to these results differently. It is not rounding
    down, it is simply only returning the integer part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use negative numbers for `trunc()` we can see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: So whenever you need to round down, you'll have to use `floor()`, if you need
    the integer part of the number, you'll need `trunc()`.
  prefs: []
  type: TYPE_NORMAL
- en: Exponent and logarithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exponent is the number to which a base is being raised. We use `e` (Euler''s
    number) a lot in mathematics, this is what the `exp()` method in JavaScript does.
    It returns the number to which `e` must be raised to get the input. We can use
    the `exp()` built-in method of `Math` to calculate the exponent, and the `log()`
    method to calculate the natural logarithm. You can see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if you can't follow along mathematically at this point. You'll figure
    this out whenever you'll need it for your programming.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 8.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Experiment with the `Math` object with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Output the value of `PI` into the console using `Math`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `Math` get the `ceil()` value of `5.7`, get the `floor()` value of `5.7`,
    get the round value of `5.7`, and output it into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output a random value into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Math.floor()` and `Math.random()` to get a number from 0 to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Math.floor()` and `Math.random()` to get a number from 1 to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Math.floor()` and `Math.random()` to get a number from 1 to 100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to generate a random number using the parameters of `min`
    and `max`. Run that function 100 times, returning into the console a random number
    from 1 to 100 each time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Date methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to work with dates in JavaScript we use the built-in `Date` object.
    This object contains a lot of built-in functions to work with dates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different ways to create a date. One way to create dates is by using
    the different constructors. You can see some examples here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the current date and time, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'But, this way we are not using the built-in method, but the constructor. There
    is a built-in method, `now()`, that returns the current date and time, similar
    to what the no argument constructor does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the current time, represented in seconds since January 1^(st)
    1970\. This is an arbitrary date representing the Unix epoch. In this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add 1,000 milliseconds to the Unix epoch time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'It will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript can also convert many string formats to a date. Always mind the
    order in which days and months of dates are presented in the date format and the
    interpreter of JavaScript. This can vary depending on the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, you can also specify a certain date using the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Please mind this very important detail here, the second parameter is the month.
    `0` is for January and `11` is for December.
  prefs: []
  type: TYPE_NORMAL
- en: Methods to get and set the elements of a date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have seen how to create dates, we''ll learn how to get certain parts
    of dates. This can be done with one of the many `get` methods. Which you will
    use depends on the part you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The time is so high because it''s the number of milliseconds since January
    1^(st) 1970\. You can change the date in a similar way with a `set` method. Important
    to note here is that the original date object gets changed with these set methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed the year of our date object to 2010\. This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change the month. Let''s add the below snippet to our change of
    the year code. This will change it to October. Please mind that while I''m doing
    this, I run the code again and again, so the minutes and smaller units of time
    will vary in the examples when I haven''t set these yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'It will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a weird one, in order to change the day, we have to call the `setDate()`
    method and not the `setDay()` method. There is no `setDay()` method, since the
    day of the week is deducted from the specific date. We cannot change that September
    5^(th) 2021 is a Sunday. We can change the number of days of the month though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also change the hours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Remember how JavaScript doesn't like to crash? If you call `setHours()` with
    a number higher than 24, it will roll over to the next date (1 per 24 hours) and
    after using the modulo operator, whatever is left over from `hours % 24` will
    be the hours. The same process applies for minutes, seconds, and milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setTime()` actually overrides the complete date with the inserted epoch
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Parsing dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the built-in `parse()` method we can parse epoch dates from strings. It
    accepts many formats, but again you will have to be careful with the order of
    days and months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it ends with many zeros, because no time or seconds are specified
    in our string. And here is another example of a completely different format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The input for the parse is ISO formats of dates. Quite a few formats can be
    parsed to string, but you'll have to be careful. The result might depend on the
    exact implementation. Make sure that you know what the format of the incoming
    string is, so that you don't confuse months and days, and make sure that you know
    the behavior of the implementations. This can only be done reliably if you know
    what the string format is. So for example when you need to convert data coming
    from your own database or website's date picker.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a date to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also convert dates back to strings. For example with these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the day in written format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another method that converts it differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'It will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Practice exercise 8.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Output the date with the full month name into the console. When converting
    to or from arrays, remember that they are zero-based:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a date object, which can be any date in the future or past. Log the date
    out into the console to see how it is typically output as a date object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an array with all the named months of the year. Keep them in sequential
    order so that they will match the date month output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the day from the date object value, using `getDate()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the year from the date object value, using `getFullYear()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the month of the date object value, using `getMonth()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a variable to hold the date of the date object and output the month using
    the numeric value as the index for the array month name. Due to arrays being zero-based
    and the month returning a value of 1-12, the result needs to be subtracted by
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the result into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word scrambler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a function that returns a value of a word and scrambles the letter order
    with `Math.random()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string that will hold a word value of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that can intake a parameter of the string word value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like an array, strings also have a length by default. You can use this
    length to set the loop maximum value. You will need to create a separate variable
    to hold this value as the length of the string will be decreasing as the loop
    continues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty temporary string variable that you can use to hold the new scrambled
    word value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `for` loop that will iterate the number of letters within the string
    parameter starting at 0 and iterating until the original length value of the string
    is reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable that will randomly select one letter using its index value,
    with `Math.floor()` and `Math.random()` multiplied by the current length of the
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new letter to the new string and remove it from the original string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `console.log()` output the newly constructed string from the random letters
    and output to the console both the original string and the new one as the loop
    continues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the original string by selecting the substring from the index value and
    adding it to the remaining string value from the index plus one onward. Output
    the new original string value with the removed characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you loop through the content you will see a countdown of the remaining letters,
    the new scrambled version of the word as it is built, and the decreasing letters
    in the original word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the final result and invoke the function with the original string word
    as an argument. Output this to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Countdown timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create code for a countdown timer that can be executed in the console window,
    and will show the total milliseconds, days, hours, minutes, and seconds remaining
    until a target date is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an end date that you want to count down to. Format it in a date type
    format within a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a countdown function that will parse the `endDate()` and subtract the
    current date from that end date. This will show the total in milliseconds. Using
    `Date.parse()` you can convert a string representation of a date to a numeric
    value as a number of milliseconds since January 1, 1970, 00:00:00 UTC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the total milliseconds, to get the days, hours, minutes, and
    seconds you can take the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get days you can divide the number of milliseconds in a date, removing the
    remainder with `Math.floor()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get hours you can use modulus to capture just the remainder once the total
    days are removed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get minutes you can use the value of milliseconds in a minute and using the
    modulus capture the remainder.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the same for seconds by dividing the number by seconds in milliseconds and
    getting the remainder. If you use `Math.floor()` you can round down removing any
    remaining decimal places that will be shown in the lower values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return all the values within an object with property names indicating what the
    unit of time the values refer to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to use a `setTimeout()` to run the `update()` function every
    second (1,000 milliseconds). The `update()` function will create a variable that
    can temporarily hold the object return values of `countdown()`, and create an
    empty variable that will be used to create the output values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the same function, using the `for` loop get all the properties and values
    of the `temp` object variable. As you iterate through the object update the output
    string to contain the property name and property value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `console.log()`, print the output result string into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which method will decode the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`decodeURIComponent(e)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`e.decodeUriComponent()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`decoderURIComponent(c)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`decoderURIComponent(e)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be output into the console from the following syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the result of the below code in the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the result of the below code in the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have dealt with many built-in methods. These are methods
    that are handed to us by JavaScript and that we can use for things that we'll
    often need. We went over the most used global built-in methods, which are so common
    they can be used without being prepended by the object they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed array methods, string methods, number methods, math methods,
    and date methods. You'll find yourself using these methods a lot and chaining
    them (whenever they return a result) when you get more comfortable with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've become familiar with many of JavaScript's core features, we'll spend
    the next couple of chapters diving into how it works alongside HTML and the browser
    to bring web pages to life!
  prefs: []
  type: TYPE_NORMAL
