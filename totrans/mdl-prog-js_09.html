<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Modular Application Design and Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Modular Application Design and Testing</h1></div></div></div><p>Now that we have completed the implementation of our application, it is time for us to talk about testing it. Of course, we test our application to make sure things works as expected and that the future changes to our code-base do not break our application's functionality.</p><p>One thing to keep in mind here, is that we are writing our tests after we have completed our implementation. However, there are times when we write our tests before our application's code.</p><p>The idea is that we write <a id="id482" class="indexterm"/>our tests first and expect them to fail since there is no implementation of the code. Then, as we implement our application, our tests start passing and we can be sure that the implemented code behaves as expected.</p><p>You may choose this approach over implementation first and testing later for your projects, but I would like to emphasize the point that, regardless of the approach, you need to write some automated tests!</p><p>With that in mind, in this chapter we are going to have a look at how we can write some unit tests, and how our modular approach in our application design makes writing automated tests easier and more maintainable. For brevity, we will only write unit tests for two of our modules but the principles discussed can be used to test our other modules too.</p><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How our modules can be tested individually</li><li class="listitem" style="list-style-type: disc">Writing tests without the need for third-party frameworks</li><li class="listitem" style="list-style-type: disc">Improving and streamlining our unit tests using third party tools</li><li class="listitem" style="list-style-type: disc">Using Jasmine as a testing framework</li><li class="listitem" style="list-style-type: disc">Using Mocha and its related assertion libraries as a testing framework</li></ul></div><div class="section" title="Advantages of writing automated tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Advantages of writing automated tests</h1></div></div></div><p>As developers, our<a id="id483" class="indexterm"/> primary concern is to write code that can produce the expected functionality and results. While principle holds true, the way we achieve our final implementation goal is also very important.</p><p>A properly designed application is not just about achieving the final goal of the application but it should also be about implementing an easily extensible and maintainable code-base.</p><p>Using a modular approach certainly helps us with achieving such objectives but as we make changes to our code-base, and as our application goes through its life cycle, we need to make sure all the pieces of the application still work properly.</p><p>When we make a change to one part of the application, we need to make sure that the change does not adversely affect the other parts of our code base. Of course, one way of assuring this, is to test everything manually and check every aspect of our application under all the circumstance that it was designed for.. But such an approach is not only time-consuming, it is also very tedious as we need to go through the same process for every single change in our application.</p><p>Also, especially in big projects, other developers could be working on various pieces of the application. How can we be sure that their changes would not have undesired effects on the parts of the application that we are responsible for?</p><p>Automated tests enable us to check the functionality that we expect from our code base, either in a targeted manner for a particular piece of code or for the entire application as a whole. We write the tests once, and then can run them many times at will, either when there is a change in the code-base or on a continuous basis as part of our regular and testing process.</p><p>The other advantage of automated tests is that, as we are implementing our code, we get into the habit of considering how we can test the particular functionality using automated tests. This mindset results in writing better, more targeted and modular code.</p></div></div>
<div class="section" title="Different types of automated tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Different types of automated tests</h1></div></div></div><p>There are many different types<a id="id484" class="indexterm"/> of automated tests, but we will consider and talk about only three categories of such tests as listed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">Integration testing</li><li class="listitem" style="list-style-type: disc">End to end testing</li></ul></div><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Unit testing</h2></div></div></div><p>Unit tests are usually designed to test the functionality of individual pieces of our code in isolation. This<a id="id485" class="indexterm"/> usually means testing our functions and methods, one at a time, to make sure they do exactly what is expected of them.</p><p>We usually<a id="id486" class="indexterm"/> write such tests in a manner that can verify the functionality of our methods and individual pieces of our code in various scenarios.</p><p>There are two main styles of writing unit tests; <span class="strong"><strong>Test Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>) and <span class="strong"><strong>Behavioral Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>).</p><p>Let's have a simplified overview of what they are and how they are different.</p><div class="section" title="TDD unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec41"/>TDD unit tests</h3></div></div></div><p>TDD unit testing is mostly <a id="id487" class="indexterm"/>used to test the implementation of our code. This is done by testing the actual result that a method produces against what is expected.</p><p>The TDD process<a id="id488" class="indexterm"/> can be thought of as the following loop, if we write our tests before the code implementation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a unit test</li><li class="listitem">Run the test and expect it to fail</li><li class="listitem">Write the code required to make the test pass</li><li class="listitem">Run the test again to make sure the test passes</li><li class="listitem">Re-factor the code if needed</li><li class="listitem">Start from the first step again</li></ol></div><p>As you can see, TDD is meant to be implemented from the beginning of the project and to continue through the project's life cycle.</p></div><div class="section" title="BDD unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec42"/>BDD unit tests</h3></div></div></div><p>This style of testing<a id="id489" class="indexterm"/> is focused on the expected behavior of our code and not necessarily the implementation of it.</p><p>When we use <a id="id490" class="indexterm"/>BDD style of writing unit tests, we write our assertions in a way that can be read like a natural sentence.</p><p>For instance a test should read as, "returns a value that is incremented by 1 from the previous value".</p><p>BDD can also follow the same process loop shown in the TDD section.</p></div><div class="section" title="TDD versus BDD"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec43"/>TDD versus BDD</h3></div></div></div><p>Imagine that we have<a id="id491" class="indexterm"/> a function which is a counter, and when it is called for the first time, it will return the value 1 and every time after that, it will return the previous counter value plus 1.</p><p>In TDD style <a id="id492" class="indexterm"/>of writing unit tests, we test that our function is initialized with the default value (start value) of zero, since that is tied with the very first time that the function is called.</p><p>This detail (that the start value is 0) is an implementation aspect, and TDD style of writing tests checks for such implementation details. It also means that if we decide the default value (start value) in our counter function should change to 2, our test case also needs to change accordingly.</p><p>In BDD style of writing unit tests, we don't check to see what the returned value is when the function is called for the very first time. We only check to see that every time the function is called the counter has been incremented by 1. This means that if we change the start value of the function at some later time, it has no effect on the expected behavior of the function. Our function should always increment the previous value by 1, regardless of the starting value.</p><p>The difference between TDD and BDD is very subtle but important to keep in mind.</p><p>In this chapter we will focus on writing unit tests in BDD style.</p></div><div class="section" title="Test coverage"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec44"/>Test coverage</h3></div></div></div><p>It is ideal to write enough unit tests to achieve 100 percent test coverage of our code. However, in reality, it is not always possible to write unit tests for every aspect of the code.</p><p>Of course, the more<a id="id493" class="indexterm"/> tests we write, the better the code quality we can expect, but time lines also need to be kept in mind for every project. In reality, we do not always have sufficient time to achieve the full coverage of our code base with unit tests.  However, we should keep in mind that in the long run, we save more time on finding and fixing bugs when we have more code coverage with our tests.</p><p>In the absence of sufficient time, my recommendation is to make sure that you at least write unit tests for the core pieces of your application and cover them 100 percent. Then, if time permits, turn your focus to other non-critical pieces of your application and write as many unit tests as you can for those pieces.</p><p>This way, you can make sure of the quality and integrity of the application core and isolate possible issues in non-core and non-critical modules.</p></div></div><div class="section" title="Integration testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>Integration testing</h2></div></div></div><p>This type of testing is mainly focused on making sure that different pieces of the application can work together properly.</p><p>When different<a id="id494" class="indexterm"/> methods and modules are involved to provide a certain functionality, we want to test and see if the desired functionality has been achieved by the sum of collaboration among such pieces.</p><p>An example could be<a id="id495" class="indexterm"/> that one function reads a string from a file and passes it to another function, which creates an array based on the comma delimiter in the string. Our integration test will make sure that the correct array was produced based on these two functions working together to read and process the string.</p></div><div class="section" title="End to end testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>End to end testing</h2></div></div></div><p>These tests usually <a id="id496" class="indexterm"/>checks the flow of the application's functionality from the start to finish to make sure that the application as a whole is working properly and as intended.</p><p>For instance, to test the correct behavior of the application based on the form submission <a id="id497" class="indexterm"/> on a page, we can submit the form values to the server using an AJAX call, get the results from the server, and then refresh the content area of the application based on the returned values. By examining the final result, we can be sure that our application behaves as expected.</p><p>
<span class="strong"><strong>End to end</strong></span> (also known as <span class="strong"><strong>E2E</strong></span>) testing is usually done after our unit tests and integration tests have passed.</p></div></div>
<div class="section" title="A simple start to writing our unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>A simple start to writing our unit tests</h1></div></div></div><p>Writing unit tests is<a id="id498" class="indexterm"/> not about using the latest and greatest unit testing tools and libraries. It is simply about testing little pieces of the code in isolation. The simple fact which we should always keep in mind is that the main goal of unit testing is to ensure the proper functionality and integrity of our code. Even if you are not familiar with any unit testing tools, you can still write you own unit tests, using the skills that you already have in JavaScript.</p><p>However, as you will see later in this chapter, using third-party tools and frameworks can greatly help us to write better and more sophisticated tests.</p><p>For the rest of the chapter, we will target two of our sub-modules (<code class="literal">CookieHandler</code> and <code class="literal">StorageHandler</code>) and will write some simple unit tests for them. We will also explore how our modular architecture can help us write targeted and independent unit tests for each module.</p><div class="section" title="Writing unit tests without any unit testing frameworks"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec76"/>Writing unit tests without any unit testing frameworks</h2></div></div></div><p>While I don't recommend writing your unit tests without any help from third-party libraries and frameworks, my <a id="id499" class="indexterm"/>focus here is to get you started writing unit tests, regardless of whether you use a testing framework or not. Once you<a id="id500" class="indexterm"/> get started, you will slowly get used to the process and soon it will become a part of your regular development routine.</p><p>Thus, as a starting point, we will write our unit tests using plain JavaScript.</p><div class="section" title="Adding an AppTester module to our application"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec45"/>Adding an AppTester module to our application</h3></div></div></div><p>As our client architecture is <a id="id501" class="indexterm"/>based on a modular design, we will continue with that approach and create a module that is responsible for running our unit tests.</p><p>Have a look at how I have structured this module in our project.</p><div class="mediaobject"><img src="graphics/B04910_09_01.jpg" alt="Adding an AppTester module to our application"/></div><p>The <code class="literal">AppTester</code> module resides in the <code class="literal">AppTester.js</code> file, and adds itself to our MainCore Module (<code class="literal">ImagesInc_Core</code>) as a sub-module, as follows:</p><div class="informalexample"><pre class="programlisting">// adding AppTester as a sub-module
ImagesInc_Core.AppTester = (function(){
    function runAllUnitTests(){
        var testModule;
        for(testModule in ImagesInc_Core.AppTester){
            
            if(typeof ImagesInc_Core.AppTester[testModule] === 'object'){
                // run tests
                ImagesInc_Core.AppTester[testModule].runAllTest(); 
            }
        }        
    }    
    function reportTestResults(totalNumOfTest, passedNum, failedNum){      
        var failTestMsgColor;        
        failTestMsgColor = failedNum ? 'red':'pink';
       
        ImagesInc_Core.log(1, 'Total number of tests run: ' + totalNumOfTest, 'orange');
        ImagesInc_Core.log(1, 'Number of Tests Passed: ' + passedNum, 'green');
        ImagesInc_Core.log(1, 'Number of Tests failed: ' + failedNum, failTestMsgColor);        
    }    
    return {
        runAllUnitTests: runAllUnitTests,
        reportTestResults: reportTestResults
    };            
})();</pre></div><p>This sub-module exposes two methods: <code class="literal">runAllUnitTests</code> which runs all the unit tests that have been added to it and <code class="literal">reportTestResults</code> which is our unit test reporter responsible<a id="id502" class="indexterm"/> for displaying the result of our unit tests when they are run.</p><p>Notice that we are using the logging mechanism of our core module for reporting our test results, which demonstrates the re-usability of our modules and sub-modules in different contexts.</p></div><div class="section" title="Adding unit test suites to our test-runner"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec46"/>Adding unit test suites to our test-runner</h3></div></div></div><p>We are going to add <a id="id503" class="indexterm"/>our unit tests to our test-runner <code class="literal">AppTester</code>, using the tight augmentation technique that you are now quite familiar with.</p><p>Generally speaking, it is a good idea to have at least one test file per module which contains all the related unit tests for that module in our application. As such, we have two files in our project; <code class="literal">CookieHandlerTester.js</code> and <code class="literal">StorageHandlerTester.js</code>. As the names imply, one of them holds all the unit tests related to <code class="literal">CookieHandler</code> sub-module and the other contains all the related tests for <code class="literal">StorageHandler</code> sub-module.</p><p>Keep in mind that if you create a large number of unit tests (the more, the better), you can further break down your unit tests into smaller chunks and files, which focus the different functionality of each module. </p><p>In our application, since<a id="id504" class="indexterm"/> we have a limited number of unit tests, we have kept all of them in their related files, one file per module.</p><p>In the following sections, we will only discuss one of them as they are both structured in a very similar manner.</p></div><div class="section" title="CookieHandler module unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec47"/>CookieHandler module unit tests</h3></div></div></div><p>The unit test suite related to our <code class="literal">CookieHandler</code> sub-module is added to the <code class="literal">AppTester</code> module as an object<a id="id505" class="indexterm"/> property. This enables our test runner (<code class="literal">AppTester</code>) to easily loop through all of our unit tests and execute them.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.AppTester = (function(mainTestModule){
    
    if(!mainTestModule){
        ImagesInc_Core.log(3, 'main test module not found!');
        return false;  
    }    
    var CookieTester = mainTestModule.CookieHandlerTester = {};    
    var unitTests = [], totalErrors = 0, totalPasses = 0;
    
    //create a new value in the cookie
    unitTests[unitTests.length] = CookieTester.createCookie = function(name, value, decodeFlag){    
        if(!name){
            name = "testCreateCookie";
        }
        if(!value){
            value = "testing for cookie";
        }
        if(!decodeFlag){
            decodeFlag = false;
        }
...
return mainTestModule;
    
})(ImagesInc_Core.AppTester); // using tight augmentation</pre></div><p>Note how we have added an object as a property to <code class="literal">AppTester</code> module. This object (test suite) has all the related tests as its properties.</p><div class="informalexample"><pre class="programlisting">var CookieTester = mainTestModule.CookieHandlerTester = {};</pre></div><p>Every individual unit test is added to this object, as follows:</p><div class="informalexample"><pre class="programlisting">CookieTester.createCookie = function(name, value, decodeFlag){
...
}</pre></div><p>The array <code class="literal">unitTests</code> is used to run all of our tests using a loop when <code class="literal">AppTester</code> module calls the <code class="literal">cookieTester.runAllTests</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">// run all unit tests
CookieTester.runAllTests = function (){    
        ImagesInc_Core.log(1, '*** RUNNING CookieHandler MODULE UNIT TESTS ***', 'orange');
        
        // run all unit tests
        for(var i=0; i&lt; unitTests.length; i++){
          unitTests[i]();  
        }

        //** test for negative result
        // should not be able to find the value below in the cookie specified
        CookieTester.findValueInCookie("testCreateCookie", "some value!", true);
        unitTests.length++;
        // should not be able to add the value to the cookie as it will be a duplicate
        CookieTester.addValueToCookie("testCreateCookie","testing for cookie",false);
        unitTests.length++;        
        mainTestModule.reportTestResults(unitTests.length,totalPasses, totalErrors);
        CookieTester.cleanup();    
};</pre></div><p>To run individual unit tests, we can<a id="id506" class="indexterm"/> call them by using their name identifier, directly on the <code class="literal">CookieTester</code> object, like so:</p><div class="informalexample"><pre class="programlisting">CookieTester.findValueInCookie("testCreateCookie", "some value!", true);</pre></div><p>That is why each individual unit test is added to both the <code class="literal">CookieTester</code> object and the <code class="literal">unitTests</code> array when defined, as follows:</p><div class="informalexample"><pre class="programlisting">unitTests[unitTests.length] = CookieTester.createCookie = function(name, value, decodeFlag)</pre></div><p>I highly recommend that <a id="id507" class="indexterm"/>you have a look at the code related to the <code class="literal">AppTester</code> and <code class="literal">CookieHandlerTester</code> modules in the accompanying project for this chapter to see how they are implemented.</p></div><div class="section" title="Running CookieHandler unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec48"/>Running CookieHandler unit tests</h3></div></div></div><p>In our project setup, since <a id="id508" class="indexterm"/>we are not using an automated build system, we can add the functionality to our <code class="literal">index.html</code> and our core module to run all the unit tests when <code class="literal">index.html</code> is loaded in the browser.</p><p>Of course, we do not want to do this in a<a id="id509" class="indexterm"/> production environment. Usually, a good development <a id="id510" class="indexterm"/>environment leverages task runners such as <span class="strong"><strong>Grunt</strong></span> or <span class="strong"><strong>Gulp</strong></span> to run the unit tests as well as all the other client application build tasks such as linting, minifying and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>If you are not familiar with these task runners, please check the following resources online:</p><p>
<a class="ulink" href="http://gruntjs.com/">http://gruntjs.com/</a>
</p><p>
<a class="ulink" href="http://gulpjs.com/">http://gulpjs.com/</a>
</p></div></div><p>In our environment, to run the unit tests, we call the following method in our <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.runAllUnitTests();</pre></div><p>
<code class="literal">runAllUnitTests</code> method in our MainCore module, will use <code class="literal">AppTester</code> module to run all of our unit tests.</p><p>Consider the following implementation in our MainCore module:</p><div class="informalexample"><pre class="programlisting">mainCore.runAllUnitTests = function(){         
        if(typeof ImagesInc_Core.AppTester !== 'undefined'){
            
            try{
                ImagesInc_Core.AppTester.runAllUnitTests();                
            }catch(e){
                mainCore.log(3, 'AppTester ERROR! ' + e.name + ": " + e.message);
            }
        }else{         
            mainCore.log(3, 'AppTester not available! ');
        }                  
};</pre></div><p>Here, we first check to see if <code class="literal">AppTester</code> module is present, and if so, we call <code class="literal">runAllUnitTests</code> method on that module.</p><p>In <code class="literal">AppTester</code> module, the code loops through all the unit test suites (in our case, unit tests for the <code class="literal">CookieHandler</code> and <code class="literal">StorageHandler</code> modules) which are the properties of the <code class="literal">AppTester</code> object. This is shown as follows:</p><div class="informalexample"><pre class="programlisting">function runAllUnitTests(){
        var testModule;        
        for(testModule in ImagesInc_Core.AppTester){            
            if(typeof ImagesInc_Core.AppTester[testModule] === 'object'){
                // run tests
                ImagesInc_Core.AppTester[testModule].runAllTests(); 
            }
        }        
}</pre></div><p>In turn, this method calls the <code class="literal">runAllTests</code> method on each unit test suite as you saw earlier:</p><div class="informalexample"><pre class="programlisting">CookieTester.runAllTests = function (){
   ...
}</pre></div><p>Because of our<a id="id511" class="indexterm"/> modular architecture, as we can add individual unit test suites for each module to our <code class="literal">AppTester</code> module; we can also remove them. This is done so in a similar way as we added <code class="literal">CookieHandler</code> test suite to <code class="literal">AppTester</code> but by removing the property related to test suite instead.</p><p>When we run our unit tests by loading <code class="literal">index.html</code>, we will see the following output in the browser's console (I'm using Chrome Development Tools).</p><div class="mediaobject"><img src="graphics/B04910_09_02.jpg" alt="Running CookieHandler unit tests"/></div><p>I recommend that you<a id="id512" class="indexterm"/> try writing some of your own unit tests and adding them to the application's test suites.</p><p>All the needed setup for this has already been implemented for you in the accompanying code for this chapter.</p></div><div class="section" title="Cleaning up after running our unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec49"/>Cleaning up after running our unit tests</h3></div></div></div><p>It is always a<a id="id513" class="indexterm"/> good idea to design our unit tests in a way that they clean up after themselves, so any modification made either to the application or the environment is reset to its original state.</p><p>If you look at the code for both of our unit test suites, there is a clean-up method in each one of them that does just that.</p><p>Consider the following method in <code class="literal">CookieHandlerTester.js</code>:</p><div class="informalexample"><pre class="programlisting">CookieTester.cleanup = function(){    
        ImagesInc_Core.CookieHandler.deleteAllCookies();
        totalErrors = 0; totalPasses = 0;    
};</pre></div><p>As you can see, since our unit tests add a few cookies to the browser, and manipulates them, we want to make sure that all the created cookies are removed and the environment is reset to its<a id="id514" class="indexterm"/> original state.</p><p>
<code class="literal">CookieHandler.deleteAllCookies</code> method takes care of removing all the cookies in the browser.</p></div></div><div class="section" title="Writing unit tests using third party frameworks"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Writing unit tests using third party frameworks</h2></div></div></div><p>While it is possible to write our unit tests using only JavaScript and no third-party frameworks, it is a lot<a id="id515" class="indexterm"/> of manual work, even when writing a few simple tests.</p><p>Our approach in the <a id="id516" class="indexterm"/>previous section for writing unit tests was a good exercise but I think we can do much better by leveraging third-party frameworks designed specifically for this task. Such frameworks enable us to write more sophisticated tests with much less effort.</p><p>In this section, I'll introduce you to two very popular third-party frameworks, which allow us to write good, clean, and professional-grade unit tests.</p><p>The goal here is to give you a good starting point and provide you with a general overview of each library, but we will not explore any of them in great depth. Nevertheless, I'm hoping to get you excited enough about using third-party unit testing libraries (frameworks) that you will spend some time getting to know them better on your own and use them in your future projects.</p><div class="section" title="Introduction to Jasmine"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec50"/>Introduction to Jasmine</h3></div></div></div><p>Jasmine defines itself as "a behavior-driven development framework for testing JavaScript code."</p><p>Jasmine does <a id="id517" class="indexterm"/>not require a DOM and can be used for writing and running JavaScript unit tests both on the server and client side.</p><p>Setting up <span class="strong"><strong>Jasmine</strong></span> is <a id="id518" class="indexterm"/>easy, especially on the client side, and is created in a way that provides all the functionality that you may require from a professional-grade testing framework in one package. I think you will find the syntax quite intuitive and easy to follow.</p><p>I personally like Jasmine quite a bit and am very grateful to its creators for providing us with such a great tool.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In this section, I'll be<a id="id519" class="indexterm"/> using Jasmine 2.4 and encourage you to visit the related site at: <a class="ulink" href="http://jasmine.github.io/">http://jasmine.github.io/</a>.</p></div></div><div class="section" title="Setting up Jasmine"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec22"/>Setting up Jasmine</h4></div></div></div><p>When you visit<a id="id520" class="indexterm"/> Jasmine's site, you will be presented with a link to download the standalone version of the framework, which is the version that we will be using for <a id="id521" class="indexterm"/>our unit tests here.</p><p>After downloading the zip file, and extracting its contents, you will see the following structure:</p><div class="mediaobject"><img src="graphics/B04910_09_03.jpg" alt="Setting up Jasmine"/></div><p>We will be using a similar file structure for our tests, however, without the need for the <code class="literal">src</code> folder, which is the location of the source files that Jasmine loads to run the tests against.</p><p>In our tests, we will be loading <code class="literal">MainCore</code> module and <code class="literal">CookieHandler</code> module directly from where they reside currently in our project.</p><p>The <code class="literal">lib</code> folder is where all the source code for Jasmine itself is kept and the <code class="literal">spec</code> folder is where we will store our test specs.</p><p>Here is how the final file structure has been implemented in our application:</p><div class="mediaobject"><img src="graphics/B04910_09_04.jpg" alt="Setting up Jasmine"/></div><p>In order to load our test specs in <code class="literal">SpecRunner.html</code>, we need to make the following modifications to this file, as follows:</p><div class="mediaobject"><img src="graphics/B04910_09_05.jpg" alt="Setting up Jasmine"/></div><p>As you can see, we have<a id="id522" class="indexterm"/> pointed <code class="literal">SpecRunner.html</code> to the file locations of our <code class="literal">MainCore</code> and <code class="literal">CookieHandler</code> modules in the application, instead of using the default Jasmine <code class="literal">src</code> folder.</p><p>That is all we <a id="id523" class="indexterm"/>have to do to get Jasmine set up and ready for use in our client application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>
<span class="strong"><strong>Why load MainCore.js?</strong></span>
</p><p>As you may have <a id="id524" class="indexterm"/>noticed in <code class="literal">SpecRunner.html</code>, I'm loading both the <code class="literal">MainCore.js</code> and <code class="literal">CookieHandler.js</code> files. This is not necessary, as long as <code class="literal">CookieHandler.js</code> returns a global object, which can then be used in <code class="literal">CookieHandlerSpec.js</code> to run the tests against. In such a scenario, <code class="literal">CookieHandler</code> object will act as an independent module, thanks to our modular architecture. However, to keep the code as is, I load MainCore module first and then use <code class="literal">CookieHandler</code> as a sub-module of MainCore; thus both files need to be loaded.</p></div></div></div><div class="section" title="Creating our Jasmine spec file"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec23"/>Creating our Jasmine spec file</h4></div></div></div><p>To write and run our tests, we need to first create the structure of our spec file. We do this by implementing our test suites.</p><p>A test suite is constructed<a id="id525" class="indexterm"/> using <code class="literal">describe</code> function of Jasmine framework. This function takes two parameters, a string which describe the test suite and a callback function used to implement the test suite itself. This is shown below:</p><div class="informalexample"><pre class="programlisting">describe("Testing cookieHandler Sub-module", function() {
...
}</pre></div><p>Inside the callback function is where we write our test specs. Keep in mind that we can nest <code class="literal">describe</code> functions too. This means that we can use one <code class="literal">describe</code> function to create a test suite for the whole module and use nested <code class="literal">describe</code> functions inside that to create test suites for each individual method of the module. Also, any variables that we declare inside a <code class="literal">describe</code> function is available to all the specs which reside inside that <code class="literal">describe</code> block.</p><p>Let's have a look at our first spec for <code class="literal">CookieHandler</code> sub-module:</p><div class="informalexample"><pre class="programlisting">describe("Testing cookieHandler Sub-module", function() {

    var cookieHandler = ImagesInc_Core.CookieHandler;  
    describe("createCookie Method", function() {
        it("should exist", function() {
            expect(cookieHandler.createCookie).toBeDefined();
        });
…
}</pre></div><p>As you can see, we have used the outer <code class="literal">describe</code> function to encapsulate all the unit tests related to <code class="literal">CookieHandler</code> sub-module. Inside that, we are using another <code class="literal">describe</code> function to write the related specs for <code class="literal">createCookie</code> method of this sub-module. The <code class="literal">it</code> function is where we write our expectations, which are our assertions about the method that we are testing.</p><p>The expectations use matchers to implement a comparison between the actual value and the expected value. Jasmine comes with a slew of built-in matchers but it also provides us with the ability to write our own custom matchers.</p><p>In the code snippet above, we are telling Jasmine to check to see if <code class="literal">cookieHandler.createCookie</code> has been defined.</p><p>Notice how we are describing our tests using strings passed to <code class="literal">describe</code> and <code class="literal">it</code> methods. When the tests are run, these strings should read like sentences, describing what our tests are, and what kind of results we should be expecting from running such tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>
<span class="strong"><strong>Important point to keep in mind when writing unit tests</strong></span>
</p><p>Ideally, we want each unit test to only test one functionality, and not have any dependency on another functionality in the code. For instance, if we want to test that a method can read from a cookie, we <a id="id526" class="indexterm"/>should only test that and not if we can write to the cookie first, and then read the value, all in one test spec. In some of our specs <a id="id527" class="indexterm"/>we have not followed such a rule. To eliminate these types of dependencies, we need to use <span class="strong"><strong>spies</strong></span>, <span class="strong"><strong>stubs</strong></span>, and <span class="strong"><strong>mocks</strong></span> <a id="id528" class="indexterm"/>which require more in-depth knowledge of our<a id="id529" class="indexterm"/> testing frameworks as they are considered more advanced features. Since, this is only an introduction to unit testing, such advanced functionality of the frameworks are beyond the scope of this book, but I highly recommend that you research them further on your own as such features are very useful in writing unit tests.</p></div></div></div><div class="section" title="Running our Jasmine unit tests"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec24"/>Running our Jasmine unit tests</h4></div></div></div><p>We can run <a id="id530" class="indexterm"/>our unit tests by loading <code class="literal">SpecRunner.html</code> in the browser. When our tests have completed running, we will see the following results displayed in our browser window:</p><div class="mediaobject"><img src="graphics/B04910_09_06.jpg" alt="Running our Jasmine unit tests"/></div><p>As you can see, the sentence in<a id="id531" class="indexterm"/> our test suite tells us what method the group of tests belongs to, and the sentence in our assertion tells us what the test is for.</p><p>Our results show that all of our tests are passing. If one of our tests fails, Jasmine notifies us as follows:</p><div class="mediaobject"><img src="graphics/B04910_09_07.jpg" alt="Running our Jasmine unit tests"/></div><p>The message shows us<a id="id532" class="indexterm"/> what test has failed along with a stack trace related to that test. This allows us to quickly identify the failing test and look into what needs to be done to fix it.</p></div><div class="section" title="Exploring Jasmine further"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec25"/>Exploring Jasmine further</h4></div></div></div><p>Jasmine is a complete testing<a id="id533" class="indexterm"/> framework for JavaScript. My goal was to only introduce you to it, and give a very quick overview of some of its capabilities. However, Jasmine provides much more functionality to satisfy any testing needs that you might have, such as using <a id="id534" class="indexterm"/>
<span class="strong"><strong>spies</strong></span>, <span class="strong"><strong>stubs</strong></span>, and <span class="strong"><strong>mocks</strong></span>, as well as support for asynchronous <a id="id535" class="indexterm"/>testing.</p><p>I recommend that you first have <a id="id536" class="indexterm"/>a look at the test suite that I have created for our <code class="literal">CookieHandler</code> sub-module, in the code accompanying this chapter. Then, go to Jasmine's website and learn more about the framework. I think once you start using Jasmine, you will be very<a id="id537" class="indexterm"/> impressed with its capabilities and ease of use.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>For more information, refer to the following link: <a class="ulink" href="http://jasmine.github.io/2.4/introduction.html">http://jasmine.github.io/2.4/introduction.html</a>
</p></div></div></div></div><div class="section" title="Introduction to Mocha"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec51"/>Introduction to Mocha</h3></div></div></div><p>Mocha is another<a id="id538" class="indexterm"/> great testing framework which<a id="id539" class="indexterm"/> allows us to use any assertion library that we like, and provides great flexibility in that aspect. As indicated on Mocha's website, "<span class="emphasis"><em>if it throws an error, it will work!"</em></span>.</p><p>We will be using <a id="id540" class="indexterm"/>
<span class="strong"><strong>Chai</strong></span> assertion library in our tests and we will talk about this library very shortly.</p><p>Mocha can be run both on the server and the client side and it supports both BDD and TDD style tests. We can also use different<a id="id541" class="indexterm"/> reporters with Mocha, such as <span class="strong"><strong>Dot Matrix</strong></span> and<a id="id542" class="indexterm"/> <span class="strong"><strong>List</strong></span>.</p><p>For our purposes, we <a id="id543" class="indexterm"/>will be focusing on how to run Mocha in the browser.</p><div class="section" title="Setting up Mocha"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec26"/>Setting up Mocha</h4></div></div></div><p>To set up Mocha for running our<a id="id544" class="indexterm"/> tests in the browser, we can use <code class="literal">sample.html</code> file that Mocha provides on its website.</p><p>In this file, Mocha is loaded<a id="id545" class="indexterm"/> using a <a id="id546" class="indexterm"/>
<span class="strong"><strong>content delivery network</strong></span> (<span class="strong"><strong>CDN</strong></span>). We can also download the framework from GitHub, at: <a class="ulink" href="https://github.com/mochajs/mocha">https://github.com/mochajs/mocha</a>.</p><p>For our application, I have downloaded Mocha and created the following structure in the project:</p><div class="mediaobject"><img src="graphics/B04910_09_08.jpg" alt="Setting up Mocha"/></div><p>In the preceding screenshot, <code class="literal">MochaRunner.html</code> is our test-runner page and loads Mocha, Chai (the assertion library), our source file (<code class="literal">StorageHandlerSpec.js</code>), and the related spec file, <code class="literal">storageHandlerSpec.js</code>. This file stores all of our Mocha tests.</p><p>This is how our <code class="literal">MochaRunner.html</code> is set up:</p><div class="mediaobject"><img src="graphics/B04910_09_09.jpg" alt="Setting up Mocha"/></div><p>As you can see, we<a id="id547" class="indexterm"/> are also telling Mocha that we will be using BDD style test specs.</p><p>This is all we have to do to implement a simple setup for Mocha.</p></div><div class="section" title="Chai"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec27"/>Chai</h4></div></div></div><p>Chai is a very popular <a id="id548" class="indexterm"/>assertion library that integrates well with Mocha and provides<a id="id549" class="indexterm"/> different assertion styles. In my opinion, one of the best assertion styles to use is <span class="strong"><strong>Expect</strong></span>.</p><p>I think you will find <a id="id550" class="indexterm"/>Expect syntax similar to Jasmine assertion syntax and easy to understand.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>To use Chai, you <a id="id551" class="indexterm"/>can simply download the code (copy/paste) from the following location and add it to your project:</p><p>
<a class="ulink" href="http://chaijs.com/chai.js">http://chaijs.com/chai.js</a>
</p></div></div><p>As you saw previously, I have already downloaded and installed Chai in the project library and it is ready for us to use.</p></div><div class="section" title="Creating our Mocha spec file"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec28"/>Creating our Mocha spec file</h4></div></div></div><p>The setup for a <a id="id552" class="indexterm"/>Mocha <code class="literal">spec</code> file is very similar to Jasmine's spec file. We create our test suites using the global <code class="literal">describe</code> function and pass it a callback function which contains the code for our assertions.</p><p>Just as with Jasmine, we use strings to identify our tests and use <code class="literal">it</code> function to write our assertions. Also, <a id="id553" class="indexterm"/>similar to Jasmine, we can use nested <code class="literal">describe</code> blocks, and any variable defined in a <code class="literal">describe</code> block is available to all the assertions in that block.</p><p>Have a look at the following code snippet from our <code class="literal">storageHandlerSpec.js</code> file as follows:</p><div class="informalexample"><pre class="programlisting">var expect = chai.expect;
describe("Testing storageHandler Sub-module", function() {
    var storageHandler = ImagesInc_Core.StorageHandler;

    describe("saveValueToLocalStorage Method", function() {
        it("should exit", function() {		 
         	expect(storageHandler.saveValueToLocalStorage).to.exit;
        });
….
});</pre></div><p>Note that we have set the variable <code class="literal">expect</code> on <code class="literal">chai.expect</code> global object, and then this variable is used in our assertions.</p><p>Chai provides a great set of matchers which we can use in writing our unit tests. However, the set of matchers provided by Chai is not as complete as Jasmine.</p><p>For instance, to use spies, stubs, and <a id="id554" class="indexterm"/>mocks, which are considered more advanced testing features, we need to use a different library such as <span class="strong"><strong>Sinon</strong></span>.</p><p>Since such features are beyond the scope of this book, we will not explore them here but I encourage you to<a id="id555" class="indexterm"/> visit Sinon's web site for more information at: <a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a>.</p></div><div class="section" title="Running our Mocha-Chai unit tests"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec29"/>Running our Mocha-Chai unit tests</h4></div></div></div><p>If we load<a id="id556" class="indexterm"/> our project's <code class="literal">MochaRunner.html</code> file in the browser, we will see the following test results displayed, after all the tests are run:</p><div class="mediaobject"><img src="graphics/B04910_09_10.jpg" alt="Running our Mocha-Chai unit tests"/></div><p>Of course, the<a id="id557" class="indexterm"/> check marks beside our tests indicate that the tests have passed.</p><p>The following image shows the page when one of our tests fails:</p><div class="mediaobject"><img src="graphics/B04910_09_11.jpg" alt="Running our Mocha-Chai unit tests"/></div><p>As you can see, to report a related error, Mocha uses the string that we have passed to <code class="literal">it</code> function of our test<a id="id558" class="indexterm"/> spec.</p></div><div class="section" title="Exploring Mocha further"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec30"/>Exploring Mocha further</h4></div></div></div><p>Using Mocha in <a id="id559" class="indexterm"/>conjunction with Chai and Sinon enables us to create a robust testing framework. We can even go beyond that by leveraging Mocha on the server side as part of our client's build <a id="id560" class="indexterm"/>system. This allows us to set up and run our tests automatically as one of the build steps, using <span class="strong"><strong>Node.js</strong></span>. Furthermore, while not specific to Mocha, using <a id="id561" class="indexterm"/>
<span class="strong"><strong>GitHub</strong></span> as our source repository enables us to <a id="id562" class="indexterm"/>upload our Mocha tests into GitHub and have our tests run automatically in various browsers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>You can get a lot more information regarding this feature at the following site:</p><p>
<a class="ulink" href="https://ci.testling.com/">https://ci.testling.com/</a>
</p></div></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we talked about various types of tests and why continuous testing of our code is important to the integrity of our application as a whole. One of the ways to implement continuous testing is using unit tests.</p><p>We explored how we can write some simple unit tests using plain JavaScript and saw that using third-party testing frameworks enables us to have more capable and robust tests in our application, with much less effort.</p><p>Using a modular architecture, allows us to easily test our modules in isolation and to quickly find and fix possible issues in our code.</p><p>We also glanced over two very popular open source testing frameworks, Jasmine and Mocha. However, we barely scratched the surface of the capabilities that these frameworks offer, and I encourage you to explore them further on your own.</p><p>All the tests shown in this chapter are included in the source code accompanying this book, and I highly recommend that you have a look at the test suites and spend some time to become familiar with them.</p><p>In the next chapter, we will look at different approaches for loading modules into our application and see how we can manage module dependencies using industry's best practices.</p></div></body></html>