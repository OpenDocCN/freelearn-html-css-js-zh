- en: '*Chapter 6*: Creating and Using Node.js Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are at the heart of Node.js. They correspond to JavaScript files and
    can be used in our applications. A program for the Node.js server will consist
    of a set of modules, that is, JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules that we write ourselves for our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules internal to Node.js and usable directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules that can be downloaded from the internet using a utility called `npm`
    (npm stands for Node.js package manager). This `npm` utility is installed with
    Node.js itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create and use these different types of
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the type of modules used, the `require(moduleName)` instruction
    (see below) allows the module called `moduleName` to be included in the current
    file. The functionalities of the module will then be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using our own modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using internal Node.js modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using downloaded modules with npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s first see how to create and use our own modules with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter on GitHub at: [https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using our own modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we use two modules, each corresponding to a JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: The first module (here named `test.js`) will be the main file of our application,
    the one we execute using the `node test.js` command in a command window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second module (here named `module1.js`) will be the one we want to use in
    our main `test.js` module. The `module1.js` module will then be enriched to show
    how its functionalities are accessible outside the module (and will therefore
    be used in the main `test.js` module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go ahead and create these two modules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the content of the two files, `module1.js` and `test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: module1.js file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The module currently has a simple `console.log()` statement. The module will
    then be enriched. The main module test.js is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: test.js file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `require(moduleName)`instruction, which allows us to load in
    memory the `moduleName` module. Any use of the functionalities of the `moduleName`
    module requires the `require(moduleName)`instruction beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The `require(moduleName)` instruction returns a reference to the module loaded
    in memory. This reference is stored in a variable (here, `mod1`), which will then
    allow access to the functionalities described in the module (here, none for the
    moment).
  prefs: []
  type: TYPE_NORMAL
- en: The `test.js` file is the main file that loads the other modules. It is therefore
    this `test.js` file that is executed using the `node test.js` instruction in a
    command window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Using a module with require(module)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Using a module with require(module)
  prefs: []
  type: TYPE_NORMAL
- en: We can see here that the execution of the main `test.js` module invokes the
    call of the `require("./module1.js")`instruction, which executes the content of
    the `module1.js` file, hence the display text specified in the `console.log()`
    statement in the `module1.js` module.
  prefs: []
  type: TYPE_NORMAL
- en: After loading `module1.js`, the `mod1` variable is initialized and we will be
    able to access functionalities that the module exports later on.
  prefs: []
  type: TYPE_NORMAL
- en: Before adding functionalities to the `module1.js` module, let’s see how to manage
    the location of modules using the `node_modules` directory. The `node_modules`
    directory is used by Node.js to locate modules for which it does not have a path.
    Using this directory simplifies the writing of module names when loading them
    into memory with the `require(moduleName)` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Using the node_modules directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the previous `require(moduleName)` statement requires indicating the
    access path to the module, for example, `"./"` to indicate the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the module is in the `node_modules` directory, it is not necessary
    to indicate the path because we are sure that the module is inside the `node_modules`
    directory (and moreover, it should *not* be specified). The `node_modules` directory
    can be in the main application directory (called the *local* `node_modules` directory)
    or in a dedicated directory created by Node.js (called the *global* `node_modules`
    directory: in this case, it is automatically created during the installation of
    Node.js).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the module is not found in the `node_modules` directory (local or global)
    and if the access path to the module is not indicated, an error occurs when loading
    the module with the `require(moduleName)` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `node_modules` directory in the current directory where
    the main file, `test.js`, is located. Let’s transfer the `module1.js` file to
    this directory and use the `require("module1.js")` statement without specifying
    the path to the module. You can also write `require("module1")` without indicating
    the extension of the JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: Include module1 located in node_modules directory (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `module1.js` file must be in the locally created `node_modules` directory,
    while the `test.js` file remains in the current directory, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— node_modules/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`│ |— module1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— test.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The module is loaded from the node_modules directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – The module is loaded from the node_modules directory
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the module is indeed found by Node.js, because Node.js looks
    for it in the `node_modules` directory, which was created in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to allow a module’s files to be grouped in a directory, using
    the `package.json` file associated with the module.
  prefs: []
  type: TYPE_NORMAL
- en: Using the package.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `node_modules` directory (whether located in the application directory or
    the Node.js installation directory) can contain a lot of files and sometimes a
    module can consist of many files and directories. It would be easier to associate
    a module with a directory in the `node_modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the `module1` directory inside the `node_modules` directory. The
    `module1` directory contains the `module1.js` file but may also contain other
    files and directories related to this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file system is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— node_modules/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| |— module1/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`│ |— module1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— test.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `moduleName` indicated in the `require(moduleName)` statement represents,
    in this case, the name of the *directory* that contains the module files.
  prefs: []
  type: TYPE_NORMAL
- en: But as it is necessary to know which file of the directory we must use first
    when loading the module (as there can be many files in this directory), we indicate
    this correspondence in the `package.json` file in the `"main"` key.
  prefs: []
  type: TYPE_NORMAL
- en: The `package.json` file is a text file in JSON format, located in the directory
    of each Node.js module.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create the `package.json` file in the `module1` module directory
    and indicate in this file the `"main"` key with the value `"module1.js"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file system is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— node_modules/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`| |— module1/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`│ |— module1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`│ |— package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`|— test.js`'
  prefs: []
  type: TYPE_NORMAL
- en: package.json file in the node_modules/module1 directory (package.json file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We indicate in the `"main"` key that we must load the `module1.js` file during
    the `require("module1")` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Including module1 located in node_modules/module1 directory (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the module name in the `require("module1")` statement in this
    case is the name of the directory that contains the module in the `node_modules`
    directory. So, we cannot write the instruction here in the form `require("module1.js")`,
    which would cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now visualize the execution of the `test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Module loaded with the package.json file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Module loaded with the package.json file
  prefs: []
  type: TYPE_NORMAL
- en: The `"main"` key in the `package.json` file is optional if the main module file
    is named `index.js`. In all other cases, the `"main"` key must be indicated in
    `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: We know how to run a module, but for now, the module contains a simple `console.log()`
    statement. Let’s see how to add features to the module and then use them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionalities to the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The newly created `module1.js` module is accessible but does not currently offer
    any functionality. Let’s see how to add some.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting multiple functions in the module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, let’s create the function `add(a, b)`, which returns the sum of
    `a` and `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: add(a, b) function defined in module1.js (module1.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To export a function outside of a module (and make it accessible to users of
    the module), you can just embed it in the `module.exports` object defined by Node.js
    in each module. Each key defined in the `module.exports` object will be a function
    accessible outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: We can thus define several functions in the module that will be accessible thanks
    to the `module.exports` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of the `add(a, b)` function in the `test.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using add() function in test.js file (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following display is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The add() function added to the module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – The add() function added to the module
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a second function in the module. For example, the function `mult(a,
    b)`, which returns `a*b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the `mult(a, b)` function in the module, it is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the mult(a, b) function to the module (module1.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the two functions `add()` and `mult()` in the `test.js` file.
    This verifies that a module can provide several functionalities to other modules
    that use it:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the module’s add() and mult() functions (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following display is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Using the two functions of the module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Using the two functions of the module
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to improve the module concept by using a so-called main function
    in the module.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing a function to be the main function of the module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, the module wishes to make a function its main function (the other functions
    defined in the module are secondary functions). This allows access to this main
    function in a simplified form.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose (as before) that `module1` makes available the `add(a, b)`function and
    the `mult(a, b)`function. We want the `add()` function to be the main function
    of the module, which means that we can use it outside the module as `mod1(2, 3)`
    instead of `mod1.add(2, 3)`. The `mult(a, b)` function will remain accessible
    in the form `mod1.mult(2, 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that only one function can be defined as the main function in a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, just specify it in the `module.exports` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the add() function accessible as a main module function (module1.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to assign the values in this order in the `module.exports` object
    (define the main function first, then the secondary functions). If you make the
    assignment in the other direction (`module.exports.mult` first, then `module.exports`),
    the assignment of `module.exports` last will erase the value already positioned
    in `module.exports.mult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can no longer assign `module.exports` as an object, because that would
    remove the previously assigned value if we wrote `module.exports = { mult : mult
    }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now use the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the module1.js module that has a main function (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following display is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Using the module with the main function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Using the module with the main function
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that instead of using the `mod1` variable as an object, we now use it
    as a function. In the call to `mod1(a, b)` causes the addition of a and b, so
    it is preferable that the variable be named `"add"` rather than `"mod1"` in the
    instruction `require(moduleName)`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to create and use our own module. Now let’s take a look at how to
    use internal Node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using internal Node.js modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js already has internal modules. They can also be used with the `require(moduleName)`
    instruction seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of an internal module. There is, for example, the `"fs"`
    module in the Node.js system. The name `"fs"` is short for file system. This module
    allows you to interact with the internal file system of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the `"fs"` module to read the contents of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the contents of a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use the `"fs"` module to read the file named `file1.txt` located in the
    current directory (where the `test.js` file is located). Here are the contents
    of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: file1.txt file (in the directory where test.js is located)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The program that uses the `"fs"` module and displays the contents of the file
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and displaying the contents of the file (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We use the `readFileSync()` method defined in the `"fs"` module. It returns
    the contents of the file in the corresponding variable, which is then displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Displaying file contents using the "fs" module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Displaying file contents using the “fs” module
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the file are displayed but as hexadecimal characters. Next,
    let’s display the contents of the file as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying file contents as strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The contents of the file are displayed in the form of a buffer of bytes (see
    *Figure 6.7*). Node.js makes it easy to manipulate byte streams. It is also possible
    to view the contents of the file directly as strings by specifying the `{encoding:
    "utf-8"}` option in the second parameter (`options`) of the `readFileSync(name,
    options)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying file contents as strings (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is now displayed as strings (see the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Displaying file contents as strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Displaying file contents as strings
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the file are displayed. However, the program waits for the contents
    of the file to be retrieved in order to display them. By using the `readFile()`
    method instead of the `readFileSync()` method, it is possible to not block the
    program while waiting for the file.
  prefs: []
  type: TYPE_NORMAL
- en: Using non-blocking file reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you observe the previous `readFileSync()` method, you will see that the contents
    of the file are rendered in return for the method call. This means that the Node.js
    program is blocked while the file is being read (even if only for a few milliseconds).
    Within our small program, this is not noticeable, but in a case where the reading
    of the file is carried out by thousands of simultaneous users (for example, on
    a server), this will slow down access to the server.
  prefs: []
  type: TYPE_NORMAL
- en: For this, Node.js has provided, for all blocking features such as this one,
    a non-blocking version of the method. Rather than returning the return result
    of the method (as before), we use a callback function indicated as a parameter
    of the method. In the case of reading the file, we will therefore use the `readFile(name,
    options, callback)` method, also defined in the `"fs"` module. The result of reading
    the file will be passed as a parameter in the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the non-blocking form of reading the file, using the `readFile()`
    method instead of the `readFileSync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Using readFile() method to read the file (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The callback function uses the `error` and `data` parameters (in that order),
    which respectively correspond to a possible error message (`null` if none), and
    to the contents of the file if the latter has been read. The `options` parameter
    indicated as the second parameter of `readFile()` is similar to that of the `readFileSync(name,
    options)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Displaying file contents using the non-blocking readFile() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Displaying file contents using the non-blocking readFile() method
  prefs: []
  type: TYPE_NORMAL
- en: We can check in the result displayed above that the `readFile()` method is really
    non-blocking. Indeed, the text indicated following the call to the `readFile()`
    method is displayed in the console even though the file has not yet been read
    and displayed, which would have been impossible using the blocking method `readFileSync()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can therefore see that the use of modules internal to Node.js is done very
    simply by using the `require(moduleName)` instruction, and then by calling methods
    on the object returned by this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create and use your own modules, and how to use internal
    Node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to use modules available on the internet using the `npm` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using downloaded modules with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the modules internal to Node.js, it is possible to import modules
    from the internet using the `npm` utility provided with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the `npm` command is used (in a command interpreter) by indicating
    arguments that allow you to perform the corresponding actions on the imported
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using the npm command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common uses of the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install moduleName`: Installs the indicated module in the *local* `node_modules`
    directory. The module will only be accessible for the current application and
    not for other applications (unless it is installed again).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm install moduleName -g`: Installs the specified module in the *global*
    `node_modules` directory. The `-g` option allows you to indicate that this module
    can be accessed by other applications because it is installed in the `node_modules`
    directory of Node.js (globally).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm link moduleName`: It is possible that a module installed globally (with
    the `-g` option) is inaccessible (you get a module loading error during the `require(moduleName)`
    statement). In this case, it is necessary to run the `npm link moduleName` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm ll`: Lists modules already present in the *local* `node_modules` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm ll -g`: Lists modules already present in the *global* `node_modules` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm start`: Starts the Node.js application according to the command indicated
    in the `"scripts"` key, then the `"start"` key of the `package.json` file. For
    example, if you specify `"scripts": { "start": "node test.js" }` in the `package.json`
    file, you can type `npm start` instead of `node test.js` to run the `test.js`
    file. It is common to use `npm start` to start a Node.js application. This will
    be used to start an application under `uninstall` instead of `install`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let’s create the following `package.json` file in the directory
    of the `test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json file (in the same directory as test.js)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `npm start` command to start the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Starting the Node.js application with npm start'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Starting the Node.js application with npm start
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `npm start` command thus makes it possible to execute the
    `test.js` program. The `npm start` command is often used to start a Node.js program,
    thanks to the mechanism explained above.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to use modules written by other developers by downloading
    them using `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a downloaded module with npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at an example of using `npm`. Here, we will use `npm` to install
    the module named `colors`. It allows you to display colored text in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the colors module in the node_modules local directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the command `npm install colors`. The result of the installation of the
    `"colors"` module is displayed in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Installing the colors module with npm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Installing the colors module with npm
  prefs: []
  type: TYPE_NORMAL
- en: Once the module has been installed by `npm`, you can see that the `colors` directory
    of the module has inserted itself into the `node_modules` local directory of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the features of the colors module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the ways to have an overview of the functionalities offered by a module
    is to display the content of the object returned by the `require(moduleName)`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying contents of colors object returned by require(“colors”) (test.js
    file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.12 – Displaying contents of the colors module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Displaying contents of the colors module
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s use the last method listed in the module, namely the `random()`
    method. It allows you to transform a character string into a string with random
    colors for each character:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the random() method of the colors module (test.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `random()` method is used by prefixing its name with the name of the variable
    returned by `require("colors")`, that is, with the name of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The display of the following figure is obtained, in which each character displayed
    is a random color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Using the colors module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Using the colors module
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen here the three types of modules used with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules written by ourselves, for our own needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing internal modules in Node.js, such as the `fs` module allowing access
    to the internal file system of Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules downloadable using the `npm` command, such as the colors module used
    above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All that remains is to use these different types of modules in our programs.
    We will discuss that later on.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in this chapter how to create and use modules with Node.js, which
    are the essential components of programs created with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the module is created by us, is an internal Node.js module, or is a
    module downloaded with `npm`, its use is the same in all cases. We use the `require(moduleName)`
    instruction and with the value returned in a variable, we access the functionality
    of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to study the Express module, which is one of the main modules
    used with Node.js, allowing us to easily structure our applications according
    to the rules of the MVC model, currently widely used.
  prefs: []
  type: TYPE_NORMAL
