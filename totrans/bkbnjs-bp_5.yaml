- en: Chapter 5. Building a Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all the applications that we've built have used plain old Backbone.
    This isn't to say that we haven't used helper libraries, but that we haven't yet
    used any libraries that extend Backbone itself. However, such libraries do exist;
    the Backbone GitHub wiki has a whole list of them ([https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources](https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources)).
    In this chapter, we'll use one of these libraries to make building this application
    a little simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be focusing on the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party library to make large applications easier to handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing real-time communication between the server and the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlining the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, let's define exactly what it is we're going to build.
    It will be an online chat application; a user will go to the website, choose a
    screen name, choose a room, and chat with other members in the room. There won't
    be real user accounts; you join by simply giving a name, kind of like a simpler
    version of IRC. If someone else is using that name, you'll have to choose another.
    Users will also be able to create new rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a few new tools in this chapter: Socket.IO and Marionette.
    **Socket.IO** ([http://socket.io](http://socket.io)) is a real-time communication
    library that allows the client to talk to the server quickly and easily. Think
    of it as a publish and subscribe system (like Backbone''s `trigger` and `listenTo`
    methods) between the client and the server; you can read more about that design
    pattern on Wikipedia ([https://en.wikipedia.org/wiki/Publish_and_subscribe](https://en.wikipedia.org/wiki/Publish_and_subscribe)).
    We''ll use this to make the live aspect of our chat application a lot easier to
    write.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Marionette** ([http://marionettejs.com](http://marionettejs.com)), however,
    is a little more interesting. It bills itself as a composite application library
    for Backbone.js that aims to simplify the construction of large scale JavaScript
    applications. Here''s the idea; as you may have noticed from all the previous
    chapters, a lot of the code that we write in Backbone applications is repeated
    in each application. For example, we have views for both models and collections.
    Often, the collection view will loop over the models in the collection and render
    a model view for each of them, putting them in a container element. As this is
    a common pattern, Marionette wraps all this up for us and allows us to write just
    a few lines to do it all. However, Marionette also offers other tools that make
    managing large applications a little easier. We''ll look at a bunch of these in
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to begin this application with a bit of server-side code. We will use
    Express as our primary server; however, we also want to use Socket.IO, so we have
    to set it up. Copy the template to start the new project. Then, in the project
    directory, go ahead and install all our packages and then Socket.IO with npm as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to get Express and Socket.IO to play together nicely, we need to do things
    a bit differently in our `server.js` file. First, we require the `http` library
    of Node.js and `socket.io`. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to wrap our Express application (the `app` object) in a Node.js
    server object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a server. The final step to getting things working with Socket.IO
    is to create a Socket.IO instance that listens to our server. We do that this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently in the `server.js` file, you''ll have the code that calls the `app.listen`
    function. However, as we''re now wrapping our Express app in a Node.js server
    object, we need to call `listen` on that. So remove the `app.listen` call, and
    replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to boot up the server (`npm start`) and go
    to `http://localhost:3000` and get our blank page.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step takes us into the `views/index.ejs` file. Marionette, of course,
    is a client library, but Socket.IO has a client component too; so we''ll need
    to add script tags for both of them. Put these just below the tag for `backbone.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Socket.IO on the backend will send the right file to that route, even though
    we never put `socket.io.js` in place. However, we do need to download Marionette.
    If you head over to the Marionette downloads page ([http://marionettejs.com/#download](http://marionettejs.com/#download)),
    you''ll see there are a few versions available. The Marionette library uses two
    main components: `Backbone.Wreqr` and `Backbone.BabySitter` (both have been built
    by the same good folks who made Marionette). You can download Wreqr, BabySitter,
    and Marionette separately, or you can get them bundled together. Make sure you
    download the bundled version and place it in the `public` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will split our application into many smaller pieces and place them
    in their own files, similar to how we've done in the previous two chapters. For
    each file we make, you would want to add a script tag for it to the `views/index.ejs`
    file. In this case, the order will matter, and we'll see why that is and how to
    order them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A word about Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Socket.IO makes it really easy to send data back and forth between the server
    and the client. As we''ve seen, this is one of the most important parts of Backbone;
    sending our models to and from the server. It would be relatively easier to replace
    the `Backbone.sync` function (as we did in [Chapter 2](ch02.html "Chapter 2. Building
    a Photo-sharing Application"), *Building a Photo-sharing Application*) with an
    implementation that uses Socket.IO. For example, we might do something like what
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't used Socket.IO before, this code won't make much sense just yet;
    but look at this again towards the end of the chapter and it should be clear.
    While we could write a Backbone application using Socket.IO this way, that's not
    the way we're going to be doing it here. To the get the live aspect of our chat
    application, we can't use the regular Backbone methods that talk to the server,
    such as `save` and `create`; we'll need to take things into our own hands. Part
    of the beauty of Backbone is that this will work out fine; if we decide to use
    Backbone to build an application that doesn't really fall within its *normal*
    usage, there's no extra friction from Backbone. However, you should know that
    you can use Socket.IO to do the syncing of a normal Backbone application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all of our code in this chapter will be put into modules, which Marionette
    will provide for us. But we need to start with some application preparation code.
    Previously, we've seen how we can put all the components of our application in
    a single global variable. Marionette takes this a step further by giving us an
    `Application` class; it's more than just an object onto which we can hang our
    own classes. As you'll see, it provides a lot of other interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we start in the usual `app.js` file. Here''s the code that we''ll put in
    that file for starters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We're already familiar with template settings for Underscore, so the other lines
    are what you should focus on. The first line is how we create our single global
    variable for our application. All the special classes and components that Marionette
    gives us are available through the `Backbone.Marionette` namespace, and here,
    we will create an instance of the `Backbone.Marionette.Application`.
  prefs: []
  type: TYPE_NORMAL
- en: The way a Marionette application object works is that we'll eventually start
    up the application with `App.start()`. When we do that, any initializers we have
    added (with the `App.addInitializer` method) to the application will be run. We
    haven't added any initializers yet, but we will later.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of that code, we're listening for the `initialize:after` event.
    Marionette fires many different events at many points in the life of an application,
    and this is one of them. As you probably suspect, this event is fired after all
    the initializers we set up have been run. Once the application is initialized,
    we can start the router by starting Backbone's history mechanism, as we've done
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic application object, we can create modules. In general,
    in any programming language or library, modules are a way of grouping related
    code into one piece; the internals are kept hidden, and only the pieces we choose
    can be accessed from outside the module. This is exactly how Marionette uses them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first module will be very simple; it''s the Socket module. The file will
    be `public/socket.js`. The following is the code for this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is the Marionette way of creating a module. We call the `App.module` method;
    it takes two parameters. The first is the name of the module. The module will
    be made available as a property of our `App` object by this name. As we call it
    `Socket` here, we'll be able to access this module in other places through `App.Socket`.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a function; of course, in this function we create the
    module. You might expect that whatever object we return from this function becomes
    our module, but that's not actually how it works. Instead, the `App.module` function
    will pass a parameter to our function; we will call it `Socket` as well. This
    is the object that will become our property. Anything we make a property of that
    object will be accessible from the `App` object. So in all our other modules,
    we can call the `App.Socket.io` property. However, what exactly is this property
    that we've just created?
  prefs: []
  type: TYPE_NORMAL
- en: The script that we added to the `index.ejs` file will give us a global `io`
    object that we can work with. We create our connection by calling the `connect`
    method and passing it the URL to which we want to connect. Since we're running
    our local server on port 3000, this is the path we connect to; if you were to
    use this in a public application, you'll want to put the public URL for your application
    in there. So this is our connection object, and as we just saw, we'll be able
    to access it from other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll create users. Unlike some of our previous applications, these aren't
    user accounts that users can log into. Instead, a user is just someone who is
    currently using our chat application; all they need to provide is a screen name.
    So a collection of users is really just a list of currently used screen names.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a `public/user.js` file and start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we start. First, we create a basic `UserModel` class (we can''t
    just call it `User` because that would overwrite our module variable). Then, we
    create a collection class. As we''ve done before, we give it the model class.
    Things begin to get interesting in the collection''s `initialize` function. Remember,
    we''re not using the normal channels for communicating with the server here, so,
    we need to set up a way to discover when other users join or leave the site. We''ll
    use Socket.IO on the server to emit a `user:join` event whenever a user joins
    the site; the event will send the new user''s data to the client, which is an
    object with a name property, such as `{ name: ''Andrew'' }`. We can listen for
    this event with `App.Socket.io.on`; this method takes the name of the event we''re
    listening for and a function that will be run each time the event occurs. As you
    can see, each time a user joins, we''ll add that user to the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to know when a user leaves. We'll listen for the `user:leave` event;
    when this happens, we'll use the collection's `findWhere` method to find that
    `UserModel` instance, and then destroy it, removing it from the collection. A
    Backbone collection's `findWhere` method will return the first model that matches
    the attributes hash we pass to it. Since we'll make sure that each name is unique
    on the server side, we can be sure we're destroying the right user.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing to point out is that we will keep the `UserModel` class local
    to the module, but we will make the `Collection` class public by putting it on
    the `User` object. This is because we will never need to use the model class directly
    (only through the collection), so we can keep it hidden. There's no need to give
    the code outside this module access to more functionality from within this module
    than we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created our model and collection classes, let''s make views
    for them. These views go in the `User` module too. The views look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using two of the handy view classes that Marionette gives us:
    `Backbone.Marionette.ItemView` and `Backbone.Marionette.CollectionView`. We commonly
    create views specifically to render individual models or collections, and these
    classes wrap up that common code for us. First, we create an `ItemView` class.
    The only properties we need to give it are `tagName` and `template`. These are
    both properties that we usually use; however, you''ll notice something different
    about the `template` attribute. Instead of getting the template text via jQuery
    and using Underscore to convert it to a template function, all we have to do is
    set the template to a selector string. Here, we will set it to `#user`. Of course,
    we''ll put this template in the `index.ejs` file, with the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A simple template for sure. However, it shows how the extensions that Marionette
    provides can make complex applications simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The `User.CollectionView` is even simpler. We don't have to give it a `tagName`,
    but we can, and as our `ItemView` instances are list items, it makes sense to
    make the elements of `CollectionView` a list. Then, we only have to say what `itemView`
    is. In our case, this is the `ItemView` class we just created. The way a `Marionette.CollectionView`
    works is that it will loop over the collection, create an `itemView` for each
    item, and append it to the collection's element.
  prefs: []
  type: TYPE_NORMAL
- en: So that's our first module. We'll be creating several more modules in this application,
    but the `User` module is a good example of a typical Marionette module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve created three files here (`app.js`, `socket.js`, and `users.js`), so
    let''s add them to the `index.ejs` file. Make sure that `app.js` comes first.
    We will add the three files using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Building the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is the layout. This isn''t something we''ve done in the previous
    applications, but it is something that Marionette gives us. This functionality
    allows us to organize and manipulate the many views we''ll have on screen at once.
    In a large application, this can get tricky, and Marionette has two classes that
    make this simpler: `Region` and `Layout`. A region is basically an area of the
    screen, an object we can use to easily show and hide views or layouts. A layout
    is basically a group of regions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a `Layout` module for our layout classes. The following
    is the whole of our `public/layout.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first class is the layout for our application. Think of it as a view class
    but with no model or collection to display. Instead, it gives us access to several
    regions. Just like with the `ItemView`, the `template` property is a selector
    for the template. The template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have four main areas, and these are the regions. We have
    a list of users, a list of rooms, the actual chat conversation, and a controls
    area where the user will log in and type in their message. In our `Layout` class,
    we have a `regions` property, which defines what the regions of our layout are.
    Each one is a selector, pointing to each of the four `<div>` elements in our template.
    When we create an instance of this `Layout` class, we'll be able to control the
    content of each of these regions individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that comes the `MainRegion` class, which is a `Marionette Region`. This
    time, instead of setting a `tagName`, we will set the `el` property. When we do
    this, the class will use an existing DOM element instead of creating a new one.
    This is simply a region within which we will render our layout. In fact, this
    is our next step; to make our `App` object aware of this main region. In `app.js`,
    we need to add a call to the `addInitialize` method we discussed earlier. This
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our `App` object has an `addRegions` method that takes an object as a parameter.
    The property names are the names of the regions, and the value is the region class
    we're using. Here, we will create a single region, `main`, with our `MainRegion`
    class. Notice how, since we assigned `main` as a property of `Layout` in `layout.js`,
    we can access it via `App.Layout.MainRegion`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a doubt, the most complex part of this chapter's application is the
    router, and with more advanced applications, this will often be the case. Due
    to this, Marionette's recommended pattern is to split the functionality of the
    Backbone router into two parts. The first part is still called the router; its
    job is to decide what should be done based on the current route. Then, there's
    the controller that actually performs the action decided upon by the router. Marionette
    has the `Marionette.AppRouter` class for the routing functionality. Interestingly,
    Marionette provides no framework for the controller. All that's required is a
    basic object with the right methods. We will create a constructor function and
    place all our methods on the prototype. So, let's create `router.js` within `public`
    and get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Marionette recommends shifting most of the traditional Backbone router''s
    work to the controller, the router itself is very minimal. Here''s how it starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We wrap this in a `Router` module. Then, we use Marionette's `AppRouter` class;
    as in many other Backbone classes, we create an `initialize` function that will
    run when we create our router instance. This is where we render our layout. We
    create a new instance of our `Layout` class and pass it to the `main` region's
    `show` method. As you'll see in the controller, this is the Marionette way of
    rendering layouts and views. we never call the `render` method ourselves. Instead,
    we pass a layout or view instance to a region's `show` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that we''re making our layout instance a property on our `App`
    module: `App.layout`. This is how we''ll access our four regions from within the
    controller using `App.layout.users` or `App.layout.controls`. As these are regions,
    they will have the `show` method, to which we can pass the views we want to render.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, instead of a `routes` property, our `AppRouter` will have an `appRoutes`
    property. This works just like the `routes` method of a normal router, except
    that the methods we call will be in the controller instead of on the router itself.
    We will start with a simple `index` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start with the controller. This also goes inside the `Router` module
    that we''ve created. The controller can be started like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot more to come, but this is what we can do right now with the code
    we've already written. In the constructor function, we'll create a `users` property.
    This is the collection that will manage our list of users. As our router will
    be looking for a method called `index`, we'll add that to `prototype` of our `Controller`
    function. This method simply creates an `App.User.CollectionView` instance and
    renders it in the `users` region of our layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we load up our page, we need to instantiate the router. At the bottom
    of the `Router` module, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate our router, passing it a new `Controller` object as a property
    in an options object. The router will use this object as the controller for our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to having some code we can actually run is to add a few lines
    to the `index.ejs` file. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We add our layout and router modules, and then, right at the bottom, we start
    the application. Remember that, even when we add other script tags later on, it
    is important that the `router.js` script should be the last one loaded because
    it references almost all the other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run `npm start` to boot the server up and load `http://localhost:3000`
    in a browser. At this point, you won''t see anything at all on the page; however,
    open the developer tools and you''ll see that things are starting to take shape.
    We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the router](img/6997OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that our layout has been rendered and that the `<ul>` element of
    our `User.CollectionView` instance is present. Even though we aren't rendering
    any content, this is an important step. We've written a lot of code that might
    seem disparate and unconnected, but it has all come together to create the humble
    beginnings of our application. Now that we have the infrastructure working, we
    can start to think about specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users join the fun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first serious feature will be allowing users to choose a screen name and
    join the chat rooms. We'll need a view with a form where a user can submit their
    name. However, as part of this, we'll need a way to ask the server if this name
    has been taken yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all this, we go back to the `User` module, and add a method to the `User.CollectionView`,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes the `name` that the user wants to use as well as a `callback`
    function. Inside the method, we use another Socket.IO method: `emit`. This is
    the flip side of the `App.Socket.io.on` method we saw earlier in this class''s
    `initialize` method. The `on` method listens for events while `emit` actually
    makes the occurrence of the event. The `emit` method takes at least one parameter;
    the name of the event that we''re triggering. We can then pass as many subsequent
    parameters as we like; these are pieces of data that we can associate with the
    event. If the server is listening for this event, it will receive these parameters.
    We pass the user''s name and a function. The name makes sense; if the server is
    going to tell us whether this name is already in use, we need to send it the name.
    However, the function is a little different. We receive the function on the server
    side, but when we call the function (from the server, remember!) it will be executed
    here in the browser. This is not only incredibly cool, it''s also very useful.
    On the server, we''ll pass that function a Boolean value; `true` if the user can
    use this name and has been added to the list of current users or `false` if the
    name is already in use.'
  prefs: []
  type: TYPE_NORMAL
- en: If the user has successfully joined the chat rooms, we'll set their screen name
    as a property of our `App` object, so we can access it from other places. Then,
    we'll call the `callback` function that was passed to the `addUser` method, passing
    it the `joined` value. The `context` parameter is actually just a nice touch.
    I'm not a fan of having to put the value of `this` in a variable every time I
    enter a callback function, so when I have the option, I'll create functions that
    take a context as a final parameter. This way, I can use `this` as I want inside
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in place, let''s move over to `server.js`. We haven''t written any
    Socket.IO-specific code yet, but we''re going to start that now. Start by adding
    this to `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `users` object; it's empty right now, but as users join, it
    will be used. As we aren't creating actual user accounts, there's no need for
    this record to be persistent; a regular object will do.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we created the `io` object. This object has a `sockets` object on which
    we have the `on` method, which we can use to listen for connections being opened
    from browsers. As you can see here, we're listening for the `connection` event.
    The callback function here will be run when a new connection is made. The new
    socket (the connection to the browser) is a parameter of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this callback, we''ll start by listening for the `join` event that the
    `User.CollectionView` class'' `addUser` method was emitting. Add this inside that
    callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember that when we emitted the `join` event, we sent the name and a function
    along with it. You can see these here on the server as the parameters of the function
    that will be called when this event occurs. In this function, we check to see
    whether the user exists using a `userExists` function, which we haven't written
    yet. If the user already exists, we'll call that `response` function (that is
    executed on the client, remember?) and pass `false` (because the user can't join
    under that name). However, if the user doesn't currently exist, we'll respond
    with `true`. Then, we'll add the user to the `users` object. We can use the unique
    `socket.id` as a key. Finally, we'll emit the `user:join` event, passing a basic
    user object as the data associated with that event. All the currently connected
    clients (including the client that sent the join event) will receive this event.
    Remember that in our `User.Collection` class' `initialize` method, we're listening
    for this event. This is how the client can learn about new users joining the chat
    room.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we can't just look at the users in the collection to see
    whether a name is in use, instead of asking the server whenever a new user tries
    to join. After all, if the collection is a list of currently connected users,
    it should know whether the name is already in use. The problem with this is that
    in some scenarios, which we haven't yet come to, the user will try to join before
    the server has had the chance to send the current list of users to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something we have to add. When a new socket is connected, we need to
    send it the list of the currently connected users. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Object.keys` method takes an object and returns an array of its keys. We
    can loop over all the users in our `users` object and emit the `user:join` event
    for each one. There's an important difference between this event and the `user:join`
    event we emitted previously. In the `join` event listener, we use `io.sockets.emit`,
    which emits the event to all sockets. Here, we use `socket.emit`. This way, only
    that socket will receive these events.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we''re ready to write the view that allows our users
    to join the chat rooms. We''ll put this code in our `User` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a `Marionette.ItemView` class, so we don''t have to write the
    `render` method ourselves. Instead of passing in a `model`, when creating an instance
    of this class, we''re putting it right here in the class definition (this is possible
    in a regular Backbone view too; it''s not special to Marionette). We''re doing
    this because of the template. Normally, our views that display forms don''t have
    models, but this one does because we want to use this template for multiple views.
    We will use a template with the ID `form`. The template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is very basic. It has only an input element and a button. The placeholder
    text and the button text need to come from a model, so that's why we add a basic
    Backbone model with the right attributes to this class definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `events` property is not new or special. When we click on the button, we'll
    call the `addUser` method (of this class). The `ui` property, on the other hand,
    is special to Marionette views; we often need to reference specific elements of
    the view from within view methods, and the `ui` property is a shortcut to access
    them. The keys are the names by which we'll refer to the element, and the value
    is a selector for the element. In this case, we find the input element and call
    it `input`. You can see this in use in the `addUser` method. Instead of searching
    for the input element with `this.$("input")`, we can just reference `this.ui.input`;
    it's even a jQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: In `addUser`, we start by preventing the default submission of the form. Then,
    we get whatever name the user typed into the textbox, and send it to the collection's
    `addUser` method. In our callback function, if the user has successfully joined
    the chat rooms, we'll trigger the `user-added` event on this view. This is the
    Backbone equivalent of emitting an event with Socket.IO (this isn't Marionette-specific;
    you can trigger and listen for events in plain Backbone applications as well).
    Later, we'll listen for this event. If the user did not join successfully, we'll
    clear the input element so that they can try a new name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the `Controller.prototype.index` method in the `router.js`
    file. We need to render a `LogInView` instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is where the collection in the `addUser` method comes from.
    With this code in place, things are starting to get interesting. If you open `http://localhost:3000`,
    you'll see a textbox and button. Type in a name and click on **Join**; and the
    name will appear above in the list. Now, the magic begins. Open the site in another
    browser tab. You'll see the first name already in the list. Go ahead and add another
    one; it will appear in the list. Now, go back to the first window. You'll see
    that it also received the second name. Isn't that amazing! This works for two
    reasons. First, Socket.IO makes sure every new user is added to the user collection
    of every connected browser. Then, Marionette's `CollectionView` will immediately
    render new models added to the collection, which is why it appears in the list
    without us doing any manual rendering or watching the collection for changes.
  prefs: []
  type: TYPE_NORMAL
- en: There's a little problem, though. If you close the second window and go back
    to the first one, you'll find that both names are still in the list. We need to
    remove a name from the collection when a user closes the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in `server.js`. When a socket disconnects from the server, we
    get a disconnect event; so let''s listen for that (within the `connection` event
    callback). We can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When this socket disconnects, we check the user's object to see whether there's
    an entry for this Socket ID. Remember, if the user never tried to join the chat
    rooms (maybe they loaded the page and then closed it), they won't have an entry;
    that's why we check. If they do, we'll emit a `user:leave` event to all sockets,
    and then delete that entry from our users hash.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that our user collection is listening for the `user:leave` event,
    and when it occurs, the user will be removed from the collection. Accordingly,
    Marionette will update the `User.CollectionView`. Now, if you do our quick-and-dirty
    test in the browser again, you'll see that when you close the second browser window,
    the second name disappears from the first window. Clever, no?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before leaving the user module behind, let''s add one more feature. Later,
    we''ll be writing some CSS for our application; so let''s highlight the user''s
    own name in the list. In the `ItemView` class in the `User` module, let''s add
    a method called `onRender`. This method will be called after the view has been
    rendered. Here''s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's quick and simple. If the model we're rendering this view for has the same
    name as the user in this browser, add the class `highlight` to the element.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a user has selected their screen name, the next step is selecting a room.
    This is a bit more complex than choosing a name because they can either choose
    from a list of existing rooms, or they can start a new room by typing in a new
    name. If the user types in the name of an existing room, they'll go to the existing
    rooms because we obviously can't have multiple rooms with the same name. The tricky
    part in all this is that while we're calling them rooms, they're actually more
    like tags. The only place they exist is as a property on the chat messages; they
    aren't stored on their own. When a user creates a new room, there's no actual
    record of the room until they write the first message in that room. If they create
    a room and then close the page, the room doesn't exist. All this will make it
    a bit trickier to keep track of the rooms, but we love a good challenge, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file, `rooms.js`, in `public`. Just like our `user.js` file, this
    will have a model, collection, model view, collection view, and form view. The
    following code shows how we start with this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the module `Room`, and we start with `RoomModel`. This model has a
    single method; it returns the URL for the room. The plan is to eventually allow
    users to go straight to the room of their choice by having it in the URL. This
    makes specific rooms easy to bookmark. Of course, they''ll still have to enter
    their screen name before they can actually see the room, but it will omit the
    "choose a room" step from the process. We''ll use this method to get the route
    to a given room model. Next, we write the collection, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in our `User.Collection` class, the `initialize` method here listens
    for an event. In this case, it''s the `room:new` event. When that happens, we''ll
    call this class''s `getRoom` method. This method probably doesn''t look like what
    you''d expect. Its purpose, in this context is to add the room to the collection
    if it isn''t already there. You might expect it to look something like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, later on we'll also need a method that takes a room name, and either
    returns the existing room by that name or creates a new room with that name, and
    this is exactly what the `getRoom` method does. As it turns out, the logic in
    `getRoom` is exactly the same as this example `addRoom` method. If the room doesn't
    exist, add it. So our `getRoom` method is a two-for-one deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move over to `server.js` for a moment. When a new socket connects, we
    need to send the list of existing rooms to this room collection. Inside the function
    that is run when a new socket connects, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing in the preceding code is finding all the records in our database;
    these records are the chat messages. What we need to do is convert this array
    of messages into a list of the rooms that they are in. Although we don't have
    any messages yet, each one will have a `room` property. We loop over each model
    and add a property to a disposable `rooms` object. As an object can't have multiple
    properties with the same name, the result will be an object whose keys are a unique
    list of the existing rooms. Then, we can use `Object.keys` to get an array of
    just those keys; finally, we'll loop over that array and emit the `room:new` event
    for each room. As we've just seen, the `Room.Collection` instance will catch these
    on the browser's end and fill the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our model and collection, we can make their respective views
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RoomView` class is the item view in this case. It will be a list item
    element; the template has the ID `room`. Here''s that template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the list of rooms will be links; then in the view, we'll listen
    for a click on one of these anchor elements. When that happens, we'll prevent
    the default reloading of the page, and use Backbone to navigate to the room's
    URL. This time, instead of pulling a method from the router, we're using the `Backbone.history.navigate`
    method. Of all the ways of changing the route that we've looked at, this is clearly
    the best one (of course, it's good to know about the others).
  prefs: []
  type: TYPE_NORMAL
- en: The `Room.CollectionView` class is very basic. We just make the wrapping element
    a list and point to the item view.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all we need to display the list of existing rooms. However, if a user
    wants to create a new room, we need a view for that. So, here''s that view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Room.CreateRoomView` class will use the same form template that we used
    in `Login View`, so the whole class will look pretty similar. We're adding the
    model here, so we can set the template's placeholder text and button text. When
    the button is clicked, we'll call the `createRoom` method. This method will prevent
    the default form submission and then get the text from the input element. As our
    room names will be used in URLs, we need to clean the name up a bit by first replacing
    all spaces with underscores and then removing all other non-word characters. Then,
    we pass the room name to the collection's `getRoom` function. As we know, this
    will return a room (either a newly created one or an existing one with that name).
    Then, we'll navigate to that room's URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these classes, we can use them. First, in `index.ejs`, add
    the `Room` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Controller` function in `router.js`, add the following line of
    code. It will be the collection object that our application uses to keep track
    of the rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to our controller''s `index` function; we''ve already written part
    of it, but here''s the whole new and improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As earlier, we render the list of users and the login form. However, we're also
    rendering our new rooms collection in the appropriate collection view in the `rooms`
    region of the layout. Then, we listen for the `user-added` event on the login
    form. Remember, that event will be emitted when a user successfully joins the
    site. When that happens, we'll render a different view in the `controls` region;
    the view to create a new room. We can't forget to give that view the collection,
    to which it can add the new room. The Backbone `on` method takes a context variable
    as a third parameter, so we can use `this` inside the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you test our application, you''ll see that after you put in a screen
    name, the form will change and ask for a room name, as shown in the following
    screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining a room](img/6997OS_05_03.jpg)![Joining a room](img/6997OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, there's no list of room names to choose from as we haven't stored
    any messages yet, but if you look at the DOM, you'll see the empty `<ul>` element
    waiting. Type in a room name and click on the button, and two things should happen.
    First, the room name should appear on screen in a list. Second, the URL will change
    to the room route.
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL change means we need to add a route to our `Router` class. In the
    `appRoutes` property, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means that we need to create a `room` method on our controller prototype.
    Before we write the method, think of this; if choosing a room sends our user to
    the room route, it's also possible that the user could directly to the route.
    If they do this, the room will be selected, but the user will not have chosen
    a screen name. This means that this method will have to check for the presence
    of a screen name, and if a screen name hasn't been given, we'll have to get one
    before showing the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as it is possible that this route will be loaded directly (and not via
    Backbone through the room link), we''ll need to render the user list and the room
    list. Since we''ll do this first in all the routes we will end up creating, let''s
    move that into a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `showUsersAndRooms` method on the controller prototype renders those views
    in the right regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write one more helper function. As we figured out, if the user hasn''t
    selected a screen name yet, we''ll need to display the same view we''re showing
    in the `index` route: `logInView`. So let''s write a `showLogin` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create `loginView`, display it in the `controls` region, and then return
    the view. We return it because the route function that calls this helper function
    will probably want to listen for that `user-added` event. With these two helper
    functions in place, we can really clean up the `index` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the reason for creating these helper functions is that they''ll also
    be useful in the room route function we need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We first render the users and rooms lists. Then, we set a property on our global
    `App` object for the room that the user chooses to view. Then, we check to see
    whether `App.name` is set. If the user has come from the `index` route (or has
    switched rooms by clicking on a link from the list), `App.name` will be set. If
    it isn't set, we'll show the login form. If the name is set, or after the name
    is set (determined by the `user-added` event we're listening for), we'll need
    to render the chat room conversation. To do this, we need to create the `Chat`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chat module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the `Chat` module, we''ll create the `chat.js` file within `public`.
    Once again, we''ll start with the model and collection classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Message` model is very simple, but the `Chat.Collection` class is a little
    more interesting. First, notice that this function takes two parameters: `models`
    and `options`. We never actually expect to receive any models, but it is a Backbone
    convention for a collection to receive these two parameters. So, we''ll follow
    this convention. We expect that option''s object to have the name of the room
    that these messages are in. Once we have that name, we can emit the `room:join`
    event with two parameters: the name of the room and a callback function. The function
    is this collection''s `add` method. We expect the server to call the callback
    function with a list of all the messages currently in the room. Then, for all
    messages created after the collection is created, the server will emit a `message:new`
    event. We''ll pick up on this `message:new` event here, and if the room on the
    new message is in the same room as the room this `Chat.Collection` instance is
    for, we''ll add it to the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''ll add item and collection views as we''ve done before. Here''s how
    that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MessageView` is simple: a list item element that will render the message
    template. Here''s that template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Every message will have a user name, the text of the message, and the date and
    time when the message was created. Notice that we're not displaying the date value
    as it is. Instead, we use the Moment library to convert that date to a string
    such as `10 minutes ago`. As we've done in previous applications, we can go ahead
    and download Moment ([http://momentjs.com](http://momentjs.com)) and add the appropriate
    script tag to `index.ejs`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CollectionView` makes use of the `onRender` function in an interesting
    way. After the view renders, this function will set a timeout, to recall the `render`
    method again in 60 seconds. This is done so that the *time ago* timestamp will
    update on our message views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last view for this module is the `Chat.CreateMessageView` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to our other two form views. We have the model for setting
    the placeholder and button text. Then, when we click on the button, we run the
    `addMessage` method. This method will prevent the form from getting submitted,
    and then emit a `message:new` event to the server. As data, we get the user's
    name, the text in the input element, the name of the room that the user is currently
    in, and the current date and time. All this data is sent to the server. Then,
    we clear the input element, and focus it for the next message.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're done with `chat.js`, add it to the `index.ejs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happens on the server? Well, that''s where we listen for the the `message:new`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When that happens, we'll insert the data into the database. Once it has been
    successfully saved, we'll emit the `message:new` event to all connected clients.
    Those viewing the room this message was in will see it almost immediately. We
    also search the database for records in the same room. If a user has started a
    new chat room, there will be only one message with that room name (the one we
    just saved). However, this also means that all the other clients don't yet have
    this room in their `Room.Collection` object. So, we'll send them all a `room:new`
    event with the room's name.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `Chat` module created, we can turn back to the controller, where we
    want to render the chat for the chosen room. Let''s create a helper function for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `controls` region, we put `Chat.CreateMessageView`. Then, in the `conversation`
    region, we render a `Chat.CollectionView` instance. Now, in our `Controller.prototype.room`
    method, we can call this `showChat` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, this route is complete. Once we have a name, we'll show the chat messages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some other routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we have two routes. However, we want to add a few more. Next, we'll
    add a `/user/:name` route, so that the user can skip the logging-in step. For
    example, I could go directly to `http://localhost:3000/user/Andrew`, and I wouldn't
    have to log in; I could just choose a room. While this may not be practical or
    realistic, I think it's a fun touch that is very simple to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the router class, add the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write this method in the controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll call our `showUsersAndRooms` helper method to display the lists
    of users and rooms. Then, we'll call the user collection's `addUser` method. Remember
    that this method will decide whether the user can use the screen name they chose.
    Since the screen name is part of the URL, we get it as a parameter to the function.
    In the callback function, if the user has successfully joined, we'll display `CreateRoomView`
    where they can start a new room (alternatively, they can click on a room in the
    rooms list). Otherwise, we'll redirect them to the root route where they can choose
    an unused screen name.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ve made it possible for someone coming to our application to choose
    either their screen name or a room right from the URL. Why don''t we take it one
    step further and allow users to do both? We can make it work in both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the router, add the following lines of code to the `appRoutes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start with the `room_user` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We start by calling `showUsersAndRooms` again. Then, we get the room model through
    the name given to us in the URL. Lastly, we try to log the user in. If they join
    successfully, we'll show the chat room they chose. If they need to pick another
    screen name, we'll redirect them to the URL for that room.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, the `user_room` method simply switches the order of the
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have all the functionality we need in place! Our application is
    just about finished. All it needs now is a coat of paint.
  prefs: []
  type: TYPE_NORMAL
- en: Writing CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since styling isn't the main purpose of this book, we've left this for the end;
    if you aren't interested, jump to the chapter summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'While our application is functioning very well right now, it''s certainly not
    easy on the eyes. Let''s fix that. First, we''ll link to a stylesheet from the
    `<head>` element in the `index.ejs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create that file in `style.css` within `public`. We''ll start with some
    generic styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It's really just a mini reset; we use several `<ul>` elements in this application,
    so this will be important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few lines of code are mainly for styling the list of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The users and room lists will be the sidebars on the left and right, respectively.
    We'll set their width and margin, shrink the font size a bit, and then float them
    to the left. We then do some basic styling for the user list items. You'll recall
    that we added the `highlight` class to the user view for the logged-in user; we're
    defining that class here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we style the list of rooms with these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Then, we provide some styling for the user list; it's a bit more complex as
    the list items have anchor elements inside them. Of course, we add some basic
    hover styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we style the conversation itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `conversation` region goes in the middle, between the two sidebars, so it
    is important that it be floated to the left-hand side as well. The `<span>` element
    we style is where the date and time of the message will be displayed, so we shrink
    the text a bit, and move it to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we style the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The last portion of the CSS styles is the `control` region. This is where all
    the forms will be displayed. We're doing something a bit different here. We're
    using a position that is fixed to attach it to the bottom of the screen. Now,
    the conversation can get as long as it wants, but the message form will always
    be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the code is complete. The following is a screenshot of the final application
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing CSS](img/6997OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you found this chapter interesting. The biggest idea we've looked at
    here is using Marionette instead of plain Backbone to build our application. As
    you've seen, when using a framework designed for large applications, there's a
    lot more of what you might call scaffolding code. Basing everything on an application
    object, using modules, splitting routers and controllers, it all makes for a lot
    more moving parts. Here's the thing; the application we've built here really can't
    be called large, so you might think it doesn't really make that much sense to
    use Marionette. However, if you've worked on any large projects, you know that
    the more code that's involved, the more you'll appreciate the constructs that
    a framework like Marionette gives you. That extra level of boundaries is certainly
    not required, but I think you'll find that it can be extremely helpful and that
    it keeps a huge project manageable as it grows and changes.
  prefs: []
  type: TYPE_NORMAL
- en: The other big idea in this chapter was Socket.IO. In this application, we completely
    ignored the built-in syncing channels that Backbone gives us, but as I mentioned
    earlier, that's not the only way it can be done. Now would be a good time to go
    back and look at the implementation of `Backbone.sync` using Socket.IO, and maybe
    even build a small application to test it. The bigger thing to take away from
    the way in which we used Socket.IO is that Backbone is just another tool, and
    there's no one right way to use it. Don't ignore the conventions and suggestions
    of the Backbone community, but don't be afraid to bend it to your will and see
    what happens. We'll do more of this in the next chapter when we create a podcast
    subscription application.
  prefs: []
  type: TYPE_NORMAL
