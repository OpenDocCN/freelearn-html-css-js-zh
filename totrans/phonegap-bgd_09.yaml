- en: Chapter 9. Getting Ready for Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So far, you''ve created your app with PhoneGap, defined the building blocks
    of its interface, and learned to use various APIs provided by PhoneGap. In this
    chapter, you will consolidate the app architecture and learn how to prepare your
    app for your final release to the public. You can optimize your application using
    various methods to give your users a solid UX experience.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to compress your JavaScript and also learn why this is especially important
    for a mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to introduce JavaScript dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about template engines and how to compress template files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create fluid, multiple views of your app using PhoneGap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to create hardware-accelerated transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to use common code base for web and mobile platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring JavaScript compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer programming, we refer to the process of removing unnecessary characters
    from the source code files, and eventually concatenating them, as **file compression**.
    When dealing with web standards, we can compress any file type, including HTML,
    CSS, and JavaScript. The main goal of this process is to reduce the file size
    in order to speed up download time.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of compressing your source code when working with PhoneGap
    is performance improvement. When dealing with a mobile app, the files are compiled
    as a single file that eventually loads external data. However, when dealing with
    an app built using PhoneGap, the files, even if they are stored locally, have
    to be loaded in the browser (that is, the **WebView**). Smaller files will be
    executed faster, so the end user will get a better experience with a more responsive
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: You may think that what really matters on a mobile device is the memory consumption,
    and that compression will not cause a great reduction of memory usage because
    the original file and the minified one are interpreted into the same code. However,
    there are compression tools that can affect the runtime performance as well. The
    following sections discuss three of the most popular compression tools that may
    help improve the performance of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Google Closure Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google Closure** is a set of open source tools built in order to help developers
    speed up the development process of modern web applications. The project consists
    of a JavaScript optimizer, comprehensive JavaScript library, server-side and client-side
    template engine, and JavaScript style checker and style fixer. As a complete overview
    of Google Closure is beyond the scope of this book, we will focus only on the
    compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the sentences that best describes the compiler comes from the online
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Instead of compiling from a source language to machine code, it compiles
    from JavaScript to better JavaScript.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can use the compiler in one of the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use it online at [http://closure-compiler.appspot.com/home](http://closure-compiler.appspot.com/home)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download a Java application from [http://closure-compiler.googlecode.com/files/compiler-latest.zip](http://closure-compiler.googlecode.com/files/compiler-latest.zip)
    and execute it through the command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the API provided by Google (see [https://developers.google.com/closure/compiler/docs/gettingstarted_api](https://developers.google.com/closure/compiler/docs/gettingstarted_api))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you open the online application, you can specify in the left pane the URLs
    of the scripts you want to compile, what kind of optimization you want to be applied
    to the output file, and if you want the output to be formatted for readability.
    On the right pane of the web application, you will get a report dealing with the
    original size and the optimized size of the file, the compiled code, a list of
    warnings, eventually some errors, and the POST data sent to the Closure Compiler
    APIs. The warnings provided refer to possible mistakes in the source code and
    optimization that can be performed. For a reference to possible warning messages,
    go to [https://developers.google.com/closure/compiler/docs/error-ref](https://developers.google.com/closure/compiler/docs/error-ref).
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Closure Compiler](img/B03476_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you prefer working with the command-line tool, you can download the compiler
    application and execute it, specifying the compiling options and the input and
    output files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You get the same result when using the online tool; however, using the command
    line saves you an extra step: you don''t have to upload the source code first.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use the advanced optimization, be aware that the renaming process will
    be more aggressive, the unused code will be removed, and the body of the function
    calls will be replaced with the body of the function itself (this process is known
    as **function inlining**).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – compressing files using the Closure Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to get a compressed and optimized file using the Google
    Closure Compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and unzip the Closure Compiler application available at [http://dl.google.com/closure-compiler/compiler-latest.zip](http://dl.google.com/closure-compiler/compiler-latest.zip).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the command-line tool, move to the unzipped folder, and create a folder
    named `sample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new folder, create three files: `index.html`, `test.js`, and `index.js`.
    You can use the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `test.js` file and define a self-executing function. Within the body
    of the function, declare two other functions and return one of them in order to
    be able to run this code from another JavaScript file (the purpose of the two
    functions is to mimic a real use case when some code is kept internal to a closure
    and some other is exposed through a returning object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `index.js` file and declare a variable in order to store the result
    of the self-executing function and make a call to the `init` function returned
    by the function itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return to the command-line tool and run the compiler against the JavaScript
    files you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the generated file and take a look at the source code; you will get the
    following JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Insert the `script` tag in the HTML page referring to the new optimized JavaScript
    file and open it in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You discovered the potential of the `ADVANCED_OPTIMIZATIONS` compilation level
    of the Closure Compiler. As you can see, it's pretty aggressive. In fact, if you
    run the same command using the files you have created for your actual project,
    you will not be able to run the application as intended. In short, ensure to check
    whether the `ADVANCED_OPTIMIZATIONS` option breaks your code; if so, you should
    consider using a different level of compression.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will discover how to optimize and compress JavaScript modules using
    UglifyJS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to get an exhaustive guide to the Closure Compiler, refer to the online
    reference at [https://developers.google.com/closure/compiler/docs/api-tutorial3](https://developers.google.com/closure/compiler/docs/api-tutorial3)
    or just type `$ java -jar compiler.jar --help` in your command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: UglifyJS2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **UglifyJS** project became very popular when jQuery started to use it.
    Being used by one of the *de facto* standard JavaScript libraries resulted in
    a lot of feedback to the author, which in turn helped him fix a number of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The new version of the project, named **UglifyJS2**, is slower than the previous
    one, but the overall compression results are much better and there are more advanced
    features such as multilevel source maps (basically, it's a way to map a combined/minified
    file back to an unbuilt state) like in the Google Closure Compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'UglifyJS2 is distributed as a Node.js module. In order to install it, you can
    proceed as with any other Node.js module. Open the command-line tool and use npm
    to install the `uglify-js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, compressing your JavaScript files just got a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using UglifyJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how you can get a compressed version of the same files you worked
    on with the Google Closure Compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your command-line tool and go to the sample folder created to test the
    Closure Compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command in order to concatenate the JavaScript files and
    to run the UglifyJS2 compressor. For Windows, you can use the `copy` command to
    concatenate the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the generated file and take a look at the source code; you will get the
    following JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Insert the `script` tag in the HTML page and open it in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a compressed version of two simple JavaScript files. As you can
    see, the output is rather different from the one created with the Closure Compiler.
    One of the main features of UglifyJS2 is that the generated output doesn't break
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete reference, you can check the project page on GitHub at [https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you run UglifyJS2 in order to compress the files created in [Chapter 4](ch04.html
    "Chapter 4. Working with Plugins"), *Working with Plugins*, you will be able to
    run the application as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization with RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RequireJS includes an optimization tool named **r.js** that combines related
    scripts together into build layers and minifies them via UglifyJS or the Closure
    Compiler. The tool can be used through Node.js or Java. When using the Closure
    Compiler, it's mandatory to run the tool using Java.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer is better than using a plain concatenation script because it runs
    RequireJS as part of the optimization, so it knows how to load the plugins and
    all the dependencies of the JavaScript modules needed in your application.
  prefs: []
  type: TYPE_NORMAL
- en: For an exhaustive guide to r.js, refer to the readme file available on GitHub
    at [https://github.com/jrburke/r.js](https://github.com/jrburke/r.js).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – optimizing JavaScript with RequireJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to optimize the source code of your app using Node.js and
    RequireJS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `requirejs` module using npm from the command-line tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the root folder of the app you worked on in the previous chapters, create
    a file named `build.js`, and add to it the build process configuration info (that
    is, the JavaScript folder, the paths to the library used in the project, the name
    of the main file of the app, and the output folder and filename):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the command-line tool again and execute the following command in order
    to build the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `index.html` file and change the entry point of your app in the `script`
    tag in the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `index.html` file in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a compressed version of the app's JavaScript files minified in a
    single file, specifying the command-line options using a build file. The result
    is that the code of the app is now optimized using UglifyJS2 (the engine that
    works behind the scenes) and it still works perfectly. In order to get a complete
    overview of the build options, refer to the sample build file available on GitHub
    at [https://github.com/jrburke/r.js/blob/master/build/example.build.js](https://github.com/jrburke/r.js/blob/master/build/example.build.js).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer to use the Closure Compiler to compress and optimize the app''s
    JavaScript files, you have to download the binaries of Rhino (an open source implementation
    of JavaScript written entirely in Java) available at [https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino](https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino),
    download r.js from the RequireJS website at [http://requirejs.org/docs/download.html#rjs](http://requirejs.org/docs/download.html#rjs),
    add the `optimize: ‘closure''` option to the build file, and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `classpath` refers to the full path to Rhino and the Closure Compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing compression tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered three of the most popular compression tools. Each tool has
    its pros and cons. As always, the right tool for you is the one that best fits
    your needs. The following table summarizes the results, in bytes, you can get
    compressing a RequireJS file itself with the tools we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Original size | Compressor | Size |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RequireJS | 82944 | UglifyJS2 | 24576 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Closure | 13312 |'
  prefs: []
  type: TYPE_TB
- en: '| r.js | 15360 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, in this example, Google Closure yields the best result, but
    that is not always the case. If you run the same tests on the popular RaphaelJS
    library, you get the best result with Google Closure Compiler instead. The results
    vary depending on the source code writing style; for this reason, there is no
    single best tool to use. I prefer r.js because it can run the compressor engine
    as well as handle the plugins and module dependencies very well.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript task runners such as Gulp or Grunt can be used to create tasks to
    link, compress, and concatenate your resources automatically whenever there are
    some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other compression tools you may consider include KJScompress, Bananascript,
    JSMin, ShrinkSafe, and YUI Compressor.
  prefs: []
  type: TYPE_NORMAL
- en: Using template engine compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work on larger HTML projects, it's advisable to use JavaScript templating
    engines and image compressions. When the application needs to be updated frequently
    with data, templating libraries will be of much use. I strongly believe that there
    is no such thing as *the* best JavaScript template engine. Each time you work
    on a project, you have to decide which is the right engine for the job at hand.
    For instance, **Underscore.js** templates are fast and lightweight and if you
    want them already loaded in your app, then it's a good option. When using jQuery,
    the natural choice seems to be **ICanHaz.js** because it returns each template
    as a jQuery object. When you need a more robust template engine, then **Google
    Closure Templates** could be a valid option. For a comparison of templating engines,
    visit [http://garann.github.io/template-chooser/](http://garann.github.io/template-chooser/).
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, **Mustache.js** completely fits the needs of an application because
    there is no logic in the templates and because the templates are language-agnostic,
    allowing you to reuse them between frontend and backend. There are several template
    engines based on **Mustache.js**, including **Handlebars.js**, **Hogan.js**, or
    **Pistachio**.
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars.js is a superset of Mustache.js that adds some useful features such
    as block expressions, helpers, and more (refer to the online documentation at
    [http://handlebarsjs.com/](http://handlebarsjs.com/) for a complete overview).
  prefs: []
  type: TYPE_NORMAL
- en: Hogan.js is a very powerful compiler for Mustache.js templates from Twitter.
    Hogan.js is also delivered with a command-line utility that compiles all the `*.mustache`
    templates stored in a folder; the utility is located in the `hogan.js-template/bin`
    folder. More information about Hogan.js is available on GitHub at [https://github.com/twitter/hogan.js](https://github.com/twitter/hogan.js).
  prefs: []
  type: TYPE_NORMAL
- en: Pistachio is not just another JavaScript template engine based on Mustache.js.
    Its package contains a pure JavaScript compiler that compiles templates into self-contained
    JavaScript functions that can be used in every JavaScript environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start using Pistachio''s compiler, you can install it as a Node.js
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you can compile a template by typing `pistachio` followed by
    the path to the file you want compile.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting features of Pistachio's compiler are the capability to compile
    a template as an AMD module or CommonJS compatible module and the possibility
    to create the output as a jQuery object. A template compiled with Pistachio is
    still dynamic and can be compressed even more using the Google Closure Compiler.
    For a complete reference on Pistachio, go to [https://npmjs.org/package/pistachio](https://npmjs.org/package/pistachio).
  prefs: []
  type: TYPE_NORMAL
- en: A compressed template speeds up your application rendering because you can cache
    it as a JavaScript function and avoid continuously loading and unloading it with
    an **AJAX** request (with some performance penalties involved) when the app is
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to include multiple templates in a file, you can simply store them
    in `script` tags, assign an ID to each tag, and then use the `getElementByID()`
    document object method and the `innerHTML` HTMLElement object property to render
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – compiling a template using Pistachio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new template file and eventually compress it using Pistachio. Follow
    the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your command-line tool and move to the folders containing the template
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the `pistachio` command and specify the name of the output file and the
    file to compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a build file named, for instance, `template-build.js`, for the existing
    template to use when compressing the file with UglifyJS2, specifying the template
    name and the desired output filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the r.js Node module from the command-line tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the file and check its syntax and size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You created a compressed version of the template file that is stored in a variable.
    You can now request it in the modules of the app and avoid any unnecessary XMLHttpRequest.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is most beneficial when working with pretty big and complex templates.
    Throughout this book, you will discover some advanced template caching techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fluid, multiple app views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of PhoneGap is that the app UI and logic are built upon
    web standards. A mobile app is made up of several views that allow the user to
    interact with its core features. As for a web app, when working with PhoneGap,
    you can think of a view as a web page or a fragment of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: You can create multiple views in your app using different HTML pages or dynamically
    changing the markup of a single HTML page. The first approach is usually known
    as **multipage pattern**; the second one is known as **single-page pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the multipage pattern is best suited to applications that
    mostly comprise static content or applications that rely mostly on the server
    for the business logic. When most of the content is static, you can package it
    using PhoneGap and deliver it as an app. When the business logic is defined on
    the server, you can think of the client as the presentation layer of your app
    and rely on a good mobile connection to make it available to users. In both cases,
    your client-side code should be pretty simple and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The multipage approach has some disadvantages. For instance, when the user navigates
    from one page to the next, the browser has to reload and parse all the JavaScript
    associated with the new page. Also, because the JavaScript code is reloaded, all
    application state is lost if your app does not use other techniques such as local
    storage or the HTML5 history state object to maintain it.
  prefs: []
  type: TYPE_NORMAL
- en: The single-page pattern overcomes the disadvantages associated with the multipage
    approach. The PhoneGap and app JavaScript code is loaded just once, removing the
    need to pass application state from one page to the next. The disadvantage of
    this approach is an increased complexity of the JavaScript that contains most
    of the business logic and that it is required to update the UI when navigation
    occurs. Single-page applications are best written using the MVC design pattern
    and libraries such as AngularJS can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference between the two patterns is that with the single-page
    pattern, the PhoneGap JavaScript bridge is loaded once. There's a noticeable pause
    when it's loaded due to the fact that the link between the JavaScript APIs and
    the native counterparts is created. When the app loads the PhoneGap JavaScript
    API once, the UI appears more responsive and the user experience is improved.
  prefs: []
  type: TYPE_NORMAL
- en: Using hardware-accelerated transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much has been said about the use of **graphics processing unit** (**GPU**) hardware
    acceleration in smartphone and tablet web browsers. The general scheme is to offload
    tasks that would otherwise be calculated by the main CPU to the GPU in your computer's
    graphics adapter. (For a very detailed article to better understand hardware-accelerated
    transitions, go to [https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers](https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers).)
  prefs: []
  type: TYPE_NORMAL
- en: 'GPU can accelerate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The general layout compositing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the CSS transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS 3D transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the canvas drawing operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create smooth animations with the new CSS transitions by pretty easily
    defining them in your style sheets or you can rely on external libraries.
  prefs: []
  type: TYPE_NORMAL
- en: CSS transitions are supported in the latest versions of Firefox, Safari, and
    Chrome. They're supported in IE 10 and above. If CSS animations aren't supported
    in a given browser, then the properties will be applied instantly, gracefully
    degrading. There are several techniques to handle a CSS transition. I will use
    **Alice.js**, which is an interesting JavaScript library that allows you to execute
    hardware-accelerated transitions in your app.
  prefs: []
  type: TYPE_NORMAL
- en: AliceJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AliceJS (A Lightweight Independent CSS Engine) is a JavaScript library that
    leverages hardware-accelerated capabilities of browsers in order to generate visual
    effects. One of the strengths of the library is that it doesn't rely on other
    libraries and that it's self-contained in a single JavaScript file (for a complete
    reference and some interesting examples, refer to the official website at [http://blackberry.github.com/Alice/demos/index.html](http://blackberry.github.com/Alice/demos/index.html).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time you want to create a transition with AliceJS, you have to set up
    a configuration object. This object varies depending on the effect or plugin you
    are using. However, some configuration properties are shared between all the effects
    and plugins, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elems`: This is the target element(s) or node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate`: This is the rotation angle in degrees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perspectiveOrigin`: This is the anchor point, which can be `top-left`, `top-center`,
    `top-right`, `center`, and so on, or the explicit coordinates in percentage of
    the entire size of `div`, for example, `{x: 200, y: 200}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: This is the duration of the effect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timing`: This is the easing function as per standard CSS specs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: This determines how long before the animation starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iteration`: This is the number of iterations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction`: This specifies whether the animation should be played in reverse
    mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playstate`: This is either `running` or `paused`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this way, it''s possible to easily configure a CSS-based animation without
    any additional required know-how. There are three plugins for AliceJS and they
    include a few animation types. The following is the simple code from the Alice
    documentation to create a wobble effect by using the Cheshire plugin. So, we need
    to include the core and the plugin file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is pretty simple; for a complete overview, please refer
    to the online documentation of AliceJS.
  prefs: []
  type: TYPE_NORMAL
- en: Porting web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that PhoneGap/Cordova allows you to have a common code base for all
    mobile platforms. PhoneGap helps to package your HTML, CSS, and JavaScript code
    so that it can be installed in a mobile device and can be used as an app in different
    types of platforms such as Android, iOS, Firefox, and so on. It's not a surprise
    now. However, did you know that, with some planning, you can convert your existing
    web application to a hybrid mobile app?
  prefs: []
  type: TYPE_NORMAL
- en: If you are a web developer, you can even create a mobile app with your existing
    knowledge of web development and can sell in app marketplaces. You can save a
    lot of time and money by avoiding redevelopment.
  prefs: []
  type: TYPE_NORMAL
- en: PhoneGap/Cordova provides a lot of APIs to access device features such as the
    camera, accelerometer, and more. In this way, PhoneGap gives developers the ability
    to create a full-featured mobile app using web technologies. However, you can't
    use such device-related APIs in your web application. So, you have to design your
    code base so that it provides modularity.
  prefs: []
  type: TYPE_NORMAL
- en: The way a user interacts with an Android app is different from interacting with
    an iOS app and so on. So, there has to be careful planning on the design factors
    of the app. You might need tweaks on each platform to have a better user experience.
    You can use responsive design and media queries to target multiple screen sizes,
    devices, and display destinations (standard or high-density).
  prefs: []
  type: TYPE_NORMAL
- en: Providing a robust design for a common code base is beyond the scope of this
    book. However, there are lots of success stories of porting web applications to
    hybrid mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to optimize the source code of your app and
    also how to compress the templates that you use; we also saw various code compression
    methods. With this, we have completed our learning and it's time to put them to
    work. In the next chapter, we will create an app to demonstrate all our knowledge
    of PhoneGap.
  prefs: []
  type: TYPE_NORMAL
