<html><head></head><body>
        

                            
                    <h1 class="header-title">Producing Graphics from Data - the Foundations of D3</h1>
                
            
            
                
<p>We have acquired our toolbox and reviewed the basics of SVG. It is now time to explore D3.js. D3 is the evolution of the Protovis (<a href="http://mbostock.github.io/protovis/">http://mbostock.github.io/protovis/</a>) library. If you have already delved into data visualization have been interested in making charts for your web application, you might have already used this library. Additional libraries also exist that can be differentiated by how quickly they rendered graphics and their compatibility with different browsers. For example, Internet Explorer did not support SVG but used its own implementation, VML. This made the <kbd>Raphaël.js</kbd> library an excellent option because it automatically mapped to either VML or SVG. On the other hand, jqPlot was easy to use, and its simplistic jQuery plugin interface allowed developers to adopt it very quickly.</p>
<p>However, Protovis had something different. Given the vector nature of the library, it allowed you to illustrate different kinds of visualizations, as well as generate fluid transitions. Please feel free to look at the links provided and see for yourself. Examine the force-directed layout at: <a href="http://mbostock.github.io/protovis/ex/force.html">http://mbostock.github.io/protovis/ex/force.html</a>. In 2010, these were interesting and compelling visualizations, especially for the browser.</p>
<p>Inspired by Protovis, a team at Stanford University (consisting of Jeff Heer, Mike Bostock, and Vadim Ogievetsky) began to focus on D3. D3, and its application to SVG, gave developers an easy way to bind their visualizations to data and add interactivity.</p>
<p>There is a wealth of information available for researching D3. A great resource for complete coverage can be found on the D3 website at: <a href="https://github.com/mbostock/d3/wiki">https://github.com/mbostock/d3/wiki</a>. In this chapter, we will introduce the following concepts that will be used throughout this book:</p>
<ul>
<li>Creating basic SVG elements</li>
<li>The <kbd>enter()</kbd> function</li>
<li>The <kbd>update</kbd> function</li>
<li>The <kbd>exit()</kbd> function</li>
<li>AJAX</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating basic SVG elements</h1>
                
            
            
                
<p>A common operation in D3 is to select a DOM element and append SVG elements. Subsequent calls will then set the SVG attributes, which we learned about in <a href="029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml">Chapter 2</a>, <em>Creating Images from Simple Text</em>. D3 accomplishes this operation through an easy-to-read, functional syntax called <strong>method chaining</strong>. Let's walk through a very simple example to illustrate how this is accomplished (go to <kbd>http://localhost:8080/chapter-3/example-1.html</kbd> if you have the http-server running):</p>
<pre>var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200) </pre>
<p>First, we select the <kbd>body</kbd> tag and append an SVG element to it. This SVG element has a width and height of <kbd>200</kbd> pixels. We also store the selection in a variable:</p>
<pre>svg.append('rect') 
    .attr('x', 10) 
    .attr('y', 10) 
    .attr("width",50) 
    .attr("height",100); </pre>
<p>Next, we use the <kbd>svg</kbd> variable and append a <kbd>&lt;rect&gt;</kbd> item to it. This <kbd>rect</kbd> item will start at (<kbd>10</kbd>,<kbd>10</kbd>) and will have a width of <kbd>50</kbd> and a height of <kbd>100</kbd>. From your Chrome browser, open the Chrome developer tools with the Elements tab selected and inspect the SVG element:</p>
<div><img src="img/231de160-0a34-433b-adf5-c07cf1a53e08.png"/></div>
<p>Notice the pattern: <kbd>append('svg')</kbd> creates <kbd>&lt;svg&gt;&lt;/svg&gt;</kbd>. <kbd>attr('width',200)</kbd> and <kbd>attr('height',200)</kbd> sets <kbd>width="200"</kbd> and <kbd>height="200"</kbd>  respectively. Together, they produce the SVG syntax we learned about in the previous chapter:</p>
<pre>&lt;svg width="200" height="200"&gt;...&lt;/svg&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The enter() function</h1>
                
            
            
                
<p>The <kbd>enter()</kbd> function is a part of every basic D3 visualization. It allows the developer to define a starting point with attached data. The <kbd>enter()</kbd> function can be thought of as a section of code that executes when data is applied to the visualization for the first time. Typically, the <kbd>enter()</kbd> function will follow the selection of a DOM element. Let's walk through an example (<kbd>http://localhost:8080/chapter-3/example-2.html</kbd>):</p>
<pre>var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); </pre>
<p>Create the SVG container as we did earlier, as follows:</p>
<pre>svg.selectAll('rect').data([1,2]).enter() </pre>
<p>The <kbd>data</kbd> function is the way we bind data to our selection. In this example, we are binding a very simple array, <kbd>[1,2]</kbd>, to the selection <kbd>&lt;rect&gt;</kbd>. The <kbd>enter()</kbd> function will loop through the <kbd>[1,2]</kbd> array and apply the subsequent function calls, as shown in the following code:</p>
<pre>.append('rect') 
.attr('x', function(d){ return d*20; }) 
.attr('y', function(d){ return d*50; }) </pre>
<p>As we loop through each element in the array, we will do the following:</p>
<ul>
<li>Append a new <kbd>rect</kbd> SVG element</li>
<li>Position the <kbd>rect</kbd> element in coordinates <em>x = d * 20</em> and <em>y = d * 50</em> for the element, where <em>d</em> is equal to 1 for the first element and 2 for the second element, as shown in the following code:</li>
</ul>
<pre>.attr("width",50) 
.attr("height",100); </pre>
<p>We will keep <kbd>height</kbd> and <kbd>width</kbd> the same:</p>
<pre>&lt;svg width="200" height="200"&gt; 
  &lt;rect x="20" y="50" width="50" height="100"&gt;&lt;/rect&gt; 
  &lt;rect x="40" y="100" width="50" height="100"&gt;&lt;/rect&gt; 
&lt;/svg&gt; </pre>
<p>Look closely; take a peek at the Chrome developer tools. We see two rectangles, each corresponding to one element in our array, as shown in the following screenshot:</p>
<div><img src="img/daa6cee2-47f6-4921-939b-0d4471d5cdef.png"/></div>
<p>Remember, data doesn't necessarily have to be boring numbers, such as 1 or 2. The data array can consist of any data objects. To illustrate this, we will change the previous array to an array of objects in the next example (see <kbd>http://localhost:8080/chapter-3/example-3.html</kbd>):</p>
<div><img src="img/f6b2fa09-9fac-418b-84f1-013715088026.png"/></div>
<p>As you can see in the following code snippet, our data array has two objects, each one with four different key-value pairs: </p>
<pre>var data = [ 
  { 
    x:10, 
    y:10, 
    width:5, 
    height:40 
  },{ 
    x:40, 
    y:10, 
    width:100, 
    height:40 
  } 
]; 
 
  var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); 
 
  svg.selectAll('rect').data(data).enter() 
    .append('rect') 
    .attr('x', function(d){ return d.x}) 
    .attr('y', function(d){ return d.y}) 
    .attr("width", function(d){ return d.width}) 
    .attr("height", function(d){ return d.height}); </pre>
<p>Now, as we loop through each object in the array, we will do the following:</p>
<ul>
<li>Still append a new <kbd>rect</kbd> SVG element.</li>
<li>Position and size the <kbd>rect</kbd> element by the properties of the object. The first rectangle will be positioned at <kbd>x=10</kbd>, <kbd>y=10</kbd>, and have a width of <kbd>5</kbd> and a height of <kbd>40</kbd>. The second rectangle will be positioned at <kbd>40</kbd>, <kbd>10</kbd>, and will have a width of <kbd>100</kbd> and a height of <kbd>40</kbd>.</li>
<li>Remember that <kbd>d</kbd> represents the datum, or each object within the array, which is why we refer to <kbd>d.x</kbd> or <kbd>d.y</kbd> to get  <kbd>x</kbd> and <kbd>y</kbd>  properties accordingly.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The update function</h1>
                
            
            
                
<p>Not only do we have our rectangles, but we've also joined them to a dataset composed of two objects. Both objects share the same properties, namely <kbd>x</kbd>, <kbd>y</kbd>, <kbd>width</kbd>, and <kbd>height</kbd>, so it's easy to loop through them and read/bind the values to our visualization. The output of this is a set of static SVG elements. This section will cover how to update the SVG elements and properties as the joined data changes. Let's enhance the previous example to explain exactly how this works (<kbd>http://localhost:8080/chapter-3/example-4.html</kbd>):</p>
<div><img height="249" width="428" src="img/4a0b87c0-44ac-4e67-aa23-ac4bf804d111.png"/></div>
<pre>function makeData(n){ 
  var arr = []; 
 
  for (var i=0; i&lt;n; i++){ 
    arr.push({ 
      x:Math.floor((Math.random() * 100) + 1), 
      y:Math.floor((Math.random() * 100) + 1), 
      width:Math.floor((Math.random() * 100) + 1), 
      height:Math.floor((Math.random() * 100) + 1) 
    }) 
  }; 
 
  return arr; 
} </pre>
<p>This function creates a new array of objects with random properties for <kbd>x</kbd>, <kbd>y</kbd>, <kbd>width</kbd>, and <kbd>height</kbd>. We can use this to simulate a change in data, allowing us to create <kbd>n</kbd> number of items, all with different properties:</p>
<pre>var rectangles = function(svg) { </pre>
<p>Here, we create a function that inserts rectangles into the DOM on every invocation of D3. The description is as follows:</p>
<pre>var data = makeData(2); </pre>
<p>Let's generate our fake data:</p>
<pre>var rect = svg.selectAll('rect').data(data); </pre>
<p>Let's select our rectangle and assign our data to it. This gives us a variable to which we can easily apply <kbd>enter()</kbd> and <kbd>update</kbd> later. The following sections are written in a verbose way to illustrate exactly what is going on with <kbd>enter()</kbd>, <kbd>update</kbd>, and <kbd>exit()</kbd>. While it's possible to take shortcuts in D3, it's best to stick to the following style to prevent confusion:</p>
<pre>  // Enter 
  rect.enter().append('rect') 
    .attr('test', function(d,i) { 
      // Enter called 2 times only 
      console.log('enter placing initial rectangle: ', i) 
    }); </pre>
<p>As in the previous section, for each element in the array we append a rectangle tag to the DOM. If you're running this code in your Chrome browser, you will notice that the console only displays <kbd>enter placing initial rectangle</kbd> twice. This is because the <kbd>enter()</kbd> section is called only when there are more elements in the array than in the DOM:</p>
<pre>  // Update 
  rect.transition().duration(500).attr('x', function(d){ <br/>     return d.x; }) 
      .attr('y', function(d){ return d.y; }) 
      .attr('width', function(d){ return d.width; }) 
      .attr('height', function(d){ return d.height; }) 
      .attr('test', function(d, i) { 
        // update every data change 
        console.log('updating x position to: ', d.x) 
      }); </pre>
<p>The <kbd>update</kbd> section is applied to every element in the original selection, excluding entered elements. In the previous example, we set the <kbd>x</kbd>, <kbd>y</kbd>, <kbd>width</kbd>, and <kbd>height</kbd> attributes of the rectangle for every data object. The <kbd>update</kbd> section is not defined with an explicit <kbd>update</kbd> method. D3 implies an <kbd>update</kbd> call if no other section is provided. If you are running the code in your Chrome browser, you will see the console display <kbd>updating x position to:</kbd> every time the data changes:</p>
<pre>var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); </pre>
<p>The following command inserts our working SVG container:</p>
<pre>rectangles(svg); </pre>
<p>The following command draws the first version of our visualization:</p>
<pre>setInterval(function(){ 
  rectangles(svg); 
},1000); </pre>
<p>The <kbd>setInterval()</kbd> function is the JavaScript function used to execute an operation every <em>x</em> milliseconds. In this case, we are calling the <kbd>rectangles</kbd> function every <kbd>1000</kbd> milliseconds.</p>
<p>The <kbd>rectangles</kbd> function generates a new dataset every time it is called. It has the same property structure that we had before, but the values tied to those properties are random numbers between <em>1</em> and <em>100</em>. On the first call, the <kbd>enter()</kbd> section is invoked and we create our initial two rectangles. Every <kbd>1000</kbd> milliseconds, we reinvoke the <kbd>rectangles</kbd> function with the same data structure but different random property attributes. Because the structure is the same, the <kbd>enter()</kbd> section is now skipped and only <kbd>update</kbd> is reapplied to the existing rectangles. This is why we get the same rectangles with different dimensions every time we plot.</p>
<p>The <kbd>update</kbd> method is very useful. For instance, your dataset could be tied to the stock market and you could update your visualization every <em>n</em> milliseconds to reflect the changes in the stock market. You could also bind the update to an event triggered by a user and have the user control the visualization. The options are endless.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The exit() function</h1>
                
            
            
                
<p>We've discussed <kbd>enter()</kbd> and <kbd>update</kbd>. We've seen how one determines the starting point of our visualization and the other modifies its attributes based on new data coming in. However, the examples covered had the exact number of data elements with the same properties. What would happen if our new dataset had a different amount of items? What if it has fewer or more?</p>
<p>Let's take the <kbd>update</kbd> part of the previous example and modify it a bit to demonstrate what we're talking about (<kbd>http://localhost:8080/chapter-3/example-5.html</kbd>):</p>
<div><img height="315" width="538" src="img/5f76fdbf-f2e6-46c7-9874-fa5ffb2673a1.png"/></div>
<p>We can explain how this works with two small changes to the <kbd>rectangles</kbd> function:</p>
<pre>var rectangles = function(svg) { 
var data = makeData((Math.random() * 5) + 1); </pre>
<p>Here, we tell the <kbd>data</kbd> function to create a random number of <kbd>data</kbd> objects:</p>
<pre>  var rect = svg.selectAll('rect').data(data); 
 
  // Enter 
  rect.enter().append('rect') 
    .attr('test', function(d,i) { 
      // Enter called 2 times only 
      console.log('enter placing inital rectangle: ', i) 
  }); 
 
  // Update 
  rect.transition().duration(500).attr('x', function(d){ return d.x; }) 
      .attr('y', function(d){ return d.y; }) 
      .attr('width', function(d){ return d.width; }) 
      .attr('height', function(d){ return d.height; }) 
      .attr('test', function(d, i) { 
        // update every data change 
        console.log('updating x position to: ', d.x) 
      }); </pre>
<p>The <kbd>exit()</kbd> function will be the same as before. Add a new <kbd>exit()</kbd> section:</p>
<pre>  // Exit 
  rect.exit().attr('test', function(d) { 
    console.log('no data...') 
  }).remove(); 
} </pre>
<p>The <kbd>exit()</kbd> method serves the purpose of cleansing or cleaning the no-longer-used DOM items in our visualization. This is helpful because it allows us to join our data with DOM elements, keeping them in sync. An easy way to remember this is as follows: if there are more data elements than DOM elements, the <kbd>enter()</kbd> section will be invoked; if there are fewer data elements than DOM elements, the <kbd>exit()</kbd> section will be invoked. In the previous example, we just removed the DOM element if there was no matching data.</p>
<p>The following is a graphical representation of the sequence that occurs when <kbd>enter()</kbd> and <kbd>update</kbd> functions are called. Notice that there's no DOM element for data element <strong>6</strong>, so, the <kbd>enter()</kbd> section is executed. For data elements <strong>0</strong> to <strong>5</strong>, the update code is always called. For data element <strong>6</strong>, the <strong>update</strong> section will be executed after the <strong>enter</strong> process has completed. Refer to the following diagram:</p>
<div><img src="img/5779c5c0-edf9-4116-ae68-efda44678cc4.png"/></div>
<p>This illustrates what happens when you have fewer data elements than DOM elements. The <strong>update</strong> section is always called where there is a match, as shown in the following diagram:</p>
<div><img src="img/0c82b03b-0e3d-4ec9-b653-e49415b12ee1.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">AJAX</h1>
                
            
            
                
<p><strong>Asynchronous JavaScript and XML</strong> (<strong>AJAX</strong>) doesn't relate 100 percent to D3. It actually has its foundation in JavaScript. In short, AJAX allows the developer to obtain data from the background of the web page. This technique is extremely useful in map development because geographic datasets can be very large. Acquiring the data from the background will help produce a refined user experience. In addition, in <a href="80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml">Chapter 6</a>, <em>Finding and Working with Geographic Data</em>, we will cover techniques to compress the size of geographic data.</p>
<p>Separating the data from the code base will also provide the following advantages:</p>
<ul>
<li>A lighter code base that is easier to manage</li>
<li>The ability to update the data without making code changes</li>
<li>The ability to use third-party providers for data sources</li>
</ul>
<p>This is accomplished by acquiring the data through an AJAX call with the aid of a D3 function. Let's examine the following code:</p>
<pre>d3.json("data/dataFile.json", function(error, json) { </pre>
<p>The <kbd>d3.json()</kbd> method has two parameters: a path to the file and a callback function. The callback function indicates what to do with the data once it has been transferred. In the previous code, if the call fetches the data correctly, it assigns it to the <kbd>json</kbd> variable. The <kbd>error</kbd> variable is just a general error object that indicates whether there were any problems fetching the data or not:</p>
<pre>if (error) return console.log(error); 
var data = json; </pre>
<p>We store our JSON data into the data variable, and continue to process it as we did in the previous examples:</p>
<pre>  var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); 
 
  svg.selectAll('rect') 
    .data(data).enter() 
    .append('rect') 
    .attr('x', function(d){ return d.x; }) 
    .attr('y', function(d){ return d.y; }) 
    .attr("width", function(d){ return d.width; }) 
    .attr("height", function(d){ return d.height; }); 
}); </pre>
<div><img height="496" width="534" src="img/6fbec84a-5332-4bf2-ac79-a7a14cf5147c.png"/></div>
<p>D3 provides us with many kinds of data acquisition methods, and JSON is just one type. It also supports CSV files, plain text files, XML files, or even entire HTML pages. We strongly suggest that you read about AJAX in the documentation at: <a href="https://github.com/d3/d3/blob/master/API.md#requests-d3-request">https://github.com/d3/d3/blob/master/API.md#requests-d3-request</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we explained the core elements of D3 (<kbd>enter()</kbd>, <kbd>update</kbd>, and <kbd>exit()</kbd>).<br/>
We understood the power of joining data to our visualization. Not only can data come from many different sources, but it is possible to have the visualization automatically updated as well.</p>
<p>Many detailed examples can be found in the D3 Gallery at: <a href="https://github.com/mbostock/d3/wiki/Gallery">https://github.com/mbostock/d3/wiki/Gallery</a>.</p>
<p>In the next chapter, we will combine all of these techniques to build our first map from scratch. Get ready!</p>


            

            
        
    </body></html>