<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Producing Graphics from Data - the Foundations of D3</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have acquired our toolbox and reviewed the basics of SVG. </span><span class="koboSpan" id="kobo.2.2">It is now time to explore D3.js. </span><span class="koboSpan" id="kobo.2.3">D3 is the evolution of the Protovis (</span><a href="http://mbostock.github.io/protovis/"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">http://mbostock.github.io/protovis/</span></span></a><span class="koboSpan" id="kobo.4.1">) library. </span><span class="koboSpan" id="kobo.4.2">If you have already delved into data visualization have been interested in making charts for your web application, you might have already used this library. </span><span class="koboSpan" id="kobo.4.3">Additional libraries also exist that can be differentiated by how quickly they rendered graphics and their compatibility with different browsers. </span><span class="koboSpan" id="kobo.4.4">For example, Internet Explorer did not support SVG but used its own implementation, VML. </span><span class="koboSpan" id="kobo.4.5">This made the </span><kbd><span class="koboSpan" id="kobo.5.1">Raphaël.js</span></kbd><span class="koboSpan" id="kobo.6.1"> library an excellent option because it automatically mapped to either VML or SVG. </span><span class="koboSpan" id="kobo.6.2">On the other hand, jqPlot was easy to use, and its simplistic jQuery plugin interface allowed developers to adopt it very quickly.</span></p>
<p><span class="koboSpan" id="kobo.7.1">However, Protovis had something different. </span><span class="koboSpan" id="kobo.7.2">Given the vector nature of the library, it allowed you to illustrate different kinds of visualizations, as well as generate fluid transitions. </span><span class="koboSpan" id="kobo.7.3">Please feel free to look at the links provided and see for yourself. </span><span class="koboSpan" id="kobo.7.4">Examine the force-directed layout at: </span><a href="http://mbostock.github.io/protovis/ex/force.html"><span class="URLPACKT"><span class="koboSpan" id="kobo.8.1">http://mbostock.github.io/protovis/ex/force.html</span></span></a><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">In 2010, these were interesting and compelling visualizations, especially for the browser.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Inspired by Protovis, a team at Stanford University (consisting of Jeff Heer, Mike Bostock, and Vadim Ogievetsky) began to focus on D3. </span><span class="koboSpan" id="kobo.10.2">D3, and its application to SVG, gave developers an easy way to bind their visualizations to data and add interactivity.</span></p>
<p><span class="koboSpan" id="kobo.11.1">There is a wealth of information available for researching D3. </span><span class="koboSpan" id="kobo.11.2">A great resource for complete coverage can be found on the D3 website at: </span><a href="https://github.com/mbostock/d3/wiki"><span class="URLPACKT"><span class="koboSpan" id="kobo.12.1">https://github.com/mbostock/d3/wiki</span></span></a><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">In this chapter, we will introduce the following concepts that will be used throughout this book:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Creating basic SVG elements</span></li>
<li><span class="koboSpan" id="kobo.15.1">The </span><kbd><span class="koboSpan" id="kobo.16.1">enter()</span></kbd><span class="koboSpan" id="kobo.17.1"> function</span></li>
<li><span class="koboSpan" id="kobo.18.1">The </span><kbd><span class="koboSpan" id="kobo.19.1">update</span></kbd><span class="koboSpan" id="kobo.20.1"> function</span></li>
<li><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">exit()</span></kbd><span class="koboSpan" id="kobo.23.1"> function</span></li>
<li><span class="koboSpan" id="kobo.24.1">AJAX</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating basic SVG elements</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A common operation in D3 is to select a DOM element and append SVG elements. </span><span class="koboSpan" id="kobo.2.2">Subsequent calls will then set the SVG attributes, which we learned about in </span><a href="029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Creating Images from Simple Text</span></em><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">D3 accomplishes this operation through an easy-to-read, functional syntax called </span><strong><span class="koboSpan" id="kobo.7.1">method chaining</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Let's walk through a very simple example to illustrate how this is accomplished (go to </span><kbd><span class="koboSpan" id="kobo.9.1">http://localhost:8080/chapter-3/example-1.html</span></kbd><span class="koboSpan" id="kobo.10.1"> if you have the http-server running):</span></p>
<pre><span class="koboSpan" id="kobo.11.1">var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200) </span></pre>
<p><span class="koboSpan" id="kobo.12.1">First, we select the </span><kbd><span class="koboSpan" id="kobo.13.1">body</span></kbd><span class="koboSpan" id="kobo.14.1"> tag and append an SVG element to it. </span><span class="koboSpan" id="kobo.14.2">This SVG element has a width and height of </span><kbd><span class="koboSpan" id="kobo.15.1">200</span></kbd><span class="koboSpan" id="kobo.16.1"> pixels. </span><span class="koboSpan" id="kobo.16.2">We also store the selection in a variable:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">svg.append('rect') 
    .attr('x', 10) 
    .attr('y', 10) 
    .attr("width",50) 
    .attr("height",100); </span></pre>
<p><span class="koboSpan" id="kobo.18.1">Next, we use the </span><kbd><span class="koboSpan" id="kobo.19.1">svg</span></kbd><span class="koboSpan" id="kobo.20.1"> variable and append a </span><kbd><span class="koboSpan" id="kobo.21.1">&lt;rect&gt;</span></kbd><span class="koboSpan" id="kobo.22.1"> item to it. </span><span class="koboSpan" id="kobo.22.2">This </span><kbd><span class="koboSpan" id="kobo.23.1">rect</span></kbd><span class="koboSpan" id="kobo.24.1"> item will start at (</span><kbd><span class="koboSpan" id="kobo.25.1">10</span></kbd><span class="koboSpan" id="kobo.26.1">,</span><kbd><span class="koboSpan" id="kobo.27.1">10</span></kbd><span class="koboSpan" id="kobo.28.1">) and will have a width of </span><kbd><span class="koboSpan" id="kobo.29.1">50</span></kbd><span class="koboSpan" id="kobo.30.1"> and a height of </span><kbd><span class="koboSpan" id="kobo.31.1">100</span></kbd><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">From your Chrome browser, open the Chrome developer tools with the </span><span class="packt_screen"><span class="koboSpan" id="kobo.33.1">Elements</span></span><span class="koboSpan" id="kobo.34.1"> tab selected and inspect the SVG element:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.35.1"><img src="assets/231de160-0a34-433b-adf5-c07cf1a53e08.png"/></span></div>
<p><span class="koboSpan" id="kobo.36.1">Notice the pattern: </span><kbd><span class="koboSpan" id="kobo.37.1">append('svg')</span></kbd><span class="koboSpan" id="kobo.38.1"> creates </span><kbd><span class="koboSpan" id="kobo.39.1">&lt;svg&gt;&lt;/svg&gt;</span></kbd><span class="koboSpan" id="kobo.40.1">. </span><kbd><span class="koboSpan" id="kobo.41.1">attr('width',200)</span></kbd><span class="koboSpan" id="kobo.42.1"> and </span><kbd><span class="koboSpan" id="kobo.43.1">attr('height',200)</span></kbd><span class="koboSpan" id="kobo.44.1"> sets </span><kbd><span class="koboSpan" id="kobo.45.1">width="200"</span></kbd><span class="koboSpan" id="kobo.46.1"> and </span><kbd><span class="koboSpan" id="kobo.47.1">height="200"</span></kbd><span class="koboSpan" id="kobo.48.1">  respectively. </span><span class="koboSpan" id="kobo.48.2">Together, they produce the SVG syntax we learned about in the previous chapter:</span></p>
<pre><span class="koboSpan" id="kobo.49.1">&lt;svg width="200" height="200"&gt;...&lt;/svg&gt; </span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The enter() function</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">enter()</span></kbd><span class="koboSpan" id="kobo.4.1"> function is a part of every basic D3 visualization. </span><span class="koboSpan" id="kobo.4.2">It allows the developer to define a starting point with attached data. </span><span class="koboSpan" id="kobo.4.3">The </span><kbd><span class="koboSpan" id="kobo.5.1">enter()</span></kbd><span class="koboSpan" id="kobo.6.1"> function can be thought of as a section of code that executes when data is applied to the visualization for the first time. </span><span class="koboSpan" id="kobo.6.2">Typically, the </span><kbd><span class="koboSpan" id="kobo.7.1">enter()</span></kbd><span class="koboSpan" id="kobo.8.1"> function will follow the selection of a DOM element. </span><span class="koboSpan" id="kobo.8.2">Let's walk through an example (</span><kbd><span class="koboSpan" id="kobo.9.1">http://localhost:8080/chapter-3/example-2.html</span></kbd><span class="koboSpan" id="kobo.10.1">):</span></p>
<pre><span class="koboSpan" id="kobo.11.1">var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); </span></pre>
<p><span class="koboSpan" id="kobo.12.1">Create the SVG container as we did earlier, as follows:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">svg.selectAll('rect').data([1,2]).enter() </span></pre>
<p><span class="koboSpan" id="kobo.14.1">The </span><kbd><span class="koboSpan" id="kobo.15.1">data</span></kbd><span class="koboSpan" id="kobo.16.1"> function is the way we bind data to our selection. </span><span class="koboSpan" id="kobo.16.2">In this example, we are binding a very simple array, </span><kbd><span class="koboSpan" id="kobo.17.1">[1,2]</span></kbd><span class="koboSpan" id="kobo.18.1">, to the selection </span><kbd><span class="koboSpan" id="kobo.19.1">&lt;rect&gt;</span></kbd><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">The </span><kbd><span class="koboSpan" id="kobo.21.1">enter()</span></kbd><span class="koboSpan" id="kobo.22.1"> function will loop through the </span><kbd><span class="koboSpan" id="kobo.23.1">[1,2]</span></kbd><span class="koboSpan" id="kobo.24.1"> array and apply the subsequent function calls, as shown in the following code:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">.append('rect') 
.attr('x', function(d){ return d*20; }) 
.attr('y', function(d){ return d*50; }) </span></pre>
<p><span class="koboSpan" id="kobo.26.1">As we loop through each element in the array, we will do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">Append a new </span><kbd><span class="koboSpan" id="kobo.28.1">rect</span></kbd><span class="koboSpan" id="kobo.29.1"> SVG element</span></li>
<li><span class="koboSpan" id="kobo.30.1">Position the </span><kbd><span class="koboSpan" id="kobo.31.1">rect</span></kbd><span class="koboSpan" id="kobo.32.1"> element in coordinates </span><em><span class="koboSpan" id="kobo.33.1">x = d * 20</span></em><span class="koboSpan" id="kobo.34.1"> and </span><em><span class="koboSpan" id="kobo.35.1">y = d * 50</span></em><span class="koboSpan" id="kobo.36.1"> for the element, where </span><em><span class="koboSpan" id="kobo.37.1">d</span></em><span class="koboSpan" id="kobo.38.1"> is equal to 1 for the first element and 2 for the second element, as shown in the following code:</span></li>
</ul>
<pre><span class="koboSpan" id="kobo.39.1">.attr("width",50) 
.attr("height",100); </span></pre>
<p><span class="koboSpan" id="kobo.40.1">We will keep </span><kbd><span class="koboSpan" id="kobo.41.1">height</span></kbd><span class="koboSpan" id="kobo.42.1"> and </span><kbd><span class="koboSpan" id="kobo.43.1">width</span></kbd><span class="koboSpan" id="kobo.44.1"> the same:</span></p>
<pre><span class="koboSpan" id="kobo.45.1">&lt;svg width="200" height="200"&gt; 
  &lt;rect x="20" y="50" width="50" height="100"&gt;&lt;/rect&gt; 
  &lt;rect x="40" y="100" width="50" height="100"&gt;&lt;/rect&gt; 
&lt;/svg&gt; </span></pre>
<p><span class="koboSpan" id="kobo.46.1">Look closely; take a peek at the Chrome developer tools. </span><span class="koboSpan" id="kobo.46.2">We see two rectangles, each corresponding to one element in our array, as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.47.1"><img src="assets/daa6cee2-47f6-4921-939b-0d4471d5cdef.png"/></span></div>
<p><span class="koboSpan" id="kobo.48.1">Remember, data doesn't necessarily have to be boring numbers, such as 1 or 2. </span><span class="koboSpan" id="kobo.48.2">The data array can consist of any data objects. </span><span class="koboSpan" id="kobo.48.3">To illustrate this, we will change the previous array to an array of objects in the next example (see </span><kbd><span class="koboSpan" id="kobo.49.1">http://localhost:8080/chapter-3/example-3.html</span></kbd><span class="koboSpan" id="kobo.50.1">):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.51.1"><img src="assets/f6b2fa09-9fac-418b-84f1-013715088026.png"/></span></div>
<p><span class="koboSpan" id="kobo.52.1">As you can see in the following code snippet, our data array has two objects, each one with four different key-value pairs: </span></p>
<pre><span class="koboSpan" id="kobo.53.1">var data = [ 
  { 
    x:10, 
    y:10, 
    width:5, 
    height:40 
  },{ 
    x:40, 
    y:10, 
    width:100, 
    height:40 
  } 
]; 
 
  var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); 
 
  svg.selectAll('rect').data(data).enter() 
    .append('rect') 
    .attr('x', function(d){ return d.x}) 
    .attr('y', function(d){ return d.y}) 
    .attr("width", function(d){ return d.width}) 
    .attr("height", function(d){ return d.height}); </span></pre>
<p><span class="koboSpan" id="kobo.54.1">Now, as we loop through each object in the array, we will do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.55.1">Still append a new </span><kbd><span class="koboSpan" id="kobo.56.1">rect</span></kbd><span class="koboSpan" id="kobo.57.1"> SVG element.</span></li>
<li><span class="koboSpan" id="kobo.58.1">Position and size the </span><kbd><span class="koboSpan" id="kobo.59.1">rect</span></kbd><span class="koboSpan" id="kobo.60.1"> element by the properties of the object. </span><span class="koboSpan" id="kobo.60.2">The first rectangle will be positioned at </span><kbd><span class="koboSpan" id="kobo.61.1">x=10</span></kbd><span class="koboSpan" id="kobo.62.1">, </span><kbd><span class="koboSpan" id="kobo.63.1">y=10</span></kbd><span class="koboSpan" id="kobo.64.1">, and have a width of </span><kbd><span class="koboSpan" id="kobo.65.1">5</span></kbd><span class="koboSpan" id="kobo.66.1"> and a height of </span><kbd><span class="koboSpan" id="kobo.67.1">40</span></kbd><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">The second rectangle will be positioned at </span><kbd><span class="koboSpan" id="kobo.69.1">40</span></kbd><span class="koboSpan" id="kobo.70.1">, </span><kbd><span class="koboSpan" id="kobo.71.1">10</span></kbd><span class="koboSpan" id="kobo.72.1">, and will have a width of </span><kbd><span class="koboSpan" id="kobo.73.1">100</span></kbd><span class="koboSpan" id="kobo.74.1"> and a height of </span><kbd><span class="koboSpan" id="kobo.75.1">40</span></kbd><span class="koboSpan" id="kobo.76.1">.</span></li>
<li><span class="koboSpan" id="kobo.77.1">Remember that </span><kbd><span class="koboSpan" id="kobo.78.1">d</span></kbd><span class="koboSpan" id="kobo.79.1"> represents the datum, or each object within the array, which is why we refer to </span><kbd><span class="koboSpan" id="kobo.80.1">d.x</span></kbd><span class="koboSpan" id="kobo.81.1"> or </span><kbd><span class="koboSpan" id="kobo.82.1">d.y</span></kbd><span class="koboSpan" id="kobo.83.1"> to get  </span><kbd><span class="koboSpan" id="kobo.84.1">x</span></kbd><span class="koboSpan" id="kobo.85.1"> and </span><kbd><span class="koboSpan" id="kobo.86.1">y</span></kbd><span class="koboSpan" id="kobo.87.1">  properties accordingly.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The update function</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Not only do we have our rectangles, but we've also joined them to a dataset composed of two objects. </span><span class="koboSpan" id="kobo.2.2">Both objects share the same properties, namely </span><kbd><span class="koboSpan" id="kobo.3.1">x</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">y</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">width</span></kbd><span class="koboSpan" id="kobo.8.1">, and </span><kbd><span class="koboSpan" id="kobo.9.1">height</span></kbd><span class="koboSpan" id="kobo.10.1">, so it's easy to loop through them and read/bind the values to our visualization. </span><span class="koboSpan" id="kobo.10.2">The output of this is a set of static SVG elements. </span><span class="koboSpan" id="kobo.10.3">This section will cover how to update the SVG elements and properties as the joined data changes. </span><span class="koboSpan" id="kobo.10.4">Let's enhance the previous example to explain exactly how this works (</span><kbd><span class="koboSpan" id="kobo.11.1">http://localhost:8080/chapter-3/example-4.html</span></kbd><span class="koboSpan" id="kobo.12.1">):</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="249" width="428" src="assets/4a0b87c0-44ac-4e67-aa23-ac4bf804d111.png"/></span></div>
<pre><span class="koboSpan" id="kobo.14.1">function makeData(n){ 
  var arr = []; 
 
  for (var i=0; i&lt;n; i++){ 
    arr.push({ 
      x:Math.floor((Math.random() * 100) + 1), 
      y:Math.floor((Math.random() * 100) + 1), 
      width:Math.floor((Math.random() * 100) + 1), 
      height:Math.floor((Math.random() * 100) + 1) 
    }) 
  }; 
 
  return arr; 
} </span></pre>
<p><span class="koboSpan" id="kobo.15.1">This function creates a new array of objects with random properties for </span><kbd><span class="koboSpan" id="kobo.16.1">x</span></kbd><span class="koboSpan" id="kobo.17.1">, </span><kbd><span class="koboSpan" id="kobo.18.1">y</span></kbd><span class="koboSpan" id="kobo.19.1">, </span><kbd><span class="koboSpan" id="kobo.20.1">width</span></kbd><span class="koboSpan" id="kobo.21.1">, and </span><kbd><span class="koboSpan" id="kobo.22.1">height</span></kbd><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">We can use this to simulate a change in data, allowing us to create </span><kbd><span class="koboSpan" id="kobo.24.1">n</span></kbd><span class="koboSpan" id="kobo.25.1"> number of items, all with different properties:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">var rectangles = function(svg) { </span></pre>
<p><span class="koboSpan" id="kobo.27.1">Here, we create a function that inserts rectangles into the DOM on every invocation of D3. </span><span class="koboSpan" id="kobo.27.2">The description is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">var data = makeData(2); </span></pre>
<p><span class="koboSpan" id="kobo.29.1">Let's generate our fake data:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">var rect = svg.selectAll('rect').data(data); </span></pre>
<p><span class="koboSpan" id="kobo.31.1">Let's select our rectangle and assign our data to it. </span><span class="koboSpan" id="kobo.31.2">This gives us a variable to which we can easily apply </span><kbd><span class="koboSpan" id="kobo.32.1">enter()</span></kbd><span class="koboSpan" id="kobo.33.1"> and </span><kbd><span class="koboSpan" id="kobo.34.1">update</span></kbd><span class="koboSpan" id="kobo.35.1"> later. </span><span class="koboSpan" id="kobo.35.2">The following sections are written in a verbose way to illustrate exactly what is going on with </span><kbd><span class="koboSpan" id="kobo.36.1">enter()</span></kbd><span class="koboSpan" id="kobo.37.1">, </span><kbd><span class="koboSpan" id="kobo.38.1">update</span></kbd><span class="koboSpan" id="kobo.39.1">, and </span><kbd><span class="koboSpan" id="kobo.40.1">exit()</span></kbd><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">While it's possible to take shortcuts in D3, it's best to stick to the following style to prevent confusion:</span></p>
<pre><span class="koboSpan" id="kobo.42.1">  // Enter 
  rect.enter().append('rect') 
    .attr('test', function(d,i) { 
      // Enter called 2 times only 
      console.log('enter placing initial rectangle: ', i) 
    }); </span></pre>
<p><span class="koboSpan" id="kobo.43.1">As in the previous section, for each element in the array we append a rectangle tag to the DOM. </span><span class="koboSpan" id="kobo.43.2">If you're running this code in your Chrome browser, you will notice that the console only displays </span><kbd><span class="koboSpan" id="kobo.44.1">enter placing initial rectangle</span></kbd><span class="koboSpan" id="kobo.45.1"> twice. </span><span class="koboSpan" id="kobo.45.2">This is because the </span><kbd><span class="koboSpan" id="kobo.46.1">enter()</span></kbd><span class="koboSpan" id="kobo.47.1"> section is called only when there are more elements in the array than in the DOM:</span></p>
<pre><span class="koboSpan" id="kobo.48.1">  // Update 
  rect.transition().duration(500).attr('x', function(d){ </span><br/><span class="koboSpan" id="kobo.49.1">     return d.x; }) 
      .attr('y', function(d){ return d.y; }) 
      .attr('width', function(d){ return d.width; }) 
      .attr('height', function(d){ return d.height; }) 
      .attr('test', function(d, i) { 
        // update every data change 
        console.log('updating x position to: ', d.x) 
      }); </span></pre>
<p><span class="koboSpan" id="kobo.50.1">The </span><kbd><span class="koboSpan" id="kobo.51.1">update</span></kbd><span class="koboSpan" id="kobo.52.1"> section is applied to every element in the original selection, excluding entered elements. </span><span class="koboSpan" id="kobo.52.2">In the previous example, we set the </span><kbd><span class="koboSpan" id="kobo.53.1">x</span></kbd><span class="koboSpan" id="kobo.54.1">, </span><kbd><span class="koboSpan" id="kobo.55.1">y</span></kbd><span class="koboSpan" id="kobo.56.1">, </span><kbd><span class="koboSpan" id="kobo.57.1">width</span></kbd><span class="koboSpan" id="kobo.58.1">, and </span><kbd><span class="koboSpan" id="kobo.59.1">height</span></kbd><span class="koboSpan" id="kobo.60.1"> attributes of the rectangle for every data object. </span><span class="koboSpan" id="kobo.60.2">The </span><kbd><span class="koboSpan" id="kobo.61.1">update</span></kbd><span class="koboSpan" id="kobo.62.1"> section is not defined with an explicit </span><kbd><span class="koboSpan" id="kobo.63.1">update</span></kbd><span class="koboSpan" id="kobo.64.1"> method. </span><span class="koboSpan" id="kobo.64.2">D3 implies an </span><kbd><span class="koboSpan" id="kobo.65.1">update</span></kbd><span class="koboSpan" id="kobo.66.1"> call if no other section is provided. </span><span class="koboSpan" id="kobo.66.2">If you are running the code in your Chrome browser, you will see the console display </span><kbd><span class="koboSpan" id="kobo.67.1">updating x position to:</span></kbd><span class="koboSpan" id="kobo.68.1"> every time the data changes:</span></p>
<pre><span class="koboSpan" id="kobo.69.1">var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); </span></pre>
<p><span class="koboSpan" id="kobo.70.1">The following command inserts our working SVG container:</span></p>
<pre><span class="koboSpan" id="kobo.71.1">rectangles(svg); </span></pre>
<p><span class="koboSpan" id="kobo.72.1">The following command draws the first version of our visualization:</span></p>
<pre><span class="koboSpan" id="kobo.73.1">setInterval(function(){ 
  rectangles(svg); 
},1000); </span></pre>
<p><span class="koboSpan" id="kobo.74.1">The </span><kbd><span class="koboSpan" id="kobo.75.1">setInterval()</span></kbd><span class="koboSpan" id="kobo.76.1"> function is the JavaScript function used to execute an operation every </span><em><span class="koboSpan" id="kobo.77.1">x</span></em><span class="koboSpan" id="kobo.78.1"> milliseconds. </span><span class="koboSpan" id="kobo.78.2">In this case, we are calling the </span><kbd><span class="koboSpan" id="kobo.79.1">rectangles</span></kbd><span class="koboSpan" id="kobo.80.1"> function every </span><kbd><span class="koboSpan" id="kobo.81.1">1000</span></kbd><span class="koboSpan" id="kobo.82.1"> milliseconds.</span></p>
<p><span class="koboSpan" id="kobo.83.1">The </span><kbd><span class="koboSpan" id="kobo.84.1">rectangles</span></kbd><span class="koboSpan" id="kobo.85.1"> function generates a new dataset every time it is called. </span><span class="koboSpan" id="kobo.85.2">It has the same property structure that we had before, but the values tied to those properties are random numbers between </span><em><span class="koboSpan" id="kobo.86.1">1</span></em><span class="koboSpan" id="kobo.87.1"> and </span><em><span class="koboSpan" id="kobo.88.1">100</span></em><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">On the first call, the </span><kbd><span class="koboSpan" id="kobo.90.1">enter()</span></kbd><span class="koboSpan" id="kobo.91.1"> section is invoked and we create our initial two rectangles. </span><span class="koboSpan" id="kobo.91.2">Every </span><kbd><span class="koboSpan" id="kobo.92.1">1000</span></kbd><span class="koboSpan" id="kobo.93.1"> milliseconds, we reinvoke the </span><kbd><span class="koboSpan" id="kobo.94.1">rectangles</span></kbd><span class="koboSpan" id="kobo.95.1"> function with the same data structure but different random property attributes. </span><span class="koboSpan" id="kobo.95.2">Because the structure is the same, the </span><kbd><span class="koboSpan" id="kobo.96.1">enter()</span></kbd><span class="koboSpan" id="kobo.97.1"> section is now skipped and only </span><kbd><span class="koboSpan" id="kobo.98.1">update</span></kbd><span class="koboSpan" id="kobo.99.1"> is reapplied to the existing rectangles. </span><span class="koboSpan" id="kobo.99.2">This is why we get the same rectangles with different dimensions every time we plot.</span></p>
<p><span class="koboSpan" id="kobo.100.1">The </span><kbd><span class="koboSpan" id="kobo.101.1">update</span></kbd><span class="koboSpan" id="kobo.102.1"> method is very useful. </span><span class="koboSpan" id="kobo.102.2">For instance, your dataset could be tied to the stock market and you could update your visualization every </span><em><span class="koboSpan" id="kobo.103.1">n</span></em><span class="koboSpan" id="kobo.104.1"> milliseconds to reflect the changes in the stock market. </span><span class="koboSpan" id="kobo.104.2">You could also bind the update to an event triggered by a user and have the user control the visualization. </span><span class="koboSpan" id="kobo.104.3">The options are endless.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The exit() function</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We've discussed </span><kbd><span class="koboSpan" id="kobo.3.1">enter()</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">update</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">We've seen how one determines the starting point of our visualization and the other modifies its attributes based on new data coming in. </span><span class="koboSpan" id="kobo.6.3">However, the examples covered had the exact number of data elements with the same properties. </span><span class="koboSpan" id="kobo.6.4">What would happen if our new dataset had a different amount of items? </span><span class="koboSpan" id="kobo.6.5">What if it has fewer or more?</span></p>
<p><span class="koboSpan" id="kobo.7.1">Let's take the </span><kbd><span class="koboSpan" id="kobo.8.1">update</span></kbd><span class="koboSpan" id="kobo.9.1"> part of the previous example and modify it a bit to demonstrate what we're talking about (</span><kbd><span class="koboSpan" id="kobo.10.1">http://localhost:8080/chapter-3/example-5.html</span></kbd><span class="koboSpan" id="kobo.11.1">):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="315" width="538" src="assets/5f76fdbf-f2e6-46c7-9874-fa5ffb2673a1.png"/></span></div>
<p><span class="koboSpan" id="kobo.13.1">We can explain how this works with two small changes to the </span><kbd><span class="koboSpan" id="kobo.14.1">rectangles</span></kbd><span class="koboSpan" id="kobo.15.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">var rectangles = function(svg) { 
var data = makeData((Math.random() * 5) + 1); </span></pre>
<p><span class="koboSpan" id="kobo.17.1">Here, we tell the </span><kbd><span class="koboSpan" id="kobo.18.1">data</span></kbd><span class="koboSpan" id="kobo.19.1"> function to create a random number of </span><kbd><span class="koboSpan" id="kobo.20.1">data</span></kbd><span class="koboSpan" id="kobo.21.1"> objects:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">  var rect = svg.selectAll('rect').data(data); 
 
  // Enter 
  rect.enter().append('rect') 
    .attr('test', function(d,i) { 
      // Enter called 2 times only 
      console.log('enter placing inital rectangle: ', i) 
  }); 
 
  // Update 
  rect.transition().duration(500).attr('x', function(d){ return d.x; }) 
      .attr('y', function(d){ return d.y; }) 
      .attr('width', function(d){ return d.width; }) 
      .attr('height', function(d){ return d.height; }) 
      .attr('test', function(d, i) { 
        // update every data change 
        console.log('updating x position to: ', d.x) 
      }); </span></pre>
<p><span class="koboSpan" id="kobo.23.1">The </span><kbd><span class="koboSpan" id="kobo.24.1">exit()</span></kbd><span class="koboSpan" id="kobo.25.1"> function will be the same as before. </span><span class="koboSpan" id="kobo.25.2">Add a new </span><kbd><span class="koboSpan" id="kobo.26.1">exit()</span></kbd><span class="koboSpan" id="kobo.27.1"> section:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">  // Exit 
  rect.exit().attr('test', function(d) { 
    console.log('no data...') 
  }).remove(); 
} </span></pre>
<p><span class="koboSpan" id="kobo.29.1">The </span><kbd><span class="koboSpan" id="kobo.30.1">exit()</span></kbd><span class="koboSpan" id="kobo.31.1"> method serves the purpose of cleansing or cleaning the no-longer-used DOM items in our visualization. </span><span class="koboSpan" id="kobo.31.2">This is helpful because it allows us to join our data with DOM elements, keeping them in sync. </span><span class="koboSpan" id="kobo.31.3">An easy way to remember this is as follows: if there are more data elements than DOM elements, the </span><kbd><span class="koboSpan" id="kobo.32.1">enter()</span></kbd><span class="koboSpan" id="kobo.33.1"> section will be invoked; if there are fewer data elements than DOM elements, the </span><kbd><span class="koboSpan" id="kobo.34.1">exit()</span></kbd><span class="koboSpan" id="kobo.35.1"> section will be invoked. </span><span class="koboSpan" id="kobo.35.2">In the previous example, we just removed the DOM element if there was no matching data.</span></p>
<p><span class="koboSpan" id="kobo.36.1">The following is a graphical representation of the sequence that occurs when </span><kbd><span class="koboSpan" id="kobo.37.1">enter()</span></kbd><span class="koboSpan" id="kobo.38.1"> and </span><kbd><span class="koboSpan" id="kobo.39.1">update</span></kbd><span class="koboSpan" id="kobo.40.1"> functions are called. </span><span class="koboSpan" id="kobo.40.2">Notice that there's no DOM element for data element </span><strong><span class="koboSpan" id="kobo.41.1">6</span></strong><span class="koboSpan" id="kobo.42.1">, so, the </span><kbd><span class="koboSpan" id="kobo.43.1">enter()</span></kbd><span class="koboSpan" id="kobo.44.1"> section is executed. </span><span class="koboSpan" id="kobo.44.2">For data elements </span><strong><span class="koboSpan" id="kobo.45.1">0</span></strong><span class="koboSpan" id="kobo.46.1"> to </span><strong><span class="koboSpan" id="kobo.47.1">5</span></strong><span class="koboSpan" id="kobo.48.1">, the update code is always called. </span><span class="koboSpan" id="kobo.48.2">For data element </span><strong><span class="koboSpan" id="kobo.49.1">6</span></strong><span class="koboSpan" id="kobo.50.1">, the </span><strong><span class="koboSpan" id="kobo.51.1">update</span></strong><span class="koboSpan" id="kobo.52.1"> section will be executed after the </span><strong><span class="koboSpan" id="kobo.53.1">enter</span></strong><span class="koboSpan" id="kobo.54.1"> process has completed. </span><span class="koboSpan" id="kobo.54.2">Refer to the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.55.1"><img src="assets/5779c5c0-edf9-4116-ae68-efda44678cc4.png"/></span></div>
<p><span class="koboSpan" id="kobo.56.1">This illustrates what happens when you have fewer data elements than DOM elements. </span><span class="koboSpan" id="kobo.56.2">The </span><strong><span class="koboSpan" id="kobo.57.1">update</span></strong><span class="koboSpan" id="kobo.58.1"> section is always called where there is a match, as shown in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.59.1"><img src="assets/0c82b03b-0e3d-4ec9-b653-e49415b12ee1.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">AJAX</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Asynchronous JavaScript and XML</span></strong><span class="koboSpan" id="kobo.3.1"> (</span><strong><span class="koboSpan" id="kobo.4.1">AJAX</span></strong><span class="koboSpan" id="kobo.5.1">) doesn't relate 100 percent to D3. </span><span class="koboSpan" id="kobo.5.2">It actually has its foundation in JavaScript. </span><span class="koboSpan" id="kobo.5.3">In short, AJAX allows the developer to obtain data from the background of the web page. </span><span class="koboSpan" id="kobo.5.4">This technique is extremely useful in map development because geographic datasets can be very large. </span><span class="koboSpan" id="kobo.5.5">Acquiring the data from the background will help produce a refined user experience. </span><span class="koboSpan" id="kobo.5.6">In addition, in </span><a href="80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.6.1">Chapter 6</span></span></a><span class="koboSpan" id="kobo.7.1">, </span><em><span class="koboSpan" id="kobo.8.1">Finding and Working with Geographic Data</span></em><span class="koboSpan" id="kobo.9.1">, we will cover techniques to compress the size of geographic data.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Separating the data from the code base will also provide the following advantages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">A lighter code base that is easier to manage</span></li>
<li><span class="koboSpan" id="kobo.12.1">The ability to update the data without making code changes</span></li>
<li><span class="koboSpan" id="kobo.13.1">The ability to use third-party providers for data sources</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">This is accomplished by acquiring the data through an AJAX call with the aid of a D3 function. </span><span class="koboSpan" id="kobo.14.2">Let's examine the following code:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">d3.json("data/dataFile.json", function(error, json) { </span></pre>
<p><span class="koboSpan" id="kobo.16.1">The </span><kbd><span class="koboSpan" id="kobo.17.1">d3.json()</span></kbd><span class="koboSpan" id="kobo.18.1"> method has two parameters: a path to the file and a callback function. </span><span class="koboSpan" id="kobo.18.2">The callback function indicates what to do with the data once it has been transferred. </span><span class="koboSpan" id="kobo.18.3">In the previous code, if the call fetches the data correctly, it assigns it to the </span><kbd><span class="koboSpan" id="kobo.19.1">json</span></kbd><span class="koboSpan" id="kobo.20.1"> variable. </span><span class="koboSpan" id="kobo.20.2">The </span><kbd><span class="koboSpan" id="kobo.21.1">error</span></kbd><span class="koboSpan" id="kobo.22.1"> variable is just a general error object that indicates whether there were any problems fetching the data or not:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">if (error) return console.log(error); 
var data = json; </span></pre>
<p><span class="koboSpan" id="kobo.24.1">We store our JSON data into the data variable, and continue to process it as we did in the previous examples:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">  var svg = d3.select("body") 
    .append("svg") 
    .attr("width", 200) 
    .attr("height", 200); 
 
  svg.selectAll('rect') 
    .data(data).enter() 
    .append('rect') 
    .attr('x', function(d){ return d.x; }) 
    .attr('y', function(d){ return d.y; }) 
    .attr("width", function(d){ return d.width; }) 
    .attr("height", function(d){ return d.height; }); 
}); </span></pre>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="496" width="534" src="assets/6fbec84a-5332-4bf2-ac79-a7a14cf5147c.png"/></span></div>
<p><span class="koboSpan" id="kobo.27.1">D3 provides us with many kinds of data acquisition methods, and JSON is just one type. </span><span class="koboSpan" id="kobo.27.2">It also supports CSV files, plain text files, XML files, or even entire HTML pages. </span><span class="koboSpan" id="kobo.27.3">We strongly suggest that you read about AJAX in the documentation at: </span><a href="https://github.com/d3/d3/blob/master/API.md#requests-d3-request"><span class="URLPACKT"><span class="koboSpan" id="kobo.28.1">https://github.com/d3/d3/blob/master/API.md#requests-d3-request</span></span></a><span class="koboSpan" id="kobo.29.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we explained the core elements of D3 (</span><kbd><span class="koboSpan" id="kobo.3.1">enter()</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">update</span></kbd><span class="koboSpan" id="kobo.6.1">, and </span><kbd><span class="koboSpan" id="kobo.7.1">exit()</span></kbd><span class="koboSpan" id="kobo.8.1">).</span><br/><span class="koboSpan" id="kobo.9.1">
We understood the power of joining data to our visualization. </span><span class="koboSpan" id="kobo.9.2">Not only can data come from many different sources, but it is possible to have the visualization automatically updated as well.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Many detailed examples can be found in the D3 Gallery at: </span><a href="https://github.com/mbostock/d3/wiki/Gallery"><span class="URLPACKT"><span class="koboSpan" id="kobo.11.1">https://github.com/mbostock/d3/wiki/Gallery</span></span></a><span class="koboSpan" id="kobo.12.1">.</span></p>
<p><span class="koboSpan" id="kobo.13.1">In the next chapter, we will combine all of these techniques to build our first map from scratch. </span><span class="koboSpan" id="kobo.13.2">Get ready!</span></p>


            </article>

            
        </section>
    </body></html>