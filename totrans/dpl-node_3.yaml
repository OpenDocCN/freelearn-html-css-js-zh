- en: Chapter 3. Scaling Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。扩展Node
- en: Like *concurrency* and *parallelism*, *scalability* and *performance* are not
    the same thing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与*并发*和*并行性*一样，*可伸缩性*和*性能*不是同一回事。
- en: '|   | *"The terms "performance" and "scalability" are commonly used interchangeably,
    but the two are distinct: performance measures the speed with which a single request
    can be executed, while scalability measures the ability of a request to maintain
    its performance under increasing load. For example, the performance of a request
    may be reported as generating a valid response within three seconds, but the scalability
    of the request measures the request''s ability to maintain that three-second response
    time as the user load increases."* |   |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | *"性能"和"可伸缩性"这两个术语通常被互换使用，但两者是不同的：性能衡量单个请求可以执行的速率，而可伸缩性衡量请求在负载增加的情况下维持其性能的能力。例如，一个请求的性能可能报告为在3秒内生成有效的响应，但请求的可伸缩性衡量的是请求在用户负载增加时维持该3秒响应时间的能力。"*
    |   |'
- en: '|   | --*Pro Java EE 5, Steve Haines* |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   | --*《Pro Java EE 5, Steve Haines》* |'
- en: It is not unusual for a reviewer to assert that Node cannot scale across cores
    and is, therefore, unable to optimize performance on a given machine. This belief
    is based on two false impressions—that Node is "not good at" CPU-intensive tasks
    and that it *cannot scale* because its process can only leverage a single core.
    These claims are often stretched further into assertions about how Node's claim
    of being nonblocking is false, primarily by imagining locked threads and underutilized
    hardware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 审查员声称Node无法跨核心扩展，因此无法在特定机器上优化性能，这种情况并不少见。这种信念基于两个错误的印象——Node"不擅长"CPU密集型任务，以及它*不能扩展*，因为它的进程只能利用单个核心。这些说法通常进一步扩展到关于Node声称的非阻塞性是错误的断言，主要是通过想象锁定的线程和未充分利用的硬件。
- en: 'Scalable applications remain responsive under increasing load. Scalable applications
    imply that more nodes can be added to, and removed from, a system depending on
    fluctuations in both client connections and resource needs (such as more memory
    or storage space). Node aims to make it easy to conceptualize, describe, and implement
    scalable networked applications. The primary focus is on creating a toolkit to
    build structures out of many nodes connected through evented network streams communicating
    through standard protocols. Distributed systems are concerned with failure more
    than with performance and the question that arises is: how can we swap, add, and
    remove nodes intelligently within a running system?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩的应用程序在增加的负载下保持响应。可伸缩的应用程序意味着可以根据客户端连接和资源需求（如更多内存或存储空间）的变化，向系统添加更多节点或从系统中移除节点。Node旨在使概念化、描述和实现可伸缩网络应用程序变得容易。主要重点是创建一个工具包，用于构建由通过事件驱动的网络流连接并通过标准协议通信的多个节点组成的结构。分布式系统更关注故障而不是性能，出现的问题是：我们如何在运行系统中智能地交换、添加和移除节点？
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Solving the **C10K problem**, which is *the problem of optimizing network sockets
    to handle a large number of clients at the same time* ([https://en.wikipedia.org/wiki/C10k_problem](https://en.wikipedia.org/wiki/C10k_problem))
    is a key design goal for many modern application tools and environments, including
    Node.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 解决**C10K问题**，即**优化网络套接字以同时处理大量客户端的问题**（[https://en.wikipedia.org/wiki/C10k_problem](https://en.wikipedia.org/wiki/C10k_problem)），是许多现代应用程序工具和环境的关键设计目标，包括Node。
- en: We will look at two common scaling strategies—vertical and horizontal scaling.
    Vertical scaling (*scaling up*) involves increasing the ability of a single server
    to handle increasing load, usually by increasing the number of CPUs, memory, storage
    space, and so on, on a single box. Horizontally scaling systems (*scaling out*)
    respond to a load by adding or subtracting servers or other network resources.
    Deploying a scalable Node solution can be done by utilizing both of these techniques
    either individually or in tandem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种常见的扩展策略——垂直扩展和水平扩展。垂直扩展（*向上扩展*）涉及增加单个服务器处理增加负载的能力，通常是通过在单个盒子上增加CPU、内存、存储空间等。水平扩展系统（*向外扩展*）通过添加或减少服务器或其他网络资源来响应负载。通过利用这两种技术中的任何一种或同时使用它们，可以部署可伸缩的Node解决方案。
- en: Scaling vertically across multiple cores
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个核心上垂直扩展
- en: As we discussed in [Chapter 1](ch01.html "Chapter 1. Appreciating Node"), *Appreciating
    Node*, `libuv` is used within the Node environment to manage multiple I/O threads.
    The OS itself also schedules threads, distributing the work required by various
    processes. Node provides a way for a developer to take advantage of this OS-level
    scheduling by spawning and forking many processes. In this section, we will learn
    how to distribute your program's tasks across independent processes generally
    and how to distribute a Node server's load across multiple cooperating server
    processes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第一章](ch01.html "第一章。欣赏Node")中讨论的，*欣赏Node*，`libuv`在Node环境中用于管理多个I/O线程。操作系统本身也会调度线程，分配各种进程所需的工作。Node提供了一种方式，让开发者可以通过创建和派生许多进程来利用这种操作系统级别的调度。在本节中，我们将学习如何将程序的任务分配给独立进程，以及如何将Node服务器的负载分配给多个协作服务器进程。
- en: Modern software development is no longer the realm of monolithic programs. Modern
    applications are distributed and decoupled. We now build applications that connect
    users with resources distributed across the Internet. Many users are accessing
    shared resources simultaneously. A complex system is easier to understand if the
    whole is understood as a collection of interfaces to programs that solve one or
    a few clearly defined, related problems. In such a system, it is expected (and
    desirable) that processes should not sit idle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件开发不再是单体程序的地盘。现代应用程序是分布式和松耦合的。我们现在构建的应用程序将用户与分布在整个互联网上的资源连接起来。许多用户同时访问共享资源。如果一个复杂系统被理解为一个解决一个或几个明确定义、相关问题的程序接口集合，那么它就更容易理解。在这样的系统中，预期（并且是所希望的）进程不应该处于空闲状态。
- en: 'While a single Node process runs on a single core, any number of Node processes
    can be "spun up" through the use of the `child_process` module. Basic usage of
    this module is straightforward: we fetch a `ChildProcess` object and listen for
    data events. This example will call the Unix command `ls`, listing the current
    directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个Node进程在单个核心上运行，但可以通过使用`child_process`模块“启动”任意数量的Node进程。此模块的基本用法很简单：我们获取一个`ChildProcess`对象并监听数据事件。本例将调用Unix命令`ls`，列出当前目录：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we use `spawn` on the `ls` process (list directory) and read from the
    resulting readable stream, receiving something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`ls`进程（列出目录）上使用`spawn`，并从结果的可读流中读取，接收类似以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any number of child processes can be spawned in this way. It is important to
    note here that when a child process is spawned or otherwise created, the OS itself
    assigns the responsibility for that process to a given CPU. Node is not responsible
    for how an OS allocates resources. The upshot is that on a machine with eight
    cores, it is likely that spawning eight processes will result in each being allocated
    to independent processors. In other words, child processes are automatically spread
    by the OS across CPUs, putting the lie to claims that Node cannot take full advantage
    of multicore environments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以这种方式派生任意数量的子进程。这里需要注意的是，当派生或以其他方式创建子进程时，操作系统本身会将该进程的责任分配给特定的CPU。Node不负责操作系统如何分配资源。结果是，在具有八个核心的机器上，派生八个进程可能会导致每个进程被分配到独立的处理器。换句话说，子进程会自动由操作系统分配到CPU上，这反驳了Node不能充分利用多核环境的说法。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each new Node process (child) is allocated 10 MB of memory and represents a
    new V8 instance that will take at least 30 milliseconds to start up. While it
    is unlikely that you will spawn many thousands of these processes, understanding
    how to query and set OS limits on user-created processes is beneficial. You can
    use `htop` or `top` to report the number of processes currently running, or you
    can use `ps aux | wc –l` from the command line. The Unix command `ulimit` ([http://ss64.com/bash/ulimit.html](http://ss64.com/bash/ulimit.html))
    provides important information on user limits on an OS. Passing `ulimit` the `–u`
    argument will show the maximum number of user processes that can be spawned. Changing
    the limit is accomplished by passing it as an argument—`ulimit –u 8192`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的Node进程（子进程）分配了10 MB的内存，并代表一个新的V8实例，该实例至少需要30毫秒才能启动。虽然你不太可能创建成千上万的这些进程，但了解如何查询和设置用户创建的进程的操作系统限制是有益的。你可以使用`htop`或`top`来报告当前正在运行的进程数，或者你可以从命令行使用`ps
    aux | wc –l`。Unix命令`ulimit`([http://ss64.com/bash/ulimit.html](http://ss64.com/bash/ulimit.html))提供了关于操作系统上用户限制的重要信息。传递`ulimit`的`–u`参数将显示可以派生的最大用户进程数。通过传递参数来更改限制——`ulimit
    –u 8192`。
- en: 'The `child_process` module represents a class exposing four main methods: `spawn`,
    `fork`, `exec`, and `execFile`. These methods return a `ChildProcess` object that
    extends `EventEmitter`, exposing an interface to child events, and a few functions
    helpful to manage child processes. We''ll take a look at its main methods and
    follow up with a discussion of the common `ChildProcess` interface.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_process`模块代表一个类，公开四个主要方法：`spawn`、`fork`、`exec`和`execFile`。这些方法返回一个`ChildProcess`对象，它扩展了`EventEmitter`，公开了子事件接口，以及一些有助于管理子进程的函数。我们将查看其主要方法，并随后讨论常见的`ChildProcess`接口。'
- en: spawn(command, [arguments], [options])
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`spawn(command, [arguments], [options])`'
- en: 'This powerful command allows a Node program to start and interact with processes
    spawned via system commands. In the preceding example, we used `spawn` to call
    a native OS process, `ls`, passing that command the arguments `''-lh''` and `''.''`.
    In this way, any process can be started just as one might start it via a command
    line. The method takes three arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此强大命令允许Node程序通过系统命令启动和交互子进程。在先前的示例中，我们使用`spawn`调用原生OS进程`ls`，将参数`'-lh'`和`'.'`传递给该命令。这样，任何进程都可以像通过命令行启动一样启动。此方法接受三个参数：
- en: '**command**: This is a command to be executed by the OS shell'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**command**：这是由操作系统shell执行的命令'
- en: '**arguments**: These are optional command-line arguments sent as an array'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arguments**：这些是作为数组发送的可选命令行参数'
- en: '**options**: This is an optional map of settings for `spawn`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options**：这是`spawn`的设置的可选映射'
- en: 'The options for `spawn` allow its behavior to be carefully customized:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`的选项允许其行为被仔细定制：'
- en: '**cwd** (string): By default, this command will understand its current working
    directory to be the same as that of the Node process calling `spawn`. Change that
    setting using this directive.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cwd**（字符串）：默认情况下，此命令将理解其当前工作目录与调用`spawn`的Node进程相同。使用此指令更改该设置。'
- en: '**env** (object): This is used to pass environment variables to a child process,
    for instance, we spawn a child process with an environment object, such as:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**env**（对象）：这用于向子进程传递环境变量，例如，我们使用环境对象启动子进程，如下所示：'
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The child process environment will have access to the values specified in the
    preceding code.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子进程环境将能够访问前面代码中指定的值。
- en: '**detached** (Boolean): When a parent process spawns a child process, both
    processes form a group, and the parent process is normally the leader of that
    group. To make a child process the group leader, use `detached`. This allows the
    child process to continue running even after the parent process exits. Because
    the parent process waits for the child process to exit by default, you can call
    `child.unref()` to tell the parent process''s event loop that it should not count
    the child reference and exit if no other work exists.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**detached**（布尔值）：当父进程启动子进程时，两个进程形成一个组，父进程通常是该组的领导者。要使子进程成为组领导者，请使用`detached`。这允许子进程在父进程退出后继续运行。因为父进程默认会等待子进程退出，所以你可以调用`child.unref()`来告诉父进程的事件循环它不应计算子进程引用并在没有其他工作存在时退出。'
- en: '**uid** (number): Set the uid (user identity) for the child process in terms
    of standard system permissions, such as a uid that has privileges to execute on
    the child process.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uid**（数字）：以标准系统权限设置子进程的uid（用户身份），例如具有在子进程中执行权限的uid。'
- en: '**gid** (number): Set the gid (group identity) for the child process in terms
    of standard system permissions, such as a gid that has execute privileges on the
    child process.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gid**（数字）：以标准系统权限设置子进程的gid（组身份），例如具有在子进程中执行权限的gid。'
- en: '**stdio** (string or array): Child processes have file descriptors, the first
    three being `process.stdin`, `process.stdout`, and `process.stderr` standard I/O
    descriptors in that order (fds = 0,1,2). This directive allows those descriptors
    to be redefined, inherited, and so on.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stdio**（字符串或数组）：子进程有文件描述符，前三个是按顺序的`process.stdin`、`process.stdout`和`process.stderr`标准I/O描述符（fds
    = 0,1,2）。此指令允许重新定义、继承等这些描述符。'
- en: 'Normally, to read the output of the following child process program, a parent
    process would listen on `child.stdout`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了读取以下子进程程序输出，父进程会监听`child.stdout`：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If, instead, we wanted a child to inherit its parent''s `stdio` such that when
    the child writes to `process.stdout`, what is emitted is piped through to the
    parent process''s `process.stdout` stream, we would pass the relevant parent file
    descriptors to the child, overriding its own:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个子进程继承其父进程的 `stdio`，以便当子进程写入 `process.stdout` 时，所发出的内容会通过管道传输到父进程的 `process.stdout`
    流，我们将传递相关的父文件描述符给子进程，以覆盖其自身的设置：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the child's output will pipe straight through to the parent process's
    standard output channel. Also, see `fork`, in the upcoming paragraphs, for more
    information on this kind of pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，子进程的输出将直接通过管道传输到父进程的标准输出通道。此外，请参阅下文中的 `fork`，以获取有关此类模式更多信息。
- en: 'Each of the three (or more) file descriptors can take one of six values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 三个（或更多）文件描述符中的每一个可以取六个值之一：
- en: '**''pipe''**: This creates a pipe between the child process and the parent
    process. As the first three child file descriptors are already exposed to the
    parent process (`child.stdin`, `child.stdout`, `child.stderr`), this is only necessary
    in more complex child implementations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**''pipe''**：这将在子进程和父进程之间创建一个管道。由于前三个子进程文件描述符已经暴露给父进程（`child.stdin`、`child.stdout`、`child.stderr`），这在更复杂的子进程实现中是必要的。'
- en: '**''ipc''**: Create an IPC channel to pass messages between a child process
    and a parent process. A child process can have a maximum of one IPC file descriptor.
    Once this connection is established, the parent process can communicate with the
    child process via `child.send`. If the child sends JSON messages through this
    file descriptor, those emissions can be caught using `child.on("message")`. If
    you are running a Node program as a child, it is likely a better choice to use
    `ChildProcess.fork`, which has this messaging channel built in.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**''ipc''**：创建一个 IPC 通道，用于在子进程和父进程之间传递消息。子进程最多可以有一个 IPC 文件描述符。一旦建立此连接，父进程就可以通过
    `child.send` 与子进程通信。如果子进程通过此文件描述符发送 JSON 消息，则可以使用 `child.on("message")` 捕获这些输出。如果你正在以子进程的形式运行
    Node 程序，那么使用 `ChildProcess.fork` 可能是一个更好的选择，因为它内置了这种消息通道。'
- en: '**''ignore''**: The file descriptors 0–2 will have `/dev/null` attached to
    them. For others, the referenced file descriptor will not be set on the child.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**''ignore''**：文件描述符 0–2 将连接到 `/dev/null`。对于其他文件描述符，不会在子进程中设置引用的文件描述符。'
- en: '**A stream object**: This allows the parent to share a stream with the child.
    For demonstration purposes, given a child that will write the same content to
    any provided `Writable` stream, we could do something like this:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个流对象**：这允许父进程与子进程共享一个流。为了演示目的，假设有一个子进程将将相同的内容写入任何提供的 `Writable` 流，我们可以这样做：'
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The child will now fetch its content and pipe it to whichever output stream
    it has been sent to:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子进程现在将获取其内容并将其管道传输到它被发送到的任何输出流：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**An integer**: This is a file descriptor ID.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个整数**：这是一个文件描述符 ID。'
- en: '**null, undefined**: These are the default values. For file descriptors 0–2
    (`stdin`, `stdout`, `stderr`), a pipe is created. Others default to *ignore*.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**null, undefined**：这些是默认值。对于文件描述符 0–2 (`stdin`, `stdout`, `stderr`)，将创建一个管道。其他默认为
    *ignore*。'
- en: 'In addition to passing `stdio` settings as an array, certain common groupings
    can be implemented by passing a shortcut string value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以数组的形式传递 `stdio` 设置外，还可以通过传递快捷字符串值来实现某些常见的分组：
- en: '`''ignore'' = [''ignore'', ''ignore'', ''ignore'']`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''ignore'' = [''ignore'', ''ignore'', ''ignore'']`'
- en: '`''pipe'' = [''pipe'', ''pipe'', ''pipe'']`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''pipe'' = [''pipe'', ''pipe'', ''pipe'']`'
- en: '`''inherit'' = [process.stdin, process.stdout, process.stderr] or [0,1,2]`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''inherit'' = [process.stdin, process.stdout, process.stderr] or [0,1,2]`'
- en: 'It should be noted that the ability to spawn any system process means that
    one can use Node to run other application environments installed on the OS. If
    we had the popular PHP language installed, the following would be possible:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，能够启动任何系统进程的能力意味着可以使用 Node 运行操作系统上安装的其他应用程序环境。如果我们安装了流行的 PHP 语言，以下情况是可能的：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running a more interesting, larger program would be just as easy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个更有趣、更大的程序同样简单。
- en: 'Apart from the ease with which one can run Java, Ruby, or other programs through
    Node using this technique, asynchronously, we also have here a good answer to
    a persistent criticism of Node: JavaScript is not as fast as other languages for
    crunching numbers or doing other CPU-heavy tasks. This is true in the sense that
    Node is primarily optimized for I/O efficiency and helping with the management
    of high-concurrency applications, and JavaScript is an interpreted language without
    a strong focus on heavy computation.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过此技术轻松运行 Java、Ruby 或其他程序，并且异步执行之外，我们还有对 Node 持续批评的良好回应：JavaScript 在处理数字或其他
    CPU 密集型任务方面不如其他语言快。这在 Node 主要优化 I/O 效率和帮助管理高并发应用程序的意义上是正确的，而 JavaScript 是一种解释型语言，没有强烈关注重计算。
- en: However, using `spawn`, one can very easily pass massive computations and long-running
    routines on analytic engines or calculation engines to separate processes in other
    environments. Node's simple event loop will notify the main application when those
    operations are done, seamlessly integrating the resultant data. Meantime, the
    main application is free to keep serving clients.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `spawn`，可以非常容易地将大量计算和长时间运行的例程传递到分析引擎或计算引擎中的其他环境中的分离进程。Node 的简单事件循环将在这些操作完成时通知主应用程序，无缝集成结果数据。同时，主应用程序可以自由地继续服务客户端。
- en: fork(modulePath, [arguments], [options])
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`fork(modulePath, [arguments], [options])`'
- en: Just like `spawn`, `fork` starts a child process but is designed to run Node
    programs with the added benefit of having a communication built in. Rather than
    passing a system command to `fork` as its first argument, we pass the path to
    a Node program. As with `spawn`, command-line options can be sent as a second
    argument, accessible via `process.argv` in the forked child process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `spawn` 一样，`fork` 启动一个子进程，但设计用于运行 Node 程序，并具有内置通信的额外好处。与将系统命令作为 `fork` 的第一个参数传递不同，我们传递
    Node 程序的路径。与 `spawn` 一样，命令行选项可以作为第二个参数发送，在分叉的子进程中可通过 `process.argv` 访问。
- en: 'An optional object can be passed as its third argument, with the following
    parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递一个可选的对象作为其第三个参数，包含以下参数：
- en: '**cwd** (string): By default, this command will understand its current working
    directory to be the same as that of the Node process calling `fork`. Change that
    setting using this directive.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cwd** (字符串): 默认情况下，此命令将理解其当前工作目录与调用 `fork` 的 Node 进程相同。使用此指令更改该设置。'
- en: '**env** (object): This is used to pass environment variables to a child process.
    See `spawn`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**env** (对象): 这用于将环境变量传递给子进程。参见 `spawn`。'
- en: '**encoding** (string): This sets the encoding of the communication channel.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding** (字符串): 这设置了通信通道的编码。'
- en: '**execPath** (string): This is the executable used to create the child process.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**execPath** (字符串): 这是创建子进程时使用的可执行文件。'
- en: '**silent** (Boolean): By default, a child process for which `fork` has been
    used will have `stdio` associated with that of the parent process (`child.stdout`
    is identical to `parent.stdout`, for example). Setting this option to ''true''
    disables this behavior.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**silent** (布尔值): 默认情况下，使用 `fork` 创建的子进程将与父进程的 `stdio` 相关联（例如，`child.stdout`
    与 `parent.stdout` 相同）。将此选项设置为 ''true'' 将禁用此行为。'
- en: An important difference between `fork` and `spawn` is that the former's child
    process *does not automatically exit* when it is finished. Such a child process
    must explicitly exit when it is done, which is easily accomplished via `process.exit()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork` 和 `spawn` 之间的重要区别在于，前者在完成时其子进程**不会自动退出**。此类子进程在完成后必须显式退出，这可以通过 `process.exit()`
    轻易实现。'
- en: 'In the following example, we will create a child process that emits an incrementing
    number every tenth of a second, which its parent process then dumps to the system
    console. First, let''s look at the child program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个子进程，该子进程每十分之一秒发出一个递增的数字，然后其父进程将其输出到系统控制台。首先，让我们看看子程序：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, this will simply write a steadily increasing number. When forked a child
    process, a child process will inherit the `stdio` stream of its parent, so we
    only need to create the child process in order to get the output in a terminal
    running the parent process:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这只会简单地写入一个持续增加的数字。当分叉一个子进程时，子进程将继承其父进程的 `stdio` 流，因此我们只需要创建子进程，就可以在运行父进程的终端中获取输出：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The silent option can be demonstrated here. The following code turns off any
    output to the terminal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以演示 silent 选项。以下代码将关闭任何输出到终端：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating multiple, parallel processes is easy. Let''s multiply the number of
    children created:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个、并行的进程很容易。让我们增加创建的子进程数量：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It should be clear at this point that using `fork`, we are creating many parallel
    execution contexts spread across all machine cores.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应该很清楚，使用 `fork`，我们正在创建许多并行执行上下文，这些上下文分布在所有机器核心上。
- en: 'This is straightforward enough, but the built-in communication channel that
    `fork` provides makes communicating with child processes for which `fork` has
    been used even easier and cleaner. Consider the following two code snippets:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很直接了，但 `fork` 提供的内置通信通道使得与使用 `fork` 的子进程通信变得更加简单和清晰。考虑以下两个代码片段：
- en: '**Parent**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**父进程**：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Child**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**子进程**：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By executing the parent script, we will see the following in our console:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行父脚本，我们将在控制台看到以下内容：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: exec(command, [options], callback)
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exec(command, [options], callback)
- en: 'In cases where the complete buffered output of a child process is sufficient,
    with no need to manage data through events, `child_process` offers the `exec`
    method. The method takes three arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整缓冲输出足以满足需求，无需通过事件管理数据的情况下，`child_process` 提供了 `exec` 方法。该方法接受三个参数：
- en: '**command**: This is a command-line string. Unlike `spawn` and `fork`, which
    pass arguments to a command via an array, this first argument accepts a full command
    string, such as `ps aux | grep node`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**command**: 这是一个命令行字符串。与 `spawn` 和 `fork` 不同，它们通过数组将参数传递给命令，这个第一个参数接受一个完整的命令字符串，例如
    `ps aux | grep node`。'
- en: '**options**: This is optional.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options**: 这是可选的。'
- en: '**cwd**: This is a string. Set the working directory for the command process.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cwd**: 这是一个字符串。为命令进程设置工作目录。'
- en: '**env**: This is an object. It''s a map of key-value pairs that will be exposed
    to the child process.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**env**: 这是一个对象。它是一个键值对的映射，这些键值对将被暴露给子进程。'
- en: '**encoding**: This is a string. It is the encoding of the child process''s
    data stream. The default value is `''utf8''`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding**: 这是一个字符串。它是子进程数据流的编码。默认值是 `''utf8''`。'
- en: '**timeout**: This is a number. It is the number of milliseconds that we need
    to wait for the process to complete, at which point the child process will be
    sent the **killSignal** signal.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout**: 这是一个数字。这是我们等待进程完成的毫秒数，此时子进程将收到 **killSignal** 信号。'
- en: '**maxBuffer**: This is a number. It is the maximum number of bytes allowed
    on `stdout` or `stderr`. When this number is exceeded, the process is killed.
    The default value is 200 KB.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxBuffer**: 这是一个数字。它是允许在 `stdout` 或 `stderr` 上的最大字节数。当超过此数字时，进程将被终止。默认值是
    200 KB。'
- en: '**killSignal**: This is a string. The child process receives this signal after
    a **timeout**. The default value is SIGTERM.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**killSignal**: 这是一个字符串。子进程在 **timeout** 后接收此信号。默认值是 SIGTERM。'
- en: '**callback**: This receives three arguments: an `Error` object, if any; `stdout`
    (a `Buffer` containing the result); and `stderr` (a `Buffer` containing error
    data, if any). If the process was killed, `Error.signal` will contain the kill
    signal.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**callback**: 这接收三个参数：一个 `Error` 对象（如果有）；`stdout`（一个包含结果的 `Buffer`）；和 `stderr`（一个包含错误数据的
    `Buffer`，如果有）。如果进程被终止，`Error.signal` 将包含终止信号。'
- en: execFile
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: execFile
- en: Use this method when you want the functionality of `exec` but are targeting
    a Node file. Importantly, `execFile` does not spawn a new subshell, which makes
    it slightly less expensive to run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用 `exec` 的功能但针对 Node 文件时，请使用此方法。重要的是，`execFile` 不会启动新的子shell，这使得它运行起来稍微便宜一些。
- en: Communicating with your child process
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与子进程通信
- en: All instances of the `ChildProcess` object extend `EventEmitter`, exposing events
    which are useful to manage child data connections. Additionally, `ChildProcess`
    objects expose useful methods of interacting with child processes directly. Let's
    go through these now, beginning with attributes and methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `ChildProcess` 对象的实例都扩展了 `EventEmitter`，暴露了用于管理子数据连接的有用事件。此外，`ChildProcess`
    对象还暴露了与子进程直接交互的有用方法。现在让我们逐一介绍这些方法，从属性和方法开始。
- en: child.connected
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.connected
- en: When a child process is disconnected from its parent process via `child.disconnect()`,
    this flag will be set to false.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程通过 `child.disconnect()` 与父进程断开连接时，此标志将设置为 false。
- en: child.stdin
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.stdin
- en: This is a `Writable` stream corresponding to the child process's standard in.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对应于子进程标准输入的 `Writable` 流。
- en: child.stdout
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.stdout
- en: This is a `Readable` stream corresponding to the child process's standard out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对应于子进程标准输出的 `Readable` 流。
- en: child.stderr
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.stderr
- en: This is a `Readable` stream corresponding to the child process's standard error.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对应于子进程标准错误的 `Readable` 流。
- en: child.pid
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.pid
- en: This is an integer representing the **process ID** (**PID**) assigned to the
    child process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示分配给子进程的 **进程ID**（**PID**）的整数。
- en: child.kill([signal])
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.kill([signal])
- en: Try to terminate a child process, sending it an optional signal. If no signal
    is specified, the default is SIGTERM (for more about signals, see [http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7](http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7)).
    While the method name sounds terminal, it is not guaranteed to kill a process—it
    only sends a signal to a process. Dangerously, if `kill` is attempted on a process
    that has already exited, it is possible that another process, which has been newly
    assigned the PID of the dead process, will receive the signal, with indeterminable
    consequences. You should fire a `close` event, which will receive the signal used
    to close the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试终止一个子进程，发送一个可选的信号。如果没有指定信号，默认为 SIGTERM（有关信号的更多信息，请参阅 [http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7](http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7)）。虽然方法名听起来像是终端，但它并不能保证杀死进程——它只是向进程发送一个信号。危险的是，如果尝试对已经退出的进程执行
    `kill` 操作，可能另一个进程（它已经被分配了已死亡进程的PID）将接收到该信号，后果不可预测。你应该触发一个 `close` 事件，该事件将接收用于关闭进程的信号。
- en: child.disconnect()
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.disconnect()
- en: When `child.disconnect()` is triggered on a child process belonging to a process
    group that it does not lead, the IPC connection between the child and its parent
    will be severed, resulting in the child dying gracefully as it has no IPC channel
    to keep it alive. You can also call `process.disconnect()` from within the child
    process itself. Once a child process has disconnected, the `connected` flag on
    that child reference will be set to false.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当对不属于其领导的进程组的子进程触发 `child.disconnect()` 时，子进程与其父进程之间的IPC连接将被切断，导致子进程优雅地死亡，因为它没有IPC通道来维持其存活。你还可以在子进程内部调用
    `process.disconnect()`。一旦子进程断开连接，该子进程引用上的 `connected` 标志将被设置为 false。
- en: child.send(message, [sendHandle])
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: child.send(message, [sendHandle])
- en: 'As we saw in our discussion of `fork`, and when using the `ipc` option on `spawn`,
    child processes can be sent messages via this method. A TCP server or socket object
    can be passed along with the message as a second argument. In this way, a TCP
    server can spread requests across multiple child processes. For example, the following
    server distributes socket handling across a number of child processes equaling
    the total number of CPUs available. Each forked child is given a unique ID, which
    it reports when started. Whenever the TCP server receives a socket, that socket
    is passed as a handle to a random child process. That child process then sends
    a unique response, demonstrating that socket handling is being distributed. The
    following code snippets show this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `fork` 的讨论中看到的那样，当在 `spawn` 上使用 `ipc` 选项时，可以通过此方法向子进程发送消息。可以将TCP服务器或套接字对象作为消息的第二个参数传递。通过这种方式，TCP服务器可以将请求分散到多个子进程中。例如，以下服务器将套接字处理分散到与可用的CPU总数相等的多个子进程中。每个分叉的子进程都会被分配一个唯一的ID，它在启动时报告。每当TCP服务器接收到套接字时，该套接字就会作为句柄传递给一个随机的子进程。然后该子进程发送一个唯一的响应，表明套接字处理正在分散。以下代码片段展示了这一点：
- en: '**Parent**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**父进程**：'
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Child**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**子进程**：'
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start the parent server in a terminal window. In another window, run `telnet
    127.0.0.1 8080`. You should see something similar to the following, with a random
    child ID being displayed on each connection (assuming there exist multiple cores):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中启动父服务器。在另一个窗口中，运行 `telnet 127.0.0.1 8080`。你应该会看到类似以下的内容，每个连接上都会显示一个随机的子进程ID（假设存在多个核心）：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The cluster module
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群模块
- en: We saw how spreading work across multiple cores by spawning independent processes
    helps to vertically scale Node applications. The Node API has been further augmented
    with a `cluster` module that formalizes this pattern and extends it. Continuing
    with Node's core purpose of helping to make scalable network software easier to
    build, the particular goal of the `cluster` module is to facilitate the sharing
    of network sockets among many child workers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，通过创建独立进程来分散工作可以帮助垂直扩展Node应用程序。Node API已经通过 `cluster` 模块进一步扩展，该模块正式化了这种模式并扩展了它。继续Node的核心目标，即帮助使可扩展的网络软件更容易构建，`cluster`
    模块的具体目标是促进多个子工作进程之间网络套接字的共享。
- en: 'For example, the following code creates a cluster of worker processes, all
    sharing the same HTTP connection:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码创建了一个由工作进程组成的集群，所有进程共享相同的HTTP连接：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll dig into the details shortly. The important thing to note is how this
    program does different things depending on whether it is running as a master process
    or as a child process. On its first execution, it is the master, indicated by
    `cluster.isMaster`. When a master process calls `cluster.fork`, this same program
    is forked as a child process, in this case one child for each CPU. When this program
    is re-executed, in a forking context, `cluster.isWorker` will be `true`, and a
    new HTTP server *running on a shared port* is started. Multiple processes are
    sharing the load for a single server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会深入细节。需要注意的是，这个程序根据它是以主进程还是子进程运行而执行不同的操作。在其第一次执行时，它是主进程，由 `cluster.isMaster`
    指示。当主进程调用 `cluster.fork` 时，这个相同的程序会作为子进程被 fork，在这种情况下，每个 CPU 对应一个子进程。当这个程序在 fork
    的上下文中重新执行时，`cluster.isWorker` 将为 `true`，并且会启动一个新的在共享端口上运行的 HTTP 服务器。多个进程正在为单个服务器分担负载。
- en: Connect to this server with a browser. You will see something like **Hello from
    8**, the integer corresponding to the unique `cluster.worker.id` ID of the worker
    that is assigned the responsibility of handling your request. Balancing across
    all workers is handled automatically such that refreshing your browser a few times
    will result in different worker IDs being displayed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器连接到这个服务器。你会看到类似 **Hello from 8** 的内容，这是对应于分配处理你请求的工作者的唯一 `cluster.worker.id`
    ID 的整数。所有工作者的负载均衡是自动处理的，这样刷新浏览器几次就会显示不同的工作者 ID。
- en: 'The `cluster` API breaks down into two sections: the methods, attributes, and
    events available to the cluster master and those available to the child process.
    As workers in this context are defined using `fork`, the documentation for that
    method of `child_process` can be applied here as well.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster` API 分为两部分：集群主进程可用的方法、属性和事件，以及子进程可用的方法。由于在此上下文中工作者是通过 `fork` 定义的，因此可以在这里应用
    `child_process` 方法的文档。'
- en: cluster.isMaster
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.isMaster`'
- en: This is a Boolean value indicating whether the process is a master.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔值，指示进程是否是主进程。
- en: cluster.isWorker
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.isWorker`'
- en: This is a Boolean value indicating whether the process was forked from a master.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔值，指示进程是否是从主进程 fork 出来的。
- en: cluster.worker
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.worker`'
- en: This is a reference to the current worker object and is only available to a
    child process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前工作对象的引用，并且仅对子进程可用。
- en: cluster.workers
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.workers`'
- en: This is a hash containing references to all active worker objects, keyed by
    the worker ID. Use this to loop through all worker objects. This only exists within
    the master process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含所有活动工作对象引用的哈希，键为工作者 ID。使用它来遍历所有工作对象。这仅存在于主进程中。
- en: cluster.setupMaster([settings])
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.setupMaster([settings])`'
- en: 'This is a convenient way of passing a map of default arguments when a child
    is forked. If all child processes are going to use `fork` on the same file (as
    is often the case), you will save time by setting it here. The available defaults
    are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在子进程 fork 时传递默认参数映射的便捷方式。如果所有子进程都将使用 `fork` 在相同的文件上（这种情况很常见），你将在这里设置它来节省时间。可用的默认值如下：
- en: '**exec**: This is a string. The file path to the process file defaults to `__filename`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exec**：这是一个字符串。进程文件的文件路径默认为 `__filename`。'
- en: '**args**: This is an array. Strings are sent as arguments to the child process.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**args**：这是一个数组。字符串作为参数发送到子进程。'
- en: '**silent**: This is a Boolean value that determines whether or not to send
    output to the master''s `stdio`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**silent**：这是一个布尔值，用于确定是否将输出发送到主进程的 `stdio`。'
- en: cluster.fork([env])
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.fork([env])`'
- en: This creates a new worker process. Only the master process can call this method.
    To expose a map of key-value pairs to the child's process environment, send an
    object to `env`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个新的工作进程。只有主进程可以调用此方法。要向子进程的环境暴露键值对映射，请向 `env` 发送一个对象。
- en: cluster.disconnect([callback])
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster.disconnect([callback])`'
- en: This is used to terminate all workers in a cluster. Once all the workers have
    died gracefully, the cluster process will itself terminate if it has no further
    events to wait on. To be notified when all child processes have expired, pass
    `callback`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于终止集群中的所有工作者。一旦所有工作者都优雅地死亡，如果没有其他事件等待，集群进程将自行终止。要通知所有子进程已过期，请传递 `callback`。
- en: cluster events
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cluster` 事件'
- en: 'This cluster object emits several events:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集群对象会发出几个事件：
- en: '**fork**: This is fired when the master tries to use `fork` on a new child.
    This is not the same as `online`. This receives a worker object.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fork**：当主进程尝试在新的子进程中使用 `fork` 时会触发此事件。这不同于 `online`。它接收一个工作对象。'
- en: '**online**: This is fired when the master receives notification that a child
    is fully bound. This differs from the `fork` event. This receives a worker object.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线**: 当主进程收到通知，子进程已完全绑定时，会触发此事件。这不同于 `fork` 事件。它接收一个 worker 对象。'
- en: '**listening**: When the worker performs an action that requires a `listen()`
    call (such as starting an HTTP server), this event will be fired in the master.
    The event emits two arguments: a worker object and the address object containing
    the `address`, `port`, and `addressType` of the connection.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听**: 当 worker 执行需要 `listen()` 调用的操作（如启动 HTTP 服务器）时，主进程将触发此事件。事件发出两个参数：一个
    worker 对象和包含 `address`、`port` 和 `addressType` 的连接地址对象。'
- en: '**disconnect**: This is called whenever a child disconnects, which can happen
    either through process exit events or after calling `child.kill()`. This will
    fire prior to the `exit` event—they are not the same. This receives a worker object.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断开**: 当子进程断开连接时调用，这可以通过进程退出事件或调用 `child.kill()` 后发生。它将在 `exit` 事件之前触发——它们不是同一个事件。它接收一个
    worker 对象。'
- en: '**exit**: Whenever a child dies, this event is emitted. It receives three arguments:
    a worker object, the exit code number, and the signal string, such as SIGHUP,
    that caused the process to be killed.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出**: 当子进程死亡时，会触发此事件。它接收三个参数：一个 worker 对象、退出代码数字以及导致进程被杀死的信号字符串，例如 SIGHUP。'
- en: '**setup**: This is called after `cluster.setupMaster` has executed.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**: 在 `cluster.setupMaster` 执行后调用。'
- en: worker.id
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.id
- en: This is the unique ID assigned to a worker, which also represents the worker's
    key in the `cluster.workers` index.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分配给 worker 的唯一 ID，它也代表了 worker 在 `cluster.workers` 索引中的键。
- en: worker.process
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.process
- en: This is a `ChildProcess` object referencing a worker.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个引用 worker 的 `ChildProcess` 对象。
- en: worker.suicide
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.suicide
- en: These workers, that have recently had `kill` or `disconnect` called on them,
    will have their `suicide` attribute set to true.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最近被调用过 `kill` 或 `disconnect` 的 worker，它们的 `suicide` 属性将被设置为 true。
- en: worker.send(message, [sendHandle])
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.send(message, [sendHandle])
- en: See `child_process.fork()`in the *Scaling vertically across multiple cores*
    section where I describe the `#fork` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *在多个核心上垂直扩展* 部分的 `child_process.fork()`，我在那里描述了 `#fork` 方法。
- en: worker.kill([signal])
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.kill([signal])
- en: This kills a worker. The master can check this worker's `suicide` property in
    order to determine whether the death was intentional or accidental. The default
    signal sent is SIGTERM.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这会杀死一个 worker。主进程可以检查此 worker 的 `suicide` 属性，以确定死亡是故意的还是意外的。默认发送的信号是 SIGTERM。
- en: worker.disconnect()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: worker.disconnect()
- en: This instructs a worker to disconnect. Importantly, existing connections to
    the worker are not immediately terminated (as with `kill`) but are allowed to
    exit normally prior to the worker fully disconnecting. Because existing connections
    can stay in existence for a very long time, it is a good habit to regularly check
    whether the worker has actually disconnected, perhaps using timeouts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 worker 断开连接。重要的是，现有的 worker 连接不会立即终止（如 `kill` 所做的那样），而是在 worker 完全断开连接之前允许它们正常退出。由于现有的连接可以存在很长时间，因此定期检查
    worker 是否实际上已经断开连接是一个好习惯，可能使用超时来实现。
- en: 'Workers also emit events:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Workers 也会发出事件：
- en: '**message**: See `child_process.fork` in the *Scaling vertically across multiple
    cores* section where I describe the `#fork` method'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**: 查看 *在多个核心上垂直扩展* 部分的 `child_process.fork()`，我在那里描述了 `#fork` 方法。'
- en: '**online**: This is identical to `cluster.online` except that the check is
    against only the specified worker'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线**: 这与 `cluster.online` 相同，但检查仅针对指定的 worker'
- en: '**listening**: This is identical to `cluster.listening` except that the check
    is against only the specified worker'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听**: 这与 `cluster.listening` 相同，但检查仅针对指定的 worker'
- en: '**disconnect**: This is identical to `cluster.disconnect` except that the check
    is against only the specified worker'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断开**: 这与 `cluster.disconnect` 相同，但检查仅针对指定的 worker'
- en: '**exit**: See the `exit` event for `child_process`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出**: 查看 `child_process` 的 `exit` 事件'
- en: '**setup**: This is called after `cluster.setupMaster` has executed'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**: 在 `cluster.setupMaster` 执行后调用'
- en: Now that we have a good understanding of how to accomplish vertical scaling
    with Node, let's take a look at some ways to handle horizontal scaling
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了如何使用 Node 实现垂直扩展，让我们来看看一些处理水平扩展的方法
- en: Scaling horizontally across different machines
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同机器上水平扩展
- en: Because Node is so efficient, most websites or applications can accommodate
    all of their scaling needs in the vertical dimension. As we learned from Eran
    Hammer's experiences at Walmart, Node can handle enormous levels of traffic using
    only a few CPUs and an unexceptional volume of memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node非常高效，大多数网站或应用程序都可以在垂直维度上满足所有扩展需求。正如我们从Eran Hammer在沃尔玛的经历中学到的那样，Node只需使用少量CPU和非常普通的内存量就能处理巨大的流量。
- en: Nevertheless, horizontal scaling can still be the right choice, even if only
    for architectural reasons. Having one point of failure, no matter how robust,
    still entails some risk. The *parking lot problem* is another consideration that
    Walmart likely faces—during shopping holidays, you will need many thousands of
    parking spots, but during the rest of the year this investment in empty space
    is hard to justify. In terms of servers, the ability to dynamically scale both
    up and down argues against building fixed vertical silos. Adding hardware to a
    running server is also a more complicated process than spinning up and seamlessly
    linking another virtual machine to your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，水平扩展仍然可能是正确的选择，即使只是为了架构原因。无论多么健壮，只有一个故障点仍然存在一些风险。"停车场问题"也是沃尔玛可能面临的一个考虑因素——在购物假日，你需要成千上万的停车位，但在一年中的其他时间，这种对空空间的投资很难证明其合理性。从服务器的角度来看，能够动态地向上和向下扩展的能力，反对建立固定的垂直孤岛。向运行中的服务器添加硬件也是一个比启动和无缝连接另一个虚拟机到应用程序更复杂的过程。
- en: In this section, we'll look at a few techniques for horizontal scaling, considering
    load balancing using native Node techniques, third-party solutions, and some ideas
    for cross-server communication.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些水平扩展的技术，考虑到使用原生Node技术、第三方解决方案以及一些跨服务器通信的想法。
- en: Using Nginx
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nginx
- en: '**Nginx** (pronounced **Engine X**) remains a popular choice for those whose
    architecture benefits from hiding Node servers behind a proxy. Nginx is a very
    popular high-performance web server that is often used as a proxy server. Given
    its design, Nginx is a popular choice with Node developers. According to [http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy](http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nginx**（发音为**Engine X**）对于那些从隐藏Node服务器背后的代理中受益的架构来说，仍然是一个流行的选择。Nginx是一个非常流行的性能高的Web服务器，通常用作代理服务器。根据[http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy](http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy)：'
- en: '*"Nginx is able to serve more requests per second with less resources because
    of its architecture. It consists of a master process, which delegates work to
    one or more worker processes. Each worker handles multiple requests in an event-driven
    or asynchronous manner using special functionality from the Linux kernel (epoll/select/poll).
    This allows Nginx to handle a large number of concurrent requests quickly with
    very little overhead."*'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Nginx由于其架构，能够以更少的资源每秒处理更多的请求。它由一个主进程组成，该进程将工作委托给一个或多个工作进程。每个工作进程以事件驱动或异步的方式处理多个请求，使用Linux内核的特殊功能（epoll/select/poll）。这使得Nginx能够快速处理大量的并发请求，同时开销非常小。"*'
- en: 'Its similarity in design to Node is striking: event delegation across processes
    and an evented, asynchronous environment coordinated by the OS delivering high
    concurrency.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它的设计与Node的相似性非常明显：跨进程的事件委托以及由操作系统协调的事件驱动、异步环境，提供高并发性。
- en: A **proxy** is someone or something acting on behalf of another.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**是指代表他人行事的人或事物。'
- en: 'A *forward* proxy normally works on behalf of clients in a private network,
    brokering requests to an outside network, such as retrieving data from the Internet.
    Early *web providers*, such as AOL, functioned in this way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**正向代理**通常在私有网络中代表客户端工作，作为外部网络（如从互联网检索数据）的请求经纪人。早期的**网络提供商**，如AOL，就是这样运作的：'
- en: '![Using Nginx](img/1403OS_03_01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用Nginx](img/1403OS_03_01.jpg)'
- en: Network administrators often use forward proxies when restrictions on access
    to the outside world (that is, the Internet) are needed. If malware is downloaded
    from a bad website via an e-mail attachment, the administrator might block access
    to that location. Restrictions on access to social networking sites might be imposed
    on an office network. Some countries even restrict access to the general Internet
    in this way.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员在需要限制对外部世界（即互联网）的访问时通常会使用正向代理。如果通过电子邮件附件从不良网站下载恶意软件，管理员可能会阻止对该位置的访问。办公室网络可能会对社交网站实施访问限制。一些国家甚至以这种方式限制对互联网的访问。
- en: 'A *reverse* proxy, not surprisingly, works in the opposite manner, accepting
    requests from a public network and servicing those requests within a private network
    that the client might not have much visibility into. Direct access to servers
    by clients is first delegated to a reverse proxy. This can be shown with the help
    of the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理，不出所料，以相反的方式工作，接受来自公共网络的请求，并在客户端可能不太了解的私有网络中处理这些请求。客户端首先将直接访问服务器的权限委托给反向代理。以下图可以帮助说明这一点：
- en: '![Using Nginx](img/1403OS_03_02.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用Nginx](img/1403OS_03_02.jpg)'
- en: This is the type of proxy we can use to balance requests from clients across
    many Node servers. Client X does not communicate with any given server directly.
    A broker Y is the first point of contact that is able to direct X to a server
    under less load, is located closer to X, or is, in some other way, the best server
    for X to access at the time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用来平衡来自多个Node服务器的客户端请求的类型。客户端X不直接与任何给定服务器通信。经纪人Y是第一个接触点，能够将X引导到负载较轻的服务器，位于X附近，或者以其他方式，是X在此时访问的最佳服务器。
- en: Let's take a look at how Nginx can be used as a proxy, in particular, as a load
    balancer, by deploying such a system on the cloud hosting service **Digital Cloud**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Nginx如何被用作代理，特别是作为一个负载均衡器，通过在云托管服务**Digital Cloud**上部署这样的系统来实现。
- en: Deploying an Nginx load balancer on DigitalOcean
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在DigitalOcean上部署Nginx负载均衡器
- en: DigitalOcean is a cloud hosting provider that is inexpensive and easy to set
    up. We will build an Nginx load balancer on this service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: DigitalOcean是一家价格低廉且易于设置的云托管提供商。我们将在该服务上构建一个Nginx负载均衡器。
- en: To sign up, visit [http://www.digitalocean.com](http://www.digitalocean.com).
    The basic package (at the time of writing this) incurs a $5 fee, but promotion
    codes are regularly made available—a simple web search should result in a usable
    code. Create and verify an account to get started.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册，请访问[http://www.digitalocean.com](http://www.digitalocean.com)。基本套餐（在撰写本文时）收取5美元的费用，但通常会提供促销代码——简单的网络搜索应该会找到可用的代码。创建并验证账户以开始使用。
- en: DigitalOcean packages are described as droplets with certain characteristics—the
    amount of storage space, transfer limits, and so on. A basic package is sufficient
    for our needs. Also, you will indicate a hosting region and the OS to install
    in your droplet (in this example, we'll use the latest version of Ubuntu). Create
    a droplet and check your e-mail for login instructions. You're done!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: DigitalOcean的套餐被描述为具有某些特性的水滴——存储空间的大小、传输限制等。基本套餐足以满足我们的需求。此外，你将在你的水滴中指定托管区域和要安装的操作系统（在这个例子中，我们将使用Ubuntu的最新版本）。创建一个水滴，并检查你的电子邮件以获取登录说明。你已经完成了！
- en: You will receive full login information for your instance. You can now open
    a terminal and SSH into your box using those login credentials.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到实例的完整登录信息。你现在可以打开一个终端，使用这些登录凭证SSH到你的机器上。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On your initial login, you might want to update your packages. For Ubuntu, you
    would run `apt-get update` and `apt-get upgrade`. Other package managers have
    similar commands (such as `yum update` for RHEL/CentOS).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的首次登录时，你可能想更新你的软件包。对于Ubuntu，你会运行`apt-get update`和`apt-get upgrade`。其他包管理器有类似的命令（例如，RHEL/CentOS的`yum
    update`）。
- en: Before we begin to install, let's change our root password and create a nonroot
    user (it is unsafe to expose the root to external logins and software installs).
    To change your root password, type `passwd` and follow the instructions in your
    terminal. To create a new user, enter `adduser <new user name>` (for example,
    `adduser john`). Follow the instructions mentioned in the upcoming paragraphs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始安装之前，让我们更改我们的root密码并创建一个非root用户（将root暴露给外部登录和软件安装是不安全的）。要更改root密码，请输入`passwd`并遵循终端中的说明。要创建新用户，输入`adduser
    <新用户名>`（例如，`adduser john`）。遵循下文提到的说明。
- en: 'One more step: we want to give some administrative privileges to our new user
    as we''ll install software as that user. In Unix parlance, you want to give `sudo`
    access to this new user. Instructions on how to do this are easy to find for whichever
    OS you''ve chosen. Essentially, you will want to change the `/etc/sudoers` file.
    Remember to do this using a command such as `visudo`—do not edit the `sudoers`
    file by hand! You may also want to restrict root logins and do other SSH access
    management at this point.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再多一步：由于我们将以该新用户身份安装软件，因此我们希望给这个新用户一些管理权限。在Unix术语中，你希望给这个新用户`sudo`访问权限。如何操作的说明很容易找到，无论你选择了哪个操作系统。本质上，你将想要更改`/etc/sudoers`文件。请记住使用`visudo`之类的命令来执行此操作——不要手动编辑`sudoers`文件！此时，你可能还想限制root登录并执行其他SSH访问管理。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After successfully executing `sudo -i` in your terminal, you will be able to
    enter commands without prefixing each one with `sudo`. The following examples
    assume that you've done this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中成功执行`sudo -i`后，你将能够输入命令而无需在每个命令前加上`sudo`前缀。以下示例假设你已经这样做过了。
- en: 'We''ll now create an Nginx load balancer frontend for two Node servers. This
    means that we will create three droplets—one for the balancer and two added droplets
    as Node servers. In the end, we will end up with an architecture that looks something
    like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为两个Node服务器创建一个Nginx负载均衡器前端。这意味着我们将创建三个Droplet——一个用于均衡器，两个额外的Droplet作为Node服务器。最终，我们将得到一个类似以下架构：
- en: '![Deploying an Nginx load balancer on DigitalOcean](img/1403OS_03_05.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![在DigitalOcean上部署Nginx负载均衡器](img/1403OS_03_05.jpg)'
- en: Installing and configuring Nginx
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和配置Nginx
- en: 'Let''s install Nginx and Node/npm. If you''re still logged in as root, log
    out and reauthenticate as the new user you''ve just created. To install Nginx
    (on Ubuntu), simply type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Nginx和Node/npm。如果你仍然以root身份登录，请注销并重新以你刚刚创建的新用户身份登录。要在Ubuntu上安装Nginx，只需输入：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Most other Unix package managers will have Nginx installers. To start Nginx,
    use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他Unix包管理器都会有Nginx安装程序。要启动Nginx，请使用：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Full documentation for Nginx can be found at [http://wiki.nginx.org/Configuration](http://wiki.nginx.org/Configuration).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx的完整文档可以在[http://wiki.nginx.org/Configuration](http://wiki.nginx.org/Configuration)找到。
- en: 'You should now be able to point your browser to the IP you were assigned (check
    your inbox if you''ve forgotten) and see something like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够将你的浏览器指向分配给你的IP地址（如果你忘记了，请检查你的收件箱）并看到如下内容：
- en: '![Installing and configuring Nginx](img/1403OS_03_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![安装和配置Nginx](img/1403OS_03_04.jpg)'
- en: Now, let's set up the two servers that Nginx will balance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置Nginx将进行负载均衡的两个服务器。
- en: 'Create an additional two droplets in DigitalOcean. You must *not* install Nginx
    on these servers. Configure permissions on these servers as we did earlier. Now,
    install Node in both droplets. An easy way to manage your Node installation is
    using Tim Caswell''s **Node Version Manager** (**NVM**). NVM is essentially a
    bash script that provides a set of command-line tools facilitating Node version
    management and allowing you to easily switch between versions. To install it,
    use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在DigitalOcean上创建另外两个Droplet。你*必须*不要在这些服务器上安装Nginx。按照我们之前的方式配置这些服务器的权限。现在，在这两个Droplet上安装Node。使用Tim
    Caswell的**Node版本管理器**（**NVM**）管理你的Node安装是一个简单的方法。NVM本质上是一个bash脚本，提供了一套命令行工具，便于Node版本管理，并允许你轻松地在版本之间切换。要安装它，请使用以下命令：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, install your preferred Node version (here we ask for the latest release
    of the 0.12 version):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，安装你喜欢的Node版本（这里我们要求0.12版本的最新发布版）：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You might want to add a command to your `.bashrc` or `.profile` file to ensure
    that a certain node version is used each time you start a shell:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在`.bashrc`或`.profile`文件中添加一个命令，以确保每次启动shell时都使用特定的node版本：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To test our system, we need to set up Node servers on both of these machines.
    Create the following program file on each server, changing ''**'' to something
    unique on each (such as *one* and *two*):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的系统，我们需要在这两台机器上设置Node服务器。在每个服务器上创建以下程序文件，将****替换为每个服务器上独特的值（例如*one*和*two*）：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Start this file on each server (`node serverfile.js`). Each server will now
    answer on port `8080`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个服务器上启动此文件（`node serverfile.js`）。现在每个服务器都将通过端口`8080`进行响应。
- en: You should now be able to reach this server by pointing a browser to each droplet's
    IP:8080\. Once you have two servers responding with distinct messages, we can
    set up the Nginx load balancer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够通过将浏览器指向每个Droplet的IP地址8080来访问这个服务器。一旦你有两个服务器以不同的消息响应，我们就可以设置Nginx负载均衡器了。
- en: 'Load balancing across servers is straightforward with Nginx. You need to simply
    indicate in the Nginx configuration script which **upstream** servers should be
    balanced. The two Node servers we''ve just created are the upstream servers. The
    following diagram describes how Nginx evenly distributes requests across upstream
    servers:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nginx 在服务器之间进行负载均衡很简单。你只需要在 Nginx 配置脚本中指定哪些**upstream**服务器应该被平衡。我们刚刚创建的两个
    Node 服务器是上游服务器。以下图表描述了 Nginx 如何均匀地将请求分布在上游服务器之间：
- en: '![Installing and configuring Nginx](img/1403OS_03_03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![安装和配置 Nginx](img/1403OS_03_03.jpg)'
- en: Each request will be handled first by Nginx, which will check its *upstream*
    configuration and, based on how it is configured, will (reverse) proxy requests
    to upstream servers that will actually handle the request.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求首先由 Nginx 处理，Nginx 将检查其**upstream**配置，并根据配置情况将请求（反向）代理到实际处理请求的上游服务器。
- en: You will find the default Nginx server configuration file on your balancer droplet
    at `/etc/nginx/sites-available/default`. In production, you'll most likely want
    to create a custom directory and configuration file, but for our purposes, we'll
    simply modify the default configuration file (you might want to make a backup
    before you start modifying it).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的负载均衡 droplet 的`/etc/nginx/sites-available/default`找到默认的 Nginx 服务器配置文件。在生产环境中，你很可能想创建一个自定义目录和配置文件，但就我们的目的而言，我们将简单地修改默认配置文件（在开始修改之前，你可能想备份一下）。
- en: 'At the top of the Nginx configuration file, we want to define *upstream* servers
    that will be candidates for redirection. This is simply a map with the arbitrary
    key `lb-servers` to be referenced in the server definition that follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nginx 配置文件的最顶部，我们希望定义**upstream**服务器，这些服务器将成为重定向的候选者。这只是一个简单的映射，使用任意键`lb-servers`，在接下来的服务器定义中将被引用：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we''ve established the candidate map, we need to configure Nginx such
    that it forwards requests in a balanced way to each of the members of `lb-servers`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了候选映射，我们需要配置 Nginx，使其以平衡的方式将请求转发到`lb-servers`的每个成员：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The key line is this one:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关键行是这一行：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note how the name `lb-servers` matches the name of our upstream definition.
    This should make what is happening clear: an Nginx server listening on port `80`
    will pass the request on to a server definition contained in `lb-servers`. If
    the upstream definition has only one server in it, that server gets all the traffic.
    If several servers are defined, Nginx attempts to distribute traffic evenly among
    them.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`lb-servers`的名称与我们的上游定义名称相匹配。这应该使发生的事情变得清晰：监听端口`80`的 Nginx 服务器将请求传递给包含在`lb-servers`中的服务器定义。如果上游定义中只有一个服务器，那么该服务器将获得所有流量。如果定义了多个服务器，Nginx
    将尝试在它们之间均匀分配流量。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to balance load across several *local servers* using the
    same technique. One would simply run different Node servers on different ports,
    such as `server 127.0.0.1:8001; server 127.0.0.1:8002; ...`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，也可以使用相同的技巧在多个**本地服务器**之间平衡负载。只需在不同的端口上运行不同的 Node 服务器，例如`server 127.0.0.1:8001;
    server 127.0.0.1:8002; ...`。
- en: 'Go ahead and change the Nginx configuration (consult the `nginx.config` file
    in the code bundle for this book if you get stuck). Once you''ve changed it, restart
    Nginx with the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在去修改 Nginx 配置（如果你遇到困难，可以参考这本书的代码包中的`nginx.config`文件）。一旦修改完成，使用以下命令重启 Nginx：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, you can use this command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Assuming that the other two droplets running Node servers are active, you should
    now be able to point your browser to your Nginx-enabled droplet and see messages
    from those servers!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设运行 Node 服务器的其他两个 droplets 正在运行，你现在应该能够将你的浏览器指向你的 Nginx 启用的 droplet，并看到那些服务器的消息！
- en: Because we will likely want more precise control over how traffic is distributed
    across our upstream servers, there are further directives that can be applied
    to upstream server definitions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能希望更精确地控制流量在上游服务器之间的分布，因此可以应用进一步的上游服务器定义指令。
- en: 'Nginx balances load using a weighted round-robin algorithm. In order to control
    the relative weighting of traffic distribution, we use the **weight** directive:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 使用加权轮询算法来平衡负载。为了控制流量分布的相对权重，我们使用**weight**指令：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This definition tells Nginx to distribute twice as much load to the second server
    as to the first. Servers with more memory or CPUs might be favored, for example.
    Another way to use this system is to create an A/B testing scenario, where one
    server containing a proposed new design receives a small fraction of the total
    traffic such that metrics on the testing server (sales, downloads, engagement
    length, and so on) can be compared against the wider average.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义告诉Nginx将两倍于第一台服务器的负载分配给第二台服务器。例如，内存或CPU更多的服务器可能会被优先考虑。另一种使用此系统的方法是创建一个A/B测试场景，其中一个包含提议的新设计的服务器接收一小部分总流量，这样就可以将测试服务器的指标（如销售额、下载量、参与时长等）与更广泛的平均值进行比较。
- en: 'Three other useful directives are available, which work together to manage
    connection failures:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个其他有用的指令可用，它们共同管理连接失败：
- en: '**max_fails**: This is the number of times communication with a server fails
    prior to marking that server as inoperative. The period of time within which these
    failures must occur is defined by **fail_timeout**.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max_fails**：这是在将服务器标记为不可用之前，与服务器通信失败的次数。这些失败必须在**fail_timeout**定义的时期间发生。'
- en: '**fail_timeout**: This is the time slice during which **max_fails** must occur,
    indicating that a server is inoperative. This number also indicates the amount
    of time after a server is marked inoperative that Nginx will again attempt to
    reach the flagged server. Here''s an example:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fail_timeout**：这是**max_fails**必须发生的时长，表示服务器不可用。这个数字还表示在服务器被标记为不可用后，Nginx将再次尝试连接该标记服务器的时长。以下是一个示例：'
- en: '[PRE31]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**backup**: A server marked with this directive will only be called when and
    if *all* of the other listed servers are unavailable.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backup**：带有此指令的服务器只有在所有其他列出的服务器都不可用时才会被调用。'
- en: 'Additionally, there are some directives for the upstream definition that add
    some control over how clients are directed to upstream servers:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些针对上游定义的指令，可以添加一些控制客户端如何被导向上游服务器的控制：
- en: '**least_conn**: This passes a request to the server with the least connections.
    This provides a slightly smarter balancing, taking into consideration server load
    as well as weighting.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**least_conn**：将请求传递给连接数最少的服务器。这提供了一种稍微智能一点的平衡，考虑了服务器负载以及权重。'
- en: '**ip_hash**: The idea here is to create a hash of each connecting IP and to
    ensure that requests from a given client are always passed to the same server.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ip_hash**：这里的想法是为每个连接的IP创建一个哈希值，并确保来自特定客户端的请求始终被传递到同一服务器。'
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another commonly used tool for balancing Node servers is the dedicated load
    balancer **HAProxy**, which is available at [http://haproxy.1wt.eu/](http://haproxy.1wt.eu/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用于平衡Node服务器的工具是专门的负载均衡器**HAProxy**，可在[http://haproxy.1wt.eu/](http://haproxy.1wt.eu/)找到。
- en: Load balancing with Node
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node进行负载均衡
- en: 'For many years, it was recommended that a web server (such as Nginx) be placed
    in front of Node servers. The claim was that mature web servers handle static
    file transfers more efficiently. While this may have been true for earlier Node
    versions (which did suffer from the bugs that new technologies face), it is no
    longer necessarily true in terms of pure speed. Some recent benchmarks bear this
    out: [http://centminmod.com/siegebenchmarks/2013/020313/index.html](http://centminmod.com/siegebenchmarks/2013/020313/index.html).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，建议在Node服务器前放置一个Web服务器（如Nginx）。声称成熟的Web服务器在处理静态文件传输方面更有效率。虽然这可能适用于早期的Node版本（它们确实遭受了新技术面临的错误），但从纯速度的角度来看，这不再一定是正确的。一些最近的基准测试证实了这一点：[http://centminmod.com/siegebenchmarks/2013/020313/index.html](http://centminmod.com/siegebenchmarks/2013/020313/index.html)。
- en: File serving speeds are, of course, not the only reason you might use a proxy
    such as Nginx. It is often true that network topology characteristics make a reverse
    proxy the better choice, especially when the centralization of common services,
    such as compression, makes sense. The point is simply that Node should not be
    excluded solely due to outdated biases about its ability to efficiently serve
    files. Let's look at one example of a purely Node-based proxying and balancing
    solution, `node-http-proxy`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，文件传输速度不是使用像Nginx这样的代理的唯一原因。通常，网络拓扑特性使得反向代理成为更好的选择，尤其是在集中化常见服务（如压缩）有意义时。关键是Node不应该仅仅因为过时的偏见而排除在外，这些偏见认为它无法有效地提供文件服务。让我们看看一个纯Node基础的代理和平衡解决方案的例子，`node-http-proxy`。
- en: Using node-http-proxy
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用node-http-proxy
- en: Node is designed to facilitate the creation of network software, so it comes
    as no surprise that several proxying modules have been developed. The team at
    NodeJitsu has released the proxy they use in production—`http-proxy`. Let's take
    a look at how we would use it to route requests to different Node servers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Node被设计用来促进网络软件的创建，因此开发出几个代理模块并不令人惊讶。NodeJitsu团队发布了他们在生产中使用的代理——`http-proxy`。让我们看看我们如何使用它将请求路由到不同的Node服务器。
- en: 'Unlike with Nginx, the entirety of our routing stack will exist in Node. Listening
    on port `80`, one Node server will run our proxy. Three scenarios will be covered:
    using a single box to run multiple Node servers on separate ports on the same
    machine; using one box as a pure router proxying to external URLs; and creating
    a basic round-robin load balancer.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与Nginx不同，我们的整个路由堆栈将存在于Node中。监听端口`80`，一个Node服务器将运行我们的代理。我们将涵盖三种场景：在一个机器上使用单个盒子运行多个Node服务器，这些服务器在不同的端口上运行；使用一个盒子作为纯路由代理到外部URL；以及创建一个基本的轮询负载均衡器。
- en: 'As an initial example, let''s look at how to use this module to redirect requests:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始示例，让我们看看如何使用此模块来重定向请求：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By starting this server on port `80` of our local machine, we are able to redirect
    the user to another URL.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的本地机器的端口`80`上启动此服务器，我们能够将用户重定向到另一个URL。
- en: 'To run several distinct Node servers, each responding to a different URL, on
    a single machine, you simply have to define a router:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单个机器上运行多个不同的Node服务器，每个服务器响应不同的URL，您只需定义一个路由器：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each of your distinct websites, you can now point your DNS name servers
    (via ANAME or CNAME) to the same endpoint (wherever this Node program is running),
    and they will resolve to different Node servers. This is handy when you want to
    run several websites but don''t want to create a new physical server for each
    one. Another strategy is to handle different paths within the same website on
    different Node servers:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您每个不同的网站，您现在可以将您的DNS名称服务器（通过ANAME或CNAME）指向相同的端点（无论此Node程序在哪里运行），并且它们将解析到不同的Node服务器。当您想运行多个网站但不想为每个网站创建新的物理服务器时，这很有用。另一种策略是在不同的Node服务器上处理同一网站内的不同路径：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows specialized functionality in your application to be handled by uniquely
    configured servers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您的应用程序中的专用功能由独特配置的服务器处理。
- en: 'Setting up a load balancer is also straightforward. As with Nginx''s `upstream`
    directive, we simply list the servers to be balanced and cycle through them:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 设置负载均衡器也很简单。与Nginx的`upstream`指令一样，我们只需列出要平衡的服务器并循环通过它们：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unlike with Nginx, we are responsible for doing the actual balancing. In this
    example, we treat servers equally, cycling through them in order. After the selected
    server is proxied, it is returned to the *rear* of the list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与Nginx不同，我们负责实际进行负载均衡。在这个例子中，我们平等地对待服务器，按顺序循环。在选定的服务器被代理后，它将被返回到列表的*末尾*。
- en: It should be clear that this example could be easily extended to accommodate
    other directives, such as Nginx's `weight`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，这个例子可以很容易地扩展以适应其他指令，例如Nginx的`weight`。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another good option for proxying Node is James Halliday's `bouncy` module available
    at [https://github.com/substack/bouncy](https://github.com/substack/bouncy).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 代理Node的另一个好选择是James Halliday的`bouncy`模块，可在[https://github.com/substack/bouncy](https://github.com/substack/bouncy)找到。
- en: Using message queues
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息队列
- en: One of the best ways to ensure that distributed servers maintain a dependable
    communication channel is to bundle the complexity of remote procedure calls into
    a messaging queue. When one server wishes to send a message to another server,
    the message can simply be placed on this queue—like a "to-do" list for your application—with
    the queue service doing the work of ensuring that messages get delivered as well
    as delivering any important replies back to the original sender.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保分布式服务器保持可靠的通信通道的最佳方法之一是将远程过程调用的复杂性打包到消息队列中。当一个服务器希望向另一个服务器发送消息时，消息可以简单地放置在这个队列上——就像您应用程序的“待办事项”列表——而队列服务则负责确保消息得到传递，并将任何重要的回复发送回原始发送者。
- en: 'There are a few enterprise-grade message queues available, many of which deploy
    the **Advanced Message Queuing Protocol** (**AMQP**). We will focus on a very
    stable and well-known implementation: RabbitMQ.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个企业级消息队列可供选择，其中许多部署了**高级消息队列协议**（**AMQP**）。我们将关注一个非常稳定且广为人知的实现：RabbitMQ。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To install RabbitMQ in your environment, follow the instructions found at [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).
    Note that you will also need to install Erlang (the instructions for which can
    be found at the same link).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的环境中安装 RabbitMQ，请遵循[http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html)中找到的说明。请注意，你还需要安装
    Erlang（其说明可以在同一链接中找到）。
- en: 'After installing it, you can start the RabbitMQ server with this command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你可以使用以下命令启动 RabbitMQ 服务器：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To interact with RabbitMQ using Node, we will use Theo Schlossnagle''s `node-amqp`
    module:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Node 与 RabbitMQ 交互，我们将使用 Theo Schlossnagle 的 `node-amqp` 模块：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To use a message queue, one must first create a consumer bound to RabbitMQ
    that will listen for messages published to the queue. The most basic consumer
    will listen for all messages:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用消息队列，必须首先创建一个绑定到 RabbitMQ 的消费者，该消费者将监听发布到队列的消息。最基本的消费者将监听所有消息：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are now listening for messages from the RabbitMQ server bound to port `5672`.
    It should be obvious that the *localhost* can be replaced with a proper server
    address and bound to any number of distributed servers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在监听绑定到端口 `5672` 的 RabbitMQ 服务器的消息。很明显，*localhost* 可以替换为适当的服务器地址，并绑定到任意数量的分布式服务器。
- en: Once this consumer establishes a connection, it will establish the name of the
    queue it will listen to and should `bind` to an **exchange**. In this example,
    we create a topic `exchange` (the default), giving it a unique name. We also indicate
    that we would like to listen for *all* messages via `#`. All that is left to do
    is subscribe to the queue, receiving a message object. We will learn more about
    the message object as we progress. For now, note the important `data` property
    containing the sent messages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个消费者建立了连接，它将建立它将监听并应绑定到的队列的名称。在这个例子中，我们创建了一个主题 `exchange`（默认），给它一个唯一的名称。我们还表明我们希望通过
    `#` 监听*所有*消息。剩下要做的就是订阅队列，接收消息对象。随着我们的进展，我们将了解更多关于消息对象的内容。现在，请注意重要的 `data` 属性，它包含发送的消息。
- en: 'Now that we have established a consumer, let''s publish a message to the exchange.
    If all goes well, we will see the sent message appear in our console:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个消费者，让我们向交换发布一条消息。如果一切顺利，我们将看到发送的消息出现在我们的控制台中：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have already learned enough to implement useful scaling tools. If we have
    a number of distributed Node processes, even on different physical servers, each
    can reliably send messages to the others via RabbitMQ. Each process needs to simply
    implement an exchange queue subscriber to receive messages and an exchange publisher
    when messages need to be sent.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了足够的知识来实现有用的扩展工具。如果我们有多个分布式的 Node 进程，甚至在不同的物理服务器上，每个进程都可以通过 RabbitMQ 可靠地向其他进程发送消息。每个进程只需要简单地实现一个交换队列订阅者来接收消息，以及一个交换发布者，当需要发送消息时。
- en: 'Three types of exchanges exist: **direct**, **fanout**, and **topic**. The
    differences appear in the way each type of exchange processes **routing keys**—the
    first argument sent to `exchange.publish`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '存在三种类型的交换：**直接**、**扇出**和**主题**。不同之处在于每种类型的交换处理**路由键**的方式——`exchange.publish`
    发送的第一个参数。 '
- en: 'A direct exchange matches routing keys directly. Here''s an example of a queue
    binding:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 直接交换直接匹配路由键。以下是一个队列绑定的例子：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding queue binding will match *only* messages sent to `room-1`. Because
    no parsing is necessary, direct exchanges are able to process more messages than
    topic exchanges in a set period of time.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的队列绑定将*仅*匹配发送到 `room-1` 的消息。因为不需要解析，所以直接交换能够在一定时间内处理比主题交换更多的消息。
- en: 'A fanout exchange is indiscriminate: it routes messages to all of the queues
    bound to it, ignoring routing keys. This type of exchange is used for wide broadcasts.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 扇出交换是无差别的：它将消息路由到它绑定的所有队列，忽略路由键。这种类型的交换用于广泛的广播。
- en: A topic exchange matches routing keys based on the wildcards `#` and `*`. Unlike
    other types, routing keys for topic exchanges *must* be composed of words separated
    by dots—*animals.dogs.poodle*, for example. A `#` matches *zero or more* words—it
    will match every message (as we saw in the previous example) just like a fanout
    exchange. The other wildcard is `*`, and this matches *exactly one* word.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 主题交换根据通配符 `#` 和 `*` 匹配路由键。与其他类型不同，主题交换的路由键*必须*由点分隔的单词组成——例如 `animals.dogs.poodle`。`#`
    匹配*零个或多个*单词——它将匹配每条消息（就像我们在前面的例子中看到的那样），就像扇出交换一样。另一个通配符是 `*`，它匹配*恰好一个*单词。
- en: Direct and fanout exchanges can be implemented using nearly the same code as
    the given topic exchange example, requiring only that the exchange type be changed,
    and that bind operations be aware of how they will be associated with routing
    keys (fanout subscribers receive all messages, regardless of the key; for a direct
    exchange, the routing key must match directly).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用与提供的主题交换示例几乎相同的代码实现直接和扇出交换，只需更改交换类型，并且绑定操作要了解它们将如何与路由键关联（扇出订阅者接收所有消息，无论键是什么；对于直接交换，路由键必须直接匹配）。
- en: 'This last example should drive home how topic exchanges work. We will create
    three queues with different matching rules, filtering the messages each queue
    receives from the exchange:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的例子应该能够说明主题交换是如何工作的。我们将创建三个具有不同匹配规则的队列，过滤每个队列从交换中接收到的消息：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `node-amqp` module contains further methods to control connections, queues,
    and exchanges, in particular methods of removing queues from exchanges and subscribers
    from queues. Generally, changing the makeup of a running queue on the fly can
    lead to unexpected errors, so use these with caution.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-amqp` 模块包含进一步的方法来控制连接、队列和交换，特别是从交换中删除队列和从队列中删除订阅者的方法。通常，在运行队列上动态更改其组成可能会导致意外的错误，因此请谨慎使用这些方法。'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the AMQP (and the options available when setting up with
    `node-amqp`), visit [http://www.rabbitmq.com/tutorials/amqp-concepts.html](http://www.rabbitmq.com/tutorials/amqp-concepts.html).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 AMQP（以及使用 `node-amqp` 设置时可用选项），请访问 [http://www.rabbitmq.com/tutorials/amqp-concepts.html](http://www.rabbitmq.com/tutorials/amqp-concepts.html)。
- en: Using Node's UDP Module
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Node 的 UDP 模块
- en: '**User Datagram Protocol** (**UDP**) is a lightweight core Internet messaging
    protocol, enabling servers to pass around concise *datagrams*. UDP was designed
    with a minimum of protocol overhead, forgoing delivery, ordering, and duplication
    prevention mechanisms in favor of ensuring high performance. UDP is a good choice
    when perfect reliability is not required and high-speed transmission is, as found
    in networked video games and videoconferencing applications. Logging is another
    popular use for UDP.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）是一种轻量级的核心互联网消息协议，允许服务器传递简洁的 *数据报*。UDP 设计时考虑了最小的协议开销，放弃了交付、排序和重复预防机制，以确保高性能。当不需要完美可靠性而需要高速传输时，UDP
    是一个好的选择，例如在网络视频游戏和视频会议应用程序中。日志记录也是 UDP 的另一个流行用途。'
- en: This is not to say that UDP is *normally* unreliable. In most applications,
    it delivers messages with high probability. It is simply not suitable when *perfect*
    reliability is needed, such as in a banking application. It is an excellent candidate
    for monitoring and logging applications and for noncritical messaging services.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说 UDP 通常不可靠。在大多数应用程序中，它以高概率传递消息。它只是不适合需要 *完美* 可靠性的情况，例如在银行应用程序中。它是监控和日志记录应用程序以及非关键消息服务的优秀候选者。
- en: 'Creating a UDP server with Node is straightforward:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 创建 UDP 服务器很简单：
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The bind command takes three arguments:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定命令需要三个参数：
- en: '**port**: This is the integer port number.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 这是整数端口号。'
- en: '**address**: This is an optional address. If this is not specified, the OS
    will try to listen on all addresses (which is often what you want). You might
    also try using `0.0.0.0` explicitly.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**: 这是一个可选的地址。如果没有指定，操作系统将尝试监听所有地址（这通常是您想要的）。您也可以尝试显式使用 `0.0.0.0`。'
- en: '**callback**: This is an optional callback, which receives no arguments.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调**: 这是一个可选的回调，它不接受任何参数。'
- en: 'This socket will now emit a **message** event whenever it receives a datagram
    via port `41234`. The event callback receives the message itself as the first
    parameter and a map of packet information as the second:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当此套接字通过端口 `41234` 接收到数据报时，它将现在发出一个 **消息** 事件。事件回调将消息本身作为第一个参数，以及一个包含数据包信息的映射作为第二个参数：
- en: '**address**: This is the originating IP'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**: 这是原始 IP 地址'
- en: '**family**: This is one of IPv4 or IPv6'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家族**: 这是 IPv4 或 IPv6 之一'
- en: '**port**: This is the originating port'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**: 这是原始端口'
- en: '**size**: This is the size of the message in bytes'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**: 这是消息的字节数'
- en: This map is similar to the map returned when calling `socket.address()`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射类似于调用 `socket.address()` 时返回的映射。
- en: In addition to the message and listening events, a UDP socket also emits a `close`
    event and an `error` event, with the latter receiving an `Error` object whenever
    an error occurs. To close a UDP socket (and trigger the `close` event), use `server.close()`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消息和监听事件外，UDP套接字还会发出一个`close`事件和一个`error`事件，后者在发生错误时接收一个`Error`对象。要关闭UDP套接字（并触发`close`事件），请使用`server.close()`。
- en: 'Sending a message is even easier:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息甚至更简单：
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The send method takes the form `client.send(buffer, offset, length, port, host,
    callback)`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方法的形式为`client.send(buffer, offset, length, port, host, callback)`：
- en: '**buffer**: This is a buffer containing the datagram to be sent'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区**：这是一个包含要发送的数据报的缓冲区'
- en: '**offset**: This is an integer indicating the position in the **buffer** where
    the datagram begins'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：这是一个整数，指示数据报在**缓冲区**中的起始位置'
- en: '**length**: This is the number of bytes in a datagram. In combination with
    **offset**, this value identifies the full datagram within the **buffer**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**：这是数据报中的字节数。与**偏移量**结合，此值标识了**缓冲区**内的完整数据报'
- en: '**port**: This is an integer identifying the destination port'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：这是一个整数，用于标识目标端口'
- en: '**address**: This is a string indicating the destination IP for the datagram'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：这是一个字符串，指示数据报的目标IP地址'
- en: '**callback**: This is an optional callback function called after the send has
    taken place.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调函数**：这是一个可选的回调函数，在发送操作完成后被调用。'
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size of a datagram cannot exceed 65,507 bytes, which is equal to *2^16-1*
    (65,535) bytes minus the 8 bytes used by the UDP header minus the 20 bytes used
    by the IP header.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报的大小不能超过65,507字节，这等于*2^16-1*（65,535）字节减去UDP头部占用的8字节减去IP头部占用的20字节。
- en: We now have another candidate for interprocess messaging. It would be rather
    easy to set up a monitoring server for our Node application that listens on a
    UDP socket for program updates and statistics sent from other processes. The protocol
    speed is fast enough for real-time systems, and any packet loss or other UDP hiccups
    would be insignificant taken as a percentage of total volume over time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有另一个进程间通信的候选方案。为我们的Node应用程序设置一个监听UDP套接字的监控服务器相当容易，该服务器用于监听来自其他进程的程序更新和统计信息。该协议的速度足够快，适用于实时系统，并且任何数据包丢失或其他UDP问题，从总量的百分比来看都是微不足道的。
- en: 'Taking the idea of broadcasting further, we can also use the `dgram` module
    to create a multicast server. A "multicast" is simply a one-to-many server broadcast.
    We can broadcast to a range of IPs that have been permanently reserved as multicast
    addresses. The website [http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml](http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml)
    has this to say:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将广播的概念进一步扩展，我们还可以使用`dgram`模块创建一个多播服务器。一个“多播”简单地说是一个一对多的服务器广播。我们可以向永久保留为多播地址的IP地址范围进行广播。网站[http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml](http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml)上有以下说明：
- en: '*"Host Extensions for IP Multicasting [RFC1112] specifies the extensions required
    of a host implementation of the Internet Protocol (IP) to support multicasting.
    The multicast addresses are in the range 224.0.0.0 through 239.255.255.255."*'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"IP多播的主机扩展 [RFC1112] 指定了主机实现互联网协议（IP）所需的支持多播的扩展。多播地址的范围是224.0.0.0到239.255.255.255。"*'
- en: Additionally, the range between 224.0.0.0 and 224.0.0.255 is further reserved
    for special routing protocols.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，224.0.0.0到224.0.0.255之间的范围进一步保留用于特殊路由协议。
- en: Also, certain port numbers are allocated for use by UDP (and TCP), a list of
    which can be found at [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些端口号被分配给UDP（和TCP）使用，可以在[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)找到这些端口号的列表。
- en: The upshot of all this fascinating information is the knowledge that there is
    a block of IPs and ports reserved for UDP and/or multicasting, and we are now
    going to use some of them to implement multicasting over UDP with Node.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些有趣信息的要点是，我们知道有一块IP和端口是为UDP和/或多播保留的，我们现在将使用其中一些来实现Node上的多播。
- en: 'The only difference between setting up a multicasting UDP server and a "standard"
    one is the binding of the multicasting server to a special UDP port to indicate
    that we''d like to listen to *all* available network adapters. Our multicasting
    server initialization looks like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 设置多播UDP服务器和“标准”服务器之间的唯一区别是将多播服务器绑定到一个特殊的UDP端口，以表示我们想监听*所有*可用的网络适配器。我们的多播服务器初始化看起来像这样：
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After requesting a multicast port binding, we wait for the socket listen event,
    at which point we can configure our server.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求多播端口绑定后，我们等待套接字监听事件，此时我们可以配置我们的服务器。
- en: The most important command is `socket.addMembership`, which tells the kernel
    to join the multicast group at `multicastAddress`. Other UDP sockets can now subscribe
    to the multicast group at this address.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的命令是`socket.addMembership`，它告诉内核加入`multicastAddress`处的多播组。其他UDP套接字现在可以订阅此地址的多播组。
- en: Datagrams hop through networks just like any network packet. The `setMulticastTTL`
    method is used to set the maximum number of hops ("time to live") a datagram is
    allowed to make before it is abandoned and not delivered. The acceptable range
    is 0–255, with the default being one (1) on most systems. This is not usually
    a setting one must worry about, but it is available if deep visibility into network
    topology lends relevance to this aspect of packet delivery.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报就像任何网络数据包一样在网络中跳跃。`setMulticastTTL`方法用于设置数据报在被丢弃且未交付之前允许的最大跳跃数（“生存时间”）。可接受的范围是0–255，大多数系统上的默认值是1（1）。这通常不是必须担心的一个设置，但如果深入了解网络拓扑对数据包交付的这方面有相关性，则它是可用的。
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you'd also like to allow listening on the *local* interface, use `socket.setBroadcast(true)`
    and `socket.setMulticastLoopback(true)`. This is normally not necessary.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想允许在*本地*接口上监听，请使用`socket.setBroadcast(true)`和`socket.setMulticastLoopback(true)`。这通常不是必要的。
- en: 'We are eventually going to use this server to broadcast messages to all UDP
    listeners on `multicastAddress`. For now, let''s create two clients that will
    listen for multicasts:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将使用此服务器向`multicastAddress`上的所有UDP监听器广播消息。现在，让我们创建两个客户端，它们将监听多播：
- en: '[PRE45]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now have two clients listening to the same multicast port. All that is left
    to do is the multicasting. In this example, we will use `setTimeout` to send a
    counter value every second:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个客户端正在监听同一个多播端口。剩下要做的就是多播。在这个例子中，我们将使用`setTimeout`每秒发送一个计数器值：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code will produce something like the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生类似以下内容：
- en: '[PRE47]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have two clients listening to broadcasts from a specific group. Let''s add
    another client, listening on a different group—let''s say at the multicast address
    `230.3.2.1`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个客户端正在监听来自特定组的广播。让我们添加另一个客户端，监听不同的组——比如说在多播地址`230.3.2.1`：
- en: '[PRE48]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Because our server currently broadcasts messages to a different address, we
    will need to change our server configuration and add this new address with another
    `addMembership` call:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务器目前向不同的地址广播消息，我们需要更改我们的服务器配置，并使用另一个`addMembership`调用添加此新地址：
- en: '[PRE49]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now send messages to *both* addresses:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向*两个*地址发送消息：
- en: '[PRE50]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Of course, nothing stops the client from broadcasting to others in its group
    or even members of *another* group:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有任何东西阻止客户端向其组中的其他人广播，甚至向*另一个*组的成员广播：
- en: '[PRE51]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Any Node process that has an address on our network interface can now listen
    on a UDP multicast address for messages, providing a fast and elegant interprocess
    communication system.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有我们网络接口地址的Node进程现在都可以监听UDP多播地址上的消息，从而提供一个快速而优雅的进程间通信系统。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at ways in which Node applications can be scaled
    both vertically and horizontally. We learned how to use `spawn` on OS processes
    and to use `fork` on new Node processes. The overview of the `cluster` module
    demonstrated how easy it is to scale across cores using Node and efficiently and
    easily distribute client connections across workers with built-in messaging channels
    to the central (master) hub. We also looked at how horizontally distributed processes
    and servers can communicate using message queues and UDP servers and how these
    servers can be load balanced and proxied using Nginx or using Node modules designed
    for that purpose.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Node应用程序如何进行垂直和水平扩展的方法。我们学习了如何在操作系统进程中使用`spawn`，以及在新的Node进程中使用`fork`。`cluster`模块的概述展示了使用Node跨核心扩展是多么容易，以及如何通过内置的消息通道高效且轻松地将客户端连接分配给中央（主）枢纽。我们还探讨了水平分布的进程和服务器如何使用消息队列和UDP服务器进行通信，以及这些服务器如何使用Nginx或为该目的设计的Node模块进行负载均衡和代理。
- en: Scaling is not only about servers and load balancing. In the next chapter, we'll
    look at how to scale and manage resources, learn about memory management techniques,
    synchronize data across distributed services, synchronize data-caching strategies,
    and look at how to deal with massive numbers of simultaneous connections.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展不仅关乎服务器和负载均衡。在下一章中，我们将探讨如何扩展和管理资源，了解内存管理技术，同步分布式服务之间的数据，同步数据缓存策略，以及如何处理大量同时连接。
