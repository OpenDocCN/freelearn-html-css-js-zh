<html><head></head><body>
		<div id="_idContainer070">
			<h1 id="_idParaDest-65" class="chapter-number"><a id="_idTextAnchor078"/>4</h1>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor079"/>Super Speed – Time-Travel Paradoxes and Broken Promises</h1>
			<p>In this chapter, we will discuss how we deal with issues that arise with <a id="_idTextAnchor080"/>multithreaded execution in an event loop of a test framework. Then, we’ll look at a way to keep the switches in a framework in a consistent location when we begin to add more <span class="No-Break">complex functionality.</span></p>
			<p>JavaScript is an insanely fast programming language. Because its primary goal is to build website pages as fast as possible, it executes lines of code in an event loop with multiple threads. This is an advantage in building web pages as fast as possible, but it can be a hindrance in test automation that needs events executed in a <span class="No-Break">particular order.</span></p>
			<p>In fact, this speedster is so fast it can time travel. Let us take a look at an example in the <span class="No-Break">next section.</span></p>
			<p>Before we do that, here's a list of the topics we'll cover in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>The <span class="No-Break">time-travel dilemma</span></li>
				<li>Schrödinger and the quantum mechanics of <span class="No-Break">test automation</span></li>
				<li>Callbacks, promises, <span class="No-Break">and async/await</span></li>
				<li>The death of fibers and <span class="No-Break">synchronous mode</span></li>
			</ul>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor081"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO"><span class="No-Break">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor082"/>The time-travel dilemma</h1>
			<p>Let’s begin with <a id="_idIndexMarker192"/>the most basic script – login. Open <strong class="source-inline">login.page.ts</strong> in the <strong class="source-inline">\pageobjects</strong> folder. Note there is an <strong class="source-inline">async</strong> command in the <span class="No-Break"><strong class="source-inline">login()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
    public async login (username: string, password: string)
        await this.inputUsername.setValue(username);
        await this.inputPassword.setValue(password);
        await this.btnSubmit.click();
    }</pre>			<p>The <strong class="source-inline">async</strong> keyword forces the function to always be asynchronous, returning a <strong class="source-inline">Promise</strong> object representing the completion or failure of the function. There is also an <strong class="source-inline">await</strong> keyword preceding the <strong class="source-inline">.setValue</strong> and <strong class="source-inline">.click</strong> commands, which pauses the function until the <strong class="source-inline">Promise</strong> object is resolved or rejected. What would happen if the <strong class="source-inline">await</strong> command <a id="_idIndexMarker193"/><span class="No-Break">were removed?</span></p>
			<pre class="source-code">
    public async login (username: string, password: string) {
        //Removed await keyword
        this.inputUsername.setValue(username);
        this.inputPassword.setValue(password);
        this.btnSubmit.click();
    }</pre>			<p>From the Visual Studio Code shell, run the <span class="No-Break"><strong class="source-inline">wdio</strong></span><span class="No-Break"> test:</span></p>
			<pre class="source-code">
 &gt; yarn wdio</pre>			<p>When the test is executed, it fails! It indicates that the username provided was invalid in the following results, which leads us down a rabbit hole because the password is in fact <span class="No-Break">perfectly valid:</span></p>
			<pre class="source-code">
» \test\specs\ch2.ts
 My Login application
    <strong class="bold">x</strong> should login with valid credentials
 1 failing (12.2s)
 1) My Login application should login with valid credentials
 Expect $(`#flash`) to have text containing
- Expected  - 1
+ Received  + 2
- You logged into a secure area!
+ Your username is invalid!</pre>			<p>So, what changed? The execution order of the lines of code! Without the <strong class="source-inline">await</strong> keyword, Node.js will execute all the JavaScript commands simultaneously. So, the <strong class="bold">Submit</strong> button could get clicked before the credentials are populated. This fails the final validation in the main script checking for the text <strong class="source-inline">You are logged into a secure area!</strong>. It fails because the <strong class="bold">Login</strong> button was clicked before the <strong class="source-inline">Username </strong>field was completely populated. It instead reports <strong class="source-inline">Your username is invalid</strong> because the username was still blank when the <strong class="bold">Submit</strong> button <span class="No-Break">was clicked.</span></p>
			<p>Of course, the best superhero detectives need more evidence. No one thought to take a picture at the scene of <a id="_idIndexMarker194"/>the crime. So, let’s add some debugging output and try the <span class="No-Break">test again:</span></p>
			<pre class="source-code">
global.log (`Logging in with '${username}' and '${password}'`)
this.inputUsername.setValue(username);
global.log (`Entered '${username}'`)
this.inputPassword.setValue(password);
global.log (`Entered '${password}' and clicking Submit`)
this.btnSubmit.click();
global.log ("Submit clicked!")</pre>			<p>This time, the results show the test passed. However, we have now encountered a <span class="No-Break">stale element:</span></p>
			<pre class="source-code">
[0-0] ---&gt; Logging in with 'tomsmith' and 'SuperSecretPassword!'
[0-0] ---&gt; Entered 'tomsmith'
[0-0] ---&gt; Entered 'SuperSecretPassword!' and clicking Submit
[0-0] ---&gt; Submit clicked!
[0-0] 2022-12-03T18:07:52.839Z WARN webdriver: Request encountered a stale element - terminating request
[0-0] PASSED in chrome - D:\repos\wdio\test\specs\ch2.ts</pre>			<p>Which element was stale? In order to find out, we need to change the <strong class="source-inline">logLevel</strong> back to <strong class="source-inline">info</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">wdio.conf.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    logLevel: 'info',</pre>			<p>Now, when we rerun the test, we get a completely different error buried in a lot <span class="No-Break">of information:</span></p>
			<pre class="source-code">
[0-0]   error: 'no such element',
[0-0]   message: 'no such element: Unable to locate element: {"method":"css selector","selector":"#flash"}\n' +
[0-0]     '  (Session info: chrome=107.0.5304.122)',</pre>			<p>It looks like things have gotten out of hand. If we try to add more <strong class="source-inline">debug</strong> statements, we’ll get differing results <a id="_idIndexMarker195"/>that might not be repeatable. Would you believe this exact phenomenon is described in a book far more advanced than <span class="No-Break">this one?</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor083"/>Schrödinger and the quantum mechanics of test automation</h1>
			<p>This issue is similar<a id="_idIndexMarker196"/> to what is known<a id="_idIndexMarker197"/> as <a id="_idIndexMarker198"/>the <em class="italic">measurement problem</em> in quantum mechanics. Putting it simply, measuring the outcome of an event at the quantum level can change the outcome of the event. Imagine testing the temperature of cold water with a warm thermometer. Over time, the measuring equipment warms the cold water slightly and the equipment itself cools from the cold water. Thus, readings over time <span class="No-Break">become inconclusive.</span></p>
			<p>In this case, sending details to the console window puts a little more overhead on the system. The speed of execution of the statements changes slightly, and so does the completion order, giving different results each time. This has a lot to do with the prioritization of statement execution in the JavaScript event Loop, as <span class="No-Break">shown next:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B19395_04_1.jpg" alt="Figure 4.1 – A visualization of the execution order of promises and callbacks in the JavaScript Event loop"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A visualization of the execution order of promises and callbacks in the JavaScript Event loop</p>
			<p>JavaScript has an <a id="_idIndexMarker199"/>Event<a id="_idIndexMarker200"/> Loop with the<a id="_idIndexMarker201"/> main thread, with macro tasks and micro tasks. The latter, which are promises, execute after the main thread statements. <strong class="source-inline">MacroTasks</strong>, which include callbacks and the timeout statement, <em class="italic">can</em> execute prior to the Main thread but after promises. When these tasks are completed in an unexpected order, you can waste hours of time trying to isolate the issue <span class="No-Break">during debugging.</span></p>
			<p><strong class="source-inline">MacroTasks</strong> are usually related to I/O operations or UI rendering. Examples of <strong class="source-inline">MacroTasks</strong> include <strong class="source-inline">setTimeout</strong>, <strong class="source-inline">setInterval</strong>, <strong class="source-inline">setImmediate</strong>, and I/O operations. These tasks are executed by the event loop, and they can run before or <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">MicroTasks</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">MicroTasks</strong> are usually related to promises. They can also include mutation observers. Developers use these in various scenarios, such as tracking changes to attributes, detecting additions or removals of child elements, or even observing changes to character data within an element. <strong class="source-inline">MicroTasks</strong> are executed after the main thread statements and before the execution of the next <strong class="source-inline">macroTask</strong>. They are used to handle callbacks and <span class="No-Break">resolve promises.</span></p>
			<p>When tasks complete in an unexpected order, it can lead to debugging challenges. This is because the order of execution impacts the overall behavior of the test. This is fine for optimizing the time <a id="_idIndexMarker202"/>spent building a web page <a id="_idIndexMarker203"/>on <a id="_idIndexMarker204"/>multiple threads, but it causes havoc for SDETs trying to run script steps in a <span class="No-Break">sequential order.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor084"/>Callbacks, promises, and async/await</h1>
			<p>To resolve these issues, we <a id="_idIndexMarker205"/>need to<a id="_idIndexMarker206"/> force JavaScript to execute<a id="_idIndexMarker207"/> code in a linear order. JavaScript provides three solutions – callbacks, promises, and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords. JavaScript promises and callbacks are two ways of knowing when the asynchronous call has a result. Callbacks allow you to execute a function once a response is received. Promises do the same and allow you to specify an easily readable order for multiple operations, as well as handle error cases. However, did you know there was an even easier way to deal with promises called <span class="No-Break">synchronous mode?</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor085"/>The death of fibers and synchronous mode</h1>
			<p>Promises were<a id="_idIndexMarker208"/> added to JavaScript to make asynchronous callbacks to functions easier to implement. Functions were passed without parenthesis, making them visibly similar to variables and objects. Then, the <strong class="bold">async</strong> and <strong class="bold">await</strong> keywords were also added as syntactic sugar to make promises and callbacks easier. However, way back in 2014, there was the <strong class="source-inline">node-fibers</strong> package project, which implicitly<a id="_idIndexMarker209"/> wrapped statements as callbacks in <span class="No-Break">the background.</span></p>
			<p>Up until version 7.0, WebdriverIO leveraged the <strong class="source-inline">node-fibers</strong> package as part of the <strong class="source-inline">@wdio/sync</strong> feature. This <a id="_idIndexMarker210"/>meant all browser methods would execute synchronously without callbacks, promises, or <strong class="bold">await</strong>. This was a brilliant trade-off for WebdriverIO framework architects! It avoided the time travel issues while making the code <span class="No-Break">less complex.</span></p>
			<p>Unfortunately, the <strong class="source-inline">node-fibers</strong> project was discontinued in 2021. WebdriverIO was forced to notify users of two solutions – they could lock Node to the last supported version that was compatible with <strong class="source-inline">node-fibers</strong>, missing out on new features as JavaScript added more functionality defined by the evolving ECMAScript standard. Alternatively, they could refactor the code base to include <strong class="source-inline">async</strong> in functions and <strong class="source-inline">await</strong> in browser <a id="_idIndexMarker211"/>methods. Most chose the latter and faced a large amount of time <span class="No-Break">refactoring code.</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B19395_04_2.jpg" alt="Figure 4.2 – Packages looking for funding"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Packages looking for funding</p>
			<p>That said, let<a id="_idIndexMarker212"/> us look at how we solve this time crisis. In our previous chapter, we simulated an error by passing a <span class="No-Break"><strong class="source-inline">promise</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
await global.log (Promise) // Adds trace</pre>			<p>What happens if we remove the <span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> keyword?</span></p>
			<pre class="source-code">
global.log (Promise) // Adds trace with WARN out of order
[0-0] Trace
[0-0]     at global.log (D:\repos\Test-Automation-with-WebdriverIO\test\wdio.conf.ts:379:21)
[0-0]     at UserContext.&lt;anonymous&gt; (D:\repos\wdio\test\specs\example.e2e.ts:13:22)
[0-0] ---&gt;     WARN: Log was passed a Promise object</pre>			<p>Note that when <strong class="source-inline">await</strong> is missing from the code, all that happens is the custom <strong class="source-inline">WARN</strong> message appears after the error detail, instead of before it. This relates to JavaScript executing in multiple <a id="_idIndexMarker213"/>threads. We have proof of the effect of events executing out <span class="No-Break">of sequence.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor086"/>Keep it simple with async and await</h2>
			<p>Every custom method<a id="_idIndexMarker214"/> in this book will execute asynchronously. In theory, we might think it would be clever to populate fields and drop-down lists concurrently for speed. However, often choosing a value from a list will kick off an <strong class="source-inline">Ajax</strong> method that will update the web page. This would then have fields generating errors if the elements do not yet exist because the code executed while the page was <span class="No-Break">built anew.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor087"/>Summary</h1>
			<p>In this chapter, we learned about the impact synchronous code execution can have on our framework. While callbacks and promises are ways to keep code running in sequential order, it is best to use async and await to keep it consistent. We also upgraded global values to a single <strong class="source-inline">switchboard</strong> object that can be viewed during <span class="No-Break">debugging sessions.</span></p>
			<p>In the next chapter, we will combine everything so far to enhance our first method <span class="No-Break">wrapper function.</span></p>
		</div>
	</body></html>