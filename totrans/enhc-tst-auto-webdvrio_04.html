<html><head></head><body>
		<div><h1 id="_idParaDest-65" class="chapter-number"><a id="_idTextAnchor078"/>4</h1>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor079"/>Super Speed – Time-Travel Paradoxes and Broken Promises</h1>
			<p>In this chapter, we will discuss how we deal with issues that arise with <a id="_idTextAnchor080"/>multithreaded execution in an event loop of a test framework. Then, we’ll look at a way to keep the switches in a framework in a consistent location when we begin to add more complex functionality.</p>
			<p>JavaScript is an insanely fast programming language. Because its primary goal is to build website pages as fast as possible, it executes lines of code in an event loop with multiple threads. This is an advantage in building web pages as fast as possible, but it can be a hindrance in test automation that needs events executed in a particular order.</p>
			<p>In fact, this speedster is so fast it can time travel. Let us take a look at an example in the next section.</p>
			<p>Before we do that, here's a list of the topics we'll cover in this chapter:</p>
			<ul>
				<li>The time-travel dilemma</li>
				<li>Schrödinger and the quantum mechanics of test automation</li>
				<li>Callbacks, promises, and async/await</li>
				<li>The death of fibers and synchronous mode</li>
			</ul>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor081"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub repository: <a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</a>.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor082"/>The time-travel dilemma</h1>
			<p>Let’s begin with <a id="_idIndexMarker192"/>the most basic script – login. Open <code>login.page.ts</code> in the <code>\pageobjects</code> folder. Note there is an <code>async</code> command in the <code>login()</code> function:</p>
			<pre class="source-code">
    public async login (username: string, password: string)
        await this.inputUsername.setValue(username);
        await this.inputPassword.setValue(password);
        await this.btnSubmit.click();
    }</pre>			<p>The <code>async</code> keyword forces the function to always be asynchronous, returning a <code>Promise</code> object representing the completion or failure of the function. There is also an <code>await</code> keyword preceding the <code>.setValue</code> and <code>.click</code> commands, which pauses the function until the <code>Promise</code> object is resolved or rejected. What would happen if the <code>await</code> command <a id="_idIndexMarker193"/>were removed?</p>
			<pre class="source-code">
    public async login (username: string, password: string) {
        //Removed await keyword
        this.inputUsername.setValue(username);
        this.inputPassword.setValue(password);
        this.btnSubmit.click();
    }</pre>			<p>From the Visual Studio Code shell, run the <code>wdio</code> test:</p>
			<pre class="source-code">
 &gt; yarn wdio</pre>			<p>When the test is executed, it fails! It indicates that the username provided was invalid in the following results, which leads us down a rabbit hole because the password is in fact perfectly valid:</p>
			<pre class="source-code">
» \test\specs\ch2.ts
 My Login application
    <strong class="bold">x</strong> should login with valid credentials
 1 failing (12.2s)
 1) My Login application should login with valid credentials
 Expect $(`#flash`) to have text containing
- Expected  - 1
+ Received  + 2
- You logged into a secure area!
+ Your username is invalid!</pre>			<p>So, what changed? The execution order of the lines of code! Without the <code>await</code> keyword, Node.js will execute all the JavaScript commands simultaneously. So, the <code>You are logged into a secure area!</code>. It fails because the <code>Username </code>field was completely populated. It instead reports <code>Your username is invalid</code> because the username was still blank when the <strong class="bold">Submit</strong> button was clicked.</p>
			<p>Of course, the best superhero detectives need more evidence. No one thought to take a picture at the scene of <a id="_idIndexMarker194"/>the crime. So, let’s add some debugging output and try the test again:</p>
			<pre class="source-code">
global.log (`Logging in with '${username}' and '${password}'`)
this.inputUsername.setValue(username);
global.log (`Entered '${username}'`)
this.inputPassword.setValue(password);
global.log (`Entered '${password}' and clicking Submit`)
this.btnSubmit.click();
global.log ("Submit clicked!")</pre>			<p>This time, the results show the test passed. However, we have now encountered a stale element:</p>
			<pre class="source-code">
[0-0] ---&gt; Logging in with 'tomsmith' and 'SuperSecretPassword!'
[0-0] ---&gt; Entered 'tomsmith'
[0-0] ---&gt; Entered 'SuperSecretPassword!' and clicking Submit
[0-0] ---&gt; Submit clicked!
[0-0] 2022-12-03T18:07:52.839Z WARN webdriver: Request encountered a stale element - terminating request
[0-0] PASSED in chrome - D:\repos\wdio\test\specs\ch2.ts</pre>			<p>Which element was stale? In order to find out, we need to change the <code>logLevel</code> back to <code>info</code> in <code>wdio.conf.ts</code>:</p>
			<pre class="source-code">
    logLevel: 'info',</pre>			<p>Now, when we rerun the test, we get a completely different error buried in a lot of information:</p>
			<pre class="source-code">
[0-0]   error: 'no such element',
[0-0]   message: 'no such element: Unable to locate element: {"method":"css selector","selector":"#flash"}\n' +
[0-0]     '  (Session info: chrome=107.0.5304.122)',</pre>			<p>It looks like things have gotten out of hand. If we try to add more <code>debug</code> statements, we’ll get differing results <a id="_idIndexMarker195"/>that might not be repeatable. Would you believe this exact phenomenon is described in a book far more advanced than this one?</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor083"/>Schrödinger and the quantum mechanics of test automation</h1>
			<p>This issue is similar<a id="_idIndexMarker196"/> to what is known<a id="_idIndexMarker197"/> as <a id="_idIndexMarker198"/>the <em class="italic">measurement problem</em> in quantum mechanics. Putting it simply, measuring the outcome of an event at the quantum level can change the outcome of the event. Imagine testing the temperature of cold water with a warm thermometer. Over time, the measuring equipment warms the cold water slightly and the equipment itself cools from the cold water. Thus, readings over time become inconclusive.</p>
			<p>In this case, sending details to the console window puts a little more overhead on the system. The speed of execution of the statements changes slightly, and so does the completion order, giving different results each time. This has a lot to do with the prioritization of statement execution in the JavaScript event Loop, as shown next:</p>
			<div><div><img src="img/B19395_04_1.jpg" alt="Figure 4.1 – A visualization of the execution order of promises and callbacks in the JavaScript Event loop"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A visualization of the execution order of promises and callbacks in the JavaScript Event loop</p>
			<p>JavaScript has an <a id="_idIndexMarker199"/>Event<a id="_idIndexMarker200"/> Loop with the<a id="_idIndexMarker201"/> main thread, with macro tasks and micro tasks. The latter, which are promises, execute after the main thread statements. <code>MacroTasks</code>, which include callbacks and the timeout statement, <em class="italic">can</em> execute prior to the Main thread but after promises. When these tasks are completed in an unexpected order, you can waste hours of time trying to isolate the issue during debugging.</p>
			<p><code>MacroTasks</code> are usually related to I/O operations or UI rendering. Examples of <code>MacroTasks</code> include <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, and I/O operations. These tasks are executed by the event loop, and they can run before or after <code>MicroTasks</code>.</p>
			<p><code>MicroTasks</code> are usually related to promises. They can also include mutation observers. Developers use these in various scenarios, such as tracking changes to attributes, detecting additions or removals of child elements, or even observing changes to character data within an element. <code>MicroTasks</code> are executed after the main thread statements and before the execution of the next <code>macroTask</code>. They are used to handle callbacks and resolve promises.</p>
			<p>When tasks complete in an unexpected order, it can lead to debugging challenges. This is because the order of execution impacts the overall behavior of the test. This is fine for optimizing the time <a id="_idIndexMarker202"/>spent building a web page <a id="_idIndexMarker203"/>on <a id="_idIndexMarker204"/>multiple threads, but it causes havoc for SDETs trying to run script steps in a sequential order.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor084"/>Callbacks, promises, and async/await</h1>
			<p>To resolve these issues, we <a id="_idIndexMarker205"/>need to<a id="_idIndexMarker206"/> force JavaScript to execute<a id="_idIndexMarker207"/> code in a linear order. JavaScript provides three solutions – callbacks, promises, and <code>async</code>/<code>await</code> keywords. JavaScript promises and callbacks are two ways of knowing when the asynchronous call has a result. Callbacks allow you to execute a function once a response is received. Promises do the same and allow you to specify an easily readable order for multiple operations, as well as handle error cases. However, did you know there was an even easier way to deal with promises called synchronous mode?</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor085"/>The death of fibers and synchronous mode</h1>
			<p>Promises were<a id="_idIndexMarker208"/> added to JavaScript to make asynchronous callbacks to functions easier to implement. Functions were passed without parenthesis, making them visibly similar to variables and objects. Then, the <code>node-fibers</code> package project, which implicitly<a id="_idIndexMarker209"/> wrapped statements as callbacks in the background.</p>
			<p>Up until version 7.0, WebdriverIO leveraged the <code>node-fibers</code> package as part of the <code>@wdio/sync</code> feature. This <a id="_idIndexMarker210"/>meant all browser methods would execute synchronously without callbacks, promises, or <strong class="bold">await</strong>. This was a brilliant trade-off for WebdriverIO framework architects! It avoided the time travel issues while making the code less complex.</p>
			<p>Unfortunately, the <code>node-fibers</code> project was discontinued in 2021. WebdriverIO was forced to notify users of two solutions – they could lock Node to the last supported version that was compatible with <code>node-fibers</code>, missing out on new features as JavaScript added more functionality defined by the evolving ECMAScript standard. Alternatively, they could refactor the code base to include <code>async</code> in functions and <code>await</code> in browser <a id="_idIndexMarker211"/>methods. Most chose the latter and faced a large amount of time refactoring code.</p>
			<div><div><img src="img/B19395_04_2.jpg" alt="Figure 4.2 – Packages looking for funding"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Packages looking for funding</p>
			<p>That said, let<a id="_idIndexMarker212"/> us look at how we solve this time crisis. In our previous chapter, we simulated an error by passing a <code>promise</code> object:</p>
			<pre class="source-code">
await global.log (Promise) // Adds trace</pre>			<p>What happens if we remove the <code>await</code> keyword?</p>
			<pre class="source-code">
global.log (Promise) // Adds trace with WARN out of order
[0-0] Trace
[0-0]     at global.log (D:\repos\Test-Automation-with-WebdriverIO\test\wdio.conf.ts:379:21)
[0-0]     at UserContext.&lt;anonymous&gt; (D:\repos\wdio\test\specs\example.e2e.ts:13:22)
[0-0] ---&gt;     WARN: Log was passed a Promise object</pre>			<p>Note that when <code>await</code> is missing from the code, all that happens is the custom <code>WARN</code> message appears after the error detail, instead of before it. This relates to JavaScript executing in multiple <a id="_idIndexMarker213"/>threads. We have proof of the effect of events executing out of sequence.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor086"/>Keep it simple with async and await</h2>
			<p>Every custom method<a id="_idIndexMarker214"/> in this book will execute asynchronously. In theory, we might think it would be clever to populate fields and drop-down lists concurrently for speed. However, often choosing a value from a list will kick off an <code>Ajax</code> method that will update the web page. This would then have fields generating errors if the elements do not yet exist because the code executed while the page was built anew.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor087"/>Summary</h1>
			<p>In this chapter, we learned about the impact synchronous code execution can have on our framework. While callbacks and promises are ways to keep code running in sequential order, it is best to use async and await to keep it consistent. We also upgraded global values to a single <code>switchboard</code> object that can be viewed during debugging sessions.</p>
			<p>In the next chapter, we will combine everything so far to enhance our first method wrapper function.</p>
		</div>
	</body></html>