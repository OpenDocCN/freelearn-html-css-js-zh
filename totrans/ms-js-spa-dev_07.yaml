- en: Chapter 7. Leveraging the MEAN Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MEAN stack is an acronym for MongoDB, Express, AngularJS, and Node.js. It
    represents full stack development using practically nothing but JavaScript alone.
    Naturally, you will need some HTML and CSS to render things to the browser and
    make them look pretty.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is a document-based NoSQL database that stores data in ways that can
    be treated like plain JavaScript objects. As the data and database methods are
    essentially JavaScript, MongoDB plays well with JavaScript-based applications.At
    this point, if you typed the code correctly, there will be no output in the console
    other than a new line. Open your favourite browser
  prefs: []
  type: TYPE_NORMAL
- en: Express is a web application framework, written in JavaScript that runs beautifully
    on Node.js. It's similar to other frameworks, such as Sinatra, but less obtrusive
    and opinionated. Express is essentially routing and middleware that handles web
    requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS is a frontend JavaScript framework that is primarily used to build
    Single Page Web applications. It's a powerful and prescriptive framework curated
    by Google, which has become one of the more popular JavaScript MV* toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll explore each of the following components of the MEAN
    stack while starting to build the framework of your very own Single Page Application:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Node.js code from the command line using the REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running Node.js scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB and basic CRUD operations from the Mongo shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Express via the standard method and the Express generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express routing, middleware, and view rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the basic components of a frontend application with Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node.js environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a runtime environment built to execute JavaScript. With it, you can
    build powerful software, such as full-fledged backend web servers. In *[Chapter
    1](ch01.html "Chapter 1. Getting Organized with NPM, Bower, and Grunt")* , *Getting
    Organized with NPM, Bower, and Grunt*, you began to use some Node.js-based tools,
    such as Grunt, NPM, and the Node Package Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is powerful, and extremely fast. It is based on the V8 JavaScript engine
    that's used in the Chrome browser and is tuned for speed. It uses a non-blocking
    I/O that allows it to handle many requests simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you have already installed the Node runtime. If not,
    go to [https://nodejs.org](https://nodejs.org), and follow the installation instructions
    for your operating system Node version 4.3.2 has been used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Running the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js provides a way to enter a run JavaScript code from the command line
    called the Read-Eval-Print Loop or REPL. You can start the REPL simply by typing
    `node` at the command line in a console. It''s a great way to begin exploring
    some of the possibilities with Node.js, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variable assignment in JavaScript returns undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it might appear that there are two return values, the first being `3`
    and the second being `undefined`. In this case, `console.log()` is a function
    that is used to write things out to the screen, but the function actually returns
    `undefined`. This will be useful in writing Node.js code where you want to log
    things to the screen, similar to print statements in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: To quit out of the REPL, hit *Ctrl* + *C* twice.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a hello Node.js script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the REPL on its own will not be incredibly useful. Node.js allows developers
    to create programs by writing them out and saving them as text files with a `.js`
    file extension.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of this is that you can use any text editor and practically
    any IDE to write Node.js programs.
  prefs: []
  type: TYPE_NORMAL
- en: To show you how powerful Node.js can be, let's start by building a simple web
    server. It will not do much, other than handling HTTP requests, but it's a great
    start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, call it `hello.js`, and open it in your favorite
    text editor or text-based IDE. Then, type the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and navigate it to the directory where it is stored with a console
    program. Then, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if you typed the code correctly, there will be no output in the
    console other than a new line. Open your favorite browser and type `localhost:3000`
    in your address bar.
  prefs: []
  type: TYPE_NORMAL
- en: You should see **Hello Node** in your browser's main window. And just like that,
    you have written a web server.
  prefs: []
  type: TYPE_NORMAL
- en: You can stop the server by typing Ctrl + C in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot going on in a small piece of code, so let''s walk through what
    the program is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the `varhttp=require('http');` code, similar to import
    statements in some programming languages, Node.js uses require to import code
    modules. Node.js ships with a number of built-in code modules. The HTTP module
    is a built-in module that provides, as you might assume, HTTP services. Built-in
    modules can be required using a string containing the name of the module. Generally,
    they will be used by assigning them to a variable. Non-built-in modules are required
    using a string containing the full path to the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next two lines, `var serverResponse = function(req, res)` and `res.end("Hello
    Node")`, the `serverResponse` function here is a callback function that we will
    pass to the web server we are creating. We will cover the request and response
    objects in more detail when we get into `Express.js`, but it's important to realize
    that we are setting up `req` to deal with the HTTP request object, and `res` to
    deal with the response. The end function on the response object sends whatever
    text is passed to it and tells the server that the response is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next code line, `varserver=http.createServer(serverResponse);`, we are
    actually creating a web server by invoking the `createServer` function on the
    HTTP object we required earlier. We pass the `serverResponse` function to the
    `createServer` function, which becomes a callback function for the server. We
    will store a reference to the server we just created in the variable called *server*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last line of the code, `server.listen(3000);`, we will invoke the `listen`
    function on the server object we just created. We will pass to it an integer representing
    the port number we want it to use to listen to requests. This bit of code actually
    starts up the server, and has it listen to requests on port `3000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Node.js project with NPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Node.js projects become larger, having a tool to mange it properly is important.
    Concerns such as consistent dependency management, version management, and environment
    management are made easier using **Node Package Manager** and the `package.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the smart people who created Node.js created a method of doing
    that using NPM. Running `npm init` from the command line will set up a Node.js
    project and build out a `package.json` file, which is used to manage your node
    projects. Let''s try it with your `hello` Node project. Note that some of the
    prompts are optional and can be left blank, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing Enter at this point will create the `package.json` file in the directory
    you''re in. Open it in your IDE or text editor and take a look. While you''re
    in there, let''s make the following small change to the scripts section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The scripts section of `package.json` allows you to run code using NPM. In this
    case, typing npm `start` will run the `node hello` command and start your web
    server. It's not a super efficient shortcut at this point, but you can create
    efficient and useful aliases for lots of commands this way.
  prefs: []
  type: TYPE_NORMAL
- en: One of the very important things that NPM does is manage dependencies. In the
    next section, on Express, you'll see how to store references to NPM modules and
    their versions in the `package.json` file. This is important when working as part
    of a group or team. By taking a copy of a project's `package.json` file, a developer
    can recreate the environment for the project just by running NPM installation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express describes itself as a fast, unopinionated, minimalist web framework
    for Node.js. Express is a very powerful and flexible framework that operates on
    top of Node.js, but still allows you access to all of the features of Node. At
    its core, Express operates as a set of routing and middleware functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get into routing and middleware in detail in later chapters. Basically,
    routing handles web requests. Middleware consists of functions that have access
    to the request and response objects and call the next piece of middleware in the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: If it's so easy to just throw up a web server using Node,js, why do we need
    something like Express?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, you don't. You could, all on your own, build a fully featured
    web application by just writing your own Node.js. Express has done a lot of the
    grunt work and heavy lifting for you. Because of the middleware that's easy to
    plus into Express, adding things such as security, authentication, and routing
    is fairly simple. And, who wants to build that stuff from scratch when you have
    an exciting new web application to build?
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, you will use NPM to install Express. There are two ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The standard method is just to use NPM to pull the Express project down and
    add a reference to it in `package.json`. This is just adding the module into a
    Node.js project. You will build an application script, require it in Express,
    and utilize it in that WAR file.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is to install the Express generator and use it to generate
    a starter web application. This method is simple to employ but it does structure
    your whole application, including folder structure, for you. Some people would
    prefer to do all of this on their own to get their setup precisely a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: We will try both methods, and use the Express generator to build the framework
    for the Single Page Application that you will build throughout the rest of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Standard method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, the standard method will just be to pull the module down and add it
    to your project. In your console, in the directory with the `package.json` file
    we just created, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a Mac, you may have to type `sudo` before `npm instal`l. If you're on a Mac,
    I would just go ahead and use `sudo` each type you are installing something with
    NPM.
  prefs: []
  type: TYPE_NORMAL
- en: The `-save` part tells npm to add Express as a dependency to your `package.json`
    file. Go ahead and open your `package.json` file and look at the dependencies
    section.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `git` or another source control system to share a code base
    with other developers, you, typically, will not store the dependencies in the
    remote repository. Instead, the `package.json` file will hold a reference to the
    required modules and their version.
  prefs: []
  type: TYPE_NORMAL
- en: Another developer can pull down your code, run `npm install`, and install all
    of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the folder where your `package.json` file resides, you will see
    a new folder called `node_modules`. This is where all of your dependencies installed
    with `npm` are stored. It's important not to move this or change it as the require
    function will look in here for modules. Typically, this folder will be added to
    a .`gitignore` file to ensure that its files aren't stored on a remote `git` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Express generator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another method of setting up an Express application. Express has created
    a generator that is a tool for rapidly setting up the framework for an Express
    application. It assumes some common conventions used in Express applications and
    configures things such as the main application, the `package,json`, and even the
    directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator is installed globally rather than in a specific project using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-g` tells NPM to install the module and its dependencies globally. They
    won't be installed in the `npm_modules` folder in your project, but in a global
    modules folder on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your Express application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the express generator installed globally, let's use it to start
    building the application we'll be building out in the rest of the book. Pick a
    folder where you want this project to live. The Express generator will create
    a new folder inside this folder, so it's fine if it is a home or projects folder
    containing other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to this folder in your console using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the express generator has created a number of files including
    `app,js`, your main app file.
  prefs: []
  type: TYPE_NORMAL
- en: The `-e` modifier we typed after the express command told the generator that
    we want to use `ejs` (embedded JavaScript) frontend templates. Express supports
    a number of templating languages, including Handlebars and Jade. If you add no
    modifier, the Express generator will assume you want to use Jade. For this project,
    we will use `ejs`, which is essentially real HTML with embedded JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: The final output of the generator tells you the next steps you need to actually
    stand up your application. Navigate to your new `giftapp` directory and run `npm
    install` (remember `sudo` if you're on a Mac or Linux box). The `npm install`
    command at this point might take a few minutes as it's installing a number of
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The next command starts your new Express application in `DEBUG` mode—you will
    see all requests logged to the console. Navigating to `localhost:3000` in your
    browser will display a **Welcome to Express** page.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, this page is being served from your very own robust Express
    web application. It's not doing much yet, but a lot of pieces are already in place
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the main script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open giftapp''s new `package.json` file. Note the following scripts object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is saying that when the `npm` start is run, the script that's actually
    invoked is at `./bin/www`. So, let's open the `www` file in your bin directory
    and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see that this file is requiring a number of things, including `app.js`;
    this is your main application file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next bit of code set''s the port number of the app. It looks to see if
    there''s an environment variable set containing the desired port number. If not,
    it sets it to `3000`. When deploying an application to production, typically,
    you will use `port 80` for HTTP or `port 443` for HTTPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next bit creates the server and starts listening on the correct port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For now, we'll skip over the rest of this file and take a look at what's in
    the `app.js` file. Go ahead and open it up.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the main application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`App.js` is the main application file that loads the routes and middleware
    and configures the application. There are a number of important sections of this
    file. In general, in Express applications, the order of loading and utilization,
    and the order middleware is invoked in this file, is important. Let''s take a
    look.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you open `app.js`, you will first encounter a number of calls to the require
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This system is known as `CommonJS`. The first set of modules includes the dependencies,
    such as Express, and a parser for cookies. The routes and users modules were created
    by the Express generator for routing. The routes you create will be required in
    the main file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, an `app` variable is declared by invoking the express function, and a
    couple of configuration variables are set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first configuration, views, tells Express where to look for the view templates.
    These are the templates that are normally rendered into HTML as the result of
    requests to the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The second configuration sets the view engine. As we discussed earlier, we will
    use `ejs` or embedded JavaScript templates.
  prefs: []
  type: TYPE_NORMAL
- en: Application-level middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing we will see in this file is a bunch of calls to the app object''s
    `use` function, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Express, calls to the application object's use function are application-level
    middleware. Requests sent to the application will execute every function matching
    the path set in `app.use`. If no path is set, the middleware function defaults
    to the root path `/`and will be invoked for every request.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `app.use(cookieParser());` means that the `cookieParser` function
    will be invoked for every request sent to the application because it defaults
    to the root path. However, `app.use('/users',users);` will only apply when the
    request begins with `/users`.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is invoked in the order it's declared. This will become very clear
    later, when we add authentication to our application, or want to handle `POST`
    data. If you don't parse cookies before you try to manage a request requiring
    authentication, it won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Express route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express uses a mechanism called routing, using its `Router` object, to handle
    HTTP requests, such as those from web browsers. In a later chapter, we will take
    a more in-depth look at Express routing. It bears examining the first route that
    the Express generator created for us. Open your `routes/index.js` file, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To create a new set of routes, we must create a new router object by invoking
    the `Expresses Router` function. You will see that we require Express first, then
    do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: The next expression is a call to the router object's get function. This, in
    Express, is router-level middleware. This function sets up middleware, in the
    form of the enclosed anonymous function, which responds to HTTP `GET` requests,
    such as typing a URL in a browser's address bar or clicking on a link.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to the function is a path to match. When the path matches,
    in this case the root path, the function is invoked. The anonymous function here
    receives the request object, the response object, and the next object.
  prefs: []
  type: TYPE_NORMAL
- en: The function invokes the response object's render function. This function looks
    in the views directory for a template called index and renders it, passing it
    the object in the second argument. The template has access to all the properties
    of that object, in this case, just the title, and can render them to in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will see the `module.exports=router;` expression. This allows the
    Node.js module system to load this code using the required function and assign
    the router object to a variable. Near the top of our `app.js` file, you'll see
    `varroutes=require('./routes/index');`.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the first view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you started the Express server, navigated to `localhost:3000`, and saw
    the default Express page, what happened?
  prefs: []
  type: TYPE_NORMAL
- en: The request came into the web application and was routed to index based on the
    request type, `GET`, and the path, `/`. The middleware then called the response
    object's render function and told it to get the index template, passing it an
    object with a property called title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `views/ index.ejs` file to see the following template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you've used other dynamic templating languages before, you probably already
    understand that this is normal HTML that contains some dynamic elements. Those
    dynamic elements that are contained by `<%...%>` are processed by the server.
    These *tags* are not sent to the browser, just clean HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the three tags are identical, all rendering the title property
    of the object passed in the call to the response object's render method. As a
    quick experiment, change the value of the title passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the *M* in the MEAN stack, is an open source document-based database.
    It's considered a NoSQL database because it doesn't use SQL and is not relational.
    It integrates well with JavaScript-based tools because, instead of tables, it
    stores data in documents that can be treated by our Node.js application as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically, MongoDB stores data in a format called BSON, short for Binary JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in getting MongoDB running on your system is installation. Head
    over to [https://www.mongodb.org/downloads#production](https://www.mongodb.org/downloads#production),
    and you will find the most updated installation download for Windows, Mac, Linux,
    or Solaris. There are also links to instructions there to install MongoDB with
    tools such as Homebrew for Mac and yum for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Up-to-date installation instructions for each operating system can be found
    at [https://docs.mongodb.org/manual/](https://docs.mongodb.org/manual/). There
    are differences between the operating systems, and installation instructions may
    change with newer versions. I suggest following the official installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can start the MongoDB service by typing `mongod` in a console.
  prefs: []
  type: TYPE_NORMAL
- en: You will not be able to type any other commands in that console while the MongoDB
    daemon is running. By default, this process will run on `port 27017` and bind
    to the IP address, `127.0.0.1`. Both of these can be changed with command flags
    at start up, or with a `.conf` file. For our purposes, the defaults will do.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the MongoDB shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll begin to work with MongoDB with the command-line shell included with the
    Mongo installation. As you must have the MongoDB daemon running to work with the
    database, you'll need to open a new console.
  prefs: []
  type: TYPE_NORMAL
- en: In the application we are building, we will rely on Node.js plugins to handle
    our database operations. It is beneficial, however, to gain an understanding of
    how MongoDB works and how it differs from SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to do that is to get our hands dirty and run some basic operations
    from the command line of MongoDB's shell.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s select the database that we want to work with. Open your command line
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running `mongo`, as opposed to `mongod`, from the command line starts the MongoDB
    shell, which allows typing commands directly to the running MongoDB daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `use` command selects which database we are currently using. But, wait
    a minute; we never created a test database. That''s correct, and we still haven''t.
    We can use the `showdbs` command to list all of the databases on our computer
    that MongoDB knows about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you've done all the previous examples, you would already have created a local
    database name `test`. Local stores a `startup` log and replica information in
    replicated environments. We can use local and add our own data to it, but that's
    not really a great idea. Let's create a database of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that records in MongoDB are referred to as documents. They loosely
    relate to rows in a traditional relation database but are much more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we insert a document now, the new database will be created use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `db.cat.insert()`command adds the document in the argument to insert to
    a collection called cat.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, a collection is a set of documents. This is similar to a table in
    a relational database, which is a set of records. Unlike relational databases,
    the documents in a collection do not have to all be the same type or have the
    same set of data.
  prefs: []
  type: TYPE_NORMAL
- en: You may get notices that the document we inserted looks like a plain old JavaScript
    object. Essentially, it is. This is one of the nice things about working with
    MongoDB as part of the MEAN stack—it's JavaScript from the frontend all the way
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: When we type `showdbs`, we will see that the test database is now created. We
    also created a cat collection in the test database by inserting a document into
    it. This is something to be cautious of when working with the shell. It's easy
    to accidentally create unwanted databases and collections with a typo.
  prefs: []
  type: TYPE_NORMAL
- en: Finding documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a database, a collection in that database, and have inserted
    a document into that collection, we need to be able to retrieve the document.
    The most basic way to do that is using the find method of MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `db.collection.find()` method is MongoDB's basic method to read data. It
    is the *R* in MongoDB's CRUD—Create, Read, Update, Delete—operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, MongoDB has added an `_id` field to our object, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've inserted a new orange cat named `Bob` here and, this time, the find method
    we're using is a little different. It's taking two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the query criteria. This tells MongoDB which documents
    to select. In this case, we've used an empty object so all documents are selected.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a projection that limits the amount of data MongoDB returns.
    We told MongoDB that we want the name field, but to suppress the `_id` field,
    which will be returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: In a later chapter, we will explore how to limit the number of documents returned
    and sort them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've adjusted our query to contain query criteria that selects only cats that
    have a color of orange. `Bob` is the only orange cat, so this is the only document
    returned. Again, we will suppress `_id` and tell MongoDB that we only want to
    see the name field.
  prefs: []
  type: TYPE_NORMAL
- en: Updating documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if we want to change a record in our database? There are several methods
    to do this, but we''ll start with the simplest one. MongoDB provides the appropriately
    named update method to modify documents in a database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the find method, the first argument to the update method tells MongoDB
    which documents to select. By default, however, MongoDB will only update one document
    at a time. To update multiple documents, we will add a third argument, a modifier
    object, `{multi:true}`.
  prefs: []
  type: TYPE_NORMAL
- en: We have selected documents where the name field equals `Bob` (there is only
    one). Then, we will use the `$set` operator to change color of `Bob` to purple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that this has worked by querying for `orange` cats using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: No documents are returned. A query for purple `cat` now returns our document
    for a `cat` named `Bob`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No set of CRUD operations is complete without the *D* or Delete operation.
    MongoDB provides the remove method for this, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The remove method has a fairly similar signature to the other MongoDB CRUD methods.
    The first argument, as you may have surmised, is a selector to choose which documents
    MongoDB should be removed.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we removed all documents containing the `purple` value
    for the color property. There was only one, so goodbye poor `Bob`. We verified
    with our call to the find method which now only returns `Tom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default for the remove method is to delete all found documents, so use
    caution. Passing an empty selector will delete all documents in a collection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we have no cats.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB has no built-in rollback functionality, so there's no real way to undo
    such a deletion. In production, this is one reason why replication and regular
    database backups are important.
  prefs: []
  type: TYPE_NORMAL
- en: Create your SPA database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now that we have mucked about with MongoDB a little bit, let's create the
    development database we will use for the SPA we are building.
  prefs: []
  type: TYPE_NORMAL
- en: In a later chapter, we will use a Node.js plugin called *mongoose to model*
    to validate, query, and manipulate our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s just get the database set up. In your mongo shell, type the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, we haven''t actually created the database yet. For that, we will
    need to stick a document into a collection. As we''ll let Mongoose do all of the
    heavy lifting for us later, we''ll just put something in a test collection to
    get started. Let''s consider the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will insert a document into the test collection. We can verify it's
    there with a call to the find method. Finally, we will run `showdbs` and see that
    our `giftapp` database is successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've got most of the pieces of our application stack in place now. We have
    a runtime environment, Node.js. We've installed and set up a web application framework,
    Express. We just set up our database, MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The one piece that's missing is pretty crucial in any SPA—no matter what the
    backend stack looks like, there's a frontend framework to make the SPA magic happen.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous frontend libraries and frameworks used for SPAs, but one
    of the most popular, and the *A* in MEAN, is AngularJS, otherwise known as Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is an open source frontend framework, particularly well-suited to building
    SPA. It's extremely popular and currently maintained by Google.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we will use AngularJS version 1.4.8, which was released in November,
    2015\. AngularJS 2.0 was announced in 2014 and is, at the time of publication,
    just made available in a production version. The 2.0 version introduced breaking
    non-backward-compatible changes. Most development today is done using some version
    on the 1.x branch, and the plan is to continue support for the foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: Installing AngularJS into the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultimately, Angular is a single JavaScript file with some optional plugin files.
    There are a few ways to add Angular to your frontend application. You can download
    the package you're interested in or load it with a tool such as `Bower`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way for us to get started is to simply point to the Angular file
    on a publicly available CDN. We can include Angular 1.4.8 from [https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js](https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our `index.ejs` file and include a script tag linking to the following
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice, when possible, to include script tags linking to external
    JavaScript files right before the closing body tag in HTML. This is done for performance
    reasons. You can find out more and see some examples showcasing the reasoning
    for this at [http://stevesouders.com/hpws/rule-js-bottom.php](http://stevesouders.com/hpws/rule-js-bottom.php).
  prefs: []
  type: TYPE_NORMAL
- en: If you restart the server and load the default page at `localhost:3000`, you
    won't see very much. You are loading AngularJS, but there's no visible effect
    yet. We will build up some example frontend code in layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do after adding the AngularJS script is to change
    the `html` tag to read as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `ng-app` attribute on the head element is what is called an Angular directive.
    When Angular loads in a page, it goes through a bootstrapping phase looking for
    directives such as `ng-app`. This directive tells Angular where the root element
    of the application is.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this attribute as a way of marking out an area of interest
    that Angular will manage. In our case, we'd like to use Angular components on
    the whole page, so we'll declare the HTML element as the root element.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build a module that will become our root application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the first AngularJS module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS was designed to be modular and includes a function to register modules.
    Modules act as containers for other objects, such as Angular services, directives,
    and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules are also injectable. This means that modules can be injected
    into and consumed by other modules. Angular has a unique dependency injection
    system, which we will see shortly and use a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new JavaScript file in the `public/javavscripts` directory of `giftapp`
    called `app.js` and type the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates and registers an Angular module using the `angular.module()`
    function. The first argument to this function is a string that Angular will use
    as the name of the module, `giftAppModule`. The second argument is an array of
    dependencies we wish to inject into this module. For now, we don't have any, so
    the array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the module to the `giftAppModule` variable. This variable name,
    even though it happens to be identical to the module name, is unrelated; we could
    have called it anything else. You don't have to assign a module to a variable
    name, but it's useful as it allows us to more cleanly add assets to the module.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, `giftAppModule.value('appName','GiftApp');`, creates a new service
    on the module by calling the `value` function. A service in Angular is a singleton,
    which is injectable. Angular includes a number of types of services. A value service
    is the simplest type and creates a name value pair that can be injected and used.
    We will use this in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to load our new module and `Bootstrap` it as the root Angular
    application in our `index.ejs` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are two important changes to note here. First, in the HTML element we
    added a reference to the `giftAppModule` we just created by setting it as the
    value of the `ng-app` directive. The next change is that we've added a new `script`
    tag before the closing body tag that loads the `app.js` file that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load order is important here, and Angular must be loaded before `app.js` or
    it will fail. Note the path that we''re using to load `app.js`: `/javascripts/app.js`.
    This works because of piece of code in the Express `app.js` that points requests
    for static files at the public directory, `app.use(express.static(path.join(__dirname,''public'')));`.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server up, if it's stopped, and reloading the page does nothing
    visible at this point. To start making changes to the page, we need to add a controller
    and an Angular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular, a controller is a JavaScript object that exposes data and functionality
    to the view. It does this through Angular's `$scope` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `app.js` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The additional code has created a controller constructor on `giftAppModule`
    called `GreetingController`. This isn't an actual controller until it is invoked
    in the page using the `ng-controller` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to the function is the name of the controller. The second
    argument is an array consisting of the dependencies we wish to inject. The final
    item in the array is the function itself. Angular documentation refers to this
    as array annotation and it is the preferred method of creating constructors.
  prefs: []
  type: TYPE_NORMAL
- en: The module name strings of the first part of the array map to the arguments
    of the function. The order of each must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to add the controller to our `index.ejs html`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will add a `div` tag and give it an `ng-controller` attribute with
    a value of `GreetingController`. When we load this page, Angular will create a
    new `GreetingController` object and attach a child scope to this part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you hit reload on your browser, you will not see anything different.
    Generally, to display data to the user, you will use Angular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data with Angular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular expressions are code snippets that are placed between double curly braces
    (`{{}}`). Angular evaluates these (the JavaScript `eval()` function is not used
    as it's not a safe mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: The Angular documentation refers to expressions as JavaScript as there are some
    pretty major differences. For example, Angular expressions don't have `control
    loops`.
  prefs: []
  type: TYPE_NORMAL
- en: Angular expressions are evaluated within the context of the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the following changes to `index.ejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We've added some Angular expressions inside `div`, where we invoked `GreetingController`.
    Angular makes the `GreetingController` scope object available inside this `div`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you reload this page, under **Welcome to Express**, you should see
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Angular has evaluated the expressions and displayed them as strings. The expressions
    containing greeting and name are pulling those values from the scope. The final
    expression is just doing a little bit of arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main features that Angular provides is called two-way data binding.
    This means that changing data in the view updates the data on the model. Likewise,
    data changed in the model is reflected in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.js` and add the following property to the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We've added a `newName` property and assigned to it the string, `Bob`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to make the following changes to `index.ejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We've made two changes to this file. The first is that we've added the `{{newName}}`
    expression after the arithmetic expression. This renders the `Bob` string to the
    screen. The second change is that we've added a text input control and added the
    `ng-model="newName"` directive. This directive binds the value in the text box
    to the `newName` property on the scope.
  prefs: []
  type: TYPE_NORMAL
- en: When the page loads, the value in the text box is `Bob`. But what happens if
    we type something besides `Bob` in the text box? The value rendered by the expression
    changes nearly instantly.
  prefs: []
  type: TYPE_NORMAL
- en: This is a clear example of what is meant by two-way data binding. Changes to
    the data in the view affect the model seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build a full stack application from database
    to frontend using nothing but JavaScript-based tools. In the previous chapters
    we looked at the MEAN stack components. Now we've started to put them together.
  prefs: []
  type: TYPE_NORMAL
- en: You started by looking at Node.js, our JavaScript-based runtime environment.
    You used the Node.js REPL to execute JavaScript code on the command line. You
    then wrote a script, a small web server, which could be run by Node.js
  prefs: []
  type: TYPE_NORMAL
- en: You learned the two methods to set up an Express application. Additionally,
    you also used the express generator to build out a functioning framework to build
    an application. You learned about routing and middleware—the two key components
    of Express.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is a NoSQL database that stores data as flexible documents in collections
    as opposed to the records/table model of relational databases. You ran each of
    the basic CRUD (Create, Read, Update, Delete) methods in Mongo with insert, find,
    update, and remove.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeply into MongoDB, gaining experience with
    the command-line interface.
  prefs: []
  type: TYPE_NORMAL
