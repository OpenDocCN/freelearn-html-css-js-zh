- en: Chapter 7. Leveraging the MEAN Stack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 利用MEAN堆栈
- en: The MEAN stack is an acronym for MongoDB, Express, AngularJS, and Node.js. It
    represents full stack development using practically nothing but JavaScript alone.
    Naturally, you will need some HTML and CSS to render things to the browser and
    make them look pretty.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN堆栈是MongoDB、Express、AngularJS和Node.js的缩写。它代表仅使用JavaScript进行全栈开发的实践。自然，你需要一些HTML和CSS来将内容渲染到浏览器中，并使其看起来更美观。
- en: MongoDB is a document-based NoSQL database that stores data in ways that can
    be treated like plain JavaScript objects. As the data and database methods are
    essentially JavaScript, MongoDB plays well with JavaScript-based applications.At
    this point, if you typed the code correctly, there will be no output in the console
    other than a new line. Open your favourite browser
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个基于文档的NoSQL数据库，它以可以像普通JavaScript对象一样处理的方式存储数据。由于数据和数据库方法本质上都是JavaScript，MongoDB与基于JavaScript的应用程序配合得很好。此时，如果你正确地输入了代码，控制台将不会有除了新行之外的输出。打开你最喜欢的浏览器
- en: Express is a web application framework, written in JavaScript that runs beautifully
    on Node.js. It's similar to other frameworks, such as Sinatra, but less obtrusive
    and opinionated. Express is essentially routing and middleware that handles web
    requests and responses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个用JavaScript编写的Web应用程序框架，它在Node.js上运行得很好。它与Sinatra等其他框架类似，但更不显眼，也没有太多偏见。Express本质上是一种路由和中间件，用于处理Web请求和响应。
- en: AngularJS is a frontend JavaScript framework that is primarily used to build
    Single Page Web applications. It's a powerful and prescriptive framework curated
    by Google, which has become one of the more popular JavaScript MV* toolkits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是一个主要用于构建单页Web应用程序的前端JavaScript框架。它是由Google精心策划的一个强大且具有指导性的框架，已经成为更受欢迎的JavaScript
    MV*工具包之一。
- en: 'In this chapter, you''ll explore each of the following components of the MEAN
    stack while starting to build the framework of your very own Single Page Application:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将在开始构建你自己的单页应用程序框架的同时，探索以下MEAN堆栈组件：
- en: Running Node.js code from the command line using the REPL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REPL从命令行运行Node.js代码
- en: Writing and running Node.js scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行Node.js脚本
- en: Installing MongoDB and basic CRUD operations from the Mongo shell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mongo shell中安装MongoDB以及基本的CRUD操作
- en: Installing Express via the standard method and the Express generator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过标准方法和Express生成器安装Express
- en: Express routing, middleware, and view rendering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express路由、中间件和视图渲染
- en: Building the basic components of a frontend application with Angular
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular构建前端应用程序的基本组件
- en: The Node.js environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js环境
- en: Node.js is a runtime environment built to execute JavaScript. With it, you can
    build powerful software, such as full-fledged backend web servers. In *[Chapter
    1](ch01.html "Chapter 1. Getting Organized with NPM, Bower, and Grunt")* , *Getting
    Organized with NPM, Bower, and Grunt*, you began to use some Node.js-based tools,
    such as Grunt, NPM, and the Node Package Manager.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个用于执行JavaScript的运行时环境。使用它，你可以构建强大的软件，例如完整的后端Web服务器。在*[第1章](ch01.html
    "第1章 使用NPM、Bower和Grunt进行组织")*，*使用NPM、Bower和Grunt进行组织*中，你开始使用一些基于Node.js的工具，如Grunt、NPM和Node包管理器。
- en: Node.js is powerful, and extremely fast. It is based on the V8 JavaScript engine
    that's used in the Chrome browser and is tuned for speed. It uses a non-blocking
    I/O that allows it to handle many requests simultaneously.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js功能强大，速度极快。它基于Chrome浏览器中使用的V8 JavaScript引擎，并针对速度进行了优化。它使用非阻塞I/O，允许它同时处理多个请求。
- en: This chapter assumes that you have already installed the Node runtime. If not,
    go to [https://nodejs.org](https://nodejs.org), and follow the installation instructions
    for your operating system Node version 4.3.2 has been used in this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经安装了Node运行时。如果没有，请访问[https://nodejs.org](https://nodejs.org)，并按照你操作系统的安装说明进行安装。本书使用了Node版本4.3.2。
- en: Running the REPL
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行REPL
- en: 'Node.js provides a way to enter a run JavaScript code from the command line
    called the Read-Eval-Print Loop or REPL. You can start the REPL simply by typing
    `node` at the command line in a console. It''s a great way to begin exploring
    some of the possibilities with Node.js, as shown in the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js提供了一种从命令行运行JavaScript代码的方法，称为读取-评估-打印循环或REPL。你只需在控制台中命令行输入`node`即可启动REPL。这是一个开始探索Node.js一些可能性的好方法，如下面的命令所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The variable assignment in JavaScript returns undefined.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的变量赋值返回undefined。
- en: Here, it might appear that there are two return values, the first being `3`
    and the second being `undefined`. In this case, `console.log()` is a function
    that is used to write things out to the screen, but the function actually returns
    `undefined`. This will be useful in writing Node.js code where you want to log
    things to the screen, similar to print statements in other programming languages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可能看起来有两个返回值，第一个是`3`，第二个是`undefined`。在这种情况下，`console.log()`是一个用于将内容输出到屏幕上的函数，但实际上它返回`undefined`。这在编写Node.js代码时很有用，你希望将内容输出到屏幕上，类似于其他编程语言中的打印语句。
- en: To quit out of the REPL, hit *Ctrl* + *C* twice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出REPL，按*Ctrl* + *C*两次。
- en: Writing a hello Node.js script
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写hello Node.js脚本
- en: Using the REPL on its own will not be incredibly useful. Node.js allows developers
    to create programs by writing them out and saving them as text files with a `.js`
    file extension.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用REPL本身不会非常有用。Node.js允许开发者通过将程序编写出来并保存为具有`.js`文件扩展名的文本文件来创建程序。
- en: One of the advantages of this is that you can use any text editor and practically
    any IDE to write Node.js programs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中一个优点是，你可以使用任何文本编辑器和几乎任何IDE来编写Node.js程序。
- en: To show you how powerful Node.js can be, let's start by building a simple web
    server. It will not do much, other than handling HTTP requests, but it's a great
    start.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Node.js的强大功能，让我们先构建一个简单的Web服务器。它不会做很多事情，除了处理HTTP请求，但这是一个很好的开始。
- en: 'Let''s create a new file, call it `hello.js`, and open it in your favorite
    text editor or text-based IDE. Then, type the following lines of code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，命名为`hello.js`，并用你喜欢的文本编辑器或基于文本的IDE打开它。然后，输入以下代码行：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file and navigate it to the directory where it is stored with a console
    program. Then, type the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并在控制台中导航到存储该文件的目录。然后，输入以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, if you typed the code correctly, there will be no output in the
    console other than a new line. Open your favorite browser and type `localhost:3000`
    in your address bar.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你正确地输入了代码，控制台将不会有除了新行之外的输出。打开你喜欢的浏览器，并在地址栏中输入`localhost:3000`。
- en: You should see **Hello Node** in your browser's main window. And just like that,
    you have written a web server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在浏览器的主窗口中看到**Hello Node**。就这样，你已经编写了一个Web服务器。
- en: You can stop the server by typing Ctrl + C in the console.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在控制台中输入Ctrl + C来停止服务器。
- en: 'There''s a lot going on in a small piece of code, so let''s walk through what
    the program is doing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么一小段代码中有很多事情在进行，所以让我们来看看程序正在做什么：
- en: In the first line of the `varhttp=require('http');` code, similar to import
    statements in some programming languages, Node.js uses require to import code
    modules. Node.js ships with a number of built-in code modules. The HTTP module
    is a built-in module that provides, as you might assume, HTTP services. Built-in
    modules can be required using a string containing the name of the module. Generally,
    they will be used by assigning them to a variable. Non-built-in modules are required
    using a string containing the full path to the module.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`varhttp=require('http');`代码的第一行中，类似于某些编程语言中的导入语句，Node.js使用`require`来导入代码模块。Node.js自带了许多内置代码模块。HTTP模块是一个内置模块，正如你可能想象的那样，它提供了HTTP服务。可以使用包含模块名称的字符串来导入内置模块。通常，它们会被分配给一个变量来使用。非内置模块则使用包含模块完整路径的字符串来导入。
- en: In the next two lines, `var serverResponse = function(req, res)` and `res.end("Hello
    Node")`, the `serverResponse` function here is a callback function that we will
    pass to the web server we are creating. We will cover the request and response
    objects in more detail when we get into `Express.js`, but it's important to realize
    that we are setting up `req` to deal with the HTTP request object, and `res` to
    deal with the response. The end function on the response object sends whatever
    text is passed to it and tells the server that the response is done.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的两行中，`var serverResponse = function(req, res)`和`res.end("Hello Node")`，这里的`serverResponse`函数是一个回调函数，我们将将其传递给我们所创建的Web服务器。当我们进入`Express.js`时，我们将更详细地介绍请求和响应对象，但重要的是要意识到我们正在设置`req`来处理HTTP请求对象，以及`res`来处理响应。响应对象上的`end`函数发送传递给它的任何文本，并告诉服务器响应已完成。
- en: In the next code line, `varserver=http.createServer(serverResponse);`, we are
    actually creating a web server by invoking the `createServer` function on the
    HTTP object we required earlier. We pass the `serverResponse` function to the
    `createServer` function, which becomes a callback function for the server. We
    will store a reference to the server we just created in the variable called *server*.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一行代码中，`var server = http.createServer(serverResponse);`，我们实际上是通过在之前导入的 HTTP
    对象上调用 `createServer` 函数来创建一个 Web 服务器。我们将 `serverResponse` 函数传递给 `createServer`
    函数，它成为服务器的回调函数。我们将刚刚创建的服务器引用存储在名为 *server* 的变量中。
- en: In the last line of the code, `server.listen(3000);`, we will invoke the `listen`
    function on the server object we just created. We will pass to it an integer representing
    the port number we want it to use to listen to requests. This bit of code actually
    starts up the server, and has it listen to requests on port `3000`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码的最后一行，`server.listen(3000);`，我们将对刚刚创建的服务器对象调用 `listen` 函数。我们将传递一个整数作为端口号，表示我们希望它监听的端口号。这段代码实际上启动了服务器，并使其在端口
    `3000` 上监听请求。
- en: Setting up a Node.js project with NPM
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NPM 设置 Node.js 项目
- en: As Node.js projects become larger, having a tool to mange it properly is important.
    Concerns such as consistent dependency management, version management, and environment
    management are made easier using **Node Package Manager** and the `package.json`
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node.js项目的变大，拥有一个能够正确管理它的工具变得非常重要。使用 **Node Package Manager** 和 `package.json`
    文件，可以更容易地处理诸如一致的依赖管理、版本管理和环境管理等问题。
- en: 'Fortunately, the smart people who created Node.js created a method of doing
    that using NPM. Running `npm init` from the command line will set up a Node.js
    project and build out a `package.json` file, which is used to manage your node
    projects. Let''s try it with your `hello` Node project. Note that some of the
    prompts are optional and can be left blank, as shown in the following commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，创建 Node.js 的聪明人创造了一种使用 NPM 来实现这一目标的方法。在命令行中运行 `npm init` 将会设置一个 Node.js
    项目并构建一个 `package.json` 文件，该文件用于管理你的 Node.js 项目。让我们用你的 `hello` Node 项目来试一试。请注意，一些提示是可选的，可以留空，如下面的命令所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Pressing Enter at this point will create the `package.json` file in the directory
    you''re in. Open it in your IDE or text editor and take a look. While you''re
    in there, let''s make the following small change to the scripts section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此按 Enter 键将会在当前目录中创建 `package.json` 文件。在您的 IDE 或文本编辑器中打开它并查看。当你在里面时，让我们对脚本部分进行以下小的修改：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The scripts section of `package.json` allows you to run code using NPM. In this
    case, typing npm `start` will run the `node hello` command and start your web
    server. It's not a super efficient shortcut at this point, but you can create
    efficient and useful aliases for lots of commands this way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 的脚本部分允许你使用 NPM 运行代码。在这种情况下，输入 npm `start` 将运行 `node hello` 命令并启动你的
    Web 服务器。目前这并不是一个超级高效的快捷方式，但你可以通过这种方式创建许多高效且有用的命令别名。'
- en: One of the very important things that NPM does is manage dependencies. In the
    next section, on Express, you'll see how to store references to NPM modules and
    their versions in the `package.json` file. This is important when working as part
    of a group or team. By taking a copy of a project's `package.json` file, a developer
    can recreate the environment for the project just by running NPM installation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 做的非常重要的一件事是管理依赖。在下一节中，关于 Express，你将看到如何将 NPM 模块及其版本存储在 `package.json` 文件中。当作为团队的一部分工作时，这非常重要。通过复制项目的
    `package.json` 文件，开发者可以通过运行 NPM 安装来重新创建项目环境。
- en: Getting started with Express
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Express
- en: Express describes itself as a fast, unopinionated, minimalist web framework
    for Node.js. Express is a very powerful and flexible framework that operates on
    top of Node.js, but still allows you access to all of the features of Node. At
    its core, Express operates as a set of routing and middleware functionality.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Express 自称为 Node.js 的快速、无偏见、极简主义 Web 框架。Express 是一个非常强大且灵活的框架，它运行在 Node.js 之上，但仍然允许你访问
    Node 的所有功能。在核心上，Express 作为一组路由和中间件功能运行。
- en: We'll get into routing and middleware in detail in later chapters. Basically,
    routing handles web requests. Middleware consists of functions that have access
    to the request and response objects and call the next piece of middleware in the
    stack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中详细讨论路由和中间件。基本上，路由处理 Web 请求。中间件由可以访问请求和响应对象并调用堆栈中下一个中间件的函数组成。
- en: If it's so easy to just throw up a web server using Node,js, why do we need
    something like Express?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Node.js 随意搭建一个 Web 服务器如此简单，为什么我们还需要像 Express 这样的东西呢？
- en: The answer is, you don't. You could, all on your own, build a fully featured
    web application by just writing your own Node.js. Express has done a lot of the
    grunt work and heavy lifting for you. Because of the middleware that's easy to
    plus into Express, adding things such as security, authentication, and routing
    is fairly simple. And, who wants to build that stuff from scratch when you have
    an exciting new web application to build?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，您不需要。您可以完全独立地，仅通过编写自己的 Node.js 代码来构建一个功能齐全的 Web 应用程序。Express 已经为您做了很多艰苦的工作和重活。由于
    Express 中间件易于添加，添加诸如安全、身份验证和路由等功能相对简单。而且，当您有一个令人兴奋的新 Web 应用程序要构建时，谁愿意从头开始构建这些功能呢？
- en: Installing Express
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Express
- en: Of course, you will use NPM to install Express. There are two ways to do this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您会使用 NPM 来安装 Express。这里有两种方法可以做到这一点。
- en: The standard method is just to use NPM to pull the Express project down and
    add a reference to it in `package.json`. This is just adding the module into a
    Node.js project. You will build an application script, require it in Express,
    and utilize it in that WAR file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方法只是使用 NPM 拉取 Express 项目并将其添加到 `package.json` 中的引用。这只是将模块添加到 Node.js 项目中。您将构建一个应用程序脚本，在
    Express 中调用它，并在那个 WAR 文件中利用它。
- en: The second method is to install the Express generator and use it to generate
    a starter web application. This method is simple to employ but it does structure
    your whole application, including folder structure, for you. Some people would
    prefer to do all of this on their own to get their setup precisely a certain way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是安装 Express 生成器，并使用它来生成一个入门级 Web 应用程序。这种方法简单易行，但它会为您构建整个应用程序的结构，包括文件夹结构。有些人可能更喜欢自己完成所有这些工作，以确保设置方式精确无误。
- en: We will try both methods, and use the Express generator to build the framework
    for the Single Page Application that you will build throughout the rest of this
    book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试两种方法，并使用 Express 生成器来构建您将在本书剩余部分构建的单页应用程序的框架。
- en: Standard method
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准方法
- en: 'Again, the standard method will just be to pull the module down and add it
    to your project. In your console, in the directory with the `package.json` file
    we just created, type the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，标准方法只是将模块拉下来并添加到您的项目中。在您的控制台中，在刚刚创建的 `package.json` 文件所在的目录中，输入以下命令：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: On a Mac, you may have to type `sudo` before `npm instal`l. If you're on a Mac,
    I would just go ahead and use `sudo` each type you are installing something with
    NPM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，您可能需要在 `npm install` 前面输入 `sudo`。如果您在 Mac 上，我建议您在每次使用 NPM 安装任何东西时都使用
    `sudo`。
- en: The `-save` part tells npm to add Express as a dependency to your `package.json`
    file. Go ahead and open your `package.json` file and look at the dependencies
    section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`-save` 部分告诉 npm 将 Express 添加到您的 `package.json` 文件中的依赖项。现在，请打开您的 `package.json`
    文件并查看依赖项部分。'
- en: If you are using `git` or another source control system to share a code base
    with other developers, you, typically, will not store the dependencies in the
    remote repository. Instead, the `package.json` file will hold a reference to the
    required modules and their version.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 `git` 或其他源代码控制系统与其他开发者共享代码库，您通常不会在远程仓库中存储依赖项。相反，`package.json` 文件将包含对所需模块及其版本的引用。
- en: Another developer can pull down your code, run `npm install`, and install all
    of the dependencies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位开发者可以拉取您的代码，运行 `npm install`，并安装所有依赖项。
- en: If you look in the folder where your `package.json` file resides, you will see
    a new folder called `node_modules`. This is where all of your dependencies installed
    with `npm` are stored. It's important not to move this or change it as the require
    function will look in here for modules. Typically, this folder will be added to
    a .`gitignore` file to ensure that its files aren't stored on a remote `git` repository.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `package.json` 文件所在的文件夹，您将看到一个名为 `node_modules` 的新文件夹。这是您使用 `npm` 安装的依赖项存储的地方。不要移动这个文件夹或更改它，因为
    require 函数会在这里查找模块。通常，这个文件夹会被添加到 `.gitignore` 文件中，以确保其文件不会存储在远程 `git` 仓库中。
- en: Express generator
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达生成器
- en: There is another method of setting up an Express application. Express has created
    a generator that is a tool for rapidly setting up the framework for an Express
    application. It assumes some common conventions used in Express applications and
    configures things such as the main application, the `package,json`, and even the
    directory structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设置Express应用程序的方法是，Express创建了一个生成器，这是一个用于快速搭建Express应用程序框架的工具。它假设了一些在Express应用程序中常用的约定，并配置了主应用程序、`package.json`以及甚至目录结构。
- en: 'The generator is installed globally rather than in a specific project using
    the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是通过以下命令全局安装的，而不是在特定项目中使用：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `-g` tells NPM to install the module and its dependencies globally. They
    won't be installed in the `npm_modules` folder in your project, but in a global
    modules folder on your system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`告诉NPM全局安装模块及其依赖项。它们不会安装在你项目的`npm_modules`文件夹中，而是在系统上的全局模块文件夹中。'
- en: Setting up your Express application
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的Express应用程序
- en: Now that we have the express generator installed globally, let's use it to start
    building the application we'll be building out in the rest of the book. Pick a
    folder where you want this project to live. The Express generator will create
    a new folder inside this folder, so it's fine if it is a home or projects folder
    containing other things.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全局安装了express生成器，让我们使用它来开始构建本书其余部分将要构建的应用程序。选择一个你希望这个项目存在的文件夹。Express生成器将在这个文件夹内创建一个新的文件夹，所以如果你是一个包含其他内容的家庭或项目文件夹，那也是可以的。
- en: 'Navigate to this folder in your console using the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在你的控制台中导航到这个文件夹：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the express generator has created a number of files including
    `app,js`, your main app file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，express生成器创建了一些文件，包括`app.js`，这是你的主应用程序文件。
- en: The `-e` modifier we typed after the express command told the generator that
    we want to use `ejs` (embedded JavaScript) frontend templates. Express supports
    a number of templating languages, including Handlebars and Jade. If you add no
    modifier, the Express generator will assume you want to use Jade. For this project,
    we will use `ejs`, which is essentially real HTML with embedded JavaScript code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在express命令后输入的`-e`修饰符告诉生成器我们想要使用`ejs`（嵌入式JavaScript）前端模板。Express支持多种模板语言，包括Handlebars和Jade。如果你没有添加任何修饰符，Express生成器将假设你想要使用Jade。对于这个项目，我们将使用`ejs`，它本质上是一种嵌入JavaScript代码的HTML。
- en: The final output of the generator tells you the next steps you need to actually
    stand up your application. Navigate to your new `giftapp` directory and run `npm
    install` (remember `sudo` if you're on a Mac or Linux box). The `npm install`
    command at this point might take a few minutes as it's installing a number of
    dependencies.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的最终输出会告诉你下一步你需要执行的操作，以便真正搭建你的应用程序。导航到你的新`giftapp`目录并运行`npm install`（如果你在Mac或Linux机器上，请记住使用`sudo`）。此时，`npm
    install`命令可能需要几分钟，因为它正在安装多个依赖项。
- en: The next command starts your new Express application in `DEBUG` mode—you will
    see all requests logged to the console. Navigating to `localhost:3000` in your
    browser will display a **Welcome to Express** page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将以`DEBUG`模式启动你的新Express应用程序——你将看到所有请求都记录在控制台。在浏览器中导航到`localhost:3000`将显示一个**欢迎使用Express**页面。
- en: Congratulations, this page is being served from your very own robust Express
    web application. It's not doing much yet, but a lot of pieces are already in place
    for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，这个页面正在由你自己的强大Express Web应用程序提供服务。目前它还没有做什么，但已经为你搭建了很多基础。
- en: Exploring the main script
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索主脚本
- en: 'Open giftapp''s new `package.json` file. Note the following scripts object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开giftapp的新`package.json`文件。注意以下scripts对象：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is saying that when the `npm` start is run, the script that's actually
    invoked is at `./bin/www`. So, let's open the `www` file in your bin directory
    and take a look.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当运行`npm start`时，实际调用的脚本位于`./bin/www`。所以，让我们打开你bin目录下的`www`文件并查看。
- en: 'You''ll see that this file is requiring a number of things, including `app.js`;
    this is your main application file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个文件正在引入许多东西，包括`app.js`；这是你的主应用程序文件：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next bit of code set''s the port number of the app. It looks to see if
    there''s an environment variable set containing the desired port number. If not,
    it sets it to `3000`. When deploying an application to production, typically,
    you will use `port 80` for HTTP or `port 443` for HTTPS:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码设置了应用程序的端口号。它检查是否有设置包含所需端口号的环境变量。如果没有，它将其设置为`3000`。在生产环境中部署应用程序时，通常你会使用`端口80`用于HTTP或`端口443`用于HTTPS：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next bit creates the server and starts listening on the correct port:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分创建服务器并开始监听正确的端口：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For now, we'll skip over the rest of this file and take a look at what's in
    the `app.js` file. Go ahead and open it up.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将跳过这个文件的其余部分，看看 `app.js` 文件中有什么。打开它看看。
- en: Looking at the main application
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看主应用
- en: '`App.js` is the main application file that loads the routes and middleware
    and configures the application. There are a number of important sections of this
    file. In general, in Express applications, the order of loading and utilization,
    and the order middleware is invoked in this file, is important. Let''s take a
    look.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js` 是主应用文件，它加载路由和中间件并配置应用。这个文件中有几个重要的部分。一般来说，在 Express 应用中，加载和利用的顺序以及在这个文件中中间件被调用的顺序是很重要的。让我们来看看。'
- en: Loading dependencies
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载依赖
- en: 'When you open `app.js`, you will first encounter a number of calls to the require
    function, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 `app.js` 时，你首先会遇到对 require 函数的多次调用，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This system is known as `CommonJS`. The first set of modules includes the dependencies,
    such as Express, and a parser for cookies. The routes and users modules were created
    by the Express generator for routing. The routes you create will be required in
    the main file as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统被称为 `CommonJS`。第一组模块包括依赖项，如 Express 和 cookies 解析器。路由和用户模块是由 Express 生成器为路由创建的。你创建的路由也将需要在主文件中导入。
- en: Configuring the application
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用
- en: 'Next, an `app` variable is declared by invoking the express function, and a
    couple of configuration variables are set, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过调用 express 函数声明了一个 `app` 变量，并设置了一些配置变量，如下所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first configuration, views, tells Express where to look for the view templates.
    These are the templates that are normally rendered into HTML as the result of
    requests to the web application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项配置，视图，告诉 Express 在哪里查找视图模板。这些模板通常在向网络应用发送请求时渲染成 HTML。
- en: The second configuration sets the view engine. As we discussed earlier, we will
    use `ejs` or embedded JavaScript templates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项配置设置了视图引擎。正如我们之前讨论的，我们将使用 `ejs` 或嵌入式 JavaScript 模板。
- en: Application-level middleware
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用级别中间件
- en: 'The next thing we will see in this file is a bunch of calls to the app object''s
    `use` function, which is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中接下来我们看到的是对 app 对象的 `use` 函数的一堆调用，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Express, calls to the application object's use function are application-level
    middleware. Requests sent to the application will execute every function matching
    the path set in `app.use`. If no path is set, the middleware function defaults
    to the root path `/`and will be invoked for every request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，对应用对象 use 函数的调用是应用级别的中间件。发送到应用的请求将执行与 `app.use` 中设置的路径匹配的每个函数。如果没有设置路径，中间件函数默认为根路径
    `/`，并将对每个请求进行调用。
- en: For example, `app.use(cookieParser());` means that the `cookieParser` function
    will be invoked for every request sent to the application because it defaults
    to the root path. However, `app.use('/users',users);` will only apply when the
    request begins with `/users`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`app.use(cookieParser());` 表示对于发送到应用的每个请求，都会调用 `cookieParser` 函数，因为它默认为根路径。然而，`app.use('/users',users);`
    只会在请求以 `/users` 开头时应用。
- en: Middleware is invoked in the order it's declared. This will become very clear
    later, when we add authentication to our application, or want to handle `POST`
    data. If you don't parse cookies before you try to manage a request requiring
    authentication, it won't work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的调用顺序与声明顺序一致。这将在我们添加身份验证到我们的应用或想要处理 `POST` 数据时变得非常清楚。如果你在尝试管理需要身份验证的请求之前不解析
    cookies，它将不起作用。
- en: Our first Express route
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一条 Express 路由
- en: 'Express uses a mechanism called routing, using its `Router` object, to handle
    HTTP requests, such as those from web browsers. In a later chapter, we will take
    a more in-depth look at Express routing. It bears examining the first route that
    the Express generator created for us. Open your `routes/index.js` file, as shown
    in the following code block:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Express 使用一个称为路由的机制，通过其 `Router` 对象来处理 HTTP 请求，例如来自网络浏览器的请求。在后面的章节中，我们将更深入地探讨
    Express 路由。检查 Express 生成器为我们创建的第一个路由是很有必要的。打开你的 `routes/index.js` 文件，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To create a new set of routes, we must create a new router object by invoking
    the `Expresses Router` function. You will see that we require Express first, then
    do exactly that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一组新的路由，我们必须通过调用 `Express Router` 函数创建一个新的路由器对象。你会看到我们首先需要 Express，然后做完全一样的事情。
- en: The next expression is a call to the router object's get function. This, in
    Express, is router-level middleware. This function sets up middleware, in the
    form of the enclosed anonymous function, which responds to HTTP `GET` requests,
    such as typing a URL in a browser's address bar or clicking on a link.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表达式是对路由对象get函数的调用。在Express中，这是路由级别的中间件。这个函数设置中间件，形式为包含的匿名函数，它响应HTTP `GET`请求，例如在浏览器地址栏中输入URL或点击链接。
- en: The first argument to the function is a path to match. When the path matches,
    in this case the root path, the function is invoked. The anonymous function here
    receives the request object, the response object, and the next object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一个参数是要匹配的路径。当路径匹配时，在这种情况下是根路径，函数被调用。这里的匿名函数接收请求对象、响应对象和下一个对象。
- en: The function invokes the response object's render function. This function looks
    in the views directory for a template called index and renders it, passing it
    the object in the second argument. The template has access to all the properties
    of that object, in this case, just the title, and can render them to in the response.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用响应对象的render函数。这个函数在views目录中查找名为index的模板并渲染它，传递第二个参数中的对象。模板可以访问该对象的所有属性，在这种情况下，只是标题，并将它们渲染到响应中。
- en: Finally, we will see the `module.exports=router;` expression. This allows the
    Node.js module system to load this code using the required function and assign
    the router object to a variable. Near the top of our `app.js` file, you'll see
    `varroutes=require('./routes/index');`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到`module.exports=router;`表达式。这允许Node.js模块系统使用required函数加载此代码，并将路由对象分配给一个变量。在我们的`app.js`文件顶部附近，你会看到`var
    routes = require('./routes/index');`。
- en: Rendering the first view
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染第一个视图
- en: When you started the Express server, navigated to `localhost:3000`, and saw
    the default Express page, what happened?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Express服务器，导航到`localhost:3000`，并看到默认的Express页面时，发生了什么？
- en: The request came into the web application and was routed to index based on the
    request type, `GET`, and the path, `/`. The middleware then called the response
    object's render function and told it to get the index template, passing it an
    object with a property called title.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请求进入Web应用程序，根据请求类型`GET`和路径`/`被路由到index。然后中间件调用响应对象的render函数，并告诉它获取index模板，传递一个具有名为title的属性的对象。
- en: 'Open your `views/ index.ejs` file to see the following template code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`views/index.ejs`文件，查看以下模板代码：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you've used other dynamic templating languages before, you probably already
    understand that this is normal HTML that contains some dynamic elements. Those
    dynamic elements that are contained by `<%...%>` are processed by the server.
    These *tags* are not sent to the browser, just clean HTML.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过其他动态模板语言，你可能已经理解这很正常，这是包含一些动态元素的普通HTML。那些被`<%...%>`包含的动态元素由服务器处理。这些*标签*不会发送到浏览器，只是干净的HTML。
- en: In this case, the three tags are identical, all rendering the title property
    of the object passed in the call to the response object's render method. As a
    quick experiment, change the value of the title passed in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，三个标签是相同的，都渲染了传递给响应对象render方法的调用中的对象的标题属性。作为一个快速实验，改变传递的标题值。
- en: Exploring MongoDB
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索MongoDB
- en: Remember that the *M* in the MEAN stack, is an open source document-based database.
    It's considered a NoSQL database because it doesn't use SQL and is not relational.
    It integrates well with JavaScript-based tools because, instead of tables, it
    stores data in documents that can be treated by our Node.js application as JSON.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，MEAN栈中的*M*是一个开源的文档型数据库。因为它不使用SQL且不是关系型数据库，所以被认为是一个NoSQL数据库。它很好地与基于JavaScript的工具集成，因为它不是存储在表中，而是存储在文档中，这些文档可以被我们的Node.js应用程序当作JSON处理。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, MongoDB stores data in a format called BSON, short for Binary JSON.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，MongoDB以BSON格式存储数据，BSON是Binary JSON的缩写。
- en: Setting up MongoDB
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置MongoDB
- en: The first step in getting MongoDB running on your system is installation. Head
    over to [https://www.mongodb.org/downloads#production](https://www.mongodb.org/downloads#production),
    and you will find the most updated installation download for Windows, Mac, Linux,
    or Solaris. There are also links to instructions there to install MongoDB with
    tools such as Homebrew for Mac and yum for Linux.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统上运行MongoDB的第一步是安装。访问[https://www.mongodb.org/downloads#production](https://www.mongodb.org/downloads#production)，你将找到Windows、Mac、Linux或Solaris的最新安装下载。那里也有链接到使用Homebrew（Mac）和yum（Linux）等工具安装MongoDB的说明。
- en: Up-to-date installation instructions for each operating system can be found
    at [https://docs.mongodb.org/manual/](https://docs.mongodb.org/manual/). There
    are differences between the operating systems, and installation instructions may
    change with newer versions. I suggest following the official installation instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的最新安装说明可以在 [https://docs.mongodb.org/manual/](https://docs.mongodb.org/manual/)
    找到。操作系统之间存在差异，安装说明可能会随着新版本的发布而更改。我建议遵循官方的安装说明。
- en: Once installed, you can start the MongoDB service by typing `mongod` in a console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以在控制台中输入 `mongod` 来启动 MongoDB 服务。
- en: You will not be able to type any other commands in that console while the MongoDB
    daemon is running. By default, this process will run on `port 27017` and bind
    to the IP address, `127.0.0.1`. Both of these can be changed with command flags
    at start up, or with a `.conf` file. For our purposes, the defaults will do.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MongoDB 守护进程运行时，你将无法在该控制台中输入任何其他命令。默认情况下，此进程将在 `端口 27017` 上运行并绑定到 IP 地址 `127.0.0.1`。这两个都可以通过启动时的命令标志或
    `.conf` 文件进行更改。就我们的目的而言，默认设置就足够了。
- en: Working with the MongoDB shell
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MongoDB 命令行界面
- en: We'll begin to work with MongoDB with the command-line shell included with the
    Mongo installation. As you must have the MongoDB daemon running to work with the
    database, you'll need to open a new console.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用随 MongoDB 安装一起提供的命令行界面来处理 MongoDB。由于你必须运行 MongoDB 守护进程才能与数据库一起工作，因此你需要打开一个新的控制台。
- en: In the application we are building, we will rely on Node.js plugins to handle
    our database operations. It is beneficial, however, to gain an understanding of
    how MongoDB works and how it differs from SQL databases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在构建的应用程序中，我们将依赖 Node.js 插件来处理我们的数据库操作。然而，了解 MongoDB 的工作原理以及它与 SQL 数据库的不同之处是有益的。
- en: The best way to do that is to get our hands dirty and run some basic operations
    from the command line of MongoDB's shell.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，最好的方式是亲自动手，从 MongoDB 命令行界面运行一些基本操作。
- en: Selecting a database
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择数据库
- en: 'Let''s select the database that we want to work with. Open your command line
    and enter the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择我们想要工作的数据库。打开你的命令行并输入以下命令：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running `mongo`, as opposed to `mongod`, from the command line starts the MongoDB
    shell, which allows typing commands directly to the running MongoDB daemon.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行 `mongo` 而不是 `mongod` 将启动 MongoDB 命令行界面，这允许直接向运行的 MongoDB 守护进程输入命令。
- en: 'The `use` command selects which database we are currently using. But, wait
    a minute; we never created a test database. That''s correct, and we still haven''t.
    We can use the `showdbs` command to list all of the databases on our computer
    that MongoDB knows about:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 命令用于选择我们当前正在使用的数据库。但是，等等；我们从未创建过测试数据库。这是正确的，我们确实还没有创建。我们可以使用 `showdbs`
    命令列出我们计算机上 MongoDB 所知的所有数据库：'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you've done all the previous examples, you would already have created a local
    database name `test`. Local stores a `startup` log and replica information in
    replicated environments. We can use local and add our own data to it, but that's
    not really a great idea. Let's create a database of our own.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了所有前面的示例，那么你已经有了一个名为 `test` 的本地数据库。本地数据库存储启动日志和复制环境中的副本信息。我们可以使用本地数据库并添加我们自己的数据，但这并不是一个好主意。让我们创建一个我们自己的数据库。
- en: Inserting documents
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入文档
- en: Remember that records in MongoDB are referred to as documents. They loosely
    relate to rows in a traditional relation database but are much more flexible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，MongoDB 中的记录被称为文档。它们与传统关系型数据库中的行有松散的联系，但更加灵活。
- en: 'If we insert a document now, the new database will be created use the following
    commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在插入一个文档，新数据库将使用以下命令创建：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `db.cat.insert()`command adds the document in the argument to insert to
    a collection called cat.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.cat.insert()` 命令将插入参数中的文档到名为 cat 的集合中。'
- en: In MongoDB, a collection is a set of documents. This is similar to a table in
    a relational database, which is a set of records. Unlike relational databases,
    the documents in a collection do not have to all be the same type or have the
    same set of data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，集合是一组文档。这类似于关系型数据库中的表，它是一组记录。与关系型数据库不同，集合中的文档不必都是同一类型或具有相同的数据集。
- en: You may get notices that the document we inserted looks like a plain old JavaScript
    object. Essentially, it is. This is one of the nice things about working with
    MongoDB as part of the MEAN stack—it's JavaScript from the frontend all the way
    to the database.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会收到通知，我们插入的文档看起来像是一个普通的 JavaScript 对象。本质上，它就是这样。这是在 MEAN 栈中将 MongoDB 作为一部分使用时的一个优点——从前端到数据库都是
    JavaScript。
- en: When we type `showdbs`, we will see that the test database is now created. We
    also created a cat collection in the test database by inserting a document into
    it. This is something to be cautious of when working with the shell. It's easy
    to accidentally create unwanted databases and collections with a typo.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入 `showdbs` 时，我们将看到测试数据库现在已经创建。我们还通过向其中插入文档在测试数据库中创建了一个猫集合。当使用 shell 工作时，这需要小心。很容易因为打字错误而意外创建不需要的数据库和集合。
- en: Finding documents
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找文档
- en: Now that we have a database, a collection in that database, and have inserted
    a document into that collection, we need to be able to retrieve the document.
    The most basic way to do that is using the find method of MongoDB.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个数据库，数据库中的一个集合，并且已经将一个文档插入到该集合中，我们需要能够检索该文档。最基本的方法是使用 MongoDB 的查找方法。
- en: 'Let''s take a look at our document:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的文档：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `db.collection.find()` method is MongoDB's basic method to read data. It
    is the *R* in MongoDB's CRUD—Create, Read, Update, Delete—operations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.collection.find()` 方法是 MongoDB 读取数据的基本方法。它是 MongoDB CRUD 操作中的 *R*——创建、读取、更新、删除。'
- en: 'As you can see, MongoDB has added an `_id` field to our object, which is as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，MongoDB 已经为我们添加了一个 `_id` 字段，如下所示：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've inserted a new orange cat named `Bob` here and, this time, the find method
    we're using is a little different. It's taking two arguments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里插入了一只名叫 `Bob` 的新橘猫，这次我们使用的是一种稍微不同的查找方法。它接受两个参数。
- en: The first argument is the query criteria. This tells MongoDB which documents
    to select. In this case, we've used an empty object so all documents are selected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是查询条件。这告诉 MongoDB 选择哪些文档。在这种情况下，我们使用了一个空对象，因此选择了所有文档。
- en: The second argument is a projection that limits the amount of data MongoDB returns.
    We told MongoDB that we want the name field, but to suppress the `_id` field,
    which will be returned by default.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是投影，它限制了 MongoDB 返回的数据量。我们告诉 MongoDB 我们想要名称字段，但抑制默认会返回的 `_id` 字段。
- en: In a later chapter, we will explore how to limit the number of documents returned
    and sort them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何限制返回的文档数量并对其进行排序。
- en: 'Take a look at following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下命令：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've adjusted our query to contain query criteria that selects only cats that
    have a color of orange. `Bob` is the only orange cat, so this is the only document
    returned. Again, we will suppress `_id` and tell MongoDB that we only want to
    see the name field.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经调整了查询，使其包含查询条件，仅选择颜色为橘色的猫。`Bob` 是唯一的橘猫，因此这是唯一返回的文档。同样，我们将抑制 `_id` 并告诉 MongoDB
    我们只想看到名称字段。
- en: Updating documents
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'What if we want to change a record in our database? There are several methods
    to do this, but we''ll start with the simplest one. MongoDB provides the appropriately
    named update method to modify documents in a database, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更改数据库中的记录怎么办？有几种方法可以做到这一点，但我们将从最简单的一种开始。MongoDB 提供了一个名为 update 的方法来修改数据库中的文档，如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similar to the find method, the first argument to the update method tells MongoDB
    which documents to select. By default, however, MongoDB will only update one document
    at a time. To update multiple documents, we will add a third argument, a modifier
    object, `{multi:true}`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与查找方法类似，更新方法的第一个参数告诉 MongoDB 选择哪些文档。然而，默认情况下，MongoDB 将一次只更新一个文档。要更新多个文档，我们将添加第三个参数，一个修饰符对象，`{multi:true}`。
- en: We have selected documents where the name field equals `Bob` (there is only
    one). Then, we will use the `$set` operator to change color of `Bob` to purple.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了名称字段等于 `Bob`（只有一个）的文档。然后，我们将使用 `$set` 操作符将 `Bob` 的颜色改为紫色。
- en: 'We can verify that this has worked by querying for `orange` cats using the
    following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下命令查询 `orange` 猫来验证这一点：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: No documents are returned. A query for purple `cat` now returns our document
    for a `cat` named `Bob`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文档返回。现在对紫色 `cat` 的查询返回了名为 `Bob` 的 `cat` 文档。
- en: Removing documents
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文档
- en: 'No set of CRUD operations is complete without the *D* or Delete operation.
    MongoDB provides the remove method for this, which is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一组 CRUD 操作是完整的，没有 *D* 或删除操作。MongoDB 提供了 remove 方法来实现这一点，如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The remove method has a fairly similar signature to the other MongoDB CRUD methods.
    The first argument, as you may have surmised, is a selector to choose which documents
    MongoDB should be removed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: remove方法具有与其他MongoDB CRUD方法相当类似的签名。第一个参数，正如你可能推测的那样，是一个选择器，用于选择MongoDB应该移除哪些文档。
- en: In the preceding example, we removed all documents containing the `purple` value
    for the color property. There was only one, so goodbye poor `Bob`. We verified
    with our call to the find method which now only returns `Tom`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们移除了所有包含颜色属性`purple`值的文档。只有一个，所以再见了可怜的`Bob`。我们通过调用find方法进行了验证，现在它只返回`Tom`。
- en: 'The default for the remove method is to delete all found documents, so use
    caution. Passing an empty selector will delete all documents in a collection,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: remove方法的默认操作是删除所有找到的文档，所以请谨慎使用。传递一个空的选择器将删除集合中的所有文档，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And with that, we have no cats.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们没有了猫。
- en: MongoDB has no built-in rollback functionality, so there's no real way to undo
    such a deletion. In production, this is one reason why replication and regular
    database backups are important.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB没有内置的回滚功能，所以没有真正的方法可以撤销这样的删除。在生产环境中，这是为什么复制和定期数据库备份很重要的原因之一。
- en: Create your SPA database
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的SPA数据库
- en: So, now that we have mucked about with MongoDB a little bit, let's create the
    development database we will use for the SPA we are building.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经对MongoDB进行了一些操作，让我们创建我们将用于构建SPA的开发数据库。
- en: In a later chapter, we will use a Node.js plugin called *mongoose to model*
    to validate, query, and manipulate our data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将使用一个名为*mongoose to model*的Node.js插件来验证、查询和操作我们的数据。
- en: 'For now, let''s just get the database set up. In your mongo shell, type the
    following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只设置数据库。在你的mongo shell中，输入以下命令：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remember, we haven''t actually created the database yet. For that, we will
    need to stick a document into a collection. As we''ll let Mongoose do all of the
    heavy lifting for us later, we''ll just put something in a test collection to
    get started. Let''s consider the following code as an example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们实际上还没有创建数据库。为此，我们需要将一个文档放入一个集合中。由于我们将在以后让Mongoose为我们做所有繁重的工作，我们将先在测试集合中放入一些内容以开始。以下代码作为示例：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we will insert a document into the test collection. We can verify it's
    there with a call to the find method. Finally, we will run `showdbs` and see that
    our `giftapp` database is successfully created.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将向测试集合中插入一个文档。我们可以通过调用find方法来验证它是否在那里。最后，我们将运行`showdbs`并查看我们的`giftapp`数据库是否成功创建。
- en: Starting with AngularJS
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AngularJS开始
- en: We've got most of the pieces of our application stack in place now. We have
    a runtime environment, Node.js. We've installed and set up a web application framework,
    Express. We just set up our database, MongoDB.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将应用堆栈的大部分组件放在一起了。我们有一个运行时环境，Node.js。我们已经安装并设置了Web应用框架Express。我们刚刚设置了数据库，MongoDB。
- en: The one piece that's missing is pretty crucial in any SPA—no matter what the
    backend stack looks like, there's a frontend framework to make the SPA magic happen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何SPA中缺失的一个关键部分是——无论后端堆栈看起来如何，都有一个前端框架来使SPA魔法发生。
- en: There are numerous frontend libraries and frameworks used for SPAs, but one
    of the most popular, and the *A* in MEAN, is AngularJS, otherwise known as Angular.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于SPAs的前端库和框架，但最受欢迎的，也是MEAN中的*A*，是AngularJS，也称为Angular。
- en: Angular is an open source frontend framework, particularly well-suited to building
    SPA. It's extremely popular and currently maintained by Google.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个开源的前端框架，特别适合构建SPA。它非常受欢迎，目前由Google维护。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will use AngularJS version 1.4.8, which was released in November,
    2015\. AngularJS 2.0 was announced in 2014 and is, at the time of publication,
    just made available in a production version. The 2.0 version introduced breaking
    non-backward-compatible changes. Most development today is done using some version
    on the 1.x branch, and the plan is to continue support for the foreseeable future.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用AngularJS版本1.4.8，该版本于2015年11月发布。AngularJS 2.0于2014年宣布，在出版时，刚刚推出了生产版本。2.0版本引入了破坏性的非向后兼容更改。今天的大多数开发都是使用1.x分支上的某个版本进行的，计划在未来继续支持。
- en: Installing AngularJS into the application
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将AngularJS安装到应用中
- en: Ultimately, Angular is a single JavaScript file with some optional plugin files.
    There are a few ways to add Angular to your frontend application. You can download
    the package you're interested in or load it with a tool such as `Bower`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way for us to get started is to simply point to the Angular file
    on a publicly available CDN. We can include Angular 1.4.8 from [https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js](https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our `index.ejs` file and include a script tag linking to the following
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice, when possible, to include script tags linking to external
    JavaScript files right before the closing body tag in HTML. This is done for performance
    reasons. You can find out more and see some examples showcasing the reasoning
    for this at [http://stevesouders.com/hpws/rule-js-bottom.php](http://stevesouders.com/hpws/rule-js-bottom.php).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you restart the server and load the default page at `localhost:3000`, you
    won't see very much. You are loading AngularJS, but there's no visible effect
    yet. We will build up some example frontend code in layers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do after adding the AngularJS script is to change
    the `html` tag to read as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `ng-app` attribute on the head element is what is called an Angular directive.
    When Angular loads in a page, it goes through a bootstrapping phase looking for
    directives such as `ng-app`. This directive tells Angular where the root element
    of the application is.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this attribute as a way of marking out an area of interest
    that Angular will manage. In our case, we'd like to use Angular components on
    the whole page, so we'll declare the HTML element as the root element.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build a module that will become our root application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Building the first AngularJS module
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS was designed to be modular and includes a function to register modules.
    Modules act as containers for other objects, such as Angular services, directives,
    and controllers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules are also injectable. This means that modules can be injected
    into and consumed by other modules. Angular has a unique dependency injection
    system, which we will see shortly and use a lot.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new JavaScript file in the `public/javavscripts` directory of `giftapp`
    called `app.js` and type the following code into it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line creates and registers an Angular module using the `angular.module()`
    function. The first argument to this function is a string that Angular will use
    as the name of the module, `giftAppModule`. The second argument is an array of
    dependencies we wish to inject into this module. For now, we don't have any, so
    the array is empty.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the module to the `giftAppModule` variable. This variable name,
    even though it happens to be identical to the module name, is unrelated; we could
    have called it anything else. You don't have to assign a module to a variable
    name, but it's useful as it allows us to more cleanly add assets to the module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将模块分配给`giftAppModule`变量。尽管这个变量名恰好与模块名相同，但它是不相关的；我们可以将其命名为任何其他名称。你不必将模块分配给一个变量名，但这样做很有用，因为它允许我们更干净地添加资产到模块中。
- en: The next line, `giftAppModule.value('appName','GiftApp');`, creates a new service
    on the module by calling the `value` function. A service in Angular is a singleton,
    which is injectable. Angular includes a number of types of services. A value service
    is the simplest type and creates a name value pair that can be injected and used.
    We will use this in our controller.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，`giftAppModule.value('appName','GiftApp');`通过调用`value`函数在模块上创建了一个新的服务。Angular中的服务是一个单例，它可以被注入。Angular包含多种类型的服务。值服务是最简单的一种，它创建一个可以被注入和使用的名称值对。我们将在我们的控制器中使用它。
- en: Finally, we want to load our new module and `Bootstrap` it as the root Angular
    application in our `index.ejs` template.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在`index.ejs`模板中将我们的新模块加载并作为根Angular应用程序`Bootstrap`。
- en: 'Take a look at the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are two important changes to note here. First, in the HTML element we
    added a reference to the `giftAppModule` we just created by setting it as the
    value of the `ng-app` directive. The next change is that we've added a new `script`
    tag before the closing body tag that loads the `app.js` file that we just created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的更改需要注意。首先，在HTML元素中，我们通过将`ng-app`指令的值设置为`giftAppModule`来添加了对我们刚刚创建的`giftAppModule`的引用。下一个更改是在关闭`body`标签之前添加了一个新的`script`标签，该标签加载了我们刚刚创建的`app.js`文件。
- en: 'Load order is important here, and Angular must be loaded before `app.js` or
    it will fail. Note the path that we''re using to load `app.js`: `/javascripts/app.js`.
    This works because of piece of code in the Express `app.js` that points requests
    for static files at the public directory, `app.use(express.static(path.join(__dirname,''public'')));`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 加载顺序在这里很重要，Angular必须在`app.js`之前加载，否则会失败。注意我们用来加载`app.js`的路径：`/javascripts/app.js`。这之所以有效，是因为Express
    `app.js`中的一段代码将静态文件请求指向公共目录，`app.use(express.static(path.join(__dirname,'public')));`。
- en: Starting the server up, if it's stopped, and reloading the page does nothing
    visible at this point. To start making changes to the page, we need to add a controller
    and an Angular expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器停止，启动服务器并重新加载页面在这个阶段没有任何可见的变化。要开始对页面进行更改，我们需要添加一个控制器和一个Angular表达式。
- en: Adding a controller
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制器
- en: In Angular, a controller is a JavaScript object that exposes data and functionality
    to the view. It does this through Angular's `$scope` object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，控制器是一个JavaScript对象，它通过Angular的`$scope`对象向视图公开数据和功能。
- en: 'Open your `app.js` file and add the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`app.js`文件，并添加以下代码：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The additional code has created a controller constructor on `giftAppModule`
    called `GreetingController`. This isn't an actual controller until it is invoked
    in the page using the `ng-controller` directive.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的代码在`giftAppModule`上创建了一个名为`GreetingController`的控制器构造函数。这还不是真正的控制器，直到它在页面上使用`ng-controller`指令被调用时才成为如此。
- en: The first argument to the function is the name of the controller. The second
    argument is an array consisting of the dependencies we wish to inject. The final
    item in the array is the function itself. Angular documentation refers to this
    as array annotation and it is the preferred method of creating constructors.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一个参数是控制器的名称。第二个参数是一个数组，包含我们希望注入的依赖项。数组中的最后一项是函数本身。Angular文档称这为数组注解，并且这是创建构造函数的首选方法。
- en: The module name strings of the first part of the array map to the arguments
    of the function. The order of each must be the same.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 数组第一部分的模块名称字符串映射到函数的参数。每个参数的顺序必须相同。
- en: 'Next, we will need to add the controller to our `index.ejs html`, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将控制器添加到我们的`index.ejs html`中，如下所示：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we will add a `div` tag and give it an `ng-controller` attribute with
    a value of `GreetingController`. When we load this page, Angular will create a
    new `GreetingController` object and attach a child scope to this part of the page.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将添加一个`div`标签，并给它一个值为`GreetingController`的`ng-controller`属性。当我们加载这个页面时，Angular将创建一个新的`GreetingController`对象，并将一个子作用域附加到页面的这部分。
- en: Again, if you hit reload on your browser, you will not see anything different.
    Generally, to display data to the user, you will use Angular expressions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你在浏览器中刷新，你将不会看到任何不同。通常，为了向用户显示数据，你会使用Angular表达式。
- en: Displaying data with Angular expressions
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular表达式显示数据
- en: Angular expressions are code snippets that are placed between double curly braces
    (`{{}}`). Angular evaluates these (the JavaScript `eval()` function is not used
    as it's not a safe mechanism).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Angular表达式是放置在双大括号`{{}}`之间的代码片段。Angular评估这些（JavaScript的`eval()`函数没有被使用，因为它不是一个安全的机制）。
- en: The Angular documentation refers to expressions as JavaScript as there are some
    pretty major differences. For example, Angular expressions don't have `control
    loops`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档将表达式称为JavaScript，因为它们有一些相当大的差异。例如，Angular表达式没有`控制循环`。
- en: Angular expressions are evaluated within the context of the current scope.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Angular表达式是在当前作用域的上下文中评估的。
- en: 'Let''s make the following changes to `index.ejs`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`index.ejs`文件进行以下修改：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've added some Angular expressions inside `div`, where we invoked `GreetingController`.
    Angular makes the `GreetingController` scope object available inside this `div`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`div`中添加了一些Angular表达式，其中调用了`GreetingController`。Angular使得`GreetingController`的作用域对象在`div`内部可用。
- en: 'Now, if you reload this page, under **Welcome to Express**, you should see
    the following line of code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新加载这个页面，在**欢迎使用Express**下，你应该看到以下行代码：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Angular has evaluated the expressions and displayed them as strings. The expressions
    containing greeting and name are pulling those values from the scope. The final
    expression is just doing a little bit of arithmetic.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Angular评估了表达式并将它们作为字符串显示。包含问候和名称的表达式从作用域中提取那些值。最后的表达式只是进行了一点算术运算。
- en: Two-way data binding
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: One of the main features that Angular provides is called two-way data binding.
    This means that changing data in the view updates the data on the model. Likewise,
    data changed in the model is reflected in the view.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的主要功能之一被称为双向数据绑定。这意味着在视图中更改数据会更新模型中的数据。同样，模型中更改的数据会在视图中反映出来。
- en: 'Open `app.js` and add the following property to the scope:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.js`并添加以下属性到作用域中：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We've added a `newName` property and assigned to it the string, `Bob`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`newName`属性并将其赋值为字符串`Bob`。
- en: 'Now, we will need to make the following changes to `index.ejs`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`index.ejs`文件进行以下修改：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've made two changes to this file. The first is that we've added the `{{newName}}`
    expression after the arithmetic expression. This renders the `Bob` string to the
    screen. The second change is that we've added a text input control and added the
    `ng-model="newName"` directive. This directive binds the value in the text box
    to the `newName` property on the scope.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个文件做了两个修改。第一个是我们在算术表达式之后添加了`{{newName}}`表达式。这将在屏幕上渲染`Bob`字符串。第二个修改是添加了一个文本输入控件，并添加了`ng-model="newName"`指令。这个指令将文本框中的值绑定到作用域上的`newName`属性。
- en: When the page loads, the value in the text box is `Bob`. But what happens if
    we type something besides `Bob` in the text box? The value rendered by the expression
    changes nearly instantly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，文本框中的值是`Bob`。但如果我们在文本框中输入除了`Bob`之外的内容会发生什么呢？表达式的渲染值几乎瞬间改变。
- en: This is a clear example of what is meant by two-way data binding. Changes to
    the data in the view affect the model seamlessly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双向数据绑定的明显例子。视图中的数据更改无缝地影响模型。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to build a full stack application from database
    to frontend using nothing but JavaScript-based tools. In the previous chapters
    we looked at the MEAN stack components. Now we've started to put them together.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何仅使用基于JavaScript的工具从数据库到前端构建一个全栈应用程序。在前面的章节中，我们探讨了MEAN栈组件。现在我们已经开始将它们组合起来。
- en: You started by looking at Node.js, our JavaScript-based runtime environment.
    You used the Node.js REPL to execute JavaScript code on the command line. You
    then wrote a script, a small web server, which could be run by Node.js
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你从查看Node.js开始，这是我们的基于JavaScript的运行环境。你使用了Node.js的REPL在命令行上执行JavaScript代码。然后你编写了一个脚本，一个小型Web服务器，它可以由Node.js运行
- en: You learned the two methods to set up an Express application. Additionally,
    you also used the express generator to build out a functioning framework to build
    an application. You learned about routing and middleware—the two key components
    of Express.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了两种设置 Express 应用程序的方法。此外，你还使用了 express generator 来构建一个功能框架以构建应用程序。你了解了路由和中间件——Express
    的两个关键组件。
- en: MongoDB is a NoSQL database that stores data as flexible documents in collections
    as opposed to the records/table model of relational databases. You ran each of
    the basic CRUD (Create, Read, Update, Delete) methods in Mongo with insert, find,
    update, and remove.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个 NoSQL 数据库，它将数据作为灵活的文档存储在集合中，而不是像关系数据库那样存储在记录/表模型中。你已经在 Mongo 中运行了每个基本的
    CRUD（创建、读取、更新、删除）方法，即插入、查找、更新和删除。
- en: In the next chapter, we will dive deeply into MongoDB, gaining experience with
    the command-line interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 MongoDB，通过命令行界面获得经验。
