["```js\n// Builds and returns a string based\n// on the \"name\" argument.\nexport default function sayHello(name = 'World') {\n  return `Hello ${name}!`;\n}\n```", "```js\n// Tells Jest that we want the real \"hello\"\n// module, not the mocked version.\njest.unmock('../hello');\n\n// Imports the function we want to test.\nimport sayHello from '../hello';\n\n// Your typical Jasmine test suite, test cases,\n// and test assertions.\ndescribe('sayHello()', () => {\n  it('says hello world', () => {\n    expect(sayHello()).toBe('Hello World!');\n  });\n\n  it('says hello flux', () => {\n    expect(sayHello('Flux')).toBe('Hello Flux!');\n  });\n});\n```", "```js\nimport sayHello from './hello';\nsayHello();\n```", "```js\njest.unmock('../main');\n\n// The \"main\" module is the real deal. The\n// \"sayHello()\" function is a mock.\nimport '../main';\nimport sayHello from '../hello';\n\ndescribe('main', () => {\n\n  // We're expecting the \"main\" module to call\n  // \"sayHello()\" exactly once. Since the \"sayHello()\"\n  // function we've imported here is the same mock\n  // called by main, we can verify this is indeed\n  // what main is actually doing.\n  it('calls sayHello()', () => {\n    expect(sayHello.mock.calls.length).toBe(1);\n  });\n});\n```", "```js\nimport dispatcher from '../dispatcher';\n\nexport const SYNC = 'SYNC';\n\n// Your typical synchronous action creator\n// function. Dispatches an action with\n// payload data.\nexport function syncFunc(payload) {\n  dispatcher.dispatch({\n    type: SYNC,\n    payload\n  });\n}\n```", "```js\n// We want to test the real \"syncFunc()\" implementation.\njest.unmock('../actions/sync-func');\n\nimport dispatcher from '../dispatcher';\nimport { syncFunc } from '../actions/sync-func';\n\n// The \"dispatch()\" method is mocked by\n// Jest. We'll use it in the test to validate\n// our action.\nconst { dispatch } = dispatcher;\n\ndescribe('syncFunc()', () => {\n  it('calls dispatch()', () => {\n\n    // Calling \"syncFunc()\" should dispatch an\n    // action. We can verify this by making sure\n    // that the \"dispatch()\" was called.\n    syncFunc('data');\n    expect(dispatch.mock.calls.length).toBe(1);\n  });\n\n  it('calls dispatch() with correct payload', () => {\n    syncFunc('data');\n\n    // After calling \"syncFunc()\", we can get\n    // argument information from the mock.\n    const args = dispatch.mock.calls[1];\n    const [ action ] = args;\n\n    // Make sure the correct information was\n    // passed to the dispater.\n    expect(action).toBeDefined();\n    expect(action.type).toBe('SYNC');\n    expect(action.payload).toBe('data');\n  });\n});\n```", "```js\nimport dispatcher from '../dispatcher';\nimport request from '../request';\n\nexport const ASYNC = 'ASYNC';\n\n// Makes a \"request()\" call (which is really\n// just an alias for \"fetch()\") and dispatches\n// the \"ASYNC\" action with the JSON response\n// as the action payload.\nexport function asyncFunc() {\n  return request('https://httpbin.org/ip')\n    .then(resp => resp.json())\n    .then(resp => dispatcher.dispatch({\n      type: ASYNC,\n      payload: resp\n    }));\n}\n```", "```js\n// We're exporting the global \"fetch()\" function\n// so that Jest has an opportunity to mock it.\nexport default fetch;\n```", "```js\n// Exports the mocked version of the \"request()\"\n// function our action creators use. In this case,\n// we're emulating the \"fetch()\" function and the\n// \"Response\" object that it resolves.\nexport default function request() {\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      resolve({\n        json: () => new Promise((resolve, reject) => {\n\n          // This is where we put all of our mock fetch\n          // data. A given function should just test\n          // the properties that it's interested in,\n          // ignoring the rest.\n          resolve({ origin: 'localhost' });\n        })\n      });\n    });\n  });\n}\n```", "```js\njest.unmock('../actions/async-func');\n\n// The \"dispatcher\" is mock while \"asyncFunc()\"\n// is not.\nimport dispatcher from '../dispatcher';\nimport { asyncFunc } from '../actions/async-func';\n\ndescribe('asyncFunc()', () => {\n\n  // For testing asynchronous code that returns\n  // promises, we use \"pit()\" in place of \"it()\".\n  pit('dispatch', () => {\n\n    // Once the call to \"asyncFunc()\" has resolved,\n    // we can perform our test assertions.\n    return asyncFunc().then(() => {\n      // Collect stats about he mock\n      // \"dispatch()\" method.\n      const { calls } = dispatcher.dispatch.mock;\n      const { type, payload } = calls[0][0];\n\n      // Make sure that the asynchronous function\n      // dispatches an action with the appropriate\n      // payload.\n      expect(calls.length).toBe(1);\n      expect(type).toBe('ASYNC');\n      expect(payload.origin).toBe('localhost');\n    });\n  });\n});\n```", "```js\nimport { EventEmitter } from '../events';\nimport dispatcher from '../dispatcher';\nimport { DO_STUFF } from '../actions/do-stuff';\n\nvar state = {};\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // Registers a method of this store as the\n    // handler, to better support unit testing.\n    this.id = dispatcher.register(this.onAction.bind(this));\n  }\n\n  // Instead of performing the state transformation\n  // in the function that's registered with the\n  // dispatcher, it just determines which store\n  // method to call. This approach better supports\n  // testability.\n  onAction(action) {\n    switch (action.type) {\n      case DO_STUFF:\n        this.doStuff(action.payload);\n        break;\n    }\n  }\n\n  // Changes the \"state\" of the store, and emits\n  // a \"change\" event.\n  doStuff(payload) {\n    this.emit('change', (state = payload));\n  }\n}\n\nexport default new MyStore();\n```", "```js\n// In order to mock the Node \"EventEmitter\" API,\n// we need to expose it through one of our own modules.\nimport { EventEmitter } from 'events';\nexport { EventEmitter as EventEmitter } ;\n```", "```js\n// We want to test the real store...\njest.unmock('../stores/my-store');\n\nimport myStore from '../stores/my-store';\n\ndescribe('MyStore', () => {\n  it('does stuff', () => {\n\n    // Directly calls the store method that's\n    // registered with the dispatcher, passing it\n    // the same type of data that the dispatcher\n    // would.\n    myStore.onAction({\n      type: 'DO_STUFF',\n      payload: { foo: 'bar' }\n    });\n\n    // Get some of the mocked \"emit()\" call info...\n    const calls = myStore.emit.mock.calls;\n    const [ args ] = calls;\n\n    // We can now assert that the store emits a\n    // \"change\" event and that it has the correct info.\n    expect(calls.length).toBe(1);\n    expect(args[0]).toBe('change');\n    expect(args[1].foo).toBe('bar');\n  });\n});\n```", "```js\nimport { EventEmitter } from '../events';\nimport dispatcher from '../dispatcher';\nimport { POWER_ON } from '../actions/power-on';\nimport { POWER_OFF } from '../actions/power-off';\n\n// The initial state of the store...\nvar state = {\n  power: 'off',\n  busy: false\n};\n\nclass MyStore extends EventEmitter {\n\n  // Sets the initial state of the store to the given\n  // argument if provided.\n  constructor(initialState = state) {\n    super();\n    state = initialState;\n    this.id = dispatcher.register(this.onAction.bind(this));\n  }\n\n  // Figure out which action was dispatched and call the\n  // appropriate method.\n  onAction(action) {\n    switch (action.type) {\n      case POWER_ON:\n        this.powerOn();\n        break;\n      case POWER_OFF:\n        this.powerOff();\n        break;\n    }\n  }\n\n  // Changes the power state to \"on\", if the power state is\n  // currently \"off\".\n  powerOn() {\n    if (state.power === 'off') {\n      this.emit('change', \n        (state = Object.assign({}, state, {\n          power: 'on'\n        }))\n      );\n    }\n  }\n\n  // Changes the power state to \"off\" if \"busy\" is false and\n  // if the current power state is \"on\".\n  powerOff() {\n    if (!state.busy && state.power === 'on') {\n      this.emit('change', \n        (state = Object.assign({}, state, {\n          power: 'off'\n        }))\n      );\n    }\n  }\n\n  // Gets the state...\n  get state() {\n    return state;\n  }\n}\n\nexport default MyStore;\n```", "```js\n// We want to test the real store...\njest.unmock('../stores/my-store');\n\nimport MyStore from '../stores/my-store';\n\ndescribe('MyStore', () => {\n\n  // The default initial state of the store is\n  // powered off. This test makes sure that\n  // dispatching the \"POWER_ON\" action changes the\n  // power state of the store.\n  it('powers on', () => {\n    let myStore = new MyStore();\n\n    myStore.onAction({ type: 'POWER_ON' });\n\n    expect(myStore.state.power).toBe('on');\n    expect(myStore.state.busy).toBe(false);\n    expect(myStore.emit.mock.calls.length).toBe(1);\n  });\n\n  // This test changes the initial state of the store\n  // when it is first instantiated. The initial state\n  // is now powered off, and we've also marked the\n  // store as busy. This test makes sure that the\n  // logic of the store works as expected - the state\n  // shouldn't change, and no events are emitted.\n  it('does not powers off if busy', () => {\n    let myStore = new MyStore({\n      power: 'on',\n      busy: true\n    });\n\n    myStore.onAction({ type: 'POWER_OFF' });\n\n    expect(myStore.state.power).toBe('on');\n    expect(myStore.state.busy).toBe(true);\n    expect(myStore.emit.mock.calls.length).toBe(0);\n  });\n\n  // This test is just like the one above, only the\n  // \"busy\" property is false, which means that we\n  // should be able to power off the store when the\n  // \"POWER_OFF\" action is dispatched.\n  it('does not powers off if busy', () => {\n    let myStore = new MyStore({\n      power: 'on',\n      busy: false\n    });\n    myStore.onAction({ type: 'POWER_OFF' });\n\n    expect(myStore.state.power).toBe('off');\n    expect(myStore.state.busy).toBe(false);\n    expect(myStore.emit.mock.calls.length).toBe(1);\n  });\n});\n```", "```js\nimport { Suite } from 'benchmark';\n\n// The \"setup()\" function is used by each benchmark in\n// the suite to create data to used within the test.\n// This is run before anything is measured.\nfunction setup() {\n\n  // The \"coll\" array will be available in each\n  // benchmark function because this source gets\n  // compiled into the benchmark function.\n  const coll = new Array(10000)\n    .fill({\n      first: 'First',\n      last: 'Last',\n      disabled: false\n    });\n\n  // Disable some of the items...\n  for (let i = 0; i<coll.length; i += 10) {\n    coll[i].disabled = true;\n  }\n}\n\nnew Suite()\n\n  // Adds a benchmark that tests the \"filter()\"\n  // function to remove disabled items and the\n  // \"map()\" function to transform the string\n  // properties.\n  .add('filter() + map()', () => {\n    const results = coll\n      .filter(item => !item.disabled)\n      .map(item => ({\n        first: item.first.toUpperCase(),\n        last: item.last.toUpperCase()\n      }));\n  }, { setup: setup })\n\n  // Adds a benchmark that tests a \"for..of\" loop\n  // to build the \"results\" array.\n  .add('for..of', () => {\n    const results = [];\n\n    for (let item of coll) {\n      if (!item.disabled) {\n        results.push({\n          first: item.first.toUpperCase(),\n          last: item.last.toUpperCase()\n        });\n      }\n    }\n  }, { setup: setup })\n\n  // Adds a benchmark that tests a \"reduce()\"\n  // call to filter out disabled items\n  // and perform the string transforms.\n  .add('reduce()', () => {\n    const results = coll\n      .reduce((res, item) => !item.disabled ?\n        res.concat({\n          first: item.first.toUpperCase(),\n          last: item.last.toUpperCase()\n        }) : res);\n  }, { setup: setup })\n\n  // Setup event handlers for logging output...\n  .on('cycle', function(event) {\n    console.log(String(event.target));\n  })\n  .on('start', () => {\n    console.log('Running...');\n  })\n  .on('complete', function() {\n    const name = this.filter('fastest').map('name');\n    console.log(`Fastest is \"${name}\"`);\n  })\n  .on('error', function(e) {\n    console.error(e.target.error);\n  })\n  // Runs the benchmarks...\n  .run({ 'async': true });\n  // →\n  // Running...\n  // filter() x 1,470 ops/sec ±1.00% (86 runs sampled)\n  // for..of x 1,971 ops/sec ±2.39% (81 runs sampled)\n  // reduce() x 1,479 ops/sec ±0.89% (87 runs sampled)\n  // Fastest is \"for..of\"\n```"]