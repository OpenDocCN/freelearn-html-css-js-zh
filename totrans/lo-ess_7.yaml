- en: Chapter 7. Using Lo-Dash with Other Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：与其他库一起使用 Lo-Dash
- en: The previous chapter showed us what our Lo-Dash code starts to look like as
    it falls in place within a larger application. Things get factored into a more
    generic, reusable form, and they're named and structured consistently. Patterns
    start to emerge, and as your code starts to realize these patterns, it takes the
    shape of a production-ready system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章向我们展示了我们的 Lo-Dash 代码在更大的应用中定位后的样子。事物被分解成更通用的、可重用的形式，并且命名和结构保持一致。模式开始显现，随着你的代码开始实现这些模式，它将呈现出一个生产就绪系统的形态。
- en: In the spirit of deploying Lo-Dash code to a production environment, this chapter
    addresses the ecosystem into which our code is tossed when deemed stable. Lo-Dash
    does a lot, but there are some tasks that this library is simply not well suited
    for. In other words, it's highly unlikely that Lo-Dash is the only library your
    application will use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Lo-Dash 代码部署到生产环境的精神下，本章讨论了当我们的代码被认为稳定时被投入其中的生态系统。Lo-Dash 做了很多事情，但有一些任务这个库并不适合。换句话说，Lo-Dash
    很可能不是你应用程序唯一使用的库。
- en: The best way to keep our code organized and modular is by using modules. Module
    technology has gained a lot of attention over the last few years in the JavaScript
    community, and Lo-Dash is no exception. We can make it work using the same module
    loaders that applications use. There are also Lo-Dash packages available for Node.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们的代码组织和模块化的最佳方式是使用模块。模块技术在过去的几年中在 JavaScript 社区中受到了很多关注，Lo-Dash 也不例外。我们可以使用应用程序使用的相同模块加载器来实现它。还有适用于
    Node.js 的 Lo-Dash 包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: jQuery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: Backbone
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone
- en: Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: Modules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: If you've done any frontend development in the past few years, you have probably
    heard of AMD modules, if you haven't already experimented with them. AMD is growing
    fast, with no shortage of production deployments around the world. This modular
    movement in frontend development stemmed from a lack of a decent way to organize
    large-scale projects that have many dependencies. Before modules for the web were
    a thing, the only tool at our disposal for organizing dependencies was the `<script>`
    element. This is still an accepted way to pull in JavaScript code—except when
    there are hundreds of modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你过去几年中做过任何前端开发，你可能已经听说过 AMD 模块，即使你还没有尝试过它们。AMD 发展迅速，全球范围内有大量的生产部署。前端开发中的这种模块化运动源于缺乏组织具有许多依赖的大型项目的合理方式。在
    Web 模块出现之前，我们用来组织依赖的唯一工具是 `<script>` 元素。这仍然是一种被接受的方式来引入 JavaScript 代码——除非有数百个模块。
- en: Modularity, especially frontend web development modularity, is a large topic—too
    large for this book (let alone for this chapter) to properly address. So let's
    strip the topic down to the relevant parts for us, the Lo-Dash programmers. It's
    good programming practice to divide our code into modules that serve a single
    purpose. This provides a good separation of concerns and allows our components
    to evolve more easily and independently of one another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化，尤其是前端网络开发模块化，是一个很大的话题——对于这本书（更不用说本章）来说，太大而不可能充分讨论。所以让我们将这个话题简化为我们 Lo-Dash
    程序员相关的内容。将我们的代码分解成只服务于单一目的的模块是良好的编程实践。这提供了良好的关注点分离，并允许我们的组件更容易地独立发展。
- en: In this section, we'll take a look at **RequireJS**, one of the leading AMD
    module loader technologies available. Lo-Dash has builds that help us utilize
    this technology and construct modules of our own. With that said, let's get into
    some of the practical nitty-gritty.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 **RequireJS**，这是可用的主要 AMD 模块加载技术之一。Lo-Dash 有构建来帮助我们利用这项技术并构建我们自己的模块。话虽如此，让我们深入了解一些实际细节。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**AMD** stands for **asynchronous module definition**, a simple pattern followed
    by many JavaScript components. It''s not a recognized specification, although
    something is brewing in the upcoming ES6 specification. There''s a related pattern
    called UMD, which aims to be more universal than AMD and has some questionable
    fallback modes. My advice is to stick to something that''s easy to use, such as
    RequireJS, until there''s an adopted standard that''s widely supported.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**AMD** 代表 **异步模块定义**，这是许多 JavaScript 组件遵循的一个简单模式。虽然它不是一个公认的规范，但在即将到来的 ES6
    规范中有所酝酿。还有一个相关的模式称为 UMD，它旨在比 AMD 更通用，并有一些值得怀疑的回退模式。我的建议是坚持使用易于使用的东西，比如 RequireJS，直到有一个被广泛支持的采用标准。'
- en: Organizing your code with modules
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块组织你的代码
- en: Let's see what a basic module looks like. The idea is that a definition function
    returns the component that the module defines. The component could be a function,
    an object, a string, or any value for that matter. If you're developing a Lo-Dash
    application, your modules are likely to return functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本模块的样子。想法是定义函数返回模块定义的组件。组件可以是函数、对象、字符串或任何值。如果你正在开发Lo-Dash应用程序，你的模块很可能会返回函数。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since RequireJS makes XHR requests, it''s a lot easier to serve your JavaScript
    modules with a simple static web server. The code that is shipped with this book
    has a `Gruntfile`, which lets you run a simple web server. However, you''ll need
    Node.js installed. There are plenty of resources all over the Internet that can
    be used to install Node on any platform. Once Node is available, you can install
    Grunt with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RequireJS会发起XHR请求，因此使用简单的静态Web服务器来提供JavaScript模块要容易得多。这本书附带的一些代码有一个`Gruntfile`，它允许你运行一个简单的Web服务器。然而，你需要安装Node.js。互联网上有许多资源可以帮助你在任何平台上安装Node。一旦Node可用，你可以使用以下命令安装Grunt：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will make the `grunt` command available on your system. From within the
    root code directory, where the `Gruntfile.js` file is located, run the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的系统上使`grunt`命令可用。在根代码目录内，`Gruntfile.js`文件所在的位置，运行以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll see some output about the server running forever. Pressing *Ctrl* + *C*
    will stop it. And that's it! You can navigate to `http://0.0.0.0:8000/chapter7.html`
    to run the examples from this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些关于服务器无限运行的信息。按下*Ctrl* + *C*将停止它。就这样！你可以导航到`http://0.0.0.0:8000/chapter7.html`来运行本章的示例。
- en: 'Consider the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see that the `define()` function takes two arguments. The first is
    an array of modules that we''re dependent on and the second is a function that
    returns the component this module defines. In this case, our module doesn''t have
    any external dependencies and it returns an anonymous function. This function
    takes a `coll` and a `filter` argument. Then we use the Lo-Dash constructor to
    wrap the collection and we reduce it to the average value. Next, let''s take a
    look at how this module gets used:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`define()`函数接受两个参数。第一个是我们依赖的模块数组，第二个是返回该模块定义的组件的函数。在这种情况下，我们的模块没有外部依赖，它返回一个匿名函数。这个函数接受一个`coll`和一个`filter`参数。然后我们使用Lo-Dash构造函数来包装集合，并将其缩减到平均值。接下来，让我们看看这个模块是如何被使用的：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see here that our call to the `require()` function passes an array of
    module dependencies. In this case, we're dependent on the `average-age` module.
    The function callback is triggered when this module is loaded, evaluated, and
    ready to use. The `averageAge` argument is the value returned by the module. In
    this case, it's the function we defined earlier, and we show how it can be applied
    to a collection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到，我们对`require()`函数的调用传递了一个模块依赖数组。在这种情况下，我们依赖于`average-age`模块。当这个模块被加载、评估并准备好使用时，函数回调会被触发。`averageAge`参数是模块返回的值。在这种情况下，它是我们之前定义的函数，我们展示了如何将其应用于一个集合。
- en: Requiring Lo-Dash
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入Lo-Dash
- en: The downside to our `average-age` module is that it doesn't define any explicit
    dependencies. Yet, it clearly depends on Lo-Dash being available. So how does
    this code even work? Where does the `_` variable get defined? Well, the only reason
    the preceding example runs is because we've included Lo-Dash on the page using
    the standard `<script>` tag. This adds the `_` symbol to the global namespace.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`average-age`模块的缺点是它没有定义任何明确的依赖。然而，它显然依赖于Lo-Dash可用。那么这段代码是如何工作的呢？`_`变量在哪里定义的？好吧，前面的例子之所以能运行，仅仅是因为我们使用标准的`<script>`标签包含了Lo-Dash。这会将`_`符号添加到全局命名空间中。
- en: 'This goes against one of the grounding principles of modules—there shouldn''t
    be a need for global variables. What we end up with are implicit dependencies,
    as is the case in the previous code. This means our modules that use this implicit
    dependency aren''t as portable as they could be. If that `<script>` tag goes away,
    our module stops working. Thankfully, we can define our modules that depend on
    Lo-Dash as having this dependency explicitly, as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了模块的一个基本原理——不应该需要全局变量。我们最终得到的是隐式依赖，就像前面的代码那样。这意味着使用这个隐式依赖的模块不如它们可能的那样可移植。如果那个`<script>`标签消失了，我们的模块就停止工作了。幸运的是，我们可以将依赖于Lo-Dash的模块定义为具有这个依赖的显式依赖，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can see that instead of passing an empty array as the first argument
    to `define()`, we have a string that points to the Lo-Dash module. Now the `_`
    symbol is an argument within our `define()` function instead of being referenced
    globally. Let''s see this module being put to use now:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，我们不是将空数组作为 `define()` 的第一个参数传递，而是有一个指向 Lo-Dash 模块的字符串。现在 `_` 符号是 `define()`
    函数内的一个参数，而不是全局引用。现在让我们看看这个模块是如何被使用的：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we require our `sort-name` module as a dependency and the `sortName()`
    function is an argument to the `require()` callback function. The function sorts
    an input collection by name and returns a wrapper instance. This is illustrated
    here, by calling `sortBy()` followed by `value()`. This is actually a good thing
    because it means that the returned wrapper instance can be extended before it
    is evaluated and unwrapped.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `sort-name` 模块作为依赖项，`sortName()` 函数是 `require()` 回调函数的参数。该函数按名称对输入集合进行排序，并返回一个包装器实例。这在这里通过调用
    `sortBy()` 后跟 `value()` 来说明。这实际上是一件好事，因为它意味着返回的包装器实例可以在评估和展开之前进行扩展。
- en: You'll also notice that we're indirectly depending on Lo-Dash here because we
    depend on `sort-name`. We can call the `value()` function and extend the returned
    wrapper without an explicit reference to the `_` symbol. This means that, should
    the `sort-name` module no longer rely on Lo-Dash at some point in the future,
    our function will still work, although we might have to remove the `value()` invocation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，我们在这里间接依赖于 Lo-Dash，因为我们依赖于 `sort-name`。我们可以调用 `value()` 函数并扩展返回的包装器，而不需要显式引用
    `_` 符号。这意味着，如果将来某个时刻 `sort-name` 模块不再依赖于 Lo-Dash，我们的函数仍然可以工作，尽管我们可能需要移除 `value()`
    调用。
- en: 'There''s another step involved with getting Lo-Dash to work with RequireJS.
    Let''s take a look at the `main.js` configuration file that helps RequireJS figure
    out where to find modules and what they expose:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Lo-Dash 与 RequireJS 一起工作，还需要进行另一个步骤。让我们看看 `main.js` 配置文件，它帮助 RequireJS 确定模块的位置以及它们暴露的内容：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our code referenced `lodash` as a dependency. This path configuration tells
    RequireJS where to find that module. The `shim` configuration section is for modules
    that aren't defined as AMD modules. Since this is the case with Lo-Dash, we have
    to add a shim that tells RequireJS what's actually returned when something requires
    the concerned module.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中将 `lodash` 作为依赖项。这个路径配置告诉 RequireJS 在哪里找到该模块。`shim` 配置部分用于未定义为 AMD 模块的模块。由于
    Lo-Dash 就是这样，我们必须添加一个适配器，告诉 RequireJS 当某个模块被要求时实际返回什么。
- en: Working with Lo-Dash AMD modules
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Lo-Dash AMD 模块
- en: 'It turns out that there''s a better way to use Lo-Dash in the form of AMD modules.
    Lo-Dash has specific AMD builds available for download and these don''t require
    a shim. Another benefit of obtaining Lo-Dash components this way is that we don''t
    have to pull down the entire library if we depend on only a handful of functions.
    For example, let''s see how we can depend on function categories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，使用 Lo-Dash 的更好方式是采用 AMD 模块的形式。Lo-Dash 提供了特定的 AMD 构建版本可供下载，这些版本不需要使用适配器。通过这种方式获取
    Lo-Dash 组件的另一个好处是，如果我们只依赖少数几个函数，我们就不必下载整个库。例如，让我们看看我们如何依赖函数类别：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're using the AMD build of Lo-Dash in this example. This is made apparent
    by the module path that we require. The `collection` module is defined as an AMD
    module and contains all the collection-related functions. You can see that we're
    using the `_` symbol as the function argument. This means the code that uses the
    collection functions can be written just as if it is using any Lo-Dash module.
    For instance, if we were to require the full Lo-Dash API instead of just the collection
    functions, none of the code would need to change. Instead, we're only requiring
    a subset of Lo-Dash, thus saving the network delivery cost.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是 Lo-Dash 的 AMD 构建。这是通过我们要求的模块路径来体现的。`collection` 模块被定义为 AMD 模块，并包含所有与集合相关的函数。你可以看到我们使用
    `_` 符号作为函数参数。这意味着使用集合函数的代码可以像使用任何 Lo-Dash 模块一样编写。例如，如果我们要求完整的 Lo-Dash API 而不是仅集合函数，则不需要更改任何代码。相反，我们只要求
    Lo-Dash 的一个子集，从而节省了网络传输成本。
- en: 'The code is using the `invoke()` function on our collection to call the `name()`
    method on each item while collecting the results. However, that''s only one function.
    There''s still a lot in the collections category that we require and are not using
    at all. Let''s see how we can use more fine-grained Lo-Dash function dependencies:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在集合上使用`invoke()`函数调用每个项目的`name()`方法，同时收集结果。然而，这只是一个函数。集合类别中还有很多我们需要的但我们根本不使用的功能。让我们看看我们如何使用更细粒度的Lo-Dash函数依赖项：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see when you drill into the categories, there's a specific module
    for any given function you'd like to include. The preceding code is using two
    Lo-Dash functions. The `filter()` function comes from the collection category
    and the `partial()` function comes from the function category. Both functions
    are passed directly as callback arguments. Since both of these function modules
    are themselves defined as AMD modules, they require only the internal dependencies
    needed to work. This means that we're only requiring what we need, which might
    only be one or two functions in certain contexts, such as our preceding example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在深入类别时可以看到的，对于您想要包含的任何特定功能，都有一个特定的模块。前面的代码使用了两个Lo-Dash函数。`filter()`函数来自集合类别，而`partial()`函数来自函数类别。这两个函数都直接作为回调参数传递。由于这两个函数模块本身定义为AMD模块，它们只需要工作所需的内部依赖项。这意味着我们只要求我们需要的，这可能在某些上下文中只是一件或两件函数，例如我们前面的例子。
- en: 'The downside to this level of granularity is that if you''re unsure of what
    you need, you''ll constantly have to modify your list of model dependencies. Lo-Dash
    has a lot to offer, and it''s a good idea to utilize Lo-Dash functions wherever
    you can. For example, if you''re wrapping values and chaining together function
    calls, it''s tough to know in advance which functions you''re going to require.
    So it''s probably a good idea to obtain the whole API so that there''s no possibility
    of something you want to use not being there. Consider the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种细粒度级别的一个缺点是，如果您不确定需要什么，您将不得不不断修改您的模型依赖项列表。Lo-Dash有很多东西可以提供，并且最好尽可能使用Lo-Dash函数。例如，如果您正在包装值并将函数调用链接在一起，那么事先知道您将需要哪些函数是很困难的。因此，获取整个API可能是一个好主意，这样就没有可能您想要使用的某些东西不在那里。考虑以下代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is similar to our first example, where we required the entire Lo-Dash API.
    The difference here is that this is the AMD build, so we require the `main` Lo-Dash
    module, which includes everything we'll need. The other difference is that with
    this approach, there's no need to set up paths or shims within the main RequireJS
    configuration file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的第一个例子相似，其中我们要求整个Lo-Dash API。这里的区别在于这是一个AMD构建，因此我们要求`main` Lo-Dash模块，它包括我们需要的所有内容。另一个区别是，采用这种方法，在主RequireJS配置文件中不需要设置路径或shim。
- en: jQuery
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery
- en: jQuery is undoubtedly one of the most successful and widely used technologies
    of all time. And it came into being because of browser inconsistencies; John Resig
    decided to do something about it. Rather than having the application developers
    maintain their own code that deals with all the mundane cross-browser issues,
    why not let jQuery handle that stuff for them?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery无疑是历史上最成功和最广泛使用的技术之一。它的出现是因为浏览器的不一致性；约翰·雷斯（John Resig）决定对此采取行动。与其让应用程序开发者维护自己的代码来处理所有这些平凡的跨浏览器问题，为什么不让他们让jQuery来处理这些事情呢？
- en: jQuery has evolved over the years, thanks to thousands and thousands of users
    and contributing developers wanting to make frontend development less intimidating.
    Over time, it has changed certain aspects of itself and added new features to
    keep up with the changing environments in which it resides.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery经过多年的发展，得益于成千上万的用户和贡献开发者希望使前端开发不那么令人畏惧。随着时间的推移，它改变了自己的一些方面，并添加了新功能，以跟上其所在环境的变化。
- en: It's safe to say that jQuery has changed the way frontend development is done
    and will continue to do so because of its mass adoption. Several web standards
    that exist today are rooted in jQuery. Lo-Dash is similar to jQuery in a lot of
    ways. While it's not nearly as mature as jQuery, it's being rapidly adopted. Like
    jQuery, Lo-Dash originated from an effort to fix cross-browser issues and performance
    issues present in Underscore.js. The development effort of Lo-Dash has expanded
    much beyond a simple drop-in replacement for Underscore.js and will certainly
    influence future JavaScript specifications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，jQuery已经改变了前端开发的方式，并且由于其广泛的采用，将继续这样做。今天存在的几个网络标准都根植于jQuery。Lo-Dash在许多方面与jQuery相似。虽然它远不如jQuery成熟，但它正在迅速被采用。像jQuery一样，Lo-Dash起源于解决Underscore.js中存在的跨浏览器问题和性能问题的努力。Lo-Dash的开发工作已经远远超出了Underscore.js的简单替换，并将肯定影响未来的JavaScript规范。
- en: So jQuery and Lo-Dash are similar in their effectiveness. Where they differ
    is in the specific problems they solve for programmers. Let's take a closer look
    at those and see whether there is a way in which the two libraries can complement
    one another.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，jQuery和Lo-Dash在有效性方面相似。它们之间的区别在于它们为程序员解决的具体问题。让我们更仔细地看看这些问题，看看这两个库是否可以相互补充。
- en: Challenges faced by Lo-Dash
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lo-Dash面临的挑战
- en: Lo-Dash is a low-level framework that augments JavaScript at the language level.
    Low-level is a relative term. It's not that Lo-Dash doesn't have any abstractions;
    it has plenty. It's just that there's a lot more to frontend development than
    just JavaScript. Lo-Dash isn't good at any of those other things, nor is it intended
    to be.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash是一个低级框架，它在语言级别上增强JavaScript。低级是一个相对术语。并不是说Lo-Dash没有任何抽象；它有很多。只是前端开发不仅仅是JavaScript。Lo-Dash不擅长那些其他事情，也不是为了这个目的而设计的。
- en: While you can use Lo-Dash to write better code, that's only half the battle.
    Standalone JavaScript code doesn't get you very far. If you're developing an application,
    at some point, you're going to eventually touch the DOM. You're going to make
    API calls that load your application data and change the state of the server-side
    resources. You're also going to deal with the asynchronous nature of these calls
    and user events, while taking care to perform well and prevent leaks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用Lo-Dash编写更好的代码，但这只是战斗的一半。独立的JavaScript代码并不能让你走得很远。如果你正在开发一个应用程序，在某个时候，你最终会接触到DOM。你将进行API调用以加载你的应用程序数据并改变服务器端资源的状态。你还将处理这些调用的异步性质和用户事件，同时注意性能并防止泄漏。
- en: Frontend development is a complicated endeavor but Lo-Dash is great for all
    things in JavaScript. Writing concise, readable code that performs well is where
    Lo-Dash shines. This generally means the core of your frontend code. For everything
    else, there are other libraries, such as jQuery.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发是一项复杂的任务，但Lo-Dash在JavaScript的所有方面都表现得非常出色。编写简洁、易读且性能良好的代码正是Lo-Dash的强项。这通常意味着你的前端代码的核心。对于其他所有事情，还有其他库，例如jQuery。
- en: Challenges faced by jQuery
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery面临的挑战
- en: One of the reasons jQuery is so attractive to programmers is its low barrier
    to entry. Anyone building a website can immediately learn and benefit from jQuery,
    often in a day or two. At the same time, it's powerful enough to scale from a
    basic site to a powerful web application. DOM traversal and manipulation are one
    thing jQuery excels at, but it's also capable of dealing with complicated Ajax
    calls, DOM events, and asynchronous callbacks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery对程序员如此有吸引力的一个原因是它的入门门槛低。任何构建网站的人都可以立即学习和从jQuery中受益，通常只需要一两天。同时，它足够强大，可以从一个基本网站扩展到强大的网络应用程序。DOM遍历和操作是jQuery擅长的，但它也能处理复杂的Ajax调用、DOM事件和异步回调。
- en: These are all the areas Lo-Dash lacks any support in. Again, this is intentional.
    The two libraries serve different purposes. However, they're also complementary
    and often sit side by side in the same application, carrying out their roles.
    What jQuery doesn't have is a set of tools to aid the programmer inside all of
    these callback functions that run in response to Ajax requests, user events, and
    so on. This is not what it's meant for. You're free to use any library you like
    to enhance the core application business logic, and Lo-Dash is one such choice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是 Lo-Dash 缺乏支持的领域。再次强调，这是故意的。这两个库服务于不同的目的。然而，它们也是互补的，通常在同一个应用程序中并肩作战，执行各自的职责。jQuery
    没有提供一组工具来帮助程序员在响应 Ajax 请求、用户事件等所有这些回调函数中。这不是它的用途。你可以自由地使用你喜欢的任何库来增强核心应用程序的业务逻辑，而
    Lo-Dash 就是这样的选择之一。
- en: The focused nature of both Lo-Dash and jQuery leaves us with a clear separation
    of concerns. jQuery lets the Lo-Dash programmer worry about creating high-quality
    functional code. We've already seen how to utilize RequireJS with Lo-Dash in an
    effort to produce modular components. Let's now look at how we can use Lo-Dash
    alongside jQuery.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 和 jQuery 的专注特性使我们能够清晰地分离关注点。jQuery 允许 Lo-Dash 程序员专注于创建高质量的函数式代码。我们已经看到了如何使用
    RequireJS 与 Lo-Dash 结合来生成模块化组件。现在让我们看看如何将 Lo-Dash 与 jQuery 结合使用。
- en: Using jQuery instances as collections
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 jQuery 实例用作集合
- en: 'Perhaps, the most common use case of jQuery is querying the DOM for elements.
    The result is a jQuery object that closely resembles an array. We can exercise
    our Lo-Dash know-how to treat these instances as collections. For example, let''s
    compare the jQuery `map()` function to the Lo-Dash `map()` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，jQuery 最常见的用例是查询 DOM 元素。结果是 jQuery 对象，它非常类似于数组。我们可以运用 Lo-Dash 的知识将这些实例视为集合。例如，让我们比较
    jQuery 的 `map()` 函数与 Lo-Dash 的 `map()` 函数：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The mapped output of both approaches is exactly the same. Even the code differences
    are subtle at best. The difference is only in the looping performance—the Lo-Dash
    `map()` function will always have an edge over the jQuery `map()` function due
    to the differences in implementation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的映射输出完全相同。即使是代码差异也是微不足道的。差异仅在于循环性能——由于实现上的差异，Lo-Dash 的 `map()` 函数将始终优于
    jQuery 的 `map()` 函数。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following chapter goes into greater detail on why iterative Lo-Dash functions
    perform the way they do.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更详细地介绍为什么迭代式 Lo-Dash 函数以这种方式执行。
- en: The performance gain isn't all that great. What's a few milliseconds here and
    there? The preceding example only finds a handful of elements, and the test is
    repeated 1,000 times. In production, you're probably going to be dealing with
    larger query results, iterated more than 1,000 times, and over time, the milliseconds
    start to add up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升并不算很大。这里那里多几毫秒又如何呢？前面的例子只找到了几个元素，测试重复了 1,000 次。在生产环境中，你可能会处理更大的查询结果，迭代超过
    1,000 次，随着时间的推移，毫秒开始累积。
- en: Is there anything fundamentally wrong with the performance of jQuery `map()`?
    Absolutely not. If it works, use it. This change itself isn't going to pleasantly
    surprise your users. On the other hand, if you're a Lo-Dash programmer, you're
    going to use it for what it's good at. Lo-Dash is very good at iterating over
    collections. jQuery is very good at querying the DOM, and it still takes up this
    responsibility. So what's the code cost of implementing this improvement? Essentially
    zero.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的 `map()` 函数的性能是否存在根本问题？绝对没有。如果它有效，就使用它。这种变化本身不会让用户感到惊喜。另一方面，如果你是 Lo-Dash
    程序员，你会用它来发挥它的长处。Lo-Dash 非常擅长遍历集合。jQuery 非常擅长查询 DOM，并且它仍然承担这个责任。那么实现这个改进的代码成本是多少？基本上为零。
- en: Binding functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数绑定
- en: 'In the previous section, we looked at an area where Lo-Dash and jQuery overlap.
    We chose the Lo-Dash approach because it made sense to do so, both from a responsibility
    perspective (iterating over collections) and a cost-to-implement perspective (the
    code looks nearly identical). Another area of overlap is function binding. jQuery
    has tools available to bind functions to a given context, but Lo-Dash has better
    functional tools. Let''s compare the two approaches again:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了 Lo-Dash 和 jQuery 重叠的领域。我们选择 Lo-Dash 方法，因为它在责任角度（遍历集合）和实现成本角度（代码几乎相同）上都是合理的。另一个重叠的领域是函数绑定。jQuery
    提供了将函数绑定到特定上下文中的工具，但 Lo-Dash 拥有更好的函数式工具。让我们再次比较这两种方法：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both approaches reduce the collection to the same result. The code is basically
    identical; the only difference is the way the callback passed to `reduce()` is
    bound. The context we're binding the functions to is a plain object with a `multiplier`
    property that's looked up when the callback is run. It's looked up by referencing
    `this`, which is why we have to bind the context before passing the callback to
    the `reduce()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将收集过程简化为相同的结果。代码基本上是相同的；唯一的区别是传递给 `reduce()` 的回调函数的绑定方式。我们将函数绑定到的上下文是一个具有
    `multiplier` 属性的普通对象，当回调函数运行时，会查找这个属性。它是通过引用 `this` 来查找的，这就是为什么我们必须在将回调函数传递给 `reduce()`
    函数之前绑定上下文的原因。
- en: The first approach uses the `proxy()` jQuery function while the second approach
    uses the Lo-Dash `bind()` function. As with the preceding example of `map()`,
    the performance edge goes to Lo-Dash, there's no cost to implement it, and it's
    something that Lo-Dash was designed to do well. So if you're passing callbacks
    to jQuery event functions, `bind()` is just as viable as `proxy()` and is within
    the scope of something Lo-Dash is good at.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法使用 `proxy()` jQuery 函数，而第二种方法使用 Lo-Dash 的 `bind()` 函数。与前面 `map()` 的例子一样，性能优势属于
    Lo-Dash，实现它没有成本，而且这是 Lo-Dash 设计得很好的功能之一。所以如果你正在将回调传递给 jQuery 事件函数，`bind()` 和 `proxy()`
    一样可行，而且是在 Lo-Dash 擅长的范围内。
- en: Working with jQuery deferred instances
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 jQuery 延迟实例一起工作
- en: 'We''ve seen how Lo-Dash can aid in iterating over DOM elements after they''ve
    been queried by jQuery. We''ve also seen how Lo-Dash can improve function bindings
    in our jQuery code. Let''s turn things around and see where jQuery can help our
    Lo-Dash code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Lo-Dash 如何在 jQuery 查询 DOM 元素后帮助迭代这些元素。我们也看到了 Lo-Dash 如何在我们的 jQuery 代码中改进函数绑定。让我们反过来看看
    jQuery 如何帮助我们编写 Lo-Dash 代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we're utilizing the `Deferred` jQuery object. This is something that's
    returned by a function that does something asynchronously. Once the caller has
    possession of the deferred instance, it serves as a channel between the caller
    and the function. When the function is done with its asynchronous work, it notifies
    the caller and a callback function is run. There's a whole bunch of tricks we
    can perform with deferred instances, but we'll keep it straightforward here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用 `Deferred` jQuery 对象。这是由执行异步操作的功能返回的。一旦调用者拥有延迟实例，它就充当调用者和函数之间的通道。当函数完成其异步工作后，它会通知调用者并运行回调函数。我们可以对延迟实例执行许多技巧，但在这里我们将保持简单。
- en: The job of the `query()` function we've implemented is to wrap the collection
    in a Lo-Dash wrapper and filter it using the `filter` argument. If the `sort`
    argument was provided, we sort the collection as well. The asynchronous work happens
    when we check the size of the collection. Note that we haven't actually executed
    any of the chained function calls yet, because we haven't called `value()`. If
    the collection contains more than 5,000 items, we use the Lo-Dash `defer()` function
    to clear the JavaScript call stack before executing `value()`. If the collection
    contains less items, we execute the filter immediately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的 `query()` 函数的职责是将集合包装在 Lo-Dash 包装器中，并使用 `filter` 参数进行过滤。如果提供了 `sort` 参数，我们也会对集合进行排序。异步工作发生在我们检查集合大小时。请注意，我们实际上还没有执行任何链式函数调用，因为我们还没有调用
    `value()`。如果集合包含超过 5,000 个项目，我们使用 Lo-Dash 的 `defer()` 函数在执行 `value()` 之前清除 JavaScript
    调用栈。如果集合包含较少的项目，我们立即执行过滤器。
- en: The result of calling `value()` is passed to the caller through the jQuery deferred
    instance, using the `resolve()` function. What's nice about this function is that
    it's always asynchronous to the caller. Even when we have smaller collections,
    it's still treated as asynchronous. The output illustrates when our randomized
    collection has more than 5,000 items, and the filter is deferred. When we see
    the `awaiting results` message, it means that the control had returned to the
    caller before the query was executed. This is the idea; since the collection is
    large, we let other things happen first in case the filter takes a while to complete.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `value()` 的结果通过 jQuery 延迟实例传递给调用者，使用 `resolve()` 函数。这个函数的优点是它总是对调用者异步。即使我们处理的是较小的集合，它仍然被视为异步。输出说明了当我们的随机集合有超过
    5,000 个项目时，过滤器是延迟的。当我们看到“等待结果”的消息时，这意味着在查询执行之前，控制权已经返回给调用者。这是这个想法；由于集合很大，我们让其他事情先发生，以防过滤器需要一段时间才能完成。
- en: Backbone
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背骨
- en: Unlike jQuery, Backbone is a library that's concerned with creating higher-level
    abstractions for the application. Things such as models, collections, and views
    are concepts that the Backbone programmer extends to provide seamless integration
    with the API data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与 jQuery 不同，Backbone 是一个关注于为应用程序创建高级抽象的库。例如模型、集合和视图等概念，Backbone 程序员会扩展这些概念以提供与
    API 数据的无缝集成。
- en: Backbone recognizes its own strengths and utilizes other libraries such as jQuery
    and Underscore to implement certain things such as fetching and saving data. This
    is a job well suited for jQuery as is rendering views in the DOM. For lower-level
    tasks, Backbone utilizes Underscore's capabilities. Because Backbone leverages
    these libraries, it's able to maintain a small code footprint. Moreover, since
    it follows simple patterns, it more or less stays out of the developer's way,
    letting them adapt the library to specific use cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 认识到自己的优势，并利用其他库如 jQuery 和 Underscore 来实现某些功能，例如获取和保存数据。这对于 jQuery 来说是非常适合的，因为它在
    DOM 中渲染视图。对于更底层的任务，Backbone 利用 Underscore 的能力。由于 Backbone 利用这些库，它能够保持较小的代码体积。此外，由于它遵循简单的模式，它基本上不会干扰开发者，让他们能够根据特定用例调整库。
- en: There's an entire ecosystem surrounding Backbone, and Lo-Dash is a part of this
    ecosystem. Since it was originally conceived as a drop-in replacement for Underscore,
    Lo-Dash integrates closely with Backbone. In this section, we'll look at replacing
    Underscore in a Backbone application and extending Backbone's capabilities with
    functionality not found in Underscore.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕 Backbone 有一个完整的生态系统，Lo-Dash 是这个生态系统的一部分。由于它最初被构想为 Underscore 的直接替代品，Lo-Dash
    与 Backbone 集成得非常紧密。在本节中，我们将探讨在 Backbone 应用程序中替换 Underscore 以及通过 Underscore 中找不到的功能扩展
    Backbone 的能力。
- en: Replacing Underscore.js
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换 Underscore.js
- en: 'Backbone requires both jQuery and Underscore. Since it''s wrapped as a UMD
    function, if we were to define Lo-Dash as an AMD module, it''s quite simple to
    replace. Let''s take a look at a RequireJS configuration that replaces Underscore
    with Lo-Dash:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 需要jQuery 和 Underscore。由于它被封装为 UMD 函数，如果我们把 Lo-Dash 定义为 AMD 模块，那么替换它相当简单。让我们看看一个用
    RequireJS 配置替换 Underscore 为 Lo-Dash 的例子：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the Backbone module loads, it looks for the `jquery` and the `underscore`
    modules, both of which we''ve provided here. You''ll notice that the `underscore`
    module points to `lodash.backbone.min`. This is a special Lo-Dash build that contains
    only the functions required by Backbone. In other words, it doesn''t have any
    extra stuff that Backbone doesn''t use internally. Now let''s define a simple
    model:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Backbone 模块加载时，它会查找 `jquery` 和 `underscore` 模块，这两个模块我们在这里都提供了。你会注意到 `underscore`
    模块指向 `lodash.backbone.min`。这是一个特殊的 Lo-Dash 构建，它只包含 Backbone 所需的函数。换句话说，它不包含 Backbone
    内部不使用的任何额外内容。现在让我们定义一个简单的模型：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that we require `underscore`, which is actually Lo-Dash, so we
    can use the `extend()` function. The Backbone model will also use Lo-Dash internally
    since it has the same Underscore requirement. Now let''s use this model:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们要求 `underscore`，实际上就是 Lo-Dash，因此我们可以使用 `extend()` 函数。Backbone 模型也将内部使用
    Lo-Dash，因为它有相同的 Underscore 需求。现在让我们使用这个模型：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The main reason you would drop Lo-Dash into Backbone like this is the improvement
    in speed and consistency Lo-Dash has over Underscore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你之所以会将 Lo-Dash 以这种方式集成到 Backbone 中，主要原因是 Lo-Dash 相比 Underscore 在速度和一致性方面的提升。
- en: Full-featured Lo-Dash and Backbone
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全功能的 Lo-Dash 和 Backbone
- en: 'As our application grows in sophistication, we''ll probably want more Lo-Dash
    functionality, despite this not being a strict requirement for Backbone. The alternative
    would be to replace Underscore with a full version of Lo-Dash. For this, we can
    use the AMD build of Lo-Dash. Here''s a modified version of the RequireJS configuration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得更加复杂，我们可能会需要更多 Lo-Dash 功能，尽管这并不是 Backbone 的严格要求。另一种选择是用 Lo-Dash 的完整版本替换
    Underscore。为此，我们可以使用 Lo-Dash 的 AMD 构建。以下是一个修改后的 RequireJS 配置示例：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is similar to the previous configuration, except that it doesn''t require
    a shim to export the `_` symbol and it points to the `main` Lo-Dash module. Let''s
    redefine our model using this approach:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置与之前的配置类似，只不过它不需要一个垫片来导出 `_` 符号，并且它指向 `main` Lo-Dash 模块。让我们使用这种方法重新定义我们的模型：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this version of our model definition, we do not require Underscore. In fact,
    we only require one specific Lo-Dash function—`assign()`—in addition to Backbone.
    Mind you, Backbone will still load the entire Lo-Dash API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的模型定义中，我们不需要 Underscore。实际上，我们只需要除了 Backbone 之外的一个特定的 Lo-Dash 函数——`assign()`。请注意，Backbone
    仍然会加载整个 Lo-Dash API。
- en: Enhancing collections and models
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强集合和模型
- en: 'If we require the full version of Lo-Dash, we can extend the capabilities of
    Backbone collections fairly easily. Let''s define an extension module that extends
    Backbone collections with methods not found in Underscore:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求 Lo-Dash 的完整版本，我们可以相当容易地扩展 Backbone 集合的功能。让我们定义一个扩展模块，该模块将不在 Underscore
    中找到的方法扩展到 Backbone 集合中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This module, whenever required, will extend the `Backbone.Collection` prototype
    with two new methods, `takeRight()` and `dropWhile()`. Note that it returns Backbone,
    so whenever we require Backbone, we can just use this module and get the extended
    version as a result. Let''s see this extended collection in use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块在需要时，将两个新方法 `takeRight()` 和 `dropWhile()` 扩展到 `Backbone.Collection` 原型上。请注意，它返回
    Backbone，所以每次我们要求 Backbone 时，我们都可以使用此模块并获取扩展版本作为结果。让我们看看这个扩展集合的使用情况：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the collection now has a `takeRight()` and a `dropWhile()` method—something
    that's easy to add since the functions are already implemented by Lo-Dash. We
    just need to glue the parts together, the same way as Backbone does with Underscore
    functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，集合现在有了 `takeRight()` 和 `dropWhile()` 方法——由于这些函数已经由 Lo-Dash 实现，所以很容易添加。我们只需要将这些部分粘合在一起，就像
    Backbone 对 Underscore 函数所做的那样。
- en: Node.js
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: In the closing section of this chapter, we'll turn our attention to writing
    Lo-Dash code for the backend. This of course means installing Lo-Dash as a Node.js
    package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾部分，我们将把注意力转向编写用于后端的 Lo-Dash 代码。这当然意味着将 Lo-Dash 作为 Node.js 包安装。
- en: Installing the Lo-Dash package
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Lo-Dash 包
- en: 'Assuming you already have Node installed, since you had to do so in order to
    run the `grunt` command in the RequireJS examples, you should have an `npm` command
    on your system. If that''s the case, installation is incredibly easy:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了 Node，因为你必须这样做才能在 RequireJS 示例中运行 `grunt` 命令，你应该在你的系统上有一个 `npm` 命令。如果是这样，安装将非常简单：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will install Lo-Dash globally, meaning it''s accessible to any other Node
    project that wishes to use it. This is probably a good idea since Lo-Dash is a
    library after all. To verify that the installation was a success, you can run
    the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局范围内安装 Lo-Dash，这意味着它对任何希望使用它的其他 Node 项目都是可访问的。这可能是好主意，因为毕竟 Lo-Dash 是一个库。为了验证安装成功，你可以运行以下命令：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you see a long error message, it means that something went wrong at the time
    of installation. If it exists silently, you're all set.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个长的错误消息，这意味着在安装时出了问题。如果它静默存在，那么你就设置好了。
- en: Creating a simple command
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的命令
- en: 'To get our hands dirty with Node.js along with Lo-Dash development, let''s
    create a simple command that sorts a comma-separated input:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Lo-Dash 开发一起深入了解 Node.js，让我们创建一个简单的命令，该命令对逗号分隔的输入进行排序：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `args` variable is a Lo-Dash wrapper that contains the command arguments
    as a value. We'll call `size()` and `contains()` on this wrapper to validate the
    input. A second wrapper is created and stored in the `input` variable. This is
    the comma-separated list, where we're splitting the string and removing any excess
    whitespaces. Then we call `sortBy()` to sort the list and optionally reverse the
    order if the `-d` flag was set. The string is then joined back together. Calling
    `join()` will actually execute the function call chain, and this is the output
    of the command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 变量是一个 Lo-Dash 包装器，其中包含命令参数作为值。我们将在这个包装器上调用 `size()` 和 `contains()` 来验证输入。然后创建第二个包装器并存储在
    `input` 变量中。这是一个以逗号分隔的列表，我们将字符串分割并删除任何多余的空白。然后我们调用 `sortBy()` 来排序列表，如果设置了 `-d`
    标志，则可选地反转顺序。然后将字符串重新连接起来。调用 `join()` 实际上会执行函数调用链，这是命令的输出。'
- en: Custom Lo-Dash builds
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Lo-Dash 构建
- en: 'Another good reason to have Node.js installed is that you can install the `lodash-cli`
    package, which is the Lo-Dash build system. Using this tool, you can create custom
    builds on the fly and at a granular level. Right down to the function, you can
    specify what''s included or what''s excluded using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个安装 Node.js 的好理由是你可以安装 `lodash-cli` 包，这是 Lo-Dash 的构建系统。使用这个工具，你可以实时地以细粒度创建自定义构建。甚至可以指定到函数级别，使用以下命令来指定包含或排除的内容：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will run an AMD build of Lo-Dash for us, only including what's necessary
    for functions in the `function` category.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们运行 Lo-Dash 的 AMD 构建，只包括 `function` 类别中的函数所必需的内容。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on using Lo-Dash in the broader context of frontend development.
    Achieving modularity is made easier with technologies such as RequireJS. We looked
    at several ways to do this, and Lo-Dash has built-in support for these types on
    environments. We learned that Lo-Dash is a very focused library, helping the developer
    to write clean and efficient code while ignoring other things. The things that
    Lo-Dash isn't good at are nicely covered by other stable libraries such as jQuery
    and Backbone. We also wrote some Lo-Dash code that directly helps these libraries,
    both from a performance perspective and a functionality perspective.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了在更广泛的前端开发背景下使用 Lo-Dash。借助 RequireJS 等技术，实现模块化变得更加容易。我们探讨了多种实现方式，Lo-Dash
    在这些环境类型上提供了内置支持。我们了解到 Lo-Dash 是一个非常专注的库，帮助开发者编写干净且高效的代码，同时忽略其他事物。Lo-Dash 不擅长的地方则被其他稳定的库如
    jQuery 和 Backbone 优雅地覆盖。我们还编写了一些 Lo-Dash 代码，这些代码直接帮助这些库，无论是在性能方面还是在功能方面。
- en: We closed the chapter with a look at Node.js, and how it's possible to write
    Lo-Dash code for applications that run outside the browser. There's also a Node
    package that is used to build Lo-Dash and you can customize these builds to include
    whatever you like. Now that we've covered much ground on what you can do as a
    Lo-Dash programmer from the outside, let's take a look at the inside of Lo-Dash.
    Knowing how and why certain things are designed will better inform your decisions,
    in the interest of better performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以对 Node.js 的探讨结束本章，以及如何为运行在浏览器之外的程序编写 Lo-Dash 代码。还有一个用于构建 Lo-Dash 的 Node 包，你可以自定义这些构建以包含你喜欢的任何内容。现在我们已经从外部了解了作为一个
    Lo-Dash 程序员你能做什么，让我们来看看 Lo-Dash 的内部。了解某些事物是如何和为什么被设计出来的，将更好地帮助你做出决策，以实现更好的性能。
