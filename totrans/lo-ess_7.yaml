- en: Chapter 7. Using Lo-Dash with Other Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter showed us what our Lo-Dash code starts to look like as
    it falls in place within a larger application. Things get factored into a more
    generic, reusable form, and they're named and structured consistently. Patterns
    start to emerge, and as your code starts to realize these patterns, it takes the
    shape of a production-ready system.
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of deploying Lo-Dash code to a production environment, this chapter
    addresses the ecosystem into which our code is tossed when deemed stable. Lo-Dash
    does a lot, but there are some tasks that this library is simply not well suited
    for. In other words, it's highly unlikely that Lo-Dash is the only library your
    application will use.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to keep our code organized and modular is by using modules. Module
    technology has gained a lot of attention over the last few years in the JavaScript
    community, and Lo-Dash is no exception. We can make it work using the same module
    loaders that applications use. There are also Lo-Dash packages available for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've done any frontend development in the past few years, you have probably
    heard of AMD modules, if you haven't already experimented with them. AMD is growing
    fast, with no shortage of production deployments around the world. This modular
    movement in frontend development stemmed from a lack of a decent way to organize
    large-scale projects that have many dependencies. Before modules for the web were
    a thing, the only tool at our disposal for organizing dependencies was the `<script>`
    element. This is still an accepted way to pull in JavaScript code—except when
    there are hundreds of modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity, especially frontend web development modularity, is a large topic—too
    large for this book (let alone for this chapter) to properly address. So let's
    strip the topic down to the relevant parts for us, the Lo-Dash programmers. It's
    good programming practice to divide our code into modules that serve a single
    purpose. This provides a good separation of concerns and allows our components
    to evolve more easily and independently of one another.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a look at **RequireJS**, one of the leading AMD
    module loader technologies available. Lo-Dash has builds that help us utilize
    this technology and construct modules of our own. With that said, let's get into
    some of the practical nitty-gritty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**AMD** stands for **asynchronous module definition**, a simple pattern followed
    by many JavaScript components. It''s not a recognized specification, although
    something is brewing in the upcoming ES6 specification. There''s a related pattern
    called UMD, which aims to be more universal than AMD and has some questionable
    fallback modes. My advice is to stick to something that''s easy to use, such as
    RequireJS, until there''s an adopted standard that''s widely supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your code with modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see what a basic module looks like. The idea is that a definition function
    returns the component that the module defines. The component could be a function,
    an object, a string, or any value for that matter. If you're developing a Lo-Dash
    application, your modules are likely to return functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since RequireJS makes XHR requests, it''s a lot easier to serve your JavaScript
    modules with a simple static web server. The code that is shipped with this book
    has a `Gruntfile`, which lets you run a simple web server. However, you''ll need
    Node.js installed. There are plenty of resources all over the Internet that can
    be used to install Node on any platform. Once Node is available, you can install
    Grunt with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the `grunt` command available on your system. From within the
    root code directory, where the `Gruntfile.js` file is located, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You'll see some output about the server running forever. Pressing *Ctrl* + *C*
    will stop it. And that's it! You can navigate to `http://0.0.0.0:8000/chapter7.html`
    to run the examples from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the `define()` function takes two arguments. The first is
    an array of modules that we''re dependent on and the second is a function that
    returns the component this module defines. In this case, our module doesn''t have
    any external dependencies and it returns an anonymous function. This function
    takes a `coll` and a `filter` argument. Then we use the Lo-Dash constructor to
    wrap the collection and we reduce it to the average value. Next, let''s take a
    look at how this module gets used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that our call to the `require()` function passes an array of
    module dependencies. In this case, we're dependent on the `average-age` module.
    The function callback is triggered when this module is loaded, evaluated, and
    ready to use. The `averageAge` argument is the value returned by the module. In
    this case, it's the function we defined earlier, and we show how it can be applied
    to a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring Lo-Dash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The downside to our `average-age` module is that it doesn't define any explicit
    dependencies. Yet, it clearly depends on Lo-Dash being available. So how does
    this code even work? Where does the `_` variable get defined? Well, the only reason
    the preceding example runs is because we've included Lo-Dash on the page using
    the standard `<script>` tag. This adds the `_` symbol to the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This goes against one of the grounding principles of modules—there shouldn''t
    be a need for global variables. What we end up with are implicit dependencies,
    as is the case in the previous code. This means our modules that use this implicit
    dependency aren''t as portable as they could be. If that `<script>` tag goes away,
    our module stops working. Thankfully, we can define our modules that depend on
    Lo-Dash as having this dependency explicitly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that instead of passing an empty array as the first argument
    to `define()`, we have a string that points to the Lo-Dash module. Now the `_`
    symbol is an argument within our `define()` function instead of being referenced
    globally. Let''s see this module being put to use now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we require our `sort-name` module as a dependency and the `sortName()`
    function is an argument to the `require()` callback function. The function sorts
    an input collection by name and returns a wrapper instance. This is illustrated
    here, by calling `sortBy()` followed by `value()`. This is actually a good thing
    because it means that the returned wrapper instance can be extended before it
    is evaluated and unwrapped.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice that we're indirectly depending on Lo-Dash here because we
    depend on `sort-name`. We can call the `value()` function and extend the returned
    wrapper without an explicit reference to the `_` symbol. This means that, should
    the `sort-name` module no longer rely on Lo-Dash at some point in the future,
    our function will still work, although we might have to remove the `value()` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another step involved with getting Lo-Dash to work with RequireJS.
    Let''s take a look at the `main.js` configuration file that helps RequireJS figure
    out where to find modules and what they expose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our code referenced `lodash` as a dependency. This path configuration tells
    RequireJS where to find that module. The `shim` configuration section is for modules
    that aren't defined as AMD modules. Since this is the case with Lo-Dash, we have
    to add a shim that tells RequireJS what's actually returned when something requires
    the concerned module.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lo-Dash AMD modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that there''s a better way to use Lo-Dash in the form of AMD modules.
    Lo-Dash has specific AMD builds available for download and these don''t require
    a shim. Another benefit of obtaining Lo-Dash components this way is that we don''t
    have to pull down the entire library if we depend on only a handful of functions.
    For example, let''s see how we can depend on function categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We're using the AMD build of Lo-Dash in this example. This is made apparent
    by the module path that we require. The `collection` module is defined as an AMD
    module and contains all the collection-related functions. You can see that we're
    using the `_` symbol as the function argument. This means the code that uses the
    collection functions can be written just as if it is using any Lo-Dash module.
    For instance, if we were to require the full Lo-Dash API instead of just the collection
    functions, none of the code would need to change. Instead, we're only requiring
    a subset of Lo-Dash, thus saving the network delivery cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is using the `invoke()` function on our collection to call the `name()`
    method on each item while collecting the results. However, that''s only one function.
    There''s still a lot in the collections category that we require and are not using
    at all. Let''s see how we can use more fine-grained Lo-Dash function dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see when you drill into the categories, there's a specific module
    for any given function you'd like to include. The preceding code is using two
    Lo-Dash functions. The `filter()` function comes from the collection category
    and the `partial()` function comes from the function category. Both functions
    are passed directly as callback arguments. Since both of these function modules
    are themselves defined as AMD modules, they require only the internal dependencies
    needed to work. This means that we're only requiring what we need, which might
    only be one or two functions in certain contexts, such as our preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside to this level of granularity is that if you''re unsure of what
    you need, you''ll constantly have to modify your list of model dependencies. Lo-Dash
    has a lot to offer, and it''s a good idea to utilize Lo-Dash functions wherever
    you can. For example, if you''re wrapping values and chaining together function
    calls, it''s tough to know in advance which functions you''re going to require.
    So it''s probably a good idea to obtain the whole API so that there''s no possibility
    of something you want to use not being there. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to our first example, where we required the entire Lo-Dash API.
    The difference here is that this is the AMD build, so we require the `main` Lo-Dash
    module, which includes everything we'll need. The other difference is that with
    this approach, there's no need to set up paths or shims within the main RequireJS
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jQuery is undoubtedly one of the most successful and widely used technologies
    of all time. And it came into being because of browser inconsistencies; John Resig
    decided to do something about it. Rather than having the application developers
    maintain their own code that deals with all the mundane cross-browser issues,
    why not let jQuery handle that stuff for them?
  prefs: []
  type: TYPE_NORMAL
- en: jQuery has evolved over the years, thanks to thousands and thousands of users
    and contributing developers wanting to make frontend development less intimidating.
    Over time, it has changed certain aspects of itself and added new features to
    keep up with the changing environments in which it resides.
  prefs: []
  type: TYPE_NORMAL
- en: It's safe to say that jQuery has changed the way frontend development is done
    and will continue to do so because of its mass adoption. Several web standards
    that exist today are rooted in jQuery. Lo-Dash is similar to jQuery in a lot of
    ways. While it's not nearly as mature as jQuery, it's being rapidly adopted. Like
    jQuery, Lo-Dash originated from an effort to fix cross-browser issues and performance
    issues present in Underscore.js. The development effort of Lo-Dash has expanded
    much beyond a simple drop-in replacement for Underscore.js and will certainly
    influence future JavaScript specifications.
  prefs: []
  type: TYPE_NORMAL
- en: So jQuery and Lo-Dash are similar in their effectiveness. Where they differ
    is in the specific problems they solve for programmers. Let's take a closer look
    at those and see whether there is a way in which the two libraries can complement
    one another.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges faced by Lo-Dash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lo-Dash is a low-level framework that augments JavaScript at the language level.
    Low-level is a relative term. It's not that Lo-Dash doesn't have any abstractions;
    it has plenty. It's just that there's a lot more to frontend development than
    just JavaScript. Lo-Dash isn't good at any of those other things, nor is it intended
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: While you can use Lo-Dash to write better code, that's only half the battle.
    Standalone JavaScript code doesn't get you very far. If you're developing an application,
    at some point, you're going to eventually touch the DOM. You're going to make
    API calls that load your application data and change the state of the server-side
    resources. You're also going to deal with the asynchronous nature of these calls
    and user events, while taking care to perform well and prevent leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend development is a complicated endeavor but Lo-Dash is great for all
    things in JavaScript. Writing concise, readable code that performs well is where
    Lo-Dash shines. This generally means the core of your frontend code. For everything
    else, there are other libraries, such as jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges faced by jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons jQuery is so attractive to programmers is its low barrier
    to entry. Anyone building a website can immediately learn and benefit from jQuery,
    often in a day or two. At the same time, it's powerful enough to scale from a
    basic site to a powerful web application. DOM traversal and manipulation are one
    thing jQuery excels at, but it's also capable of dealing with complicated Ajax
    calls, DOM events, and asynchronous callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the areas Lo-Dash lacks any support in. Again, this is intentional.
    The two libraries serve different purposes. However, they're also complementary
    and often sit side by side in the same application, carrying out their roles.
    What jQuery doesn't have is a set of tools to aid the programmer inside all of
    these callback functions that run in response to Ajax requests, user events, and
    so on. This is not what it's meant for. You're free to use any library you like
    to enhance the core application business logic, and Lo-Dash is one such choice.
  prefs: []
  type: TYPE_NORMAL
- en: The focused nature of both Lo-Dash and jQuery leaves us with a clear separation
    of concerns. jQuery lets the Lo-Dash programmer worry about creating high-quality
    functional code. We've already seen how to utilize RequireJS with Lo-Dash in an
    effort to produce modular components. Let's now look at how we can use Lo-Dash
    alongside jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery instances as collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps, the most common use case of jQuery is querying the DOM for elements.
    The result is a jQuery object that closely resembles an array. We can exercise
    our Lo-Dash know-how to treat these instances as collections. For example, let''s
    compare the jQuery `map()` function to the Lo-Dash `map()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The mapped output of both approaches is exactly the same. Even the code differences
    are subtle at best. The difference is only in the looping performance—the Lo-Dash
    `map()` function will always have an edge over the jQuery `map()` function due
    to the differences in implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following chapter goes into greater detail on why iterative Lo-Dash functions
    perform the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: The performance gain isn't all that great. What's a few milliseconds here and
    there? The preceding example only finds a handful of elements, and the test is
    repeated 1,000 times. In production, you're probably going to be dealing with
    larger query results, iterated more than 1,000 times, and over time, the milliseconds
    start to add up.
  prefs: []
  type: TYPE_NORMAL
- en: Is there anything fundamentally wrong with the performance of jQuery `map()`?
    Absolutely not. If it works, use it. This change itself isn't going to pleasantly
    surprise your users. On the other hand, if you're a Lo-Dash programmer, you're
    going to use it for what it's good at. Lo-Dash is very good at iterating over
    collections. jQuery is very good at querying the DOM, and it still takes up this
    responsibility. So what's the code cost of implementing this improvement? Essentially
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: Binding functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we looked at an area where Lo-Dash and jQuery overlap.
    We chose the Lo-Dash approach because it made sense to do so, both from a responsibility
    perspective (iterating over collections) and a cost-to-implement perspective (the
    code looks nearly identical). Another area of overlap is function binding. jQuery
    has tools available to bind functions to a given context, but Lo-Dash has better
    functional tools. Let''s compare the two approaches again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches reduce the collection to the same result. The code is basically
    identical; the only difference is the way the callback passed to `reduce()` is
    bound. The context we're binding the functions to is a plain object with a `multiplier`
    property that's looked up when the callback is run. It's looked up by referencing
    `this`, which is why we have to bind the context before passing the callback to
    the `reduce()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach uses the `proxy()` jQuery function while the second approach
    uses the Lo-Dash `bind()` function. As with the preceding example of `map()`,
    the performance edge goes to Lo-Dash, there's no cost to implement it, and it's
    something that Lo-Dash was designed to do well. So if you're passing callbacks
    to jQuery event functions, `bind()` is just as viable as `proxy()` and is within
    the scope of something Lo-Dash is good at.
  prefs: []
  type: TYPE_NORMAL
- en: Working with jQuery deferred instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen how Lo-Dash can aid in iterating over DOM elements after they''ve
    been queried by jQuery. We''ve also seen how Lo-Dash can improve function bindings
    in our jQuery code. Let''s turn things around and see where jQuery can help our
    Lo-Dash code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we're utilizing the `Deferred` jQuery object. This is something that's
    returned by a function that does something asynchronously. Once the caller has
    possession of the deferred instance, it serves as a channel between the caller
    and the function. When the function is done with its asynchronous work, it notifies
    the caller and a callback function is run. There's a whole bunch of tricks we
    can perform with deferred instances, but we'll keep it straightforward here.
  prefs: []
  type: TYPE_NORMAL
- en: The job of the `query()` function we've implemented is to wrap the collection
    in a Lo-Dash wrapper and filter it using the `filter` argument. If the `sort`
    argument was provided, we sort the collection as well. The asynchronous work happens
    when we check the size of the collection. Note that we haven't actually executed
    any of the chained function calls yet, because we haven't called `value()`. If
    the collection contains more than 5,000 items, we use the Lo-Dash `defer()` function
    to clear the JavaScript call stack before executing `value()`. If the collection
    contains less items, we execute the filter immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The result of calling `value()` is passed to the caller through the jQuery deferred
    instance, using the `resolve()` function. What's nice about this function is that
    it's always asynchronous to the caller. Even when we have smaller collections,
    it's still treated as asynchronous. The output illustrates when our randomized
    collection has more than 5,000 items, and the filter is deferred. When we see
    the `awaiting results` message, it means that the control had returned to the
    caller before the query was executed. This is the idea; since the collection is
    large, we let other things happen first in case the filter takes a while to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike jQuery, Backbone is a library that's concerned with creating higher-level
    abstractions for the application. Things such as models, collections, and views
    are concepts that the Backbone programmer extends to provide seamless integration
    with the API data.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone recognizes its own strengths and utilizes other libraries such as jQuery
    and Underscore to implement certain things such as fetching and saving data. This
    is a job well suited for jQuery as is rendering views in the DOM. For lower-level
    tasks, Backbone utilizes Underscore's capabilities. Because Backbone leverages
    these libraries, it's able to maintain a small code footprint. Moreover, since
    it follows simple patterns, it more or less stays out of the developer's way,
    letting them adapt the library to specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's an entire ecosystem surrounding Backbone, and Lo-Dash is a part of this
    ecosystem. Since it was originally conceived as a drop-in replacement for Underscore,
    Lo-Dash integrates closely with Backbone. In this section, we'll look at replacing
    Underscore in a Backbone application and extending Backbone's capabilities with
    functionality not found in Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Underscore.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone requires both jQuery and Underscore. Since it''s wrapped as a UMD
    function, if we were to define Lo-Dash as an AMD module, it''s quite simple to
    replace. Let''s take a look at a RequireJS configuration that replaces Underscore
    with Lo-Dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the Backbone module loads, it looks for the `jquery` and the `underscore`
    modules, both of which we''ve provided here. You''ll notice that the `underscore`
    module points to `lodash.backbone.min`. This is a special Lo-Dash build that contains
    only the functions required by Backbone. In other words, it doesn''t have any
    extra stuff that Backbone doesn''t use internally. Now let''s define a simple
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we require `underscore`, which is actually Lo-Dash, so we
    can use the `extend()` function. The Backbone model will also use Lo-Dash internally
    since it has the same Underscore requirement. Now let''s use this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The main reason you would drop Lo-Dash into Backbone like this is the improvement
    in speed and consistency Lo-Dash has over Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Full-featured Lo-Dash and Backbone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our application grows in sophistication, we''ll probably want more Lo-Dash
    functionality, despite this not being a strict requirement for Backbone. The alternative
    would be to replace Underscore with a full version of Lo-Dash. For this, we can
    use the AMD build of Lo-Dash. Here''s a modified version of the RequireJS configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to the previous configuration, except that it doesn''t require
    a shim to export the `_` symbol and it points to the `main` Lo-Dash module. Let''s
    redefine our model using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this version of our model definition, we do not require Underscore. In fact,
    we only require one specific Lo-Dash function—`assign()`—in addition to Backbone.
    Mind you, Backbone will still load the entire Lo-Dash API.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing collections and models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we require the full version of Lo-Dash, we can extend the capabilities of
    Backbone collections fairly easily. Let''s define an extension module that extends
    Backbone collections with methods not found in Underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This module, whenever required, will extend the `Backbone.Collection` prototype
    with two new methods, `takeRight()` and `dropWhile()`. Note that it returns Backbone,
    so whenever we require Backbone, we can just use this module and get the extended
    version as a result. Let''s see this extended collection in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the collection now has a `takeRight()` and a `dropWhile()` method—something
    that's easy to add since the functions are already implemented by Lo-Dash. We
    just need to glue the parts together, the same way as Backbone does with Underscore
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the closing section of this chapter, we'll turn our attention to writing
    Lo-Dash code for the backend. This of course means installing Lo-Dash as a Node.js
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Lo-Dash package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming you already have Node installed, since you had to do so in order to
    run the `grunt` command in the RequireJS examples, you should have an `npm` command
    on your system. If that''s the case, installation is incredibly easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install Lo-Dash globally, meaning it''s accessible to any other Node
    project that wishes to use it. This is probably a good idea since Lo-Dash is a
    library after all. To verify that the installation was a success, you can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you see a long error message, it means that something went wrong at the time
    of installation. If it exists silently, you're all set.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get our hands dirty with Node.js along with Lo-Dash development, let''s
    create a simple command that sorts a comma-separated input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `args` variable is a Lo-Dash wrapper that contains the command arguments
    as a value. We'll call `size()` and `contains()` on this wrapper to validate the
    input. A second wrapper is created and stored in the `input` variable. This is
    the comma-separated list, where we're splitting the string and removing any excess
    whitespaces. Then we call `sortBy()` to sort the list and optionally reverse the
    order if the `-d` flag was set. The string is then joined back together. Calling
    `join()` will actually execute the function call chain, and this is the output
    of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Lo-Dash builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another good reason to have Node.js installed is that you can install the `lodash-cli`
    package, which is the Lo-Dash build system. Using this tool, you can create custom
    builds on the fly and at a granular level. Right down to the function, you can
    specify what''s included or what''s excluded using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will run an AMD build of Lo-Dash for us, only including what's necessary
    for functions in the `function` category.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on using Lo-Dash in the broader context of frontend development.
    Achieving modularity is made easier with technologies such as RequireJS. We looked
    at several ways to do this, and Lo-Dash has built-in support for these types on
    environments. We learned that Lo-Dash is a very focused library, helping the developer
    to write clean and efficient code while ignoring other things. The things that
    Lo-Dash isn't good at are nicely covered by other stable libraries such as jQuery
    and Backbone. We also wrote some Lo-Dash code that directly helps these libraries,
    both from a performance perspective and a functionality perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We closed the chapter with a look at Node.js, and how it's possible to write
    Lo-Dash code for applications that run outside the browser. There's also a Node
    package that is used to build Lo-Dash and you can customize these builds to include
    whatever you like. Now that we've covered much ground on what you can do as a
    Lo-Dash programmer from the outside, let's take a look at the inside of Lo-Dash.
    Knowing how and why certain things are designed will better inform your decisions,
    in the interest of better performance.
  prefs: []
  type: TYPE_NORMAL
