<html><head></head><body>
        

                            
                    <h1 class="header-title">Onboarding Types with Primitive</h1>
                
            
            
                
<p>Primitive types are all the basic supported categories of value. Each type represents a domain of values in which the integrity of the format is enforced. JavaScript has a limited set of primitives that can only be inferred by the assignation of a value to a variable. For example, a value can be a number, a date, a Boolean, a string, and so on. The assignation of a subsequent value of a different model to a singular variable is permitted. The side effect is the mutation of the type, which increases the complexity of any JavaScript program. TypeScript, however, can enforce type immutability, which reduces the risk of a potential wrong value that misleads the proper execution of the application. Also, TypeScript provides support on which operation can be used, depending on which explicit type is attached to a particular value. This chapter illustrates the scoping of a variable, the subtlety between an undefined variable and a null variable, and how to make a variable optional or required. At the end of this chapter, the reader will be in a situation where all the variables will be declared properly, with an accurate type supported by TypeScript. The distinction between a primitive and a non-primitive type will no longer be a conundrum. The use of <kbd>enum</kbd> or symbol will be natural and the creation of new types will become a habit any time a new domain object is introduced in your system.</p>
<p>This chapter will cover the following:</p>
<ul>
<li>The difference between <kbd>var</kbd>, <kbd>let</kbd>, and <kbd>const</kbd></li>
<li>How to be strongly typed without specifying the type</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The difference between var, let, and const</h1>
                
            
            
                
<p>TypeScript has many ways to declare a variable. You can define a variable at a function or global scope using one of the three following keywords: <kbd>var</kbd>, <kbd>let</kbd>, and <kbd>const</kbd>. Also, you can define a variable with <kbd>public</kbd>, <kbd>private</kbd>, or <kbd>protected</kbd> at the class level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring with var</h1>
                
            
            
                
<p>The most basic way to declare a variable is by using the keyword <kbd>var</kbd>.  It is the oldest declaration, but the least-preferred way because of some quirks. The main issue with <kbd>var</kbd> is that it gets declared in the execution context, which means inside the function scope or at the global scope. If, by accident a value is assigned to a variable not explicitly declared with <kbd>var</kbd>, then the scope of the variable is at the global scope. Here is an example:</p>
<pre>function f1(){<br/>   a = 2; // No explicit "var", hence global scope instead of function scope<br/>}</pre>
<p>A <kbd>var</kbd> declaration can be made stricter with the strict mode in JavaScript so that TypeScript can turn on every file automatically by using <kbd>alwaysStrict</kbd> in its compiler's options. Otherwise, you must remember that <kbd>var</kbd>–declared variables are created before the execution of the code. Variables without the keyword <kbd>var</kbd> do not exist until the code assigning them is executed. In JavaScript, it's possible to assign a variable without declaring, which is not the case with TypeScript:</p>
<pre>a = 2; // Won't create a variable in TypeScript</pre>
<p>While TypeScript can protect against an undeclared variable, it does not protect a <kbd>var</kbd> declaration against the side effect of <strong>hoisting</strong>. The issue comes from JavaScript, where a declaration with <kbd>var</kbd> is processed before other pieces of code, which brings the variable declaration to the top of the scope (function or global). The subtlety is that the declaration is moved up, but not the initialization. That being said, TypeScript will not let you use a variable defined under its usage:</p>
<pre>console.log("Test", a); // Won’t allow to use the variable in TypeScript<br/>var a = 2;</pre>
<p>Finally, <kbd>var</kbd> lets you define the variable that overrides the initial declaration or initialization more than once:</p>
<pre>var a = 2;<br/>var a = 23;</pre>
<p>Generally, the use of <kbd>var</kbd> is a dated way to declare a variable. With TypeScript, there is a big incentive to rely on <kbd>let</kbd> or <kbd>const</kbd> because you can generate an older ECMAScript version that will generate <kbd>var</kbd> but in a proper and valid format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring with let</h1>
                
            
            
                
<p>A <kbd>let</kbd> declaration is scope-based. It cannot be declared more than once per scope, and it does not hoist the variable. It simplifies the readability of the code, and it avoids unexpected errors. Declaring with <kbd>let</kbd> also doesn't set any values globally. Relying on <kbd>let</kbd> is the way to declare a variable when you expect the variable to be set more than once. In the following code, the variable <kbd>a</kbd> is defined three times. The code is legal, even with several declarations. The reason is that each declaration, with <kbd>let</kbd>, is defined in a different scope with curly braces. The first scope is the function scope. The second scope uses an unusual syntax, but it reflects how a <kbd>while</kbd>, <kbd>if</kbd>, or other scope feature works. The third scope is within an <kbd>if</kbd> statement:</p>
<pre>function letFunction() {<br/>   let a: number = 1;<br/>   { // Scope start<br/>     let a: number = 2;<br/>   } // Scope end<br/>   console.log(a); // 1<br/> <br/>   if(true){ // Scope start<br/>     let a: number = 3;<br/>    } // Scope end<br/>    console.log(a); // 1<br/>}<br/>letFunction()</pre>
<p>Furthermore, TypeScript ensures that once a declaration is done, the type associated with the variable is immutable. This means that a variable defined as a number will be a number for the rest of the lifespan of the variable:</p>
<pre>let a:number = 2;<br/>a = "two"; // Doesn’t compile</pre>
<p class="mce-root">Declaring a variable with <kbd>let</kbd> in a <kbd>switch</kbd> case can be tricky. The reason is the scoping is not by <kbd>case</kbd> but for the <kbd>switch</kbd> that hosts all the cases. However, it is possible to conceive a scope by summoning a curly bracket inside each <kbd>case</kbd>. The following code is valid even if two variables <kbd>b</kbd> are declared:</p>
<pre>function switchFunction(num: number) {<br/>   <strong>let b: string</strong> = "functionb";<br/><br/>   switch (num) {<br/>       case 1:<br/>      <strong>   let b: string</strong> = "case 1";<br/>       break;<br/>   }<br/>}</pre>
<p>However, adding a subsequent case that also declares a variable <kbd>b</kbd> fails the compilation:</p>
<pre>function switchFunction(num: number) {<br/><strong>  let b: string</strong> = "functionb";<br/><br/>  switch (num) {<br/>    case 1:<br/>    <strong> let b: string</strong> = "case 1";<br/>    break;<br/>    case 2:<br/>     <strong>let b: string</strong> = "case 2";<br/>    break;<br/>  }<br/>}</pre>
<p>The workaround for the default scope from the <kbd>switch</kbd> is to create an artificial scope for each case. The construction of the scope can be done by adding curly brackets, as shown in the following code:</p>
<pre>function switchFunction(num: number) {<br/>  let b: string = "functionb";<br/><br/>  switch (num) {<br/>    case 1: <strong>{</strong><br/>      let b: string = "case 1";<br/>    break;<br/>    <strong>} // After break</strong><br/>    case 2: <strong>{</strong><br/>      let b: string = "case 2";<br/>    <strong>} // Before break</strong><br/>    break;<br/>  }<br/><br/>}</pre>
<p><kbd>let</kbd> is one of the most-used declarations and should always be used instead of <kbd>var</kbd> when <kbd>const</kbd> is not a valid option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">const</h1>
                
            
            
                
<p>In the case where you know that the variable is set once and will not change, then using <kbd>const</kbd> is a better alternative. The reason is that it highlights to the reader of the code that the value cannot be set more than once—it is declared and initialized. TypeScript respects <kbd>let</kbd> and <kbd>const</kbd>, and the code will not compile if a variable is defined more than once or if a value is assigned twice when the variable is a constant.</p>
<p>Conscribing a variable to stay with a single value may look restrictive, but in many situations, it is the right thing to do. The declaration of a primitive with <kbd>const</kbd> blocks the access of assigning with the equals sign (<kbd>=</kbd>), which means that it does not allow you to change the reference of the variable. However, you can change the content of the variable. For example, an array of primitives can add and remove values from the array, but cannot assign a new list of values: </p>
<pre>const arr: number[] = [1, 2, 3];<br/>arr.push(4);</pre>
<p>The following code shows that a member can be edited, even if the object is declared as a constant. However, the <kbd>myObj</kbd> is not assignable. It means that the reference will always remain the same:</p>
<pre>const myObj: { x: number } = { x: 1 };<br/>myObj.x = 2;</pre>
<p>Finally, TypeScript, with the use of <kbd>let</kbd> and <kbd>const</kbd>, ensures that the value assigned to a variable is associated with the desired variable, and any faulty assignation will cause the compiler returning an error. In the following code, two variables are clearly defined at the global scope, as well as the function scope. There is no doubt that they are two distinct variables with any collusion of value:</p>
<pre>const a = 2;<br/>function z() {<br/>   let a = 3;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Enhancing primitives with TypeScript</h1>
                
            
            
                
<p>TypeScript has the same primitive variables as JavaScript. It is possible to declare a variable to hold a number, string, Boolean, and a symbol. Also, two primitives are available for a situation where no value is available: undefined and null. Finally, with these primitives, it's possible to have an array of each of them.</p>
<p>All primitives must use one declaration previously discussed with a unique variable name and use the colon followed by the word number. However, when used as a parameter of a function, the <kbd>declaration</kbd> keyword is avoided. There is no need to specify the scope of the variable because this one is for the function. The same goes for the visibility, which is only visible to the function receiving the parameter:</p>
<pre>function noNeedConstLetvar(parameter1: number) { }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Number</h1>
                
            
            
                
<p>TypeScript follows how JavaScript manipulates and carries the primitive type of a number by having a single type: number. A number can be an <kbd>integer</kbd>, a <kbd>float</kbd>, a <kbd>double</kbd>, negative, positive and even <kbd>NaN</kbd>.</p>
<p>A number cannot directly use a <kbd>boolean</kbd> value (neither <kbd>true</kbd>, neither <kbd>false</kbd>). A conversation by parsing the <kbd>boolean</kbd> is required:</p>
<pre>let boolean: number = true; // Won't compile</pre>
<p>There are many ways to convert a Boolean to a number. You can use the <kbd>Number</kbd> constructor that takes any value and converts it into a number of <kbd>1</kbd> for <kbd>true</kbd> and <kbd>0</kbd> for <kbd>false</kbd>:</p>
<pre> let boolean1: number = Number(true);<br/> let boolean2: number = Number(false);</pre>
<p>You can use the ternary operator and manually select the desired value, which can be beyond <kbd>1</kbd> and <kbd>0</kbd>:</p>
<pre>let boolean3: number = true ? 1 : 0;<br/>let boolean4: number = false ? 1 : 0;</pre>
<p>You can use the <kbd>+</kbd> sign to start an addition to the value, which automatically converts the <kbd>boolean</kbd> value to a number:</p>
<pre>  let boolean5: number = +true;<br/>  let boolean6: number = +false;</pre>
<p>A number cannot use a string directly either. Many techniques borrowed from JavaScript are available. The first one is using <kbd>Number</kbd>, and similar to the <kbd>boolean</kbd> case will parse the string into a number:</p>
<pre>  let string1: number = Number("123.5");<br/>  let string2: number = Number("-123.5");</pre>
<p>The second approach is using the <kbd>parseInt</kbd> function. The <kbd>parse</kbd> function has a second optional parameter that allows specifying the base. It is important to note that this should always be specified to avoid error with octal or hexadecimal:</p>
<pre>  let string3: number = parseInt("123.5", 10);<br/>  let string4: number = parseInt("-123.5", 10);</pre>
<p>You can use the <kbd>+</kbd> sign to add to the value, which automatically converts the string value to a number:</p>
<pre>  let string5: number = +"123.5";<br/>  let string6: number = +"-123.5";</pre>
<p>Converting a string into a number can be tricky if the string is written with <strong>numeric separators</strong>. A numeric separator allows writing a number in a human way by dividing the digit by an underscore. This increases the readability. For example, here are nine million one hundred:</p>
<pre>let numeric_separator: number = 9_000_100;</pre>
<p>Parsing a string with a numeric separator will fail, but this is also the case when using the <kbd>Number</kbd> approach as well as the <kbd>+</kbd> sign approach. The result is inconsistent and can be from <kbd>NaN</kbd> to parsing just the value before the first underscore. In that case, replacing all underscores and using one of the techniques previously mentioned would be the solution.</p>
<p>A number can be written in a different base. As in JavaScript, TypeScript uses the <kbd>0x</kbd> literal for hexadecimal, <kbd>0b</kbd> for binary, and <kbd>0o</kbd> for octal:</p>
<pre>  let number1: number = 0x10;<br/>  let number2: number = 0b10;<br/>  let number3: number = 0o10;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">String</h1>
                
            
            
                
<p>TypeScript is identical to JavaScript for a string. You can define a string between single quotes, double quotes, or backquotes. The single quote and double quote have the same function of assigning the string between the quotes to the variable:</p>
<pre>  let string1: string = 's1';<br/>  let string2: string = "s2";<br/>  let string3: string = `s3`;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The backquote, or backtick, has a special name, <strong>string interpolation</strong>, which allows injecting code inside the string. This is possible using a special syntax with the dollar sign and curly brackets:</p>
<pre>let interpolation1: string = `This contains the variable s1: ${string1} as well as ${string2}`;<br/>let interpolation2: string = `Can invoke variable function: ${string1.substr(0, 1)} as well as any code like this addition: ${1 + 1}`;<br/><br/>console.log(interpolation2);</pre>
<p>The last example produces this output: Can invoke the variable function: s as well as any code like this addition: 2.</p>
<p>Interpolation goes beyond just injecting other value and can run any TypeScript code. The previous example does an addition in the string. Another feature of string interpolation is that you can add a line break without having any compilation problem. With a single and a double quote, a string must be on the same line or be broken in several strings and concatenated with a <kbd>+</kbd> sign:</p>
<pre>  let multipleLine1: string = "Line1" +<br/>      "Line2";<br/><br/>  let multipleLine2: string = `Line1<br/>      Line2`;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Boolean</h1>
                
            
            
                
<p>A <kbd>boolean</kbd> type allows the lowercase <kbd>true</kbd> and <kbd>false</kbd> only. No number is authorized, neither different capitalization of the value. It's possible to convert a numeric value, that is <kbd>1</kbd> or <kbd>0</kbd>, by comparing it to <kbd>1</kbd>:</p>
<pre>  let bool1: boolean = true; // true<br/>  let bool2: boolean = false; // false<br/>  let bool3: boolean = 1 === 1; // true</pre>
<p>It is also possible to use the JavaScript <kbd>Boolean</kbd> construction to have a conversion. TypeScript doesn't remove the quirks that come along with the parsing but returns a strongly typed <kbd>bool</kbd> value of the constructor. Here are some examples that barely any work for the case of a string with the value <kbd>false</kbd>:</p>
<pre>let bool4: boolean = Boolean("true"); // true<br/>let bool5: boolean = Boolean("TRUE"); // true<br/>let bool6: boolean = Boolean("false"); // true<br/>let bool7: boolean = Boolean("FALSE"); // true<br/>let bool8: boolean = Boolean(NaN); // false<br/><br/>let bool9: boolean = new Boolean("true").valueOf(); // true<br/>let bool10: boolean = new Boolean("false").valueOf(); // true<br/><br/>let bool11: boolean = "true" as any as boolean; // true<br/>let bool12: boolean = "false" as any as boolean; // false</pre>
<p>Only the last two lines are a TypeScript specific solution where we cast the string to type and then back to a <kbd>boolean</kbd>. It is also one of the only solutions that work, other than comparing to the string directly as shown in the following code:</p>
<pre>let bool13 = isTrue("true"); // true<br/>let bool14 = isTrue("false"); // false<br/><br/>function isTrue(s: string): boolean {<br/>    return s.toLocaleLowerCase() === "true";<br/>}</pre>
<p>The preferred solution is to avoid casting to any. Casting opens the door to potential unexpected errors in most cases, even if in this particular situation, the casted value is controlled in this example, which could not be the case in a real scenario. The use of the <kbd>boolean</kbd> constructor is compelling but must be used carefully as the value <kbd>false</kbd> will result in a <kbd>boolean</kbd> <kbd>true</kbd> value. If the value is not controlled and part of a string, the safest way is to compare to use the <kbd>isTrue</kbd> function provided in this section of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Null</h1>
                
            
            
                
<p>The value <kbd>Null</kbd> can be assigned to a variable when the main value is not available. Without the compiler option, <kbd>strictNullChecks</kbd>, TypeScript allows having null or undefined. As a best practice, it's always better to set the strict null check and assign manually which of the variables can have both values. The reason is that you can carefully craft each variable and type with the right amount of flexibility around what is of the specific type or null or undefined, without having a door wide open. Every time a variable can be null, a check to null will be required before being able to use the object's properties:</p>
<pre>  let n1: string | null = Math.random() &gt; 0.5 ? null : "test";<br/>  // console.log(n1.substring(0, 1)); // Won't compile since can be null<br/><br/>  if (n1 !== null) {<br/>      console.log(n1.substring(0, 1));<br/>  }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The usage of <kbd>null</kbd> should be limited in TypeScript in favor of <kbd>undefined</kbd>. The reason will be explained in the <em>Undefined</em> section.</p>
<p>With <kbd>strictNullChecks</kbd> activated, the <kbd>null</kbd> value can only be assigned to a type allowing <kbd>null</kbd> or to a value of type any. To have a type accepting null, a union must be used:</p>
<div><pre>let primitiveWithNull: number | null = null;</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Undefined</h1>
                
            
            
                
<p>The <kbd>undefined</kbd> can be assigned to a variable when the main value is not available, similar to <kbd>null</kbd>:</p>
<pre>  let n2: string | undefined = Math.random() &gt; 0.5 ? undefined : "test";<br/>  // console.log(n2.substring(0, 1)); // Won't compile since can be null<br/><br/>  if (n2 !== null) {<br/>      console.log(n2.substring(0, 1));<br/>  }</pre>
<p>However, it has more cases. For example, an optional parameter (that we will discuss later in this book) is automatically set to <kbd>undefined</kbd> when not provided by the TypeScript. The reason is that when a property does not exist in JavaScript, it is undefined, not null:</p>
<pre>function f1(optional?: string): void {<br/>    if (optional === undefined) {<br/>        // Optional parameter was not provided OR was set to undefined<br/>    } else {<br/>        // The optional parameter is for sure a string (not undefined)<br/>    }<br/>}</pre>
<p>As mentioned, <kbd>undefined</kbd> is also the value returned if you are using square brackets to access an object property that doesn't exist using a string:</p>
<pre>  let obj = { test: 1 };<br/>  console.log(obj["notInObject"]);</pre>
<p><kbd>undefined</kbd> is also the value assigned to a field variable of a class when the class has not yet set the initial value from the constructor. This is only reproducible if the compiler option <kbd>strictPropertyInitialization</kbd> is set to <kbd>false</kbd>, which is a bad practice. As a good way to avoid having a field that is not explicitly mentioning <kbd>undefined</kbd> to be undefined because of a lack of initialization, the compiler option should always be <kbd>true</kbd>.</p>
<p class="mce-root"/>
<p>With <kbd>strictNullChecks</kbd> activated, the undefined value can only be assigned to a type allowing <kbd>undefined</kbd>, a type that is optional, or to a value of type any. To have a type accept <kbd>undefined</kbd>, a union must be used with the primitive and undefined. In the case of an optional, a function can use the question mark before the colon that specifies the primitive:</p>
<pre>let primitiveWithUndefined: number | undefined = undefined;<br/><br/>function functOptionalArg(primitiveOptional?: number): void {<br/>    // ...<br/>}<br/><br/>functOptionalArg();<br/>functOptionalArg(undefined);<br/>functOptionalArg(1);</pre>
<p>An <kbd>undefined</kbd> can also use the optional notation in a class or an interface as follows:</p>
<pre>interface InterfaceWithUndefined {<br/>    m1?: number;<br/>}</pre>
<p>Like a type in a union with <kbd>undefined</kbd>, an optional value can be verified by comparing against <kbd>undefined</kbd>:</p>
<pre>let i1: InterfaceWithUndefined = {};<br/>let i2: InterfaceWithUndefined = { m1: undefined };<br/><br/>console.log(i1.m1 === undefined); // True<br/>console.log(i2.m1 === undefined); // True</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Symbol</h1>
                
            
            
                
<p>A <kbd>Symbol</kbd> allows the creation of a value that is unique. A <kbd>Symbol</kbd> is different than a constant because two constants with the same value are equal, while this is not the case with two symbols with the same value. The constant variables work like any variable, by comparing the value. Comparisons with <kbd>Symbol</kbd> work differently. Every <kbd>Symbol</kbd> is unique, hence even with the same value, they are not the same. Let's see some examples:</p>
<pre>const s2 = Symbol("s");<br/>const c1 = "s";<br/>const c2 = "s";<br/><br/>if(isSymbolEqualS(s2)){<br/>    console.log("Symbols are equal"); // Won’t print<br/>}<br/><br/>if(c1 === c2){<br/>    console.log("Constants are equal");<br/>}<br/><br/>function isSymbolEqualS(p1:Symbol): boolean{<br/>    return Symbol("s") === p1;<br/>}<br/><br/></pre>
<p>The use of <kbd>Symbol</kbd> can ensure that the value provided is absolutely the one desired. It is not able to pass another constant with the same value, neither a string with the same value. Only the exact same symbol must be used:</p>
<pre class="mce-root">let s100 = Symbol("same");<br/>let s101 = Symbol("same");<br/><br/>if (s100 === s101) {<br/> console.log("Same"); // Won't print<br/>}</pre>
<p>Finally, <kbd>Symbol</kbd> can be used as an insurance when defining a field to an object. With the symbol, you can be sure to define every field once. A <kbd>Symbol</kbd> is by nature immutable:</p>
<pre>const field1 = Symbol("field");<br/>const obj = {<br/>    [field1]: "field1 value"<br/>};<br/><br/>console.log(obj[field1]); // Print "field1 value"</pre>
<p>TypeScript needs to know about the <kbd>Symbol</kbd> feature that was introduced in ES2015. Before using the <kbd>Symbol</kbd> keyword, the <kbd>tsconfig.json</kbd> must add <kbd>lib</kbd> to the array:</p>
<pre>"lib": [<br/> "es2015",<br/> "es2015.symbol"<br/> ]</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-primitive</h1>
                
            
            
                
<p>There is also a more advanced group of variables beyond the primitives. The non-primitive group includes <kbd>void</kbd>, <kbd>string literal</kbd>, <kbd>tuple</kbd>, <kbd>any</kbd>, <kbd>unknown</kbd>, and <kbd>never</kbd>; we will now discuss these variables.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">What is void?</h1>
                
            
            
                
<p>A <kbd>void</kbd> is a special and is used mainly for a function that returns no value. With an explicit return to <kbd>void</kbd>, the function cannot accept a return statement with a value that can occur with it; hence, it acts as a guard of potential error of returning a value. A <kbd>void</kbd> function can still have an empty return to leave the function before reaching the closing curly bracket. A <kbd>void</kbd> variable can only be assigned to <kbd>undefined</kbd>:</p>
<pre>let a: void = undefined;<br/>console.log(a);</pre>
<p>This is not useful, but it explains what happens if you return a function without a value to a <kbd>void</kbd> function:</p>
<pre>function returnNothing():void{<br/>      return;<br/>}<br/>console.log(returnNothing()); // undefined</pre>
<p>It is always a good practice to mark a function with <kbd>void</kbd> instead of using the implicit return value. The implicit return type for a function is a <em>weak</em> <em>void</em> because the function allows the returning of anything. The following function doesn't have a return type and was initially returning nothing. However, in its life, the function changed (as you will see next) and now returns three different values that are not like the previous ones. The <em>implicit returns</em> value is not void anymore. Having an explicit return type define a contract and indicate to anyone touching the function what is the expected return type and that should be respected. In this example code, the function returns a union of a Boolean, number, and string:</p>
<pre>function returnWithoutType(i: number) {<br/>    if (i === 0) {<br/>        return false;<br/>    } else if (i &lt; 0) {<br/>        return -1;<br/>    } else {<br/>        return "positive";<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The reasons to avoid using any type</h1>
                
            
            
                
<p>The <kbd>any</kbd> is a wildcard type that allows not only <kbd>any</kbd> type but also to change the type at will. There are many problems with <kbd>any</kbd>. The first one is that it is hard to follow what type is a variable; we are back to how JavaScript is written:</p>
<pre>let changeMe: any;<br/>changeMe = 1;<br/>changeMe = "string too";<br/>changeMe = false;</pre>
<p>The use of <kbd>any</kbd> should be avoided because it can hold a value that is not as expected and still it can compile because TypeScript does not know the type and cannot perform validation:</p>
<pre>let anyDangerous: any = false; // still not a boolean, neither a string<br/>console.log(changeMe.subString(0, 1)); // Compile, but crash at runtime</pre>
<p>The only reason to use <kbd>any</kbd> is in two situations. The first one is that you are migrating code from JavaScript to TypeScript. Migrating code can take a long time and TypeScript is built naturally in a way that you can be in a hybrid mode for a while. It means that not only you can turn down some strictness of the compiler options, but also that you can create functions, variables, and types that are not fully detailed in terms of type by allowing <kbd>any</kbd>.</p>
<p>The second situation where <kbd>any</kbd> is potentially acceptable is when you are in a situation that you cannot figure out the type in some advanced scenario and you must move on. The latter should be a signpost and must have a follow-up because we do not want to make it a habit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Usage of the never type</h1>
                
            
            
                
<p>The <kbd>never</kbd> is a variable that should never be set. This might sound useless at first but can be useful in a case where you want to ensure that nothing falls into a particular code path. A function rarely returns <kbd>never</kbd>, but it can happen. This is the case if you are having a function that does not allow you to finish the method to execute or return any variable; hence, it never fully returns. This can be coded using an exception:</p>
<pre>function returnNever(i: number): never {<br/><br/>  // Logic here<br/><br/>  if (i === 0) {<br/>      throw Error("i is zero");<br/>  } else {<br/>      throw Error("i is not zero");<br/>  }<br/><br/>  // Will never reach the end of the function<br/><br/>}</pre>
<p><kbd>Never</kbd> occurs when you are writing code and you are writing a condition that cannot occur and that TypeScript infers the type by the usage of your code. This can happen if you have several conditions and that one englobe another making some variable fall into the <kbd>never</kbd> scenario. It can also happen if you have all the variable values covered by condition and have an <kbd>else</kbd> statement (or default with a <kbd>switch case</kbd>). The value cannot have any other value than <em>never been assigned</em>, since all values are checked. Here is an illustration of the possibility:</p>
<pre>type myUnion = "a" | "b";<br/><br/>function elseNever(value: myUnion) {<br/>    if (value === "a") {<br/>        value; // type is “a”<br/>    } else if (value === "b") {<br/>        value; // type is “b”<br/>    } else {<br/>        value; // type is never<br/>    }<br/>}</pre>
<p>In practice, the <kbd>never</kbd> type is used for checking whether all values of an <kbd>enum</kbd> or a <kbd>union</kbd> have conditions that took care of all the values. This allows creating a validation when a developer adds a value to the <kbd>enum</kbd> or the <kbd>union</kbd> but forgets to add a condition. The lack of the condition makes the code fall through the exhaustive check. TypeScript is smart enough to verify all cases and understand that the code might go in the function that takes a <kbd>never</kbd> parameter, which is not allowed because nothing can be assigned to <kbd>never</kbd>:</p>
<pre>type myUnion = "a" | "b";<br/>let c: myUnion = Math.random() &gt; 0.5 ? "a" : "b";<br/><br/>if (c == "a") {<br/>    console.log("Union a");<br/>} else {<br/>    exhaustiveCheck(c); //”b” will fallthrough<br/>}<br/><br/>function exhaustiveCheck(x: never): never {<br/>    throw new Error("");<br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Unknown type to have a stricter any type</h1>
                
            
            
                
<p>TypeScript <kbd>unknown</kbd> type is a new addition to reduce the usage of <kbd>any</kbd>. When a variable is of type <kbd>unknown</kbd><em>,</em> everything can be set to the variable. However, the value <kbd>unknown</kbd> can only be set to another <kbd>unknown</kbd> type or <kbd>any</kbd> type. Here is a list of several rules about the <kbd>unknown</kbd> type:</p>
<ul>
<li>An <kbd>unknown</kbd> type can only be used with the equality operator; no other operator will compile.</li>
<li>A function that returns <kbd>unknown</kbd> does not require to return anything.</li>
<li>An intersection with the <kbd>unknown</kbd> type is useless because the type on which the unknown is intersected will take over. However, when used in a <kbd>union</kbd>, it will always take precedence and override any other type in the union.</li>
<li>A key of on an <kbd>unknown</kbd> type is always <kbd>never</kbd>.</li>
</ul>
<p>One use case of the type <kbd>unknown</kbd> is that it can be used when you do not know a type. Instead of relying on <kbd>any</kbd><em>,</em> which can accept everything and be passed along any code, the use of<kbd> unknown</kbd> restricts the flow of the variable. Since an unknown variable cannot be set to another variable, it forces the developer to properly scope down the value to its type and continue further along. Without the <kbd>unknown</kbd> type, <kbd>any</kbd> would have been the only option. It opens the door wide to accept anything and to:</p>
<pre>function f1(x: any): string {<br/> return x;<br/>}<br/><br/>function f2(x: unknown): string {<br/> return x; // Does not compile<br/>}</pre>
<p>In this example, the first function can take anything and expect to return a string. However, no cast or anything is required because a variable of type<kbd> any</kbd> can return a string. However, with an <kbd>unknown</kbd>, it must be handled. As mentioned, the reason is that the <kbd>unknown</kbd> type cannot be assigned to types other than<kbd> unknown</kbd> or <kbd>any</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enforcing a type in a list</h1>
                
            
            
                
<p>An array can be created in two different ways. The first is using the square brackets and by using the <kbd>Array</kbd> generic object. They are both interchangeable, and both of them can be typed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The square- bracket format is more compact, and it allows to specify the type before the squared brackets. The <kbd>Array</kbd> generic object specifies the type between the smaller/bigger sign:</p>
<pre>let arrayWithSquareBrackets: number[] = [1, 2, 3];<br/>let arrayWithObject: Array&lt;number&gt; = [1, 2, 3];<br/>let arrayWithObjectNew: Array&lt;number&gt; = new Array&lt;number&gt;(1, 2 ,3);</pre>
<p>It is possible to have an array holding more than one type of a type by combining the array type with a union:</p>
<pre>let arrayWithSquareBrackets2: (number | string)[] = [1, 2, "one", "two"];<br/>let arrayWithObject2: Array&lt;number | string&gt; = [1, 2, "one", "two"];</pre>
<p>TypeScript acts the same as in JavaScript, other than specifying the type for the array. You can access the content by using the index position and using all the methods available that are automatically typed with the type of the type specified for the array:</p>
<pre>const position1 = arrayWithObject2[0]; // 1<br/>const unexisting = arrayWithObject2[100]; // undefined</pre>
<p>If a position doesn't contain a value, the type returned is undefined.</p>
<p>TypeScript allows to loop an array and retrieve for each position the element strongly typed. The type is optional because TypeScript can infer the type. It means that the following code can be written with or without the <kbd>number</kbd> type:</p>
<pre>arrayWithSquareBrackets.forEach(function (element: number){<br/>  console.log(element);<br/>});</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a conscribed set of constants with enum</h1>
                
            
            
                
<p>TypeScript has a keyword <kbd>enum</kbd> that let you specify many possible values as a group where only a single item can be selected. Defining an <kbd>enum</kbd> can be done by providing potential keys that would automatically assign a sequential number from <kbd>0</kbd> to the first potential choice of the <kbd>enum</kbd> and so on:</p>
<pre>  enum Weather {<br/>       Sunny,<br/>       Cloudy,<br/>       Rainy,<br/>       Snowy<br/>   }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>It is possible to specify a value to a key to have fine-grained control. Any missing value will be the next sequence value. In the following code example, <kbd>Sunny</kbd> is set to <kbd>100</kbd>, and <kbd>Cloudy</kbd> is automatically <kbd>101</kbd>, <kbd>Rainy</kbd> is <kbd>102</kbd>, and so on:</p>
<pre>  enum Weather {<br/>    Sunny = 100,<br/>    Cloudy,<br/>    Rainy,<br/>    Snowy<br/>}</pre>
<p>It is possible to skip, in that case, you can only provide a bigger value and the value of the assigned one is sequential. In the following code example, the values are <kbd>100</kbd>, <kbd>101</kbd>, <kbd>200</kbd>, and <kbd>201</kbd>:</p>
<pre>  enum Weather {<br/>    Sunny = 100,<br/>    Cloudy,<br/>    Rainy = 200,<br/>    Snowy<br/>}</pre>
<p>The <kbd>enum</kbd> can also support string or a mix of a string and a number:</p>
<pre>enum Weather {<br/>    Sunny = "Sun",<br/>    Cloudy = "Cloud",<br/>    Rainy = 200,<br/>    Snowy<br/>}</pre>
<p>The <kbd>enum</kbd> can be accessed by the <kbd>enum</kbd> or by value. Accessing by the <kbd>enum</kbd> requires using the dot notation from the <kbd>enum</kbd> directly. The value returned is the <kbd>enum</kbd>. This is the common way to assign an <kbd>enum</kbd> in TypeScript. It is also possible to assign the value. The assignation by value is useful when data come from JSON. For example, the value is returned from an Ajax response. It bridges non-TypeScript into TypeScript:</p>
<pre>let today: Weather = Weather.Cloudy;<br/>let tomorrow: Weather = 200;<br/><br/>console.log("Today value", today); // Today value Cloud<br/>console.log("Today key", Weather[today]); // Today key undefined<br/>console.log("Tommorow value", tomorrow); // Tommorow value 200<br/>console.log("Tommorow key", Weather[tomorrow]); // Tommorow key Rainy</pre>
<p>In the previous code, accessing the value from the with the square bracket only works when the value in the square bracket is the type, not the value.</p>
<p class="mce-root"/>
<p>In addition to <kbd>number</kbd> and <kbd>string</kbd>, <kbd>enum</kbd> supports bitwise values with the help of a bit shift operator. It allows to check whether a value contains a single or an aggregate of value with an ampersand (<kbd>&amp;</kbd>). The reason is that with the pipe <kbd>|</kbd> you can create a variable that contains several values. The stacking values can also reside inside the <kbd>enum</kbd> for reusability purposes but is not required:</p>
<pre>  enum Weather {<br/>    Sunny = 0,<br/>    Cloudy = 1 &lt;&lt; 0,<br/>    Rainy = 1 &lt;&lt; 1,<br/>    Snowy = 1 &lt;&lt; 2,<br/>    Stormy = Cloudy | Rainy // Can reside inside<br/>}<br/><br/>let today: Weather= Weather.Snowy | Weather.Cloudy; // Can be outside as well<br/><br/>if (today &amp; Weather.Rainy) { // Check<br/>    console.log("Bring an umbrella");<br/>}</pre>
<p class="mce-root">A value can hold more than a single value. This is useful if we want to persist the existing value intact and you need to use the sign <kbd>|=</kbd>. To remove a particular status, you need to use <kbd>&amp;= ~</kbd>. Using these operators will swap the value at the right position in its binary format without affecting the remaining parts of the number:</p>
<pre>today |= Weather.Rainy;<br/>today &amp;= ~Weather.Snowy;<br/>console.log(today); // 3 -&gt; 011 = Cloudy and Rainy</pre>
<p>Finally, to check whether the variable is of a particular status, you must use the triple equals with the ampersand to the value you want to check against. The use of a single ampersand for comparison is a mistake. The ampersand returns a number, not a <kbd>boolean</kbd>. The comparison needs to be against the value that we want to check. It is possible to check against many values by creating a combined value in the comparison:</p>
<pre>if (Weather.Rainy === (today &amp; Weather.Rainy)) { // Check<br/>  console.log("Rainy");<br/>}<br/><br/>if (Weather.Cloudy === (today &amp; Weather.Cloudy)) { // Check<br/>  console.log("Cloudy");<br/>}<br/><br/>if ((Weather.Cloudy &amp; Weather.Rainy) === (today &amp; Weather.Cloudy &amp; Weather.Rainy)) { // Check<br/>  console.log("Cloudy and Rainy");<br/>}</pre>
<p>The <kbd>enum</kbd> is a great way to define a set of potential value from a specific domain for a variable. It has the convenience of being clear by naming the choices at your convenience and letting you decide the value of each entry if needed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">String literal and its difference compared to a string</h1>
                
            
            
                
<p>A <kbd>string</kbd> is a type that allows any kind of characters. A <kbd>string literal</kbd> is the association of a particular <kbd>string</kbd> as a type. When a <kbd>string</kbd> is set to a type, it is possible to assign one value and change it later. The only value possible to set to a <kbd>string literal</kbd> is the exact string stamped at the declaration:</p>
<pre>let x: string = "Value1";<br/>x = "Value2";<br/><br/>let y: "Literal";<br/>y = "Literal";<br/>y = "sdasd"; // Won't compile</pre>
<p>TypeScript compiles the code into plain JavaScript, without types. A <kbd>string literal</kbd> ensures that while writing the code in TypeScript that only a single string value can be associated with a variable, and this is compiled into JavaScript objects with this mandatory value. The essence of this particularity is that we have in both languages the assurance that the value is unique. This becomes handy in a situation where you need to condition a type that will not be there once compiled. For example, the case of an interface and a piece of code that must act differently depending on the interface. Having a shared field (with the name) among the interfaces with a unique string literal allow comparison at design time and run-time. At design time, TypeScript will be able to narrow down the type and hence provide better support for the specified type and at run-time be able to conduct the execution flow at the right place:</p>
<pre>interface Book {<br/>    type: "book";<br/>    isbn: string;<br/>    page: number;<br/>}<br/><br/>interface Movie {<br/>    type: "movie";<br/>    lengthMinutes: number;<br/>}<br/><br/>let hobby: Movie = { type: "movie", lengthMinutes: 120 };<br/><br/>function showHobby(hobby: Book | Movie): void {<br/>    if (hobby.type === "movie") {<br/>        console.log("Long movie of " + hobby.lengthMinutes);<br/>    } else {<br/>        console.log("A book of few pages: " + hobby.page);<br/>    }<br/>}</pre>
<p>The code example shows that two interfaces share a type that is a <kbd>string literal</kbd>. To be able to access the unique property of one or the other <kbd>interface</kbd> in the function, a comparison of a discriminator is required. Without the comparison, the function that takes both interfaces with the union as a parameter does not know which of the two types is passed. However, TypeScript analyzes the two interfaces and identifies a common field and allows you to use this before scoping down the type. Once TypeScript can find which type is treated, it allows using the specific field of the type. In the example, inside the condition, all the movie's <kbd>interface</kbd> fields are available. On the other side, the <kbd>else</kbd> allows all the book's <kbd>interface</kbd> fields only.</p>
<p>A literal string is one type of three possible literals that TypeScript supports. TypeScript supports <kbd>number</kbd> and <kbd>boolean</kbd> on top of the string. Finally, when using <kbd>string literal</kbd>, always provide the type using the colon:</p>
<pre class="mce-root">let myLiteral: "onlyAcceptedValue" = "onlyAcceptedValue";</pre>
<p>Instead of relying on <kbd>let</kbd>, which opens the door to many assignations, the use of <kbd>const</kbd> can ensure a single assignation; hence, it will automatically infer a <kbd>literal</kbd> type for the three types:</p>
<pre class="mce-root">const myLiteral = "onlyAcceptedValue"; // Not a string</pre>
<p>It is possible to create a literal by omitting the type only if declared with <kbd>const</kbd> because the value cannot change; hence, TypeScript will scope to its most narrowed expression. However, a change from <kbd>const</kbd> to <kbd>let</kbd> in the future would change the type back to <kbd>string</kbd>. I suggest being as explicit as possible to avoid an undesired type of change.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Crafting a typed function</h1>
                
            
            
                
<p><strong>Functions </strong>are first-class citizens in JavaScript. Since the early versions of ECMAScript, functions were the main concept to execute code and create scope. TypeScript uses the function the same way but provides additional typing features.</p>
<p>A function has a main signature that contains the name of this one, the list of parameters, and the return type. Parameters are defined in parentheses, as in JavaScript, but each parameter will be followed by its type using the colon syntax:</p>
<pre>function funct1(param1: number): string { return ""; }</pre>
<p>A <kbd>function</kbd> can have several parameters of a different type:</p>
<pre>function funct2(param1: boolean, param2: string): void { }</pre>
<p>It can also have a parameter that has more than one type using a union:</p>
<pre>function funct3(param1: boolean | string): void { }</pre>
<p>A <kbd>function</kbd> has a single return declaration but that type can use a union to allow types:</p>
<pre>function funct4(): string | number | boolean { return ""; }</pre>
<p>A function can have a complimentary signature to indicate to the consumer which parameters match together and with the return type. Having several function signatures for the same body is the concept of an overloaded function. When using an overloaded function, all signatures must be written from top to bottom from the most specific to the largest one. All the definition requires finishing with a semicolon expect the last one. The last signature always has a union that covers all possible types for each position. In the following code example, we specify that if the parameter is a <kbd>boolean</kbd>, then the function returns a string. If the parameter is a <kbd>Date</kbd>, then the return type is a <kbd>number</kbd>. The last signature contains a first parameter the union of both possible values (<kbd>boolean</kbd> and date) as well as a union for the return type between <kbd>string</kbd> and <kbd>number</kbd>):</p>
<pre>function funct5(param1: boolean): string;<br/>function funct5(param1: Date): number;<br/>function funct5(param1: boolean | Date): string | number {<br/>    if (typeof param1 === "boolean") {<br/>        return param1 ? "Yes" : "No";<br/>    } else {<br/>        return 0;<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<pre>}<br/><br/>const expectedString: string = funct5(true); // Yes<br/>const expectedNumber: number = funct5(new Date()); // 0</pre>
<p>A function can be anonymous. Here is an example with the <em>fat arrow</em> format and one example returning a <kbd>Function</kbd> constructor:</p>
<pre>function returnAnAnonymousFunction(): () =&gt; number {<br/>    return () =&gt; 1;<br/>}<br/><br/>function returnAnAnonymousFunction2(): Function {<br/>    return function () { return 1 };<br/>}</pre>
<p>A <kbd>function</kbd> can be a <kbd>variable</kbd> function or a typical function. Here are three functions set in a <kbd>variable</kbd>. The <kbd>variable</kbd> can be called by using parentheses and the required parameter. The code example shows also two ways to return data with the <em>fat arrow</em> format. If the code returns directly without doing any <em>several</em> statements, the need for curly brackets and <em>return</em> <em>statement</em> is not needed:</p>
<pre>const variable = (message: string) =&gt; message + " world";<br/>const variable2 = (message: string) =&gt; { return message + " world" };<br/>const variable3 = function (message: string) { return message + " world" };<br/><br/>variable("Hello");</pre>
<p>A function can have an optional parameter and a default value parameter. An optional parameter is denoted by the use of question mark after the name of the parameter. An optional parameter allows avoiding passing a value. <kbd>TypeScript</kbd> automatically sets the parameter to <kbd>undefined</kbd>:</p>
<pre>function functWithOptional(param1?: boolean): void { }<br/>functWithOptional();<br/>functWithOptional(undefined);<br/>functWithOptional(true);</pre>
<p><kbd>Optional</kbd> is different than having the variable with a union to <kbd>undefined</kbd> because the union requires passing the value or undefined while optional allows passing the value, undefined or nothing:</p>
<pre>function functWithUndefined(param1: boolean | undefined): void { }<br/>functWithUndefined(true);<br/>functWithUndefined(undefined);</pre>
<p class="mce-root"/>
<p><kbd>Optional</kbd> can only be set after non-optional parameter. The reason is that other parameters are required but having <kbd>Optional</kbd> before or in the middle would make it hard to map <kbd>which</kbd> parameter is <kbd>which</kbd>. The following code example presents a case where the function does not compile because of that rule. However, it's possible to have many optional parameters:</p>
<pre>function functWithOptional2(param1?: boolean, param2: string): void { } // Doesn't compile<br/>function functWithOptional3(param1?: boolean, param2?: string): void { }</pre>
<p>A <kbd>function</kbd> can be in a class (object-oriented is covered in a future chapter). When this happens, the syntax is different. It doesn't use the keyword <kbd>function</kbd>. Instead, the visibility is provided, which is <kbd>public</kbd>, <kbd>private</kbd>, or <kbd>protected</kbd>. <kbd>TypeScript</kbd> allows avoiding access modifiers, which will result in a <kbd>public</kbd> function. As for a class variable, the omission of the visibility uses <kbd>public</kbd> as default:</p>
<pre>  class ClassFullOfFunctions {<br/>      public f1() { }<br/>      private f2(p1: number): string { return ""; }<br/>      protected f3(): void { }<br/>      f4(): boolean { return true; }<br/>      f5(): void { } // Public<br/>}</pre>
<p>The basis remains the same with parameters and a return type that is strongly typed. It is also possible to create a variable that holds the function inside a class as seen in this chapter. Here are three examples of a <kbd>private</kbd> function defined as a <kbd>variable</kbd>. The first one is long and very explicit. The second example doesn't define the type at the function level because it is already defined in the declaration. The last example doesn't define the type of the variable and the variable is still strongly typed because it infers its signature from the initialization:</p>
<pre>private long: (p1: number) =&gt; string = (p1: number) =&gt; { return ""; }<br/>private short: (p1: number) =&gt; string = (p1) =&gt; "";<br/>private tiny = (p1: number) =&gt; "";</pre>
<p>A <kbd>function</kbd> in a variable is technically called a <strong>function expression</strong>, while the more traditional <kbd>function</kbd> syntax is named a <strong>function statement</strong>. The usage of one or the other is the same in <kbd>TypeScript</kbd> than with <kbd>JavaScript</kbd>. Because it operates under JavaScript's law, it means that the expression function is not hoisted.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to be strongly typed without specifying the type</h1>
                
            
            
                
<p>TypeScript can have a type specified explicitly or you can have the type determined by TypeScript. The latter is called an <strong>implicit type</strong> or a type defined by inference. The action of inference is conducted by TypeScript depending on how a variable is initialized during declaration for the variable or what is returned for a function return type.</p>
<p>A variable inference is only possible when a value is assigned at the declaration. It means that you must set a value when using <kbd>var</kbd>/<kbd>let</kbd>/<kbd>const</kbd>:</p>
<pre>const x = 1;<br/>let y = 1;<br/>let z;<br/>// ...<br/>z = 1;</pre>
<p>In the previous code example, the value <kbd>1</kbd> is assigned to the variables <kbd>x</kbd> and <kbd>y</kbd> during the initialization. This is valid even if the colon is not used. <kbd>TypeScript</kbd> will infer the type for both variables. In the case of not specifying a value, only <kbd>var</kbd> or <kbd>let</kbd> would compile because it allows in a future moment the assignation. The value is not specified, which means that the type is falling back to <kbd>any</kbd>. This is true even if the value is set within the scope of the variable life.</p>
<p>In the previous code example, the value <kbd>1</kbd> was assigned to a constant and a variable. The type of both of these declarators is different. The constant type is not a number, it is a number literal of <kbd>1</kbd>. It means that the type is <kbd>1</kbd> and only <kbd>1</kbd> and not any other number. However, the type of the variable declared with <kbd>let</kbd> is <kbd>number</kbd>. The reason is that with the constant, TypeScript knows that it can only be initialized once and that the value cannot change. It scopes down the simplest type it can find which is the value of the primitive. On the contrary, the variable declared with <kbd>let</kbd> can change its value during the lifetime of the variable. The TypeScript scopes the type every number. This is <kbd>true</kbd> with a <kbd>number</kbd>, <kbd>string</kbd>, and <kbd>boolean</kbd>:</p>
<pre>const d1 = new Date();<br/>let d2 = new Date();<br/><br/>const b1 = true;<br/>let b2 = false;<br/><br/>const c1 = {<br/> m1: 1<br/>};<br/><br/>let c2 = {<br/> m1: 1<br/>};</pre>
<p>However, a date will stay to the date type regardless of the declarator, the same for any class or interface because it is the smaller denominator. In the previous code example, both <kbd>c1</kbd> and <kbd>c2</kbd> are of the type of an object that must have a member named <kbd>m1</kbd> of a type number. This example illustrates how TypeScript can also infer type inside type. <kbd>m1</kbd> is a number by inference.</p>
<p>Inference works with functions as well. However, it has some limitations. The first one is that parameter must be explicit. The reason is that you cannot infer by usage without having a potential room for error. In the following code, the argument <kbd>a</kbd> is implicit <kbd>any</kbd>:</p>
<pre>function f1(a) {<br/>   return a;<br/>}</pre>
<p>However, the return can be implicit. By returning a known type, the return type can be defined:</p>
<pre>function f2(a: number) {<br/>   return a;<br/>}</pre>
<p>In the case of returning several values, TypeScript creates a union of all potential types. In the following code example, there are two return statements. TypeScript looks for each value returned and concludes that two different values are returned. The return type generated is <kbd>number | string</kbd>:</p>
<pre>function f3() {<br/>   if (true) {<br/>       return 1;<br/>   } else {<br/>       return "1";<br/>   }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we saw how TypeScript can declare variables and which declarator is be the best to use depending on the situation. We saw that TypeScript improves JavaScript's primitive type by enforcing the type during the lifetime of the variable. We explained how to transform a variable into a multiple type container with the concept of the union. TypeScript brings type to functions and we saw how we could improve the readability of a function that takes many combinations of arguments and return types with the overload function. TypeScript brings a new way to type variables with the popular <kbd>enum</kbd> borrowed from popular languages such as Java and C#. Finally, we glimpsed at how TypeScript is smart to infer types in different situations that can be advantageous to reduce lengthy definitions.</p>
<p>In the next chapter, we will see in detail the differences between many different object types and look at how we can manipulate types to have a strongly typed code flexible enough to fulfil our needs of defining our business models with TypeScript.</p>


            

            
        
    </body></html>