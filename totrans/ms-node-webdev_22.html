<html><head></head><body>
<div><h1 class="chapternumber">20</h1>
<h1 class="chaptertitle" id="_idParaDest-342">SportsStore: Administration</h1>
<p class="normal1">In this chapter, I will create the <em class="italic">SportsStore</em> administration features, which will allow authorized users to edit the product catalog and change the shipping status of customer orders.</p>
<h1 class="heading" id="_idParaDest-343">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">sportsstore</code> project from <em class="italic">Chapter 19</em>. Open a new command prompt, navigate to the <code class="inlinecode">sportsstore</code> folder, and run the command shown in <em class="italic">Listing 20.1</em> to start the development tools.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 20.1: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a new browser window, navigate to <code class="inlinecode">http://localhost:5000</code>, and you will see the product catalog, as shown in <em class="italic">Figure 20.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.1: Running the application</p>
<h1 class="heading" id="_idParaDest-344">Understanding HTML RESTful web services</h1>
<p class="normal1">The web service<a id="_idIndexMarker1054" class="calibre3"/> created in <em class="italic">Chapter 14</em> follows the most common approach, which is to return JSON data that the client can process and present to the user. This is the most flexible approach because it doesn’t limit the way that the data is used, allowing clients to be created that use data in ways the developers of the web service did not envisage and without their involvement.</p>
<p class="normal">For many projects, the developers of the web service are also responsible for the client, which leads to the strange situation where all of the state management features developed by the round-trip client are recreated, using a framework such as Angular or React to create a more responsive set of features.</p>
<p class="normal">In this situation, an alternative is to create a web service that returns fragments of HTML content instead of JSON, and create a client that responds to user interaction by sending HTTP requests to the web service, displaying the results that are obtained. The web service still relies on HTTP methods to identify the type of operation that will be performed, and the URL path to identify the resource that is affected, but the result is pre-formatted content that can be displayed to the user, which is produced using the same template, session, and data features that were created for the conventional HTML application.</p>
<p class="normal">This isn’t suitable for every project, especially when you need to provide access to your application’s data to third parties, but if you find yourself using a framework like React or Angular to duplicate the functionality already created for the server, then this can be a good approach that avoids the complexity of using<a id="_idIndexMarker1055" class="calibre3"/> a big client-side framework. </p>
<h1 class="heading" id="_idParaDest-345">Preparing for client development</h1>
<p class="normal1">The package I am going<a id="_idIndexMarker1056" class="calibre3"/> to use to send HTTP requests and process the HTML responses<a id="_idIndexMarker1057" class="calibre3"/> is called <code class="inlinecode">htmx</code> (<a href="https://htmx.org" class="calibre3">https://htmx.org</a>), which is a good choice when the server can provide all of the statement management and content generation that will be required to create the client, which is the case for the SportsStore application. To install the <code class="inlinecode">HTMX</code> package, run the command shown in <em class="italic">Listing 20.2</em> in the <code class="inlinecode">sportsstore</code> folder.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">Another good package<a id="_idIndexMarker1058" class="calibre3"/> to consider is Alpine (<a href="https://alpinejs.dev" class="calibre3">https://alpinejs.dev</a>), which is more complex, but it makes it easier to manage state data in the browser and can more easily be used with web services that return JSON data.</p>
</div>
<p class="packt_figref">Listing 20.2: Installing the htmx package</p>
<pre class="programlisting1"><code class="hljs-con">npm install htmx.org@1.9.10
</code></pre>
<p class="normal"><em class="italic">Table 20.1</em> describes the package for quick reference.</p>
<p class="packt_figref">Table 20.1: The client-side package</p>
<table class="table-container" id="table001-17">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><a href="http://htmx.org" class="url">htmx.org</a>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">The <code class="inlinecode">HTMX</code> package scans HTML elements for special attributes that configure asynchronous HTTP requests, which will be sent to a web service that returns a fragment of HTML.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlinecode">HTMX</code> package works by applying attributes to HTML elements, which are processed by JavaScript code loaded using a <code class="inlinecode">script</code> element. This approach means that no client-side development toolchain is required, and the developer can simply reload the browser to see the effect of changes during development. I find that style of development frustrating because I often forget to reload the browser, which causes me momentary confusion when the content displayed by the browser doesn’t match up with the markup that I have just saved in the code editor. To that end, I am going to set up the <strong class="screentext">webpack</strong> bundler so that I can take advantage of the development server <code class="inlinecode">reload</code> feature.</p>
<p class="normal">Some packages just deal<a id="_idIndexMarker1059" class="calibre3"/> with browser reloading, but using webpack is a form of insurance because the bundle that it creates means that I can easily add JavaScript code to the client side later, without needing to revise the project tooling. There is no requirement to use a webpack bundler with an <code class="inlinecode">HTMX</code> project, but I consider it a worthwhile escape hatch that lets me fix awkward problems that would otherwise be hard to deal with.</p>
<p class="normal">Run the commands shown in <em class="italic">Listing 20.3</em> in the <code class="inlinecode">sportsstore</code> folder to install the packages required to create the client-side bundles. </p>
<p class="packt_figref">Listing 20.3: Installing the packages required for the bundler</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev webpack@5.89.0
npm install --save-dev webpack-cli@5.1.4
npm install --save-dev webpack-dev-server@4.15.1
npm install --save-dev npm-run-all@4.1.5
npm install http-proxy@1.18.1
</code></pre>
<p class="normal"><em class="italic">Table 20.2</em> describes these packages for quick reference.</p>
<p class="packt_figref">Table 20.2: The client-side development tool packages</p>
<table class="table-container" id="table002-15">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">webpack</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains the webpack bundler.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">webpack-cli</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains the command line for webpack.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">webpack-dev-server</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains the webpack development HTTP server.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">npm-run-all</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package allows you to start multiple commands using <code class="inlinecode">npm</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">http-proxy</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains an HTTP proxy, which will forward requests to the webpack server during development.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Add a file named <code class="inlinecode">webpack.config.mjs</code> to the <code class="inlinecode">sportsstore</code> folder<a id="_idIndexMarker1060" class="calibre3"/> with the content shown in <em class="italic">Listing 20.4</em>, which configures webpack and sets up its development server.</p>
<p class="packt_figref">Listing 20.4: The contents of the webpack.config.mjs file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from "url";
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry:   "./src/admin/client.js",
    devtool: "source-map",   
    output: {
        path: path.resolve(__dirname, "dist/admin"),
        filename: "bundle.js"
    },
    devServer: {
        watchFiles: ["templates/admin"],
        port: 5100,	
        client: { webSocketURL: "http://localhost:5000/ws" }
    }
};
</code></pre>
<p class="normal">The configuration tells webpack to create a bundle using a file named <code class="inlinecode">client.js</code> in the <code class="inlinecode">src/admin</code> folder, and also to trigger a browser update if the bundle changes or if a file in the <code class="inlinecode">templates/admin</code> folder changes. The bundle will be created in a file named <code class="inlinecode">bundle.js</code>, which will be written to the <code class="inlinecode">dist/admin</code> folder. Create the <code class="inlinecode">src/admin</code> folder, and add to it a file named <code class="inlinecode">client.js</code> with the content shown in <em class="italic">Listing 20.5</em>.</p>
<p class="packt_figref">Listing 20.5: The contents of the client.js file in the src/admin folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', () =&gt; {
    // do nothing
});
</code></pre>
<p class="normal">The code in this file does nothing<a id="_idIndexMarker1061" class="calibre3"/> because the bundle is just a means to use the webpack development HTTP server. The bundle will be omitted from the production build of the application.</p>
<h2 class="heading1" id="_idParaDest-346">Creating the routes and templates</h2>
<p class="normal1">The next steps<a id="_idIndexMarker1062" class="calibre3"/> are to configure<a id="_idIndexMarker1063" class="calibre3"/> the route<a id="_idIndexMarker1064" class="calibre3"/> that will be the entry point<a id="_idIndexMarker1065" class="calibre3"/> into the administration features and define the template that will be used to generate the response. Create the <code class="inlinecode">src/routes/admin</code> folder, and add to it a file named <code class="inlinecode">index.ts</code> with the content shown in <em class="italic">Listing 20.6</em>.</p>
<p class="packt_figref">Listing 20.6: The contents of the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const createAdminRoutes = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        resp.locals.layout = false;
        next();
    })
    app.get("/admin", (req, resp) =&gt; resp.render("admin/admin_layout"));
}
</code></pre>
<p class="normal">The <code class="inlinecode">createAdminRoutes</code> function sets up the administration routes. To get started, there is a middleware component that disables the default layout for the template engine, and a route that handles <code class="inlinecode">GET</code> requests to the <code class="inlinecode">/admin</code> URL by rendering a template named <code class="inlinecode">admin/admin_layout</code>. The name of the template includes the <code class="inlinecode">admin</code> folder so that I can keep the administration templates separate from the rest of the application content. The drawback of this approach is that the folder name has to be included in all calls to the <code class="inlinecode">render</code> method.</p>
<p class="normal"><em class="italic">Listing 20.7</em> adds the <code class="inlinecode">createAdminRoutes</code> to the set of functions called to set up the application’s routes.</p>
<p class="packt_figref">Listing 20.7: Adding routes to the index.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createCatalogRoutes } from "./catalog";
import { createCartMiddleware, createCartRoutes } from "./cart";
import { createOrderRoutes } from "./orders";
import { createAdminRoutes } from "./admin";
export const createRoutes = (app: Express) =&gt; {
    createCartMiddleware(app);
    createCatalogRoutes(app);
    createCartRoutes(app);
    createOrderRoutes(app);
    createAdminRoutes(app);
}
</code></pre>
<p class="normal">To create the initial<a id="_idIndexMarker1066" class="calibre3"/> template, create the <code class="inlinecode">sportsstore/templates/admin</code> folder, and add<a id="_idIndexMarker1067" class="calibre3"/> to it a file<a id="_idIndexMarker1068" class="calibre3"/> named <code class="inlinecode">admin_layout.handlebars</code> with the content<a id="_idIndexMarker1069" class="calibre3"/> shown in <em class="italic">Listing 20.8</em>.</p>
<p class="packt_figref">Listing 20.8: The contents of the admin_layout.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
        &lt;link href="/font/bootstrap-icons.min.css" rel="stylesheet"&gt;
        {{#if (isDevelopment) }}
            &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        {{/if }}
        &lt;script src="img/htmx.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container-fluid"&gt;
            &lt;div class="row bg-info text-white py-2 px-1"&gt;
                &lt;div class="col align-baseline pt-1"&gt;SPORTS STORE ADMIN&lt;/div&gt;
                &lt;div class="col-auto text-end"&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row p-2"&gt;
                &lt;div class="col-2" id="area_buttons"&gt;&lt;/div&gt;
                &lt;div class="col" id="content"&gt;
                    Content Goes Here...
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">This template renders <a id="_idIndexMarker1070" class="calibre3"/>an HTML document, with <code class="inlinecode">link</code> elements<a id="_idIndexMarker1071" class="calibre3"/> for the Bootstrap CSS and Icons<a id="_idIndexMarker1072" class="calibre3"/> files, and <code class="inlinecode">script</code> elements for the webpack bundle<a id="_idIndexMarker1073" class="calibre3"/> and the <code class="inlinecode">HTMX</code> JavaScript file.</p>
<h2 class="heading1" id="_idParaDest-347">Configuring the application</h2>
<p class="normal1">To complete the<a id="_idIndexMarker1074" class="calibre3"/> preparation, <em class="italic">Listing 20.9</em> sets up request forwarding<a id="_idIndexMarker1075" class="calibre3"/> to the webpack dev server and adds the <code class="inlinecode">HTMX</code> package folder to the set of static file locations.</p>
<p class="packt_figref">Listing 20.9: Configuring the application in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
import { getConfig, getEnvironment, Env } from "./config";
import { createRoutes } from "./routes";
import { createTemplates } from "./helpers";
import { createErrorHandlers } from "./errors";
import { createSessions } from "./sessions";
import { createAuthentication } from "./authentication";
<strong class="screentext">import httpProxy from "http-proxy";</strong>
const port = getConfig("http:port", 5000);
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use(express.static("node_modules/bootstrap-icons"));
expressApp.use(express.static("node_modules/htmx.org/dist"));
createTemplates(expressApp);
createSessions(expressApp);
createAuthentication(expressApp);
createRoutes(expressApp);
<strong class="screentext">//createErrorHandlers(expressApp);</strong>
const server = createServer(expressApp);
<strong class="screentext">if (getEnvironment</strong><strong class="screentext">() === Env.Development) {</strong>
<strong class="screentext">    const proxy = httpProxy.createProxyServer({</strong>
<strong class="screentext">        target: "http://localhost:5100", ws: true</strong>
<strong class="screentext">    });   </strong>
<strong class="screentext">    expressApp.use("/admin"</strong><strong class="screentext">, (req, resp) =&gt; proxy.web(req, resp));     </strong>
<strong class="screentext">    server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));</strong>
<strong class="screentext">}</strong>
<strong class="screentext">createErrorHandlers(expressApp);</strong>
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">If the application is configured<a id="_idIndexMarker1076" class="calibre3"/> for the development<a id="_idIndexMarker1077" class="calibre3"/> environment, then the <code class="inlinecode">http-proxy</code> package is used to forward requests to the webpack development HTTP server, which will enable automatic browser reloading. </p>
<p class="normal">The error handlers have to be moved so that the <code class="inlinecode">404</code> <code class="inlinecode">-</code> <code class="inlinecode">Not</code> <code class="inlinecode">Found</code> response isn’t generated until after the handler for webpack development server has had the chance to match the request.</p>
<p class="normal">The final preparatory step is to configure the <code class="inlinecode">npm</code> commands to start both the server and webpack, and to prevent the server from being restarted when the templates in the <code class="inlinecode">admin</code> folder are changed, as shown in <em class="italic">Listing 20.10</em>.</p>
<p class="packt_figref">Listing 20.10: Configuring the application in the package.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
  "name": "sportsstore",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "watch": "tsc-watch --noClear --onsuccess \"node dist/server.js\"",
    <strong class="screentext">"server": "nodemon --exec npm run watch",</strong>
<strong class="screentext">    "client": "webpack serve",</strong>
<strong class="screentext">    "start": "npm-run-all --parallel server client"</strong>
  },
  "nodemonConfig": {
    "ext": "js,handlebars,json",
    "ignore": [
      "dist/**",
      "node_modules/**",
     <strong class="screentext"> "templates/admin/**"     </strong>
    ]
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    // ...packages omitted for brevity...
  },
  "dependencies": {
    // ...packages omitted for brevity...
  }
}
</code></pre>
<p class="normal">Stop the server if it is running, and then run<a id="_idIndexMarker1078" class="calibre3"/> the command<a id="_idIndexMarker1079" class="calibre3"/> shown in <em class="italic">Listing 20.11</em> in the <code class="inlinecode">sportsstore</code> folder to start the client-side build tools and the server.</p>
<p class="packt_figref">Listing 20.11: Starting the client build tools and server</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a browser and navigate to <code class="inlinecode">http://localhost:5000/admin</code>. The browser will display the administration<a id="_idIndexMarker1080" class="calibre3"/> layout, with some placeholder<a id="_idIndexMarker1081" class="calibre3"/> text, as shown in <em class="italic">Figure 20.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.2: Preparing for the administration features</p>
<h1 class="heading" id="_idParaDest-348">Administering the product catalog</h1>
<p class="normal1">Now that the basic structure<a id="_idIndexMarker1082" class="calibre3"/> is in place, it is time to start adding features. Create a file named <code class="inlinecode">area_buttons.handlebars</code> in the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.12</em>. </p>
<p class="packt_figref">Listing 20.12: The contents of the area_buttons.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;swap_wrapper hx-swap-oob="innerHTML:#area_buttons"&gt;
    &lt;div class="d-grid gap-2" &gt;
        &lt;button id="products_btn" class="btn <strong class="screentext">{{ buttonClass "products" mode }}</strong>"
            hx-get="/api/products/table" hx-target="#content"&gt;
            Products
        &lt;/button&gt;
        &lt;button id="orders_btn" class="btn {{ buttonClass "orders" mode }}"
            hx-get="/api/orders/table" hx-target="#content"&gt;
            Orders
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/swap_wrapper&gt;
</code></pre>
<p class="normal">This template contains the buttons that will allow the user to select an area of functionality: managing the catalog or shipping orders. The file is processed by the Handlebars template engine, which evaluates the <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> sections to produce the HTML content that is included in the response to the client. There are two template <a id="_idIndexMarker1083" class="calibre3"/>expressions in this file, which change the value of the class attribute applied to the <code class="inlinecode">button</code> elements: </p>
<pre class="programlisting"><code class="hljs-code">...
&lt;swap_wrapper <strong class="screentext">hx-swap-oob="innerHTML:#area_buttons"</strong>&gt;
    &lt;div class="d-grid gap-2" &gt;
        &lt;button id="products_btn" class="btn {{ buttonClass "products" mode }}"
           <strong class="screentext"> hx-get="</strong><strong class="screentext">/api/products/table" hx-target="#content"&gt;</strong>
            Products
        &lt;/button&gt;
        &lt;button id="orders_btn" class="btn {{ buttonClass "orders" mode }}"
           <strong class="screentext"> hx-get="/api/orders/table" hx-target="#content"&gt;</strong>
            Orders
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/swap_wrapper&gt;
...
</code></pre>
<p class="normal">The classes applied to the elements will show the user which part of the application is active and rely on a template helper named <code class="inlinecode">buttonClass</code>, which I’ll create shortly.</p>
<p class="normal">Once the HTML content is received by the browser, it will be processed a second time, by the <code class="inlinecode">HTMX</code> package, which looks for attributes whose name begins with <code class="inlinecode">hx</code>:</p>
<pre class="programlisting"><code class="hljs-code">...
&lt;swap_wrapper hx-swap-oob="innerHTML:#area_buttons"&gt;
    &lt;div class="d-grid gap-2" &gt;
        &lt;button id="products_btn" class="btn {{ buttonClass "products" mode }}"
            hx-get="/api/products/table" hx-target="#content"&gt;
            Products
        &lt;/button&gt;
        &lt;button id="orders_btn" class="btn {{ buttonClass "orders" mode }}"
            hx-get="/api/orders/table" hx-target="#content"&gt;
            Orders
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/swap_wrapper&gt;
...
</code></pre>
<p class="normal">The <code class="inlinecode">hx-get</code> attributes tell <code class="inlinecode">HTMX</code> to send a <code class="inlinecode">GET</code> request to a specific URL. By default, <code class="inlinecode">HTMX</code> uses the HTML in the response to replace the element that triggered the requests, but this can be changed with the <code class="inlinecode">hx-target</code> attribute, which means that the <code class="inlinecode">button</code> elements will request <code class="inlinecode">/api/products/table</code> or <code class="inlinecode">/api/orders/table</code>, and the response will be displayed using the element whose ID is <code class="inlinecode">content</code>. (The value of the <code class="inlinecode">hx-target</code> attribute is a CSS selector, and the <code class="inlinecode">#</code> prefix denotes an element’s ID.)</p>
<p class="normal">The <code class="inlinecode">hx-swap-oob</code> attribute allows a fragment of content to specify where it will be displayed. The attribute applied to the <code class="inlinecode">swap_wrapper</code> element tells <code class="inlinecode">HTMX</code> that the content it contains should be used to replace the content of the element whose name is <code class="inlinecode">area_buttons</code>. (The <code class="inlinecode">swap_wrapper</code> element name is entirely made up and was chosen so that it won’t be mistaken for the actual application HTML content. You can use any element name in your projects.)</p>
<p class="normal">To define the <code class="inlinecode">buttonClass</code> helper <a id="_idIndexMarker1084" class="calibre3"/>that is used in <em class="italic">Listing 20.12</em>, add a file named <code class="inlinecode">admin_helpers.ts</code> to the <code class="inlinecode">src/helpers</code> folder with the content shown in <em class="italic">Listing 20.13</em>.</p>
<p class="packt_figref">Listing 20.13: The contents of the admin_helpers.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">export const buttonClass = (btn: string, mode: string) =&gt;
    btn == mode ? "btn-secondary" : "btn-outline-secondary";
</code></pre>
<p class="normal"><em class="italic">Listing 20.14</em> includes the new helper in the template engine configuration when the application starts.</p>
<p class="packt_figref">Listing 20.14: Adding helpers to the index.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { getConfig } from "../config";
import { engine } from "express-handlebars";
import * as env_helpers from "./env";
import * as catalog_helpers from "./catalog_helpers";
import * as cart_helpers from "./cart_helpers";
import * as order_helpers from "./order_helpers";
<strong class="screentext">import * as admin_helpers from "./admin_helpers";</strong>
const location = getConfig("templates:location");
const config = getConfig("templates:config");
export const createTemplates = (app: Express) =&gt; {
    app.set("views", location);
    app.engine("handlebars", engine({
        ...config,
       <strong class="screentext"> helpers: {...env_helpers, ...catalog_helpers, ...cart_helpers,</strong>
<strong class="screentext">                    ...order_helpers, ...admin_helpers}</strong>
    }));
    app.set("view engine", "handlebars");
}
</code></pre>
<p class="normal">The content in <em class="italic">Listing 20.12</em> is a partial<a id="_idIndexMarker1085" class="calibre3"/> template, which will be combined with other content to produce an HTML response, using the features provided by the template engine, and the template also allows small files to be defined and managed. Add a file named <code class="inlinecode">product_table.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.15</em>.</p>
<p class="packt_figref">Listing 20.15: The contents of the product_table.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="products"}}
&lt;table class="table table-sm"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Category&lt;/th&gt;&lt;th&gt;Supplier&lt;/th&gt;
            &lt;th class="text-end"&gt;Price&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#each products }}   
            &lt;tr&gt;&lt;td colspan="6"&gt;{{name}}&lt;/td&gt;&lt;/tr&gt;
        {{/each }}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">This template presents the table of products in the catalog to the user and incorporates the <code class="inlinecode">area_buttons</code> partial template. The template receives a <code class="inlinecode">product</code> data property that is used to populate<a id="_idIndexMarker1086" class="calibre3"/> the contents of a table, using the <code class="inlinecode">each</code> helper.</p>
<h2 class="heading1" id="_idParaDest-349">Starting the web service routes</h2>
<p class="normal1">I like to get the basic template<a id="_idIndexMarker1087" class="calibre3"/> features in place<a id="_idIndexMarker1088" class="calibre3"/> and switch between the routes and data management as I work, returning to the templates to refine the data presentation as features fall into place. To define the route that will provide the initial view of the catalog, add a file named <code class="inlinecode">admin_catalog_routes.ts</code> to the <code class="inlinecode">src/routes/admin</code> folder with the content shown in <em class="italic">Listing 20.16</em>. </p>
<p class="packt_figref">Listing 20.16: The contents of the admin_catalog_routes.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { CategoryModel, ProductModel, SupplierModel }
    from "../../data/orm/models";
   
export const createAdminCatalogRoutes = (router: Router) =&gt; {
    router.get("/table", async (req, resp) =&gt; {
        const products = await ProductModel.findAll({
                include: [
                    {model: SupplierModel, as: "supplier" },
                    {model: CategoryModel, as: "category" }],
                raw: true, nest: true
        });
        resp.render("admin/product_table", { products });
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">createAdminCatalogRoutes</code> function receives a <code class="inlinecode">Router</code> object, which allows requests to be handled relative to a base URL that is defined elsewhere in the application. There is one route that handles the <code class="inlinecode">/table</code> URL and responds by rendering the <code class="inlinecode">admin/product_table</code> template, which is provided by data read from the database.</p>
<p class="normal">In earlier chapters, I accessed the database through the repository, which is my preferred way of isolating details of data access from the rest of the application. Not everyone likes using a repository and the additional complexity it introduces, so for the administration features, I am going to access the database directly through the Sequelize model classes to demonstrate both techniques, showing that they can coexist in the same project. To get the data for the template, the request handler queries for all <code class="inlinecode">ProductModel</code> objects and includes the associated <code class="inlinecode">SupplierModel</code> and <code class="inlinecode">CategoryModel</code> objects. The <code class="inlinecode">raw</code> property is used to prevent Sequelize from transforming the response, which is a useful option when the data<a id="_idIndexMarker1089" class="calibre3"/> that is read from the database<a id="_idIndexMarker1090" class="calibre3"/> can be used without modification.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">I still recommend using a repository because doing so ensures that data is accessed consistently, and it makes it easier to swap out the data access package. If you do choose to work directly with the data access package in your project, remember that you will have to go through the initialization process. For the <em class="italic">SportsStore</em> application, this is done in the <code class="inlinecode">core.ts</code> file in the <code class="inlinecode">src/data/orm</code> folder.</p>
</div>
<p class="normal"><em class="italic">Listing 20.17</em> calls the <code class="inlinecode">createAdminCatalogRoutes</code> function when the application starts.</p>
<p class="packt_figref">Listing 20.17: Adding routes to the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { Express, Router } from "express"</strong><strong class="screentext">;</strong>
<strong class="screentext">import { createAdminCatalogRoutes } from "./admin_catalog_routes";</strong>
export const createAdminRoutes = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        resp.locals.layout = false;
        next();
    })
   <strong class="screentext"> const cat_router = Router();</strong>
<strong class="screentext">    createAdminCatalogRoutes(cat_router);</strong>
<strong class="screentext">    app.use("/api/products"</strong><strong class="screentext">, cat_router);</strong>
    app.get("/admin", (req, resp) =&gt; resp.render("admin/admin_layout"));
}
</code></pre>
<p class="normal">A new <code class="inlinecode">Router</code> object<a id="_idIndexMarker1091" class="calibre3"/> is created and passed<a id="_idIndexMarker1092" class="calibre3"/> to the <code class="inlinecode">createAdminCatalogRoutes</code> function so that the relative routes can be defined, and it is then added to the request pipeline with the <code class="inlinecode">use</code> method. <code class="inlinecode">Router</code> is a middleware component that tries to match requests with its routes; otherwise, it will pass on requests. In this case, the <code class="inlinecode">Router</code> object passed to the <code class="inlinecode">createAdminCatalogRoutes</code> function is configured to try and match requests with the <code class="inlinecode">/api/products</code> path, using the routes defined in <em class="italic">Listing 20.16</em>, which means that the <code class="inlinecode">/api/products/table</code> URL will be received by the handler defined in <em class="italic">Listing 20.16</em>, responding with the rendered output from the <code class="inlinecode">admin/product_table</code> template.</p>
<p class="normal"><em class="italic">Listing 20.18</em> updates the top-level template so that <code class="inlinecode">HTMX</code> will send a request that will be processed by the handler defined in <em class="italic">Listing 20.16</em>.</p>
<p class="packt_figref">Listing 20.18: Loading data into the admin_layout.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
        &lt;link href="/font/bootstrap-icons.min.css" rel="stylesheet"&gt;
        {{#if (isDevelopment) }}
            &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        {{/if }}
        &lt;script src="img/htmx.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container-fluid"&gt;
            &lt;div class="row bg-info text-white py-2 px-1"&gt;
                &lt;div class="col align-baseline pt-1"&gt;SPORTS STORE ADMIN&lt;/div&gt;
                &lt;div class="col-auto text-end"&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row p-2"&gt;
                &lt;div class="col-2" id="area_buttons"&gt;&lt;/div&gt;
               <strong class="screentext"> &lt;div class="col" id="</strong><strong class="screentext">content" hx-get="/api/products/table"</strong>
<strong class="screentext">                    hx-trigger="load"&gt;&lt;/div&gt;</strong>
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">hx-get</code> attribute tells <code class="inlinecode">HTMX</code> to request the <code class="inlinecode">/api/product/table</code> URL. By default, requests are sent when the user interacts with an element, but the <code class="inlinecode">hx-trigger</code> attribute overrides this behavior and tells <code class="inlinecode">HTMX</code> to send the HTTP request when the element<a id="_idIndexMarker1093" class="calibre3"/> is loaded. Use a browser<a id="_idIndexMarker1094" class="calibre3"/> to request <code class="inlinecode">http://localhost:5000/admin</code>, and you will see the content shown in <em class="italic">Figure 20.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.3: Starting the development of the administration features</p>
<p class="normal">Before moving on, it is worth recapping the process that produces the content shown in the figure:</p>
<ol class="calibre6">
<li class="bulletlist1" value="1">The user requests <code class="inlinecode">http://localhost:5000/admin</code>.</li>
<li class="bulletlist1">The request is handled by rendering the <code class="inlinecode">admin_layout</code> template, which contains an element whose attributes tell <code class="inlinecode">HTMX</code> to send an HTTP request to <code class="inlinecode">http://localhost:5000/api/products/table</code> once the HTML content has been loaded.</li>
<li class="bulletlist1">The second request is handled by rendering the <code class="inlinecode">product_table</code> template, and the content that is produced is used as the contents of the element that triggered the HTTP request, except for the content in the <code class="inlinecode">area_buttons</code> partial template, which is used to replace the contents of the element with the same name.</li>
</ol>
<p class="normal">This initial presentation<a id="_idIndexMarker1095" class="calibre3"/> of content may seem like the existing<a id="_idIndexMarker1096" class="calibre3"/> round-trip functionality, but the key difference is that some of the content was obtained using the web service, whose importance will become more obvious as features are added.</p>
<h2 class="heading1" id="_idParaDest-350">Displaying product data and deleting products</h2>
<p class="normal1">Now that the basic structure<a id="_idIndexMarker1097" class="calibre3"/> is in place, I am going<a id="_idIndexMarker1098" class="calibre3"/> to pick up the pace and build out the rest of the product management features, pausing periodically to check that everything works as it should. To display the product details correctly, add a file named <code class="inlinecode">product_row.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.19</em>. </p>
<p class="packt_figref">Listing 20.19: The contents of the product_row.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;tr id="row{{ id }}"&gt;
    &lt;td&gt;{{ id }}&lt;/td&gt;
    &lt;td&gt;{{ name }}&lt;/td&gt;
    &lt;td&gt;{{ category.name }}&lt;/td&gt;
    &lt;td&gt;{{ supplier.name }}&lt;/td&gt;
    &lt;td class="text-end"&gt;{{ currency price}}&lt;/td&gt;
    &lt;td class="ps-3"&gt;       
        &lt;button class="btn btn-sm btn-warning"
            hx-get="/api/products/edit/{{id}}" hx-target="#content"&gt;
                Edit
            &lt;/button&gt;
        &lt;button class="btn btn-sm btn-danger"
            hx-delete="/api/products/{{id}}" hx-target="#row{{id}}"
                    hx-swap="delete"&gt;
                Delete
        &lt;/button&gt;           
    &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">button</code> elements will allow the user to edit or delete products. The <strong class="screentext">Edit</strong> <code class="inlinecode">button</code> element has an <code class="inlinecode">hx-get</code> attribute that sends a request when the button is clicked, including the <code class="inlinecode">id</code> value in the requested URL, so that clicking on the <strong class="screentext">Edit</strong> button for the product with <code class="inlinecode">ID</code> 2, for example, will send an HTTP request to <code class="inlinecode">/api/products/edit/2</code>.</p>
<p class="normal">The <code class="inlinecode">Delete</code> button element<a id="_idIndexMarker1099" class="calibre3"/> has the <code class="inlinecode">hx-delete</code> attribute, which tells <code class="inlinecode">HTMX</code> to send<a id="_idIndexMarker1100" class="calibre3"/> an HTTP <code class="inlinecode">DELETE</code> request when the button is clicked. The <code class="inlinecode">hx-swap</code> attribute is set to <code class="inlinecode">delete</code>, which tells <code class="inlinecode">HTMX</code> to remove the element specified by the <code class="inlinecode">hx-target</code> attribute. The effect is that the table row for the product will be removed when the <strong class="screentext">Delete</strong> button is clicked, and the server confirms that the product has been removed from the database.</p>
<p class="normal"><em class="italic">Listing 20.20</em> applies the new template to format the product data.</p>
<p class="packt_figref">Listing 20.20: Applying a template to the product_table.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="products"}}
&lt;table class="table table-sm"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Category&lt;/th&gt;&lt;th&gt;Supplier&lt;/th&gt;
            &lt;th class="text-end"&gt;Price&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#each products }}   
           <strong class="screentext"> {{&gt; admin/product_row }}</strong>
        {{/each }}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal"><em class="italic">Listing 20.21</em> adds a route that handles <code class="inlinecode">DELETE</code> requests, receiving the ID of the product to delete it as a URL parameter.</p>
<p class="packt_figref">Listing 20.21: Adding a route to the admin_catalog_routes.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { CategoryModel, ProductModel, SupplierModel }
    from "../../data/orm/models";
export const createAdminCatalogRoutes = (router: Router) =&gt; {
    router.get("/table", async (req, resp) =&gt; {
        const products = await ProductModel.findAll({
                include: [
                    {model: SupplierModel, as: "supplier" },
                    {model: CategoryModel, as: "category" }],
                raw: true, nest: true
        });
        resp.render("admin/product_table", { products });
    });
   <strong class="screentext"> router.delete("/:id", async (req, resp) =&gt; {</strong>
<strong class="screentext">        const</strong><strong class="screentext"> id = req.params.id;</strong>
<strong class="screentext">        const count = await ProductModel.destroy({ where: { id }});</strong>
<strong class="screentext">        if (count == 1) {</strong>
<strong class="screentext">            resp.end</strong><strong class="screentext">();</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            throw Error(`Unexpected deletion count result: ${count}`)</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">Request <code class="inlinecode">http://localhost:5000/admin</code>, and you will see a more detailed<a id="_idIndexMarker1101" class="calibre3"/> presentation of the product<a id="_idIndexMarker1102" class="calibre3"/> data. Clicking the <strong class="screentext">Delete</strong> button removes a product from the database, as shown in <em class="italic">Figure 20.4</em>. (The application is configured to reset the database, which means that the deleted products will be restored the next time you change one of the project files.)</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.4: Product details and deleting a product</p>
<h2 class="heading1" id="_idParaDest-351">Editing products</h2>
<p class="normal1">The <strong class="screentext">Edit</strong> feature will present<a id="_idIndexMarker1103" class="calibre3"/> the user with an HTML form that is populated with the details of a product, presenting validation messages when the form is submitted with unusual values. I am going to build up the form using a series of smaller, more manageable templates, which will be combined to produce an HTML response and ensure that each data property is handled consistently. Starting with a template to display validation messages, add a file named <code class="inlinecode">validation_messages.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder, with the content shown in <em class="italic">Listing 20.22</em>. </p>
<p class="packt_figref">Listing 20.22: The contents of the validation_messages.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{#if invalid }}
    {{#each messages }}
        &lt;div class="text-danger"&gt;{{ this }}&lt;/div&gt;
    {{/each }}
{{/if }}
</code></pre>
<p class="normal">I am going to use the existing validation features, which means that the <code class="inlinecode">invalid</code> property will be <code class="inlinecode">true</code> when there is a validation issue and the <code class="inlinecode">messages</code> property contains the content to be displayed to the user.</p>
<p class="normal">Some of the product details will be displayed using <code class="inlinecode">input</code> elements, allowing the user to freely enter a value. To create a template for <code class="inlinecode">input</code> elements, add a file named <code class="inlinecode">product_input.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.23</em>.</p>
<p class="packt_figref">Listing 20.23: The contents of the product_input.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="mb-2"&gt;
    &lt;label&gt;{{label}}&lt;/label&gt;
    &lt;input {{ disabled label }} name="{{ name }}" class="form-control"
        value="{{ data.value }}" /&gt;
    {{&gt; admin/validation_messages data }}
&lt;/div&gt;
</code></pre>
<p class="normal">The template creates <code class="inlinecode">label</code> and <code class="inlinecode">input</code> elements, formatted<a id="_idIndexMarker1104" class="calibre3"/> using the Bootstrap CSS styles, and incorporates the <code class="inlinecode">validation messages</code> template. To simplify data management, users won’t be allowed to change the <code class="inlinecode">ID</code> property of a product, and so a <code class="inlinecode">disabled</code> helper is used to add the <code class="inlinecode">disabled</code> attribute to the <code class="inlinecode">input</code> element when that element is used for the <code class="inlinecode">ID</code> property, as shown in <em class="italic">Listing 20.24</em>.</p>
<p class="packt_figref">Listing 20.24: Adding a helper to the admin_helpers.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">export const buttonClass = (btn: string, mode: string) =&gt;
    btn == mode ? "btn-secondary" : "btn-outline-secondary";
<strong class="screentext">export const disabled = (val: any) =&gt; val == "ID"</strong><strong class="screentext"> ? "disabled" : "";</strong>
</code></pre>
<p class="normal">Some product properties will be edited by picking from a list of values. To create a template that will produce a <code class="inlinecode">select</code> element, add a file named <code class="inlinecode">product_select.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.25</em>.</p>
<p class="packt_figref">Listing 20.25: The contents of the product_select.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="mb-2"&gt;
    &lt;label&gt;{{ label }}&lt;/label&gt;
    &lt;select name="{{name}}" class="form-select " &gt;
        &lt;option value="" disabled selected&gt;Choose Category&lt;/option&gt;
        {{#each list }}
            &lt;option {{ selected id ../data.value }}
                value="{{id}}"&gt;{{ name }}
            &lt;/option&gt;
        {{/each}}
    &lt;/select&gt;
    {{&gt; admin/validation_messages data }}
&lt;/div&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">select</code> element is populated with a set of <code class="inlinecode">option</code> elements from which the user can choose, along with a fallback element that will be useful later when adding support to create new products. A helper is required to determine whether an <code class="inlinecode">option</code> element is decorated with the <code class="inlinecode">selected</code> attribute, as shown in <em class="italic">Listing 20.26</em>.</p>
<p class="packt_figref">Listing 20.26: Adding a helper to the admin_helpers.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">export const buttonClass = (btn: string, mode: string) =&gt;
    btn == mode ? "btn-secondary" : "btn-outline-secondary";
export const disabled = (val: any) =&gt; val == "ID" ? "disabled" : "";
<strong class="screentext">export const selected = (val1: any, val2: any) =&gt;</strong>
<strong class="screentext">    val1 == val2 ? "selected" : "";</strong>
</code></pre>
<p class="normal">To create the template<a id="_idIndexMarker1105" class="calibre3"/> that combines the <code class="inlinecode">input</code> and <code class="inlinecode">select</code> elements to present the user with a complete HTML form, add a file named <code class="inlinecode">product_editor.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.27</em>.</p>
<p class="packt_figref">Listing 20.27: The contents of the product_editor.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="products"}}
&lt;form hx-put="/api/products/{{product.id.value}}"&gt;
    {{&gt; admin/product_input label="ID" name="id" data=product.id }}
    {{&gt; admin/product_input label="Name" name="name" data=product.name }}
    &lt;div class="mb-2"&gt;
        &lt;label&gt;Description&lt;/label&gt;
        &lt;textarea name="description"
            class="form-control"&gt;{{ product.description.value }}&lt;/textarea&gt;
        {{&gt; admin/validation_messages product.description }}           
    &lt;/div&gt;
    {{&gt; admin/product_select label="Category" name="categoryId"
            data=product.categoryId list=categories}}
    {{&gt; admin/product_select label="Supplier" name="supplierId"
            data=product.supplierId list=suppliers}}
    {{&gt; admin/product_input label="Price" name="price" data=product.price }}
    &lt;div&gt;
        &lt;button type="submit" class="btn btn-secondary text-white"&gt;Save&lt;/button&gt;
        &lt;button class="btn btn-outline-secondary"
            hx-get="/api/products/table" hx-target="#content"&gt;Cancel&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p class="normal">This template contains a <code class="inlinecode">form</code> element that is decorated with the <code class="inlinecode">hx-put</code> attribute, which tells <code class="inlinecode">HTMX</code> to submit the form using an HTTP <code class="inlinecode">PUT</code> request to a URL that combines <code class="inlinecode">/api/products</code> with the product <code class="inlinecode">ID</code> (such as <code class="inlinecode">/api/products/1</code> for the product whose <code class="inlinecode">ID</code> value is <code class="inlinecode">1</code>).</p>
<p class="normal">The contents of the form are created using the templates for <code class="inlinecode">input</code> and <code class="inlinecode">select</code> elements, along with a <code class="inlinecode">textarea</code> element that will allow the user to enter multiple lines of text for the description. There is also a button that will trigger the <code class="inlinecode">PUT</code> request, as well as a <code class="inlinecode">Cancel</code> button that instructs <code class="inlinecode">HTMX</code> to send a <code class="inlinecode">get</code> request to <code class="inlinecode">/api/products/table</code> and display<a id="_idIndexMarker1106" class="calibre3"/> the results in the <code class="inlinecode">content</code> element.</p>
<h3 class="heading2" id="_idParaDest-352">Adding product data validation</h3>
<p class="normal1">The data that is received<a id="_idIndexMarker1107" class="calibre3"/> from the product editing form must be validated before it is stored in the database. Add a file named <code class="inlinecode">product_dto_rules.ts</code> to the <code class="inlinecode">src/data/validation</code> folder with the content shown in <em class="italic">Listing 20.28</em>. </p>
<p class="packt_figref">Listing 20.28: The contents of the product_dto_rules.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">import { Validator } from "./validator";
import { required, minLength } from "./basic_rules";
import { ValidationStatus } from ".";
import { CategoryModel, SupplierModel } from "../orm/models";
type ProductDTO = {
    name: string, description: string, categoryId: number,
    supplierId: number, price: number
}
const supplierExists = async (status: ValidationStatus) =&gt; {
    const count = await SupplierModel.count({ where: { id: status.value } });
    if (count !== 1) {
        status.setInvalid(true);
        status.messages.push("A valid supplier is required");       
    }
}
const categoryExists = async (status: ValidationStatus) =&gt; {
    const count = await CategoryModel.count({ where: { id: status.value } });
    if (count !== 1) {
        status.setInvalid(true);
        status.messages.push("A valid category is required");       
    }
}
export const ProductDTOValidator = new Validator&lt;ProductDTO&gt;({   
    name: [required, minLength(3)],
    description: required,
    categoryId : categoryExists,
    supplierId: supplierExists,
    price: required,
});
</code></pre>
<p class="normal">The <code class="inlinecode">ProductDTO</code> type represents<a id="_idIndexMarker1108" class="calibre3"/> the data that will be received when the user edits<a id="_idIndexMarker1109" class="calibre3"/> a product and submits the form (the term <strong class="screentext">DTO</strong> means <strong class="screentext">data transfer object</strong> and is used to describe types that represent data when it is transferred). The validation rules for the <code class="inlinecode">ProductDTO</code> type are exported as a constant, named <code class="inlinecode">ProductDTOValidator</code>. Two custom rules are required to ensure that a value corresponds to an existing supplier or category in the database. <em class="italic">Listing 20.29</em> incorporates the new validator.</p>
<p class="packt_figref">Listing 20.29: Adding a validator to the index.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">export * from "./validation_types";
export * from "./validator";
export * from "./basic_rules";
export * from "./order_rules";
<strong class="screentext">export * from "./product_dto_rules";</strong>
</code></pre>
<h3 class="heading2" id="_idParaDest-353">Adding the routes for editing</h3>
<p class="normal1">Two new routes are required<a id="_idIndexMarker1110" class="calibre3"/> to support editing: the first route<a id="_idIndexMarker1111" class="calibre3"/> receives an HTTP <code class="inlinecode">GET</code> request and responds with a populated HTML form. The second route receives the HTTP <code class="inlinecode">PUT</code> request and is responsible for validating the data and storing it. Both routes are defined in <em class="italic">Listing 20.30</em>.</p>
<p class="packt_figref">Listing 20.30: Adding editing routes to the admin_catalog_routes.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { CategoryModel, ProductModel, SupplierModel }
    from "../../data/orm/models";
<strong class="screentext">import { ProductDTOValidator, getData, isValid } from "../../data/validation";</strong>
export const createAdminCatalogRoutes = (router: Router) =&gt; {
    // ...existing routes omitted for brevity...
    <strong class="screentext">router.get("/edit/:id", async (req, resp) =&gt; {</strong>
<strong class="screentext">        const id = req.</strong><strong class="screentext">params.id;</strong>
<strong class="screentext">        const data = {</strong>
<strong class="screentext">            product: { id: { value: id },</strong>
<strong class="screentext">                ...await ProductDTOValidator.validate(</strong>
<strong class="screentext">                await </strong><strong class="screentext">ProductModel.findByPk(id, { raw: true}))},</strong>
<strong class="screentext">            suppliers: await SupplierModel.findAll({raw: true}),</strong>
<strong class="screentext"> </strong><strong class="screentext">categories: await CategoryModel.findAll({raw: true})</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        resp.render("admin/product_editor", data);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    router.put("/:id", </strong><strong class="screentext">async (req, resp) =&gt; {</strong>
<strong class="screentext">        const validation = await ProductDTOValidator.validate(req.body);</strong>
<strong class="screentext">        if (isValid(validation)) {</strong>
<strong class="screentext">            await ProductModel.</strong><strong class="screentext">update(</strong>
<strong class="screentext">                getData(validation), { where: { id: req.params.id}}</strong>
<strong class="screentext">            );</strong>
<strong class="screentext">            resp.redirect(303, "/api/products/table");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.</strong><strong class="screentext">render("admin/product_editor", {</strong>
<strong class="screentext">                product: { id: { value: req.params.id} , ...validation },</strong>
<strong class="screentext">                suppliers: await SupplierModel.</strong><strong class="screentext">findAll({raw: true}),</strong>
<strong class="screentext">                categories: await CategoryModel.findAll({raw: true})</strong>
<strong class="screentext">            })</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });   </strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">GET</code> route receives the <code class="inlinecode">ID</code> of the product that the user wants to edit through the URL and queries the database to get the data, which is fed through the validator so that the same template can be used when editing starts and invalid data is received.</p>
<p class="normal">The <code class="inlinecode">PUT</code> route receives<a id="_idIndexMarker1112" class="calibre3"/> data that the user wants to store, with the <code class="inlinecode">ID</code> received<a id="_idIndexMarker1113" class="calibre3"/> from the URL. The data is validated, and if it is invalid, the <code class="inlinecode">admin/product_editor</code> template is rendered, which will display the validation messages to the user.</p>
<p class="normal">If the data is valid, the database is updated and the browser is redirected, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
resp.redirect(303, "/api/products/table");
...
</code></pre>
<p class="normal">The <code class="inlinecode">303</code> status code causes the browser to request the specified URL, using an HTTP <code class="inlinecode">GET</code> request, and effectively ends the editing session by displaying the product data, which will include the edited data.</p>
<p class="normal">One problem with the <code class="inlinecode">303</code> redirection is that it will fail during development because the default security configuration applied by the Helmet package tells the browser to upgrade insecure requests. This means that the <code class="inlinecode">303</code> redirection tells the browser to request <code class="inlinecode">http://localhost:5000/api/products/table</code>; however, due to the security policy, the browser will make an HTTPS request instead. <em class="italic">Listing 20.31</em> adds a new section to the configuration file that will be used to configure the Helmet package.</p>
<p class="packt_figref">Listing 20.31: Adding a section to the server.config.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000,
        <strong class="screentext">"content_security": {</strong>
<strong class="screentext">            "</strong><strong class="screentext">contentSecurityPolicy": {</strong>
<strong class="screentext">                "directives": {</strong>
<strong class="screentext">                    "upgradeInsecureRequests": null</strong>
<strong class="screentext">                }</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        }</strong>
    },
    // ...other configuration sections omitted for brevity...
}
</code></pre>
<p class="normal"><em class="italic">Listing 20.32</em> updates the application<a id="_idIndexMarker1114" class="calibre3"/> configuration to disable insecure<a id="_idIndexMarker1115" class="calibre3"/> upgrades when the application is in the development environment.</p>
<p class="packt_figref">Listing 20.32: Disabling insecure upgrades in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
import { getConfig, getEnvironment, Env } from "./config";
import { createRoutes } from "./routes";
import { createTemplates } from "./helpers";
import { createErrorHandlers } from "./errors";
import { createSessions } from "./sessions";
import { createAuthentication } from "./authentication";
import httpProxy from "http-proxy";
const port = getConfig("http:port", 5000);
const expressApp: Express = express();
<strong class="screentext">expressApp.use(helmet(</strong><strong class="screentext">getConfig("http:content_security", {})));</strong>
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use(express.static("node_modules/bootstrap-icons"));
expressApp.use(express.static("node_modules/htmx.org/dist"));
createTemplates(expressApp);
createSessions(expressApp);
createAuthentication(expressApp);
createRoutes(expressApp);
const server = createServer(expressApp);
if (getEnvironment() === Env.Development) {
    const proxy = httpProxy.createProxyServer({
        target: "http://localhost:5100", ws: true
    });   
    expressApp.use("/admin", (req, resp) =&gt; proxy.web(req, resp));
    server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
}
createErrorHandlers(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Let the browser reload<a id="_idIndexMarker1116" class="calibre3"/> automatically or navigate to <code class="inlinecode">http://localhost:5000/admin</code>, and click <a id="_idIndexMarker1117" class="calibre3"/>the <strong class="screentext">Edit</strong> button for one of the products. Clear the <strong class="screentext">Name</strong> field and click the <strong class="screentext">Save</strong> button to see a validation error. Enter a new name and click the <strong class="screentext">Save</strong> button again, and you will see the modified data displayed in the overview table, as shown in <em class="italic">Figure 20.5</em>.</p>
<p class="normal">You may need to clear your browser cache for the change in the security policy to take effect. Some browsers, including Chrome, will keep trying to upgrade to HTTPS connections until the cache is cleared.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.5: Validating and editing data</p>
<p class="normal">Bear in mind that the application<a id="_idIndexMarker1118" class="calibre3"/> is configured to reset the database<a id="_idIndexMarker1119" class="calibre3"/> every time there is a change, which means that the changes you make will be lost as soon as a file change is detected.</p>
<h3 class="heading2" id="_idParaDest-354">Creating new products</h3>
<p class="normal1">The final feature<a id="_idIndexMarker1120" class="calibre3"/> is to create new products. <em class="italic">Listing 20.33</em> adds a new <code class="inlinecode">button</code> element that will send an <code class="inlinecode">HTTP</code> <code class="inlinecode">GET</code> request to start the editing process. </p>
<p class="packt_figref">Listing 20.33: Adding an element to the product_table.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="products"}}
&lt;table class="table table-sm"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Category&lt;/th&gt;&lt;th&gt;Supplier&lt;/th&gt;
            &lt;th class="text-end"&gt;Price&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#each products }}   
            {{&gt; admin/product_row }}
        {{/each }}
    &lt;/tbody&gt;
&lt;/table&gt;
<strong class="screentext">&lt;button class="btn btn-secondary" hx-get="/api/products/create"</strong>
<strong class="screentext">        hx-target="#content"&gt;</strong>
<strong class="screentext">    Create</strong>
<strong class="screentext">&lt;/button&gt;</strong>
</code></pre>
<p class="normal"><em class="italic">Listing 20.34</em> updates the editor template<a id="_idIndexMarker1121" class="calibre3"/> so that a different <code class="inlinecode">form</code> element is included in the HTML output, based on the value of a property named <code class="inlinecode">create</code>, so <code class="inlinecode">POST</code> requests are used when creating new products while <code class="inlinecode">PUT</code> requests are used to modify existing data.</p>
<p class="packt_figref">Listing 20.34: Changing the form in the product_editor.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="products"}}
<strong class="screentext">{{#if create}}</strong>
<strong class="screentext">&lt;form hx-post="/api/products/create"&gt;</strong>
<strong class="screentext">{{else}}</strong>
<strong class="screentext">&lt;form hx-put="/api/products/{{product.id.value}}"&gt;</strong>
<strong class="screentext">{{/if}}</strong>
    {{&gt; admin/product_input label="ID" name="id" data=product.id }}
    {{&gt; admin/product_input label="Name" name="name" data=product.name }}
    &lt;div class="mb-2"&gt;
        &lt;label&gt;Description&lt;/label&gt;
        &lt;textarea name="description"
            class="form-control"&gt;{{ product.description.value }}&lt;/textarea&gt;
        {{&gt; admin/validation_messages product.description }}           
    &lt;/div&gt;
    {{&gt; admin/product_select label="Category" name="categoryId"
            data=product.categoryId list=categories}}
    {{&gt; admin/product_select label="Supplier" name="supplierId"
            data=product.supplierId list=suppliers}}
    {{&gt; admin/product_input label="Price" name="price" data=product.price }}
    &lt;div&gt;
        &lt;button type="submit" class="btn btn-secondary text-white"&gt;Save&lt;/button&gt;
        &lt;button class="btn btn-outline-secondary"
            hx-get="/api/products/table" hx-target="#content"&gt;Cancel&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p class="normal"><em class="italic">Listing 20.35</em> adds two new routes, which handle<a id="_idIndexMarker1122" class="calibre3"/> the <code class="inlinecode">GET</code> request that starts the creation process and the <code class="inlinecode">POST</code> request that is sent when the user submits the form.</p>
<p class="packt_figref">Listing 20.35: Adding routes to the admin_catalog_routes.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { CategoryModel, ProductModel, SupplierModel }
    from "../../data/orm/models";
import { ProductDTOValidator, getData, isValid } from "../../data/validation";
export const createAdminCatalogRoutes = (router: Router) =&gt; {
    // ...other routes omitted for brevity...
    <strong class="screentext">router.get("/create", async (req, resp) =&gt; {</strong>
<strong class="screentext">        const data = {</strong>
<strong class="screentext">            product: {},</strong>
<strong class="screentext">            suppliers: await </strong><strong class="screentext">SupplierModel.findAll({raw: true}),</strong>
<strong class="screentext">            categories: await CategoryModel.findAll({raw: true}),</strong>
<strong class="screentext"> </strong><strong class="screentext">create: true</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        resp.render("admin/product_editor", data);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    router.post("/create", async (req, resp) =&gt; {</strong>
<strong class="screentext">        const validation = await </strong><strong class="screentext">ProductDTOValidator.validate(req.body);</strong>
<strong class="screentext">        if (isValid(validation)) {</strong>
<strong class="screentext">            await ProductModel.create(getData(validation));</strong>
<strong class="screentext">            resp.redirect(</strong><strong class="screentext">303, "/api/products/table");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.render("admin/product_editor", {</strong>
<strong class="screentext">                product: validation,</strong>
<strong class="screentext">                suppliers: await SupplierModel.findAll({</strong><strong class="screentext">raw: true}),</strong>
<strong class="screentext">                categories: await CategoryModel.findAll({raw: true}),</strong>
<strong class="screentext">                create: true</strong>
<strong class="screentext">            })</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });  </strong>
}
</code></pre>
<p class="normal">Let the browser reload<a id="_idIndexMarker1123" class="calibre3"/> or request <code class="inlinecode">http://localhost:5000/admin</code>, and then click the <strong class="screentext">Create</strong> button. Fill out the form and click the <strong class="screentext">Save</strong> button to create a new product, as shown in <em class="italic">Figure 20.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.6: Creating a new product</p>
<h1 class="heading" id="_idParaDest-355">Administering orders</h1>
<p class="normal1">Now that the product<a id="_idIndexMarker1124" class="calibre3"/> features are in place, it is time to turn to the order data. Add a file named <code class="inlinecode">admin_order_routes.ts</code> to the <code class="inlinecode">src/routes/admin</code> folder with the content shown in <em class="italic">Listing 20.36</em>. </p>
<p class="packt_figref">Listing 20.36: The contents of the admin_order_routes.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { AddressModel, OrderModel, ProductSelectionModel }
    from "../../data/orm/models/order_models";
import { CustomerModel } from "../../data/orm/models/customer_models";
import { ProductModel } from "../../data/orm/models";
export const createAdminOrderRoutes = (router: Router) =&gt; {
    router.get("/table", async (req, resp) =&gt; {
        const orders = (await OrderModel.findAll({
            include: [
                { model: CustomerModel, as: "customer"},
                { model: AddressModel, as: "address"},
                { model: ProductSelectionModel, as: "selections",
                    include: [{ model: ProductModel, as: "product"}]
                }
            ],
            order: ["shipped", "id"]
        })).map(o =&gt; o.toJSON())
        resp.render("admin/order_table", { orders });
    });
    router.post("/ship", async (req, resp) =&gt; {
        const { id, shipped } = req.body;
        const [rows] = await  OrderModel.update({ shipped },{ where: { id }});
        if (rows === 1) {
            resp.redirect(303, "/api/orders/table");
        } else {
            throw new Error(`Expected 1 row updated, but got ${rows}`);
        }
    });
}
</code></pre>
<p class="normal">The route that handles <code class="inlinecode">GET</code> requests renders<a id="_idIndexMarker1125" class="calibre3"/> a template named <code class="inlinecode">admin/order_table</code>, which is provided with the orders from the database. Earlier queries used the <code class="inlinecode">raw</code> setting, which tells Sequelize to pass on the data as it is read from the database, which is a good technique when the data is naturally in a structure that suits the template that consumes it. In this case, the nested <code class="inlinecode">include</code> properties lead to queries that are not readily used without additional processing. Instead of using the <code class="inlinecode">raw</code> setting, <code class="inlinecode">Sequelize</code> processes the data, which is then converted<a id="_idIndexMarker1126" class="calibre3"/> to a simple object format using the <code class="inlinecode">toJSON</code> method:</p>
<pre class="programlisting"><code class="hljs-code">...
const orders = (await OrderModel.findAll({
    include: [{ model: CustomerModel, as: "customer"},
              { model: AddressModel, as: "address"},
              { model: ProductSelectionModel, as: "selections",
                    include: [{ model: ProductModel, as: "product"}]
               }],
            order: ["shipped", "id"]
        })).map(o =&gt; o.<strong class="screentext">toJSON</strong>())
...
</code></pre>
<p class="normal">The <code class="inlinecode">toJSON</code> method is required because Sequelize usually creates objects that track changes so they can be written to a database, but this confuses the template engine. The <code class="inlinecode">toJSON</code> method creates objects without the tracking functionality and which are suitable for template use.</p>
<p class="normal">The handler for <code class="inlinecode">POST</code> requests is used to change the shipping status of orders. If a request is received that corresponds to an order in the database, then the database is updated and a redirection is performed using the <code class="inlinecode">HTTP 303</code> status code.</p>
<p class="normal"><em class="italic">Listing 20.37</em> enables the order routes so that they are reached through the <code class="inlinecode">/api/orders</code> prefix.</p>
<p class="packt_figref">Listing 20.37: Configuring routes in the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Router } from "express";
import { createAdminCatalogRoutes } from "./admin_catalog_routes";
<strong class="screentext">import</strong><strong class="screentext"> { createAdminOrderRoutes } from "./admin_order_routes";</strong>
export const createAdminRoutes = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        resp.locals.layout = false;
        next();
    })
    const cat_router = Router();
    createAdminCatalogRoutes(cat_router);
    app.use("/api/products", cat_router);
    <strong class="screentext">const</strong><strong class="screentext"> order_router = Router();</strong>
<strong class="screentext">    createAdminOrderRoutes(order_router);</strong>
<strong class="screentext">    app.use("/api/orders", order_router);</strong>
    app.get("/admin", (req, resp) =&gt; resp.render("admin/admin_layout"));
}
</code></pre>
<p class="normal">To create the template<a id="_idIndexMarker1127" class="calibre3"/> that will present the order data, add a file named <code class="inlinecode">order_table.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.38</em>.</p>
<p class="packt_figref">Listing 20.38: The contents of the order_table.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="orders"}}
&lt;table class="table table-sm table-bordered"&gt;
    &lt;thead&gt;&lt;tr&gt;&lt;th colspan="7" class="text-center"&gt;Orders&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
    &lt;tbody&gt;
        {{#unless orders}}
          &lt;tr&gt;&lt;td colspan="7" class="text-center"&gt;No Orders&lt;/td&gt;&lt;/tr&gt;
        {{/unless}}
        {{#each orders}}
            &lt;tr class="table-active"&gt;
                &lt;th&gt;#&lt;/th&gt;&lt;th&gt;Customer&lt;/th&gt;&lt;th&gt;ZIP&lt;/th&gt;
                &lt;th&gt;Product&lt;/th&gt;&lt;th&gt;Quantity&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;th&gt;&lt;/th&gt;
            &lt;/tr&gt;
            {{#each selections}}
            &lt;tr&gt;
                {{#if (first @index)}}
                    &lt;td&gt;{{ ../id }}&lt;/td&gt;
                    &lt;td&gt;{{ ../customer.name }}&lt;/td&gt;
                    &lt;td&gt;{{ ../address.zip }}&lt;/td&gt;
                {{else }}
                    &lt;th colspan="3"&gt;&lt;/th&gt;
                {{/if}}
                &lt;td&gt;{{product.name}}&lt;/td&gt;
                &lt;td&gt;{{ quantity }}&lt;/td&gt;
                &lt;td&gt;{{currency product.price}}&lt;/td&gt;
                {{#if (first @index)}}
                    {{&gt; admin/order_button id=../id shipped=../shipped}}
                {{else}}
                    &lt;td&gt;&lt;/td&gt;
                {{/if}}
                &lt;/tr&gt;
            {{/each }}
            &lt;tr&gt;
                &lt;th colspan="5" class="text-end"&gt;Total:&lt;/th&gt;
                &lt;td&gt;{{currency (total selections)}}&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">The complexity in this template<a id="_idIndexMarker1128" class="calibre3"/> is the structure of the table, in which order details are presented using summary and detail rows. To create a template that will present the user with a button to change the shipping status, create a file named <code class="inlinecode">order_button.handlebars</code> in the <code class="inlinecode">templates/admin</code> folder, with the content shown in <em class="italic">Listing 20.39</em>.</p>
<p class="packt_figref">Listing 20.39: The contents of the order_button.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;td&gt;
    &lt;form hx-post="/api/orders/ship" hx-target="#content"&gt;
        &lt;input type="hidden" name="id" value="{{id}}"&gt;
        {{#if shipped }}
            &lt;input type="hidden" name="shipped" value="false"&gt;
            &lt;button class="btn btn-sm btn-warning"&gt;Mark Unshipped&lt;/button&gt;
        {{else }}
            &lt;input type="hidden" name="shipped" value="true"&gt;
            &lt;button class="btn btn-sm btn-danger"&gt;Ship Order&lt;/button&gt;
        {{/if}}
    &lt;/form&gt;
&lt;/td&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">hx-post</code> attribute tells <code class="inlinecode">HTMX</code> to send a <code class="inlinecode">POST</code> request when the user clicks the button. <em class="italic">Listing 20.40</em> defines the helpers that are required for the orders template.</p>
<p class="packt_figref">Listing 20.40: Adding a helper to the admin_helpers.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">export const buttonClass = (btn: string, mode: string) =&gt;
    btn == mode ? "btn-secondary" : "btn-outline-secondary";
export const disabled = (val: any) =&gt; val == "ID" ? "disabled" : "";
export const selected = (val1: any, val2: any) =&gt;
    val1 == val2 ? "selected" : "";
<strong class="screentext">export const first = (index: number) =&gt; index == 0;</strong>
<strong class="screentext">export const total = (sels: any[]) =&gt;</strong>
<strong class="screentext">    sels.reduce((total, s) =&gt; total += (s.quantity * s.product.price), 0);</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">first</code> helper is used to determine whether a value is the first element in an array and to work out where to insert the customer details and the status change buttons. This relies on the Handlebars <code class="inlinecode">each</code> helper, which provides an <code class="inlinecode">@index</code> value that reports the index of the element being processed:</p>
<pre class="programlisting"><code class="hljs-code">...
{{#if (first <strong class="screentext">@index</strong>)}}
...
</code></pre>
<p class="normal">The <code class="inlinecode">total</code> helper calculates the total value of the product selections in the order and is combined with the existing <code class="inlinecode">currency</code> helper to create a formatted total price for the order:</p>
<pre class="programlisting"><code class="hljs-code">...
&lt;td&gt;{{currency (<strong class="screentext">total</strong> selections)}}&lt;/td&gt;
...
</code></pre>
<p class="normal">There are no orders in the seed data, so the first step in checking the administration features is to create some orders. Navigate to <code class="inlinecode">http://localhost:5000</code>, add products to the cart, and check out to create an order. Navigate to <code class="inlinecode">http://localhost:5000/admin</code>, click the <strong class="screentext">Orders</strong> button, and use the buttons to toggle<a id="_idIndexMarker1129" class="calibre3"/> the shipment status of orders, as shown in <em class="italic">Figure 20.7</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.7: Changing the order shipping status</p>
<h1 class="heading" id="_idParaDest-356">Fixing the URLs</h1>
<p class="normal1">The <code class="inlinecode">HTMX</code> package<a id="_idIndexMarker1130" class="calibre3"/> makes asynchronous HTTP requests to the web service and displays the results, which is an effective way to create a responsible application, but the result doesn’t behave correctly. To see the problem, navigate to <code class="inlinecode">http://localhost:5000/admin</code>, click the <strong class="screentext">Orders</strong> button, and then click the browser’s reload button. Instead of reloading the <strong class="screentext">Orders</strong> table, the products are displayed, as shown in <em class="italic">Figure 20.8</em>. </p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_08.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.8: Reloading the browser</p>
<p class="normal">The browser isn’t aware of the effect of user interaction, and reloading effectively resets the client, which displays the product table. To fix this means defining a set of routes that allow direct navigation to specific application features, as well as configuring <code class="inlinecode">HTMX</code> to add URLs that will target those routes following user interaction. <em class="italic">Listing 20.41</em> defines the routes required to navigate directly<a id="_idIndexMarker1131" class="calibre3"/> to the products table, the orders table, and the editor for a specific product.</p>
<p class="packt_figref">Listing 20.41: Adding direct routes to the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Router } from "express";
import { createAdminCatalogRoutes } from "./admin_catalog_routes";
import { createAdminOrderRoutes } from "./admin_order_routes";
export const createAdminRoutes = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        resp.locals.layout = false;
        next();
    })
    const cat_router = Router();
    createAdminCatalogRoutes(cat_router);
    app.use("/api/products", cat_router);
    const order_router = Router();
    createAdminOrderRoutes(order_router);
    app.use("/api/orders", order_router);
    app.get("/admin", (req, resp) =&gt; resp.redirect("/admin/products"));
<strong class="screentext">    app.get("/admin/products", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.locals.content = "/api/products/table";</strong>
<strong class="screentext">        resp.render("admin/admin_layout"</strong><strong class="screentext">);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    app.get("/admin/products/edit/:id", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.locals.content = `/api/products/edit/${req.params.id}`;</strong>
<strong class="screentext">        resp.render("admin/admin_layout"</strong><strong class="screentext">);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    app.get("/admin/orders", (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.locals.content = "/api/orders/table";</strong>
<strong class="screentext">        resp.render("admin/admin_layout");</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The new routes render<a id="_idIndexMarker1132" class="calibre3"/> the <code class="inlinecode">admin_layout</code> template with a <code class="inlinecode">content</code> value that specifies the URL that <code class="inlinecode">HTMX</code> should use to request content. For consistency, the <code class="inlinecode">/admin</code> route sends a redirection to the <code class="inlinecode">/admin/products</code> URL. <em class="italic">Listing 20.42</em> updates the template to use the <code class="inlinecode">content</code> value that is provided by the new routes.</p>
<p class="packt_figref">Listing 20.42: Loading a URL into the admin_layout.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
        &lt;link href="/font/bootstrap-icons.min.css" rel="stylesheet"&gt;
        &lt;script src="img/bundle.js" defer&gt;&lt;/script&gt;
        &lt;script src="img/htmx.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container-fluid"&gt;
            &lt;div class="row bg-info text-white py-2 px-1"&gt;
                &lt;div class="col align-baseline pt-1"&gt;SPORTS STORE ADMIN&lt;/div&gt;
                &lt;div class="col-auto text-end"&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row p-2"&gt;
                &lt;div class="col-2" id="area_buttons"&gt;&lt;/div&gt;
                <strong class="screentext">&lt;div class="col" id="content" hx-get="{{content}}"</strong>
<strong class="screentext">                    hx-trigger</strong><strong class="screentext">="load"&gt;&lt;/div&gt;</strong>
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The web service URLs that provide fragments of HTML content are of no use for direct navigation because they do not provide a complete HTML document. Fortunately, <code class="inlinecode">HTMX</code> supports the <code class="inlinecode">hx-push-url</code> attribute, which adds a URL to the browser’s history, as shown in <em class="italic">Listing 20.43</em>.</p>
<p class="packt_figref">Listing 20.43: Pushing URLs into the area_buttons.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;swap_wrapper hx-swap-oob="innerHTML:#area_buttons"&gt;
    &lt;div class="d-grid gap-2" &gt;
        <strong class="screentext">&lt;button</strong><strong class="screentext"> id="products_btn" class="btn {{ buttonClass "products" mode }}"</strong>
<strong class="screentext">            hx-get="/api/products/table" hx-target="#content"</strong>
<strong class="screentext"> </strong><strong class="screentext">hx-push-url="/admin/products"&gt;</strong>
            Products
        &lt;/button&gt;
        <strong class="screentext">&lt;button id="orders_btn" class="btn {{ buttonClass "orders"</strong><strong class="screentext"> mode }}"</strong>
<strong class="screentext">            hx-get="/api/orders/table" hx-target="#content"</strong>
<strong class="screentext">            hx-push-url="/admin/orders"&gt;</strong>
            Orders
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/swap_wrapper&gt;
</code></pre>
<p class="normal">When the user clicks<a id="_idIndexMarker1133" class="calibre3"/> on one of the buttons, the <code class="inlinecode">HTMX</code> package will request a fragment of HTML from the web service but will add one of the direct navigation URLs to the browser’s history. <em class="italic">Listing 20.44</em> applies the same attribute to the button that starts the editing process for a product.</p>
<p class="packt_figref">Listing 20.44: Pushing a URL into the product_row.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;tr id="row{{ id }}"&gt;
    &lt;td&gt;{{ id }}&lt;/td&gt;
    &lt;td&gt;{{ name }}&lt;/td&gt;
    &lt;td&gt;{{ category.name  }}&lt;/td&gt;
    &lt;td&gt;{{ supplier.name  }}&lt;/td&gt;
    &lt;td class="text-end"&gt;{{ currency price}}&lt;/td&gt;
    &lt;td class="ps-3"&gt;       
       <strong class="screentext"> &lt;button class="btn btn-sm btn-warning"</strong>
<strong class="screentext">hx-get="</strong><strong class="screentext">/api/products/edit/{{id}}" hx-target="#content"</strong>
<strong class="screentext">                hx-push-url="/admin/products/edit/{{id}}"&gt;</strong>
                Edit
            &lt;/button&gt;
        &lt;button class="btn btn-sm btn-danger"
            hx-delete="/api/products/{{id}}" hx-target="#row{{id}}"
                    hx-swap="delete"&gt;
                Delete
        &lt;/button&gt;           
    &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<p class="normal">Navigate to <code class="inlinecode">http://localhost:5000/admin</code>, and your browser will be redirected to <code class="inlinecode">http://localhost:5000/admin/products</code>. Click the <strong class="screentext">Orders</strong> button, and the URL bar will display <code class="inlinecode">http://localhost:5000/admin/orders</code>, even though <code class="inlinecode">HTMX</code> sent an HTTP request to the <code class="inlinecode">/api/orders/table</code> URL.</p>
<p class="normal">Click the reload button, and the browser<a id="_idIndexMarker1134" class="calibre3"/> will display the <strong class="screentext">Orders</strong> list. (The database will have been reset when the files changed and will not contain any orders.) Request <code class="inlinecode">http://localhost:5000/admin/products/edit/2</code>, and you will see the editor for the <code class="inlinecode">Lifejacket</code> product, as shown in <em class="italic">Figure 20.9</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_09.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.9: Navigating directly to an application feature</p>
<h1 class="heading" id="_idParaDest-357">Restricting access to administration features</h1>
<p class="normal1">Access to the administration features<a id="_idIndexMarker1135" class="calibre3"/> should be restricted to approved users, which means implementing authentication and authorization. The application already has support to identify users, using Google accounts, and the quickest way to restrict access is to configure the application to restrict access to a predefined list of accounts. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Using OAuth to authenticate administrators is a useful way to identify users, but care should be taken in real projects to ensure some form of administration access if the OAuth service is unavailable.</p>
</div>
<p class="normal">To start, navigate to <a href="https://console.developers.google.com" class="calibre3">https://console.developers.google.com</a>, click <strong class="screentext">Credentials</strong>, and select the <strong class="screentext">Edit OAuth Client</strong> action, which is represented<a id="_idIndexMarker1136" class="calibre3"/> by the pencil icon, as shown in <em class="italic">Figure 20.10</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_10.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.10: Editing the OAuth client</p>
<p class="normal">Add the following URLs to the <strong class="screentext">Authorized redirect URIs</strong> section:</p>
<ul class="calibre4">
<li class="bulletlist"><code class="inlinecode">http://localhost:5000/auth-signin-google</code></li>
<li class="bulletlist1"><code class="inlinecode">https://localhost/auth-signin-google</code></li>
</ul>
<p class="normal">There should now be four URIs in this section, as shown in <em class="italic">Figure 20.11</em>. Click <strong class="screentext">Save</strong> to update the OAuth configuration.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_11.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.11: The authorized redirection URLs</p>
<p class="normal">Returning to the code<a id="_idIndexMarker1137" class="calibre3"/> editor, add a new <code class="inlinecode">configuration</code> section that provides the application with the OAuth redirection and a list of approved administration users, as shown in <em class="italic">Listing 20.45</em>. (You must enter the email address for a Google account for which you have the credentials to be able to authenticate yourself.)</p>
<p class="packt_figref">Listing 20.45: Adding a configuration section to the server.config.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000,
        "content_security": {
            "contentSecurityPolicy": {
                "directives": {
                    "upgradeInsecureRequests": null
                }
            }           
        }       
    },
   
    // ...configuration settings omitted for brevity...
    "auth": {
        "openauth": {
            "redirectionUrl": "http://localhost:5000/signin-google"
        }
    },
    <strong class="screentext">"admin": {</strong>
<strong class="screentext">        "openauth": {</strong>
<strong class="screentext">            "redirectionUrl": "http://localhost:5000/auth-signin-google"</strong>
<strong class="screentext">        },</strong>
<strong class="screentext">        "users": ["alice@example.com", "your_account@google.com"]</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal"><em class="italic">Listing 20.46</em> creates a new authentication<a id="_idIndexMarker1138" class="calibre3"/> strategy and adds a new property to the <code class="inlinecode">User</code> interface that differentiates between authentication for administration and authentication for placing orders.</p>
<p class="packt_figref">Listing 20.46: Creating a strategy in the authentication.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { getConfig, getSecret } from "./config";
import passport from "passport";
import { Strategy as GoogleStrategy, Profile, VerifyCallback }
    from "passport-google-oauth20";
import { customer_repository } from "./data";
import { Customer } from "./data/customer_models";
const callbackURL: string = getConfig("auth:openauth:redirectionUrl");
const clientID = getSecret("GOOGLE_CLIENT_ID");
const clientSecret = getSecret("GOOGLE_CLIENT_SECRET");
<strong class="screentext">const authCallbackURL: string = getConfig("</strong><strong class="screentext">admin:openauth:redirectionUrl")</strong>
declare global {
    namespace Express {
        interface User extends Customer {
           <strong class="screentext"> adminUser?: boolean;</strong>
        }
    }
}
export const createAuthentication = (app:Express) =&gt; {
    <strong class="screentext">passport.use("admin-auth", new GoogleStrategy({</strong>
<strong class="screentext">        clientID, clientSecret, callbackURL: authCallbackURL,</strong>
<strong class="screentext">        scope: ["email", "</strong><strong class="screentext">profile"],</strong>
<strong class="screentext">        state: true       </strong>
<strong class="screentext">    }, (accessToken: string, refreshToken: string,</strong>
<strong class="screentext">            profile: Profile, callback: VerifyCallback) =&gt; {</strong>
<strong class="screentext">        return callback(null, {</strong>
<strong class="screentext">            name: profile.displayName,</strong>
<strong class="screentext"> </strong><strong class="screentext">email: profile.emails?.[0].value ?? "",</strong>
<strong class="screentext">            federatedId: profile.id,</strong>
<strong class="screentext">            adminUser: true</strong>
<strong class="screentext">        })   </strong>
<strong class="screentext">    }));</strong>
    passport.use(new GoogleStrategy({
        clientID, clientSecret, callbackURL,
        scope: ["email", "profile"],
        state: true
    } , async (accessToken: string, refreshToken: string,
            profile: Profile, callback: VerifyCallback) =&gt; {
        const emailAddr = profile.emails?.[0].value ?? "";           
        const customer = await customer_repository.storeCustomer({
            name: profile.displayName, email: emailAddr,
            federatedId: profile.id
        });
        const { id, name, email } = customer;
        return callback(null, { id, name, email });
    }));
    passport.serializeUser((user, callback) =&gt; {
        <strong class="screentext">callback(null, user.adminUser ? JSON.stringify(user) : user.id);</strong>
    });
    <strong class="screentext">passport.</strong><strong class="screentext">deserializeUser((id: number | string , callbackFunc) =&gt; {</strong>
<strong class="screentext">        if (typeof id == "string") {</strong>
<strong class="screentext">            callbackFunc(null, JSON.parse(id));</strong>
<strong class="screentext">        } </strong><strong class="screentext">else {</strong>
            customer_repository.getCustomer(id).then(user =&gt;
                callbackFunc(null, user));
        }
    });
    app.use(passport.session());
}
</code></pre>
<p class="normal">The new strategy is created<a id="_idIndexMarker1139" class="calibre3"/> with the name <code class="inlinecode">admin-auth</code> to differentiate it from the existing OAuth strategy. The new callback URL is read from the configuration file and used to create the strategy, and the callback function creates a USER with the <code class="inlinecode">adminUser</code> property set to <code class="inlinecode">true</code>.</p>
<p class="normal">There is no persistent data store for administration user details, so the <code class="inlinecode">serializeUser</code> and <code class="inlinecode">deserializeUser</code> functions have been modified to serialize the entire <code class="inlinecode">User</code> object in the session, but only when the <code class="inlinecode">adminUser</code> property is <code class="inlinecode">true</code>.</p>
<p class="normal">A new set of routes is required to handle administration authentication, along with middleware components to authorize requests, as shown in <em class="italic">Listing 20.47</em>.</p>
<p class="packt_figref">Listing 20.47: Adding routes and middleware to the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, NextFunction, Request, Response, Router } from "express";
import { createAdminCatalogRoutes } from "./admin_catalog_routes";
import { createAdminOrderRoutes } from "./admin_order_routes";
<strong class="screentext">import passport from "passport";</strong>
<strong class="screentext">import { getConfig} from "../../config";</strong>
<strong class="screentext">const users: string[] = getConfig("admin:users", []);</strong>
export const createAdminRoutes = (app: Express) =&gt; {
    app.use((req, resp, next) =&gt; {
        resp.locals.layout = false;
        <strong class="screentext">resp.locals.user = req.user;</strong>
        next();
    });
    <strong class="screentext">app.get("</strong><strong class="screentext">/admin/signin", (req, resp) =&gt; resp.render("admin/signin"));</strong>
<strong class="screentext">    app.post("/admin/signout", (req, resp) =&gt;</strong>
<strong class="screentext">        req.logOut(</strong><strong class="screentext">() =&gt; { resp.redirect("/admin/signin") }));</strong>
<strong class="screentext">    app.get("/admin/google", passport.authenticate("admin-auth"));</strong>
<strong class="screentext">    app.get("/auth-signin-google", passport.authenticate("</strong><strong class="screentext">admin-auth", {</strong>
<strong class="screentext">        successRedirect: "/admin/products", keepSessionInfo: true</strong>
<strong class="screentext">    }));   </strong>
<strong class="screentext">    const authCheck = (r: Request) =&gt; users.find(u =&gt;</strong><strong class="screentext"> r.user?.email === u);</strong>
<strong class="screentext">    const apiAuth = (req: Request, resp: Response, next: NextFunction) =&gt; {</strong>
<strong class="screentext">        if (!authCheck(req)) {</strong>
<strong class="screentext">            return resp.sendStatus(401</strong><strong class="screentext">)</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        next();</strong>
<strong class="screentext">    };</strong>
    const cat_router = Router();
    createAdminCatalogRoutes(cat_router);
  <strong class="screentext">  app.use("/api/products", apiAuth, cat_router);</strong>
    const order_router = Router();
    createAdminOrderRoutes(order_router);
    <strong class="screentext">app.use</strong><strong class="screentext">("/api/orders", apiAuth, order_router);</strong>
    c<strong class="screentext">onst userAuth = (req: Request, resp: Response, next: NextFunction) =&gt; {</strong>
<strong class="screentext">        if (!authCheck(req)) {</strong>
<strong class="screentext">            return resp.redirect("/admin/signin");</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        next</strong><strong class="screentext">();</strong>
<strong class="screentext">    };</strong>
<strong class="screentext">    app.get("/admin", userAuth, (req, resp) =&gt;</strong>
        resp.redirect("/admin/products"));
    <strong class="screentext">app.get("/admin/products", userAuth, (req, resp) =&gt;</strong><strong class="screentext"> {</strong>
        resp.locals.content = "/api/products/table";
        resp.render("admin/admin_layout");
    })
   <strong class="screentext"> app.get("/admin/products/edit/:id", userAuth, (req, resp) =&gt; {</strong>
        resp.locals.content = `/api/products/edit/${req.params.id}`;
        resp.render("admin/admin_layout");
    })
   <strong class="screentext"> app.get("/admin/orders", userAuth, (req, resp) =&gt; {</strong>
        resp.locals.content = "/api/orders/table";
        resp.render("admin/admin_layout");
    })
}
</code></pre>
<p class="normal">The new routes are used to prompt<a id="_idIndexMarker1140" class="calibre3"/> the user to sign in, allow users to sign out again, and handle the Google OAuth redirections. The middleware components check that the signed-in user is one of the approved users from the configuration file, with redirection responses for the direct navigation routes and <code class="inlinecode">401</code> responses for the web service routes.</p>
<p class="normal">To define the template that will be rendered when the user needs to sign in, add a file named <code class="inlinecode">signin.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder with the content shown in <em class="italic">Listing 20.48</em>.</p>
<p class="packt_figref">Listing 20.48: The contents of the signin.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
        &lt;link href="/font/bootstrap-icons.min.css" rel="stylesheet"&gt;
        {{#if (isDevelopment) }}
            &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        {{/if }}
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container-fluid"&gt;
            &lt;div class="row bg-info text-white py-2 px-1"&gt;
                &lt;div class="col align-baseline pt-1"&gt;SPORTS STORE ADMIN&lt;/div&gt;
                &lt;div class="col-auto text-end"&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row p-2"&gt;
                &lt;div class="col"&gt;&lt;/div&gt;
                &lt;div class="col-auto"&gt;
                    &lt;a class="btn btn-primary" href="/admin/google"&gt;
                        &lt;i class="bi bi-google"&gt;&lt;/i&gt;
                        Sign in with Google Account
                    &lt;/a&gt;                 
                &lt;/div&gt; 
                &lt;div class="col"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The final step is to show the signed-in user’s name and provide a <strong class="screentext">Sign out</strong> button, as shown in <em class="italic">Listing 20.49</em>.</p>
<p class="packt_figref">Listing 20.49: Adding user details to the admin_layout.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
        &lt;link href="/font/bootstrap-icons.min.css" rel="stylesheet"&gt;
        {{#if (isDevelopment) }}
            &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        {{/if }}
        &lt;script src="img/htmx.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container-fluid"&gt;
            &lt;div class="row bg-info text-white py-2 px-1"&gt;
                &lt;div class="col align-baseline pt-1"&gt;SPORTS STORE ADMIN&lt;/div&gt;
                &lt;div class="col-auto text-end"&gt;
                    <strong class="screentext">{{#if user }}</strong>
<strong class="screentext">                        ({{user.name}})</strong>
<strong class="screentext">                        &lt;button class</strong><strong class="screentext">="btn btn-secondary"</strong>
<strong class="screentext">                                hx-post="/admin/signout" hx-target="body"</strong>
<strong class="screentext">                                hx-push-url="/admin/signin"&gt;</strong>
<strong class="screentext">                            &lt;i class</strong><strong class="screentext">="bi bi-box-arrow-right"&gt;&lt;/i&gt;                               </strong>
<strong class="screentext">                        &lt;/button&gt;</strong>
<strong class="screentext">                    {{/if}}</strong>
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row p-2"&gt;
                &lt;div class="col-2" id="area_buttons"&gt;&lt;/div&gt;
                &lt;div class="col" id="content" hx-get="{{content}}"
                    hx-trigger="load"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Navigate to <code class="inlinecode">http://localhost:5000/admin</code>, and you will be prompted<a id="_idIndexMarker1141" class="calibre3"/> to <strong class="screentext">Sign in with a Google account</strong>, as shown in <em class="italic">Figure 20.12</em>. If the account matches the approved list, then you will be redirected to the administration features once the authentication process is complete. Clicking on the button at the top of the window will sign the user out of the application.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_20_12.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 20.12: Signing in to the administration features</p>
<h1 class="heading" id="_idParaDest-358">Summary</h1>
<p class="normal1">In this chapter, I created administration tools to manage the catalog and set the order shipping status:</p>
<ul class="calibre4">
<li class="bulletlist">The administration features use a RESTful web service that returns fragments of HTML, which are displayed using the <code class="inlinecode">HTMX</code> package.</li>
<li class="bulletlist1">The state is managed by the server, which renders templates to produce the HTML fragments that are returned by the web service.</li>
<li class="bulletlist1">URLs are added to the browser’s history so that the reload and back buttons work as expected.</li>
<li class="bulletlist1">Access to the administration feature is restricted to authorized users who authenticate with their Google account.</li>
</ul>
<p class="normal">In the next chapter, I will prepare the <em class="italic">SportsStore</em> application for deployment.</p>
</div>
</body></html>