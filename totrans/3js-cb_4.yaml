- en: Chapter 4. Materials and Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 材料和纹理
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Adding depth to a mesh with a bump map
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凹凸贴图给网格添加深度
- en: Adding depth to a mesh with a normal map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用法线贴图给网格添加深度
- en: Using HTML canvas as a texture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML 画布作为纹理
- en: Using HTML video as a texture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML 视频作为纹理
- en: Creating a mesh with multiple materials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有多个材料的网格
- en: Using separate materials for faces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单独的材料为面着色
- en: Setting up repeating textures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置重复纹理
- en: Making part of an object transparent
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使物体的一部分透明
- en: Using a cubemap to create reflective materials
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用立方体贴图创建反射材料
- en: Using a dynamic cubemap to create reflective materials
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态立方体贴图创建反射材料
- en: Using Blender to create custom UV mapping
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Blender 创建自定义 UV 映射
- en: Configuring blend modes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置混合模式
- en: Using a shadow map for fixed shadows
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影贴图创建固定阴影
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Three.js offers a large number of different materials and supports many different
    types of textures. These textures provide a great way to create interesting effects
    and graphics. In this chapter, we'll show you recipes that allow you to get the
    most out of these components provided by Three.js.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了大量的不同材料，并支持许多不同类型的纹理。这些纹理提供了一种创建有趣效果和图形的绝佳方式。在本章中，我们将向您展示一些食谱，让您充分利用
    Three.js 提供的这些组件。
- en: Adding depth to a mesh with a bump map
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用凹凸贴图给网格添加深度
- en: For detailed models, you require geometries with a large number of vertices
    and faces. If a geometry contains a very large number of vertices, loading the
    geometry and rendering it will take more time than it would take for a simple
    model. If you've got a scene with a large number of models, it is a good idea
    to try and minimize the number of vertices for better performance. There are a
    number of different techniques that you can use for this. In this recipe, we'll
    show you how you can use a bump map texture to add the illusion of depth to your
    model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详细模型，你需要具有大量顶点和面的几何体。如果一个几何体包含非常多的顶点，加载几何体和渲染它所需的时间将比简单模型所需的时间更长。如果你有一个包含大量模型的场景，尝试尽量减少顶点的数量以获得更好的性能是个好主意。你可以使用多种不同的技术来实现这一点。在本食谱中，我们将向您展示如何使用凹凸贴图纹理为您的模型添加深度感。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get ready for this recipe, we need to get the textures that we want to use
    on our geometries. For this recipe, we require two textures: a color map, which
    is a standard texture, and a bump map, which describes the depth associated with
    the standard texture. The following screenshot shows you the color map that we
    will use (you can find these textures in the `assets/textures` folder in the sources
    provided with this book):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个食谱，我们需要获取我们想要在几何体上使用的纹理。对于这个食谱，我们需要两个纹理：一个颜色图，这是一个标准纹理，以及一个凹凸贴图，它描述了与标准纹理相关的深度。以下截图显示了我们将使用的颜色图（你可以在本书提供的源代码中的`assets/textures`文件夹中找到这些纹理）：
- en: '![Getting ready](img/1182OS_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_01.jpg)'
- en: 'As you can see, this is a simple color map of a stone wall. Besides this texture,
    we also require the bump map. A bump map is a grayscale image, where the intensity
    of each pixel determines the height:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的石头墙颜色图。除了这个纹理，我们还需要凹凸贴图。凹凸贴图是一种灰度图像，其中每个像素的强度决定了高度：
- en: '![Getting ready](img/1182OS_04_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_02.jpg)'
- en: From the preceding screenshot, you can see that the parts between the stones
    and the mortar has less height, as it is a dark color, as compared to the stones
    themselves, which have a lighter color. You can see the result you end up with
    at the end of this recipe by opening up the `04.01-add-depth-to-mesh-with-bump-map.html`
    example in your browser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，你可以看到石头和灰浆之间的部分高度较低，因为它是深色，与颜色较浅的石头本身相比。你可以在浏览器中打开`04.01-add-depth-to-mesh-with-bump-map.html`示例，查看这个食谱结束时的结果。
- en: '![Getting ready](img/1182OS_04_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_03.jpg)'
- en: From the preceding screenshot, you can see two cubes. The cube on the left-hand
    side is rendered without a bump map, and the cube on the right-hand side is rendered
    with a bump map. As you can see, the right-hand side cube shows much more depth
    and detail than the cube on the left-hand side.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，你可以看到两个立方体。左侧的立方体没有使用凹凸贴图进行渲染，而右侧的立方体使用了凹凸贴图。正如你所见，右侧的立方体比左侧的立方体显示出更多的深度和细节。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When you''ve got textures, using them to add depth to a model is very straightforward:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有纹理时，使用它们给模型添加深度是非常直接的：
- en: 'First, create the geometry you want to use together with the bump map:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建您想要与振荡贴图一起使用的几何体：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this recipe, we create `THREE.BoxGeometry`, but you can use a bump map with
    any kind of geometry.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建 `THREE.BoxGeometry`，但您可以使用振荡贴图与任何类型的几何体一起使用。
- en: 'The next step is to create the material on which we define the bump map:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建我们定义振荡贴图的材质：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we create `THREE.MeshPhongMaterial` and set its `map` and `bumpMap` properties.
    The `map` property points to the color map texture, and the `bumpMap` property
    point to the grayscale bump map texture.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建 `THREE.MeshPhongMaterial` 并设置其 `map` 和 `bumpMap` 属性。`map` 属性指向颜色贴图纹理，而
    `bumpMap` 属性指向灰度振荡贴图纹理。
- en: 'Now you can just create `THREE.Mesh` and add it to scene:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您只需创建 `THREE.Mesh` 并将其添加到场景中：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With these three simple steps, you've created a cube that uses a bump map for
    added depth.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个简单的步骤，您已经创建了一个使用振荡贴图来增加深度的立方体。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The values of each pixel in the bump map determine the height associated with
    that part of the texture. When rendering the scene, Three.js uses this information
    to determine how light affects the final color of the pixel it is rendering. The
    result is that without defining a very detailed model, we can add the illusion
    of extra depth. If you want to know more details about how bump mapping works,
    look at this site for a very detailed explanation: [http://www.tweak3d.net/articles/bumpmapping/](http://www.tweak3d.net/articles/bumpmapping/).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 振荡贴图中每个像素的值决定了与该纹理部分相关联的高度。在渲染场景时，Three.js 使用这些信息来确定光线如何影响它正在渲染的像素的最终颜色。结果是，即使没有定义一个非常详细的模型，我们也可以添加额外的深度错觉。如果您想了解更多关于振荡贴图如何工作的详细信息，请查看这个网站以获取非常详细的解释：[http://www.tweak3d.net/articles/bumpmapping/](http://www.tweak3d.net/articles/bumpmapping/).
- en: There's more…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: In this recipe, we showed you the default way to define a bump map. There is,
    however, one additional property that you can use to tune bump mapping. The material
    we used in this recipe, `cubeBumpMaterial`, also has a `bumpScale` property. With
    this property, you can set the amount by which the bump map affects the depth.
    If this value is very small, you'll see some added depth, and if this value is
    higher, you'll see a more pronounced depth effect. You can set this property in
    the example for this cookbook (`04.01-add-depth-to-mesh-with-bump-map.html`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们向您展示了定义振荡贴图的默认方法。然而，您可以使用一个额外的属性来调整振荡贴图。我们在这个配方中使用的材质 `cubeBumpMaterial`
    也有一个 `bumpScale` 属性。使用这个属性，您可以设置振荡贴图影响深度的程度。如果这个值非常小，您会看到一些增加的深度，如果这个值更高，您会看到更明显的深度效果。您可以在本食谱的示例中设置此属性（`04.01-add-depth-to-mesh-with-bump-map.html`）。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: There is an additional way to add detail and depth to your meshes. In the *Add
    depth to a mesh with a normal map* recipe, we show how to add depth and detail
    with a normal map instead of a bump map. In the *Creating geometries from height
    maps* recipe, of [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*, we showed you a different way to use bump maps by creating `THREE.Geometry`
    from it.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种额外的方法可以为您的网格添加细节和深度。在 *使用正常贴图为网格添加深度* 配方中，我们展示了如何使用正常贴图而不是振荡贴图来添加深度和细节。在
    *从高度图创建几何体* 配方中，[第2章](ch02.html "第2章。几何体和网格")，*几何体和网格*，我们向您展示了创建 `THREE.Geometry`
    来使用振荡贴图的不同方法。
- en: Adding depth to a mesh with a normal map
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正常贴图为网格添加深度
- en: With a bump map, we showed in the *Add depth to a mesh with a bump map* recipe,
    how to add depth and detail to a mesh using a specific texture. In this recipe,
    we provide another way to add even more depth and details without increasing the
    vertex count of the geometry. To do this, we will use a normal map. A normal map
    describes the normal vector for each pixel, which should be used to calculate
    how light affects the material used in the geometry.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用振荡贴图为网格添加深度* 配方中，我们展示了如何使用特定的纹理为网格添加深度和细节。在这个配方中，我们提供了一种在不增加几何体顶点数的情况下添加更多深度和细节的方法。为此，我们将使用正常贴图。正常贴图描述了每个像素的法向量，该向量应用于计算光线如何影响几何体中使用的材质。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use normal maps, we first need to get a color map and a normal map. For
    this recipe, we''ve used two screenshots. The first is the color map:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正常贴图，我们首先需要一个颜色贴图和一个正常贴图。对于这个配方，我们使用了两个截图。第一个是颜色贴图：
- en: '![Getting ready](img/1182OS_04_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_05.jpg)'
- en: 'The next screenshot is the normal map:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图是正常贴图：
- en: '![Getting ready](img/1182OS_04_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_06.jpg)'
- en: 'Now that we''ve got the two images, let''s first look at how this would look
    in practice. To see a normal map in action, open the `04.02-add-depth-to-mesh-with-normal-map.html`
    example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了这两张图片，让我们首先看看这在实践中会是什么样子。要看到正常贴图的实际应用，请打开`04.02-add-depth-to-mesh-with-normal-map.html`示例：
- en: '![Getting ready](img/1182OS_04_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_04_07.jpg)'
- en: In this example, you can see a standard rendered cube on the left-hand side
    and one where a normal map is added to on the right-hand side. You can directly
    see that the face of the right-hand side cube looks much more detailed than the
    face of the left-hand side cube.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以在左侧看到一个标准渲染的立方体，在右侧可以看到添加了正常贴图的立方体。您可以直接看到右侧立方体的面看起来比左侧立方体的面更详细。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Adding a normal map is actually very easy:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 添加正常贴图实际上非常简单：
- en: 'First, create the geometry that we want to render:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建我们想要渲染的几何形状：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For this recipe, we use a simple `THREE.BoxGeometry` object, but you can use
    whichever geometry you want.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用一个简单的`THREE.BoxGeometry`对象，但你也可以使用你想要的任何几何形状。
- en: 'Now that we''ve got a geometry, we create the material and configure the properties:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个几何形状，我们创建材质并配置属性：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `map` properties contain the standard texture, and the `normalMap` properties
    contain the normal texture, which we showed you in the *Getting ready* section
    of this recipe.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`map`属性包含标准纹理，而`normalMap`属性包含正常纹理，这是我们在这份配方*准备就绪*部分向您展示的。'
- en: 'All that is left to do now is to create a `THREE.Mesh` object and add it to
    the scene like this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的只是创建一个`THREE.Mesh`对象并将其添加到场景中，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from these steps, using a normal map is very simple.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些步骤中看到的，使用正常贴图非常简单。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In 3D modeling, a couple of mathematical concepts are important to understand.
    One of these concepts is a **normal** vector. A normal is the vector that stands
    perpendicular to the surface of the face of a geometry. This is shown in the following
    screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D建模中，有几个数学概念是重要的，需要理解。其中之一是一个**法向量**的概念。法向量是垂直于几何形状面面的向量。这在上面的屏幕截图中显示：
- en: '![How it works...](img/1182OS_04_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1182OS_04_08.jpg)'
- en: Each blue line represents the normal vector, which is the vector that is perpendicular
    to the surface of that face. In a normal map, the direction of these vectors are
    shown as RGB values. When you apply a normal map to a specific face, Three.js
    uses the information from this normal map and the normal of the face to add depth
    to that face without adding additional vertices. For more information on how normal
    maps are used, refer to the site at [http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/](http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每条蓝色线条代表法向量，这是垂直于该表面面的向量。在正常贴图中，这些向量的方向以RGB值的形式显示。当你将正常贴图应用于特定的面时，Three.js会使用这个正常贴图和面的法线信息来为该面添加深度，而不添加额外的顶点。有关正常贴图如何使用的更多信息，请参考[http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/](http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/)网站。
- en: There's more…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'You can fine-tune the height and direction in which the information from the
    normal map is applied to the face of geometry. For this, you can use the `normalScale`
    property like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以微调从正常贴图中应用到几何形状面的高度和方向。为此，你可以使用`normalScale`属性，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To see this effect in action, look at the example for this recipe, `04.02-add-depth-to-mesh-with-normal-map.html`,
    where you can use the menu in the top-right section to change this value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果的实际应用，请查看这个配方的示例`04.02-add-depth-to-mesh-with-normal-map.html`，在那里你可以使用右上角的菜单来改变这个值。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: An alternative for normal maps is bump maps. In the *Add depth to a mesh with
    a bump map* recipe, we show you how to use such a map instead of a normal map
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常贴图的替代方案是凹凸贴图。在*使用凹凸贴图给网格添加深度*的配方中，我们向您展示了如何使用这种贴图而不是正常贴图。
- en: Using HTML canvas as a texture
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML画布作为纹理
- en: Most often when you use textures, you use static images. With Three.js, however,
    it is also possible to create interactive textures. In this recipe, we will show
    you how you can use an HTML5 canvas element as an input for your texture. Any
    change to this canvas is automatically reflected after you inform Three.js about
    this change in the texture used on the geometry.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你使用纹理时，你会使用静态图像。然而，在Three.js中，也可以创建交互式纹理。在这个食谱中，我们将向您展示如何使用HTML5画布元素作为纹理的输入。一旦您通知Three.js关于纹理使用的这个变化，任何对这个画布的更改都会自动反映出来。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need an HTML5 canvas element that can be displayed as a
    texture. We can create one ourselves and add some output, but for this recipe,
    we''ve chosen something else. We will use a simple JavaScript library, which outputs
    a clock to a canvas element. The resulting mesh will look like this (see the `04.03-use-html-canvas-as-texture.html`
    example):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要一个可以显示为纹理的HTML5画布元素。我们可以自己创建一个并添加一些输出，但在这个食谱中，我们选择了其他东西。我们将使用一个简单的JavaScript库，它将时钟输出到一个画布元素。生成的网格将看起来像这样（参见`04.03-use-html-canvas-as-texture.html`示例）：
- en: '![Getting ready](img/1182OS_04_09.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_04_09.jpg)'
- en: 'The JavaScript used to render the clock was based on the code from this site:
    [http://saturnboy.com/2013/10/html5-canvas-clock/](http://saturnboy.com/2013/10/html5-canvas-clock/).
    To include the code that renders the clock in our page, we need to add the following
    to the `head` element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染时钟所使用的JavaScript代码基于这个网站的代码：[http://saturnboy.com/2013/10/html5-canvas-clock/](http://saturnboy.com/2013/10/html5-canvas-clock/)。为了在我们的页面中包含渲染时钟的代码，我们需要在`head`元素中添加以下内容：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To use a canvas as a texture, we need to perform a couple of steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将画布用作纹理，我们需要执行几个步骤：
- en: 'The first thing we need to do is create the canvas element:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建画布元素：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we create an HTML canvas element programmatically and define a fixed width.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过编程创建一个HTML画布元素，并定义一个固定的宽度。
- en: 'Now that we''ve got a canvas, we need to render the clock that we use as the
    input for this recipe on it. The library is very easy to use; all you have to
    do is pass in the canvas element we just created:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个画布，我们需要在它上面渲染我们用作这个食谱输入的时钟。这个库非常容易使用；您只需传入我们刚刚创建的画布元素：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, we''ve got a canvas that renders and updates an image of a clock.
    What we need to do now is create a geometry and a material and use this canvas
    element as a texture for this material:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经得到了一个渲染并更新时钟图像的画布。我们现在需要做的是创建一个几何体和一个材质，并使用这个画布元素作为这个材质的纹理：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To create a texture from a canvas element, all we need to do is create a new
    instance of `THREE.Texture` and pass in the `canvas` element we created in step
    1\. We assign this texture to the `cubeMaterial.map` property, and that's it.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从画布元素创建纹理，我们只需创建一个新的`THREE.Texture`实例，并传入我们在步骤1中创建的`canvas`元素。我们将这个纹理分配给`cubeMaterial.map`属性，这样就完成了。
- en: 'If you run the recipe at this step, you might see the clock rendered on the
    sides of the cubes. However, the clock won''t update itself. We need to tell Three.js
    that the canvas element has been changed. We do this by adding the following to
    the rendering loop:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在这个步骤运行食谱，您可能会看到时钟渲染在立方体的侧面。然而，时钟不会自动更新。我们需要告诉Three.js画布元素已经更改。我们通过在渲染循环中添加以下内容来完成此操作：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This informs Three.js that our canvas texture has changed and needs to be updated
    the next time the scene is rendered.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通知Three.js我们的画布纹理已更改，需要在下次渲染场景时更新。
- en: With these four simple steps, you can easily create interactive textures and
    use everything you can create on a canvas element as a texture in Three.js.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这四个简单的步骤，您可以轻松创建交互式纹理，并将您在画布元素上创建的所有内容用作Three.js中的纹理。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: How this works is actually pretty simple. Three.js uses WebGL to render scenes
    and apply textures. WebGL has native support for using HTML canvas element as
    textures, so Three.js just passes on the provided canvas element to WebGL and
    it is processed as any other texture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是如何工作的非常简单。Three.js使用WebGL来渲染场景并应用纹理。WebGL原生支持使用HTML画布元素作为纹理，因此Three.js只需将提供的画布元素传递给WebGL，它就会被处理成任何其他纹理。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Besides using images and canvas elements as textures, we can also use a video
    element as a texture. In the *Using HTML video as a texture* recipe, we show you
    how to use a HTML video element as the input for a texture.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了使用图像和画布元素作为纹理外，我们还可以使用视频元素作为纹理。在*使用HTML视频作为纹理*食谱中，我们向您展示如何使用HTML视频元素作为纹理的输入。
- en: Using HTML video as a texture
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML视频作为纹理
- en: Modern browsers have great support for playing video without requiring any plugins.
    With Three.js, we can even use this video as the input for our textures. In this
    recipe, we'll show you the steps you need to take to output a video on a side
    of a cube.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器在无需任何插件的情况下播放视频方面提供了很好的支持。使用Three.js，我们甚至可以使用这个视频作为纹理的输入。在这个配方中，我们将向您展示输出视频在立方体侧面所需的步骤。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need a video to play, of course. We used the trailer for
    the Blender-made movie *Sintel* ([http://www.sintel.org/](http://www.sintel.org/)),
    which is freely available. To view the result of this recipe, open `04.04-use-html-video-as-texture.html`
    in your browser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这个配方，我们需要一个要播放的视频。我们使用了Blender制作的影片《Sintel》的预告片([http://www.sintel.org/](http://www.sintel.org/))，它是免费提供的。要查看此配方的结果，请在您的浏览器中打开`04.04-use-html-video-as-texture.html`。
- en: '![Getting ready](img/1182OS_04_10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_04_10.jpg)'
- en: When you run this example, you can see that the video is being played at the
    side of a cube and keeps updating even when the cube is rotating.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此示例时，您可以看到视频正在一个立方体的侧面播放，并且即使在立方体旋转时也会持续更新。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To accomplish this effect, we need to define an HTML video element as the source
    for a texture. To do this, perform the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种效果，我们需要将HTML视频元素定义为纹理的源。为此，执行以下步骤：
- en: 'The first thing we need is a way to play the video. For this, we add the following
    HTML element to the `body` element of the page:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要一种播放视频的方法。为此，我们在页面的`body`元素中添加以下HTML元素：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this piece of HTML, we'll load the video and play it looped once it is
    loaded using the `autoplay` and `loop` properties. As we've set `display:none`,
    this `video` element won't show up on the page.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这段HTML，我们将加载视频，并在加载后使用`autoplay`和`loop`属性循环播放。由于我们设置了`display:none`，这个`video`元素不会显示在页面上。
- en: 'Now that we''ve got a video playing, we can get a reference to this element
    and use it to create a texture:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经播放了视频，我们可以获取这个元素的引用，并使用它来创建一个纹理：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `minFilter`, `magFilter`, `format`, and `generateMipmaps` properties used
    here provide the best result and performance when using a video as a texture.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里使用的`minFilter`、`magFilter`、`format`和`generateMipmaps`属性在将视频用作纹理时提供最佳结果和性能。
- en: 'At this point, we''ve got a texture that we can use like any other texture:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们得到了一个可以像其他纹理一样使用的纹理：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we set the `map` property of the material to the video texture. So, any
    `THREE.Mesh` object we create that uses this material will show the video.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将材质的`map`属性设置为视频纹理。因此，我们创建的任何使用此材质的`THREE.Mesh`对象都会显示视频。
- en: 'To finish the recipe, create `THREE.Mesh` object and add it to the scene:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成这个配方，创建`THREE.Mesh`对象并将其添加到场景中：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Three.js normally caches textures as they usually don''t change that often.
    In this recipe, though, the texture changes continuously. To inform Three.js that
    the texture has changed, we need to add the following to the render loop:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Three.js通常缓存纹理，因为它们通常不会经常改变。然而，在这个配方中，纹理是持续变化的。为了通知Three.js纹理已更改，我们需要在渲染循环中添加以下内容：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use this approach with any video that can be played in the browser.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方法处理任何在浏览器中可以播放的视频。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WebGL, which is used by Three.js to render the scenes, has native support to
    use video elements as input for the textures. Three.js just passes the video element
    to WebGL and doesn't need to do any preprocessing. In the WebGL code, the current
    image shown by the video is converted to a texture. Whenever we set `videoTexture.needsUpdate`
    to `true`, the texture is updated in WebGL.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL，Three.js用来渲染场景的工具，原生支持使用视频元素作为纹理的输入。Three.js只需将视频元素传递给WebGL，无需进行任何预处理。在WebGL代码中，视频显示的当前图像被转换为纹理。每次我们设置`videoTexture.needsUpdate`为`true`时，纹理就会在WebGL中更新。
- en: There's more…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One thing to remember when working with the video element is that the different
    browsers have varying support for video formats. A good up-to-date overview of
    what format is supported by which browser can be found on Wikipedia at [http://en.wikipedia.org/wiki/HTML5_video#Browser_support](http://en.wikipedia.org/wiki/HTML5_video#Browser_support).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理视频元素时，需要记住的一件事是，不同的浏览器对视频格式的支持各不相同。有关哪些浏览器支持哪些格式的最新概述，可以在维基百科上找到[http://en.wikipedia.org/wiki/HTML5_video#Browser_support](http://en.wikipedia.org/wiki/HTML5_video#Browser_support)。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: An alternative way to easily create changing textures is explained in the *Using
    HTML canvas as a texture* recipe. In this recipe, we explain how you can use the
    HTML `canvas` element as the input for a texture.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种轻松创建可变纹理的方法在*使用HTML canvas作为纹理*配方中解释。在这个配方中，我们解释了如何使用HTML `canvas`元素作为纹理的输入。
- en: Creating a mesh with multiple materials
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有多种材料的网格
- en: When you create `THREE.Mesh`, you can only specify a single material that can
    be used for that mesh. In most scenarios, this will be sufficient. However, there
    are also cases where you want to combine multiple materials. For instance, you
    might want to combine `THREE.MeshLambertMaterial` with a material that shows you
    the wireframe of the geometry. In this recipe, we'll show you the required steps
    to create a mesh that uses multiple materials.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建`THREE.Mesh`时，你可以指定一个用于该网格的单个材料。在大多数情况下，这将是足够的。然而，也有一些情况下，你想结合多种材料。例如，你可能想将`THREE.MeshLambertMaterial`与显示几何体线框的材料结合。在这个配方中，我们将向你展示创建使用多种材料的网格所需的步骤。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we don't require additional resources or libraries. If you
    want to look at the result of this recipe, open up the `04.05-create-a-mesh-with-multiple-materials.html`
    example in your browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们不需要额外的资源或库。如果你想查看这个配方的结果，请在浏览器中打开`04.05-create-a-mesh-with-multiple-materials.html`示例。
- en: '![Getting ready](img/1182OS_04_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_11.jpg)'
- en: In the preceding screenshot, you can see a cylinder. This cylinder is rendered
    with two materials. In the next section, we'll show you the steps you need to
    take to create this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到一个圆柱体。这个圆柱体是用两种材料渲染的。在下一节中，我们将向你展示创建这个圆柱体所需的步骤。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a multimaterial mesh, Three.js provides a helper function. You can
    use `THREE.SceneUtils` for this, as is shown in the next couple of steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个多材料网格，Three.js提供了一个辅助函数。你可以使用`THREE.SceneUtils`来做这件事，就像在接下来的几个步骤中展示的那样：
- en: 'The first thing you need to do is create the geometry you want to use. For
    this recipe, we use a simple `THREE.CylinderGeometry` object:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先你需要做的是创建你想要使用的几何体。对于这个配方，我们使用了一个简单的`THREE.CylinderGeometry`对象：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the geometry, we can create the materials. You can use as many as you
    want, but in this recipe, we''ll just use two:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几何体之后，我们可以创建材料。你可以使用你想要的任何数量，但在这个配方中，我们只使用两个：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we create a transparent `THREE.MeshLambertMaterial` object and
    `THREE.MeshBasicMaterial` object, which only renders a wireframe.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个透明的`THREE.MeshLambertMaterial`对象和一个`THREE.MeshBasicMaterial`对象，它们只渲染线框。
- en: 'Now, we can create the object that can be added to the scene. Instead of instantiating
    `THREE.Mesh`, we use the `createMultiMaterialObject` function provided by the
    `THREE.SceneUtils` object:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建可以添加到场景中的对象。我们不是实例化`THREE.Mesh`，而是使用`THREE.SceneUtils`对象提供的`createMultiMaterialObject`函数：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can add the result from this function to the scene:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将这个函数的结果添加到场景中：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One thing to take into account is that the object we create here isn't `THREE.Mesh`
    but `THREE.Object3D`. Why a different object is created is explained in the next
    section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，我们在这里创建的对象不是`THREE.Mesh`，而是`THREE.Object3D`。为什么创建了一个不同的对象将在下一节中解释。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'What happens when you call the `createMultiMaterialObject` function is that
    Three.js simply creates multiple meshes and groups them together. If you open
    the Three.js file and look up this function, you''ll see the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`createMultiMaterialObject`函数时，Three.js只是简单地创建多个网格并将它们组合在一起。如果你打开Three.js文件并查找这个函数，你会看到以下代码：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this function, Three.js iterates over the materials that are provided, and
    for each material, a new `THREE.Mesh` object is created. Because all the created
    meshes are added to group, the result looks like a single mesh that's created
    with multiple materials.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，Three.js遍历提供的材料，并为每个材料创建一个新的`THREE.Mesh`对象。因为所有创建的网格都被添加到组中，所以结果看起来像是一个使用多种材料创建的单个网格。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: When you use the approach from this recipe to create a material that uses multiple
    materials, the materials are applied to the complete geometry. In the *Using separate
    materials for faces* recipe, we show you how to use a different material for each
    specific face of a geometry.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用这个配方中的方法创建使用多种材料的材料时，这些材料被应用到完整的几何体上。在*为面的每个特定面使用不同的材料*配方中，我们展示了如何为几何体的每个特定面使用不同的材料。
- en: Using separate materials for faces
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为面使用不同的材料
- en: Each geometry in Three.js consists of a number of vertices and faces. In most
    cases, when you define a material that can be used together with a geometry, you
    use a single material. With Three.js, however, it is also possible to define a
    unique material for each of the faces of your geometry. You could, for instance,
    use this to apply different textures to each side of a model of a house. In this
    recipe, we will explain how to set up the materials so that you can use different
    textures for individual faces.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，每个几何体都由多个顶点和面组成。在大多数情况下，当你定义一个可以与几何体一起使用的材料时，你使用一个单一的材料。然而，使用Three.js，你也可以为你的几何体的每个面定义一个独特的材料。例如，你可以使用这种方法为房屋模型的每一面应用不同的纹理。在这个菜谱中，我们将解释如何设置材料，以便你可以为单个面使用不同的纹理。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, we won't use any external textures or libraries. It is good,
    however, to look at the final result that we'll be creating in this recipe. For
    this, open the `04.06-use-separate-materials-for-faces.html` example in your browser.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们不会使用任何外部纹理或库。然而，查看我们将在这个菜谱中创建的最终结果是有益的。为此，请在您的浏览器中打开`04.06-use-separate-materials-for-faces.html`示例。
- en: '![Getting ready](img/1182OS_04_12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_12.jpg)'
- en: In the preceeding screenshot, you can see a rotating sphere, where each face
    is rendered with a different color and half of the faces have been made transparent.
    In the following section, we'll show you the steps you need to take to recreate
    this.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到一个旋转的球体，其中每个面都渲染了不同的颜色，并且一半的面被设置为透明。在下一节中，我们将向您展示重现这一效果所需的步骤。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To define specific materials for each face, we need to perform the following
    steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个面定义特定的材料，我们需要执行以下步骤：
- en: 'The first thing we need to do is create the geometry. For this recipe, we use
    `THREE.SphereGeometry`, but these steps can also be applied to other geometries:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是创建几何体。对于这个菜谱，我们使用`THREE.SphereGeometry`，但这些步骤也可以应用于其他几何体：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we create the material in step 3, we provide an array of materials that
    we want to use. Additionally, we need to specify on each face the material from
    the array we''ll use. You can do this with the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在步骤3中创建材料时，我们提供了一个我们想要使用的材料数组。此外，我们还需要在每个面上指定我们将使用的数组中的材料。你可以用以下代码来完成这个操作：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code snippet, we traverse all the faces of the geometry we created.
    For each face, we set the `materialIndex` property to the index of the material
    we want to use. We also create a unique `material` object for each face in this
    code snippet, make half of them transparent, and finally, push the materials we
    create into the materials array.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们遍历了我们创建的几何体的所有面。对于每个面，我们将`materialIndex`属性设置为我们要使用的材料的索引。我们还在这个代码片段中为每个面创建一个独特的`material`对象，使其中一半透明，最后，将我们创建的材料推入材料数组。
- en: 'At this point, the materials array contains a unique material for each face
    of the geometry, and for all the faces, the `materialIndex` property points to
    one of the materials in that array. Now, we can create `THREE.MeshFaceMaterial`
    object and together with the geometry, we can create `THREE.Mesh`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，材料数组包含几何体每个面的独特材料，并且对于所有面，`materialIndex`属性都指向该数组中的一个材料。现在，我们可以创建`THREE.MeshFaceMaterial`对象，并与几何体一起创建`THREE.Mesh`：
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's it. Each face of the geometry will use the material it points to.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。几何体的每个面都将使用它指向的材料。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we specify `materialIndex` on each `THREE.Face` object, Three.js knows
    which material from the provided array it should use when it wants to render a
    specific face. One thing you need to take into account is that this can affect
    the performance of your scene, as each of the materials needs to be managed by
    Three.js; however, the performance is better than using separate meshes but worse
    than combining the textures into one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在每个`THREE.Face`对象上指定了`materialIndex`，Three.js知道当它想要渲染特定的面时应该使用提供的数组中的哪个材料。你需要考虑的一件事是，这可能会影响你场景的性能，因为Three.js需要管理每个材料；然而，性能比使用单独的网格要好，但比将纹理组合在一起要差。
- en: There's more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some of the geometries Three.js provides already set a `materialIndex` property
    when you instantiate them. For instance, when you create `THREE.BoxGeometry`,
    the first two faces are mapped to `materialIndex 1`, the next two are mapped to
    `materialIndex 2`, and so on. So, if you want to style the sides of a box, you
    just have to provide an array with six materials.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Three.js 提供的几何体在实例化时已经设置了 `materialIndex` 属性。例如，当你创建 `THREE.BoxGeometry`
    时，前两个面映射到 `materialIndex 1`，接下来的两个映射到 `materialIndex 2`，依此类推。所以，如果你想给盒子的侧面添加样式，你只需要提供一个包含六个材质的数组。
- en: 'Another interesting use of using materials for specific faces is that you can
    easily create interesting patterns, for instance, when you can very easily create
    a checked layout like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定面的材质的另一个有趣用途是，你可以轻松地创建有趣的图案，例如，当你可以非常容易地创建一个类似这样的棋盘布局：
- en: '![There''s more…](img/1182OS_04_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_04_13.jpg)'
- en: 'All you need is some small change to how you assign the `materialIndex` properties
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要对如何分配 `materialIndex` 属性做一些小的改变，如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you don't want to style specific faces but apply multiple materials to a
    complete geometry, you can look at the *Creating a mesh with multiple materials*
    recipe, where we explain how to do just that
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想对特定面进行样式化，但想对一个完整的几何体应用多个材质，你可以查看 *创建具有多个材质的网格* 菜谱，其中我们解释了如何做到这一点。
- en: Setting up repeating textures
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置重复纹理
- en: Sometimes, when you've found a texture you want to apply, you might want to
    repeat it. For instance, if you've got a large ground plane on which you want
    to apply a seamless wood texture, you don't want the texture to be applied as
    a single image for the whole plane. Three.js allows you to define the manner in
    which a texture is repeated when it is used on a geometry. In this recipe, we'll
    explain the steps you need to take to accomplish this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你找到一个想要应用的纹理时，你可能希望重复它。例如，如果你有一个大地面，你想要在上面应用无缝木纹纹理，你不想整个平面都应用一个单独的图像。Three.js
    允许你定义纹理在几何体上使用时的重复方式。在这个菜谱中，我们将解释你需要采取的步骤来完成这个任务。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The first thing we need is the image that we'll use for a texture. For the best
    effect, you should use seamless textures. A seamless texture can be repeated without
    showing the seam between two textures next to each other. For this recipe, we'll
    use the `webtreats_metal_6-512px.jpg` texture, which you can find in the `asset/textures`
    folder that you can find in the sources for this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是用作纹理的图像。为了达到最佳效果，你应该使用无缝纹理。无缝纹理可以在不显示相邻两个纹理之间的接缝的情况下重复。在这个菜谱中，我们将使用
    `webtreats_metal_6-512px.jpg` 纹理，你可以在本书源代码中的 `asset/textures` 文件夹中找到它。
- en: '![Getting ready](img/1182OS_04_30.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_30.jpg)'
- en: To see the repeat effect in practice, you can open the `04.12-setup-repeating-textures.html`
    example in your browser.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在实际中看到重复效果，你可以在浏览器中打开 `04.12-setup-repeating-textures.html` 示例。
- en: '![Getting ready](img/1182OS_04_31.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_31.jpg)'
- en: With the menu in the top-right corner, you can define how often the texture
    is repeated along its *x* axis and *y* axis.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右上角的菜单，你可以定义纹理沿其 *x* 轴和 *y* 轴重复的频率。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up a repeating texture is very simple and only requires a couple of
    steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 设置重复纹理非常简单，只需几个步骤：
- en: 'First, create the geometry and the material:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建几何形状和材质：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this recipe, we use `THREE.MeshPhongMaterial`, but you can use this recipe
    for all the materials that allow you use textures.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `THREE.MeshPhongMaterial`，但你也可以使用这个菜谱来处理所有允许使用纹理的材质。
- en: 'Next, we load the texture and set it on `cubeMaterial`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们加载纹理并将其设置在 `cubeMaterial` 上：
- en: '[PRE27]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to set the `wrapS` and `wrapT` properties on the texture:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在纹理上设置 `wrapS` 和 `wrapT` 属性：
- en: '[PRE28]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These properties define whether Three.js should stretch the texture to the side
    (`THREE.ClampToEdgeWrapping`) or repeat the texture with `THREE.RepeatWrapping`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些属性定义了 Three.js 是否应该拉伸纹理到边缘（`THREE.ClampToEdgeWrapping`）或使用 `THREE.RepeatWrapping`
    重复纹理。
- en: 'The final step is to set how often to repeat the texture along the *x* axis
    and *y* axis:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是设置沿 *x* 轴和 *y* 轴重复纹理的频率：
- en: '[PRE29]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, we repeat the texture along both its axis twice.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在两个轴上重复纹理两次。
- en: An interesting thing to know is that by providing negative values to the `map.repeat.set`
    function, you can also mirror the texture.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有趣的是，通过向 `map.repeat.set` 函数提供负值，你也可以镜像纹理。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each face within a geometry has a UV mapping that defines which part of a texture
    should be used for that face. When you configure a repeat wrapping, Three.js changes
    this UV mapping according to the values that have been set on the `map.repeat`
    property. As we also define that we want to use `THREE.RepeatWrapping`, WebGL
    knows how to interpret these changed UV values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几何体内的每个面都有一个 UV 映射，它定义了应该使用纹理的哪个部分来表示该面。当您配置重复包装时，Three.js 会根据在 `map.repeat`
    属性上设置的值更改这个 UV 映射。因为我们还定义了我们要使用 `THREE.RepeatWrapping`，WebGL 就知道如何解释这些更改后的 UV
    值。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Repeating textures works by changing the UV mapping according to the repeat
    property. You can also configure a UV mapping by hand, as shown in the *Using
    Blender to create custom UV mapping* recipe.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复纹理是通过根据重复属性更改 UV 映射来工作的。您也可以手动配置 UV 映射，如 *使用 Blender 创建自定义 UV 映射* 菜谱中所示。
- en: Making part of an object transparent
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使对象的一部分透明
- en: You can create a lot of interesting visualizations using the various materials
    available with Three.js. In this recipe, we'll look at how you can use the materials
    available with Three.js to make part of an object transparent. This will allow
    you to create complex-looking geometries with relative ease.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Three.js 提供的各种材质创建许多有趣的可视化效果。在这个菜谱中，我们将探讨您如何使用 Three.js 中可用的材质使对象的一部分透明。这将使您能够相对容易地创建看起来复杂的外观。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before we dive into the required steps in Three.js, we first need to have the
    texture that we will use to make an object partially transparent. For this recipe,
    we will use the following texture, which was created in Photoshop:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 Three.js 中所需的步骤之前，我们首先需要我们用来使对象部分透明的纹理。对于这个菜谱，我们将使用以下纹理，它是在 Photoshop
    中创建的：
- en: '![Getting ready](img/1182OS_04_14.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_04_14.jpg)'
- en: 'You don''t have to use Photoshop; the only thing you need to keep in mind is
    that you use an image with a transparent background. Using this texture, in this
    recipe, we''ll show you how you can create the following (`04.08-make-part-of-object-transparent.html`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用 Photoshop；您需要记住的唯一一件事是使用一个带有透明背景的图片。使用这种纹理，在这个菜谱中，我们将向您展示您如何创建以下内容（`04.08-make-part-of-object-transparent.html`）：
- en: '![Getting ready](img/1182OS_04_15.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_04_15.jpg)'
- en: As you can see in the preceeding, only part of the sphere is visible, and you
    can look through the sphere to see the back at the other side of the sphere.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面看到的，只有球体的一部分是可见的，您可以通过球体看到球体的另一侧。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at the steps you need to take to accomplish this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您需要采取的步骤来完成这个任务：
- en: 'The first thing we do is create the geometry. For this recipe, we use `THREE.SphereGeometry`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建几何体。对于这个菜谱，我们使用 `THREE.SphereGeometry`：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Just like all the other recipes, you can use whatever geometry you want.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像所有其他菜谱一样，您可以使用任何您想要的几何体。
- en: 'In the second step, we create the material:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建材质：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in this fragment, we create `THREE.MeshPhongMaterial` and load
    the texture we saw in the *Getting ready* section of this recipe. To render this
    correctly, we also need to set the side property to `THREE.DoubleSide` so that
    the inside of the sphere is also rendered, and we need to set the `depthWrite`
    property to false. This will tell WebGL that we still want to test our vertices
    against the WebGL depth buffer, but we don't write to it. Often, you need to set
    this to false when working with more complex transparent objects or particles.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您在这个片段中看到的，我们创建 `THREE.MeshPhongMaterial` 并加载我们在本菜谱 *准备就绪* 部分中看到的纹理。为了正确渲染，我们还需要将侧面属性设置为
    `THREE.DoubleSide`，以便渲染球体的内部，并且我们需要将 `depthWrite` 属性设置为 false。这将告诉 WebGL 我们仍然想要测试我们的顶点与
    WebGL 深度缓冲区，但我们不写入它。通常，当与更复杂的透明对象或粒子一起工作时，您需要将此设置为 false。
- en: 'Finally, add the sphere to the scene:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将球体添加到场景中：
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With these simple steps, you can create really interesting effects by just experimenting
    with textures and geometries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的步骤，您可以通过仅对纹理和几何体进行实验来创建非常有趣的效果。
- en: There's more…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'With Three.js, it is possible to repeat textures (refer to the *Setup repeating
    textures* recipe). You can use this to create interesting-looking objects such
    as this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Three.js，可以重复纹理（参考 *设置重复纹理* 菜谱）。您可以使用它来创建看起来很有趣的对象，例如这个：
- en: '![There''s more…](img/1182OS_04_16.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_04_16.jpg)'
- en: 'The code required to set a texture to repeat is the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 设置纹理重复所需的代码如下：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By changing the `mat.map.repeat.set` values, you define how often the texture
    is repeated.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改`mat.map.repeat.set`的值，你可以定义纹理重复的频率。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: There are two alternative ways of making part of an object transparent. You
    could divide the object into multiple geometries and group them, or you could
    make individual faces transparent like we did in the *Using separate materials
    for faces* recipe.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两种不同的方法可以使物体的一部分透明。你可以将物体分成多个几何体并分组，或者你可以像我们在*使用单独的材质为面*配方中所做的那样，使单个面透明。
- en: Using a cubemap to create reflective materials
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立方体贴图创建反射材质
- en: With the approach Three.js uses to render scenes in real time, it is difficult
    and very computationally intensive to create reflective materials. Three.js, however,
    provides a way you can cheat and approximate reflectivity. For this, Three.js
    uses cubemaps. In this recipe, we'll explain how to create cubemaps and use them
    to create reflective materials.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Three.js使用实时渲染场景的方法，创建反射材质既困难又非常计算密集。然而，Three.js提供了一种你可以作弊并近似反射率的方法。为此，Three.js使用立方体贴图。在这个配方中，我们将解释如何创建立方体贴图以及如何使用它们来创建反射材质。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A cubemap is a set of six images that can be mapped to the inside of a cube.
    They can be created from a panorama picture and look something like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图是一组六个图像，可以映射到立方体的内部。它们可以从全景图片创建，看起来可能像这样：
- en: '![Getting ready](img/1182OS_04_17.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_04_17.jpg)'
- en: 'In Three.js, we map such a map on the inside of a cube or sphere and use that
    information to calculate reflections. The following screenshot (example `04.10-use-reflections.html`)
    shows what this looks like when rendered in Three.js:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，我们在立方体或球体的内部映射这样的贴图，并使用这些信息来计算反射。以下截图（示例`04.10-use-reflections.html`）显示了在Three.js中渲染时的样子：
- en: '![Getting ready](img/1182OS_04_18.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_04_18.jpg)'
- en: 'As you can see in the preceeding screenshot, the objects in the center of the
    scene reflect the environment they are in. This is something often called a skybox.
    To get ready, the first thing we need to do is get a cubemap. If you search on
    the Internet, you can find some ready-to-use cubemaps, but it is also very easy
    to create one yourself. For this, go to [http://gonchar.me/panorama/](http://gonchar.me/panorama/).
    On this page, you can upload a panoramic picture and it will be converted to a
    set of pictures you can use as a cubemap. For this, perform the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，场景中心的物体反射了它们所在的环境。这通常被称为天空盒。为了做好准备，我们首先需要做的是获取一个立方体贴图。如果你在网上搜索，你可以找到一些现成的立方体贴图，但自己创建一个也非常简单。为此，请访问[http://gonchar.me/panorama/](http://gonchar.me/panorama/)。在这个页面上，你可以上传一张全景图片，它将被转换成你可以用作立方体贴图的图片集。为此，执行以下步骤：
- en: First, get a 360 degrees panoramic picture. Once you have one, upload it to
    the [http://gonchar.me/panorama/](http://gonchar.me/panorama/) website by clicking
    on the large **OPEN** button:![Getting ready](img/1182OS_04_19.jpg)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取一张360度的全景图片。一旦你有了，点击大型的**打开**按钮将其上传到[http://gonchar.me/panorama/](http://gonchar.me/panorama/)网站：![准备工作](img/1182OS_04_19.jpg)
- en: Once uploaded, the tool will convert the panorama picture to a cubemap as shown
    in the following screenshot:![Getting ready](img/1182OS_04_20.jpg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦上传，该工具将把全景图片转换为立方体贴图，如下截图所示：![准备工作](img/1182OS_04_20.jpg)
- en: When the conversion is done, you can download the various cube map sites. The
    recipe in this book uses the naming convention provided by **Cube map sides**
    option, so download them. You'll end up with six images with names such as `right.png`,
    `left.png`, `top.png`, `bottom.png`, `front.png`, and `back.png`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换完成后，你可以下载各种立方体贴图站点。本书中的配方使用**立方体贴图侧面**选项提供的命名约定，因此请下载它们。你将得到六个名为`right.png`、`left.png`、`top.png`、`bottom.png`、`front.png`和`back.png`的图像。
- en: Once you've got the sides of the cubemap, you're ready to perform the steps
    in the recipe.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了立方体贴图的侧面，你就可以执行配方中的步骤了。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use the cubemap we created in the previous section and create reflecting
    material,we need to perform a fair number of steps, but it isn''t that complex:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用上一节中创建的立方体贴图并创建反射材质，我们需要执行相当多的步骤，但这并不复杂：
- en: 'The first thing you need to do is create an array from the cubemap images you
    downloaded:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是从你下载的立方体贴图图像中创建一个数组：
- en: '[PRE34]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this array, we can create a cubemap texture like this:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个数组，我们可以创建一个像这样的立方体贴图纹理：
- en: '[PRE35]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From this cubemap, we can use `THREE.BoxGeometry` and a custom `THREE.ShaderMaterial`
    object to create a skybox (the environment surrounding our meshes):'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个立方体贴图中，我们可以使用`THREE.BoxGeometry`和一个自定义的`THREE.ShaderMaterial`对象来创建一个天空盒（围绕我们的网格的环境）：
- en: '[PRE36]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Three.js provides a custom shader (a piece of WebGL code) that we can use for
    this. As you can see in the code snippet, to use this WebGL code, we need to define
    a `THREE.ShaderMaterial` object. With this material, we create a giant `THREE.BoxGeometry`
    object that we add to scene.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Three.js提供了一个自定义着色器（一段WebGL代码），我们可以用它来做这个。正如你在代码片段中看到的，要使用这段WebGL代码，我们需要定义一个`THREE.ShaderMaterial`对象。使用这个材质，我们创建一个巨大的`THREE.BoxGeometry`对象并将其添加到场景中。
- en: 'Now that we''ve created the skybox, we can define the reflecting objects:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了天空盒，我们可以定义反射对象：
- en: '[PRE37]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we also pass in the cubemap we created as a property (`envmap`)
    to the material. This informs Three.js that this object is positioned inside a
    skybox, defined by the images that make up `cubemap`.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们还把创建的立方体贴图作为属性（`envmap`）传递给材质。这告诉Three.js这个对象位于由`cubemap`组成的图像定义的天空盒内。
- en: 'The last step is to add the object to the scene, and that''s it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将对象添加到场景中，然后就这样：
- en: '[PRE38]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the example in the beginning of this recipe, you saw three geometries. You
    can use this approach with all different types of geometries. Three.js will determine
    how to render the reflective area.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱开头的示例中，你看到了三个几何体。你可以用这种方法处理所有不同类型的几何体。Three.js将确定如何渲染反射区域。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Three.js itself doesn''t really do that much to render the `cubemap` object.
    It relies on a standard functionality provided by WebGL. In WebGL, there is a
    construct called `samplerCube`. With `samplerCube`, you can sample, based on a
    specific direction, which color matches the `cubemap` object. Three.js uses this
    to determine the color value for each part of the geometry. The result is that
    on each mesh, you can see a reflection of the surrounding cubemap using the WebGL
    `textureCube` function. In Three.js, this results in the following call (taken
    from the WebGL shader in GLSL):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js本身并没有做很多来渲染`cubemap`对象。它依赖于WebGL提供的一个标准功能。在WebGL中，有一个叫做`samplerCube`的结构。使用`samplerCube`，你可以根据特定的方向采样，以确定与`cubemap`对象匹配的颜色。Three.js使用这个来确定几何体每一部分的颜色值。结果是，在每一个网格上，你可以看到使用WebGL的`textureCube`函数反射的周围立方体贴图。在Three.js中，这导致以下调用（从GLSL的WebGL着色器中提取）：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A more in-depth explanation on how this works can be found at [http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup](http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这是如何工作的更深入的解释可以在[http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup](http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup)找到。
- en: There's more...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we created the `cubemap` object by providing six separate images.
    There is, however, an alternative way to create the `cubemap` object. If you''ve
    got a 360 degrees panoramic image, you can use the following code to directly
    create a `cubemap` object from that image:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们通过提供六个单独的图像创建了`cubemap`对象。然而，还有一种创建`cubemap`对象的方法。如果你有一个360度的全景图像，你可以使用以下代码直接从该图像创建`cubemap`对象：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Normally when you create a `cubemap` object, you use the code shown in this
    recipe to map it to a skybox. This usually gives the best results but requires
    some extra code. You can also use `THREE.SphereGeometry` to create a skybox like
    this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你创建一个`cubemap`对象时，你使用本食谱中显示的代码将其映射到天空盒。这通常给出最佳结果，但需要一些额外的代码。你也可以使用`THREE.SphereGeometry`创建一个类似这样的天空盒：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This applies the texture to a sphere and with `mesh.scale`, turns this sphere
    inside out.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将纹理应用到球体上，并通过`mesh.scale`将这个球体翻转内外。
- en: 'Besides reflection, you can also use a `cubemap` object for refraction (think
    about light bending through water drops or glass objects):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反射，你还可以使用`cubemap`对象进行折射（想想光线通过水滴或玻璃物体弯曲的情况）：
- en: '![There''s more...](img/1182OS_04_21.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1182OS_04_21.jpg)'
- en: 'All you have to do to make a refractive material is load the `cubemap` object
    like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个折射材质，你只需要像这样加载`cubemap`对象：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And define the material in the following way:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式定义材质：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you look closely at the example shown at the beginning of this recipe, you
    might notice that you don't see the reflections of the individual objects on each
    other. You only see the reflection of the skybox. In the *Using a dynamic cubemap
    to create reflective materials* recipe, we show you how you can make the `cubemap`
    object dynamic so that other rendered meshes are reflected.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您仔细观察这个配方开始时展示的示例，您可能会注意到您看不到各个对象之间的反射。您只能看到天空盒的反射。在 *使用动态立方体贴图创建反射材料* 配方中，我们向您展示了如何使
    `cubemap` 对象动态化，以便其他渲染网格也能被反射。
- en: Using a dynamic cubemap to create reflective materials
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态立方体贴图创建反射材料
- en: In the *Using a cubemap to create reflective materials* recipe, we showed how
    you can create a material that reflects its environment. The only caveat was that
    other meshes rendered in the scene didn't show up in the reflection; only the
    cubemap was shown. In this recipe, we will show you how you can create a dynamic
    cubemap that also reflects other meshes in the scene.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用立方体贴图创建反射材料* 的配方中，我们展示了如何创建一个能够反射其环境的材料。唯一的限制是场景中渲染的其他网格在反射中并未显示；只有立方体贴图被显示出来。在这个配方中，我们将向您展示如何创建一个动态的立方体贴图，它也能反射场景中的其他网格。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To get ready for this recipe, you need to follow the steps explained in the
    *Getting ready* section for the *Using a cubemap to create reflective materials*
    recipe. For this recipe, we provide a separate example that you can display by
    opening `04.11-use-reflections-dynamically.html` in your browser.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个配方，您需要遵循 *准备就绪* 部分中 *使用立方体贴图创建反射材料* 配方的说明。对于这个配方，我们提供了一个单独的示例，您可以通过在浏览器中打开
    `04.11-use-reflections-dynamically.html` 来显示它。
- en: '![Getting ready](img/1182OS_04_22.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_04_22.jpg)'
- en: If you look closely at the central sphere in the preceding, you can see that
    it not only reflects the environment, but also reflects the cylinder, and if you
    rotate the scene, you can also see the cube reflection.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察前面的中央球体，您可以看到它不仅反射了环境，还反射了圆柱体，如果您旋转场景，您还可以看到立方体贴图的反射。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To accomplish this, we first need to perform a couple of the same steps, like
    we did in the *Using a cubemap to create reflective materials* recipe. So, before
    you start with the steps in this recipe, take the first three steps from that
    recipe. After these three steps, you can continue with these steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先需要执行一些与 *使用立方体贴图创建反射材料* 配方中相同的步骤。因此，在开始本配方中的步骤之前，请从该配方中取前三个步骤。完成这三个步骤后，您可以继续以下步骤：
- en: 'To create a dynamic cubemap, we need to use `THREE.CubeCamera`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个动态立方体贴图，我们需要使用 `THREE.CubeCamera`：
- en: '[PRE44]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With `THREE.CubeCamera`, we can take a snapshot of the environment and use
    it as the `cubemap` object in our materials. For the best result, you should position
    `THREE.CubeCamera` at the same location as the mesh on which you want to use the
    dynamic `cubemap` object. In this recipe, we use it on the central sphere, which
    is located at this position: 0, 0, 0\. So, we don''t need to set the position
    of `cubeCamera`.'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `THREE.CubeCamera`，我们可以捕捉环境并使用它作为材料中的 `cubemap` 对象。为了获得最佳效果，您应该将 `THREE.CubeCamera`
    放置在您想要使用动态 `cubemap` 对象的网格相同的位置。在这个配方中，我们使用它来处理位于此位置的中央球体：0, 0, 0。因此，我们不需要设置 `cubeCamera`
    的位置。
- en: 'For this recipe, we use three geometries:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用了三个几何体：
- en: '[PRE45]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''re going to define the materials. We use the following two materials:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义材料。我们使用以下两种材料：
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first one is the material that uses the output from `cubeCamera` as its
    cubemap, and the second material uses a static `cubemap` object.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个是使用 `cubeCamera` 输出作为其立方体贴图的材料，第二个材料使用一个静态的 `cubemap` 对象。
- en: 'With these two materials, we can create the meshes and add them to the scene:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这两种材料，我们可以创建网格并将它们添加到场景中：
- en: '[PRE47]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last step we need to take is that in the `render` loop, we update `cubeCamera`
    like this:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是在 `render` 循环中更新 `cubeCamera`，如下所示：
- en: '[PRE48]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When you've taken all these steps, you'll end up with a sphere in the middle
    of the scene that not only reflects the environment, but also the other objects
    in the scene.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成所有这些步骤后，您将在场景中间得到一个球体，它不仅反射环境，还反射场景中的其他对象。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the *Using a cubemap to create reflective materials* recipe we explained
    how a cubemap is used to create reflective objects. The same principle also applies
    to this recipe, so if you haven't read the *How it works…* section from the *Using
    a cubemap to create reflective materials* recipe, please do that first. The main
    difference is that for this recipe, we create a cubemap on the fly with `THREE.CubeCamera`
    instead of using a static one. When you instantiate `THREE.CubeCamera`, you're
    really creating six `THREE.PerspectiveCamera` objects—one for each side of the
    cubemap. Whenever you call `updateCubeMap`, as we do in this recipe in the `render`
    loop, Three.js just renders the scene using these six cameras and uses the render
    results as the cubemap to be used.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用立方体贴图创建反射材料*菜谱中，我们解释了如何使用立方体贴图创建反射对象。同样的原理也适用于这个菜谱，所以如果你还没有阅读*它是如何工作的…*部分，请先阅读。主要区别是，对于这个菜谱，我们使用`THREE.CubeCamera`动态创建立方体贴图，而不是使用静态的立方体贴图。当你实例化`THREE.CubeCamera`时，你实际上创建了六个`THREE.PerspectiveCamera`对象——每个立方体贴图的一个面。每次你调用`updateCubeMap`，就像我们在本菜谱的`render`循环中所做的那样，Three.js只是使用这六个相机渲染场景，并将渲染结果用作要使用的立方体贴图。
- en: There's more…
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: In this recipe, we showed you how to make one mesh reflect the complete scene.
    If you create separate `THREE.CubeCamera` objects for each of the meshes in the
    scene, you can create a dynamic cubemap for all the objects. Keep in mind, though,
    that this is a rather computationally-intensive process. Instead of rendering
    the scene once, you incur six additional render passes for each cube camera you
    use.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了如何使一个网格反射整个场景。如果你为场景中的每个网格创建单独的`THREE.CubeCamera`对象，你可以为所有对象创建一个动态立方体贴图。然而，请注意，这是一个相当计算密集的过程。与只渲染一次场景相比，你将需要为每个立方体贴图对象进行六个额外的渲染过程。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a static cubemap, you can use the steps explained in the previous recipe,which
    is the *Using a cubemap to create reflective materials* recipe
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于静态立方体贴图，你可以使用前一个菜谱中解释的步骤，即*使用立方体贴图创建反射材料*菜谱
- en: Using Blender to create custom UV mapping
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Blender创建自定义UV映射
- en: If you want to apply a texture (a 2D image) to a geometry, you need to tell
    Three.js which part of the texture should be used for a specific `THREE.face`
    object. The definition of how a texture maps to the individual faces of a geometry
    is called a UV mapping. A UV mapping, for example, tells Three.js how to map a
    2D map of the earth to a 3D sphere geometry. When you're working with simple shapes,
    or the basic geometries provided with Three.js, the standard UV mapping that's
    provided is often enough. However, when shapes become more complex or you have
    some specific texture mapping requirements, you need to change how each face of
    a geometry is mapped to part of a texture. One option is to do this by hand, but
    for larger geometries, this is very difficult and time-consuming. In this recipe,
    we will show you how you can create a custom mapping with Blender.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将纹理（一个2D图像）应用到几何体上，你需要告诉Three.js纹理的哪一部分应该用于特定的`THREE.face`对象。如何将纹理映射到几何体的各个面的定义称为UV映射。例如，UV映射告诉Three.js如何将地球的2D地图映射到3D球面几何体。当你处理简单形状或Three.js提供的基几何体时，提供的标准UV映射通常就足够了。然而，当形状变得更加复杂或你有特定的纹理映射要求时，你需要改变几何体的每个面如何映射到纹理的一部分。一个选择是手动完成，但对于较大的几何体来说，这非常困难且耗时。在这个菜谱中，我们将向你展示如何使用Blender创建自定义映射。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, you need to have Blender installed; if you haven''t installed
    Blender yet, look at the *Getting ready* section of the *Creating and exporting
    a model from Blender* recipe from [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. Once you''ve installed Blender, start it
    and you''re presented with a screen similar to the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要安装Blender；如果你还没有安装Blender，请查看[第2章](ch02.html "第2章。几何体和网格")中“从Blender创建和导出模型”菜谱的“准备就绪”部分，*几何体和网格*。一旦安装了Blender，启动它，你将看到一个类似于以下截图的屏幕：
- en: '![Getting ready](img/1182OS_04_23.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_04_23.jpg)'
- en: In the following section, we'll show you the steps you need to take to create
    a custom UV mapping for this cube.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将向你展示创建此立方体贴图所需采取的步骤。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps explain how to create a custom UV mapping in Blender and
    use it in Three.js:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了如何在Blender中创建自定义UV映射并在Three.js中使用它：
- en: The first thing to do is switch to edit mode. To do this, hover the mouse over
    the cube and hit **tab**. You should see something like this:![How to do it...](img/1182OS_04_24.jpg)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是切换到编辑模式。为此，将鼠标悬停在立方体上并按**tab**键。您应该会看到类似这样的效果：![如何操作...](img/1182OS_04_24.jpg)
- en: If the cube isn't highlighted, hover over it with the mouse and push a. This
    will select all the vertices and faces.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果立方体没有高亮显示，用鼠标悬停在它上面并按a键。这将选择所有顶点和面。
- en: Now, let's create a standard UV mapping for this cube. To do this, navigate
    to **Mesh** | **Uv Unwrap** | **Unwrap**. Now, split the active view and open
    the **UV/Image editor** view.![How to do it...](img/1182OS_04_25.jpg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为这个立方体创建一个标准的UV映射。为此，导航到**网格** | **UV展开** | **展开**。现在，分割活动视图并打开**UV/图像编辑器**视图。![如何操作...](img/1182OS_04_25.jpg)
- en: In the left part of the Blender window, we now see how all the selected faces
    and vertices are mapped to a texture.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Blender窗口的左侧部分，我们现在可以看到所有选定的面和顶点是如何映射到纹理上的。
- en: In the right-hand side view, select the front face, and you can immediately
    see how that face is mapped to the texture:![How to do it...](img/1182OS_04_26.jpg)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧视图中，选择前面，您可以直接看到该面是如何映射到纹理上的：![如何操作...](img/1182OS_04_26.jpg)
- en: Now, we can change the mapping of this face by moving the vertices on the left-hand
    side side of the screen. Before we do that, though, we first load a texture image.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以通过移动屏幕左侧的顶点来更改这个面的映射。不过，在我们这样做之前，我们首先加载一个纹理图像。
- en: With your mouse on top of the left part of the screen, hit *Alt* + *O* to select
    an image. For this recipe, it is easiest to use the `debug.png` texture you can
    find in the `assets/textures` directory. Once you open the image, the screen will
    look like this:![How to do it...](img/1182OS_04_27.jpg)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标放在屏幕左侧部分，按*Alt* + *O*选择一个图像。对于这个配方，使用在`assets/textures`目录中可以找到的`debug.png`纹理是最简单的。一旦打开图像，屏幕将看起来像这样：![如何操作...](img/1182OS_04_27.jpg)
- en: By dragging the corners in the left view, we change the UV mapping of the selected
    face. Move these corners around to create something like this:![How to do it...](img/1182OS_04_28.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在左侧视图中拖动角落，我们更改了所选面的UV映射。将这些角落移动到类似这样的位置：![如何操作...](img/1182OS_04_28.jpg)
- en: As you can see, we changed the UV mapping for this face from the whole texture
    to just the top-left corner.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们将这个面的UV映射从整个纹理更改为仅左上角。
- en: The next step is to export this geometry, load it in Three.js, and see whether
    the mapping has really changed for the face we changed. To export the model, we'll
    use the `OBJ` format in this recipe. So, navigate to **File** | **Export** | **Wavefront**
    and save the model.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是导出这个几何形状，在Three.js中加载它，并查看我们更改的面是否确实发生了映射变化。在这个配方中，我们将使用`OBJ`格式来导出模型。因此，导航到**文件**
    | **导出** | **Wavefront**并保存模型。
- en: 'To load the model, we first need to include the `OBJLoader` JavaScript file
    on the header of the page:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加载模型，我们首先需要在页面的头部包含`OBJLoader` JavaScript文件：
- en: '[PRE49]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can use the loader to load the model and add it to the scene:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用加载器来加载模型并将其添加到场景中：
- en: '[PRE50]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we explicitly set the texture we want to use, as we didn't
    use `OBJMTLLoader`.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们明确设置了我们想要使用的纹理，因为我们没有使用`OBJMTLLoader`。
- en: As a final step, let's look at the result. We provided an example, `04.14-create-custom-uv-mapping.html`,
    that shows the result of these steps.![How to do it...](img/1182OS_04_29.jpg)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们看看结果。我们提供了一个示例，`04.14-create-custom-uv-mapping.html`，展示了这些步骤的结果。![如何操作...](img/1182OS_04_29.jpg)
- en: As you can see from the preceding screenshot, the front face for which we changed
    the UV mapping shows only part of the texture, while the other sides show the
    complete texture.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，我们更改了UV映射的前面只显示了纹理的一部分，而其他侧面则显示了完整的纹理。
- en: There's more…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We''ve only touched upon a very small part of how Blender can help in creating
    UV mappings. A good starting point to learn more about UV mapping in Blender are
    the following two sites:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是简要介绍了Blender在创建UV映射方面的帮助。要了解更多关于Blender中UV映射的信息，以下两个网站是很好的起点：
- en: '[http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics](http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics](http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics)'
- en: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/ Mapping/UV](http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/Mapping/UV)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/Mapping/UV](http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/Mapping/UV)'
- en: See also
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: For more information on how to integrate Three.js with Blender, you can have
    a look at the *Creating and exporting a model from Blender* recipe, from [Chapter
    2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and Meshes* where
    we show how to install the Three.js plugin for Blender and how you can load a
    model and its material directly in Three.js.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何将Three.js与Blender集成的更多信息，你可以查看[第2章](ch02.html "第2章。几何体和网格")中的*从Blender创建和导出模型*食谱，*几何体和网格*，其中我们展示了如何安装Blender的Three.js插件以及如何在Three.js中直接加载模型及其材质。
- en: Configuring blend modes
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置混合模式
- en: When an object is rendered on top of another object in Three.js, you can configure
    how to blend in the colors from the objects behind it. In this recipe, we show
    you the steps you need to take to set a specific blend mode. You can compare this
    with the way the various blending layers in Photoshop work.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Three.js中渲染一个对象在另一个对象之上时，你可以配置如何混合来自其后方的对象的颜色。在这个食谱中，我们向您展示了设置特定混合模式所需的步骤。你可以将其与Photoshop中各种混合层的工作方式进行比较。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Understanding the results of a specific blend mode is difficult. To help in
    understanding the different available blend modes, we provide a simple web page
    that shows you the blend modes and allows you to switch between them. You can
    see this example by opening `04.13-configuring-blend-modes.html` in your browser.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 理解特定混合模式的结果是困难的。为了帮助理解不同的可用混合模式，我们提供了一个简单的网页，展示了混合模式并允许你在它们之间切换。你可以在浏览器中打开`04.13-configuring-blend-modes.html`来查看这个示例。
- en: '![Getting ready](img/1182OS_04_32.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_04_32.jpg)'
- en: With the menu in the top-right section of the preceding screenshot, you can
    see what the result of each blend mode is.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前一个截图右上角的菜单，你可以看到每种混合模式的结果。
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Setting a blend mode is easy:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 设置混合模式很简单：
- en: 'First, create a geometry and a material:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个几何体和一个材质：
- en: '[PRE51]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, set the `blending` property to the blend mode you want to use:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`blending`属性设置为你要使用的混合模式：
- en: '[PRE52]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, set the `transparent` property to `true`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`transparent`属性设置为`true`：
- en: '[PRE53]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can find an overview of the available, standard blend modes by looking
    at the Three.js sources:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过查看Three.js源代码来找到可用标准混合模式的概述：
- en: '[PRE54]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we've seen, Three.js uses WebGL to render the scenes. The blend modes you
    define on the material for Three.js are used internally by WebGL to determine
    how to blend the background color with the foreground color.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Three.js使用WebGL来渲染场景。你在材质上定义的混合模式被WebGL内部用来确定如何混合背景色和前景色。
- en: There's more…
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Besides the blend modes we''ve shown in this recipe, it is also possible to
    define your own custom blend modes. You can do this by setting the `blending`
    property to `THREE.CustomBlending`. Use these three material properties to define
    how the foreground is blended with the background: `blendSrc`, `blendDst`, and
    `blendEquation`. For `blendSrc`, you can use the following values:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这个食谱中展示的混合模式外，你也可以定义自己的自定义混合模式。你可以通过将`blending`属性设置为`THREE.CustomBlending`来实现这一点。使用以下三个材质属性来定义前景与背景的混合方式：`blendSrc`、`blendDst`和`blendEquation`。对于`blendSrc`，你可以使用以下值：
- en: '[PRE55]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For `blendDst`, you can use these values:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`blendDst`，你可以使用以下值：
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For the `blendEquation`, WebGL supports the following set:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`blendEquation`，WebGL支持以下集合：
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A very good example that shows many of these settings can be found on the Three.js
    examples site at [http://threejs.org/examples/#webgl_materials_blending_custom](http://threejs.org/examples/#webgl_materials_blending_custom).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的例子，展示了这些设置中的许多，可以在Three.js示例网站上找到，网址为[http://threejs.org/examples/#webgl_materials_blending_custom](http://threejs.org/examples/#webgl_materials_blending_custom)。
- en: Using a shadow map for fixed shadows
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阴影贴图进行固定阴影
- en: In [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and
    Custom Shaders* we will show you a number of recipes that deal with lights and
    shadows. It is, however, also possible to fake shadows using a texture. This kind
    of texture is called a shadow map or a light map. In this recipe, we explain how
    you can use such a texture in Three.js.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。灯光和自定义着色器")中，我们将向您展示一些处理灯光和阴影的食谱。然而，使用纹理也可以伪造阴影。这种纹理被称为阴影贴图或光照贴图。在这个食谱中，我们解释了如何在Three.js中使用这种纹理。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we first need a shadow map. There are different ways to create
    shadow maps, but that is outside the scope of this recipe. If you''re interested
    in creating your own shadow maps, you can follow this tutorial from the Blender
    site: [http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps](http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps).'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们首先需要一个阴影贴图。创建阴影贴图有不同的方法，但这超出了本配方的范围。如果您对创建自己的阴影贴图感兴趣，可以参考Blender网站上的这个教程：[http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps](http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps)。
- en: In the sources for this book, in the `assets/textures` folder, you can find
    a `shadow-map.png` file that we'll use in this recipe.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的源代码中，在`assets/textures`文件夹中，您可以找到一个`shadow-map.png`文件，我们将在这个配方中使用它。
- en: '![Getting ready](img/1182OS_04_33.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_33.jpg)'
- en: 'In the preceding figure, you can see what a shadow map looks like. As you can
    see, a shadow map contains the shadows of a scene prerendered in the target geometry,
    in this case, a plane. If we use this image as a shadow map, we can easily view
    the following scene:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到阴影贴图的样子。如您所见，阴影贴图包含在目标几何体中预先渲染的场景的阴影，在本例中是一个平面。如果我们使用这张图片作为阴影贴图，我们可以轻松地查看以下场景：
- en: '![Getting ready](img/1182OS_04_34.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_04_34.jpg)'
- en: In this scene, we use the shadow map to create shadows for the ground plane.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们使用阴影贴图来为地面平面创建阴影。
- en: How to do it...
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using a shadow map is very easy. Before we look at the steps, make sure that
    you''ve got a geometry and a material. In the following steps, we have `THREE.Mesh`
    with the name floor:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阴影贴图非常简单。在我们查看步骤之前，请确保您有一个几何体和一个材质。在以下步骤中，我们有名为floor的`THREE.Mesh`：
- en: 'A UV mapping defines how a face maps to a specific part of a texture. The UV
    mapping in a geometry is stored in the `faceVertexUvs` property of a geometry.
    The first element of this array contains the UV mappings used for the other kinds
    of textures, and the second element contains the UV mapping for the shadow map.
    As this value isn''t filled by default, we point it to the first element in the
    `faceVertexUvs` array:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UV贴图定义了面如何映射到纹理的特定部分。几何体中的UV贴图存储在几何体的`faceVertexUvs`属性中。此数组的第一个元素包含用于其他类型纹理的UV映射，第二个元素包含阴影贴图的UV映射。由于默认情况下此值未填充，我们将它指向`faceVertexUvs`数组中的第一个元素：
- en: '[PRE58]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, you need to set the shadow map to the `lightmap` property of the material:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要将阴影贴图设置为材质的`lightmap`属性：
- en: '[PRE59]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, you add the other textures you might want to use:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加您可能想要使用的其他纹理：
- en: '[PRE60]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That's all you need to do. This works great, especially when you've got scenes
    with static meshes and fixed lights, and this is a great boost to performance.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要做的全部。这效果非常好，尤其是在您有静态网格和固定灯光的场景中，这对性能的提升非常显著。
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you require dynamic shadows that update based on animated lighting or objects
    in the scene, you need something else (or in addition to) than shadow maps. In
    [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and Custom
    Shaders* in the *Creating shadows with Three.SpotLight* recipe, we explain how
    to create dynamic shadows.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要基于动画灯光或场景中的对象更新的动态阴影，您需要其他（或除了阴影贴图之外）的东西。在[第5章](ch05.html "第5章。灯光和自定义着色器")的*Creating
    shadows with Three.SpotLight*配方中，我们解释了如何创建动态阴影。
