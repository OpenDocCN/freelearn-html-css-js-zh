- en: Chapter 4. Materials and Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding depth to a mesh with a bump map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding depth to a mesh with a normal map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML canvas as a texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML video as a texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mesh with multiple materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using separate materials for faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up repeating textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making part of an object transparent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a cubemap to create reflective materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a dynamic cubemap to create reflective materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Blender to create custom UV mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring blend modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shadow map for fixed shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js offers a large number of different materials and supports many different
    types of textures. These textures provide a great way to create interesting effects
    and graphics. In this chapter, we'll show you recipes that allow you to get the
    most out of these components provided by Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Adding depth to a mesh with a bump map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For detailed models, you require geometries with a large number of vertices
    and faces. If a geometry contains a very large number of vertices, loading the
    geometry and rendering it will take more time than it would take for a simple
    model. If you've got a scene with a large number of models, it is a good idea
    to try and minimize the number of vertices for better performance. There are a
    number of different techniques that you can use for this. In this recipe, we'll
    show you how you can use a bump map texture to add the illusion of depth to your
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get ready for this recipe, we need to get the textures that we want to use
    on our geometries. For this recipe, we require two textures: a color map, which
    is a standard texture, and a bump map, which describes the depth associated with
    the standard texture. The following screenshot shows you the color map that we
    will use (you can find these textures in the `assets/textures` folder in the sources
    provided with this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, this is a simple color map of a stone wall. Besides this texture,
    we also require the bump map. A bump map is a grayscale image, where the intensity
    of each pixel determines the height:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that the parts between the stones
    and the mortar has less height, as it is a dark color, as compared to the stones
    themselves, which have a lighter color. You can see the result you end up with
    at the end of this recipe by opening up the `04.01-add-depth-to-mesh-with-bump-map.html`
    example in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see two cubes. The cube on the left-hand
    side is rendered without a bump map, and the cube on the right-hand side is rendered
    with a bump map. As you can see, the right-hand side cube shows much more depth
    and detail than the cube on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you''ve got textures, using them to add depth to a model is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the geometry you want to use together with the bump map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we create `THREE.BoxGeometry`, but you can use a bump map with
    any kind of geometry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to create the material on which we define the bump map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create `THREE.MeshPhongMaterial` and set its `map` and `bumpMap` properties.
    The `map` property points to the color map texture, and the `bumpMap` property
    point to the grayscale bump map texture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can just create `THREE.Mesh` and add it to scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these three simple steps, you've created a cube that uses a bump map for
    added depth.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The values of each pixel in the bump map determine the height associated with
    that part of the texture. When rendering the scene, Three.js uses this information
    to determine how light affects the final color of the pixel it is rendering. The
    result is that without defining a very detailed model, we can add the illusion
    of extra depth. If you want to know more details about how bump mapping works,
    look at this site for a very detailed explanation: [http://www.tweak3d.net/articles/bumpmapping/](http://www.tweak3d.net/articles/bumpmapping/).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you the default way to define a bump map. There is,
    however, one additional property that you can use to tune bump mapping. The material
    we used in this recipe, `cubeBumpMaterial`, also has a `bumpScale` property. With
    this property, you can set the amount by which the bump map affects the depth.
    If this value is very small, you'll see some added depth, and if this value is
    higher, you'll see a more pronounced depth effect. You can set this property in
    the example for this cookbook (`04.01-add-depth-to-mesh-with-bump-map.html`).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an additional way to add detail and depth to your meshes. In the *Add
    depth to a mesh with a normal map* recipe, we show how to add depth and detail
    with a normal map instead of a bump map. In the *Creating geometries from height
    maps* recipe, of [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*, we showed you a different way to use bump maps by creating `THREE.Geometry`
    from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding depth to a mesh with a normal map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a bump map, we showed in the *Add depth to a mesh with a bump map* recipe,
    how to add depth and detail to a mesh using a specific texture. In this recipe,
    we provide another way to add even more depth and details without increasing the
    vertex count of the geometry. To do this, we will use a normal map. A normal map
    describes the normal vector for each pixel, which should be used to calculate
    how light affects the material used in the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use normal maps, we first need to get a color map and a normal map. For
    this recipe, we''ve used two screenshots. The first is the color map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot is the normal map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve got the two images, let''s first look at how this would look
    in practice. To see a normal map in action, open the `04.02-add-depth-to-mesh-with-normal-map.html`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see a standard rendered cube on the left-hand side
    and one where a normal map is added to on the right-hand side. You can directly
    see that the face of the right-hand side cube looks much more detailed than the
    face of the left-hand side cube.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a normal map is actually very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the geometry that we want to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this recipe, we use a simple `THREE.BoxGeometry` object, but you can use
    whichever geometry you want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a geometry, we create the material and configure the properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `map` properties contain the standard texture, and the `normalMap` properties
    contain the normal texture, which we showed you in the *Getting ready* section
    of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that is left to do now is to create a `THREE.Mesh` object and add it to
    the scene like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from these steps, using a normal map is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 3D modeling, a couple of mathematical concepts are important to understand.
    One of these concepts is a **normal** vector. A normal is the vector that stands
    perpendicular to the surface of the face of a geometry. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each blue line represents the normal vector, which is the vector that is perpendicular
    to the surface of that face. In a normal map, the direction of these vectors are
    shown as RGB values. When you apply a normal map to a specific face, Three.js
    uses the information from this normal map and the normal of the face to add depth
    to that face without adding additional vertices. For more information on how normal
    maps are used, refer to the site at [http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/](http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can fine-tune the height and direction in which the information from the
    normal map is applied to the face of geometry. For this, you can use the `normalScale`
    property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To see this effect in action, look at the example for this recipe, `04.02-add-depth-to-mesh-with-normal-map.html`,
    where you can use the menu in the top-right section to change this value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative for normal maps is bump maps. In the *Add depth to a mesh with
    a bump map* recipe, we show you how to use such a map instead of a normal map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML canvas as a texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most often when you use textures, you use static images. With Three.js, however,
    it is also possible to create interactive textures. In this recipe, we will show
    you how you can use an HTML5 canvas element as an input for your texture. Any
    change to this canvas is automatically reflected after you inform Three.js about
    this change in the texture used on the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we need an HTML5 canvas element that can be displayed as a
    texture. We can create one ourselves and add some output, but for this recipe,
    we''ve chosen something else. We will use a simple JavaScript library, which outputs
    a clock to a canvas element. The resulting mesh will look like this (see the `04.03-use-html-canvas-as-texture.html`
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The JavaScript used to render the clock was based on the code from this site:
    [http://saturnboy.com/2013/10/html5-canvas-clock/](http://saturnboy.com/2013/10/html5-canvas-clock/).
    To include the code that renders the clock in our page, we need to add the following
    to the `head` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a canvas as a texture, we need to perform a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create an HTML canvas element programmatically and define a fixed width.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a canvas, we need to render the clock that we use as the
    input for this recipe on it. The library is very easy to use; all you have to
    do is pass in the canvas element we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we''ve got a canvas that renders and updates an image of a clock.
    What we need to do now is create a geometry and a material and use this canvas
    element as a texture for this material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To create a texture from a canvas element, all we need to do is create a new
    instance of `THREE.Texture` and pass in the `canvas` element we created in step
    1\. We assign this texture to the `cubeMaterial.map` property, and that's it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you run the recipe at this step, you might see the clock rendered on the
    sides of the cubes. However, the clock won''t update itself. We need to tell Three.js
    that the canvas element has been changed. We do this by adding the following to
    the rendering loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This informs Three.js that our canvas texture has changed and needs to be updated
    the next time the scene is rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these four simple steps, you can easily create interactive textures and
    use everything you can create on a canvas element as a texture in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How this works is actually pretty simple. Three.js uses WebGL to render scenes
    and apply textures. WebGL has native support for using HTML canvas element as
    textures, so Three.js just passes on the provided canvas element to WebGL and
    it is processed as any other texture.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides using images and canvas elements as textures, we can also use a video
    element as a texture. In the *Using HTML video as a texture* recipe, we show you
    how to use a HTML video element as the input for a texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML video as a texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern browsers have great support for playing video without requiring any plugins.
    With Three.js, we can even use this video as the input for our textures. In this
    recipe, we'll show you the steps you need to take to output a video on a side
    of a cube.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need a video to play, of course. We used the trailer for
    the Blender-made movie *Sintel* ([http://www.sintel.org/](http://www.sintel.org/)),
    which is freely available. To view the result of this recipe, open `04.04-use-html-video-as-texture.html`
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you run this example, you can see that the video is being played at the
    side of a cube and keeps updating even when the cube is rotating.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this effect, we need to define an HTML video element as the source
    for a texture. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a way to play the video. For this, we add the following
    HTML element to the `body` element of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this piece of HTML, we'll load the video and play it looped once it is
    loaded using the `autoplay` and `loop` properties. As we've set `display:none`,
    this `video` element won't show up on the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a video playing, we can get a reference to this element
    and use it to create a texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `minFilter`, `magFilter`, `format`, and `generateMipmaps` properties used
    here provide the best result and performance when using a video as a texture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we''ve got a texture that we can use like any other texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we set the `map` property of the material to the video texture. So, any
    `THREE.Mesh` object we create that uses this material will show the video.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish the recipe, create `THREE.Mesh` object and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Three.js normally caches textures as they usually don''t change that often.
    In this recipe, though, the texture changes continuously. To inform Three.js that
    the texture has changed, we need to add the following to the render loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use this approach with any video that can be played in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebGL, which is used by Three.js to render the scenes, has native support to
    use video elements as input for the textures. Three.js just passes the video element
    to WebGL and doesn't need to do any preprocessing. In the WebGL code, the current
    image shown by the video is converted to a texture. Whenever we set `videoTexture.needsUpdate`
    to `true`, the texture is updated in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to remember when working with the video element is that the different
    browsers have varying support for video formats. A good up-to-date overview of
    what format is supported by which browser can be found on Wikipedia at [http://en.wikipedia.org/wiki/HTML5_video#Browser_support](http://en.wikipedia.org/wiki/HTML5_video#Browser_support).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative way to easily create changing textures is explained in the *Using
    HTML canvas as a texture* recipe. In this recipe, we explain how you can use the
    HTML `canvas` element as the input for a texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mesh with multiple materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create `THREE.Mesh`, you can only specify a single material that can
    be used for that mesh. In most scenarios, this will be sufficient. However, there
    are also cases where you want to combine multiple materials. For instance, you
    might want to combine `THREE.MeshLambertMaterial` with a material that shows you
    the wireframe of the geometry. In this recipe, we'll show you the required steps
    to create a mesh that uses multiple materials.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don't require additional resources or libraries. If you
    want to look at the result of this recipe, open up the `04.05-create-a-mesh-with-multiple-materials.html`
    example in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see a cylinder. This cylinder is rendered
    with two materials. In the next section, we'll show you the steps you need to
    take to create this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a multimaterial mesh, Three.js provides a helper function. You can
    use `THREE.SceneUtils` for this, as is shown in the next couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is create the geometry you want to use. For
    this recipe, we use a simple `THREE.CylinderGeometry` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the geometry, we can create the materials. You can use as many as you
    want, but in this recipe, we''ll just use two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we create a transparent `THREE.MeshLambertMaterial` object and
    `THREE.MeshBasicMaterial` object, which only renders a wireframe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can create the object that can be added to the scene. Instead of instantiating
    `THREE.Mesh`, we use the `createMultiMaterialObject` function provided by the
    `THREE.SceneUtils` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add the result from this function to the scene:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One thing to take into account is that the object we create here isn't `THREE.Mesh`
    but `THREE.Object3D`. Why a different object is created is explained in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What happens when you call the `createMultiMaterialObject` function is that
    Three.js simply creates multiple meshes and groups them together. If you open
    the Three.js file and look up this function, you''ll see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this function, Three.js iterates over the materials that are provided, and
    for each material, a new `THREE.Mesh` object is created. Because all the created
    meshes are added to group, the result looks like a single mesh that's created
    with multiple materials.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the approach from this recipe to create a material that uses multiple
    materials, the materials are applied to the complete geometry. In the *Using separate
    materials for faces* recipe, we show you how to use a different material for each
    specific face of a geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using separate materials for faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each geometry in Three.js consists of a number of vertices and faces. In most
    cases, when you define a material that can be used together with a geometry, you
    use a single material. With Three.js, however, it is also possible to define a
    unique material for each of the faces of your geometry. You could, for instance,
    use this to apply different textures to each side of a model of a house. In this
    recipe, we will explain how to set up the materials so that you can use different
    textures for individual faces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we won't use any external textures or libraries. It is good,
    however, to look at the final result that we'll be creating in this recipe. For
    this, open the `04.06-use-separate-materials-for-faces.html` example in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceeding screenshot, you can see a rotating sphere, where each face
    is rendered with a different color and half of the faces have been made transparent.
    In the following section, we'll show you the steps you need to take to recreate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define specific materials for each face, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the geometry. For this recipe, we use
    `THREE.SphereGeometry`, but these steps can also be applied to other geometries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we create the material in step 3, we provide an array of materials that
    we want to use. Additionally, we need to specify on each face the material from
    the array we''ll use. You can do this with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we traverse all the faces of the geometry we created.
    For each face, we set the `materialIndex` property to the index of the material
    we want to use. We also create a unique `material` object for each face in this
    code snippet, make half of them transparent, and finally, push the materials we
    create into the materials array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, the materials array contains a unique material for each face
    of the geometry, and for all the faces, the `materialIndex` property points to
    one of the materials in that array. Now, we can create `THREE.MeshFaceMaterial`
    object and together with the geometry, we can create `THREE.Mesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it. Each face of the geometry will use the material it points to.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we specify `materialIndex` on each `THREE.Face` object, Three.js knows
    which material from the provided array it should use when it wants to render a
    specific face. One thing you need to take into account is that this can affect
    the performance of your scene, as each of the materials needs to be managed by
    Three.js; however, the performance is better than using separate meshes but worse
    than combining the textures into one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the geometries Three.js provides already set a `materialIndex` property
    when you instantiate them. For instance, when you create `THREE.BoxGeometry`,
    the first two faces are mapped to `materialIndex 1`, the next two are mapped to
    `materialIndex 2`, and so on. So, if you want to style the sides of a box, you
    just have to provide an array with six materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting use of using materials for specific faces is that you can
    easily create interesting patterns, for instance, when you can very easily create
    a checked layout like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All you need is some small change to how you assign the `materialIndex` properties
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't want to style specific faces but apply multiple materials to a
    complete geometry, you can look at the *Creating a mesh with multiple materials*
    recipe, where we explain how to do just that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up repeating textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when you've found a texture you want to apply, you might want to
    repeat it. For instance, if you've got a large ground plane on which you want
    to apply a seamless wood texture, you don't want the texture to be applied as
    a single image for the whole plane. Three.js allows you to define the manner in
    which a texture is repeated when it is used on a geometry. In this recipe, we'll
    explain the steps you need to take to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need is the image that we'll use for a texture. For the best
    effect, you should use seamless textures. A seamless texture can be repeated without
    showing the seam between two textures next to each other. For this recipe, we'll
    use the `webtreats_metal_6-512px.jpg` texture, which you can find in the `asset/textures`
    folder that you can find in the sources for this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see the repeat effect in practice, you can open the `04.12-setup-repeating-textures.html`
    example in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the menu in the top-right corner, you can define how often the texture
    is repeated along its *x* axis and *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up a repeating texture is very simple and only requires a couple of
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the geometry and the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we use `THREE.MeshPhongMaterial`, but you can use this recipe
    for all the materials that allow you use textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we load the texture and set it on `cubeMaterial`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to set the `wrapS` and `wrapT` properties on the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These properties define whether Three.js should stretch the texture to the side
    (`THREE.ClampToEdgeWrapping`) or repeat the texture with `THREE.RepeatWrapping`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step is to set how often to repeat the texture along the *x* axis
    and *y* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we repeat the texture along both its axis twice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An interesting thing to know is that by providing negative values to the `map.repeat.set`
    function, you can also mirror the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each face within a geometry has a UV mapping that defines which part of a texture
    should be used for that face. When you configure a repeat wrapping, Three.js changes
    this UV mapping according to the values that have been set on the `map.repeat`
    property. As we also define that we want to use `THREE.RepeatWrapping`, WebGL
    knows how to interpret these changed UV values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Repeating textures works by changing the UV mapping according to the repeat
    property. You can also configure a UV mapping by hand, as shown in the *Using
    Blender to create custom UV mapping* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making part of an object transparent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create a lot of interesting visualizations using the various materials
    available with Three.js. In this recipe, we'll look at how you can use the materials
    available with Three.js to make part of an object transparent. This will allow
    you to create complex-looking geometries with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the required steps in Three.js, we first need to have the
    texture that we will use to make an object partially transparent. For this recipe,
    we will use the following texture, which was created in Photoshop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You don''t have to use Photoshop; the only thing you need to keep in mind is
    that you use an image with a transparent background. Using this texture, in this
    recipe, we''ll show you how you can create the following (`04.08-make-part-of-object-transparent.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceeding, only part of the sphere is visible, and you
    can look through the sphere to see the back at the other side of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the steps you need to take to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is create the geometry. For this recipe, we use `THREE.SphereGeometry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like all the other recipes, you can use whatever geometry you want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the second step, we create the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in this fragment, we create `THREE.MeshPhongMaterial` and load
    the texture we saw in the *Getting ready* section of this recipe. To render this
    correctly, we also need to set the side property to `THREE.DoubleSide` so that
    the inside of the sphere is also rendered, and we need to set the `depthWrite`
    property to false. This will tell WebGL that we still want to test our vertices
    against the WebGL depth buffer, but we don't write to it. Often, you need to set
    this to false when working with more complex transparent objects or particles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the sphere to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these simple steps, you can create really interesting effects by just experimenting
    with textures and geometries.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Three.js, it is possible to repeat textures (refer to the *Setup repeating
    textures* recipe). You can use this to create interesting-looking objects such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code required to set a texture to repeat is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: By changing the `mat.map.repeat.set` values, you define how often the texture
    is repeated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two alternative ways of making part of an object transparent. You
    could divide the object into multiple geometries and group them, or you could
    make individual faces transparent like we did in the *Using separate materials
    for faces* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a cubemap to create reflective materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the approach Three.js uses to render scenes in real time, it is difficult
    and very computationally intensive to create reflective materials. Three.js, however,
    provides a way you can cheat and approximate reflectivity. For this, Three.js
    uses cubemaps. In this recipe, we'll explain how to create cubemaps and use them
    to create reflective materials.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cubemap is a set of six images that can be mapped to the inside of a cube.
    They can be created from a panorama picture and look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Three.js, we map such a map on the inside of a cube or sphere and use that
    information to calculate reflections. The following screenshot (example `04.10-use-reflections.html`)
    shows what this looks like when rendered in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceeding screenshot, the objects in the center of the
    scene reflect the environment they are in. This is something often called a skybox.
    To get ready, the first thing we need to do is get a cubemap. If you search on
    the Internet, you can find some ready-to-use cubemaps, but it is also very easy
    to create one yourself. For this, go to [http://gonchar.me/panorama/](http://gonchar.me/panorama/).
    On this page, you can upload a panoramic picture and it will be converted to a
    set of pictures you can use as a cubemap. For this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, get a 360 degrees panoramic picture. Once you have one, upload it to
    the [http://gonchar.me/panorama/](http://gonchar.me/panorama/) website by clicking
    on the large **OPEN** button:![Getting ready](img/1182OS_04_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once uploaded, the tool will convert the panorama picture to a cubemap as shown
    in the following screenshot:![Getting ready](img/1182OS_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the conversion is done, you can download the various cube map sites. The
    recipe in this book uses the naming convention provided by **Cube map sides**
    option, so download them. You'll end up with six images with names such as `right.png`,
    `left.png`, `top.png`, `bottom.png`, `front.png`, and `back.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've got the sides of the cubemap, you're ready to perform the steps
    in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the cubemap we created in the previous section and create reflecting
    material,we need to perform a fair number of steps, but it isn''t that complex:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is create an array from the cubemap images you
    downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this array, we can create a cubemap texture like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From this cubemap, we can use `THREE.BoxGeometry` and a custom `THREE.ShaderMaterial`
    object to create a skybox (the environment surrounding our meshes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Three.js provides a custom shader (a piece of WebGL code) that we can use for
    this. As you can see in the code snippet, to use this WebGL code, we need to define
    a `THREE.ShaderMaterial` object. With this material, we create a giant `THREE.BoxGeometry`
    object that we add to scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve created the skybox, we can define the reflecting objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we also pass in the cubemap we created as a property (`envmap`)
    to the material. This informs Three.js that this object is positioned inside a
    skybox, defined by the images that make up `cubemap`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to add the object to the scene, and that''s it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the example in the beginning of this recipe, you saw three geometries. You
    can use this approach with all different types of geometries. Three.js will determine
    how to render the reflective area.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js itself doesn''t really do that much to render the `cubemap` object.
    It relies on a standard functionality provided by WebGL. In WebGL, there is a
    construct called `samplerCube`. With `samplerCube`, you can sample, based on a
    specific direction, which color matches the `cubemap` object. Three.js uses this
    to determine the color value for each part of the geometry. The result is that
    on each mesh, you can see a reflection of the surrounding cubemap using the WebGL
    `textureCube` function. In Three.js, this results in the following call (taken
    from the WebGL shader in GLSL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A more in-depth explanation on how this works can be found at [http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup](http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we created the `cubemap` object by providing six separate images.
    There is, however, an alternative way to create the `cubemap` object. If you''ve
    got a 360 degrees panoramic image, you can use the following code to directly
    create a `cubemap` object from that image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally when you create a `cubemap` object, you use the code shown in this
    recipe to map it to a skybox. This usually gives the best results but requires
    some extra code. You can also use `THREE.SphereGeometry` to create a skybox like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This applies the texture to a sphere and with `mesh.scale`, turns this sphere
    inside out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides reflection, you can also use a `cubemap` object for refraction (think
    about light bending through water drops or glass objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1182OS_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All you have to do to make a refractive material is load the `cubemap` object
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And define the material in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look closely at the example shown at the beginning of this recipe, you
    might notice that you don't see the reflections of the individual objects on each
    other. You only see the reflection of the skybox. In the *Using a dynamic cubemap
    to create reflective materials* recipe, we show you how you can make the `cubemap`
    object dynamic so that other rendered meshes are reflected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a dynamic cubemap to create reflective materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Using a cubemap to create reflective materials* recipe, we showed how
    you can create a material that reflects its environment. The only caveat was that
    other meshes rendered in the scene didn't show up in the reflection; only the
    cubemap was shown. In this recipe, we will show you how you can create a dynamic
    cubemap that also reflects other meshes in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready for this recipe, you need to follow the steps explained in the
    *Getting ready* section for the *Using a cubemap to create reflective materials*
    recipe. For this recipe, we provide a separate example that you can display by
    opening `04.11-use-reflections-dynamically.html` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look closely at the central sphere in the preceding, you can see that
    it not only reflects the environment, but also reflects the cylinder, and if you
    rotate the scene, you can also see the cube reflection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this, we first need to perform a couple of the same steps, like
    we did in the *Using a cubemap to create reflective materials* recipe. So, before
    you start with the steps in this recipe, take the first three steps from that
    recipe. After these three steps, you can continue with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a dynamic cubemap, we need to use `THREE.CubeCamera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `THREE.CubeCamera`, we can take a snapshot of the environment and use
    it as the `cubemap` object in our materials. For the best result, you should position
    `THREE.CubeCamera` at the same location as the mesh on which you want to use the
    dynamic `cubemap` object. In this recipe, we use it on the central sphere, which
    is located at this position: 0, 0, 0\. So, we don''t need to set the position
    of `cubeCamera`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For this recipe, we use three geometries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''re going to define the materials. We use the following two materials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first one is the material that uses the output from `cubeCamera` as its
    cubemap, and the second material uses a static `cubemap` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With these two materials, we can create the meshes and add them to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step we need to take is that in the `render` loop, we update `cubeCamera`
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you've taken all these steps, you'll end up with a sphere in the middle
    of the scene that not only reflects the environment, but also the other objects
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Using a cubemap to create reflective materials* recipe we explained
    how a cubemap is used to create reflective objects. The same principle also applies
    to this recipe, so if you haven't read the *How it works…* section from the *Using
    a cubemap to create reflective materials* recipe, please do that first. The main
    difference is that for this recipe, we create a cubemap on the fly with `THREE.CubeCamera`
    instead of using a static one. When you instantiate `THREE.CubeCamera`, you're
    really creating six `THREE.PerspectiveCamera` objects—one for each side of the
    cubemap. Whenever you call `updateCubeMap`, as we do in this recipe in the `render`
    loop, Three.js just renders the scene using these six cameras and uses the render
    results as the cubemap to be used.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you how to make one mesh reflect the complete scene.
    If you create separate `THREE.CubeCamera` objects for each of the meshes in the
    scene, you can create a dynamic cubemap for all the objects. Keep in mind, though,
    that this is a rather computationally-intensive process. Instead of rendering
    the scene once, you incur six additional render passes for each cube camera you
    use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a static cubemap, you can use the steps explained in the previous recipe,which
    is the *Using a cubemap to create reflective materials* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Blender to create custom UV mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to apply a texture (a 2D image) to a geometry, you need to tell
    Three.js which part of the texture should be used for a specific `THREE.face`
    object. The definition of how a texture maps to the individual faces of a geometry
    is called a UV mapping. A UV mapping, for example, tells Three.js how to map a
    2D map of the earth to a 3D sphere geometry. When you're working with simple shapes,
    or the basic geometries provided with Three.js, the standard UV mapping that's
    provided is often enough. However, when shapes become more complex or you have
    some specific texture mapping requirements, you need to change how each face of
    a geometry is mapped to part of a texture. One option is to do this by hand, but
    for larger geometries, this is very difficult and time-consuming. In this recipe,
    we will show you how you can create a custom mapping with Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to have Blender installed; if you haven''t installed
    Blender yet, look at the *Getting ready* section of the *Creating and exporting
    a model from Blender* recipe from [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. Once you''ve installed Blender, start it
    and you''re presented with a screen similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following section, we'll show you the steps you need to take to create
    a custom UV mapping for this cube.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps explain how to create a custom UV mapping in Blender and
    use it in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is switch to edit mode. To do this, hover the mouse over
    the cube and hit **tab**. You should see something like this:![How to do it...](img/1182OS_04_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the cube isn't highlighted, hover over it with the mouse and push a. This
    will select all the vertices and faces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's create a standard UV mapping for this cube. To do this, navigate
    to **Mesh** | **Uv Unwrap** | **Unwrap**. Now, split the active view and open
    the **UV/Image editor** view.![How to do it...](img/1182OS_04_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left part of the Blender window, we now see how all the selected faces
    and vertices are mapped to a texture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the right-hand side view, select the front face, and you can immediately
    see how that face is mapped to the texture:![How to do it...](img/1182OS_04_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can change the mapping of this face by moving the vertices on the left-hand
    side side of the screen. Before we do that, though, we first load a texture image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With your mouse on top of the left part of the screen, hit *Alt* + *O* to select
    an image. For this recipe, it is easiest to use the `debug.png` texture you can
    find in the `assets/textures` directory. Once you open the image, the screen will
    look like this:![How to do it...](img/1182OS_04_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By dragging the corners in the left view, we change the UV mapping of the selected
    face. Move these corners around to create something like this:![How to do it...](img/1182OS_04_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we changed the UV mapping for this face from the whole texture
    to just the top-left corner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is to export this geometry, load it in Three.js, and see whether
    the mapping has really changed for the face we changed. To export the model, we'll
    use the `OBJ` format in this recipe. So, navigate to **File** | **Export** | **Wavefront**
    and save the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To load the model, we first need to include the `OBJLoader` JavaScript file
    on the header of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the loader to load the model and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we explicitly set the texture we want to use, as we didn't
    use `OBJMTLLoader`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a final step, let's look at the result. We provided an example, `04.14-create-custom-uv-mapping.html`,
    that shows the result of these steps.![How to do it...](img/1182OS_04_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the front face for which we changed
    the UV mapping shows only part of the texture, while the other sides show the
    complete texture.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve only touched upon a very small part of how Blender can help in creating
    UV mappings. A good starting point to learn more about UV mapping in Blender are
    the following two sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics](http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/ Mapping/UV](http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/Mapping/UV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on how to integrate Three.js with Blender, you can have
    a look at the *Creating and exporting a model from Blender* recipe, from [Chapter
    2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and Meshes* where
    we show how to install the Three.js plugin for Blender and how you can load a
    model and its material directly in Three.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring blend modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object is rendered on top of another object in Three.js, you can configure
    how to blend in the colors from the objects behind it. In this recipe, we show
    you the steps you need to take to set a specific blend mode. You can compare this
    with the way the various blending layers in Photoshop work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding the results of a specific blend mode is difficult. To help in
    understanding the different available blend modes, we provide a simple web page
    that shows you the blend modes and allows you to switch between them. You can
    see this example by opening `04.13-configuring-blend-modes.html` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the menu in the top-right section of the preceding screenshot, you can
    see what the result of each blend mode is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting a blend mode is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a geometry and a material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the `blending` property to the blend mode you want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, set the `transparent` property to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can find an overview of the available, standard blend modes by looking
    at the Three.js sources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen, Three.js uses WebGL to render the scenes. The blend modes you
    define on the material for Three.js are used internally by WebGL to determine
    how to blend the background color with the foreground color.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the blend modes we''ve shown in this recipe, it is also possible to
    define your own custom blend modes. You can do this by setting the `blending`
    property to `THREE.CustomBlending`. Use these three material properties to define
    how the foreground is blended with the background: `blendSrc`, `blendDst`, and
    `blendEquation`. For `blendSrc`, you can use the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For `blendDst`, you can use these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `blendEquation`, WebGL supports the following set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: A very good example that shows many of these settings can be found on the Three.js
    examples site at [http://threejs.org/examples/#webgl_materials_blending_custom](http://threejs.org/examples/#webgl_materials_blending_custom).
  prefs: []
  type: TYPE_NORMAL
- en: Using a shadow map for fixed shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and
    Custom Shaders* we will show you a number of recipes that deal with lights and
    shadows. It is, however, also possible to fake shadows using a texture. This kind
    of texture is called a shadow map or a light map. In this recipe, we explain how
    you can use such a texture in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we first need a shadow map. There are different ways to create
    shadow maps, but that is outside the scope of this recipe. If you''re interested
    in creating your own shadow maps, you can follow this tutorial from the Blender
    site: [http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps](http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps).'
  prefs: []
  type: TYPE_NORMAL
- en: In the sources for this book, in the `assets/textures` folder, you can find
    a `shadow-map.png` file that we'll use in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding figure, you can see what a shadow map looks like. As you can
    see, a shadow map contains the shadows of a scene prerendered in the target geometry,
    in this case, a plane. If we use this image as a shadow map, we can easily view
    the following scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this scene, we use the shadow map to create shadows for the ground plane.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a shadow map is very easy. Before we look at the steps, make sure that
    you''ve got a geometry and a material. In the following steps, we have `THREE.Mesh`
    with the name floor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A UV mapping defines how a face maps to a specific part of a texture. The UV
    mapping in a geometry is stored in the `faceVertexUvs` property of a geometry.
    The first element of this array contains the UV mappings used for the other kinds
    of textures, and the second element contains the UV mapping for the shadow map.
    As this value isn''t filled by default, we point it to the first element in the
    `faceVertexUvs` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to set the shadow map to the `lightmap` property of the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you add the other textures you might want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all you need to do. This works great, especially when you've got scenes
    with static meshes and fixed lights, and this is a great boost to performance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you require dynamic shadows that update based on animated lighting or objects
    in the scene, you need something else (or in addition to) than shadow maps. In
    [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and Custom
    Shaders* in the *Creating shadows with Three.SpotLight* recipe, we explain how
    to create dynamic shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
