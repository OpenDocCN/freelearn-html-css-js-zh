- en: Mastering Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to work with functions. In this chapter,
    we will explore how we can use functions, together with some native APIs, to write
    asynchronous TypeScript code. We will focus on TypeScript''s asynchronous programming
    capabilities, including the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous functions (`async` and `await`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks and higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, functions can be passed as arguments to another function. Functions
    can also be returned by another function. A function passed to another as an argument
    is known as a **callback**. A function that accepts functions as parameters (callbacks)
    or returns functions is known as a **higher-order function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callback are usually anonymous functions. They can be declared before they
    are passed to the higher-order function, as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Callbacks can also be declared inline, at the same point in which they are
    passed to a higher-order function, as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declares an anonymous function and passes it to a
    function named `bar`. The anonymous function has been declared using an alternative
    syntax known as an arrow function. We will learn more about arrow functions in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, we can declare a function using a function expression or an arrow
    function. An arrow function expression has a shorter syntax than a function expression and
    lexically binds the value of the `this` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this` operator behaves a little differently in TypeScript and JavaScript
    compared to other popular programming languages. When we define a class in TypeScript,
    we can use the `this` operator to refer to the class. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a class named `Person` that contains a property of the `string`
    type called `name`. The class has a constructor and a method named `greet`. We
    have created an instance named `person` and invoked the `greet` method, which
    internally uses the `this` operator to access the `_name` property. Inside the
    `greet` method, the `this` operator points to the object that encloses the `greet`
    method (the class instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be careful when using the `this` operator because, in some scenarios,
    it can point to the wrong value. Let''s add an extra method to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `greetDelay` method, we perform an almost identical operation to the
    one performed by the `greet` method. This time, the function takes a parameter
    named `time`, which is used to delay the `greet` message.
  prefs: []
  type: TYPE_NORMAL
- en: To delay a message, we use the `setTimeout` function and a callback. As soon
    as we define an anonymous function (the callback), the `this` keyword changes
    its value and starts pointing to the anonymous function, which explains why the
    TypeScript compiler will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, an arrow function expression lexically binds the value of the
    `this` operator. This means that it allows us to add a function without altering
    the value of this operator. Let''s replace the function expression from the previous
    example with an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using an arrow function, we can ensure that the `this` operator still points
    to the `Person` instance and not to the `setTimeout` callback. If we execute the
    `greetDelay` function, the name property will be displayed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is generated by the TypeScript compiler. When compiling
    an arrow function, the TypeScript compiler will generate an alias for the `this`
    operator named `_this`. The alias is used to ensure that the `this` operator points
    to the correct object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will look in depth at the `this` operator in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml),
    *The Runtime – The Event Loop and* the this O*perator*.
  prefs: []
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that callbacks and higher-order functions are two powerful and
    flexible JavaScript and TypeScript features. However, the use of callbacks can
    lead to a maintainability issue known as callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to write an example to showcase callback hell. We are going
    to write three functions with the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function is named `doSomethingAsync`. The function takes an array
    of numbers as one of its arguments and adds a new number to it. The function uses
    `setTimeout` to simulate some I/O operation, such as reading from a database,
    and `Math.ramdom` to simulate a potential exception, such as a request timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function is named `doSomethingElseAsync`, and the third and final
    function is named `doSomethingMoreAsync`. We are going to skip the implementation
    of these two functions in the following code snippet because both functions have
    the exact same implementation that we used in the `doSomethingAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions simulate an asynchronous operation by using the `setTimeout`
    function. Each function takes a `success` callback, which is invoked if the operation
    is successful, and an `error` callback, which is invoked if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, asynchronous operations usually involve some interaction
    with hardware (for example, the filesystem, network…). These interactions are
    known as **input**/**output** (**I**/**O**) operations. I/O operations can fail
    for many different reasons; for example, we get an error when we try to interact
    with the filesystem to save a new file and there is not enough space available
    in the hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functions generate a random number and throw an error if the number
    is lower than `25`; we do this to simulate potential I/O errors. They then add
    the random number to an array that is passed as an argument to each of the functions.
    If no errors take place, the result of the final function (`doSomethingMoreAsync`)
    should be an array with three random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the three functions have been declared, we can try to invoke them
    in order. We are going to use callbacks to ensure that `doSomethingMoreAsync`
    is invoked after `doSomethingElseAsync`, and that `doSomethingElseAsync` is invoked
    after `doSomethingAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example used a few nesting callbacks. These kinds of nested callbacks
    are known as callback hell because they can lead to some maintainability issues,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They make the code harder to follow and understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make the code harder to maintain (refactor, reuse, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make exception handling more difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After seeing how the use of callbacks can lead to some maintainability problems,
    we are now going to learn about promises and how they can be used to write better
    asynchronous code. The core idea behind promises is that a promise represents
    the result of an asynchronous operation. A promise must be in one of the following
    three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: The initial state of a promise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled**: Also known as resolved, this the state of a promise representing
    a successful operation. The terms *fulfilled* and *resolved* are both commonly
    used to refer to this state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: The state of a promise representing a failed operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a promise is fulfilled or rejected, its state can never change again.
    Let''s look at the basic syntax of a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Please note that a `try…catch` statement is used here to showcase how we can
    explicitly fulfill or reject a promise. The `try…catch` statement is not needed
    for a `Promise` function because, when an error is thrown within a promise, the
    promise will automatically be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet declares a function named `foo` that returns a promise.
    The promise contains a method named `then`, which accepts a callback function
    as an argument. The callback function is invoked when the promise is fulfilled.
    Promises also provide a method named `catch`, which is invoked when a promise
    is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Promises will not be recognized by the TypeScript compiler if we are targeting
    ES5 because the `Promise` API is part of ES6\. We can solve this by enabling the
    `es2015.promise` type using the `lib` option in the `tsconfig.json` file. Note
    that enabling this option will disable some types that are included by default
    and thereby break some examples. You will be able to resolve the problems by including
    the `dom` and `es5` types as well by using the lib option in the `tsconfig.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to rewrite the `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync` functions, which we wrote in the *Callback hell* section,
    but this time, we are going to use promises instead of callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we are going to skip the implementation details of the `doSomethingElseAsync`
    and `doSomethingMoreAsync` functions because they should be identical to the implementation
    of the `doSomethingAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can chain the promises returned by each of the preceding functions using
    the `Promise` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is a little better than the one used in the callback
    example, because we only needed to declare one instead of three exception handlers.
    This is possible because errors are propagated through the chain of promises.
    However, we can improve the code even more because the `Promise` API allows us
    to chain promises in a much less verbose manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is much easier to read and follow than the one used during
    the callback examples, but this is not the only reason to favor promises over
    callbacks. Using promises also gives us better control over the execution flow
    of operations. Let's look at a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Promise` API includes a method named `all`, which allows us to execute
    a series of promises in parallel and get all the results of each of the promises
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Promise` API also includes a method named `race`, which allows us to execute
    a series of promises in parallel and obtain the result of the first promise resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use many different types of asynchronous flow control when working with
    promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrent**: The tasks are executed in parallel (as in the `Promise.all`
    example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Race**: The tasks are executed in parallel, and only the result of the fastest
    promise is returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: A group of tasks is executed in sequence, but the preceding tasks
    do not pass arguments to the next task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waterfall**: A group of tasks is executed in sequence, and each task passes
    arguments to the next task (as in the example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This is any combination of the previous concurrent, series,
    and waterfall approaches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariant checking in callback parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript 2.4 changed the way the type system behaves internally to improve
    error detection in nested callbacks and promises:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript's checking of callback parameters is now covariant in relation to
    immediate signature checks. Previously, it was bivariant and occasionally allowed
    incorrect types through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, this means that callback parameters and classes that contain callbacks
    are checked more carefully, so Typescript will require stricter types in this
    release. This is particularly true of promises and observables due to the way
    in which their APIs are specified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In TypeScript versions before 2.4, the following example was considered valid,
    and no errors were thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript versions following the 2.4 release, we will need to add the complete
    signature of `nestedCallback` to resolve this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the internal change in the TypeScript type system, the following
    error is also detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Before TypeScript 2.4, the preceding promise would have been inferred as `Promise<{}>`
    because we forgot to add the generic argument, `<number>`, when we created an
    instance of the `Promise` class. The string error would then have been considered
    a valid instance of `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is a clear example of why it is recommended you upgrade TypeScript
    regularly. Each new version of TypeScript introduces new features able to detect
    new errors for us.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we invoke a function in TypeScript, we can assume that, once the function
    starts running, it will always run to completion before any other code can run.
    However, one type of function known as a **generator** can may be paused in the
    middle of execution—once or many times—and resumed later, allowing other code
    to run during these paused periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator represents a sequence of values. The interface of a generator object
    is just an **iterator**. An iterator implements the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `next` function can be invoked until it runs out of values. We can define
    a generator by using the `function` keyword, followed by an asterisk, (`*`). The
    `yield` keyword is used to stop the execution of the function and return a value.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that some additional types are required by generators if you are targeting
    ES5\. You will need to add `es2015.generator` and `es2015.iterable`, and enable `downlevelIteration` to
    your `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding iterator has five steps. The first time we call
    the `next` method, the function will be executed until it reaches the first `yield`
    statement, and then it will return the value `1` and stop the execution of the
    function until we invoke the generator''s `next` method again. As we can see,
    we are now able to stop the function''s execution at a given point. This allows
    us to write infinite loops without causing a stack overflow exception, as demonstrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The generator's API opens up possibilities with reference to synchronicity,
    as we can call the generator's `next` method after an asynchronous event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions – async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous functions are a TypeScript feature that arrived with the TypeScript
    1.6 release. Developers can use the `await` keyword to wait for an asynchronous
    operation to be completed without blocking the normal execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous functions helps to increase the readability of a piece of
    code when compared with the use of promises or callbacks but, technically, we
    can achieve the same features using both promises and asynchronous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a basic `async`/`await` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declares a promise named `p`. This promise represents
    a future result. As we can see, the `fn` function is preceded by the `async` keyword,
    which is used to indicate to the compiler that it is an asynchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, the `await` keyword is used to suspend execution until
    the promise `p` is fulfilled or rejected. As we can see, the syntax is less verbose
    and cleaner than it would have been had we used the `Promise` API or callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous function, such as `fn`, returns a promise at runtime. This should
    explain why we need to use the `then` method at the end of the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet showcases how we can declare an asynchronous function
    named `invokeTaskAsync`. The asynchronous function uses the `await` keyword to
    wait for the result of the `doSomethingAsync`, `doSomethingElseAsync`, and `doSomethingMoreAsync`
    functions that we declared during the promises example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invokeTaskAsync` function is asynchronous. Therefore, it will return a
    promise at runtime. This means that we can use the `Promise` API to await a result
    or catch potential errors respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define asynchronous IIFE as a convenient way to use the `async`
    and `await` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an `async` IIFE is very useful because it is very common to not be able
    to use the `await` keyword outside a function, for example, in the entry point
    of an application. We can use the `async` IIFE to overcome this limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned about the interface implemented by all iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we haven''t learned yet about the interface implemented by all asynchronous
    iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An asynchronous iterator returns a promise every time we invoke the `next`
    method. The following code snippet demonstrates how asynchronous iterators can
    be very useful when used in conjunction with asynchronous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Some additional types are required by asynchronous iterators if we are targeting
    ES5\. You will need to add `esnext.asynciterable` and enable `downlevelIteration` in your
    `tsconfig.json` file. We are also going to need to enable an additional setting
    in our `tsconfig.json` to provide full support for iterables in `for-of`, spread,
    and destructuring when targeting ES5 or ES3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous iteration (for await…of)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the new `await…of` expression to iterate and await each of the promises
    returned by an asynchronous iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Delegating to another generator (yield*)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `yield*` expression to delegate from one generator to another.
    The following code snippet defines two generator functions, named `g1` and `g2`.
    The `g2` generator uses the `yield*` expression to delegate the iteration to the
    iterator created by `g1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `yield*` expression can also be used to delegate the iteration to some
    *iterables*, such as arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example requires a number of particular settings
    in the `tsconfig.json` file. Please refer to the preceding notes in this chapter
    to learn more about the required settings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have focused on the use of callbacks, promises, and generators
    to take advantage of the asynchronous programming capabilities of TypeScript.
    In the next chapter, we will look at the runtime to understand how the event loop
    and the `this` operator work. These concepts will help us to understand some of
    the implementations of functional programming techniques that we will explore
    later in this book.
  prefs: []
  type: TYPE_NORMAL
