- en: Mastering Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握异步编程
- en: 'In the previous chapter, we learned how to work with functions. In this chapter,
    we will explore how we can use functions, together with some native APIs, to write
    asynchronous TypeScript code. We will focus on TypeScript''s asynchronous programming
    capabilities, including the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理函数。在本章中，我们将探讨如何使用函数以及一些原生 API 来编写异步 TypeScript 代码。我们将重点关注 TypeScript
    的异步编程能力，包括以下概念：
- en: Callbacks and higher-order functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数和高级函数
- en: Arrow functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Callback hell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Promises
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises
- en: Generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Asynchronous functions (`async` and `await`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数（`async` 和 `await`）
- en: Callbacks and higher-order functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数和高级函数
- en: In TypeScript, functions can be passed as arguments to another function. Functions
    can also be returned by another function. A function passed to another as an argument
    is known as a **callback**. A function that accepts functions as parameters (callbacks)
    or returns functions is known as a **higher-order function**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，函数可以作为参数传递给另一个函数。函数也可以由另一个函数返回。将函数作为参数传递的函数称为 **回调**。接受函数作为参数（回调）或返回函数的函数称为
    **高级函数**。
- en: 'Callback are usually anonymous functions. They can be declared before they
    are passed to the higher-order function, as demonstrated by the following example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常是匿名函数。它们可以在传递给高级函数之前声明，如下面的例子所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Callbacks can also be declared inline, at the same point in which they are
    passed to a higher-order function, as demonstrated by the following example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回调也可以在行内声明，即在将它们传递给高级函数的同一位置，如下面的例子所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code snippet declares an anonymous function and passes it to a
    function named `bar`. The anonymous function has been declared using an alternative
    syntax known as an arrow function. We will learn more about arrow functions in
    the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段声明了一个匿名函数并将其传递给名为 `bar` 的函数。匿名函数是使用一种称为箭头函数的替代语法声明的。我们将在下一节中了解更多关于箭头函数的内容。
- en: Arrow functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: In TypeScript, we can declare a function using a function expression or an arrow
    function. An arrow function expression has a shorter syntax than a function expression and
    lexically binds the value of the `this` operator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以使用函数表达式或箭头函数声明一个函数。箭头函数表达式比函数表达式语法更短，并且按词法绑定 `this` 操作符的值。
- en: 'The `this` operator behaves a little differently in TypeScript and JavaScript
    compared to other popular programming languages. When we define a class in TypeScript,
    we can use the `this` operator to refer to the class. Let''s look at an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 和 JavaScript 中，`this` 操作符的行为与其他流行的编程语言略有不同。当我们使用 TypeScript 定义一个类时，我们可以使用
    `this` 操作符来引用该类。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have defined a class named `Person` that contains a property of the `string`
    type called `name`. The class has a constructor and a method named `greet`. We
    have created an instance named `person` and invoked the `greet` method, which
    internally uses the `this` operator to access the `_name` property. Inside the
    `greet` method, the `this` operator points to the object that encloses the `greet`
    method (the class instance).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Person` 的类，该类包含一个名为 `name` 的 `string` 类型属性。该类有一个构造函数和一个名为 `greet`
    的方法。我们创建了一个名为 `person` 的实例并调用了 `greet` 方法，该方法内部使用 `this` 操作符来访问 `_name` 属性。在 `greet`
    方法内部，`this` 操作符指向包含 `greet` 方法（类实例）的对象。
- en: 'We must be careful when using the `this` operator because, in some scenarios,
    it can point to the wrong value. Let''s add an extra method to the previous example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `this` 操作符时必须小心，因为在某些情况下，它可能指向错误值。让我们在之前的例子中添加一个额外的方法：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `greetDelay` method, we perform an almost identical operation to the
    one performed by the `greet` method. This time, the function takes a parameter
    named `time`, which is used to delay the `greet` message.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `greetDelay` 方法中，我们执行的操作几乎与 `greet` 方法执行的操作相同。这次，函数接受一个名为 `time` 的参数，该参数用于延迟
    `greet` 消息。
- en: To delay a message, we use the `setTimeout` function and a callback. As soon
    as we define an anonymous function (the callback), the `this` keyword changes
    its value and starts pointing to the anonymous function, which explains why the
    TypeScript compiler will throw an error.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要延迟消息，我们使用 `setTimeout` 函数和回调。一旦我们定义了一个匿名函数（回调），`this` 关键字就会改变其值并开始指向匿名函数，这也解释了为什么
    TypeScript 编译器会抛出错误。
- en: 'As mentioned, an arrow function expression lexically binds the value of the
    `this` operator. This means that it allows us to add a function without altering
    the value of this operator. Let''s replace the function expression from the previous
    example with an arrow function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，箭头函数表达式词法绑定 `this` 操作符的值。这意味着它允许我们添加一个函数而不改变该操作符的值。让我们将前一个示例中的函数表达式替换为箭头函数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using an arrow function, we can ensure that the `this` operator still points
    to the `Person` instance and not to the `setTimeout` callback. If we execute the
    `greetDelay` function, the name property will be displayed as expected.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用箭头函数，我们可以确保 `this` 操作符仍然指向 `Person` 实例，而不是 `setTimeout` 回调。如果我们执行 `greetDelay`
    函数，名称属性将显示为预期的那样。
- en: 'The following piece of code is generated by the TypeScript compiler. When compiling
    an arrow function, the TypeScript compiler will generate an alias for the `this`
    operator named `_this`. The alias is used to ensure that the `this` operator points
    to the correct object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是由 TypeScript 编译器生成的。当编译一个箭头函数时，TypeScript 编译器将为 `this` 操作符生成一个名为 `_this`
    的别名。这个别名用于确保 `this` 操作符指向正确的对象：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will look in depth at the `this` operator in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml),
    *The Runtime – The Event Loop and* the this O*perator*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [《运行时 – 事件循环和 this 操作符》](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)
    中深入探讨 `this` 操作符，*运行时 – 事件循环和 this 操作符*。
- en: Callback hell
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调地狱
- en: We have learned that callbacks and higher-order functions are two powerful and
    flexible JavaScript and TypeScript features. However, the use of callbacks can
    lead to a maintainability issue known as callback hell.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到回调函数和高级函数是 JavaScript 和 TypeScript 中的两个强大且灵活的特性。然而，回调函数的使用可能会导致一个称为回调地狱的可维护性问题。
- en: We are now going to write an example to showcase callback hell. We are going
    to write three functions with the same behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个示例来展示回调地狱。我们将编写三个具有相同行为的函数。
- en: 'The first function is named `doSomethingAsync`. The function takes an array
    of numbers as one of its arguments and adds a new number to it. The function uses
    `setTimeout` to simulate some I/O operation, such as reading from a database,
    and `Math.ramdom` to simulate a potential exception, such as a request timeout:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数被命名为 `doSomethingAsync`。该函数接受一个数字数组作为其参数之一，并向其中添加一个新数字。该函数使用 `setTimeout`
    来模拟一些 I/O 操作，例如从数据库读取，以及使用 `Math.random` 来模拟潜在的异常，例如请求超时：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second function is named `doSomethingElseAsync`, and the third and final
    function is named `doSomethingMoreAsync`. We are going to skip the implementation
    of these two functions in the following code snippet because both functions have
    the exact same implementation that we used in the `doSomethingAsync` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数被命名为 `doSomethingElseAsync`，第三个也是最后一个函数被命名为 `doSomethingMoreAsync`。我们将在以下代码片段中跳过这两个函数的实现，因为这两个函数与我们在
    `doSomethingAsync` 函数中使用的实现完全相同：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding functions simulate an asynchronous operation by using the `setTimeout`
    function. Each function takes a `success` callback, which is invoked if the operation
    is successful, and an `error` callback, which is invoked if something goes wrong.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数通过使用 `setTimeout` 函数来模拟异步操作。每个函数都接受一个 `success` 回调，如果操作成功则调用该回调，以及一个 `error`
    回调，如果发生错误则调用该回调。
- en: In real-world applications, asynchronous operations usually involve some interaction
    with hardware (for example, the filesystem, network…). These interactions are
    known as **input**/**output** (**I**/**O**) operations. I/O operations can fail
    for many different reasons; for example, we get an error when we try to interact
    with the filesystem to save a new file and there is not enough space available
    in the hard disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，异步操作通常涉及与硬件的交互（例如，文件系统、网络等）。这些交互被称为 **输入**/**输出** （**I**/**O**）操作。I/O
    操作可能因许多不同的原因而失败；例如，当我们尝试与文件系统交互以保存新文件时，硬盘上没有足够的空间，我们会得到一个错误。
- en: The preceding functions generate a random number and throw an error if the number
    is lower than `25`; we do this to simulate potential I/O errors. They then add
    the random number to an array that is passed as an argument to each of the functions.
    If no errors take place, the result of the final function (`doSomethingMoreAsync`)
    should be an array with three random numbers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数生成一个随机数，如果该数字小于 `25`，则抛出错误；我们这样做是为了模拟潜在的 I/O 错误。然后，它们将随机数添加到作为每个函数参数传递的数组中。如果没有发生错误，最终函数（`doSomethingMoreAsync`）的结果应该是一个包含三个随机数的数组。
- en: 'Now that the three functions have been declared, we can try to invoke them
    in order. We are going to use callbacks to ensure that `doSomethingMoreAsync`
    is invoked after `doSomethingElseAsync`, and that `doSomethingElseAsync` is invoked
    after `doSomethingAsync`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经声明了三个函数，我们可以尝试按顺序调用它们。我们将使用回调函数来确保在`doSomethingElseAsync`之后调用`doSomethingMoreAsync`，并且在`doSomethingAsync`之后调用`doSomethingElseAsync`：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding example used a few nesting callbacks. These kinds of nested callbacks
    are known as callback hell because they can lead to some maintainability issues,
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用了几个嵌套的回调函数。这类嵌套回调函数被称为回调地狱，因为它们可能导致一些可维护性问题，如下所示：
- en: They make the code harder to follow and understand
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使代码更难以跟踪和理解
- en: They make the code harder to maintain (refactor, reuse, and so on)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使代码更难以维护（重构、重用等）
- en: They make exception handling more difficult
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使异常处理更困难
- en: Promises
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: 'After seeing how the use of callbacks can lead to some maintainability problems,
    we are now going to learn about promises and how they can be used to write better
    asynchronous code. The core idea behind promises is that a promise represents
    the result of an asynchronous operation. A promise must be in one of the following
    three states:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到回调的使用可能导致一些可维护性问题之后，我们现在将学习关于承诺以及如何使用它们来编写更好的异步代码。承诺背后的核心思想是，承诺表示异步操作的结果。承诺必须处于以下三种状态之一：
- en: '**Pending**: The initial state of a promise.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：承诺的初始状态。'
- en: '**Fulfilled**: Also known as resolved, this the state of a promise representing
    a successful operation. The terms *fulfilled* and *resolved* are both commonly
    used to refer to this state.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：也称为已解决，这是表示成功操作的承诺的状态。术语*实现*和*已解决*都常用来指代此状态。'
- en: '**Rejected**: The state of a promise representing a failed operation.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已拒绝**：表示操作失败的承诺的状态。'
- en: 'Once a promise is fulfilled or rejected, its state can never change again.
    Let''s look at the basic syntax of a promise:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦承诺被实现或拒绝，其状态将无法再改变。让我们看看承诺的基本语法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please note that a `try…catch` statement is used here to showcase how we can
    explicitly fulfill or reject a promise. The `try…catch` statement is not needed
    for a `Promise` function because, when an error is thrown within a promise, the
    promise will automatically be rejected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用`try…catch`语句来展示如何显式实现或拒绝承诺。对于`Promise`函数，不需要`try…catch`语句，因为当在承诺内部抛出错误时，承诺将自动被拒绝。
- en: The preceding code snippet declares a function named `foo` that returns a promise.
    The promise contains a method named `then`, which accepts a callback function
    as an argument. The callback function is invoked when the promise is fulfilled.
    Promises also provide a method named `catch`, which is invoked when a promise
    is rejected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为`foo`的函数，它返回一个承诺。这个承诺包含一个名为`then`的方法，该方法接受一个回调函数作为参数。当承诺被实现时，将调用回调函数。承诺还提供了一个名为`catch`的方法，当承诺被拒绝时调用。
- en: 'Promises will not be recognized by the TypeScript compiler if we are targeting
    ES5 because the `Promise` API is part of ES6\. We can solve this by enabling the
    `es2015.promise` type using the `lib` option in the `tsconfig.json` file. Note
    that enabling this option will disable some types that are included by default
    and thereby break some examples. You will be able to resolve the problems by including
    the `dom` and `es5` types as well by using the lib option in the `tsconfig.json`
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们针对ES5，TypeScript编译器将不会识别承诺，因为`Promise` API是ES6的一部分。我们可以通过在`tsconfig.json`文件中使用`lib`选项启用`es2015.promise`类型来解决此问题。请注意，启用此选项将禁用默认包含的一些类型，从而破坏一些示例。您可以通过在`tsconfig.json`文件中使用`lib`选项包括`dom`和`es5`类型来解决这些问题：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are now going to rewrite the `doSomethingAsync`, `doSomethingElseAsync`,
    and `doSomethingMoreAsync` functions, which we wrote in the *Callback hell* section,
    but this time, we are going to use promises instead of callbacks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重写我们在*回调地狱*部分编写的`doSomethingAsync`、`doSomethingElseAsync`和`doSomethingMoreAsync`函数，但这次我们将使用承诺而不是回调：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once again, we are going to skip the implementation details of the `doSomethingElseAsync`
    and `doSomethingMoreAsync` functions because they should be identical to the implementation
    of the `doSomethingAsync` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将跳过`doSomethingElseAsync`和`doSomethingMoreAsync`函数的实现细节，因为它们应该与`doSomethingAsync`函数的实现相同：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can chain the promises returned by each of the preceding functions using
    the `Promise` API:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Promise` API 将每个先前函数返回的承诺链式连接起来：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code snippet is a little better than the one used in the callback
    example, because we only needed to declare one instead of three exception handlers.
    This is possible because errors are propagated through the chain of promises.
    However, we can improve the code even more because the `Promise` API allows us
    to chain promises in a much less verbose manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段比回调示例中使用的代码略好，因为我们只需要声明一个而不是三个异常处理程序。这是可能的，因为错误是通过承诺链传播的。然而，我们可以进一步改进代码，因为
    `Promise` API 允许我们以更简洁的方式链式连接承诺：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is much easier to read and follow than the one used during
    the callback examples, but this is not the only reason to favor promises over
    callbacks. Using promises also gives us better control over the execution flow
    of operations. Let's look at a couple of examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比回调示例中使用的代码更容易阅读和跟踪，但这并不是唯一青睐承诺而不是回调的原因。使用承诺也让我们能够更好地控制操作的执行流程。让我们看看几个例子。
- en: 'The `Promise` API includes a method named `all`, which allows us to execute
    a series of promises in parallel and get all the results of each of the promises
    at once:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` API 包含一个名为 `all` 的方法，它允许我们并行执行一系列承诺，并一次性获取每个承诺的所有结果：'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Promise` API also includes a method named `race`, which allows us to execute
    a series of promises in parallel and obtain the result of the first promise resolved:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` API 还包含一个名为 `race` 的方法，它允许我们并行执行一系列承诺，并获取第一个解决的承诺的结果：'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use many different types of asynchronous flow control when working with
    promises:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当与承诺一起工作时，我们可以使用许多不同类型的异步流程控制：
- en: '**Concurrent**: The tasks are executed in parallel (as in the `Promise.all`
    example)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**: 任务并行执行（如 `Promise.all` 示例所示）'
- en: '**Race**: The tasks are executed in parallel, and only the result of the fastest
    promise is returned'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞速**: 任务并行执行，只返回最快承诺的结果'
- en: '**Series**: A group of tasks is executed in sequence, but the preceding tasks
    do not pass arguments to the next task'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串联**: 一组任务按顺序执行，但前面的任务不会将参数传递给下一个任务'
- en: '**Waterfall**: A group of tasks is executed in sequence, and each task passes
    arguments to the next task (as in the example)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瀑布**: 一组任务按顺序执行，每个任务将参数传递给下一个任务（如示例所示）'
- en: '**Composite**: This is any combination of the previous concurrent, series,
    and waterfall approaches'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合**: 这是指之前并发、串联和瀑布方法的任何组合'
- en: Covariant checking in callback parameters
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调参数中的协变检查
- en: 'TypeScript 2.4 changed the way the type system behaves internally to improve
    error detection in nested callbacks and promises:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 2.4 改变了类型系统内部的行为方式，以改善嵌套回调和承诺的错误检测：
- en: TypeScript's checking of callback parameters is now covariant in relation to
    immediate signature checks. Previously, it was bivariant and occasionally allowed
    incorrect types through.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 对回调参数的检查现在与即时签名检查是协变的。之前它是双变的，偶尔会允许错误类型通过。
- en: Basically, this means that callback parameters and classes that contain callbacks
    are checked more carefully, so Typescript will require stricter types in this
    release. This is particularly true of promises and observables due to the way
    in which their APIs are specified.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上，这意味着回调参数和包含回调的类将受到更仔细的检查，因此TypeScript在这个版本中将需要更严格的类型。这尤其适用于承诺和观察者，因为它们的API指定方式。
- en: 'In TypeScript versions before 2.4, the following example was considered valid,
    and no errors were thrown:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 2.4 版本之前的 TypeScript 中，以下示例被认为是有效的，并且没有抛出错误：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In TypeScript versions following the 2.4 release, we will need to add the complete
    signature of `nestedCallback` to resolve this error:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 2.4 版本之后的 TypeScript 中，我们将需要添加 `nestedCallback` 的完整签名来解决此错误：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thanks to the internal change in the TypeScript type system, the following
    error is also detected:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 TypeScript 类型系统的内部变化，以下错误也被检测到：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before TypeScript 2.4, the preceding promise would have been inferred as `Promise<{}>`
    because we forgot to add the generic argument, `<number>`, when we created an
    instance of the `Promise` class. The string error would then have been considered
    a valid instance of `{}`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 2.4 之前，上述承诺会被推断为 `Promise<{}>`，因为我们创建 `Promise` 类实例时忘记添加泛型参数 `<number>`。字符串错误随后会被视为
    `{}` 的有效实例。
- en: The preceding is a clear example of why it is recommended you upgrade TypeScript
    regularly. Each new version of TypeScript introduces new features able to detect
    new errors for us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这前面的例子清楚地说明了为什么建议您定期升级TypeScript。TypeScript的每个新版本都引入了新的功能，能够为我们检测到新的错误。
- en: Generators
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: If we invoke a function in TypeScript, we can assume that, once the function
    starts running, it will always run to completion before any other code can run.
    However, one type of function known as a **generator** can may be paused in the
    middle of execution—once or many times—and resumed later, allowing other code
    to run during these paused periods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在TypeScript中调用一个函数，我们可以假设一旦函数开始运行，它将始终运行到完成，然后任何其他代码才能运行。然而，一种称为**生成器**的函数类型可以在执行过程中暂停——一次或多次——并在稍后恢复，允许在这些暂停期间运行其他代码。
- en: 'A generator represents a sequence of values. The interface of a generator object
    is just an **iterator**. An iterator implements the following interface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器代表一系列值。生成器对象的接口只是一个**迭代器**。迭代器实现了以下接口：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `next` function can be invoked until it runs out of values. We can define
    a generator by using the `function` keyword, followed by an asterisk, (`*`). The
    `yield` keyword is used to stop the execution of the function and return a value.
    Let''s look at an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`函数可以被调用，直到它耗尽值。我们可以通过使用`function`关键字，后跟一个星号（`*`），来定义一个生成器。`yield`关键字用于停止函数的执行并返回一个值。让我们看一个例子：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that some additional types are required by generators if you are targeting
    ES5\. You will need to add `es2015.generator` and `es2015.iterable`, and enable `downlevelIteration` to
    your `tsconfig.json` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您针对ES5，生成器需要一些额外的类型。您需要在`tsconfig.json`文件中添加`es2015.generator`和`es2015.iterable`，并启用`downlevelIteration`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can see, the preceding iterator has five steps. The first time we call
    the `next` method, the function will be executed until it reaches the first `yield`
    statement, and then it will return the value `1` and stop the execution of the
    function until we invoke the generator''s `next` method again. As we can see,
    we are now able to stop the function''s execution at a given point. This allows
    us to write infinite loops without causing a stack overflow exception, as demonstrated
    in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，前面的迭代器有五个步骤。第一次我们调用`next`方法时，函数将执行，直到它达到第一个`yield`语句，然后它将返回值`1`并停止函数的执行，直到我们再次调用生成器的`next`方法。正如我们所见，我们现在能够在一个给定的点上停止函数的执行。这允许我们编写无限循环而不会导致堆栈溢出异常，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generator's API opens up possibilities with reference to synchronicity,
    as we can call the generator's `next` method after an asynchronous event has occurred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的API通过同步性打开了可能性，因为异步事件发生后，我们可以调用生成器的`next`方法。
- en: Asynchronous functions – async and await
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数 – async 和 await
- en: Asynchronous functions are a TypeScript feature that arrived with the TypeScript
    1.6 release. Developers can use the `await` keyword to wait for an asynchronous
    operation to be completed without blocking the normal execution of the program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数是TypeScript 1.6版本中引入的功能。开发者可以使用`await`关键字等待异步操作完成，而不会阻塞程序的正常执行。
- en: Using asynchronous functions helps to increase the readability of a piece of
    code when compared with the use of promises or callbacks but, technically, we
    can achieve the same features using both promises and asynchronous functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步函数可以帮助提高代码的可读性，与使用承诺或回调相比，但技术上，我们可以使用两者都实现相同的功能。
- en: 'Let''s take a look at a basic `async`/`await` example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的`async`/`await`示例：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code snippet declares a promise named `p`. This promise represents
    a future result. As we can see, the `fn` function is preceded by the `async` keyword,
    which is used to indicate to the compiler that it is an asynchronous function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为`p`的承诺。这个承诺代表一个未来的结果。正如我们所见，`fn`函数前面有`async`关键字，它用于指示编译器这是一个异步函数。
- en: Inside the function, the `await` keyword is used to suspend execution until
    the promise `p` is fulfilled or rejected. As we can see, the syntax is less verbose
    and cleaner than it would have been had we used the `Promise` API or callbacks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`await`关键字用于暂停执行，直到承诺`p`得到解决或拒绝。正如我们所见，语法比使用`Promise` API或回调要简洁得多。
- en: An asynchronous function, such as `fn`, returns a promise at runtime. This should
    explain why we need to use the `then` method at the end of the code snippet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异步函数，如 `fn`，在运行时会返回一个承诺。这应该解释了为什么我们需要在代码片段的末尾使用 `then` 方法的原因。
- en: 'The following code snippet showcases how we can declare an asynchronous function
    named `invokeTaskAsync`. The asynchronous function uses the `await` keyword to
    wait for the result of the `doSomethingAsync`, `doSomethingElseAsync`, and `doSomethingMoreAsync`
    functions that we declared during the promises example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何声明一个名为 `invokeTaskAsync` 的异步函数。这个异步函数使用 `await` 关键字等待我们在承诺示例中声明的
    `doSomethingAsync`、`doSomethingElseAsync` 和 `doSomethingMoreAsync` 函数的结果：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `invokeTaskAsync` function is asynchronous. Therefore, it will return a
    promise at runtime. This means that we can use the `Promise` API to await a result
    or catch potential errors respectively:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeTaskAsync` 函数是异步的。因此，它在运行时会返回一个承诺。这意味着我们可以使用 `Promise` API 来等待结果或捕获潜在的错误：'
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also define asynchronous IIFE as a convenient way to use the `async`
    and `await` keywords:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将异步 IIFE 定义为使用 `async` 和 `await` 关键字的便捷方式：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using an `async` IIFE is very useful because it is very common to not be able
    to use the `await` keyword outside a function, for example, in the entry point
    of an application. We can use the `async` IIFE to overcome this limitation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` IIFE 非常有用，因为通常无法在函数外部使用 `await` 关键字，例如，在应用程序的入口点。我们可以使用 `async` IIFE
    来克服这种限制：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Asynchronous generators
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步生成器
- en: 'We have already learned about the interface implemented by all iterators:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了所有迭代器实现的接口：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, we haven''t learned yet about the interface implemented by all asynchronous
    iterators:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有学习所有异步迭代器实现的接口：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An asynchronous iterator returns a promise every time we invoke the `next`
    method. The following code snippet demonstrates how asynchronous iterators can
    be very useful when used in conjunction with asynchronous functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用 `next` 方法时，异步迭代器都会返回一个承诺。以下代码片段展示了异步迭代器如何与异步函数结合使用，从而变得非常有用：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some additional types are required by asynchronous iterators if we are targeting
    ES5\. You will need to add `esnext.asynciterable` and enable `downlevelIteration` in your
    `tsconfig.json` file. We are also going to need to enable an additional setting
    in our `tsconfig.json` to provide full support for iterables in `for-of`, spread,
    and destructuring when targeting ES5 or ES3:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们针对 ES5，异步迭代器需要一些额外的类型。您需要在 `tsconfig.json` 文件中添加 `esnext.asynciterable`
    并启用 `downlevelIteration`。我们还需要在 `tsconfig.json` 中启用一个额外的设置，以在针对 ES5 或 ES3 时提供对
    `for-of`、展开和结构赋值的完整支持：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Asynchronous iteration (for await…of)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步迭代（for await…of）
- en: 'We can use the new `await…of` expression to iterate and await each of the promises
    returned by an asynchronous iterator:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新的 `await…of` 表达式来迭代并等待异步迭代器返回的每个承诺：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Delegating to another generator (yield*)
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将迭代委托给另一个生成器（yield*）
- en: 'We can use the `yield*` expression to delegate from one generator to another.
    The following code snippet defines two generator functions, named `g1` and `g2`.
    The `g2` generator uses the `yield*` expression to delegate the iteration to the
    iterator created by `g1`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `yield*` 表达式将一个生成器委托给另一个生成器。以下代码片段定义了两个生成器函数，分别命名为 `g1` 和 `g2`。`g2` 生成器使用
    `yield*` 表达式将迭代委托给由 `g1` 创建的迭代器：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `yield*` expression can also be used to delegate the iteration to some
    *iterables*, such as arrays:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield*` 表达式也可以用来将迭代委托给某些可迭代对象，例如数组：'
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note that the preceding example requires a number of particular settings
    in the `tsconfig.json` file. Please refer to the preceding notes in this chapter
    to learn more about the required settings.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例需要在 `tsconfig.json` 文件中设置一系列特定的设置。请参考本章前面的说明，了解更多关于所需设置的信息。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have focused on the use of callbacks, promises, and generators
    to take advantage of the asynchronous programming capabilities of TypeScript.
    In the next chapter, we will look at the runtime to understand how the event loop
    and the `this` operator work. These concepts will help us to understand some of
    the implementations of functional programming techniques that we will explore
    later in this book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于使用回调、承诺和生成器来利用 TypeScript 的异步编程能力。在下一章中，我们将探讨运行时，了解事件循环和 `this` 操作符的工作原理。这些概念将帮助我们理解本书后面将要探索的一些函数式编程技术的实现。
