<html><head></head><body>
        

                            
                    <h1 class="header-title">Building with Modules</h1>
                
            
            
                
<p class="mce-root"> In this chapter, we will cover the following recipes:</p>
<ul>
<li>Installing and configuring browsers—Chrome and Firefox</li>
<li>Installing Python, using SimpleHTTPServer to host a local static file server</li>
<li>Creating an HTML page that loads an ECMAScript module</li>
<li>Exporting/importing multiple modules for external use</li>
<li>Renaming imported modules</li>
<li>Nesting modules under a single namespace</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>JavaScript is the most famous language that adheres to the ECMAScript standard. This standard was created in the late 1990s in order to guide the development of the language. In the early years, development was slow, with only four major versions reaching production in the first two decades. However, with increased exposure, largely thanks to the popularization of the Node.js run-time, the pace of development has increased dramatically. The years 2015, 2016, and 2017 each saw new releases of the of the standard, with another planned for 2018.</p>
<p>With all these developments, now is an exciting time to be a JavaScript developer. A lot of new ideas are coming in from other languages, and the standard API is expanding to be more helpful. This book focuses on new features and techniques that can be used in the newer versions of JS as well as future versions!</p>
<p>Historically, creating JavaScript programs that span multiple files has been a painful experience. The simplest approach was to include each of the files in separate <kbd>&lt;script&gt;</kbd> tags. This also requires developers to position the tags in the correct order.</p>
<p>Various libraries have attempted to improve this situation. RequireJS, Browserfy, and Webpack all attempt to solve the problem of JavaScript dependencies and module loading. Each of these requires some kind of configuration or build step.</p>
<p>The situation has improved in recent years. Browser manufacturers collaborate in creating the ECMAScript specification. It is then up to the manufacturers to implement JavaScript interpreters (programs that actually run the JavaScript) that adhere to that specification</p>
<p>New versions of browsers are being released that support native ECMAScript modules. ECMAScript modules provide an elegant method for including dependencies. Best of all, unlike the previous methods, modules don't require any build step or configuration.</p>
<p>The recipes in this chapter focus on installing and configuring the Chrome and Firefox  web browsers and how to take full advantage of ES modules and the import/export syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing and configuring - Chrome</h1>
                
            
            
                
<p>Subsequent recipes will assume an environment that is capable of using ES modules. There are two strategies for accomplishing this: creating a build step that collects all the modules used into a single file for the browser to download, or using a browser that is capable of using ES modules. This recipe demonstrates the latter option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To step through this recipe, you need a computer with an operating system (OS) that is supported by Chrome (not Chromium). It supports recent versions of Windows and macOS, as well as a large number of Linux distributions. Most likely, if your OS doesn't support this browser, you are already aware of this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To download Chrome, navigate your browser to the following:<br/>
<a href="https://www.google.co.in/chrome/">https://www.google.co.in/chrome/</a>.</li>
<li>Click Download and accept the terms of service.</li>
<li>After the installer finishes downloading, double-click the installer to launch it and follow the onscreen instructions.</li>
</ol>
<ol start="4">
<li>To check the version of Chrome, open the Chrome browser, and enter the following URL:  <br/>
<kbd>chrome://settings/help</kbd>.</li>
<li>You should see the Version number where the number is 61 or higher. See the following screenshot:</li>
</ol>
<div><img src="img/7b15a0ae-f6f6-4db2-8cb8-e2e77dafda50.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The current versions of Chrome come with ES modules enabled out of the box. So no configuration or plugins are required to get them working!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>At the time of writing, only a few browsers support ECMAScript. You can see which browsers support modules under the Browser compatibility section of the page at <a href="https://mzl.la/1PY7nnm">https://mzl.la/1PY7nnm.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing and configuring - Firefox</h1>
                
            
            
                
<p>Subsequent recipes will assume an environment that is capable of using ES modules. There are two strategies for accomplishing this: creating a build step that collects all the modules used into a single file for the browser to download, or using a browser that is capable of using ES modules. This recipe demonstrates the latter option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To step through this recipe, you need a computer with an operating system (OS) that is supported by Firefox. It supports recent versions of Windows and macOS, as well as a large number of Linux distributions. Most likely, if your OS doesn't support Firefox, you are already aware of this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To install Firefox, open a browser and enter the following URL:<br/>
<kbd>https://www.mozilla.org/firefox</kbd>.</li>
<li>Click the button that says Download to download the installer.</li>
<li>After the installer has finished downloading, double click the installer and follow the onscreen instructions.</li>
<li>To configure Firefox, open the Firefox browser and enter the following URL: <br/>
<kbd>about:config</kbd>.</li>
<li>The menu will allow you to enable advanced and experimental features. If you see a warning, click the button that says I accept the risk!</li>
<li>Find the dom.moduleScripts.enabled setting, and double-click it to set the value to true<strong>,</strong> as shown in following screenshot:</li>
</ol>
<div><img src="img/e92323cd-a98f-4724-be81-b6271d10df52.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Firefox supports ES modules, but disables them by default. This allows developers to experiment with the feature, while the majority of users are not exposed to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The same as the <em>Installing and configuring - Chrome</em> section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Python, using SimpleHTTPServer to host a local static file server</h1>
                
            
            
                
<p>It is possible to browse web pages directly from the filesystem. However, Chrome and Firefox have security features that make this inconvenient for development. What we need is a simple static file server. This recipe demonstrates how to install Python (if necessary) and use it to serve files from a directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Find out how to open the command line on your OS. On macOS and Linux, this is called the Terminal. On Windows, it is called the Command Prompt.</p>
<p>You should use a browser that is configured to load ES modules (see the first recipe).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Check whether you have Python installed already.</li>
<li>Open the command line.</li>
<li class="mce-root">Enter the following command:<br/></li>
</ol>
<pre style="padding-left: 60px"><strong>python --version</strong></pre>
<ol start="4">
<li>If you see an output like the one displayed as follows, Python is already installed. And you can skip to <em>step 6</em>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">Python 2.7.10</pre>
<ol start="5">
<li>If you receive an error such as the following, continue with the installation in <em>step 5</em>:</li>
</ol>
<pre style="padding-left: 60px"><strong>command not found: python</strong></pre>
<ol start="6">
<li>Install Python on your computer:
<ul>
<li>For macOS, download and run the installer for the latest version of Python 2 or 3 from the following link: <a href="https://www.python.org/downloads/mac-osx/">https://www.python.org/downloads/mac-osx/</a></li>
<li>For Windows, download and run the installer for the latest version of Python 2 or 3 from the following link: <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></li>
<li> For Linux, use the operating system's built in the package manager to install the Python package</li>
</ul>
</li>
<li>Create a folder on your desktop named <kbd>es8-cookbook-workspace</kbd>.</li>
<li>Inside the folder, create a text file named <kbd>hello.txt</kbd> and save some text to it.</li>
<li>Open the Command Prompt and navigate to the folder:</li>
<li> In the Linux or macOS Terminal enter:</li>
</ol>
<pre style="padding-left: 30px">    <strong>cd ~/Desktop/es8-cookbook-workspace</strong></pre>
<ol start="11">
<li>On Windows type the following command:</li>
</ol>
<pre style="padding-left: 30px">    <strong>cd C:Desktopes8-cookbook-workspace</strong> </pre>
<ol start="12">
<li>Start the Python HTTP server with the following command:</li>
</ol>
<pre style="padding-left: 30px">    <strong>python -m SimpleHTTPServer # python 2</strong> </pre>
<p style="padding-left: 60px">Or we can use following command:</p>
<pre style="padding-left: 60px"><strong>python -m http.server # python 3</strong></pre>
<ol start="13">
<li>Open your browser and enter the following URL:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="14">
<li>You should see a page that shows the contents of the <kbd>es8-cookbook-workspace</kbd> folder:</li>
</ol>
<div><img src="img/a983f629-b47b-4cdb-b94b-4e6908163069.png"/></div>
<ol start="15">
<li>Click on the link to hello.txt and you'll see the text contents of the file you created.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first thing we did was check if Python was installed. The best way to do this is to ask Python for its version number. This way we know whether Python is installed, and if it's new enough for our purposes.</p>
<p>If it's not installed, Python can be retrieved via the OS's package manager, or via the installers made available through Python's website.</p>
<p>Once installed, Python comes with a lot of utilities. The one we are interested in is the appropriately named <kbd>SimpleHTTPServer</kbd>. This utility listens for HTTP requests on port <kbd>8000</kbd>, and returns the contents of the files relative to the directory root. If the path points to a directory, it returns an HTML page that lists the directory contents.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an HTML page that loads an ECMAScript module</h1>
                
            
            
                
<p>In previous recipes, we went over installation and configurations instructions to run a static file server using Python and configure a browser to use ES modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have the static file server running in your working directory. If you haven't installed Python or configured your browser to work with ES modules, please see the first two recipes in the book.</p>
<p>The following steps will demonstrate how to create an ES module and load it into an HTML file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create an <kbd>hello.html</kbd> file with a some text content:</li>
</ol>
<pre style="padding-left: 60px">&lt;html&gt;<br/> &lt;meta charset="UTF-8" /&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>  Open Your Console!<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<ol start="2">
<li>Open <kbd>hello.html</kbd> by opening your browser, and entering the following URL: <kbd> http://localhost:8000/hello.html</kbd>.</li>
</ol>
<ol start="3">
<li>You should see Open Your Console! displayed by the browser:</li>
</ol>
<div><img src="img/57a7992c-da30-4b82-8b7a-341c30c4e717.png"/><br/></div>
<ol start="4">
<li>Lets do what the page tells us and open up the Developer Console. For both Firefox and Chrome, the command is the same:<br/>
<ul>
<li>On Windows and Linux:</li>
</ul>
</li>
</ol>
<pre style="padding-left: 120px"><strong>Ctrl + Shift + I</strong> </pre>
<ul>
<li style="padding-left: 60px">On macOS:</li>
</ul>
<pre style="padding-left: 120px"><strong>Cmd + Shift + I</strong>  </pre>
<ol start="5">
<li>Next, in the same directory, create a file called <kbd>hello.js</kbd>, which exports a function named <kbd>sayHi</kbd> that writes a message to the console:</li>
</ol>
<pre style="padding-left: 60px">// hello.js 
export function sayHi () { 
  console.log('Hello, World'); 
} </pre>
<ol start="6">
<li>Next add a script module tag to the head of <kbd>hello.html</kbd> that imports the <kbd>sayHi</kbd> method from <kbd>hello.js</kbd> (pay attention to the type value).</li>
</ol>
<ol start="7">
<li>Reload the browser window with the Developer Console open and you should see the <kbd>hello</kbd> message displayed as text:</li>
</ol>
<div><img src="img/2e2413b0-c7b4-415e-a8c9-18314f5ee757.png" style="width:35.58em;height:21.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Although our browser can work with ES modules, we still need to specify that is how we want our code to be loaded. The older way of including script files uses <kbd>type="text/javascript"</kbd>. This tells the browser to execute the content of the tag immediately (either from tag contents or from the <kbd>src</kbd> attribute).</p>
<p>By specifying <kbd>type="module"</kbd>, we are telling the browser that this tag is an ES module. The code within this tag can import members from other modules. We imported the function <kbd>sayHi</kbd> from the <kbd>hello</kbd> module and executed it within that <kbd>&lt;script&gt;</kbd> tag. We'll dig into the <kbd>import</kbd> and <kbd>export</kbd> syntax in the next couple of recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Exporting/importing multiple modules for external use</em></li>
<li><em>Adding fallback script tags</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Exporting/importing multiple modules for external use</h1>
                
            
            
                
<p>In the previous recipe, we loaded an ES module into an HTML page and executed an exported function. Now we can take a look at using multiple modules in a program. This allows us more flexibility when organizing our code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have Python installed and your browser properly configured.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new working directory, navigate into it with your command-line application, and start the Python <kbd>SimpleHTTPServer</kbd>.</li>
<li>Create a file named <kbd>rocket.js</kbd> that exports the name of a rocket, a countdown duration, and a launch function:</li>
</ol>
<pre style="padding-left: 60px">export default name = "Saturn V"; 
export const COUNT_DOWN_DURATION = 10; 
 
 
export function launch () { 
  console.log(`Launching in ${COUNT_DOWN_DURATION}`); 
  launchSequence(); 
} 
 
function launchSequence () { 
  let currCount = COUNT_DOWN_DURATION; 
 
  const countDownInterval = setInterval(function () { 
    currCount--; 
 
    if (0 &lt; currCount) { 
      console.log(currCount); 
    } else { 
      console.log('LIFTOFF!!! <img src="img/2d0bcca7-ad99-4fc1-8c63-bdc3fbcea22b.png" style="width:1.75em;height:1.75em;"/>'); 
      clearInterval(countDownInterval); 
    } 
  }, 1000); 
}</pre>
<ol start="3">
<li>Create a file named <kbd>main.js</kbd> that imports from <kbd>rocket.js</kbd>, logs out details, and then calls the launch function:</li>
</ol>
<pre style="padding-left: 60px">import rocketName, {COUNT_DOWN_DURATION, launch } from './rocket.js'; 
 
export function main () { 
  console.log('This is a "%s" rocket', rocketName); 
  console.log('It will launch in  "%d" seconds.', COUNT_DOWN_DURATION); 
  launch(); 
} </pre>
<ol start="4">
<li>Next, create an <kbd>index.html</kbd> file that imports the <kbd>main.js</kbd> module and runs the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">&lt;html&gt; 
  &lt;head&gt; 
    &lt;meta charset='UTF-8' /&gt; 
  &lt;/head&gt; 
  &lt;body&gt; 
    &lt;h1&gt;Open your console.&lt;/h1&gt; 
    &lt;script type="module"&gt; 
      import { main } from './main.js'; 
      main(); 
    &lt;/script&gt; 
  &lt;/body&gt; 
&lt;/html&gt; </pre>
<ol start="5">
<li>Open your browser and then the <kbd>index.html</kbd> file. You should see the following output:</li>
</ol>
<div><img src="img/3be6b910-02e5-4259-b3e3-85233e7fa412.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>There are two options for exporting a member from a module. It can either be exported as the <kbd>default</kbd> member, or as a named member. In <kbd>rocket.js</kbd>, we see both methods:</p>
<pre>export default name = "Saturn V"; 
export const COUNT_DOWN_DURATION = 10; 
export function launch () { ... } </pre>
<p>In this case, the string <kbd>"Saturn V"</kbd> is exported as the default member, while <kbd>COUNT_DOWN_DURATION</kbd> and <kbd>launch</kbd> are exported as named members. We can see the effect this has had when importing the module in <kbd>main.js</kbd>:</p>
<pre> <strong>import rocketName, { launch, COUNT_DOWN_DURATION } from './rocket.js';</strong> </pre>
<p>We can see the difference in how the default member and the name members are imported. The name members appear inside the curly braces, and the name they are imported with matches their name in the module source file. The default module, on the other hand, appears outside the braces, and can be assigned to any name. The unexported member <kbd>launchSequence</kbd> cannot be imported by another module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Renaming imported modules</em></li>
<li><em>Nesting imported modules under a single namespace</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Renaming imported modules</h1>
                
            
            
                
<p>Modules allow more flexibility in organizing code. This allows for a shorter, more contextual name. For example, in the previous recipe, we named a function <kbd>launch</kbd> instead of something more verbose such as <kbd>launchRocket</kbd>. This helps keep our code more readable, but it also means that different modules can export members that use the same name.</p>
<p>In this recipe, we'll rename imports in order to avoid these namespace collisions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be reusing the code from the previous recipe (<em>Exporting/importing multiple modules for external use</em>). The changes from the previous files will be highlighted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Copy the folder created for the previous recipe into a new directory.</li>
<li>Navigate to that directory with your command-line application and start the Python server.</li>
</ol>
<ol start="3">
<li>Rename <kbd>rocket.js</kbd> to <kbd>saturn-v.js</kbd>, add the name of the rocket to the log statements, and update the <kbd>main.js</kbd> import statement:</li>
</ol>
<pre style="padding-left: 60px">// main.js 
<strong>import name, { launch, COUNT_DOWN_DURATION } from './saturn-v.js';</strong> 
 
export function main () { 
  console.log('This is a "%s" rocket', name); 
  console.log('It will launch in  "%d" seconds.', COUNT_DOWN_DURATION); 
  launch(); 
} <br/>// saturn-v.js 
export function launch () { 
<strong>  console.log(`Launching %s in ${COUNT_DOWN_DURATION}`, name);</strong> 
  launchSequence(); 
} 
 
function launchSequence () { 
  // . . .  
<strong>      console.log(%shas LIFTOFF!!!</strong><img src="img/92bb1095-4efb-4b3a-a0ac-590d665f5310.png" style="width:1.75em;height:1.75em;"/><strong>', name);</strong> // . . . }</pre>
<ol start="4">
<li>Copy <kbd>saturn-v.js</kbd> to a new file named <kbd>falcon-heavy.js</kbd> and change the default export value and the <kbd>COUNT_DOWN_DURATION</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    <strong>export default name = "Falcon Heavy";</strong>
    <strong>export const COUNT_DOWN_DURATION = 5;</strong>  </pre>
<ol start="5">
<li>Import the <kbd>falcon</kbd> module into <kbd>main.js</kbd>. Rename the imported members to avoid conflicts and launch the falcon rocket as well:</li>
</ol>
<pre style="padding-left: 60px">import rocketName, { launch, COUNT_DOWN_DURATION } from './saturn-v.js'; 
<strong>import falconName, { launch as falconLaunch, COUNT_DOWN_DURATION as falconCount } from './falcon-heavy.js';</strong> 
 
export function main () { 
  console.log('This is a "%s" rocket', rocketName); 
  console.log('It will launch in  "%d" seconds.', COUNT_DOWN_DURATION); 
  launch(); 
   
<strong>  console.log('This is a "%s" rocket', falconName);</strong><strong>  console.log('It will launch in  "%d" seconds.', falconCount);</strong><strong>  falconLaunch();</strong> 
} </pre>
<ol start="6">
<li>Open <kbd>index.html</kbd> in your browser and you should see the following output:</li>
</ol>
<div><img src="img/8dbb64e7-e312-4818-958a-29b40c21704b.png" style="width:39.50em;height:31.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When we duplicated the <kbd>saturn-v.js</kbd> file to and imported the members from <kbd>falcon-heavy.js</kbd>, we had a potential namespace conflict. Both files export members named <kbd>COUNT_DOWN_DURATION</kbd> and launch. But using the <kbd>as</kbd> keyword, we renamed those members in order to avoid that conflict. Now the importing <kbd>main.js</kbd> file can use both sets of members without issue.</p>
<p class="packt_figure">Renaming members can also be helpful to adding context. For example, it might be useful to rename the launch as <kbd>launchRocket</kbd> even if there is no conflict. This give the importing module additional context, and makes the code a bit clearer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nesting modules under a single namespace</h1>
                
            
            
                
<p>As the number of modules grows, patterns start to emerge. For practical and architectural reasons, it makes sense to group multiple modules together and use them as a single package.</p>
<p>This recipe demonstrates how to collect multiple modules together and use them as a single package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>It will be helpful to have the source code available from previous recipes to bootstrap this recipe. Otherwise, you'll need to reference <em>Exporting/importing multiple modules for external use</em> for how to create the <kbd>index.html</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new folder with an <kbd>index.html</kbd> file, as seen in <em>Exporting/importing multiple modules for external use</em>.</li>
<li>Inside of that directory, create a folder named <kbd>rockets</kbd>.</li>
<li>Inside of <kbd>rockets</kbd>, create three files: <kbd>falcon-heavy.js</kbd>, <kbd>saturn-v.js</kbd>, and <kbd>launch-sequence.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// falcon-heavy.js 
import { launchSequence } from './launch-sequence.js'; 
 
export const name = "Falcon Heavy"; 
export const COUNT_DOWN_DURATION = 5; 
 
export function launch () { 
  launchSequence(COUNT_DOWN_DURATION, name); 
} (COUNT_DOWN_DURATION); 
} 
 
// saturn-v.js 
import { launchSequence } from './launch-sequence.js'; 
 
export const name = "Saturn V"; 
export const COUNT_DOWN_DURATION = 10; 
 
export function launch () { 
  launchSequence(COUNT_DOWN_DURATION, name); 
} 
 
// launch-sequence.js 
export function launchSequence (countDownDuration, name) { 
  let currCount = countDownDuration; 
  console.log(`Launching in ${COUNT_DOWN_DURATION}`, name); 
 
  const countDownInterval = setInterval(function () { 
    currCount--; 
 
    if (0 &lt; currCount) { 
      console.log(currCount); 
    } else { 
      console.log('%s LIFTOFF!!! <img src="img/1985d75a-0fda-4f64-857d-f8a410b0192f.png" style="width:2.00em;height:2.00em;"/>', name); 
      clearInterval(countDownInterval); 
    } 
  }, 1000); 
} </pre>
<ol start="4">
<li>Now create <kbd>index.js</kbd>, which exports the members of those files:</li>
</ol>
<pre style="padding-left: 60px">import * as falconHeavy from './falcon-heavy.js'; 
import * as saturnV from './saturn-v.js'; 
export { falconHeavy, saturnV }; </pre>
<ol start="5">
<li>Create a <kbd>main.js</kbd> file (in the folder that contains <kbd>rockets</kbd>), which imports <kbd>falconHeavey</kbd> and <kbd>saturnV</kbd> from the <kbd>index.js</kbd> file and launches them:</li>
</ol>
<pre style="padding-left: 60px">import { falconHeavy, saturnV } from './rockets/index.js' 
 
export function main () { 
  saturnV.launch(); 
  falconHeavy.launch(); 
} </pre>
<ol start="6">
<li>Open in the browser, and see the following output:</li>
</ol>
<div><img src="img/f30de003-ea57-4257-a371-8fecbddbacfa.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The * syntax seen on the first two lines of <kbd>index.js</kbd> imports all the exported members under the same object. This means that the <kbd>name</kbd>, <kbd>COUNT_DOWN_DURATION</kbd>, and <kbd>launch</kbd> members of <kbd>falcon-heavey.js</kbd> are all attached to the <kbd>falconHeavy</kbd> variable. Likewise, for the <kbd>saturn-v.js</kbd> modules and the <kbd>saturnV</kbd> variable. So, when <kbd>falconHeavy</kbd> and <kbd>saturnV</kbd> are exported on <em>line 4</em>, those exported names now contain all the exported members of their respective modules.</p>
<p>This provides a single point where another module (<kbd>main.js</kbd> in this case) can import those members. The pattern has three advantages. It is simple; there is only one file to import members from, rather than many. It is consistent, because all packages can use an <kbd>index</kbd> module to expose members of multiple modules. It is more flexible; members of some modules can be used throughout a package and not be exported by the <kbd>index</kbd> module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is possible to export named items directly. Consider the following file, <kbd>atlas.js</kbd>:</p>
<pre>import { launchSequence } from './launch-sequence.js'; 
 
const name = 'Atlas'; 
const COUNT_DOWN_DURATION = 20; 
 
export const atlas = { 
  name: name, 
  COUNT_DOWN_DURATION: COUNT_DOWN_DURATION, 
  launch: function () { 
    launchSequence(COUNT_DOWN_DURATION, name); 
  } 
}; </pre>
<p>The <kbd>atlas</kbd> member can be exported directly by <kbd>index.js</kbd>:</p>
<pre>import * as falconHeavy from './falcon-heavy.js'; 
import * as saturnV from './saturn-v.js'; 
 
export { falconHeavy, saturnV }; 
<strong>export { atlas } from './atlas.js';</strong></pre>
<p>Then the <kbd>main.js</kbd> file can import the <kbd>atlas</kbd> member and launch it:</p>
<pre><strong>import { atlas, falconHeavy, saturnV } from './rockets/index.js'</strong> 
 
export function main () { 
  saturnV.launch(); 
  falconHeavy.launch(); 
<strong>  atlas.launch();</strong> 
} </pre>
<p>This is one benefit of always using named exports; it's easier to collect and export specific members from packages with multiple modules.</p>
<p>Whether named or not, nesting is a great technique for grouping modules. It provides a mechanism for organizing code as the number of modules continues to grow.</p>
<div></body></html>