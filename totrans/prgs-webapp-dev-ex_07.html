<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service Worker Caching Patterns</h1>
                
            
            <article>
                
<p class="calibre2">The internet is great, until you are offline or have poor connectivity. Then it becomes an act of futility as you wait for a page to load that never seems to materialize. Eventually, the request times out and the browser displays a message letting you know you're offline—Chrome is known for its cute offline dinosaur.</p>
<p class="calibre2">Most web traffic comes from smartphones, and many of those connections are made over a cellular connection (GPRS). Cellular networks are great when they work, but often a clean connection to the internet is not guaranteed.</p>
<p class="calibre2">Even in the United States, reliable LTE networks are not ubiquitous. There are several locations near my house where I have no cell coverage. Imagine what it might be like in a less developed area.</p>
<p class="calibre2">This is where service workers and the Cache API can help you out. The combination of these two features enables you to make the network optional. A service worker has several events that you can leverage to craft a web server in the browser.</p>
<p class="calibre2">The topics that will be covered in this chapter are as follows:</p>
<ul class="calibre10">
<li class="calibre11">How the service worker cache works</li>
<li class="calibre11">Common service worker caching strategies</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How the service worker cache works</h1>
                
            
            <article>
                
<p class="calibre2">The service worker sits between the browser and the network. By adding a <kbd class="calibre12">fetch</kbd> event handler, you can determine how the request is handled. All network requests pass through the service worker's fetch event handler:</p>
<div class="cdpaligncenter"><img src="../images/00071.jpeg" class="calibre85"/></div>
<p class="calibre2">This gives you a hook, or way to inject logic into the workflow, to intercept requests and determine how and where the response is returned.</p>
<p class="calibre2">With the service worker, you can do the following:</p>
<ul class="calibre10">
<li class="calibre11">Pass the request to the network, the traditional method</li>
<li class="calibre11">Return a cached response, bypassing the network altogether</li>
<li class="calibre11">Create a custom response</li>
</ul>
<p class="calibre2">When the network fails, you can program the service worker to return a response from the cache, even if it is a <em class="calibre13">fallback</em> response. Because the service worker can return responses from the cache, your pages can load instantly if they are cached:</p>
<div class="cdpaligncenter"><img src="../images/00072.jpeg" class="calibre86"/></div>
<p class="calibre2">In the preceding diagram, the service worker is programmed to intercept all network requests, and can return a response from <span class="calibre5">either</span><span class="calibre5"> </span><span class="calibre5">the cache or the network.</span></p>
<p class="calibre2">Because the service worker runs locally, it is always available. It can decide the best way <span class="calibre5">to return a response based on the conditions.</span></p>
<p class="calibre2">The following diagram illustrates the service worker living within the context of the browser, providing a proxy to handle requests, even when the network is unavailable:</p>
<div class="cdpaligncenter"><img src="../images/00073.jpeg" class="calibre87"/></div>
<p class="calibre2">When utilizing a service worker and the network is unavailable, your website can still function if you have valid cached responses. Even if a page is not cached, you can create a response so that the customer has something relevant to interact with. Later in the book, I will go over how you can queue the user's actions and update the server when the network is available.</p>
<p class="calibre2">The following diagram shows how the service worker can use cached resources when the network is unavailable:</p>
<div class="cdpaligncenter"><img src="../images/00074.jpeg" class="calibre88"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service worker events</h1>
                
            
            <article>
                
<p class="calibre2">A<span class="calibre5"> service worker has</span><span class="calibre5"> several events. You can use these to manage your application's cache. We have already looked at using the</span> <em class="calibre13">install</em> <span class="calibre5">and</span> <em class="calibre13">activate</em> <span class="calibre5">events to precache responses in Chapter 5,  <em class="calibre13"><span class="calibre5"><span class="calibre5">The Service Worker Life Cycle</span></span></em>.</span></p>
<p class="calibre2">The all-star service worker event is <kbd class="calibre12">fetch</kbd>. This event fires each time a network-addressable asset (URL) is requested. By adding a <kbd class="calibre12">fetch</kbd> event handler to your service worker, you can intercept all network requests, triggering a workflow to determine how to respond:</p>
<pre class="calibre17">self.addEventListener("fetch", event =&gt; { 
   //process request and return best response 
}); </pre>
<p class="calibre2">As you learned <a target="_blank" href="part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 6</a>, <em class="calibre13">Mastering the Cache API – Managing Web Assets in a Podcast Application</em>, you can use the Fetch API's custom <kbd class="calibre12">request</kbd> and <kbd class="calibre12">response</kbd> objects to inspect requests and create or clone network responses.</p>
<p class="calibre2">The event variable supplied by the <kbd class="calibre12">fetch</kbd> event handler has a request property. This property is a <kbd class="calibre12">request</kbd> object. You can use the <kbd class="calibre12">request</kbd> object to determine how you will return the response. In this chapter, you will learn several caching strategies that you can apply to make your progressive web application work faster, <span class="calibre5">and </span><span class="calibre5">offline</span><span class="calibre5">.</span></p>
<p class="calibre2">Knowing how to use the <kbd class="calibre12">fetch</kbd> event to maximize performance using the application's cache is the key to providing the best user experience possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Caching patterns and strategies</h1>
                
            
            <article>
                
<p class="calibre2">Service worker events give you gateways to the service worker life cycle in order to apply your caching strategy. But there is more to this than just checking whether a valid response has been cached or is passing the request to the network. You should have a plan of how your application will use the service worker cache, events, and the network to deliver the best experience.</p>
<p class="calibre2">This means that you need to have a collection of common patterns and strategies to build your application logic upon. The rest of the chapter will review common caching patterns that you can use to build your applications.</p>
<p class="calibre2">Strategies are the combination of guidelines and example code that you can use to build your applications. As you continue through this book, you will see these strategies used in the PodStr and PWA Tickets applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Precaching</h1>
                
            
            <article>
                
<p class="calibre2">One of the key aspects of the PRPL pattern, which we will learn more about in a later chapter, is to store application assets when the application is installed. When a user accesses an initial entry point to a web application, a background process is triggered that will automatically load additional assets that will later <span class="calibre5">be</span><span class="calibre5"> </span><span class="calibre5">needed as different aspects of the site are rendered. This is known as precaching, or priming your application's cache for better performance in the future.</span></p>
<p class="calibre2">Service workers make this practice easy to manage. You can take advantage of the <kbd class="calibre12">install</kbd> and <kbd class="calibre12">activate</kbd> events, as well as when a service worker is initially triggered. The common practice is to use the <kbd class="calibre12">install</kbd> event when a new service worker is registered to precache a list of well-known assets:</p>
<pre class="calibre17">self.addEventListener("install", event =&gt; { 
 
    event.waitUntil( 
 
        caches.open(cacheName(PRECACHE_NAME)).then(cache =&gt; { 
 
            return cache.addAll(PRECACHE_URLS); 
 
        }) 
 
    ); 
 
}); </pre>
<p class="calibre2">There are two types of precache strategies you need to understand: precaching as a dependency and not as a dependency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing as a dependency</h1>
                
            
            <article>
                
<p class="calibre2">When precaching application assets, there are certain assets you know will be used rather quickly or frequently. You can consider these mission-critical. And while the initial page load or app shell load may trigger network requests for these assets, causing them to be cached, there will probably be other assets that you want to ensure are cached early in the application-loading process:</p>
<div class="cdpaligncenter"><img src="../images/00075.jpeg" class="calibre89"/></div>
<p class="calibre2">These assets should be precached as a dependency of the <kbd class="calibre12">install</kbd> event completing. In other words, these assets must complete caching before the <kbd class="calibre12">install</kbd> event closes, which means you should use the <kbd class="calibre12">event.waitUntil</kbd> method to hold the process open. By doing so, you delay any active events from triggering until these assets are completely cached:</p>
<pre class="calibre17"> 
self.addEventListener('install', function (event) { 
    event.waitUntil( 
    //pre-cache 
    //on install as a dependency 
    return caches.open(preCacheName).then(cache =&gt;{ 
        return cache.addAll(PRECACHE_URLS); 
    }); 
}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing not as a dependency</h1>
                
            
            <article>
                
<p class="calibre2">Precaching is not limited to mission-critical assets. You <span class="calibre5">can</span><span class="calibre5"> </span><span class="calibre5">most likely identify many assets that will be commonly used, but are not mission-critical to your application's success. You can still use the service worker <kbd class="calibre12">install</kbd> event to cache this set of assets, but choose not to make them dependent on the event completing. This is known as precaching assets without dependency.</span></p>
<p class="calibre2">In this scenario, you will also trigger the precaching of these network assets, but you will not return the <kbd class="calibre12">cache.addAll</kbd> method in the <kbd class="calibre12">event.wait</kbd> <kbd class="calibre12">until</kbd> call. The assets will still be added to the cache, but will not hold the <kbd class="calibre12">install</kbd> event open until all of the assets are cached.</p>
<p class="calibre2">This technique gives you the ability to minimize the latency of precaching assets that might hold the service worker installation up. One of your goals when registering a new service worker is to make it available as quickly as possible. Requesting assets that may take a little while can hold that process up. This means that your service worker cannot take control of any clients until all this caching, including the <kbd class="calibre12">activate</kbd> event, is done, as shown in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00076.jpeg" class="calibre90"/></div>
<p class="calibre2">While you trigger this request in the <kbd class="calibre12">install</kbd> event, the event is not delayed. The request will still be cached, but outside of the <kbd class="calibre12">event</kbd> loop:</p>
<pre class="calibre17">self.addEventListener('install', function (event) { 
    event.waitUntil( 
        //won't delay install completing and won't cause installation <br class="title-page-name"/>        to  
        //fail if caching fails. 
        //the difference is as dependency returns a Promise, the  
        //no dependency does not. 
        //on install not as dependency (lazy-load) 
        caches.open(preCacheNoDependencyName).then(cache =&gt;{ 
            cache.addAll(PRECACHE_NO_DEPENDENCY_URLS); 
            return cache.addAll(PRECACHE_URLS); 
        })); 
}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">On activate</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">activate</kbd> event is the next part of the service worker life cycle chain that you can leverage to manage cached assets. It can also be used to cache assets, but is more commonly used to perform cache model cleanup.</p>
<p class="calibre2">Instead of focusing on caching assets, the <kbd class="calibre12">activate</kbd> event is better suited to clean up legacy caches. This can eliminate version mismatch issues that can break your application:</p>
<div class="cdpaligncenter"><img src="../images/00077.jpeg" class="calibre91"/></div>
<p class="calibre2">To implement this strategy, you need to have a discernible version cache-naming convention. I recommend adding a version number to all of your named caches. This gives you a simple pattern that you can match to determine whether a named cache should be removed. Just be aware that any assets that are cached in those named caches will also be removed. This is okay, as the new version of the service worker typically caches updated versions of these assets:</p>
<pre class="calibre17">self.addEventListener('activate', function (event) { 
    //on activate 
    event.waitUntil( 
caches.keys().then(function (cacheNames) { 
                    cacheNames.forEach(function (value) { 
                    if (value.indexOf(VERSION) &lt; 0) { 
                       caches.delete(value); 
                   } 
                }); 
            return; 
        }) 
    ); 
}); </pre>
<p class="calibre2">The preceding example code loops through all the named caches and checks whether the cache belongs to the current service worker. The version variable has the version number pattern we are looking for. My personal preference is to declare a <kbd class="calibre12">const</kbd> value at the beginning of the service worker:</p>
<pre class="calibre17">const VERSION = "v1", </pre>
<p class="calibre2">I add a <kbd class="calibre12">v</kbd> to the value to further indicate that it is a version number, but that is more of a mental tool to appeal to my personal preferences. Feel free to use any sort of versioning pattern you like. Semantic versioning or even a random hash or GUID would also work well here.</p>
<p class="calibre2">The main point is to have a unique pattern that you can identify in your cache names. Creating a variable is useful because it can be appended to the cache name to make cleanup easier to manage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Real-time caching</h1>
                
            
            <article>
                
<p class="calibre2">Caching does not need to be limited to the service worker installation events. While you should precache your common assets, there are probably many resources that are dynamic in nature. Some example in podcast applications are the individual podcasts and podcast episode pages.</p>
<p class="calibre2">Each podcast contains unique properties, such as a title, description, and logo. Each episode also has a unique title, description, possibly an image, and, of course, the audio file.</p>
<p class="calibre2">These are very dynamic and fluid pieces of data that create many opportunities for new pages and page assets, as well as updates to these same pages and assets. The service worker <kbd class="calibre12">fetch</kbd> event handler gives you the hook to intercept all requests to the network so you can determine whether those assets are properly <span class="calibre5">locally</span><span class="calibre5"> </span><span class="calibre5">cached before hitting the internet.</span></p>
<p class="calibre2">This basic pattern gives you the ability to <span class="calibre5">instantly </span><span class="calibre5">load assets that were previously cached without worrying about network connectivity. There are many variations of this pattern, as you will see in the following sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">On user interaction</h1>
                
            
            <article>
                
<p class="calibre2">The first dynamic caching strategy is in response to a user interaction, such as clicking a button. Instead of this being explicitly caught by the service worker <kbd class="calibre12">fetch</kbd> event, it can be managed from the client JavaScript. This takes advantage of the client's (browser) access to the Client API:</p>
<div class="cdpaligncenter"><img src="../images/00078.jpeg" class="calibre92"/></div>
<p class="calibre2">The podcast application episode page has a button that the user can select to cause the episode's MP3 file to be stored offline. This is part of the listen-later functionality, something I love to use in the Stitcher app!</p>
<p class="calibre2">The following example code is a function that is executed when the user clicks the <span class="calibre5">Listen Later</span> button on an episode page. A <kbd class="calibre12">fetch</kbd> is made to the API and the response is cached in the <kbd class="calibre12">LISTEN_LATER</kbd> cache:</p>
<pre class="calibre17">    function saveEpisodeData(guid) { 
        var episodeSource = "api/episodes/" + guid + ".json"; 
        fetch(episodeSource) 
            .then(function (response) { 
                if (response &amp;&amp; response.ok) { 
                    caches.open("LISTEN_LATER").then( 
                        cache =&gt; { 
                            cache.put(episodeSource, response); 
                        }); 
                } 
            }); 
    }</pre>
<p class="calibre2">To make this feature complete, a similar method would be used to cache the episode's MP3 file. You would also want to persist something you can use to visually indicate that the episode is saved for later if the user opens the episode page later. You would also want to maintain a local list of saved episodes. This can be done using <kbd class="calibre12">IndexedDB</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">On network response</h1>
                
            
            <article>
                
<p class="calibre2">When a request returns from the network, you can intercept this part of the <kbd class="calibre12">fetch</kbd> process and handle it based on your application's logic. The most common thing to do is to cache the response while returning a copy to the client.</p>
<p class="calibre2">This also extends the core pattern of on-demand asset caching. It's important to note that when you intercept a request from the network, you should clone the response before caching it. A response can only be used once:</p>
<div class="cdpaligncenter"><img src="../images/00079.jpeg" class="calibre93"/></div>
<p class="calibre2">The <kbd class="calibre12">clone</kbd> method creates a deep copy of the response, allowing you to do something else with the response. The most common use of the <kbd class="calibre12">clone</kbd> method is to create a copy so that one can be cached and the other returned to the client, as shown in the following code:</p>
<pre class="calibre17">self.addEventListener('fetch', function (event) { 
    event.respondWith( 
        caches.open(cacheName).then(cache =&gt;{ 
            return cache.match(event.request).then(function (response)          <br class="title-page-name"/>             { 
                return response || fetch(event.request).then( 
                    function (response) { 
                        caches.open(cacheName).then( 
                            cache =&gt;{ 
                                cache.put(event.request, <br class="title-page-name"/>                                response.clone()); 
                            }); 
                        return response; 
                    }); 
            }); 
        }) 
    ); 
}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stale while revalidating</h1>
                
            
            <article>
                
<p class="calibre2">The next phase of our basic network-caching strategy is to return a previously cached version to the client while making a network request for the latest version.</p>
<p class="calibre2">This strategy is very helpful when you need to return a response quickly, but the freshness of the data is not the biggest requirement. For example, a podcast episode does not change its details much, if at all. Returning a cached version of the page and its images would not mean that the user is missing out on fresh data. The following diagram shows the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00080.jpeg" class="calibre94"/></div>
<p class="calibre2">But maybe you want to make sure that the user has the latest content. You can return the cached response instantly, while making a new request to the network and caching that response. This will replace any previously cached data for the next time the page is requested, as shown in the following code:</p>
<pre class="calibre17"> self.addEventListener('fetch', event =&gt; { 
     event.respondWith(  
caches.open(dynamicCacheName).then(cache =&gt;{    
         return cache.match(event.request).then(function <br class="title-page-name"/>         (response) { 
               var fetchPromise = fetch(event.request) 
               .then(function (networkResponse) {      
                cache.put(event.request, <br class="title-page-name"/>                networkResponse.clone());      
                return networkResponse;     
                 });  
                return response || fetchPromise;    
                })   
         })  
   ); 
}); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">On push notification</h1>
                
            
            <article>
                
<p class="calibre2">User activity and network requests are not the only times you can cache a network resource:</p>
<div class="cdpaligncenter"><img src="../images/00081.jpeg" class="calibre95"/></div>
<p class="calibre2">You can also use a <kbd class="calibre12">push</kbd> message to initiate caching responses, as shown in the following code:</p>
<pre class="calibre17">//On push message 
function parsePushMessage(message){ 
   //parse the message 
   If(message.update){ 
   //notify user of background update process here 
    caches.open(preCacheName).then(cache =&gt;{ 
        return cache.addAll(message.urls); 
    }); 
} 
} 
 
self.addEventListener('push', event =&gt; {  
   parsePushMessage(event.data); 
}); </pre>
<p class="calibre2">In this strategy, the <kbd class="calibre12">push</kbd> event handler determines the type of message action. If it is a notice to update the application, it initiates the process. The preceding code example is a bit of an oversimplification, but it shows the important parts.</p>
<p class="calibre2">The <kbd class="calibre12">push</kbd> message body should have some sort of property indicating the action that should be taken. In this case, it triggers an update workflow. Included in the message is a property, <kbd class="calibre12">urls</kbd>, which is an array of all the URLs that should be updated or cached.</p>
<p class="calibre2">The <kbd class="calibre12">cache.addAll</kbd> method makes the code simple, since it will perform all the <kbd class="calibre12">fetch</kbd> requests and cache the responses for you.</p>
<p class="calibre2">You should always notify the user that a <kbd class="calibre12">push</kbd> notification has been received and the application is being updated. In this situation, you may also want to prompt the user to reload the app if they are currently using it. You can check to see whether there are any active clients while you are updating the cache, and notify them of the updating process. You will learn more about <kbd class="calibre12">push</kbd> notifications in a future chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">On background sync</h1>
                
            
            <article>
                
<p class="calibre2">A more advanced caching pattern would be to use the Background Sync API. We'll talk about this in more detail in a later chapter.</p>
<p class="calibre2">The core idea is to wrap all of your network request in a background sync wrapper. Here, you would create a request tag and cue it up to be processed as soon as the network is available.</p>
<p class="calibre2">This adds a new layer of complexity to using the service worker fetch, but can be very valuable if you need to maintain an asynchronous dataset with the server.</p>
<p class="calibre2">If you are connected to the network, any request passed to the Background Sync API will immediately be executed as normal. If you are not connected, it's added to a queue and executed when the device regains connectivity. The following image shows the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00082.jpeg" class="calibre96"/></div>
<p class="calibre2">At that point, a <kbd class="calibre12">sync</kbd> event triggers, which could be used to initiate a cache update, as shown in the following code:</p>
<pre class="calibre17">self.addEventListener('sync', function(event) { 
  if (event.id === 'update-podcast-XYZ') { 
    event.waitUntil( 
      caches.open(DYNAMIC_CACHE_NAME).then(function(cache) { 
        return cache.add("podcast/xyz/"); 
      }) 
    ); 
  } 
}); </pre>
<p class="calibre2">In this example, a <kbd class="calibre12">background sync</kbd> tag has been created for a specific podcast. If that tag triggers the <kbd class="calibre12">sync</kbd> event, the corresponding podcast details page is added to the dynamic cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cache only</h1>
                
            
            <article>
                
<p class="calibre2">When a network resource is precached, you can choose to implement a policy of only using a cached version of the asset. This is known as the cache-only strategy.</p>
<p class="calibre2">When you know a resource can be safely cached long term, you can reduce more overhead in your application by eliminating unnecessary network chatter.</p>
<p class="calibre2">Retrieving these resources from the cache also means that the application can load faster and, of course, load offline. Just make sure they don't become too stale.</p>
<p class="calibre2">Here, any request for a network resource will be retrieved only from the cache and no network response will be used. This can be very valuable for long-term static resources, such as application core JavaScript and CSS files. You could also apply it to images such as your site's logo and font files.</p>
<p class="calibre2">If you are employing the cache-only strategy, I advise having a routine automatically triggered when your service worker is executed. This routine should <span class="calibre5">periodically</span><span class="calibre5"> </span><span class="calibre5">check for new response versions to ensure that you have the most up-to-date data.</span></p>
<p class="calibre2">Also, make sure that these resources are static or they could potentially break your application. If you choose to make them static, I advise adding these resources to a service worker version change before deploying them to your server. The following image shows the the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00083.jpeg" class="calibre97"/></div>
<p class="calibre2">The cache-only strategy pairs well with either of the precache strategies discussed earlier in the chapter. Precaching cache-only resources should ensure that they are available from the cache, as shown in the following code:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt; { 
  // If a match isn't found in the cache, the response 
  // will look like a connection error 
  event.respondWith(caches.match(event.request)); 
}); </pre>
<p class="calibre2">In this code example, the <kbd class="calibre12">fetch</kbd> event handler only responds with a match from the cache. If one does not exist, the client will receive a <kbd class="calibre12">not found</kbd> (404 status code) response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Network only</h1>
                
            
            <article>
                
<p class="calibre2">The complete opposite of cache-only is to only request a resource from the network. In this scenario, you will identify network resources that should always be requested from the server.</p>
<p class="calibre2">The strategy should be employed on data that changes very frequently. For example, a stock ticker application would want to make sure that the request to update stock prices is made immediately and not from a local cache. Stale data in this scenario can cost you a fortune. The following image shows the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00084.jpeg" class="calibre98"/></div>
<p class="calibre2">You should identify the nature of any file or network resources you might need to access, and ensure that the data is constantly being updated. You can intercept these requests and apply the proper strategy based on routes and patterns. To do so, I would advise you to have some unique identifier in these assets' URLs, as shown in the following code example:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt; { 
  event.respondWith(fetch(event.request)); 
  // or simply don't call event.respondWith, which 
  // will result in default browser behaviour 
});  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cache falling back to network</h1>
                
            
            <article>
                
<p class="calibre2">The most common pattern I see employed in service workers is the cache falling back to the network. It's very popular because checking for an asset's presence in your cache means that it can return immediately. If it does not, you still have the network fallback retrieving it as fast as possible.</p>
<p class="calibre2">Any asset that is not precached or previously cached from the same pattern would be accessible, assuming you are online. The following image shows the interactions involved:</p>
<div class="cdpaligncenter"><img src="../images/00085.jpeg" class="calibre99"/></div>
<p class="calibre2">I say that this is probably the most common pattern used because any asset that is not precached could comfortably fit into this pattern. The podcast application uses this pattern for all the individual podcast and episode pages. This makes them accessible as soon as possible, but we don't want to precache every single file and image ahead of time, only on-demand.</p>
<p class="calibre2">The following is an example of this pattern being executed:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt; { 
  event.respondWith( 
    caches.match(event.request).then(function(response) { 
      return response || fetch(event.request); 
    }) 
  ); 
}); </pre>
<p class="calibre2">It seems pointless to execute this pattern without caching the network response. The following code shows how I recommend you apply this strategy; I call it "cache falling back to the network", caching the result:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt;{ 
        caches.match(event.request).then( 
            function (response) { 
                return response || fetch(event.request).then( 
                    function (response) { 
                        caches.open(dynamicCacheName).then( 
                            cache =&gt;{ 
                                cache.put(event.request, response.clone()); 
                            }); 
                        return response; 
                    } 
                ) 
            }) 
}); </pre>
<p class="calibre2">This is the more complete version of this pattern. Now, the next time the resource is requested, it will come from the cache. But if it was not previously cached, it can be retrieved from the network.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cache and network race</h1>
                
            
            <article>
                
<p class="calibre2">Another interesting caching pattern, of the variation of the cache falling back to the network pattern, is a cache and network race pattern. This is where you will simultaneously request the resource from the cache and the network. The fastest response wins. While the cache should be the winner, it may not always win. This pattern also gives you the opportunity to retrieve the network version a little bit faster if there is no cached version. The following image shows the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00086.jpeg" class="calibre100"/></div>
<p class="calibre2">The drawback to this pattern is that you will always make a network request even if it's not needed. This will increase your network traffic. But you could also look at it as a way to ensure you've got at least some of the freshest content cached every single time. It can also be viewed as a variation of the stale while revalidating strategy. The following code shows how to implement the cache and network race pattern:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt;{ 
        promiseAny([ 
            caches.match(event.request), 
            fetch(event.request) 
        ]) 
}); 
 
// Promise.race is no good to us because it rejects if 
// a promise rejects before fulfilling. Let's make a proper 
// race function: 
function promiseAny(promises) {  
    return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>// make sure promises are all                                                             
        promises = promises.map(p =&gt; Promise.resolve(p));  <br class="title-page-name"/>// resolve this promise as soon as one resolves           
        promises.forEach(p =&gt; p.then(resolve));   <br class="title-page-name"/>// reject if all promises reject           
        promises.reduce((a, b) =&gt; a.catch(() =&gt; b))    
            .catch(() =&gt; reject(Error("All failed")));  
    }); 
}; </pre>
<p class="calibre2">Note that there is a custom <kbd class="calibre12">promiseAny</kbd> function. This is because of a limitation of the <kbd class="calibre12">Promise.race</kbd> method. When a <kbd class="calibre12">Promise.race</kbd> method is used and any of the supplied promises throws an exception, the entire process fails.</p>
<p class="calibre2">This pattern depends on at least one promise resolving a response. The <kbd class="calibre12">promiseAny</kbd> function is a modification to the <kbd class="calibre12">Promise.race</kbd> method, except it will not fail if a supplied promise fails. It assumes that one of the promises will succeed and return the winner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Network falling back to cache</h1>
                
            
            <article>
                
<p class="calibre2">If you have a time-sensitive network resource that you always want to hit the network, you should also consider using the network falling back to cache strategy. Here, you will always try to access the network, but if the network is inaccessible, then you have the built-in option to retrieve the most recently cached version of the file.</p>
<p class="calibre2">If it is critical that the resource is fresh, I advise that you visually alert the customer of the time that is associated with that response. The following image shows the interactions involved in this process:</p>
<div class="cdpaligncenter"><img src="../images/00087.jpeg" class="calibre101"/></div>
<p class="calibre2">This pattern can also be to provide a fallback for any asset that is inaccessible over the network, which we will see in the next pattern. The following code shows how to implement the network falling back to cache pattern:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt; { 
   event.respondWidth( 
        fetch(event.request).catch(function () { 
            return caches.match(event.request); 
        }) 
    }); 
}); 
 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generic fallback</h1>
                
            
            <article>
                
<p class="calibre2">The next step from the network falling back to the cache is to have a generic fallback for all requests. You should use this when no response was available either in the cache or from the network.</p>
<p class="calibre2">You can see this pattern employed across the Podstr application for podcast episodes and their associated images.</p>
<p class="calibre2">The trick here is to precache a fallback response for these particular network assets. I also advise that you apply this strategy by matching route variations and not individual URLs.</p>
<p class="calibre2">In the Podstr podcast application, there are generic fallbacks for the podcast pages, episode pages, and podcast logos. I identified each of these as dynamic resources that cannot be precached.</p>
<p class="calibre2">Typically, if you can't access the resource, that means that it is not found or the device is offline. I think it's important that you have some logic in place to determine the difference. If the application is offline, you want to visually indicate that somehow, but if the resource is <span class="calibre5">truly</span><span class="calibre5"> </span><span class="calibre5">not found, you may want to return a slightly different response.</span></p>
<p class="calibre2">I think Flipkart does a fantastic job of this. When the application is offline, they greyscale the entire UI. This is a very clear indication to the end user that the device is offline, which means that they may not necessarily be able to access the information, and that any information they receive may not be current. The following screenshot shows an example of this greyscaling:</p>
<div class="cdpaligncenter"><img src="../images/00088.jpeg" class="calibre102"/></div>
<p class="calibre2">If you receive an error <kbd class="calibre12">404</kbd> message, then you can return a Not Found page and use that to your advantage as well. The following image shows the interactions involved in this pattern:</p>
<div class="cdpaligncenter"><img src="../images/00089.jpeg" class="calibre103"/></div>
<p class="calibre2">Maybe you will choose to direct them to a related resource, or provide a sitemap, as shown in the following code:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt;{ 
   event.respondWidth( 
        caches.match(event.request).then(response =&gt; {  <br class="title-page-name"/>              // Fall back to network                
            return response || fetch(event.request);   
        }).catch(function () {    // If both fail, show a generic         <br class="title-page-name"/>          fallback: 
            return caches.match("fallback/").then(function(response){ 
                return response; 
            });     
                // However, in reality you'd have many different 
                // fallbacks, depending on URL &amp; headers. 
                // Eg, a fallback images for podcast logos. 
        }) 
   ); 
  }); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service worker templating</h1>
                
            
            <article>
                
<p class="calibre2">A concept you should embrace about service workers is that they can act like a web server in the browser. Traditionally, web servers have used runtime rendering platforms, such as ASP.NET, PHP, Ruby on Rails, and content management systems such as WordPress, Drupal, and Joomla!. These systems are rendering engines more than anything else. You can perform HTML rendering inside of a service worker.</p>
<p class="calibre2">Single-page applications have become very popular this decade. They effectively take ownership of this rendering process from the server. Today, it is popular to preload application templates, whether you're using mustache, handlebars, or larger frameworks such as Angular and React. All of these <span class="calibre5">are</span><span class="calibre5"> </span><span class="calibre5">essentially just HTML rendering systems. The difference between the server side and the client side is where the rendering takes place. </span>Because you can intercept network requests in a service worker, the rendering process can be moved from the client UI or the server to the service worker.</p>
<p class="calibre2">In this pattern, you will most likely precache the page or component templates ahead of time and make network requests to an API to return data, typically formatted in JSON. When you retrieve the new JSON, you will then render the markup in the service worker and return the HTML to the client. The following image shows the interactions involved in this pattern:</p>
<div class="cdpaligncenter"><img src="../images/00090.jpeg" class="calibre104"/></div>
<p class="calibre2">My personal technique is to use mustache because it is simple and fast. The overall technique is a little bit advanced, but once you have a working pattern, I think you'll see that it's easier to implement.</p>
<p class="calibre2">In this example, the <kbd class="calibre12">fetch</kbd> event handler looks for any request to the podcast episode routes. When an episode request is made, it is intercepted and a new custom request created. Instead of requesting the HTML from the server, the service worker will create a request to an API to retrieve the JSON.</p>
<p class="calibre2">In theory, the request for the JSON should be smaller than a request for the HTML. The smaller packet should be loaded slightly faster. The real question is can the small request be retrieved and rendered faster than a request for prerendered HTML? This is an answer I cannot give you. It will require some experimentation with your application's pages and API to determine which one is the best solution.</p>
<p class="calibre2">For small pieces of data, such as the episode page, chances are that the service worker rendering will be slightly slower. But if your page contains a lot of information that is repeatable—such as the kind of information that you often see in line-of-business applications—this technique could improve your overall performance. The following code shows how you can implement this pattern:</p>
<pre class="calibre17">self.addEventListener('fetch', event =&gt; { 
   event.respondWidth( 
        Promise.all([    
            caches.match("/product-template.html").then( 
                response =&gt; {     
                    return response.text();    
                }),     
            caches.match("api/products/35.json").then( 
                response =&gt; {     
                    return response.json();    
                })   
        ]).then(function (responses) {    
            var template = responses[0];    
            var data = responses[1];    
            return new Response(Mustache.render(template, data), {     
                headers: {      
                    "Content-Type": "text/html" 
                }    
            });   
        }) 
    }); 
}); 
 </pre>
<p class="calibre2">Once the API request returns the service worker logic, it then loads the content template and renders it to HTML. This HTML is then returned to the client in a custom <kbd class="calibre12">response</kbd> object.</p>
<p class="calibre2">An even more advanced way to use the strategy is to use it in concert with caching a response. This way, you render the response once, cache it, and check to see whether it's cached the next time.</p>
<p class="calibre2">This pattern may not be optimal for every scenario, but it should be considered if you have pages with large, repeating datasets and wish to take advantage of any speed gains.</p>
<p class="calibre2">The scenario I believe this pattern offers the most benefit for is dynamically rendered markup where data changes frequently. Progressive web apps, such as the Podstr application, may not realize performance gains, but a line-of-business application can.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">These strategies should serve as your service worker fetching and caching workflow. The reason there are so many strategies is that there are many scenarios for application assets. How you apply these strategies is up to you, and they may require some experimentation to determine the best strategy for each asset type.</p>
<p class="calibre2">These strategies may not be the exact patterns you need for your application, but they will serve as the foundation for all your caching needs. You can use these as starting points that you can extend, mix, and match to create the best strategies for your application.</p>


            </article>

            
        </section>
    </body></html>