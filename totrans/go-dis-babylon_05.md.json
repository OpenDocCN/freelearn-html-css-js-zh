["```js\n\nclass CutSceneSegment {\n    //loopAnimation = false;\n    //animationGroup;\n    //onEnd = new Observable();\n    constructor(target, scene, ...animationSequence) { ... }\n```", "```js\n\nnew CutSceneSegment(billboard, scene, fadeAnimation,\n  scaleAnimation, rotateAnimation);\n```", "```js\n\nconstructor(target, scene, ...animationSequence) {\n    this._target = target;\n    let ag = new AnimationGroup(target.name + \n      \"-animGroupCS\", scene);\n    for (var an of animationSequence) {\n        ag.addTargetedAnimation(an, target);\n    }\n    this.animationGroup = ag;\n    this.onEnd = ag.onAnimationGroupEndObservable;\n    this._scene = scene;\n}\n```", "```js\n\nstart() {\n    this.animationGroup.start(this.loopAnimation);\n}\nstop() {\n    this.animationGroup.stop();\n}\n```", "```js\n\nconst animationFps = 30;\nconst flipAnimation = new Animation(\"flip\", \"rotation.x\",\n  animationFps, Animation.ANIMATIONTYPE_FLOAT, \n  ANIMATIONLOOPMODE_CONSTANT, true);\nconst fadeAnimation = new Animation(\"entranceAndExitFade\",\n  \"visibility\", animationFps,\n  Animation.ANIMATIONTYPE_FLOAT,\n  Animation.ANIMATIONLOOPMODE_CONSTANT, true);\nconst scaleAnimation = new BABYLON.Animation(\"scaleTarget\",\n  \"scaling\", animationFps, Animation.ANIMATIONTYPE_VECTOR3,\n  Animation.ANIMATIONLOOPMODE_CYCLE, true);\n```", "```js\n\nconst splashScreen = new SplashScene(engine);\nsplashScreen.onReadyObservable.add(() =>\n  splashScreen.run());\nreturn splashScreen.scene;\n```", "```js\n\nrun() {\n    this.currentSegment.start();\n    let prior, curr = this.currentSegment;\n    this.onUpdate = this.scene.onBeforeRenderObservable\n    .add(() => {\n        if (this.skipRequested) {\n            this?.currentSegment.stop();\n            this.currentSegment = null;\n            return;\n        }\n        curr = this.currentSegment;\n        if (prior !== curr) {\n            this.currentSegment?.start();\n        }\n    });\n}\n```", "```js\n\nconst scene = this.scene = new Scene(engine);\nscene.clearColor = Color3.Black();\nthis.camera = new ArcRotateCamera(\"camera\", 0, Math.PI / 2,\n  5, Vector3.Zero(), scene);\nthis.light = new HemisphericLight(\"light\", new Vector3(0,\n  1, 0), scene);\nthis.light.groundColor = Color3.White();\nthis.light.intensity = 0.5;\nconst billboard = this.billboard =\n  PlaneBuilder.CreatePlane(\"billboard\", {\n    width: 5,\n    height: 3\n}, scene);\nbillboard.rotation.z = Math.PI;\nbillboard.rotation.x = Math.PI;\nbillboard.rotation.y = Math.PI / 2;\nconst billMat = new StandardMaterial(\"stdMat\", scene);\nbillboard.material = billMat;\n```", "```js\n\n        const start = 0;\n        const enterTime = 2.5;\n        const exitTime = enterTime + 2.5;\n        const end = exitTime + 2.5;\n```", "```js\n\n        const entranceFrame = enterTime * animationFps;\n        const beginExitFrame = exitTime * animationFps;\n        const endFrame = end * animationFps;\n```", "```js\n\nconst keys = [\n            { frame: start, value: 0 },\n            { frame: entranceFrame, value: 1 },\n            { frame: beginExitFrame, value: 0.998 },\n            { frame: endFrame, value: 0 }\n        ];\n        fadeAnimation.setKeys(keys);\n        const flipKeys = [\n            { frame: start, value: Math.PI },\n            { frame: entranceFrame, value: 0 },\n            { frame: beginExitFrame, value: Math.PI },\n            { frame: endFrame, value: 2 * Math.PI }\n        ];\n        flipAnimation.setKeys(flipKeys);\n```", "```js\n\nconst seg0 = new CutSceneSegment(this.billboard,\n  this.scene, fadeAnimation, flipAnimation);\nreturn seg0;\n```", "```js\n\n        poweredBy.onEnd.addOnce(() => {\n            console.log(\"powered End\");\n            billMat.diffuseTexture = babylonTexture;\n            billboard.rotation.x = Math.PI;\n            this.light.intensity = 0.667;\n            billboard.visibility = 0;\n            this.currentSegment = babylonBillboard;\n        });\n```", "```js\n\n// ... create billboard textures used in segments\nlet callToActionTexture = \n    this.callToActionTexture =\n      BABYLON.GUI.AdvancedDynamicTexture.\n      CreateFullscreenUI(\"splashGui\");\nlet ctaBlock = new TextBlock(\"ctaBlock\", \n    \"Press any key or tap the screen to continue...\");\nctaBlock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;\nctaBlock.color = \"white\";\nctaBlock.fontSize = \"16pt\";\nctaBlock.verticalAlignment = \n    ctaBlock.textVerticalAlignment =\n      TextBlock.VERTICAL_ALIGNMENT_BOTTOM;\nctaBlock.paddingBottom = \"12%\";\nctaBlock.isVisible = false;\ncallToActionTexture.addControl(ctaBlock);\n// ... call the builder functions\n// ... Attach onEnd delegates\n```", "```js\n\nconst inputControlsMap = {\n    /* Keyboard Mappings */\n    w: 'MOVE_UP', 87: 'MOVE_UP',\n    s: 'MOVE_DOWN', 83: 'MOVE_DOWN',\n    a: 'MOVE_LEFT', 65: 'MOVE_LEFT',\n    d: 'MOVE_RIGHT', 68: 'MOVE_RIGHT',\n    //...\n    PointerTap: 'ACTIVATE',\n    //...\n    button1: 'ACTIVATE', buttonStart: 'ACTIVATE',\n    buttonBack: 'GO_BACK', button2: 'GO_BACK',\n    dPadDown: 'MOVE_DOWN', lStickDown: 'MOVE_DOWN',\n};\nexport default { inputControlsMap, ...};\n```", "```js\n\nconst gamePadControlMap = {\n    /* deviceType */\n    2: [\n        { 0: 'button1' }, // BABYLON.Xbox360Button.A\n        { 1: 'button2' },\n        { 2: 'button3' },\n        { 3: 'button4' }\n    ]\n};\n```", "```js\n\nregisterInputForScene(sceneToRegister) {\n    logger.logInfo(\"registering input for scene\",\n      sceneToRegister);\n    const inputSubscriptions = this.inputSubscriptions;\n    const registration = {\n        scene: sceneToRegister, subscriptions: [\n            this.enableKeyboard(sceneToRegister),\n            this.enableMouse(sceneToRegister),\n            this.enableGamepad(sceneToRegister)\n        ]\n    };\n    sceneToRegister.onDisposeObservable.add(() =>\n      this.unregisterInputForScene(sceneToRegister));\n    inputSubscriptions.push(registration);\n    sceneToRegister.attachControl();\n}\n```", "```js\n\nconst checkInputs = () => {\n    const iMap = this.inputMap;\n    if (!this.gamepad) { return; }\n// handle quantitative or input that reads between 0 and 1\n//(on/off) inputs are handled by the onButton/ondPad Observables\n    let LSValues = SpaceTruckerControls\n        .normalizeJoystickInputs(this.gamepad.leftStick);\n    SpaceTruckerControls\n        .mapStickTranslationInputToActions(LSValues, iMap);\n    let RSValues = SpaceTruckerControls\n        .normalizeJoystickInputs(this.gamepad.rightStick);\n\n    SpaceTruckerControls\n        .mapStickRotationInputToActions(RSValues, iMap);\n};\n```", "```js\n\nreturn {\n            checkInputs,\n            dispose: () => {\n                this.gamepad = null;\n                manager.onGamepadConnectedObservable\n                   .remove(gamepadConnectedObserver);\n                manager.onGamepadDisconnectedObservable\n                   .remove(gamepadDisconnectedObserver);\n            }\n        };\n```", "```js\n\ngetInputs(scene) {\n    const sceneInputHandler = this.inputSubscriptions\n          .find(is => is.scene === scene);\n    if (!sceneInputHandler) {\n        return;\n    }\n    sceneInputHandler.subscriptions\n        .forEach(s => s.checkInputs());\n    const im = this.inputMap;\n    const ik = Object.keys(im);\n    const inputs = ik\n        .map((key) => {\n            return { \naction: controlsMap[key], \nlastEvent: im[key] \n            };\n        });\n    if (inputs && inputs.length > 0) {\n        this.onInputAvailableObservable\n            .notifyObservers(inputs);\n    }\n    return inputs;\n}\n```", "```js\n\nattachControl() {\n    if (!this.controlsAttached) {\n        this.scene.attachControl();\n        this.inputManager.registerInputForScene(this.scene);\n        this.onInputObserver =\n          this.inputManager.onInputAvailableObservable\n        .add((inputs) => {\n           this.inputAvailableHandler(inputs);\n        });\n        this.controlsAttached = true;\n    }\n}\n```", "```js\n\nupdate() {\n    if (!this.controlsAttached) {\n        return;\n    }\n    this.inputManager.getInputs(this.scene);\n    this.lastActionState = this.actionState;\n    const inputQueue = this.inputQueue;\n    while (inputQueue.length > 0) {\n        let input = inputQueue.pop();\n        this.inputCommandHandler(input);\n    }\n}\n```", "```js\n\ninputCommandHandler(input) {\n    input.forEach(i => {\n        const inputParam = i.lastEvent;\n        const actionFn = this.actionMap[i.action];\n        if (actionFn) {\n            const priorState = this.lastActionState \n                ? this.lastActionState[i.action] : null;                  \n            this.actionState[i.action] =\n              actionFn({priorState}, inputParam);\n        }\n    });\n}\n```", "```js\n\nbuildActionMap(actionList, createNew) {\n    if (createNew) {\n        this.actionMap = {};\n    }\n    actionList.forEach(actionDef => {\n      const action = actionDef.action;\n        const actionFn = this.screen[action];\n        if (!actionFn) {\n            return;\n        }\n        this.actionMap[action] = actionDef.shouldBounce() ? \n             bounce(actionFn, 250, this) : actionFn;\n    });\n}\n```", "```js\n\nMOVE_UP(state) {\n    logger.logInfo(\"MOVE_UP\");\n    const lastState = state.priorState;\n    if (!lastState) {\n        const oldIdx = this.selectedItemIndex;\n        const newIdx = oldIdx - 1;\n        this.selectedItemIndex = newIdx;\n    }\n    return true;\n}\n```", "```js\n\nACTIVATE(state) {\n    const lastState = state.priorState;\n    if (!this.skipRequested && !lastState) {\n        logger.logInfo(\"Key press detected. Skipping cut\n          scene.\");\n        this.skipRequested = true;\n        return true;\n    }\n    return false;\n}\n```"]