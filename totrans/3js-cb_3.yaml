- en: Chapter 3. Working with the Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera follow an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming the camera to an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a perspective camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an orthographic camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 2D overlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating the camera around a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the rendered view to a resized browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting world coordinates to screen coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an object in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important objects in Three.js is the camera. With the camera,
    you define what part of the scene will be rendered and how the information will
    be projected on the screen. In this chapter, we'll show you a number of recipes
    that will allow you to add more complex camera functionality to your Three.js
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera follow an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are creating games or visualizations with many moving objects, you
    might want to have the camera follow an object around. Normally, when you create
    a camera, it points to a single position and shows you the scene that falls within
    its field of view. In this recipe, we'll explain how you can create a camera that
    can follow any of your objects around.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe only makes use of core Three.js functions, so there isn''t any
    need to include external JavaScript libraries in your source code. If you want
    to see the final result of this recipe, you can open `03.01-camera-follow-object.html`
    in your browser, and you''ll see something similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see that the camera is focused on the sphere. As the
    sphere moves across the scene, the camera moves around to stay focused on the
    position of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we only need to take three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the object that we want to follow.
    For this recipe, we create a simple `THREE.SphereGeometry` object and add it to
    the scene like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in this short code snippet, we don't need to do anything special
    with the object we want to follow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is that we need a camera that renders the scene and stays focused
    on the object we want to follow. The following JavaScript creates and positions
    this camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a standard `THREE.PerspectiveCamera` object, which we also use in most
    of the other examples in this chapter. Once again, no special configuration is
    required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the final step, we define the render loop that will render the scene and
    also point the camera in the right direction for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `render` function, we use the `camera.lookAt` function to point the camera
    to the `position` function of the sphere. As we do this in every frame that we
    render, it will look like camera is exactly following the position of sphere.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.PerspectiveCamera` extends from the `THREE.Object3D` object. `THREE.Object3D`
    provides the `lookAt` function. When this function is called with the target position
    to look at, Three.js creates a transformation matrix (`THREE.Matrix4`) that aligns
    the position of the `THREE.Object3D` object with the target''s position. In the
    case of the camera, the result is that the target object is followed around the
    scene by the camera and is rendered in the middle of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the `lookAt` function to point a camera to a specific
    object. You can apply this same recipe for all the Three.js objects that extend
    from Object3D. For instance, you can use this to make sure `THREE.SpotLight` always
    illuminates a specific object. Or, if you're creating animations, you could use
    this effect to make sure one character is always looking at the face of a different
    character.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `lookAt` function uses matrix transformations to point one object to
    another, you could also do this without making use of the `lookAt` function. For
    this, you'll have to create a transformation matrix yourself. We've explained
    how to do this in the *Applying matrix transformations* recipe, which you can
    find in [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming the camera to an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, when you position a camera in your scene, you might move it around
    a bit or let it focus on different objects. In this recipe, we'll show you how
    you can zoom in to an object so that it almost fills the rendered view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To zoom in, we use the standard functionality from the `THREE.PerspectiveCamera`
    object. We''ve provided an example that demonstrates the result you''ll get at
    the end of this recipe. To experiment with this example, open `03.02-zoom-camera-to-object.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Initially, you''ll see a small rotating cube in the center of the scene. If
    you click on the `updateCamera` button in the menu in the top-right section, the
    camera will update and show you the rotating cube fullscreen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To zoom the camera to an object, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create and position the camera that we use
    to zoom in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this is a standard `THREE.PerspectiveCamera` object, to which
    we give a position and add to the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To zoom in with the camera, we first need to determine the distance from the
    camera to the object and its height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code snippet, we used `THREE.BoundingBoxHelper` to determine
    the `realHeight` function of cube and its distance to the camera.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this information, we can determine the field of view (`fov`) for the camera
    so that it only shows the cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What you can see in this code fragment is that we use one additional value,
    which is `control.correctForDepth`, to calculate the field of view. This value,
    which is set in the menu in the top-right section in the example, increases the
    resulting field of view slightly. We do this because in this calculation, we assume
    that the camera is facing the object straight on. If the camera isn't looking
    straight at the object, we need to compensate for this offset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got the field of view for the camera, we can assign this value
    to the `camera.fov` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As Three.js caches the `fov` property of the camera, we need to inform Three.js
    that the camera configuration has some changes. We do this with the `updateProjectionMatrix`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, the camera is completely zoomed in on the object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how this works, we need to understand what the field of view
    property of a `THREE.PerspectiveCamera` object does. The following figure shows
    you the field of view property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in this figure, there is a separate horizontal and vertical field
    of view. Three.js only allows you to set the vertical one, and the horizontal
    field of view is determined based on the aspect ratio you define on a camera.
    When you look at this figure, you can also directly see how this recipe works.
    By changing the field of view, we shrink the near and far planes and limit what
    is being rendered, and this way, we can zoom in.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an alternative way of zooming in besides the one shown here. Instead
    of changing the `fov` property of the camera, we can also move the camera closer
    to the object. In the latest version of Three.js, a `zoom` property is introduced;
    you can also use this property to zoom in on a scene, but you can't use it directly
    to zoom in on a single object.
  prefs: []
  type: TYPE_NORMAL
- en: Using a perspective camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js provides two cameras: a camera that renders the scene with a perspective
    projection (as we see images in the real world) and a camera that renders the
    scene with an orthogonal projection (fake 3D often used in games; for more information
    on this type of camera, check out the upcoming *Using an orthographic camera*
    recipe). In this recipe, we''ll look at the first of these two cameras and explain
    how you can use the perspective camera in your own scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with the properties of a camera can be a bit confusing at times. To
    help you better understand the steps or this recipe, we''ve created a simple page
    that shows you the effect each of the camera properties has. Open up `03.03-use-an-perspective-camera.html`
    in the browser, and you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the last four properties available in the menu in the top-right section,
    you can set the properties of `THREE.PerspectiveCamera`, which is used to render
    this scene, and see the effect of each property immediately.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we set up each of the camera properties separately. These properties
    can also be passed in with the constructor of `THREE.PerspectiveCamera`. In the
    *There's more…* section of this recipe, we'll show you how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up `THREE.PerspectiveCamera` completely, we need to perform a couple
    of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is instantiate the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates the camera instance, which we configure in the upcoming steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a camera, we first need to define the aspect ratio between
    the width of the viewport and the height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our recipe, we use the full width and height of the browser, so we specify
    the aspect ratio for the camera based on the `window.innerWidth` and `window.innerHeight`
    properties. If we use a `div` element with a fixed width and height, you should
    use the ratio between these values as the `aspect` function for the camera.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next two properties we need to define are the `near` and `far` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two properties define the area of the scene that this camera will render.
    With these two values, the camera will render the scene starting from a distance
    of `0.1` to a distance of `1000` from the position of the camera.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last of the properties that can be defined is the (vertical) field of view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property defines, in degrees, the area that the camera *sees*. For instance,
    humans have a horizontal field of view of 120 degrees, while in video games, often
    a field of view of around 90 or 100 degrees is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever you update one of these four properties of the camera, you have to
    inform Three.js about such a change. You do this by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, all that is left to do is position the camera and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we can use this camera with any of the available renderers to
    render a scene like this: `renderer.render(scene, camera)`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to understand how these properties affect what is rendered on
    screen is by looking at the following figure, which shows you these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The position of **Near plane** in this figure is based on the `near` property
    of the camera. **Far plane** is based on the `far` property and the *fov* shown
    in the figure corresponds to the `fov` property. With the `fov` property, you
    define the vertical field of view. The horizontal field of view is based on the
    aspect ratio, which you define with the `aspect` property on the camera.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we set each of the properties separately. `THREE.PerspectiveCamera`
    also provides a constructor that you can use to set all these properties in one
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Also remember that `THREE.PerspectiveCamera` extends from the standard Three.js
    `THREE.Object3D` object. This means that this camera can be rotated and moved
    around just like any other object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Zooming the camera to an object* recipe, we used the `fov` property
    of the camera to zoom in on an object, and in the *Using an orthographic camera*
    recipe, we will show you the second of the two cameras provided by Three.js, which
    is `THREE.OrthographicCamera`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an orthographic camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, you'll use `THREE.PerspectiveCamera` to render your scene. With
    such a camera, the result is a scene with a realistic-looking perspective. Three.js
    provides an alternative camera with `THREE.OrthographicCamera`. This camera uses
    an orthographic projection to render the scene. With this type of projection,
    all objects have the same size regardless of their distance to the camera. This
    is in contrast to `THREE.PerspectiveCamera`, where objects that are further away
    from the camera appear smaller. This was used often for fake 3D in games such
    as the Sims or older versions of SimCity (image taken from [http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg](http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an orthographic camera](img/1182OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we'll show you how to configure `THREE.OrthographicCamera` so
    that you can create this fake 3D effect for your own scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, the only object from Three.js we use is `THREE.OrthographicCamera`.
    This camera is available in the standard Three.js distribution, so there is no
    need to include any external JavaScript files. We've provided an example that
    shows the Three.Orthographic Camera in action. You can use this camera to better
    understand the properties you can use to configure the camera. If you open `03.04-use-an-orthographic-camera.html`,
    you can see a number of cubes that are rendered with `THREE.OrthographicCamera`.
    With the menu in the top-right section, you can tune the configuration of the
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at the steps you need to take to set up this camera.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up an orthographic camera in Three.js, we need to perform a couple of
    very simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the camera instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates `THREE.OrthographicCamera`, which is configured with some default
    values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to define the boundaries for this camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines the area that is rendered by this camera. In the *There's more…*
    section of this recipe, we'll explain how this works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we have to set the `near` and `far` properties of the camera. These
    properties define which distance from the camera is rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we don''t pass in the arguments in the constructor, we have to inform
    Three.js that we changed the camera''s parameter. For this, we have to add the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to position and align the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can just use this camera like any other camera and render a scene like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to understand how this camera works is by looking at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The box you see in this figure is the area an orthographic camera renders. In
    this figure, you can also see the `left`, `right`, `top`, and `bottom` properties
    we defined on the camera, which define the boundaries of this box. The final two
    properties, which are `near` and `far`, are used to define the near plane and
    the far plane. With these six properties, we can define the complete box that
    is rendered with `THREE.OrthographicCamera`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also configure `THREE.OrthographicCamera` by passing in these arguments
    in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An added advantage is that this way, you don't need to explicitly call `camera.updateProjectionMatrix()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Three.js provides two types of camera. If you want to use `THREE.PerspectiveCamera`
    instead, look at the *Using a perspective camera* recipe, where the steps that
    you need to take to create and configure a perspective camera are explained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 2D overlay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most recipes, we only focus on the 3D aspect of Three.js. We show recipes
    that explain how 3D objects and scenes are rendered, how they can be viewed with
    different cameras, and how you can change how they look through materials. When
    you are creating games, you usually also have a 2D layer on top of your 3D scene.
    You can use this to show health bars, 2D maps, inventory, and much more. In this
    recipe, we'll show you how to create a 2D overlay using `THREE.OrthogonalCamera`
    and `THREE.PerspectiveCamera` together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we require an image that we will use as an overlay. To demonstrate
    this recipe, we create a simple image that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this recipe, we''ll combine this static image with a 3D scene to create
    the scene that can be seen by opening the `03.05-create-an-hud-overview.html`
    example in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see that we've got a 3D rotating scene with a static
    2D overlay on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the steps you need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating the 2D overlay. The overlay we use in this recipe
    is the one with a fixed width and height (800 by 600). So, before we create the
    cameras, let''s first create the `div` variable that serves as container for the
    rendered scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create the camera that we use to render the overlay. For this,
    we require `THREE.OrthographicCamera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WIDTH` and `HEIGHT` properties are defined as constants with values of
    800 and 600\. This code fragment creates and positions a standard `THREE.OrthographicCamera`
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the 2D overlay, we create a separate scene where we put the 2D elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only thing we want to add to the 2D scene is the overlay image we showed
    in the *Getting ready* section of this recipe. As it''s a 2D image, we''ll use
    a `THREE.Sprite` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`THREE.Sprite` is always rendered in the same size (1 by 1 pixels) regardless
    of its distance to the camera. To make the sprite fullscreen, we scale the *x*
    axis with 800 (`WIDTH`) and the *y* axis with 600 (`HEIGHT`). With `THREE.SpriteMaterial`,
    which we used in the previous code fragment, we point to the overlay image so
    that it is shown when we add `THREE.Sprite` to the scene.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we''ve got `THREE.OrthogonalCamera` and `THREE.Scene`, which
    show you the overlay as an 800 by 600 image. The next step is to create the 3D
    screen on which we want to apply this overlay. You don''t have to do anything
    special here; you can create a 3D scene by defining `THREE.PerspectiveCamera`
    and `THREE.Scene` and adding some lights and objects. For this recipe, we assume
    you''ve got a camera and a scene with the following names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we move to the render loop where we define that we want to render the
    2D scene as an overlay, we need to configure an additional property on the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On `THREE.WebGLRenderer`, we set the `autoclear` property to `false`. This means
    that the screen isn't automatically cleared before renderer renders a scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step is to alter the render loop. We first want to render the 3D
    scene, and without clearing the 3D-rendered output, render the overlay on the
    top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do in the render loop is clear the current output by calling
    the `clear` function on the renderer. We need to do this, as we disabled `autoclear`
    on renderer. Now, we render the 3D scene, and before we render the 2D overlay,
    we call the `clearDepth` function on the renderer. This makes sure the 2D overlay
    is rendered completely on top and won't intersect at places with the 3D scene.
    So finally, we render the 2D overlay by passing in `orthoScene` and `orthoCamera`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How this recipe works is actually very simple. We can use the same renderer
    to render multiple scenes with multiple different cameras in the same render loop.
    This way, we can position various render results on top of each other. With a
    `THREE.OrthoGraphic` camera and `THREE.Sprite`, it is easy to position an object
    at absolute positions on screen. By scaling it to the required size and applying
    a texture, we can display images using a renderer. This output, combined with
    a regular 3D result, allows you to create these kinds of overlays.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of recipes that use an orthographic camera and more advanced
    tricks to compose the final rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored how to set up `THREE.OrthographicCamera` in the
    *Using an orthographic camera* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*, we'll show how you can use an HTML5 canvas and a HTML5 video as an
    input to a texture in the *Using HTML canvas as a texture* and *Using an HTML
    video as a texture* recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [chapter 6](ch06.html "Chapter 6. Point Clouds and Postprocessing"), *Point
    Clouds and Postprocessing*, we show you how to set up a more complex rendering
    pipeline in the *Setting up a postprocessing pipeline* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating the camera around a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we already showed you a number of recipes that explained how to rotate
    objects. In this recipe, we'll show you how to rotate the camera around a scene
    while the camera will keep looking at the center of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll use the standard `THREE.PerspectiveCamera` object, which
    we rotate around a simple scene. To see the final result, open the `03.08-rotate-camera-around-scene-y-axis.html`
    example in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this web page, you can see that the camera rotates around the scene while
    the floor, box, and lights stay at the same position.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this, we only need to perform a couple of very simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create `THREE.PerspectiveCamera` and position
    it somewhere in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To rotate the camera, we recalculate its position in the render loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this render function, we update the `camera.position.x` and `camera.position.z`
    variables, and by calling `camera.lookAt(scene.position)`, we make sure we keep
    looking at the center of the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we do here is some basic vector math. We execute a very small rotation
    of the camera using a rotation matrix. However, instead of the 3D and 4D matrices
    we used in other recipes, we just use a 2D matrix this time (represented with
    the two calculations in the **render** loop). After the rotation, we just need
    to make sure the camera is still looking at the correct position, so we use the
    `lookAt` function (which once again, internally uses matrix calculations to determine
    how to align the camera to the scene).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we rotated around the scene's *y* axis. This results in a very
    smooth animation where the camera circles around the scene. We could, of course,
    also apply this to the other axes. We provided an example that you can view in
    the sources provided with this book. If you open `03.08-rotate-camera-around-scene-x-axis.html`
    in your browser, the camera rotates around the *x* axis instead of the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change you have to make is change the calculations in the render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you look at this example in your browser, you might notice something strange.
    At a certain point, it'll look like the camera jumps around. The reason is that
    the camera tries to stay the right-side up, so it quickly changes orientation
    when it is at the top or bottom of its rotation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we already discussed some rotation-related recipes. If you want to learn
    more about rotation or the matrix calculations required for it, look at the following
    recipes from [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rotating an object around its own axis*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rotating an object around a point in space*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying matrix transformations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the rendered view to a resized browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you define a camera in Three.js, you need to define the aspect ratio; for
    a renderer, you need to define its output size. Normally, you do this once when
    you set up your initial scene. This works great until the user resizes their browser.
    In this case, the aspect ratio for the camera will probably change, as will the
    output size for the renderer. In this recipe, we'll show you the steps you need
    to take to react to changes to the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with every recipe, we provide an example that you can use to test and experiment
    with for this recipe as well. Open `03.06-change-the-camera-on-screen-resize.html`
    in your browser and make the screen very small.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What you see is that the same amount of information is shown in the scene—only
    rendered smaller. When you now increase the screen size again, you'll see that
    Three.js always uses the complete available space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll add a resize handler to the web page, which reacts to
    resize events. Adding this handler only takes a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to add is the function that we call when the resize
    event occurs. The following code fragment shows you the `onResize` function that
    we will call in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we first recalculate the aspect ratio for the camera based
    on the new width and height. As Three.js caches certain aspects of the camera,
    we have to call the `updateProjectionMatrix()` function next to make sure the
    new aspect ratio is used. We also change the size for the renderer to the new
    width and height, so the complete screen space is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got our update function, we need to define an event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we add an event listener for the `resize` event. So whenever
    the screen is resized, the provided function, which is `onResize`, will be called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever something happens within a browser (a button is clicked on, the mouse
    is moved, the window is resized, and so on), browsers will throw an event. From
    JavaScript, you can register listeners to these events so that you can respond
    to them. In this recipe, we use the `resize` event to listen to any change in
    the window size. For more information on this event, you can look at the excellent
    documentation Mozilla provides at [https://developer.mozilla.org/en-US/docs/Web/Events/resize](https://developer.mozilla.org/en-US/docs/Web/Events/resize).
  prefs: []
  type: TYPE_NORMAL
- en: Converting world coordinates to screen coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are creating a game that provides a 2D interface on top of a 3D world,
    for instance, as shown in the *Creating a 2D overlay* recipe, you might want to
    know how the 3D coordinates map to your 2D overlay. If you know the 2D coordinates,
    you can add all kinds of visual effects to the 2D overlay, such as tracking the
    code or letting the 2D overlay interact with the objects in the 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don''t need to perform any steps to get ready for this recipe. In this
    recipe, we can use the `THREE.Projector` object available in Three.js to determine
    the correct coordinates. You can view the result from this recipe in action by
    opening `03.07-convert-world-coordintate-to-screen-coordinates.html` in your browser
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The box appears at random positions when you open this example. When you click
    on the **calculateScreenCoordinate** button in the menu in the top-right section,
    the *x* and *y* coordinates of the center of the box will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert world coordinates to screen coordinates, we use a couple of internal
    Three.js objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first object we need is `THREE.Projector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we use this projector to project the position of the cube onto the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `vector` variable will now contain the position of the object as it is seen
    by the `camera` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you project a vector, as we did in step two, the resulting *x* and *y*
    values range from -1 to 1\. So in this final step, we convert these values to
    the current screen width and height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, the `vector` variable will contain the screen coordinates of
    the center of `object`. You can now use these coordinates with standard JavaScript,
    HTML, and CSS to add effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the same effect that Three.js uses to render the scene.
    When you render a scene, the objects are projected onto a camera, which determines
    what area needs to be rendered and where the objects appear. With the projector
    class, we can perform this projection for a single vector. The result is the position
    of this vector in two dimensions based on the used camera.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we converted world coordinates to screen coordinates. This is
    actually rather easy, as we've got all the information (in three dimensions) to
    correctly determine the coordinates (in two dimensions). In the *Selecting an
    object in the scene* recipe, we convert a screen coordinate to a world coordinate,
    which is harder to do, as we don't have any depth information we can use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an object in the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement for Three.js applications is to interact with the scene.
    You might create a shooter where you want to use the mouse for aiming or an RPG
    where you need to interact with your environment. In this recipe, we'll show you
    how you can use the mouse to select objects that are rendered on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply this effect, we'll need a scene where we can select some objects. For
    this recipe, we've provided an example, which is `03.10-select-an-object-in-the-scene.html`.
    If you open this file in your browser, you'll see a number of objects moving around
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use your mouse to select any of the objects on screen. The first time
    you click on them, they'll become transparent, and the next time, they'll become
    solid again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need to work through a couple of steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is set up the mouse listener. We want to fire
    a JavaScript function each time the mouse button is clicked on. To do this, we
    register the following listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will tell the browser to fire the `onDocumentMouseDown` button whenever
    a `mousedown` event is detected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we define the `onMouseDown` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will be called when you push the left mouse button. In the upcoming
    steps, we'll show you what to put into this function to detect which object is
    selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing we need to do is convert the *x* and *y* coordinates of the
    mouse click to a position that `THREE.PerspectiveCamera` can understand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, vector will contain the *x* and *y* coordinates in coordinates
    the camera and Three.js understands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can use another Three.js object, which is `THREE.Raycaster`, to determine
    which objects in our scene might be located at the position we clicked on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we first create `THREE.Raycaster` and use the `intersectObjects` function
    to determine whether `sphere`, `cylinder`, or `cube` are selected. If an object
    is selected, it will be stored in the `intersects` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can process the `intersects` array. The first element will be the element
    closest to the camera, and in this recipe, this is the one we''re interested in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we just switch the opacity of an object whenever it is clicked
    on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That's it. With this setup, you can select objects using your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works by using `THREE.RayCaster`. With `THREE.RayCaster`, as the
    name implies, you shoot out a ray into the scene. The path of this ray is based
    on the properties of the camera, the position of the camera, and the objects provided
    to the `intersectObjects` function. For each of the provided objects, Three.js
    determines whether a ray cast using `THREE.RayCaster` can hit the specified object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting effect that can be added, and that better visualizes what is
    happening, is rendering the ray that is cast by `THREE.RayCaster`. You can very
    easily do this by just adding the following to step 5 of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing too special in this code fragment. We just draw a line from
    the position of the camera (with a small offset to the *y* axis, or else we don''t
    see anything) to the position where the ray intersects. The result, which you
    can also see in the example discussed in the *Getting ready* section of this recipe,
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more](img/1182OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we convert a 2D coordinate into a 3D one. In the *Converting
    world coordinates to screen coordinates* recipe, we explain how to do the opposite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
