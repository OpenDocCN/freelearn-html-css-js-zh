- en: Chapter 3. Multiplayer Game API – Connect 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 多人游戏API – 连接4
- en: Connect 4 is a turn-based two-player game, where each player would drop a chip
    down a column, with the objective to get four chip of the same color in a row.
    It can be vertical, horizontal, or diagonal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 连接4是一个回合制的两人游戏，每个玩家会向下投掷一个棋子，目标是让同一颜色的四个棋子连成一线。可以是垂直、水平或对角线。
- en: In this chapter, we will build Connect4-as-a-Service. An API that allows you
    to build a game of Connect 4 on any client, be it a website, mobile app, or just
    play it from the command line; why not?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建Connect4-as-a-Service。一个API，允许你在任何客户端上构建一个Connect 4游戏，无论是网站、移动应用，还是从命令行玩；为什么不呢？
- en: In [Chapter 1](ch01.html "Chapter 1. Building a Basic Express Site"), *Building
    a Basic Express Site*, and [Chapter 2](ch02.html "Chapter 2. A Robust Movie API"),
    *MMO Word Game*, we covered the most generic use cases for an Express backed API,
    which is to serve and persist data to and from a database. In this chapter, we'll
    cover something more fun. We'll build a multiplayer game API!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 构建基本的Express网站")，*构建基本的Express网站*和[第2章](ch02.html "第2章.
    丰富的电影API")，*MMO文字游戏*中，我们介绍了Express支持的API最通用的用例，即从数据库中服务和持久化数据。在本章中，我们将介绍一些更有趣的内容。我们将构建一个多人游戏API！
- en: Some topics that will be covered include authentication, game state modeling,
    and validation middleware. Also, we will build an app using test-driven development
    with maximum code coverage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些主题包括身份验证、游戏状态建模和验证中间件。此外，我们将使用测试驱动开发构建一个具有最大代码覆盖率的app。
- en: 'For your reference, this is the folder structure of our app, which we will
    build throughout the chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的参考，这是我们应用文件夹的结构，我们将在本章中构建它：
- en: '![Multiplayer Game API – Connect 4](img/0818_03_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![多人游戏API – 连接4](img/0818_03_01.jpg)'
- en: How do you create a game? How do you join a game? How do you make a move? And
    how do you persist the game state in a DB?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何创建一个游戏？你如何加入一个游戏？你如何移动？以及你如何将游戏状态持久化到数据库中？
- en: It is always a good idea to start with the data structure. So let's get to it!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总是先从数据结构开始是一个好主意。那么，让我们开始吧！
- en: Modeling game state with Mongoose
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose建模游戏状态
- en: 'We will represent the board as a 2-dimensional array, with the values being
    `''x''`, `''o''`, or `'' ''`, representing the three possible states for each
    location on the grid. Here''s an example, where player 2 wins the game:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用二维数组来表示棋盘，其中的值是 `'x'`、`'o'` 或 `' '`，代表网格上每个位置的三个可能状态。以下是一个示例，其中玩家2赢得了游戏：
- en: '![Modeling game state with Mongoose](img/0818_03_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mongoose建模游戏状态](img/0818_03_02.jpg)'
- en: 'This game state would be represented in an array as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏状态将如下所示表示为一个数组：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This would suffice if the game were to be played locally with the state being
    stored in memory. In our case, we want to play on the internet, so we will need
    a way to identify which game we are playing, as well as which player you are,
    and whose turn it is. A game document would look as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏是在本地进行，并且状态存储在内存中，那么这将是足够的。在我们的情况下，我们想在互联网上玩游戏，所以我们需要一种方法来识别我们在玩哪个游戏，以及你是哪个玩家，以及轮到谁了。一个游戏文档将如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are the parameters:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是参数：
- en: '| Parameter | Description |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boardId` | This is a unique ID that you''ll need if you want to take a look
    at the current game state. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `boardId` | 如果你想要查看当前游戏状态，这将是一个唯一的ID。 |'
- en: '| `p1Key` | This is a secret token to identify player 1; we want to avoid the
    possibility of cheating of course |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `p1Key` | 这是一个用于识别玩家1的秘密令牌；我们当然想避免作弊的可能性 |'
- en: '| `p1Name` | This is player 1''s name |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `p1Name` | 这是玩家1的名字 |'
- en: '| `p2Key` | This is a secret token to identify player 2 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `p2Key` | 这是一个用于识别玩家2的秘密令牌 |'
- en: '| `p2Name` | This is a player 2''s name |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `p2Name` | 这是玩家2的名字 |'
- en: '| `turn` | This is the total number of turns played on this board |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `turn` | 这是这个棋盘上玩过的总回合数 |'
- en: '| `rows` | This is the number of rows of the game board |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `rows` | 这是游戏板的行数 |'
- en: '| `columns` | This is the number of columns of the game board |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `columns` | 这是游戏板的列数 |'
- en: '| `board` | This is the game state stored in a 2D array |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `board` | 这是一个存储在二维数组中的游戏状态 |'
- en: '| `status` | This is either Game in progress or Game Over. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `status` | 这将是“游戏进行中”或“游戏结束”。 |'
- en: '| `winner` | This is the name of the winner once the game is over |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `winner` | 游戏结束后，这是获胜者的名字 |'
- en: 'Let''s use the same app folder structure as was introduced in [Chapter 2](ch02.html
    "Chapter 2. A Robust Movie API"), *Building a Basic Express Site*, and let''s
    define the preceding as a Mongoose model in `src/models/game.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用与第 2 章[第 2 章。构建一个基本的 Express 网站](ch02.html "Chapter 2. Building a Basic
    Express Site")中介绍相同的 app 文件夹结构，并在 `src/models/game.js` 中定义前面的内容作为一个 Mongoose 模型：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a new game
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新游戏
- en: Now that we have defined the data structure of our game, let's start with implementing
    the logic to create and persist a new game document in the database, all the while
    following Test-Driven Development practices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了游戏的数据结构，让我们开始实现创建和持久化新游戏文档到数据库的逻辑，同时遵循测试驱动开发实践。
- en: 'In order to create a new game, we need to accept a POST to `/create` with your
    name in the POST body:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的游戏，我们需要接受一个 POST 请求到 `/create`，并在 POST 主体中包含你的名字：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few things we should think about:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑以下几点：
- en: We need to return the board information to the user, and whether or not game
    creation was successful
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将棋盘信息返回给用户，以及游戏创建是否成功
- en: We need to ensure the player can access the game they just created, so we must
    send them the `boardId`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保玩家可以访问他们刚刚创建的游戏，因此我们必须发送给他们 `boardId`
- en: In order for the player to identify themselves, we also need to ensure that
    we send them the `p1Key`, which will be needed for all future moves that Player
    One wishes to play to this board
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让玩家能够识别自己，我们还需要确保我们发送给他们 `p1Key`，这将用于玩家一未来想要在此棋盘上进行的所有移动
- en: Since we're building the game, we have the power to bend the rules of the game.
    So let's allow player 1 to optionally configure the size of the playing board!
    We should have a minimum size of 6x7, though.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建游戏，我们有权力改变游戏的规则。所以让我们允许玩家1可选地配置游戏棋盘的大小！尽管如此，我们应该有一个最小尺寸为 6x7。
- en: 'So let''s start with the tests for creating a game and fetch the game information:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从创建游戏和获取游戏信息的测试开始：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Throughout this chapter, we will use the `expect` assertion library. The only
    difference with `should` is the syntax, and the way it handles `undefined` more
    gracefully. The `should` library patches the object prototype, which means that
    if the object is undefined, it will throw a TypeError: Cannot read property should
    of undefined.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将使用 `expect` 断言库。与 `should` 的唯一区别是语法，以及它处理 `undefined` 的方式更为优雅。`should`
    库修补了对象原型，这意味着如果对象是 `undefined`，它将抛出 TypeError: Cannot read property ''should''
    of undefined。'
- en: The test will use supertest to simulate POSTing data to the `/create` endpoint,
    and we describe everything that we expect from the response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将使用 supertest 模拟向 `/create` 端点发送 POST 数据，并且我们描述了我们期望从响应中获取的所有内容。
- en: 'Now let''s create a `POST` route in `src/routes/games.js` to create a game
    in the database, and make the first test pass:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在 `src/routes/games.js` 中创建一个 `POST` 路由来在数据库中创建游戏，并使第一个测试通过：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that an API should always take care of all possible inputs, and make sure
    it return `400` error if it does not pass the input validation; more on this as
    follows.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，API 应该处理所有可能的输入，并确保在输入验证未通过时返回 `400` 错误；关于这一点将在以下内容中详细介绍。
- en: 'The `Utils.randomValueHex() method` will return a random string, which we use
    to generate a token as well as `boardId`. Instead of defining it in the preceding
    file, let''s package it up nicely in `src/lib/utils.js`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Utils.randomValueHex()` 方法将返回一个随机字符串，我们用它来生成令牌以及 `boardId`。而不是在前面文件中定义它，让我们在
    `src/lib/utils.js` 中将其包装得更好：'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the game logic of Connect4 is in `src/lib/connect4.js`, which you can find
    in the Appendix. We'll use that library to initialize the board.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Connect4 的所有游戏逻辑都在 `src/lib/connect4.js` 中，你可以在附录中找到它。我们将使用这个库来初始化棋盘。
- en: 'Also notice that rows and columns are optional arguments. We don''t want to
    be hardcoding the default values in the code, so we have the following `config.js`
    file in the root folder:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，行和列是可选参数。我们不希望在代码中硬编码默认值，因此我们在根目录中有一个 `config.js` 文件：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we initiate the app in `src/lib/app.js`, we can attach this `config` object
    onto the `app` object, so we have app-wide access to the config:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在 `src/lib/app.js` 中初始化应用程序时，我们可以将这个 `config` 对象附加到 `app` 对象上，这样我们就可以在应用程序范围内访问配置：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By now, your first pass should pass—congratulations! We can now be rest assured
    that the `POST` endpoint is working, and will keep working as expected. It's a
    great feeling because if we ever break something in the future, the test will
    fail. Now you don't have to worry about it anymore and focus on your next task.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到现在为止，你的第一次尝试应该通过了——恭喜！我们现在可以放心，`POST`端点是正常工作的，并且会按预期继续工作。这种感觉很好，因为如果我们将来破坏了某些东西，测试将会失败。现在你不再需要担心它了，可以专注于你的下一个任务。
- en: 'You do have to be diligent about getting as much code coverage as possible.
    For instance, we allow the client to customize the size of the board, but we have
    not written tests to test this feature yet, so let''s get right to it:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你确实需要勤奋地获取尽可能多的代码覆盖率。例如，我们允许客户端自定义棋盘大小，但我们还没有编写测试来测试这个功能，所以让我们立即着手：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should also enforce a minimum size of the board; otherwise, the game can''t
    be played. Remember how we defined `MIN_ROWS` and `MIN_COLUMNS` in the `config.js`
    file? We can reuse that in our tests as well, without having to resort to hardcoding
    the tests. Now if we want to be changing the minimum size of the game, we can
    do it one place! As given in the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该强制棋盘的最小尺寸；否则，游戏无法进行。还记得我们在`config.js`文件中定义了`MIN_ROWS`和`MIN_COLUMNS`吗？我们可以在测试中重用它，而无需硬编码测试。现在，如果我们想更改游戏的最小尺寸，我们可以在一个地方完成！如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As described in the preceding test cases, we should make sure that if the player
    is customizing the size of the board, that the size is not less than the minimum
    size. There are many more validation checks that we'll be doing, so let's start
    to get a bit more organized.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述测试用例所述，我们应该确保如果玩家正在自定义棋盘大小，那么大小不能小于最小尺寸。我们还将进行更多验证检查，所以让我们开始变得更加有条理。
- en: Input validation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: We should always check that the inputs we receive from a `POST` request are
    indeed what we expect, and return a `400` input error otherwise. This requires
    thinking about as many edge-case scenarios as possible. When an API is used by
    thousands of users, it is guaranteed that some users will abuse or misuse it,
    be it either intentional or unintentional. However, it is your responsibility
    to make the API as user-friendly as possible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终检查从`POST`请求接收到的输入是否确实是我们预期的，如果不是，则返回`400`输入错误。这需要尽可能多地考虑边缘情况。当一个API被成千上万的用户使用时，可以保证一些用户会滥用或误用它，无论是故意的还是无意的。然而，你的责任是尽可能使API对用户友好。
- en: The only input validation that we covered in the preceding `/create` route is
    to make sure that there is a name in the `POST` body. Now we can just add two
    more `if` blocks to cover the board-size cases to make the tests pass.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述`/create`路由中，我们唯一覆盖的输入验证是确保`POST`体中有一个名称。现在我们只需添加两个额外的`if`块来覆盖棋盘大小的情况，以便通过测试。
- en: In true TDD philosophy, you should write the least amount of code to make the
    tests pass first. They call it red-green-refactor. First, write tests that fail
    (red), make them pass as quickly as possible (green), and refactor after.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的TDD（测试驱动开发）哲学中，你应该首先编写最少的代码来使测试通过。他们称之为红-绿-重构。首先，编写失败的测试（红色），尽可能快地使其通过（绿色），然后重构。
- en: We urge you to try the preceding first. The following is the result after refactoring.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敦促你首先尝试上述代码。以下是在重构后的结果。
- en: 'A lot of the input validation checks would be useful across multiple routes,
    so let''s package it nicely as a collection of middleware in `src/lib/validators.js`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多输入验证检查可以在多个路由中使用，所以让我们将其优雅地打包成`src/lib/validators.js`中的中间件集合：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding packages three validation checkers in a reusable fashion. It returns
    an object with three middleware. Note how we DRYed up the code using a `private
    _return400Error` helper, to make it even cleaner.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码以可重用的方式打包了三个验证检查器。它返回一个包含三个中间件的对象。注意我们如何使用`private _return400Error`辅助函数来DRY（Don't
    Repeat Yourself）代码，使其更加简洁。
- en: 'Now we can refactor the `/create` route as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式重构`/create`路由：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will create a nice separation of concerns, where each of the routes that
    we will define will accept an array of (reusable!) validation middleware that
    it has to go through, before it reaches the controller logic of the route.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个很好的关注点分离，其中我们将定义的每个路由都将接受一个（可重用的！）验证中间件数组，它必须通过这些中间件，才能到达路由的控制逻辑。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure your tests still pass before you proceed with the next endpoint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一个端点之前，请确保你的测试仍然通过。
- en: Getting the game state
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取游戏状态
- en: Both players need a way to check on the state of a game that they are interested
    in. To do this, we can send a `GET` request to `/board/{boardId}`. This will return
    the current state of the game, allowing players to see the state of the board,
    as well as whose turn is next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两位玩家都需要一种方式来检查他们感兴趣的游戏的状况。为此，我们可以向`/board/{boardId}`发送`GET`请求。这将返回游戏的当前状态，允许玩家看到棋盘的状态，以及下一个轮到谁。
- en: 'We will create another endpoint to fetch a board, so let''s first write the
    test for that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个端点来获取棋盘，所以让我们首先为它编写测试：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we want to make sure that we don''t accidentally leak the player
    tokens. The response should be basically identical to the one received by the
    player that most recently made a move as given in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们想要确保我们不会意外地泄露玩家令牌。响应应该基本上与最近移动的玩家收到的响应相同，如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `_sanitizeReturn(game)` is a simple helper that just copies the game object,
    except for the player tokens.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_sanitizeReturn(game)`是一个简单的辅助函数，它只是复制游戏对象，除了玩家令牌。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Joining a game
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入游戏
- en: This game would be no fun if played alone, so we need to allow a second player
    to join the game.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个人玩这个游戏，那就没有意思了，所以我们需要允许第二个玩家加入游戏。
- en: 'In order to join a game, we need to accept `POST` to `/join` with the name
    of player2 in the `POST` body:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加入一个游戏，我们需要接受`POST`到`/join`，并在`POST`体中包含玩家2的名字：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this to work, we need to implement a rudimentary match-making system. An
    easy one is to simply have a queue of games in a joinable state, and popping one
    off when the `/join` API is hit. We chose to use Redis as our Queue implementation
    to keep track of the joinable games.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要实现一个基本的匹配系统。一个简单的方法是简单地有一个可加入状态的游戏队列，当`/join` API被调用时从中弹出。我们选择使用Redis作为我们的队列实现来跟踪可加入的游戏。
- en: Once a game is joined, we will send `boardId` and `p2Key` back to the player,
    so that they can play on this board with player 1\. This will intrinsically avoid
    a game to be joined multiple times.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦加入游戏，我们将向玩家发送`boardId`和`p2Key`，这样他们就可以与玩家1在这个板上玩游戏。这将内在地避免游戏被多次加入。
- en: 'All we need to do is add this line to push `boardId` onto the queue, once the
    game is created and stored in the DB:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的只是添加这一行，将`boardId`推入队列，一旦游戏在数据库中创建并存储：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We glanced over database connections when we showed `app.js`. The way to set
    up a MongoDB connection was covered in [Chapter 2](ch02.html "Chapter 2. A Robust
    Movie API"), *A Robust Movie API*. The following is how we''ll connect to a `redis`
    database in `src/lib/db.js`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们展示`app.js`时，我们浏览了数据库连接。在[第2章](ch02.html "第2章。一个健壮的电影API")中介绍了设置MongoDB连接的方法，*一个健壮的电影API*。以下是我们将在`src/lib/db.js`中连接到`redis`数据库的方式：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in production, we'll be connecting to Redis To Go (you can start with
    a 2MB instance for free). For local development, all you need to do is `redis.createClient()`.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在生产环境中，我们将连接到Redis To Go（你可以从免费的2MB实例开始）。对于本地开发，你所需要做的就是`redis.createClient()`。
- en: 'Now we can write the tests to join a game, TDD style:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写测试来加入游戏，TDD风格：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we flush the `redis` queue each time we run this test suite, just
    to make sure that the stack is empty. In general, it is a good idea to write atomic
    tests that can run on their own, without reliance on outside state.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们每次运行这个测试套件时都会刷新`redis`队列，只是为了确保栈是空的。一般来说，编写可以独立运行的原子测试是一个好主意，而不依赖于外部状态。
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Always remember to cover input the edge-cases! In the preceding test, we make
    sure that we cover the case that we have no games left to join. If not, we might
    crash the server or return the `500` error (which we should attempt to eradicate
    because that means it''s your fault, not the user!). Now let''s write the following
    code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是记得要覆盖输入的边缘情况！在前面的测试中，我们确保覆盖了没有剩余游戏可加入的情况。如果没有，我们可能会使服务器崩溃或返回`500`错误（我们应该尝试消除，因为这意味着这是你的责任，而不是用户的错误！）现在让我们编写以下代码：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These tests describe the core logic of creating a game and joining it. Enough
    tests to describe this endpoint. Let''s now write the accompanying code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些测试描述了创建游戏和加入游戏的核心逻辑。足够的测试来描述这个端点。现在让我们编写相应的代码：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We reuse the `Validate.name` middleware here to make sure that we have a name
    for player 2\. If so, we will look for the next joinable game in the queue. When
    there are no joinable games, we will return an appropriate `418` error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重用`Validate.name`中间件来确保我们为玩家2有一个名字。如果是这样，我们将寻找队列中的下一个可加入的游戏。当没有可加入的游戏时，我们将返回一个适当的`418`错误。
- en: If we successfully retrieve the next joinable `boardId`, we will fetch the board
    from the database, and store the name of player 2 in it. We also have to make
    sure that we do not return player 1's token along with the game object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功检索到下一个可加入的 `boardId`，我们将从数据库中获取棋盘，并在其中存储玩家 2 的名字。我们还要确保我们不将玩家 1 的 Token
    与游戏对象一起返回。
- en: Now that both players have fetched their respective tokens, let the games begin!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两位玩家都已经获取了各自的 Token，游戏可以开始了！
- en: Playing the game
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行游戏
- en: The game state is stored in the database and can be retrieved with a `GET` request
    to `/board/{boardId}`. The essence of making a move is a change to the game state.
    In familiar CRUD terms, we would be updating the document. Following REST conventions
    whenever possible, a `PUT` request to `/board/{boardId}` would be the logical
    choice to make a move.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态存储在数据库中，可以通过对 `/board/{boardId}` 的 `GET` 请求检索。移动的本质是对游戏状态的更改。在熟悉的 CRUD 术语中，我们将会更新文档。尽可能遵循
    REST 规范，对 `/board/{boardId}` 发送 `PUT` 请求将是进行移动的合逻辑选择。
- en: 'To make a valid move, a player needs to include an X-Player-Token in their
    request header matching that of the corresponding player, as well as a request
    body identifying which column to make a move in:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行有效的移动，玩家需要在他们的请求头中包含一个 X-Player-Token，该 Token 与对应玩家的 Token 匹配，以及一个请求体，指明要在哪个列进行移动：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, not all moves are legal, for example, we need to ensure that players
    only play moves when it is their turn. There are a few more things that need to
    be checked for every move:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有移动都是合法的，例如，我们需要确保玩家只能在他们的回合进行移动。对于每一次移动，还需要检查一些其他的事情：
- en: Is the move valid? Does the column parameter specify an actual column?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动是否有效？列参数是否指定了一个实际的列？
- en: Does the column still have space?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这列还有空间吗？
- en: Is the X-Player-Token a valid token for the current game?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-Player-Token 是否是当前游戏的合法 Token？
- en: Is it your turn?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮到你了？
- en: Did the move create a victory condition? Did this player win with this move?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一步是否创造了胜利条件？这位玩家是否通过这一步赢得了比赛？
- en: Did the move fill up the board and cause a draw game?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一步是否填满了棋盘并导致了平局？
- en: Now we will model all these scenarios.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将模拟所有这些场景。
- en: 'Let''s play a full game with the following tests:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用以下测试进行一整场游戏：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first test creates the game and the second test joins it. The next six tests
    are validation tests to make sure that the requests are valid.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个测试创建游戏，第二个测试加入游戏。接下来的六个测试是验证测试，以确保请求是有效的。
- en: 'Make sure that the X-Player-Token is present:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保X-Player-Token存在：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make sure that the X-Player-Token is the correct one:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保X-Player-Token是正确的：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make sure that the board you move on exists:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你移动的棋盘存在：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make sure that a column parameter is sent when making a move:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在移动时发送了列参数：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Make sure that the column is not off the board:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保列没有超出棋盘范围：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make sure that the wrong player cannot move:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保错误的玩家不能移动：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have covered all the validation cases, let''s test the entire game
    play:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有验证案例，让我们测试整个游戏流程：
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just a quick check that player 1 cannot move again, before player 2 makes a
    move:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家 2 移动之前，快速检查玩家 1 不能再次移动：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The remainder of this test suite plays out a full game. We won't show it all
    here, but you may refer to the source code. The last three tests are still interesting
    though because we cover the final game state and prevent any more moves.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本测试套件的剩余部分将进行一整场的游戏。我们不会在这里展示所有内容，但你可以参考源代码。尽管如此，最后三个测试仍然很有趣，因为我们涵盖了最终的游戏状态并阻止了任何更多的移动。
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we have described our expected behavior, let's begin with implementing
    the move endpoint.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经描述了预期的行为，让我们开始实现移动端点。
- en: First, let's cover the validation pieces, making the first 8 tests pass.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们覆盖验证部分，使前 8 个测试通过。
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We fetch the board that the move is sent to. If we cannot find the board, we
    should return a 400 error. This should make the test 'Cannot move on unknown board'
    pass.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取移动发送到的棋盘。如果我们找不到棋盘，我们应该返回一个 400 错误。这将使测试 'Cannot move on unknown board'
    通过。
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the game is over, you cannot make any moves.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏结束了，你不能进行任何移动。
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code will make sure that the token is either `p1Key` or `p2Key`.
    If not, return the `400` error with the according message:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将确保 Token 要么是 `p1Key`，要么是 `p2Key`。如果不是，返回带有相应信息的 `400` 错误：
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we have verified that the token is indeed a valid one, we still need
    to check if it is your turn.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了 Token 确实是有效的，我们仍然需要检查是否轮到你了。
- en: The `game.turn()` method will increment with each turn, so we have to take the
    modulo to check who's turn it is. Incrementing the turn, instead of toggling,
    will have the benefit of keeping a count on the number of turns that have been
    played, which will also be handy later, when we want to check whether the board
    is full, and end in a tie.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`game.turn()` 方法将在每个回合中递增，所以我们必须取模来检查是谁的回合。递增回合，而不是切换，将有一个好处，即可以记录已进行的回合数，这在稍后检查棋盘是否已满并结束平局时也会很有用。'
- en: Now we know which key to compare the token with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道要比较令牌的哪个键了。
- en: 'If your token does not match, then it is not your turn:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的令牌不匹配，那么就不是你的回合：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We added two more validation middleware for this route, move and token, which
    we can add to the validators library in `src/lib/validators.js`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个路由添加了两个额外的验证中间件，移动和令牌，我们可以将它们添加到 `src/lib/validators.js` 中的验证库中：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since we are sending the `400` error four times in the preceding code, let''s
    dry it up and reuse the same helper we had in `validators.js`, by extracting that
    helper into `src/lib/utils.js`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们发送了四次 `400` 错误，让我们简化代码并重用 `validators.js` 中的同一个辅助函数，通过将这个辅助函数提取到 `src/lib/utils.js`
    中：
- en: '[PRE40]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Don''t forget to update `src/lib/validators.js` to use this `utils`, by replacing
    the line with the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记更新 `src/lib/validators.js` 以使用这个 `utils`，通过替换以下行：
- en: '[PRE41]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can refactor the move route to make a move as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以重构移动路由，按照以下方式执行移动：
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Much cleaner, ain't it!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁多了，不是吗！
- en: For the remainder of the controller logic, we will use the `connect4.js` library
    (see Appendix), which implements the `makeMove()` and `checkForVictory()` methods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制器逻辑的其余部分，我们将使用 `connect4.js` 库（见附录），该库实现了 `makeMove()` 和 `checkForVictory()`
    方法。
- en: The `makeMove()` method will return a new board that results from the move,
    or return false if the move is invalid. Invalid here means that the column is
    already full, or the column is out of bounds. No turn validation is done here.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()` 方法将返回移动后的新棋盘，或者如果移动无效则返回 `false`。这里的无效意味着该列已满，或者列超出范围。这里没有进行回合验证。'
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One really important thing to point out is the line `game.markModified('board')`.
    Since we are using a 2D array for board, Mongoose is unable to auto-detect any
    changes. It can only do so with the basic field types. So if we do not explicitly
    mark the board as modified, it will not persist any changes when we call `game.save`!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别指出的一点是这一行代码 `game.markModified('board')`。由于我们使用二维数组作为棋盘，Mongoose无法自动检测任何更改。它只能对基本字段类型进行操作。因此，如果我们没有明确地将棋盘标记为已更改，那么在调用
    `game.save` 时，它将不会持久化任何更改！
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `checkForVictory()` method is a predicate that will check for victory based
    on the last move by the last player. We don't need to be checking the entire board
    each time. If the last move was a winning move, this method will return true;
    otherwise, it will return false.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForVictory()` 方法是一个谓词，它将根据最后一位玩家的最后一步移动来检查胜利。我们不需要每次都检查整个棋盘。如果最后一步是胜利的一步，这个方法将返回
    `true`；否则，它将返回 `false`。'
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It is a good idea to keep the controller logic as thin as possible and defer
    as much of the business logic as possible to the libraries or models. This decoupling
    and separation of concerns improves maintainability and testability, as well as
    modularity and reusability. Given the current architecture, it would be very easy
    to reuse the core components of our application in another Express project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 保持控制器逻辑尽可能简单，并将尽可能多的业务逻辑委托给库或模型是一个好主意。这种解耦和关注点的分离提高了可维护性、可测试性，以及模块化和可重用性。考虑到当前的架构，很容易在我们的Express项目中重用应用程序的核心组件。
- en: Testing for a tie
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试平局情况
- en: The only thing we haven't covered yet in our test suite is a tie game. We could
    create another test suite that would fill the entire board manually using 42 individual
    moves, but that would be too tedious. So let's fill the board programmatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试套件中，我们还没有涵盖到平局游戏。我们可以创建另一个测试套件，手动使用42个单独的步骤填满整个棋盘，但这会非常繁琐。所以，让我们通过程序来填充棋盘。
- en: That may sound easy, but it can be a bit tricky with JavaScript's asynchronous
    control flow. What would happen if we were to simply wrap the move request in
    a `for` loop?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很简单，但用JavaScript的异步控制流来做可能会有些棘手。如果我们简单地将移动请求包裹在一个 `for` 循环中，会发生什么？
- en: In short, it would be a mess. All requests would go out at the same time, and
    there will be no order. And how would you know that all moves are finished? You
    would need to maintain a global state counter that increments with each callback.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这将是一团糟。所有请求将同时发出，并且没有任何顺序。您如何知道所有移动都已完成？您需要维护一个全局状态计数器，每次回调时都会增加。
- en: This is where the `async` library becomes indispensable from Github.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么从Github来的`async`库变得不可或缺。
- en: Async is a utility module, which provides straightforward, powerful functions
    to work with asynchronous JavaScript.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Async是一个实用模块，它提供了直接且强大的函数来处理异步JavaScript。
- en: There is so much that you can do with async that would make your life easier;
    definitely a library that you should acquaint yourself with and add to your toolbox.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用async您可以做很多事情，这会让您的生活更轻松；绝对是一个您应该熟悉并添加到您的工具箱中的库。
- en: In our situation, we will use `async.series`, which allows us to send a flight
    of requests serially. Each request will wait until the previous request has returned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用`async.series`，它允许我们串行发送一系列请求。每个请求将等待先前的请求返回。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Run the functions in the tasks array in series, each one running once the previous
    function has completed. If any functions in the series pass an error to its callback,
    no more functions can be run, and callback is immediately called with the value
    of the error; otherwise, callback receives an array of results when tasks are
    completed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序运行任务数组中的函数，每个函数在先前的函数完成后运行一次。如果系列中的任何函数将其错误传递给回调，则无法运行更多函数，并且回调立即以错误值调用；否则，当任务完成时，回调接收一个结果数组。
- en: 'So to prepare our moves to be passed to `async.series`, we will use the following
    helper to create a thunk:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了准备传递给`async.series`的移动，我们将使用以下辅助函数来创建thunk：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A thunk is simply a subroutine; in this case calling the API to make a move,
    that is wrapped in a function, to be executed later. In this case, we create a
    thunk that accepts a callback parameter (as required by async), which notifies
    async that we're done.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Thunk只是一个子程序；在这种情况下，调用API进行移动，它被封装在一个函数中，稍后执行。在这种情况下，我们创建了一个接受回调参数的thunk（如async所需），它通知async我们已经完成。
- en: 'Now we can fill the board programmatically and check for the tie state:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过编程填充棋盘并检查平局状态：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! By now, all your tests should be passing and your game should
    be complete. You have mastered developing a robust and well-tested API and deal
    with validation using reusable middleware. Along the way you've also learned to
    use Redis for a simple queue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！到目前为止，所有您的测试都应该通过，您的游戏应该已经完成。您已经掌握了开发一个健壮且经过良好测试的API，并使用可重用的中间件处理验证。在这个过程中，您还学会了如何使用Redis进行简单的队列。
- en: Now you can deploy your API and you'll have your Connect4-as-a-Service available
    for the world to build their own connect 4 game upon, using their own favorite
    platform. Whether it is an HTML5 interface, a mobile app, or a command-line interface,
    it will all be powered by your backend!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以部署您的API，并且Connect4-as-a-Service将可供全世界使用，他们可以在自己的平台上构建自己的四子棋游戏。无论是HTML5界面、移动应用还是命令行界面，这一切都将由您的后端提供支持！
- en: In the next chapter, we'll be taking game development to another level—it will
    be a realtime massively multiplayer online game!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把游戏开发提升到另一个层次——它将是一个实时大规模多人在线游戏！
